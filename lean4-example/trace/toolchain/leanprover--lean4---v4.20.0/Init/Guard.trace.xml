<TracedFile path="src/lean/Init/Guard.lean" md5="c2131fe8629d31f38bb7d0fa67a6c9aa">
  <FileNode start="(1, 1)" end="(131, 16)">
    <ModuleHeaderNode start="(6, 1)" end="(11, 26)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(11, 26)">
        <ModuleImportNode start="(9, 1)" end="(9, 20)" module="Init.Tactics" path="src/lean/Init/Tactics.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 20)" leading="" trailing="&#10;" raw_val="Init.Tactics" val="Init.Tactics"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 17)" module="Init.Conv" path="src/lean/Init/Conv.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 17)" leading="" trailing="&#10;" raw_val="Init.Conv" val="Init.Conv"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 26)" module="Init.NotationExtra" path="src/lean/Init/NotationExtra.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 26)" leading="" trailing="&#10;&#10;" raw_val="Init.NotationExtra" val="Init.NotationExtra"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandNamespaceNode start="(13, 1)" end="(13, 22)" name="Lean.Parser">
      <AtomNode start="(13, 1)" end="(13, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(13, 11)" end="(13, 22)" leading="" trailing="&#10;&#10;" raw_val="Lean.Parser" val="Lean.Parser"/>
    </CommandNamespaceNode>
    <OtherNode start="(15, 1)" end="(16, 23)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(15, 1)" end="(15, 54)">
        <CommandDoccommentNode start="(15, 1)" end="(15, 54)" comment="Reducible defeq matching for `guard_hyp` types -/">
          <AtomNode start="(15, 1)" end="(15, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(15, 5)" end="(15, 54)" leading="" trailing="&#10;" val="Reducible defeq matching for `guard_hyp` types -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(16, 1)" end="(16, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(16, 8)" end="(16, 14)" leading="" trailing=" " raw_val="colonR" val="colonR"/>
      <AtomNode start="(16, 15)" end="(16, 17)" leading="" trailing=" " val=":="/>
      <NullNode start="(16, 18)" end="(16, 23)">
        <OtherNode start="(16, 18)" end="(16, 23)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(16, 18)" end="(16, 23)" kind="str">
            <AtomNode start="(16, 18)" end="(16, 23)" leading="" trailing="&#10;" val="&amp;quot; : &amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(17, 1)" end="(18, 24)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(17, 1)" end="(17, 65)">
        <CommandDoccommentNode start="(17, 1)" end="(17, 65)" comment="Default-reducibility defeq matching for `guard_hyp` types -/">
          <AtomNode start="(17, 1)" end="(17, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(17, 5)" end="(17, 65)" leading="" trailing="&#10;" val="Default-reducibility defeq matching for `guard_hyp` types -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(18, 1)" end="(18, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(18, 8)" end="(18, 14)" leading="" trailing=" " raw_val="colonD" val="colonD"/>
      <AtomNode start="(18, 15)" end="(18, 17)" leading="" trailing=" " val=":="/>
      <NullNode start="(18, 18)" end="(18, 24)">
        <OtherNode start="(18, 18)" end="(18, 24)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(18, 18)" end="(18, 24)" kind="str">
            <AtomNode start="(18, 18)" end="(18, 24)" leading="" trailing="&#10;" val="&amp;quot; :~ &amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(19, 1)" end="(20, 24)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(19, 1)" end="(19, 48)">
        <CommandDoccommentNode start="(19, 1)" end="(19, 48)" comment="Syntactic matching for `guard_hyp` types -/">
          <AtomNode start="(19, 1)" end="(19, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(19, 5)" end="(19, 48)" leading="" trailing="&#10;" val="Syntactic matching for `guard_hyp` types -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(20, 1)" end="(20, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(20, 8)" end="(20, 14)" leading="" trailing=" " raw_val="colonS" val="colonS"/>
      <AtomNode start="(20, 15)" end="(20, 17)" leading="" trailing=" " val=":="/>
      <NullNode start="(20, 18)" end="(20, 24)">
        <OtherNode start="(20, 18)" end="(20, 24)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(20, 18)" end="(20, 24)" kind="str">
            <AtomNode start="(20, 18)" end="(20, 24)" leading="" trailing="&#10;" val="&amp;quot; :ₛ &amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(21, 1)" end="(22, 24)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(21, 1)" end="(21, 47)">
        <CommandDoccommentNode start="(21, 1)" end="(21, 47)" comment="Alpha-eq matching for `guard_hyp` types -/">
          <AtomNode start="(21, 1)" end="(21, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(21, 5)" end="(21, 47)" leading="" trailing="&#10;" val="Alpha-eq matching for `guard_hyp` types -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(22, 1)" end="(22, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(22, 8)" end="(22, 14)" leading="" trailing=" " raw_val="colonA" val="colonA"/>
      <AtomNode start="(22, 15)" end="(22, 17)" leading="" trailing=" " val=":="/>
      <NullNode start="(22, 18)" end="(22, 24)">
        <OtherNode start="(22, 18)" end="(22, 24)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(22, 18)" end="(22, 24)" kind="str">
            <AtomNode start="(22, 18)" end="(22, 24)" leading="" trailing="&#10;" val="&amp;quot; :ₐ &amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(23, 1)" end="(24, 56)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(23, 1)" end="(23, 68)">
        <CommandDoccommentNode start="(23, 1)" end="(23, 68)" comment="The `guard_hyp` type specifier, one of `:`, `:~`, `:ₛ`, `:ₐ` -/">
          <AtomNode start="(23, 1)" end="(23, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(23, 5)" end="(23, 68)" leading="" trailing="&#10;" val="The `guard_hyp` type specifier, one of `:`, `:~`, `:ₛ`, `:ₐ` -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(24, 1)" end="(24, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(24, 8)" end="(24, 13)" leading="" trailing=" " raw_val="colon" val="colon"/>
      <AtomNode start="(24, 14)" end="(24, 16)" leading="" trailing=" " val=":="/>
      <NullNode start="(24, 17)" end="(24, 56)">
        <OtherNode start="(24, 17)" end="(24, 56)" kind="«stx_&amp;lt;|&amp;gt;_»">
          <OtherNode start="(24, 17)" end="(24, 23)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(24, 17)" end="(24, 23)" leading="" trailing=" " raw_val="colonR" val="colonR" full_name="Lean.Parser.colonR" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(16, 8)" def_end="(16, 14)"/>
            <NullNode/>
          </OtherNode>
          <AtomNode start="(24, 24)" end="(24, 27)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
          <OtherNode start="(24, 28)" end="(24, 56)" kind="«stx_&amp;lt;|&amp;gt;_»">
            <OtherNode start="(24, 28)" end="(24, 34)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(24, 28)" end="(24, 34)" leading="" trailing=" " raw_val="colonD" val="colonD" full_name="Lean.Parser.colonD" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(18, 8)" def_end="(18, 14)"/>
              <NullNode/>
            </OtherNode>
            <AtomNode start="(24, 35)" end="(24, 38)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
            <OtherNode start="(24, 39)" end="(24, 56)" kind="«stx_&amp;lt;|&amp;gt;_»">
              <OtherNode start="(24, 39)" end="(24, 45)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(24, 39)" end="(24, 45)" leading="" trailing=" " raw_val="colonS" val="colonS" full_name="Lean.Parser.colonS" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(20, 8)" def_end="(20, 14)"/>
                <NullNode/>
              </OtherNode>
              <AtomNode start="(24, 46)" end="(24, 49)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
              <OtherNode start="(24, 50)" end="(24, 56)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(24, 50)" end="(24, 56)" leading="" trailing="&#10;&#10;" raw_val="colonA" val="colonA" full_name="Lean.Parser.colonA" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(22, 8)" def_end="(22, 14)"/>
                <NullNode/>
              </OtherNode>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(26, 1)" end="(27, 26)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(26, 1)" end="(26, 55)">
        <CommandDoccommentNode start="(26, 1)" end="(26, 55)" comment="Reducible defeq matching for `guard_hyp` values -/">
          <AtomNode start="(26, 1)" end="(26, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(26, 5)" end="(26, 55)" leading="" trailing="&#10;" val="Reducible defeq matching for `guard_hyp` values -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(27, 1)" end="(27, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(27, 8)" end="(27, 16)" leading="" trailing=" " raw_val="colonEqR" val="colonEqR"/>
      <AtomNode start="(27, 17)" end="(27, 19)" leading="" trailing=" " val=":="/>
      <NullNode start="(27, 20)" end="(27, 26)">
        <OtherNode start="(27, 20)" end="(27, 26)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(27, 20)" end="(27, 26)" kind="str">
            <AtomNode start="(27, 20)" end="(27, 26)" leading="" trailing="&#10;" val="&amp;quot; := &amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(28, 1)" end="(29, 27)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(28, 1)" end="(28, 66)">
        <CommandDoccommentNode start="(28, 1)" end="(28, 66)" comment="Default-reducibility defeq matching for `guard_hyp` values -/">
          <AtomNode start="(28, 1)" end="(28, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(28, 5)" end="(28, 66)" leading="" trailing="&#10;" val="Default-reducibility defeq matching for `guard_hyp` values -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(29, 1)" end="(29, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(29, 8)" end="(29, 16)" leading="" trailing=" " raw_val="colonEqD" val="colonEqD"/>
      <AtomNode start="(29, 17)" end="(29, 19)" leading="" trailing=" " val=":="/>
      <NullNode start="(29, 20)" end="(29, 27)">
        <OtherNode start="(29, 20)" end="(29, 27)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(29, 20)" end="(29, 27)" kind="str">
            <AtomNode start="(29, 20)" end="(29, 27)" leading="" trailing="&#10;" val="&amp;quot; :=~ &amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(30, 1)" end="(31, 27)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(30, 1)" end="(30, 49)">
        <CommandDoccommentNode start="(30, 1)" end="(30, 49)" comment="Syntactic matching for `guard_hyp` values -/">
          <AtomNode start="(30, 1)" end="(30, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(30, 5)" end="(30, 49)" leading="" trailing="&#10;" val="Syntactic matching for `guard_hyp` values -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(31, 1)" end="(31, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(31, 8)" end="(31, 16)" leading="" trailing=" " raw_val="colonEqS" val="colonEqS"/>
      <AtomNode start="(31, 17)" end="(31, 19)" leading="" trailing=" " val=":="/>
      <NullNode start="(31, 20)" end="(31, 27)">
        <OtherNode start="(31, 20)" end="(31, 27)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(31, 20)" end="(31, 27)" kind="str">
            <AtomNode start="(31, 20)" end="(31, 27)" leading="" trailing="&#10;" val="&amp;quot; :=ₛ &amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(32, 1)" end="(33, 27)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(32, 1)" end="(32, 48)">
        <CommandDoccommentNode start="(32, 1)" end="(32, 48)" comment="Alpha-eq matching for `guard_hyp` values -/">
          <AtomNode start="(32, 1)" end="(32, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(32, 5)" end="(32, 48)" leading="" trailing="&#10;" val="Alpha-eq matching for `guard_hyp` values -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(33, 1)" end="(33, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(33, 8)" end="(33, 16)" leading="" trailing=" " raw_val="colonEqA" val="colonEqA"/>
      <AtomNode start="(33, 17)" end="(33, 19)" leading="" trailing=" " val=":="/>
      <NullNode start="(33, 20)" end="(33, 27)">
        <OtherNode start="(33, 20)" end="(33, 27)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(33, 20)" end="(33, 27)" kind="str">
            <AtomNode start="(33, 20)" end="(33, 27)" leading="" trailing="&#10;" val="&amp;quot; :=ₐ &amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(34, 1)" end="(35, 66)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(34, 1)" end="(34, 73)">
        <CommandDoccommentNode start="(34, 1)" end="(34, 73)" comment="The `guard_hyp` value specifier, one of `:=`, `:=~`, `:=ₛ`, `:=ₐ` -/">
          <AtomNode start="(34, 1)" end="(34, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(34, 5)" end="(34, 73)" leading="" trailing="&#10;" val="The `guard_hyp` value specifier, one of `:=`, `:=~`, `:=ₛ`, `:=ₐ` -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(35, 1)" end="(35, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(35, 8)" end="(35, 15)" leading="" trailing=" " raw_val="colonEq" val="colonEq"/>
      <AtomNode start="(35, 16)" end="(35, 18)" leading="" trailing=" " val=":="/>
      <NullNode start="(35, 19)" end="(35, 66)">
        <OtherNode start="(35, 19)" end="(35, 66)" kind="«stx_&amp;lt;|&amp;gt;_»">
          <OtherNode start="(35, 19)" end="(35, 27)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(35, 19)" end="(35, 27)" leading="" trailing=" " raw_val="colonEqR" val="colonEqR" full_name="Lean.Parser.colonEqR" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(27, 8)" def_end="(27, 16)"/>
            <NullNode/>
          </OtherNode>
          <AtomNode start="(35, 28)" end="(35, 31)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
          <OtherNode start="(35, 32)" end="(35, 66)" kind="«stx_&amp;lt;|&amp;gt;_»">
            <OtherNode start="(35, 32)" end="(35, 40)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(35, 32)" end="(35, 40)" leading="" trailing=" " raw_val="colonEqD" val="colonEqD" full_name="Lean.Parser.colonEqD" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(29, 8)" def_end="(29, 16)"/>
              <NullNode/>
            </OtherNode>
            <AtomNode start="(35, 41)" end="(35, 44)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
            <OtherNode start="(35, 45)" end="(35, 66)" kind="«stx_&amp;lt;|&amp;gt;_»">
              <OtherNode start="(35, 45)" end="(35, 53)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(35, 45)" end="(35, 53)" leading="" trailing=" " raw_val="colonEqS" val="colonEqS" full_name="Lean.Parser.colonEqS" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(31, 8)" def_end="(31, 16)"/>
                <NullNode/>
              </OtherNode>
              <AtomNode start="(35, 54)" end="(35, 57)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
              <OtherNode start="(35, 58)" end="(35, 66)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(35, 58)" end="(35, 66)" leading="" trailing="&#10;&#10;" raw_val="colonEqA" val="colonEqA" full_name="Lean.Parser.colonEqA" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(33, 8)" def_end="(33, 16)"/>
                <NullNode/>
              </OtherNode>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(37, 1)" end="(38, 23)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(37, 1)" end="(37, 49)">
        <CommandDoccommentNode start="(37, 1)" end="(37, 49)" comment="Reducible defeq matching for `guard_expr` -/">
          <AtomNode start="(37, 1)" end="(37, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(37, 5)" end="(37, 49)" leading="" trailing="&#10;" val="Reducible defeq matching for `guard_expr` -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(38, 1)" end="(38, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(38, 8)" end="(38, 14)" leading="" trailing=" " raw_val="equalR" val="equalR"/>
      <AtomNode start="(38, 15)" end="(38, 17)" leading="" trailing=" " val=":="/>
      <NullNode start="(38, 18)" end="(38, 23)">
        <OtherNode start="(38, 18)" end="(38, 23)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(38, 18)" end="(38, 23)" kind="str">
            <AtomNode start="(38, 18)" end="(38, 23)" leading="" trailing="&#10;" val="&amp;quot; = &amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(39, 1)" end="(40, 24)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(39, 1)" end="(39, 60)">
        <CommandDoccommentNode start="(39, 1)" end="(39, 60)" comment="Default-reducibility defeq matching for `guard_expr` -/">
          <AtomNode start="(39, 1)" end="(39, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(39, 5)" end="(39, 60)" leading="" trailing="&#10;" val="Default-reducibility defeq matching for `guard_expr` -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(40, 1)" end="(40, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(40, 8)" end="(40, 14)" leading="" trailing=" " raw_val="equalD" val="equalD"/>
      <AtomNode start="(40, 15)" end="(40, 17)" leading="" trailing=" " val=":="/>
      <NullNode start="(40, 18)" end="(40, 24)">
        <OtherNode start="(40, 18)" end="(40, 24)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(40, 18)" end="(40, 24)" kind="str">
            <AtomNode start="(40, 18)" end="(40, 24)" leading="" trailing="&#10;" val="&amp;quot; =~ &amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(41, 1)" end="(42, 24)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(41, 1)" end="(41, 43)">
        <CommandDoccommentNode start="(41, 1)" end="(41, 43)" comment="Syntactic matching for `guard_expr` -/">
          <AtomNode start="(41, 1)" end="(41, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(41, 5)" end="(41, 43)" leading="" trailing="&#10;" val="Syntactic matching for `guard_expr` -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(42, 1)" end="(42, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(42, 8)" end="(42, 14)" leading="" trailing=" " raw_val="equalS" val="equalS"/>
      <AtomNode start="(42, 15)" end="(42, 17)" leading="" trailing=" " val=":="/>
      <NullNode start="(42, 18)" end="(42, 24)">
        <OtherNode start="(42, 18)" end="(42, 24)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(42, 18)" end="(42, 24)" kind="str">
            <AtomNode start="(42, 18)" end="(42, 24)" leading="" trailing="&#10;" val="&amp;quot; =ₛ &amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(43, 1)" end="(44, 24)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(43, 1)" end="(43, 42)">
        <CommandDoccommentNode start="(43, 1)" end="(43, 42)" comment="Alpha-eq matching for `guard_expr` -/">
          <AtomNode start="(43, 1)" end="(43, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(43, 5)" end="(43, 42)" leading="" trailing="&#10;" val="Alpha-eq matching for `guard_expr` -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(44, 1)" end="(44, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(44, 8)" end="(44, 14)" leading="" trailing=" " raw_val="equalA" val="equalA"/>
      <AtomNode start="(44, 15)" end="(44, 17)" leading="" trailing=" " val=":="/>
      <NullNode start="(44, 18)" end="(44, 24)">
        <OtherNode start="(44, 18)" end="(44, 24)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(44, 18)" end="(44, 24)" kind="str">
            <AtomNode start="(44, 18)" end="(44, 24)" leading="" trailing="&#10;" val="&amp;quot; =ₐ &amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(45, 1)" end="(46, 56)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(45, 1)" end="(45, 73)">
        <CommandDoccommentNode start="(45, 1)" end="(45, 73)" comment="The `guard_expr` matching specifier, one of `=`, `=~`, `=ₛ`, `=ₐ` -/">
          <AtomNode start="(45, 1)" end="(45, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(45, 5)" end="(45, 73)" leading="" trailing="&#10;" val="The `guard_expr` matching specifier, one of `=`, `=~`, `=ₛ`, `=ₐ` -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(46, 1)" end="(46, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(46, 8)" end="(46, 13)" leading="" trailing=" " raw_val="equal" val="equal"/>
      <AtomNode start="(46, 14)" end="(46, 16)" leading="" trailing=" " val=":="/>
      <NullNode start="(46, 17)" end="(46, 56)">
        <OtherNode start="(46, 17)" end="(46, 56)" kind="«stx_&amp;lt;|&amp;gt;_»">
          <OtherNode start="(46, 17)" end="(46, 23)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(46, 17)" end="(46, 23)" leading="" trailing=" " raw_val="equalR" val="equalR" full_name="Lean.Parser.equalR" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(38, 8)" def_end="(38, 14)"/>
            <NullNode/>
          </OtherNode>
          <AtomNode start="(46, 24)" end="(46, 27)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
          <OtherNode start="(46, 28)" end="(46, 56)" kind="«stx_&amp;lt;|&amp;gt;_»">
            <OtherNode start="(46, 28)" end="(46, 34)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(46, 28)" end="(46, 34)" leading="" trailing=" " raw_val="equalD" val="equalD" full_name="Lean.Parser.equalD" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(40, 8)" def_end="(40, 14)"/>
              <NullNode/>
            </OtherNode>
            <AtomNode start="(46, 35)" end="(46, 38)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
            <OtherNode start="(46, 39)" end="(46, 56)" kind="«stx_&amp;lt;|&amp;gt;_»">
              <OtherNode start="(46, 39)" end="(46, 45)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(46, 39)" end="(46, 45)" leading="" trailing=" " raw_val="equalS" val="equalS" full_name="Lean.Parser.equalS" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(42, 8)" def_end="(42, 14)"/>
                <NullNode/>
              </OtherNode>
              <AtomNode start="(46, 46)" end="(46, 49)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
              <OtherNode start="(46, 50)" end="(46, 56)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(46, 50)" end="(46, 56)" leading="" trailing="&#10;&#10;" raw_val="equalA" val="equalA" full_name="Lean.Parser.equalA" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(44, 8)" def_end="(44, 14)"/>
                <NullNode/>
              </OtherNode>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <CommandNamespaceNode start="(48, 1)" end="(48, 17)" name="Tactic">
      <AtomNode start="(48, 1)" end="(48, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(48, 11)" end="(48, 17)" leading="" trailing="&#10;&#10;" raw_val="Tactic" val="Tactic"/>
    </CommandNamespaceNode>
    <OtherNode start="(50, 1)" end="(61, 69)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(50, 1)" end="(60, 3)">
        <CommandDoccommentNode start="(50, 1)" end="(60, 3)" comment="Tactic to check equality of two expressions.&#10;* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.&#10;* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.&#10;* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.&#10;* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.&#10;&#10;Both `e` and `e'` are elaborated then have their metavariables instantiated before the equality&#10;check. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are&#10;processed, which helps with default instance handling.&#10;-/">
          <AtomNode start="(50, 1)" end="(50, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(51, 1)" end="(60, 3)" leading="" trailing="&#10;" val="Tactic to check equality of two expressions.&#10;* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.&#10;* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.&#10;* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.&#10;* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.&#10;&#10;Both `e` and `e'` are elaborated then have their metavariables instantiated before the equality&#10;check. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are&#10;processed, which helps with default instance handling.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(61, 1)" end="(61, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(61, 8)" end="(61, 27)">
        <OtherNode start="(61, 8)" end="(61, 27)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(61, 8)" end="(61, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(61, 9)" end="(61, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(61, 14)" end="(61, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(61, 17)" end="(61, 26)" leading="" trailing="" raw_val="guardExpr" val="guardExpr"/>
          <AtomNode start="(61, 26)" end="(61, 27)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(61, 28)" end="(61, 60)">
        <OtherNode start="(61, 28)" end="(61, 41)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(61, 28)" end="(61, 41)" kind="str">
            <AtomNode start="(61, 28)" end="(61, 41)" leading="" trailing=" " val="&amp;quot;guard_expr &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(61, 42)" end="(61, 49)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(61, 42)" end="(61, 46)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
          <NullNode start="(61, 46)" end="(61, 49)">
            <OtherNode start="(61, 46)" end="(61, 49)" kind="Lean.Parser.precedence">
              <AtomNode start="(61, 46)" end="(61, 47)" leading="" trailing="" val=":"/>
              <OtherNode start="(61, 47)" end="(61, 49)" kind="num">
                <AtomNode start="(61, 47)" end="(61, 49)" leading="" trailing=" " val="51"/>
              </OtherNode>
            </OtherNode>
          </NullNode>
        </OtherNode>
        <OtherNode start="(61, 50)" end="(61, 55)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(61, 50)" end="(61, 55)" leading="" trailing=" " raw_val="equal" val="equal" full_name="Lean.Parser.equal" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(46, 8)" def_end="(46, 13)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(61, 56)" end="(61, 60)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(61, 56)" end="(61, 60)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(61, 61)" end="(61, 62)" leading="" trailing=" " val=":"/>
      <IdentNode start="(61, 63)" end="(61, 69)" leading="" trailing="&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(62, 1)" end="(63, 71)" kind="Lean.Parser.Command.syntax">
      <NullNode/>
      <NullNode start="(62, 1)" end="(62, 25)">
        <OtherNode start="(62, 1)" end="(62, 25)" kind="Lean.Parser.Term.attributes">
          <AtomNode start="(62, 1)" end="(62, 3)" leading="" trailing="" val="@["/>
          <NullNode start="(62, 3)" end="(62, 24)">
            <OtherNode start="(62, 3)" end="(62, 24)" kind="Lean.Parser.Term.attrInstance">
              <TermAttrkindNode>
                <NullNode/>
              </TermAttrkindNode>
              <OtherNode start="(62, 3)" end="(62, 24)" kind="Lean.Parser.Attr.simple">
                <IdentNode start="(62, 3)" end="(62, 14)" leading="" trailing=" " raw_val="inherit_doc" val="inherit_doc"/>
                <NullNode start="(62, 15)" end="(62, 24)">
                  <IdentNode start="(62, 15)" end="(62, 24)" leading="" trailing="" raw_val="guardExpr" val="guardExpr" full_name="Lean.Parser.Tactic.guardExpr" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(61, 17)" def_end="(61, 26)"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(62, 24)" end="(62, 25)" leading="" trailing="&#10;" val="]"/>
        </OtherNode>
      </NullNode>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(63, 1)" end="(63, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(63, 8)" end="(63, 31)">
        <OtherNode start="(63, 8)" end="(63, 31)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(63, 8)" end="(63, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(63, 9)" end="(63, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(63, 14)" end="(63, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(63, 17)" end="(63, 30)" leading="" trailing="" raw_val="guardExprConv" val="guardExprConv"/>
          <AtomNode start="(63, 30)" end="(63, 31)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(63, 32)" end="(63, 64)">
        <OtherNode start="(63, 32)" end="(63, 45)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(63, 32)" end="(63, 45)" kind="str">
            <AtomNode start="(63, 32)" end="(63, 45)" leading="" trailing=" " val="&amp;quot;guard_expr &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(63, 46)" end="(63, 53)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(63, 46)" end="(63, 50)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
          <NullNode start="(63, 50)" end="(63, 53)">
            <OtherNode start="(63, 50)" end="(63, 53)" kind="Lean.Parser.precedence">
              <AtomNode start="(63, 50)" end="(63, 51)" leading="" trailing="" val=":"/>
              <OtherNode start="(63, 51)" end="(63, 53)" kind="num">
                <AtomNode start="(63, 51)" end="(63, 53)" leading="" trailing=" " val="51"/>
              </OtherNode>
            </OtherNode>
          </NullNode>
        </OtherNode>
        <OtherNode start="(63, 54)" end="(63, 59)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(63, 54)" end="(63, 59)" leading="" trailing=" " raw_val="equal" val="equal" full_name="Lean.Parser.equal" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(46, 8)" def_end="(46, 13)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(63, 60)" end="(63, 64)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(63, 60)" end="(63, 64)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(63, 65)" end="(63, 66)" leading="" trailing=" " val=":"/>
      <IdentNode start="(63, 67)" end="(63, 71)" leading="" trailing="&#10;&#10;" raw_val="conv" val="conv" full_name="Lean.Parser.Category.conv" mod_name="Init.Conv" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Conv.lean"/>
    </OtherNode>
    <OtherNode start="(65, 1)" end="(75, 65)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(65, 1)" end="(74, 3)">
        <CommandDoccommentNode start="(65, 1)" end="(74, 3)" comment="Tactic to check that the target agrees with a given expression.&#10;* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.&#10;* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.&#10;* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.&#10;* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.&#10;&#10;The term `e` is elaborated with the type of the goal as the expected type, which is mostly&#10;useful within `conv` mode.&#10;-/">
          <AtomNode start="(65, 1)" end="(65, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(66, 1)" end="(74, 3)" leading="" trailing="&#10;" val="Tactic to check that the target agrees with a given expression.&#10;* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.&#10;* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.&#10;* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.&#10;* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.&#10;&#10;The term `e` is elaborated with the type of the goal as the expected type, which is mostly&#10;useful within `conv` mode.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(75, 1)" end="(75, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(75, 8)" end="(75, 29)">
        <OtherNode start="(75, 8)" end="(75, 29)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(75, 8)" end="(75, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(75, 9)" end="(75, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(75, 14)" end="(75, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(75, 17)" end="(75, 28)" leading="" trailing="" raw_val="guardTarget" val="guardTarget"/>
          <AtomNode start="(75, 28)" end="(75, 29)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(75, 30)" end="(75, 56)">
        <OtherNode start="(75, 30)" end="(75, 45)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(75, 30)" end="(75, 45)" kind="str">
            <AtomNode start="(75, 30)" end="(75, 45)" leading="" trailing=" " val="&amp;quot;guard_target &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(75, 46)" end="(75, 51)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(75, 46)" end="(75, 51)" leading="" trailing=" " raw_val="equal" val="equal" full_name="Lean.Parser.equal" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(46, 8)" def_end="(46, 13)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(75, 52)" end="(75, 56)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(75, 52)" end="(75, 56)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(75, 57)" end="(75, 58)" leading="" trailing=" " val=":"/>
      <IdentNode start="(75, 59)" end="(75, 65)" leading="" trailing="&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(76, 1)" end="(77, 67)" kind="Lean.Parser.Command.syntax">
      <NullNode/>
      <NullNode start="(76, 1)" end="(76, 27)">
        <OtherNode start="(76, 1)" end="(76, 27)" kind="Lean.Parser.Term.attributes">
          <AtomNode start="(76, 1)" end="(76, 3)" leading="" trailing="" val="@["/>
          <NullNode start="(76, 3)" end="(76, 26)">
            <OtherNode start="(76, 3)" end="(76, 26)" kind="Lean.Parser.Term.attrInstance">
              <TermAttrkindNode>
                <NullNode/>
              </TermAttrkindNode>
              <OtherNode start="(76, 3)" end="(76, 26)" kind="Lean.Parser.Attr.simple">
                <IdentNode start="(76, 3)" end="(76, 14)" leading="" trailing=" " raw_val="inherit_doc" val="inherit_doc"/>
                <NullNode start="(76, 15)" end="(76, 26)">
                  <IdentNode start="(76, 15)" end="(76, 26)" leading="" trailing="" raw_val="guardTarget" val="guardTarget" full_name="Lean.Parser.Tactic.guardTarget" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(75, 17)" def_end="(75, 28)"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(76, 26)" end="(76, 27)" leading="" trailing="&#10;" val="]"/>
        </OtherNode>
      </NullNode>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(77, 1)" end="(77, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(77, 8)" end="(77, 33)">
        <OtherNode start="(77, 8)" end="(77, 33)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(77, 8)" end="(77, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(77, 9)" end="(77, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(77, 14)" end="(77, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(77, 17)" end="(77, 32)" leading="" trailing="" raw_val="guardTargetConv" val="guardTargetConv"/>
          <AtomNode start="(77, 32)" end="(77, 33)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(77, 34)" end="(77, 60)">
        <OtherNode start="(77, 34)" end="(77, 49)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(77, 34)" end="(77, 49)" kind="str">
            <AtomNode start="(77, 34)" end="(77, 49)" leading="" trailing=" " val="&amp;quot;guard_target &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(77, 50)" end="(77, 55)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(77, 50)" end="(77, 55)" leading="" trailing=" " raw_val="equal" val="equal" full_name="Lean.Parser.equal" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(46, 8)" def_end="(46, 13)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(77, 56)" end="(77, 60)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(77, 56)" end="(77, 60)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(77, 61)" end="(77, 62)" leading="" trailing=" " val=":"/>
      <IdentNode start="(77, 63)" end="(77, 67)" leading="" trailing="&#10;&#10;" raw_val="conv" val="conv" full_name="Lean.Parser.Category.conv" mod_name="Init.Conv" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Conv.lean"/>
    </OtherNode>
    <OtherNode start="(79, 1)" end="(94, 63)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(79, 1)" end="(92, 3)">
        <CommandDoccommentNode start="(79, 1)" end="(92, 3)" comment="Tactic to check that a named hypothesis has a given type and/or value.&#10;&#10;* `guard_hyp h : t` checks the type up to reducible defeq,&#10;* `guard_hyp h :~ t` checks the type up to default defeq,&#10;* `guard_hyp h :ₛ t` checks the type up to syntactic equality,&#10;* `guard_hyp h :ₐ t` checks the type up to alpha equality.&#10;* `guard_hyp h := v` checks value up to reducible defeq,&#10;* `guard_hyp h :=~ v` checks value up to default defeq,&#10;* `guard_hyp h :=ₛ v` checks value up to syntactic equality,&#10;* `guard_hyp h :=ₐ v` checks the value up to alpha equality.&#10;&#10;The value `v` is elaborated using the type of `h` as the expected type.&#10;-/">
          <AtomNode start="(79, 1)" end="(79, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(80, 1)" end="(92, 3)" leading="" trailing="&#10;" val="Tactic to check that a named hypothesis has a given type and/or value.&#10;&#10;* `guard_hyp h : t` checks the type up to reducible defeq,&#10;* `guard_hyp h :~ t` checks the type up to default defeq,&#10;* `guard_hyp h :ₛ t` checks the type up to syntactic equality,&#10;* `guard_hyp h :ₐ t` checks the type up to alpha equality.&#10;* `guard_hyp h := v` checks value up to reducible defeq,&#10;* `guard_hyp h :=~ v` checks value up to default defeq,&#10;* `guard_hyp h :=ₛ v` checks value up to syntactic equality,&#10;* `guard_hyp h :=ₐ v` checks the value up to alpha equality.&#10;&#10;The value `v` is elaborated using the type of `h` as the expected type.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(93, 1)" end="(93, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(93, 8)" end="(93, 26)">
        <OtherNode start="(93, 8)" end="(93, 26)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(93, 8)" end="(93, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(93, 9)" end="(93, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(93, 14)" end="(93, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(93, 17)" end="(93, 25)" leading="" trailing="" raw_val="guardHyp" val="guardHyp"/>
          <AtomNode start="(93, 25)" end="(93, 26)" leading="" trailing="&#10;  " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(94, 3)" end="(94, 54)">
        <OtherNode start="(94, 3)" end="(94, 15)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(94, 3)" end="(94, 15)" kind="str">
            <AtomNode start="(94, 3)" end="(94, 15)" leading="" trailing=" " val="&amp;quot;guard_hyp &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(94, 16)" end="(94, 24)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(94, 16)" end="(94, 20)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
          <NullNode start="(94, 20)" end="(94, 24)">
            <OtherNode start="(94, 20)" end="(94, 24)" kind="Lean.Parser.precedence">
              <AtomNode start="(94, 20)" end="(94, 21)" leading="" trailing="" val=":"/>
              <OtherNode start="(94, 21)" end="(94, 24)" kind="precMax">
                <AtomNode start="(94, 21)" end="(94, 24)" leading="" trailing=" " val="max"/>
              </OtherNode>
            </OtherNode>
          </NullNode>
        </OtherNode>
        <OtherNode start="(94, 25)" end="(94, 38)" kind="stx_?">
          <OtherNode start="(94, 25)" end="(94, 37)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(94, 25)" end="(94, 26)" leading="" trailing="" val="("/>
            <NullNode start="(94, 26)" end="(94, 36)">
              <OtherNode start="(94, 26)" end="(94, 31)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(94, 26)" end="(94, 31)" leading="" trailing=" " raw_val="colon" val="colon" full_name="Lean.Parser.colon" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(24, 8)" def_end="(24, 13)"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(94, 32)" end="(94, 36)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(94, 32)" end="(94, 36)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(94, 36)" end="(94, 37)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(94, 37)" end="(94, 38)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(94, 39)" end="(94, 54)" kind="stx_?">
          <OtherNode start="(94, 39)" end="(94, 53)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(94, 39)" end="(94, 40)" leading="" trailing="" val="("/>
            <NullNode start="(94, 40)" end="(94, 52)">
              <OtherNode start="(94, 40)" end="(94, 47)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(94, 40)" end="(94, 47)" leading="" trailing=" " raw_val="colonEq" val="colonEq" full_name="Lean.Parser.colonEq" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(35, 8)" def_end="(35, 15)"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(94, 48)" end="(94, 52)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(94, 48)" end="(94, 52)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(94, 52)" end="(94, 53)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(94, 53)" end="(94, 54)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(94, 55)" end="(94, 56)" leading="" trailing=" " val=":"/>
      <IdentNode start="(94, 57)" end="(94, 63)" leading="" trailing="&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(95, 1)" end="(96, 61)" kind="Lean.Parser.Command.syntax">
      <NullNode/>
      <NullNode start="(95, 1)" end="(95, 24)">
        <OtherNode start="(95, 1)" end="(95, 24)" kind="Lean.Parser.Term.attributes">
          <AtomNode start="(95, 1)" end="(95, 3)" leading="" trailing="" val="@["/>
          <NullNode start="(95, 3)" end="(95, 23)">
            <OtherNode start="(95, 3)" end="(95, 23)" kind="Lean.Parser.Term.attrInstance">
              <TermAttrkindNode>
                <NullNode/>
              </TermAttrkindNode>
              <OtherNode start="(95, 3)" end="(95, 23)" kind="Lean.Parser.Attr.simple">
                <IdentNode start="(95, 3)" end="(95, 14)" leading="" trailing=" " raw_val="inherit_doc" val="inherit_doc"/>
                <NullNode start="(95, 15)" end="(95, 23)">
                  <IdentNode start="(95, 15)" end="(95, 23)" leading="" trailing="" raw_val="guardHyp" val="guardHyp" full_name="Lean.Parser.Tactic.guardHyp" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(93, 17)" def_end="(93, 25)"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(95, 23)" end="(95, 24)" leading="" trailing=" " val="]"/>
        </OtherNode>
      </NullNode>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(95, 25)" end="(95, 31)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(95, 32)" end="(95, 54)">
        <OtherNode start="(95, 32)" end="(95, 54)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(95, 32)" end="(95, 33)" leading="" trailing="" val="("/>
          <AtomNode start="(95, 33)" end="(95, 37)" leading="" trailing=" " val="name"/>
          <AtomNode start="(95, 38)" end="(95, 40)" leading="" trailing=" " val=":="/>
          <IdentNode start="(95, 41)" end="(95, 53)" leading="" trailing="" raw_val="guardHypConv" val="guardHypConv"/>
          <AtomNode start="(95, 53)" end="(95, 54)" leading="" trailing="&#10;  " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(96, 3)" end="(96, 54)">
        <OtherNode start="(96, 3)" end="(96, 15)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(96, 3)" end="(96, 15)" kind="str">
            <AtomNode start="(96, 3)" end="(96, 15)" leading="" trailing=" " val="&amp;quot;guard_hyp &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(96, 16)" end="(96, 24)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(96, 16)" end="(96, 20)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
          <NullNode start="(96, 20)" end="(96, 24)">
            <OtherNode start="(96, 20)" end="(96, 24)" kind="Lean.Parser.precedence">
              <AtomNode start="(96, 20)" end="(96, 21)" leading="" trailing="" val=":"/>
              <OtherNode start="(96, 21)" end="(96, 24)" kind="precMax">
                <AtomNode start="(96, 21)" end="(96, 24)" leading="" trailing=" " val="max"/>
              </OtherNode>
            </OtherNode>
          </NullNode>
        </OtherNode>
        <OtherNode start="(96, 25)" end="(96, 38)" kind="stx_?">
          <OtherNode start="(96, 25)" end="(96, 37)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(96, 25)" end="(96, 26)" leading="" trailing="" val="("/>
            <NullNode start="(96, 26)" end="(96, 36)">
              <OtherNode start="(96, 26)" end="(96, 31)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(96, 26)" end="(96, 31)" leading="" trailing=" " raw_val="colon" val="colon" full_name="Lean.Parser.colon" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(24, 8)" def_end="(24, 13)"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(96, 32)" end="(96, 36)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(96, 32)" end="(96, 36)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(96, 36)" end="(96, 37)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(96, 37)" end="(96, 38)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(96, 39)" end="(96, 54)" kind="stx_?">
          <OtherNode start="(96, 39)" end="(96, 53)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(96, 39)" end="(96, 40)" leading="" trailing="" val="("/>
            <NullNode start="(96, 40)" end="(96, 52)">
              <OtherNode start="(96, 40)" end="(96, 47)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(96, 40)" end="(96, 47)" leading="" trailing=" " raw_val="colonEq" val="colonEq" full_name="Lean.Parser.colonEq" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(35, 8)" def_end="(35, 15)"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(96, 48)" end="(96, 52)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(96, 48)" end="(96, 52)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(96, 52)" end="(96, 53)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(96, 53)" end="(96, 54)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(96, 55)" end="(96, 56)" leading="" trailing=" " val=":"/>
      <IdentNode start="(96, 57)" end="(96, 61)" leading="" trailing="&#10;&#10;" raw_val="conv" val="conv" full_name="Lean.Parser.Category.conv" mod_name="Init.Conv" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Conv.lean"/>
    </OtherNode>
    <CommandEndNode start="(98, 1)" end="(98, 11)" name="Tactic">
      <AtomNode start="(98, 1)" end="(98, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(98, 5)" end="(98, 11)">
        <IdentNode start="(98, 5)" end="(98, 11)" leading="" trailing="&#10;&#10;" raw_val="Tactic" val="Tactic"/>
      </NullNode>
    </CommandEndNode>
    <CommandNamespaceNode start="(100, 1)" end="(100, 18)" name="Command">
      <AtomNode start="(100, 1)" end="(100, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(100, 11)" end="(100, 18)" leading="" trailing="&#10;&#10;" raw_val="Command" val="Command"/>
    </CommandNamespaceNode>
    <OtherNode start="(102, 1)" end="(110, 74)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(102, 1)" end="(109, 57)">
        <CommandDoccommentNode start="(102, 1)" end="(109, 57)" comment="Command to check equality of two expressions.&#10;* `#guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.&#10;* `#guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.&#10;* `#guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.&#10;* `#guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.&#10;&#10;This is a command version of the `guard_expr` tactic. -/">
          <AtomNode start="(102, 1)" end="(102, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(103, 1)" end="(109, 57)" leading="" trailing="&#10;" val="Command to check equality of two expressions.&#10;* `#guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.&#10;* `#guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.&#10;* `#guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.&#10;* `#guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.&#10;&#10;This is a command version of the `guard_expr` tactic. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(110, 1)" end="(110, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(110, 8)" end="(110, 30)">
        <OtherNode start="(110, 8)" end="(110, 30)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(110, 8)" end="(110, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(110, 9)" end="(110, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(110, 14)" end="(110, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(110, 17)" end="(110, 29)" leading="" trailing="" raw_val="guardExprCmd" val="guardExprCmd"/>
          <AtomNode start="(110, 29)" end="(110, 30)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(110, 31)" end="(110, 64)">
        <OtherNode start="(110, 31)" end="(110, 45)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(110, 31)" end="(110, 45)" kind="str">
            <AtomNode start="(110, 31)" end="(110, 45)" leading="" trailing=" " val="&amp;quot;#guard_expr &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(110, 46)" end="(110, 53)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(110, 46)" end="(110, 50)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
          <NullNode start="(110, 50)" end="(110, 53)">
            <OtherNode start="(110, 50)" end="(110, 53)" kind="Lean.Parser.precedence">
              <AtomNode start="(110, 50)" end="(110, 51)" leading="" trailing="" val=":"/>
              <OtherNode start="(110, 51)" end="(110, 53)" kind="num">
                <AtomNode start="(110, 51)" end="(110, 53)" leading="" trailing=" " val="51"/>
              </OtherNode>
            </OtherNode>
          </NullNode>
        </OtherNode>
        <OtherNode start="(110, 54)" end="(110, 59)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(110, 54)" end="(110, 59)" leading="" trailing=" " raw_val="equal" val="equal" full_name="Lean.Parser.equal" mod_name="Init.Guard" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Guard.lean" def_start="(46, 8)" def_end="(46, 13)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(110, 60)" end="(110, 64)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(110, 60)" end="(110, 64)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(110, 65)" end="(110, 66)" leading="" trailing=" " val=":"/>
      <IdentNode start="(110, 67)" end="(110, 74)" leading="" trailing="&#10;&#10;" raw_val="command" val="command" full_name="Lean.Parser.Category.command" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(112, 1)" end="(127, 51)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(112, 1)" end="(126, 29)">
        <CommandDoccommentNode start="(112, 1)" end="(126, 29)" comment="Command to check that an expression evaluates to `true`.&#10;&#10;`#guard e` elaborates `e` ensuring its type is `Bool` then evaluates `e` and checks that&#10;the result is `true`. The term is elaborated *without* variables declared using `variable`, since&#10;these cannot be evaluated.&#10;&#10;Since this makes use of coercions, so long as a proposition `p` is decidable, one can write&#10;`#guard p` rather than `#guard decide p`. A consequence to this is that if there is decidable&#10;equality one can write `#guard a = b`. Note that this is not exactly the same as checking&#10;if `a` and `b` evaluate to the same thing since it uses the `DecidableEq` instance to do&#10;the evaluation.&#10;&#10;Note: this uses the untrusted evaluator, so `#guard` passing is *not* a proof that the&#10;expression equals `true`. -/">
          <AtomNode start="(112, 1)" end="(112, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(113, 1)" end="(126, 29)" leading="" trailing="&#10;" val="Command to check that an expression evaluates to `true`.&#10;&#10;`#guard e` elaborates `e` ensuring its type is `Bool` then evaluates `e` and checks that&#10;the result is `true`. The term is elaborated *without* variables declared using `variable`, since&#10;these cannot be evaluated.&#10;&#10;Since this makes use of coercions, so long as a proposition `p` is decidable, one can write&#10;`#guard p` rather than `#guard decide p`. A consequence to this is that if there is decidable&#10;equality one can write `#guard a = b`. Note that this is not exactly the same as checking&#10;if `a` and `b` evaluate to the same thing since it uses the `DecidableEq` instance to do&#10;the evaluation.&#10;&#10;Note: this uses the untrusted evaluator, so `#guard` passing is *not* a proof that the&#10;expression equals `true`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(127, 1)" end="(127, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(127, 8)" end="(127, 26)">
        <OtherNode start="(127, 8)" end="(127, 26)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(127, 8)" end="(127, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(127, 9)" end="(127, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(127, 14)" end="(127, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(127, 17)" end="(127, 25)" leading="" trailing="" raw_val="guardCmd" val="guardCmd"/>
          <AtomNode start="(127, 25)" end="(127, 26)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(127, 27)" end="(127, 41)">
        <OtherNode start="(127, 27)" end="(127, 36)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(127, 27)" end="(127, 36)" kind="str">
            <AtomNode start="(127, 27)" end="(127, 36)" leading="" trailing=" " val="&amp;quot;#guard &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(127, 37)" end="(127, 41)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(127, 37)" end="(127, 41)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(127, 42)" end="(127, 43)" leading="" trailing=" " val=":"/>
      <IdentNode start="(127, 44)" end="(127, 51)" leading="" trailing="&#10;&#10;" raw_val="command" val="command" full_name="Lean.Parser.Category.command" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <CommandEndNode start="(129, 1)" end="(129, 12)" name="Command">
      <AtomNode start="(129, 1)" end="(129, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(129, 5)" end="(129, 12)">
        <IdentNode start="(129, 5)" end="(129, 12)" leading="" trailing="&#10;&#10;" raw_val="Command" val="Command"/>
      </NullNode>
    </CommandEndNode>
    <CommandEndNode start="(131, 1)" end="(131, 16)" name="Lean.Parser">
      <AtomNode start="(131, 1)" end="(131, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(131, 5)" end="(131, 16)">
        <IdentNode start="(131, 5)" end="(131, 16)" leading="" trailing="&#10;" raw_val="Lean.Parser" val="Lean.Parser"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(15, 1)" end="(15, 54)" text="Reducible defeq matching for `guard_hyp` types -/"/>
    <Comment start="(17, 1)" end="(17, 65)" text="Default-reducibility defeq matching for `guard_hyp` types -/"/>
    <Comment start="(19, 1)" end="(19, 48)" text="Syntactic matching for `guard_hyp` types -/"/>
    <Comment start="(21, 1)" end="(21, 47)" text="Alpha-eq matching for `guard_hyp` types -/"/>
    <Comment start="(23, 1)" end="(23, 68)" text="The `guard_hyp` type specifier, one of `:`, `:~`, `:ₛ`, `:ₐ` -/"/>
    <Comment start="(26, 1)" end="(26, 55)" text="Reducible defeq matching for `guard_hyp` values -/"/>
    <Comment start="(28, 1)" end="(28, 66)" text="Default-reducibility defeq matching for `guard_hyp` values -/"/>
    <Comment start="(30, 1)" end="(30, 49)" text="Syntactic matching for `guard_hyp` values -/"/>
    <Comment start="(32, 1)" end="(32, 48)" text="Alpha-eq matching for `guard_hyp` values -/"/>
    <Comment start="(34, 1)" end="(34, 73)" text="The `guard_hyp` value specifier, one of `:=`, `:=~`, `:=ₛ`, `:=ₐ` -/"/>
    <Comment start="(37, 1)" end="(37, 49)" text="Reducible defeq matching for `guard_expr` -/"/>
    <Comment start="(39, 1)" end="(39, 60)" text="Default-reducibility defeq matching for `guard_expr` -/"/>
    <Comment start="(41, 1)" end="(41, 43)" text="Syntactic matching for `guard_expr` -/"/>
    <Comment start="(43, 1)" end="(43, 42)" text="Alpha-eq matching for `guard_expr` -/"/>
    <Comment start="(45, 1)" end="(45, 73)" text="The `guard_expr` matching specifier, one of `=`, `=~`, `=ₛ`, `=ₐ` -/"/>
    <Comment start="(50, 1)" end="(60, 3)" text="Tactic to check equality of two expressions.&#10;* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.&#10;* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.&#10;* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.&#10;* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.&#10;&#10;Both `e` and `e'` are elaborated then have their metavariables instantiated before the equality&#10;check. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are&#10;processed, which helps with default instance handling.&#10;-/"/>
    <Comment start="(65, 1)" end="(74, 3)" text="Tactic to check that the target agrees with a given expression.&#10;* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.&#10;* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.&#10;* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.&#10;* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.&#10;&#10;The term `e` is elaborated with the type of the goal as the expected type, which is mostly&#10;useful within `conv` mode.&#10;-/"/>
    <Comment start="(79, 1)" end="(92, 3)" text="Tactic to check that a named hypothesis has a given type and/or value.&#10;&#10;* `guard_hyp h : t` checks the type up to reducible defeq,&#10;* `guard_hyp h :~ t` checks the type up to default defeq,&#10;* `guard_hyp h :ₛ t` checks the type up to syntactic equality,&#10;* `guard_hyp h :ₐ t` checks the type up to alpha equality.&#10;* `guard_hyp h := v` checks value up to reducible defeq,&#10;* `guard_hyp h :=~ v` checks value up to default defeq,&#10;* `guard_hyp h :=ₛ v` checks value up to syntactic equality,&#10;* `guard_hyp h :=ₐ v` checks the value up to alpha equality.&#10;&#10;The value `v` is elaborated using the type of `h` as the expected type.&#10;-/"/>
    <Comment start="(102, 1)" end="(109, 57)" text="Command to check equality of two expressions.&#10;* `#guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.&#10;* `#guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.&#10;* `#guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.&#10;* `#guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.&#10;&#10;This is a command version of the `guard_expr` tactic. -/"/>
    <Comment start="(112, 1)" end="(126, 29)" text="Command to check that an expression evaluates to `true`.&#10;&#10;`#guard e` elaborates `e` ensuring its type is `Bool` then evaluates `e` and checks that&#10;the result is `true`. The term is elaborated *without* variables declared using `variable`, since&#10;these cannot be evaluated.&#10;&#10;Since this makes use of coercions, so long as a proposition `p` is decidable, one can write&#10;`#guard p` rather than `#guard decide p`. A consequence to this is that if there is decidable&#10;equality one can write `#guard a = b`. Note that this is not exactly the same as checking&#10;if `a` and `b` evaluate to the same thing since it uses the `DecidableEq` instance to do&#10;the evaluation.&#10;&#10;Note: this uses the untrusted evaluator, so `#guard` passing is *not* a proof that the&#10;expression equals `true`. -/"/>
  </Comments>
</TracedFile>
