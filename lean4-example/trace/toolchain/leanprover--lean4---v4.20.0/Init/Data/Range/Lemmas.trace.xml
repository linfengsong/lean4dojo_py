<TracedFile path="src/lean/Init/Data/Range/Lemmas.lean" md5="473b371b6d9a42d0ebd2609eb5d24d95">
  <FileNode start="(1, 1)" end="(105, 14)">
    <ModuleHeaderNode start="(6, 1)" end="(12, 32)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(12, 32)">
        <ModuleImportNode start="(9, 1)" end="(9, 29)" module="Init.Data.Range.Basic" path="src/lean/Init/Data/Range/Basic.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 29)" leading="" trailing="&#10;" raw_val="Init.Data.Range.Basic" val="Init.Data.Range.Basic"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 28)" module="Init.Data.List.Range" path="src/lean/Init/Data/List/Range.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 28)" leading="" trailing="&#10;" raw_val="Init.Data.List.Range" val="Init.Data.List.Range"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 30)" module="Init.Data.List.Monadic" path="src/lean/Init/Data/List/Monadic.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 30)" leading="" trailing="&#10;" raw_val="Init.Data.List.Monadic" val="Init.Data.List.Monadic"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(12, 1)" end="(12, 32)" module="Init.Data.Nat.Div.Lemmas" path="src/lean/Init/Data/Nat/Div/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(12, 1)" end="(12, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(12, 8)" end="(12, 32)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.Nat.Div.Lemmas" val="Init.Data.Nat.Div.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(14, 1)" end="(18, 3)" comment="# Lemmas about `Std.Range`&#10;&#10;We provide lemmas rewriting for loops over `Std.Range` in terms of `List.range'`.&#10;-/">
      <AtomNode start="(14, 1)" end="(14, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(15, 1)" end="(18, 3)" leading="" trailing="&#10;&#10;" val="# Lemmas about `Std.Range`&#10;&#10;We provide lemmas rewriting for loops over `Std.Range` in terms of `List.range'`.&#10;-/"/>
    </CommandModuledocNode>
    <CommandNamespaceNode start="(20, 1)" end="(20, 20)" name="Std.Range">
      <AtomNode start="(20, 1)" end="(20, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(20, 11)" end="(20, 20)" leading="" trailing="&#10;&#10;" raw_val="Std.Range" val="Std.Range"/>
    </CommandNamespaceNode>
    <CommandDeclarationNode start="(22, 1)" end="(31, 72)" name="mem_of_mem_range'_aux" full_name="Std.Range.mem_of_mem_range'_aux">
      <CommandDeclmodifiersNode start="(22, 1)" end="(23, 8)">
        <NullNode start="(22, 1)" end="(22, 91)">
          <CommandDoccommentNode start="(22, 1)" end="(22, 91)" comment="Generalization of `mem_of_mem_range'` used in `forIn'_loop_eq_forIn'_range'` below. -/">
            <AtomNode start="(22, 1)" end="(22, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(22, 5)" end="(22, 91)" leading="" trailing="&#10;" val="Generalization of `mem_of_mem_range'` used in `forIn'_loop_eq_forIn'_range'` below. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode start="(23, 1)" end="(23, 8)">
          <CommandPrivateNode start="(23, 1)" end="(23, 8)">
            <AtomNode start="(23, 1)" end="(23, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(23, 9)" end="(31, 72)" name="mem_of_mem_range'_aux" full_name="Std.Range.mem_of_mem_range'_aux" _is_private_decl="True">
        <AtomNode start="(23, 9)" end="(23, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(23, 17)" end="(23, 38)">
          <IdentNode start="(23, 17)" end="(23, 38)" leading="" trailing=" " raw_val="mem_of_mem_range'_aux" val="mem_of_mem_range'_aux"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(23, 39)" end="(25, 80)">
          <NullNode start="(23, 39)" end="(25, 72)">
            <OtherNode start="(23, 39)" end="(23, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(23, 39)" end="(23, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(23, 40)" end="(23, 41)">
                <IdentNode start="(23, 40)" end="(23, 41)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(23, 42)" end="(23, 49)">
                <AtomNode start="(23, 42)" end="(23, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(23, 44)" end="(23, 49)" leading="" trailing="" raw_val="Range" val="Range" full_name="Std.Range" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
              </NullNode>
              <AtomNode start="(23, 49)" end="(23, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(23, 51)" end="(23, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(23, 51)" end="(23, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(23, 52)" end="(23, 53)">
                <IdentNode start="(23, 52)" end="(23, 53)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(23, 54)" end="(23, 59)">
                <AtomNode start="(23, 54)" end="(23, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(23, 56)" end="(23, 59)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(23, 59)" end="(23, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(23, 61)" end="(23, 94)">
              <AtomNode start="(23, 61)" end="(23, 62)" leading="" trailing="" val="("/>
              <NullNode start="(23, 62)" end="(23, 64)">
                <IdentNode start="(23, 62)" end="(23, 64)" leading="" trailing=" " raw_val="w₁" val="w₁"/>
              </NullNode>
              <NullNode start="(23, 65)" end="(23, 93)">
                <AtomNode start="(23, 65)" end="(23, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(23, 67)" end="(23, 93)" kind="«term_=_»">
                  <OtherNode start="(23, 67)" end="(23, 89)" kind="«term_%_»">
                    <OtherNode start="(23, 67)" end="(23, 80)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(23, 67)" end="(23, 68)" leading="" trailing="" val="("/>
                      <OtherNode start="(23, 68)" end="(23, 79)" kind="«term_-_»">
                        <IdentNode start="(23, 68)" end="(23, 69)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(23, 70)" end="(23, 71)" leading="" trailing=" " val="-"/>
                        <IdentNode start="(23, 72)" end="(23, 79)" leading="" trailing="" raw_val="r.start" val="r.start"/>
                      </OtherNode>
                      <AtomNode start="(23, 79)" end="(23, 80)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <AtomNode start="(23, 81)" end="(23, 82)" leading="" trailing=" " val="%"/>
                    <IdentNode start="(23, 83)" end="(23, 89)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                  </OtherNode>
                  <AtomNode start="(23, 90)" end="(23, 91)" leading="" trailing=" " val="="/>
                  <OtherNode start="(23, 92)" end="(23, 93)" kind="num">
                    <AtomNode start="(23, 92)" end="(23, 93)" leading="" trailing="" val="0"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(23, 93)" end="(23, 94)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(24, 5)" end="(24, 23)">
              <AtomNode start="(24, 5)" end="(24, 6)" leading="" trailing="" val="("/>
              <NullNode start="(24, 6)" end="(24, 8)">
                <IdentNode start="(24, 6)" end="(24, 8)" leading="" trailing=" " raw_val="w₂" val="w₂"/>
              </NullNode>
              <NullNode start="(24, 9)" end="(24, 22)">
                <AtomNode start="(24, 9)" end="(24, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(24, 11)" end="(24, 22)" kind="«term_≤_»">
                  <IdentNode start="(24, 11)" end="(24, 18)" leading="" trailing=" " raw_val="r.start" val="r.start"/>
                  <AtomNode start="(24, 19)" end="(24, 20)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(24, 21)" end="(24, 22)" leading="" trailing="" raw_val="i" val="i"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(24, 22)" end="(24, 23)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(25, 5)" end="(25, 72)">
              <AtomNode start="(25, 5)" end="(25, 6)" leading="" trailing="" val="("/>
              <NullNode start="(25, 6)" end="(25, 7)">
                <IdentNode start="(25, 6)" end="(25, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(25, 8)" end="(25, 71)">
                <AtomNode start="(25, 8)" end="(25, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(25, 10)" end="(25, 71)" kind="«term_∈_»">
                  <IdentNode start="(25, 10)" end="(25, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(25, 12)" end="(25, 13)" leading="" trailing=" " val="∈"/>
                  <OtherNode start="(25, 14)" end="(25, 71)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(25, 14)" end="(25, 25)" leading="" trailing=" " raw_val="List.range'" val="List.range'" full_name="List.range'" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(25, 26)" end="(25, 71)">
                      <IdentNode start="(25, 26)" end="(25, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                      <OtherNode start="(25, 28)" end="(25, 64)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(25, 28)" end="(25, 29)" leading="" trailing="" val="("/>
                        <OtherNode start="(25, 29)" end="(25, 63)" kind="«term_/_»">
                          <OtherNode start="(25, 29)" end="(25, 54)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(25, 29)" end="(25, 30)" leading="" trailing="" val="("/>
                            <OtherNode start="(25, 30)" end="(25, 53)" kind="«term_-_»">
                              <OtherNode start="(25, 30)" end="(25, 49)" kind="«term_+_»">
                                <OtherNode start="(25, 30)" end="(25, 40)" kind="«term_-_»">
                                  <IdentNode start="(25, 30)" end="(25, 36)" leading="" trailing=" " raw_val="r.stop" val="r.stop"/>
                                  <AtomNode start="(25, 37)" end="(25, 38)" leading="" trailing=" " val="-"/>
                                  <IdentNode start="(25, 39)" end="(25, 40)" leading="" trailing=" " raw_val="i" val="i"/>
                                </OtherNode>
                                <AtomNode start="(25, 41)" end="(25, 42)" leading="" trailing=" " val="+"/>
                                <IdentNode start="(25, 43)" end="(25, 49)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                              </OtherNode>
                              <AtomNode start="(25, 50)" end="(25, 51)" leading="" trailing=" " val="-"/>
                              <OtherNode start="(25, 52)" end="(25, 53)" kind="num">
                                <AtomNode start="(25, 52)" end="(25, 53)" leading="" trailing="" val="1"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(25, 53)" end="(25, 54)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <AtomNode start="(25, 55)" end="(25, 56)" leading="" trailing=" " val="/"/>
                          <IdentNode start="(25, 57)" end="(25, 63)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                        </OtherNode>
                        <AtomNode start="(25, 63)" end="(25, 64)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <IdentNode start="(25, 65)" end="(25, 71)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(25, 71)" end="(25, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(25, 73)" end="(25, 80)">
            <AtomNode start="(25, 73)" end="(25, 74)" leading="" trailing=" " val=":"/>
            <OtherNode start="(25, 75)" end="(25, 80)" kind="«term_∈_»">
              <IdentNode start="(25, 75)" end="(25, 76)" leading="" trailing=" " raw_val="a" val="a"/>
              <AtomNode start="(25, 77)" end="(25, 78)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(25, 79)" end="(25, 80)" leading="" trailing=" " raw_val="r" val="r"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(25, 81)" end="(31, 72)">
          <AtomNode start="(25, 81)" end="(25, 83)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(25, 84)" end="(31, 72)">
            <AtomNode start="(25, 84)" end="(25, 86)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(26, 3)" end="(31, 72)">
              <TacticTacticseq1IndentedNode start="(26, 3)" end="(31, 72)">
                <NullNode start="(26, 3)" end="(31, 72)">
                  <OtherNode start="(26, 3)" end="(26, 45)" kind="Lean.Parser.Tactic.obtain" state_before="i : Nat&#10;r : Range&#10;a : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;h : a ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ a ∈ r" state_after="case intro.intro&#10;i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : j &amp;lt; (r.stop - i + r.step - 1) / r.step&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ i + r.step * j ∈ r" tactic="obtain ⟨j, h', rfl⟩ := List.mem_range'.1 h">
                    <AtomNode start="(26, 3)" end="(26, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(26, 10)" end="(26, 22)">
                      <OtherNode start="(26, 10)" end="(26, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(26, 10)" end="(26, 22)">
                          <OtherNode start="(26, 10)" end="(26, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                            <AtomNode start="(26, 10)" end="(26, 11)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(26, 11)" end="(26, 21)">
                              <OtherNode start="(26, 11)" end="(26, 12)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(26, 11)" end="(26, 12)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(26, 11)" end="(26, 12)">
                                    <OtherNode start="(26, 11)" end="(26, 12)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(26, 11)" end="(26, 12)" leading="" trailing="" raw_val="j" val="j"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(26, 12)" end="(26, 13)" leading="" trailing=" " val=","/>
                              <OtherNode start="(26, 14)" end="(26, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(26, 14)" end="(26, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(26, 14)" end="(26, 16)">
                                    <OtherNode start="(26, 14)" end="(26, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(26, 14)" end="(26, 16)" leading="" trailing="" raw_val="h'" val="h'"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(26, 16)" end="(26, 17)" leading="" trailing=" " val=","/>
                              <OtherNode start="(26, 18)" end="(26, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(26, 18)" end="(26, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(26, 18)" end="(26, 21)">
                                    <OtherNode start="(26, 18)" end="(26, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(26, 18)" end="(26, 21)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(26, 21)" end="(26, 22)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(26, 23)" end="(26, 45)">
                      <AtomNode start="(26, 23)" end="(26, 25)" leading="" trailing=" " val=":="/>
                      <NullNode start="(26, 26)" end="(26, 45)">
                        <OtherNode start="(26, 26)" end="(26, 45)" kind="Lean.Parser.Term.app">
                          <OtherNode start="(26, 26)" end="(26, 43)" kind="Lean.Parser.Term.proj">
                            <IdentNode start="(26, 26)" end="(26, 41)" leading="" trailing="" raw_val="List.mem_range'" val="List.mem_range'" full_name="List.mem_range'" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                            <AtomNode start="(26, 41)" end="(26, 42)" leading="" trailing="" val="."/>
                            <OtherNode start="(26, 42)" end="(26, 43)" kind="fieldIdx">
                              <AtomNode start="(26, 42)" end="(26, 43)" leading="" trailing=" " val="1"/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode start="(26, 44)" end="(26, 45)">
                            <IdentNode start="(26, 44)" end="(26, 45)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(27, 3)" end="(27, 24)" kind="Lean.Parser.Tactic.refine" state_before="case intro.intro&#10;i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : j &amp;lt; (r.stop - i + r.step - 1) / r.step&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ i + r.step * j ∈ r" state_after="case intro.intro&#10;i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : j &amp;lt; (r.stop - i + r.step - 1) / r.step&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ i + r.step * j &amp;lt; r.stop ∧ (i + r.step * j - r.start) % r.step = 0" tactic="refine ⟨by omega, ?_⟩">
                    <AtomNode start="(27, 3)" end="(27, 9)" leading="" trailing=" " val="refine"/>
                    <OtherNode start="(27, 10)" end="(27, 24)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(27, 10)" end="(27, 11)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(27, 11)" end="(27, 23)">
                        <TermBytacticNode start="(27, 11)" end="(27, 19)">
                          <AtomNode start="(27, 11)" end="(27, 13)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(27, 14)" end="(27, 19)">
                            <TacticTacticseq1IndentedNode start="(27, 14)" end="(27, 19)">
                              <NullNode start="(27, 14)" end="(27, 19)">
                                <OtherNode start="(27, 14)" end="(27, 19)" kind="Lean.Parser.Tactic.omega" state_before="i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : j &amp;lt; (r.stop - i + r.step - 1) / r.step&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ r.start ≤ i + r.step * j" state_after="no goals" tactic="omega">
                                  <AtomNode start="(27, 14)" end="(27, 19)" leading="" trailing="" val="omega"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                        <AtomNode start="(27, 19)" end="(27, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(27, 21)" end="(27, 23)" kind="Lean.Parser.Term.syntheticHole">
                          <AtomNode start="(27, 21)" end="(27, 22)" leading="" trailing="" val="?"/>
                          <AtomNode start="(27, 22)" end="(27, 23)" leading="" trailing="" val="_"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(27, 23)" end="(27, 24)" leading="" trailing="&#10;  " val="⟩"/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(28, 3)" end="(28, 60)" kind="Lean.Parser.Tactic.rwSeq" state_before="case intro.intro&#10;i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : j &amp;lt; (r.stop - i + r.step - 1) / r.step&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ i + r.step * j &amp;lt; r.stop ∧ (i + r.step * j - r.start) % r.step = 0" state_after="case intro.intro&#10;i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : r.step * j &amp;lt; r.stop - i + r.step - 1 - (r.step - 1)&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ i + r.step * j &amp;lt; r.stop ∧ (i + r.step * j - r.start) % r.step = 0" tactic="rw [Nat.lt_div_iff_mul_lt r.step_pos, Nat.mul_comm] at h'">
                    <AtomNode start="(28, 3)" end="(28, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(28, 6)" end="(28, 54)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(28, 6)" end="(28, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(28, 7)" end="(28, 53)">
                        <OtherNode start="(28, 7)" end="(28, 39)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(28, 7)" end="(28, 39)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(28, 7)" end="(28, 28)" leading="" trailing=" " raw_val="Nat.lt_div_iff_mul_lt" val="Nat.lt_div_iff_mul_lt" full_name="Nat.lt_div_iff_mul_lt" mod_name="Init.Data.Nat.Div.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Div/Lemmas.lean"/>
                            <NullNode start="(28, 29)" end="(28, 39)">
                              <IdentNode start="(28, 29)" end="(28, 39)" leading="" trailing="" raw_val="r.step_pos" val="r.step_pos"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(28, 39)" end="(28, 40)" leading="" trailing=" " val=","/>
                        <OtherNode start="(28, 41)" end="(28, 53)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(28, 41)" end="(28, 53)" leading="" trailing="" raw_val="Nat.mul_comm" val="Nat.mul_comm" full_name="Nat.mul_comm" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(28, 53)" end="(28, 54)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(28, 55)" end="(28, 60)">
                      <OtherNode start="(28, 55)" end="(28, 60)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(28, 55)" end="(28, 57)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(28, 58)" end="(28, 60)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(28, 58)" end="(28, 60)">
                            <IdentNode start="(28, 58)" end="(28, 60)" leading="" trailing="&#10;  " raw_val="h'" val="h'"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(29, 3)" end="(29, 14)" kind="Lean.Parser.Tactic.constructor" state_before="case intro.intro&#10;i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : r.step * j &amp;lt; r.stop - i + r.step - 1 - (r.step - 1)&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ i + r.step * j &amp;lt; r.stop ∧ (i + r.step * j - r.start) % r.step = 0" state_after="case intro.intro.left&#10;i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : r.step * j &amp;lt; r.stop - i + r.step - 1 - (r.step - 1)&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ i + r.step * j &amp;lt; r.stop&#10;&#10;case intro.intro.right&#10;i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : r.step * j &amp;lt; r.stop - i + r.step - 1 - (r.step - 1)&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ (i + r.step * j - r.start) % r.step = 0" tactic="constructor">
                    <AtomNode start="(29, 3)" end="(29, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(30, 3)" end="(30, 10)" kind="Lean.cdot" state_before="case intro.intro.left&#10;i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : r.step * j &amp;lt; r.stop - i + r.step - 1 - (r.step - 1)&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ i + r.step * j &amp;lt; r.stop&#10;&#10;case intro.intro.right&#10;i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : r.step * j &amp;lt; r.stop - i + r.step - 1 - (r.step - 1)&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ (i + r.step * j - r.start) % r.step = 0" state_after="case intro.intro.right&#10;i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : r.step * j &amp;lt; r.stop - i + r.step - 1 - (r.step - 1)&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ (i + r.step * j - r.start) % r.step = 0" tactic="· omega">
                    <OtherNode start="(30, 3)" end="(30, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(30, 3)" end="(30, 4)" kind="patternIgnore">
                        <OtherNode start="(30, 3)" end="(30, 4)" kind="token.«· »">
                          <AtomNode start="(30, 3)" end="(30, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(30, 5)" end="(30, 10)">
                      <TacticTacticseq1IndentedNode start="(30, 5)" end="(30, 10)">
                        <NullNode start="(30, 5)" end="(30, 10)">
                          <OtherNode start="(30, 5)" end="(30, 10)" kind="Lean.Parser.Tactic.omega" state_before="case intro.intro.left&#10;i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : r.step * j &amp;lt; r.stop - i + r.step - 1 - (r.step - 1)&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ i + r.step * j &amp;lt; r.stop" state_after="no goals" tactic="omega">
                            <AtomNode start="(30, 5)" end="(30, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(31, 3)" end="(31, 72)" kind="Lean.cdot" state_before="case intro.intro.right&#10;i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : r.step * j &amp;lt; r.stop - i + r.step - 1 - (r.step - 1)&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ (i + r.step * j - r.start) % r.step = 0" state_after="no goals" tactic="· rwa [Nat.add_comm, Nat.add_sub_assoc w₂, Nat.mul_add_mod_self_left]">
                    <OtherNode start="(31, 3)" end="(31, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(31, 3)" end="(31, 4)" kind="patternIgnore">
                        <OtherNode start="(31, 3)" end="(31, 4)" kind="token.«· »">
                          <AtomNode start="(31, 3)" end="(31, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(31, 5)" end="(31, 72)">
                      <TacticTacticseq1IndentedNode start="(31, 5)" end="(31, 72)">
                        <NullNode start="(31, 5)" end="(31, 72)">
                          <OtherNode start="(31, 5)" end="(31, 72)" kind="Lean.Parser.Tactic.tacticRwa__" state_before="case intro.intro.right&#10;i : Nat&#10;r : Range&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;j : Nat&#10;h' : r.step * j &amp;lt; r.stop - i + r.step - 1 - (r.step - 1)&#10;h : i + r.step * j ∈ List.range' i ((r.stop - i + r.step - 1) / r.step) r.step&#10;⊢ (i + r.step * j - r.start) % r.step = 0" state_after="no goals" tactic="rwa [Nat.add_comm, Nat.add_sub_assoc w₂, Nat.mul_add_mod_self_left]">
                            <AtomNode start="(31, 5)" end="(31, 8)" leading="" trailing=" " val="rwa"/>
                            <OtherNode start="(31, 9)" end="(31, 72)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(31, 9)" end="(31, 10)" leading="" trailing="" val="["/>
                              <NullNode start="(31, 10)" end="(31, 71)">
                                <OtherNode start="(31, 10)" end="(31, 22)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(31, 10)" end="(31, 22)" leading="" trailing="" raw_val="Nat.add_comm" val="Nat.add_comm" full_name="Nat.add_comm" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(31, 22)" end="(31, 23)" leading="" trailing=" " val=","/>
                                <OtherNode start="(31, 24)" end="(31, 44)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(31, 24)" end="(31, 44)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(31, 24)" end="(31, 41)" leading="" trailing=" " raw_val="Nat.add_sub_assoc" val="Nat.add_sub_assoc" full_name="Nat.add_sub_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                    <NullNode start="(31, 42)" end="(31, 44)">
                                      <IdentNode start="(31, 42)" end="(31, 44)" leading="" trailing="" raw_val="w₂" val="w₂"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(31, 44)" end="(31, 45)" leading="" trailing=" " val=","/>
                                <OtherNode start="(31, 46)" end="(31, 71)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(31, 46)" end="(31, 71)" leading="" trailing="" raw_val="Nat.mul_add_mod_self_left" val="Nat.mul_add_mod_self_left" full_name="Nat.mul_add_mod_self_left" mod_name="Init.Data.Nat.Div.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Div/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(31, 71)" end="(31, 72)" leading="" trailing="&#10;&#10;" val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(33, 1)" end="(35, 52)" name="mem_of_mem_range'" full_name="Std.Range.mem_of_mem_range'">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(33, 1)" end="(35, 52)" name="mem_of_mem_range'" full_name="Std.Range.mem_of_mem_range'" _is_private_decl="False">
        <AtomNode start="(33, 1)" end="(33, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(33, 9)" end="(33, 26)">
          <IdentNode start="(33, 9)" end="(33, 26)" leading="" trailing=" " raw_val="mem_of_mem_range'" val="mem_of_mem_range'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(33, 27)" end="(33, 90)">
          <NullNode start="(33, 27)" end="(33, 82)">
            <OtherNode start="(33, 27)" end="(33, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(33, 27)" end="(33, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(33, 28)" end="(33, 29)">
                <IdentNode start="(33, 28)" end="(33, 29)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(33, 30)" end="(33, 37)">
                <AtomNode start="(33, 30)" end="(33, 31)" leading="" trailing=" " val=":"/>
                <IdentNode start="(33, 32)" end="(33, 37)" leading="" trailing="" raw_val="Range" val="Range" full_name="Std.Range" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
              </NullNode>
              <AtomNode start="(33, 37)" end="(33, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(33, 39)" end="(33, 82)">
              <AtomNode start="(33, 39)" end="(33, 40)" leading="" trailing="" val="("/>
              <NullNode start="(33, 40)" end="(33, 41)">
                <IdentNode start="(33, 40)" end="(33, 41)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(33, 42)" end="(33, 81)">
                <AtomNode start="(33, 42)" end="(33, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(33, 44)" end="(33, 81)" kind="«term_∈_»">
                  <IdentNode start="(33, 44)" end="(33, 45)" leading="" trailing=" " raw_val="x" val="x"/>
                  <AtomNode start="(33, 46)" end="(33, 47)" leading="" trailing=" " val="∈"/>
                  <OtherNode start="(33, 48)" end="(33, 81)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(33, 48)" end="(33, 59)" leading="" trailing=" " raw_val="List.range'" val="List.range'" full_name="List.range'" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(33, 60)" end="(33, 81)">
                      <IdentNode start="(33, 60)" end="(33, 67)" leading="" trailing=" " raw_val="r.start" val="r.start"/>
                      <IdentNode start="(33, 68)" end="(33, 74)" leading="" trailing=" " raw_val="r.size" val="r.size"/>
                      <IdentNode start="(33, 75)" end="(33, 81)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(33, 81)" end="(33, 82)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(33, 83)" end="(33, 90)">
            <AtomNode start="(33, 83)" end="(33, 84)" leading="" trailing=" " val=":"/>
            <OtherNode start="(33, 85)" end="(33, 90)" kind="«term_∈_»">
              <IdentNode start="(33, 85)" end="(33, 86)" leading="" trailing=" " raw_val="x" val="x"/>
              <AtomNode start="(33, 87)" end="(33, 88)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(33, 89)" end="(33, 90)" leading="" trailing=" " raw_val="r" val="r"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(33, 91)" end="(35, 52)">
          <AtomNode start="(33, 91)" end="(33, 93)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(33, 94)" end="(35, 52)">
            <AtomNode start="(33, 94)" end="(33, 96)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(34, 3)" end="(35, 52)">
              <TacticTacticseq1IndentedNode start="(34, 3)" end="(35, 52)">
                <NullNode start="(34, 3)" end="(35, 52)">
                  <OtherNode start="(34, 3)" end="(34, 19)" kind="Lean.Parser.Tactic.unfold" state_before="x : Nat&#10;r : Range&#10;h : x ∈ List.range' r.start r.size r.step&#10;⊢ x ∈ r" state_after="x : Nat&#10;r : Range&#10;h : x ∈ List.range' r.start ((r.stop - r.start + r.step - 1) / r.step) r.step&#10;⊢ x ∈ r" tactic="unfold size at h">
                    <AtomNode start="(34, 3)" end="(34, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(34, 10)" end="(34, 14)">
                      <IdentNode start="(34, 10)" end="(34, 14)" leading="" trailing=" " raw_val="size" val="size" full_name="Std.Range.size" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
                    </NullNode>
                    <NullNode start="(34, 15)" end="(34, 19)">
                      <OtherNode start="(34, 15)" end="(34, 19)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(34, 15)" end="(34, 17)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(34, 18)" end="(34, 19)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(34, 18)" end="(34, 19)">
                            <IdentNode start="(34, 18)" end="(34, 19)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(35, 3)" end="(35, 52)" kind="Lean.Parser.Tactic.apply" state_before="x : Nat&#10;r : Range&#10;h : x ∈ List.range' r.start ((r.stop - r.start + r.step - 1) / r.step) r.step&#10;⊢ x ∈ r" state_after="no goals" tactic="apply mem_of_mem_range'_aux (by simp) (by simp) h">
                    <AtomNode start="(35, 3)" end="(35, 8)" leading="" trailing=" " val="apply"/>
                    <OtherNode start="(35, 9)" end="(35, 52)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(35, 9)" end="(35, 30)" leading="" trailing=" " raw_val="mem_of_mem_range'_aux" val="mem_of_mem_range'_aux" full_name="_private.Init.Data.Range.Lemmas.0.Std.Range.mem_of_mem_range'_aux" mod_name="Init.Data.Range.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Lemmas.lean" def_start="(23, 17)" def_end="(23, 38)"/>
                      <NullNode start="(35, 31)" end="(35, 52)">
                        <OtherNode start="(35, 31)" end="(35, 40)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(35, 31)" end="(35, 32)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(35, 32)" end="(35, 39)">
                            <AtomNode start="(35, 32)" end="(35, 34)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(35, 35)" end="(35, 39)">
                              <TacticTacticseq1IndentedNode start="(35, 35)" end="(35, 39)">
                                <NullNode start="(35, 35)" end="(35, 39)">
                                  <OtherNode start="(35, 35)" end="(35, 39)" kind="Lean.Parser.Tactic.simp" state_before="x : Nat&#10;r : Range&#10;h : x ∈ List.range' r.start ((r.stop - r.start + r.step - 1) / r.step) r.step&#10;⊢ (r.start - r.start) % r.step = 0" state_after="no goals" tactic="simp">
                                    <AtomNode start="(35, 35)" end="(35, 39)" leading="" trailing="" val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(35, 39)" end="(35, 40)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <OtherNode start="(35, 41)" end="(35, 50)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(35, 41)" end="(35, 42)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(35, 42)" end="(35, 49)">
                            <AtomNode start="(35, 42)" end="(35, 44)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(35, 45)" end="(35, 49)">
                              <TacticTacticseq1IndentedNode start="(35, 45)" end="(35, 49)">
                                <NullNode start="(35, 45)" end="(35, 49)">
                                  <OtherNode start="(35, 45)" end="(35, 49)" kind="Lean.Parser.Tactic.simp" state_before="x : Nat&#10;r : Range&#10;h : x ∈ List.range' r.start ((r.stop - r.start + r.step - 1) / r.step) r.step&#10;⊢ r.start ≤ r.start" state_after="no goals" tactic="simp">
                                    <AtomNode start="(35, 45)" end="(35, 49)" leading="" trailing="" val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(35, 49)" end="(35, 50)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <IdentNode start="(35, 51)" end="(35, 52)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(37, 1)" end="(55, 10)" name="size_eq" full_name="Std.Range.size_eq">
      <CommandDeclmodifiersNode start="(37, 1)" end="(37, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(37, 1)" end="(37, 8)">
          <CommandPrivateNode start="(37, 1)" end="(37, 8)">
            <AtomNode start="(37, 1)" end="(37, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(37, 9)" end="(55, 10)" name="size_eq" full_name="Std.Range.size_eq" _is_private_decl="True">
        <AtomNode start="(37, 9)" end="(37, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(37, 17)" end="(37, 24)">
          <IdentNode start="(37, 17)" end="(37, 24)" leading="" trailing=" " raw_val="size_eq" val="size_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(37, 25)" end="(39, 56)">
          <NullNode start="(37, 25)" end="(37, 57)">
            <TermExplicitbinderNode start="(37, 25)" end="(37, 40)">
              <AtomNode start="(37, 25)" end="(37, 26)" leading="" trailing="" val="("/>
              <NullNode start="(37, 26)" end="(37, 27)">
                <IdentNode start="(37, 26)" end="(37, 27)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(37, 28)" end="(37, 39)">
                <AtomNode start="(37, 28)" end="(37, 29)" leading="" trailing=" " val=":"/>
                <IdentNode start="(37, 30)" end="(37, 39)" leading="" trailing="" raw_val="Std.Range" val="Std.Range" full_name="Std.Range" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(37, 39)" end="(37, 40)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(37, 41)" end="(37, 57)">
              <AtomNode start="(37, 41)" end="(37, 42)" leading="" trailing="" val="("/>
              <NullNode start="(37, 42)" end="(37, 43)">
                <IdentNode start="(37, 42)" end="(37, 43)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(37, 44)" end="(37, 56)">
                <AtomNode start="(37, 44)" end="(37, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(37, 46)" end="(37, 56)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(37, 46)" end="(37, 47)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(37, 48)" end="(37, 49)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(37, 50)" end="(37, 56)" leading="" trailing="" raw_val="r.stop" val="r.stop"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(37, 56)" end="(37, 57)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(37, 58)" end="(39, 56)">
            <AtomNode start="(37, 58)" end="(37, 59)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(38, 5)" end="(39, 56)" kind="«term_=_»">
              <OtherNode start="(38, 5)" end="(38, 39)" kind="«term_/_»">
                <OtherNode start="(38, 5)" end="(38, 30)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(38, 5)" end="(38, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(38, 6)" end="(38, 29)" kind="«term_-_»">
                    <OtherNode start="(38, 6)" end="(38, 25)" kind="«term_+_»">
                      <OtherNode start="(38, 6)" end="(38, 16)" kind="«term_-_»">
                        <IdentNode start="(38, 6)" end="(38, 12)" leading="" trailing=" " raw_val="r.stop" val="r.stop"/>
                        <AtomNode start="(38, 13)" end="(38, 14)" leading="" trailing=" " val="-"/>
                        <IdentNode start="(38, 15)" end="(38, 16)" leading="" trailing=" " raw_val="i" val="i"/>
                      </OtherNode>
                      <AtomNode start="(38, 17)" end="(38, 18)" leading="" trailing=" " val="+"/>
                      <IdentNode start="(38, 19)" end="(38, 25)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                    </OtherNode>
                    <AtomNode start="(38, 26)" end="(38, 27)" leading="" trailing=" " val="-"/>
                    <OtherNode start="(38, 28)" end="(38, 29)" kind="num">
                      <AtomNode start="(38, 28)" end="(38, 29)" leading="" trailing="" val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(38, 29)" end="(38, 30)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(38, 31)" end="(38, 32)" leading="" trailing=" " val="/"/>
                <IdentNode start="(38, 33)" end="(38, 39)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
              </OtherNode>
              <AtomNode start="(38, 40)" end="(38, 41)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(39, 7)" end="(39, 56)" kind="«term_+_»">
                <OtherNode start="(39, 7)" end="(39, 52)" kind="«term_/_»">
                  <OtherNode start="(39, 7)" end="(39, 43)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(39, 7)" end="(39, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(39, 8)" end="(39, 42)" kind="«term_-_»">
                      <OtherNode start="(39, 8)" end="(39, 38)" kind="«term_+_»">
                        <OtherNode start="(39, 8)" end="(39, 29)" kind="«term_-_»">
                          <IdentNode start="(39, 8)" end="(39, 14)" leading="" trailing=" " raw_val="r.stop" val="r.stop"/>
                          <AtomNode start="(39, 15)" end="(39, 16)" leading="" trailing=" " val="-"/>
                          <OtherNode start="(39, 17)" end="(39, 29)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(39, 17)" end="(39, 18)" leading="" trailing="" val="("/>
                            <OtherNode start="(39, 18)" end="(39, 28)" kind="«term_+_»">
                              <IdentNode start="(39, 18)" end="(39, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                              <AtomNode start="(39, 20)" end="(39, 21)" leading="" trailing=" " val="+"/>
                              <IdentNode start="(39, 22)" end="(39, 28)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                            </OtherNode>
                            <AtomNode start="(39, 28)" end="(39, 29)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(39, 30)" end="(39, 31)" leading="" trailing=" " val="+"/>
                        <IdentNode start="(39, 32)" end="(39, 38)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                      </OtherNode>
                      <AtomNode start="(39, 39)" end="(39, 40)" leading="" trailing=" " val="-"/>
                      <OtherNode start="(39, 41)" end="(39, 42)" kind="num">
                        <AtomNode start="(39, 41)" end="(39, 42)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(39, 42)" end="(39, 43)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <AtomNode start="(39, 44)" end="(39, 45)" leading="" trailing=" " val="/"/>
                  <IdentNode start="(39, 46)" end="(39, 52)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                </OtherNode>
                <AtomNode start="(39, 53)" end="(39, 54)" leading="" trailing=" " val="+"/>
                <OtherNode start="(39, 55)" end="(39, 56)" kind="num">
                  <AtomNode start="(39, 55)" end="(39, 56)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(39, 57)" end="(55, 10)">
          <AtomNode start="(39, 57)" end="(39, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(39, 60)" end="(55, 10)">
            <AtomNode start="(39, 60)" end="(39, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(40, 3)" end="(55, 10)">
              <TacticTacticseq1IndentedNode start="(40, 3)" end="(55, 10)">
                <NullNode start="(40, 3)" end="(55, 10)">
                  <OtherNode start="(40, 3)" end="(40, 23)" kind="Lean.Parser.Tactic.tacticHave_" state_before="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;⊢ (r.stop - i + r.step - 1) / r.step = (r.stop - (i + r.step) + r.step - 1) / r.step + 1" state_after="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;⊢ (r.stop - i + r.step - 1) / r.step = (r.stop - (i + r.step) + r.step - 1) / r.step + 1" tactic="have w := r.step_pos">
                    <AtomNode start="(40, 3)" end="(40, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(40, 8)" end="(40, 23)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(40, 8)" end="(40, 23)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(40, 8)" end="(40, 9)" kind="Lean.Parser.Term.haveId">
                          <IdentNode start="(40, 8)" end="(40, 9)" leading="" trailing=" " raw_val="w" val="w"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(40, 10)" end="(40, 12)" leading="" trailing=" " val=":="/>
                        <IdentNode start="(40, 13)" end="(40, 23)" leading="" trailing="&#10;  " raw_val="r.step_pos" val="r.step_pos"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(41, 3)" end="(55, 10)" kind="Lean.Parser.Tactic.tacIfThenElse" state_before="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;⊢ (r.stop - i + r.step - 1) / r.step = (r.stop - (i + r.step) + r.step - 1) / r.step + 1" state_after="no goals" tactic="if i + r.step &amp;lt; r.stop then rw [Nat.div_eq_iff w, Nat.add_one_mul]&#10;  have : (r.stop - (i + r.step) + r.step - 1) / r.step * r.step ≤&#10;      (r.stop - (i + r.step) + r.step - 1) := Nat.div_mul_le_self _ _&#10;  have : r.stop - (i + r.step) + r.step - 1 - r.step &amp;lt;&#10;      (r.stop - (i + r.step) + r.step - 1) / r.step * r.step :=&#10;    Nat.lt_div_mul_self w (by omega)&#10;  omega&#10;else&#10;  have : (r.stop - i + r.step - 1) / r.step = 1 := by&#10;    rw [Nat.div_eq_iff w, Nat.one_mul]&#10;    omega&#10;  have : (r.stop - (i + r.step) + r.step - 1) / r.step = 0 := by&#10;    rw [Nat.div_eq_iff] &amp;lt;;&amp;gt; omega&#10;  omega">
                    <AtomNode start="(41, 3)" end="(41, 5)" leading="" trailing=" " val="if"/>
                    <OtherNode start="(41, 6)" end="(41, 25)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(41, 6)" end="(41, 16)" kind="«term_+_»">
                        <IdentNode start="(41, 6)" end="(41, 7)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(41, 8)" end="(41, 9)" leading="" trailing=" " val="+"/>
                        <IdentNode start="(41, 10)" end="(41, 16)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                      </OtherNode>
                      <AtomNode start="(41, 17)" end="(41, 18)" leading="" trailing=" " val="&amp;lt;"/>
                      <IdentNode start="(41, 19)" end="(41, 25)" leading="" trailing=" " raw_val="r.stop" val="r.stop"/>
                    </OtherNode>
                    <AtomNode start="(41, 26)" end="(41, 30)" leading="" trailing=" -- Not sure this case split is strictly necessary.&#10;    " val="then"/>
                    <TacticTacticseqNode start="(42, 5)" end="(48, 10)">
                      <TacticTacticseq1IndentedNode start="(42, 5)" end="(48, 10)">
                        <NullNode start="(42, 5)" end="(48, 10)">
                          <OtherNode start="(42, 5)" end="(42, 43)" kind="Lean.Parser.Tactic.rwSeq" state_before="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : i + r.step &amp;lt; r.stop&#10;⊢ (r.stop - i + r.step - 1) / r.step = (r.stop - (i + r.step) + r.step - 1) / r.step + 1" state_after="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : i + r.step &amp;lt; r.stop&#10;⊢ (r.stop - (i + r.step) + r.step - 1) / r.step * r.step + r.step ≤ r.stop - i + r.step - 1 ∧&#10;    r.stop - i + r.step - 1 ≤ (r.stop - (i + r.step) + r.step - 1) / r.step * r.step + r.step + r.step - 1" tactic="rw [Nat.div_eq_iff w, Nat.add_one_mul]">
                            <AtomNode start="(42, 5)" end="(42, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(42, 8)" end="(42, 43)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(42, 8)" end="(42, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(42, 9)" end="(42, 42)">
                                <OtherNode start="(42, 9)" end="(42, 25)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(42, 9)" end="(42, 25)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(42, 9)" end="(42, 23)" leading="" trailing=" " raw_val="Nat.div_eq_iff" val="Nat.div_eq_iff" full_name="Nat.div_eq_iff" mod_name="Init.Data.Nat.Div.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Div/Lemmas.lean"/>
                                    <NullNode start="(42, 24)" end="(42, 25)">
                                      <IdentNode start="(42, 24)" end="(42, 25)" leading="" trailing="" raw_val="w" val="w"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(42, 25)" end="(42, 26)" leading="" trailing=" " val=","/>
                                <OtherNode start="(42, 27)" end="(42, 42)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(42, 27)" end="(42, 42)" leading="" trailing="" raw_val="Nat.add_one_mul" val="Nat.add_one_mul" full_name="Nat.add_one_mul" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(42, 42)" end="(42, 43)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(43, 5)" end="(44, 72)" kind="Lean.Parser.Tactic.tacticHave_" state_before="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : i + r.step &amp;lt; r.stop&#10;⊢ (r.stop - (i + r.step) + r.step - 1) / r.step * r.step + r.step ≤ r.stop - i + r.step - 1 ∧&#10;    r.stop - i + r.step - 1 ≤ (r.stop - (i + r.step) + r.step - 1) / r.step * r.step + r.step + r.step - 1" state_after="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : i + r.step &amp;lt; r.stop&#10;this : (r.stop - (i + r.step) + r.step - 1) / r.step * r.step ≤ r.stop - (i + r.step) + r.step - 1&#10;⊢ (r.stop - (i + r.step) + r.step - 1) / r.step * r.step + r.step ≤ r.stop - i + r.step - 1 ∧&#10;    r.stop - i + r.step - 1 ≤ (r.stop - (i + r.step) + r.step - 1) / r.step * r.step + r.step + r.step - 1" tactic="have : (r.stop - (i + r.step) + r.step - 1) / r.step * r.step ≤&#10;    (r.stop - (i + r.step) + r.step - 1) := Nat.div_mul_le_self _ _">
                            <AtomNode start="(43, 5)" end="(43, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(43, 10)" end="(44, 72)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(43, 10)" end="(44, 72)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(43, 10)" end="(43, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(43, 10)" end="(43, 10)" kind="hygieneInfo">
                                    <IdentNode start="(43, 10)" end="(43, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(43, 10)" end="(44, 45)">
                                  <TermTypespecNode start="(43, 10)" end="(44, 45)">
                                    <AtomNode start="(43, 10)" end="(43, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(43, 12)" end="(44, 45)" kind="«term_≤_»">
                                      <OtherNode start="(43, 12)" end="(43, 66)" kind="«term_*_»">
                                        <OtherNode start="(43, 12)" end="(43, 57)" kind="«term_/_»">
                                          <OtherNode start="(43, 12)" end="(43, 48)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(43, 12)" end="(43, 13)" leading="" trailing="" val="("/>
                                            <OtherNode start="(43, 13)" end="(43, 47)" kind="«term_-_»">
                                              <OtherNode start="(43, 13)" end="(43, 43)" kind="«term_+_»">
                                                <OtherNode start="(43, 13)" end="(43, 34)" kind="«term_-_»">
                                                  <IdentNode start="(43, 13)" end="(43, 19)" leading="" trailing=" " raw_val="r.stop" val="r.stop"/>
                                                  <AtomNode start="(43, 20)" end="(43, 21)" leading="" trailing=" " val="-"/>
                                                  <OtherNode start="(43, 22)" end="(43, 34)" kind="Lean.Parser.Term.paren">
                                                    <AtomNode start="(43, 22)" end="(43, 23)" leading="" trailing="" val="("/>
                                                    <OtherNode start="(43, 23)" end="(43, 33)" kind="«term_+_»">
                                                      <IdentNode start="(43, 23)" end="(43, 24)" leading="" trailing=" " raw_val="i" val="i"/>
                                                      <AtomNode start="(43, 25)" end="(43, 26)" leading="" trailing=" " val="+"/>
                                                      <IdentNode start="(43, 27)" end="(43, 33)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                                                    </OtherNode>
                                                    <AtomNode start="(43, 33)" end="(43, 34)" leading="" trailing=" " val=")"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(43, 35)" end="(43, 36)" leading="" trailing=" " val="+"/>
                                                <IdentNode start="(43, 37)" end="(43, 43)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                              </OtherNode>
                                              <AtomNode start="(43, 44)" end="(43, 45)" leading="" trailing=" " val="-"/>
                                              <OtherNode start="(43, 46)" end="(43, 47)" kind="num">
                                                <AtomNode start="(43, 46)" end="(43, 47)" leading="" trailing="" val="1"/>
                                              </OtherNode>
                                            </OtherNode>
                                            <AtomNode start="(43, 47)" end="(43, 48)" leading="" trailing=" " val=")"/>
                                          </OtherNode>
                                          <AtomNode start="(43, 49)" end="(43, 50)" leading="" trailing=" " val="/"/>
                                          <IdentNode start="(43, 51)" end="(43, 57)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                        </OtherNode>
                                        <AtomNode start="(43, 58)" end="(43, 59)" leading="" trailing=" " val="*"/>
                                        <IdentNode start="(43, 60)" end="(43, 66)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                      </OtherNode>
                                      <AtomNode start="(43, 67)" end="(43, 68)" leading="" trailing="&#10;        " val="≤"/>
                                      <OtherNode start="(44, 9)" end="(44, 45)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(44, 9)" end="(44, 10)" leading="" trailing="" val="("/>
                                        <OtherNode start="(44, 10)" end="(44, 44)" kind="«term_-_»">
                                          <OtherNode start="(44, 10)" end="(44, 40)" kind="«term_+_»">
                                            <OtherNode start="(44, 10)" end="(44, 31)" kind="«term_-_»">
                                              <IdentNode start="(44, 10)" end="(44, 16)" leading="" trailing=" " raw_val="r.stop" val="r.stop"/>
                                              <AtomNode start="(44, 17)" end="(44, 18)" leading="" trailing=" " val="-"/>
                                              <OtherNode start="(44, 19)" end="(44, 31)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(44, 19)" end="(44, 20)" leading="" trailing="" val="("/>
                                                <OtherNode start="(44, 20)" end="(44, 30)" kind="«term_+_»">
                                                  <IdentNode start="(44, 20)" end="(44, 21)" leading="" trailing=" " raw_val="i" val="i"/>
                                                  <AtomNode start="(44, 22)" end="(44, 23)" leading="" trailing=" " val="+"/>
                                                  <IdentNode start="(44, 24)" end="(44, 30)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                                                </OtherNode>
                                                <AtomNode start="(44, 30)" end="(44, 31)" leading="" trailing=" " val=")"/>
                                              </OtherNode>
                                            </OtherNode>
                                            <AtomNode start="(44, 32)" end="(44, 33)" leading="" trailing=" " val="+"/>
                                            <IdentNode start="(44, 34)" end="(44, 40)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                          </OtherNode>
                                          <AtomNode start="(44, 41)" end="(44, 42)" leading="" trailing=" " val="-"/>
                                          <OtherNode start="(44, 43)" end="(44, 44)" kind="num">
                                            <AtomNode start="(44, 43)" end="(44, 44)" leading="" trailing="" val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(44, 44)" end="(44, 45)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(44, 46)" end="(44, 48)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(44, 49)" end="(44, 72)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(44, 49)" end="(44, 68)" leading="" trailing=" " raw_val="Nat.div_mul_le_self" val="Nat.div_mul_le_self" full_name="Nat.div_mul_le_self" mod_name="Init.Data.Nat.Div.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Div/Basic.lean"/>
                                  <NullNode start="(44, 69)" end="(44, 72)">
                                    <TermHoleNode start="(44, 69)" end="(44, 70)">
                                      <AtomNode start="(44, 69)" end="(44, 70)" leading="" trailing=" " val="_"/>
                                    </TermHoleNode>
                                    <TermHoleNode start="(44, 71)" end="(44, 72)">
                                      <AtomNode start="(44, 71)" end="(44, 72)" leading="" trailing="&#10;    " val="_"/>
                                    </TermHoleNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(45, 5)" end="(47, 39)" kind="Lean.Parser.Tactic.tacticHave_" state_before="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : i + r.step &amp;lt; r.stop&#10;this : (r.stop - (i + r.step) + r.step - 1) / r.step * r.step ≤ r.stop - (i + r.step) + r.step - 1&#10;⊢ (r.stop - (i + r.step) + r.step - 1) / r.step * r.step + r.step ≤ r.stop - i + r.step - 1 ∧&#10;    r.stop - i + r.step - 1 ≤ (r.stop - (i + r.step) + r.step - 1) / r.step * r.step + r.step + r.step - 1" state_after="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : i + r.step &amp;lt; r.stop&#10;this✝ : (r.stop - (i + r.step) + r.step - 1) / r.step * r.step ≤ r.stop - (i + r.step) + r.step - 1&#10;this : r.stop - (i + r.step) + r.step - 1 - r.step &amp;lt; (r.stop - (i + r.step) + r.step - 1) / r.step * r.step&#10;⊢ (r.stop - (i + r.step) + r.step - 1) / r.step * r.step + r.step ≤ r.stop - i + r.step - 1 ∧&#10;    r.stop - i + r.step - 1 ≤ (r.stop - (i + r.step) + r.step - 1) / r.step * r.step + r.step + r.step - 1" tactic="have : r.stop - (i + r.step) + r.step - 1 - r.step &amp;lt;&#10;    (r.stop - (i + r.step) + r.step - 1) / r.step * r.step :=&#10;  Nat.lt_div_mul_self w (by omega)">
                            <AtomNode start="(45, 5)" end="(45, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(45, 10)" end="(47, 39)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(45, 10)" end="(47, 39)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(45, 10)" end="(45, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(45, 10)" end="(45, 10)" kind="hygieneInfo">
                                    <IdentNode start="(45, 10)" end="(45, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(45, 10)" end="(46, 63)">
                                  <TermTypespecNode start="(45, 10)" end="(46, 63)">
                                    <AtomNode start="(45, 10)" end="(45, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(45, 12)" end="(46, 63)" kind="«term_&amp;lt;_»">
                                      <OtherNode start="(45, 12)" end="(45, 55)" kind="«term_-_»">
                                        <OtherNode start="(45, 12)" end="(45, 46)" kind="«term_-_»">
                                          <OtherNode start="(45, 12)" end="(45, 42)" kind="«term_+_»">
                                            <OtherNode start="(45, 12)" end="(45, 33)" kind="«term_-_»">
                                              <IdentNode start="(45, 12)" end="(45, 18)" leading="" trailing=" " raw_val="r.stop" val="r.stop"/>
                                              <AtomNode start="(45, 19)" end="(45, 20)" leading="" trailing=" " val="-"/>
                                              <OtherNode start="(45, 21)" end="(45, 33)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(45, 21)" end="(45, 22)" leading="" trailing="" val="("/>
                                                <OtherNode start="(45, 22)" end="(45, 32)" kind="«term_+_»">
                                                  <IdentNode start="(45, 22)" end="(45, 23)" leading="" trailing=" " raw_val="i" val="i"/>
                                                  <AtomNode start="(45, 24)" end="(45, 25)" leading="" trailing=" " val="+"/>
                                                  <IdentNode start="(45, 26)" end="(45, 32)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                                                </OtherNode>
                                                <AtomNode start="(45, 32)" end="(45, 33)" leading="" trailing=" " val=")"/>
                                              </OtherNode>
                                            </OtherNode>
                                            <AtomNode start="(45, 34)" end="(45, 35)" leading="" trailing=" " val="+"/>
                                            <IdentNode start="(45, 36)" end="(45, 42)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                          </OtherNode>
                                          <AtomNode start="(45, 43)" end="(45, 44)" leading="" trailing=" " val="-"/>
                                          <OtherNode start="(45, 45)" end="(45, 46)" kind="num">
                                            <AtomNode start="(45, 45)" end="(45, 46)" leading="" trailing=" " val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(45, 47)" end="(45, 48)" leading="" trailing=" " val="-"/>
                                        <IdentNode start="(45, 49)" end="(45, 55)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                      </OtherNode>
                                      <AtomNode start="(45, 56)" end="(45, 57)" leading="" trailing="&#10;        " val="&amp;lt;"/>
                                      <OtherNode start="(46, 9)" end="(46, 63)" kind="«term_*_»">
                                        <OtherNode start="(46, 9)" end="(46, 54)" kind="«term_/_»">
                                          <OtherNode start="(46, 9)" end="(46, 45)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(46, 9)" end="(46, 10)" leading="" trailing="" val="("/>
                                            <OtherNode start="(46, 10)" end="(46, 44)" kind="«term_-_»">
                                              <OtherNode start="(46, 10)" end="(46, 40)" kind="«term_+_»">
                                                <OtherNode start="(46, 10)" end="(46, 31)" kind="«term_-_»">
                                                  <IdentNode start="(46, 10)" end="(46, 16)" leading="" trailing=" " raw_val="r.stop" val="r.stop"/>
                                                  <AtomNode start="(46, 17)" end="(46, 18)" leading="" trailing=" " val="-"/>
                                                  <OtherNode start="(46, 19)" end="(46, 31)" kind="Lean.Parser.Term.paren">
                                                    <AtomNode start="(46, 19)" end="(46, 20)" leading="" trailing="" val="("/>
                                                    <OtherNode start="(46, 20)" end="(46, 30)" kind="«term_+_»">
                                                      <IdentNode start="(46, 20)" end="(46, 21)" leading="" trailing=" " raw_val="i" val="i"/>
                                                      <AtomNode start="(46, 22)" end="(46, 23)" leading="" trailing=" " val="+"/>
                                                      <IdentNode start="(46, 24)" end="(46, 30)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                                                    </OtherNode>
                                                    <AtomNode start="(46, 30)" end="(46, 31)" leading="" trailing=" " val=")"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(46, 32)" end="(46, 33)" leading="" trailing=" " val="+"/>
                                                <IdentNode start="(46, 34)" end="(46, 40)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                              </OtherNode>
                                              <AtomNode start="(46, 41)" end="(46, 42)" leading="" trailing=" " val="-"/>
                                              <OtherNode start="(46, 43)" end="(46, 44)" kind="num">
                                                <AtomNode start="(46, 43)" end="(46, 44)" leading="" trailing="" val="1"/>
                                              </OtherNode>
                                            </OtherNode>
                                            <AtomNode start="(46, 44)" end="(46, 45)" leading="" trailing=" " val=")"/>
                                          </OtherNode>
                                          <AtomNode start="(46, 46)" end="(46, 47)" leading="" trailing=" " val="/"/>
                                          <IdentNode start="(46, 48)" end="(46, 54)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                        </OtherNode>
                                        <AtomNode start="(46, 55)" end="(46, 56)" leading="" trailing=" " val="*"/>
                                        <IdentNode start="(46, 57)" end="(46, 63)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(46, 64)" end="(46, 66)" leading="" trailing="&#10;      " val=":="/>
                                <OtherNode start="(47, 7)" end="(47, 39)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(47, 7)" end="(47, 26)" leading="" trailing=" " raw_val="Nat.lt_div_mul_self" val="Nat.lt_div_mul_self" full_name="Nat.lt_div_mul_self" mod_name="Init.Data.Nat.Div.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Div/Lemmas.lean"/>
                                  <NullNode start="(47, 27)" end="(47, 39)">
                                    <IdentNode start="(47, 27)" end="(47, 28)" leading="" trailing=" " raw_val="w" val="w"/>
                                    <OtherNode start="(47, 29)" end="(47, 39)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(47, 29)" end="(47, 30)" leading="" trailing="" val="("/>
                                      <TermBytacticNode start="(47, 30)" end="(47, 38)">
                                        <AtomNode start="(47, 30)" end="(47, 32)" leading="" trailing=" " val="by"/>
                                        <TacticTacticseqNode start="(47, 33)" end="(47, 38)">
                                          <TacticTacticseq1IndentedNode start="(47, 33)" end="(47, 38)">
                                            <NullNode start="(47, 33)" end="(47, 38)">
                                              <OtherNode start="(47, 33)" end="(47, 38)" kind="Lean.Parser.Tactic.omega" state_before="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : i + r.step &amp;lt; r.stop&#10;this : (r.stop - (i + r.step) + r.step - 1) / r.step * r.step ≤ r.stop - (i + r.step) + r.step - 1&#10;⊢ r.step ≤ r.stop - (i + r.step) + r.step - 1" state_after="no goals" tactic="omega">
                                                <AtomNode start="(47, 33)" end="(47, 38)" leading="" trailing="" val="omega"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </TacticTacticseq1IndentedNode>
                                        </TacticTacticseqNode>
                                      </TermBytacticNode>
                                      <AtomNode start="(47, 38)" end="(47, 39)" leading="" trailing="&#10;    " val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(48, 5)" end="(48, 10)" kind="Lean.Parser.Tactic.omega" state_before="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : i + r.step &amp;lt; r.stop&#10;this✝ : (r.stop - (i + r.step) + r.step - 1) / r.step * r.step ≤ r.stop - (i + r.step) + r.step - 1&#10;this : r.stop - (i + r.step) + r.step - 1 - r.step &amp;lt; (r.stop - (i + r.step) + r.step - 1) / r.step * r.step&#10;⊢ (r.stop - (i + r.step) + r.step - 1) / r.step * r.step + r.step ≤ r.stop - i + r.step - 1 ∧&#10;    r.stop - i + r.step - 1 ≤ (r.stop - (i + r.step) + r.step - 1) / r.step * r.step + r.step + r.step - 1" state_after="no goals" tactic="omega">
                            <AtomNode start="(48, 5)" end="(48, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                    <AtomNode start="(49, 3)" end="(49, 7)" leading="" trailing="&#10;    " val="else"/>
                    <TacticTacticseqNode start="(50, 5)" end="(55, 10)">
                      <TacticTacticseq1IndentedNode start="(50, 5)" end="(55, 10)">
                        <NullNode start="(50, 5)" end="(55, 10)">
                          <OtherNode start="(50, 5)" end="(52, 12)" kind="Lean.Parser.Tactic.tacticHave_" state_before="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : ¬i + r.step &amp;lt; r.stop&#10;⊢ (r.stop - i + r.step - 1) / r.step = (r.stop - (i + r.step) + r.step - 1) / r.step + 1" state_after="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : ¬i + r.step &amp;lt; r.stop&#10;this : (r.stop - i + r.step - 1) / r.step = 1&#10;⊢ (r.stop - i + r.step - 1) / r.step = (r.stop - (i + r.step) + r.step - 1) / r.step + 1" tactic="have : (r.stop - i + r.step - 1) / r.step = 1 := by&#10;  rw [Nat.div_eq_iff w, Nat.one_mul]&#10;  omega">
                            <AtomNode start="(50, 5)" end="(50, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(50, 10)" end="(52, 12)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(50, 10)" end="(52, 12)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(50, 10)" end="(50, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(50, 10)" end="(50, 10)" kind="hygieneInfo">
                                    <IdentNode start="(50, 10)" end="(50, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(50, 10)" end="(50, 50)">
                                  <TermTypespecNode start="(50, 10)" end="(50, 50)">
                                    <AtomNode start="(50, 10)" end="(50, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(50, 12)" end="(50, 50)" kind="«term_=_»">
                                      <OtherNode start="(50, 12)" end="(50, 46)" kind="«term_/_»">
                                        <OtherNode start="(50, 12)" end="(50, 37)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(50, 12)" end="(50, 13)" leading="" trailing="" val="("/>
                                          <OtherNode start="(50, 13)" end="(50, 36)" kind="«term_-_»">
                                            <OtherNode start="(50, 13)" end="(50, 32)" kind="«term_+_»">
                                              <OtherNode start="(50, 13)" end="(50, 23)" kind="«term_-_»">
                                                <IdentNode start="(50, 13)" end="(50, 19)" leading="" trailing=" " raw_val="r.stop" val="r.stop"/>
                                                <AtomNode start="(50, 20)" end="(50, 21)" leading="" trailing=" " val="-"/>
                                                <IdentNode start="(50, 22)" end="(50, 23)" leading="" trailing=" " raw_val="i" val="i"/>
                                              </OtherNode>
                                              <AtomNode start="(50, 24)" end="(50, 25)" leading="" trailing=" " val="+"/>
                                              <IdentNode start="(50, 26)" end="(50, 32)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                            </OtherNode>
                                            <AtomNode start="(50, 33)" end="(50, 34)" leading="" trailing=" " val="-"/>
                                            <OtherNode start="(50, 35)" end="(50, 36)" kind="num">
                                              <AtomNode start="(50, 35)" end="(50, 36)" leading="" trailing="" val="1"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(50, 36)" end="(50, 37)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                        <AtomNode start="(50, 38)" end="(50, 39)" leading="" trailing=" " val="/"/>
                                        <IdentNode start="(50, 40)" end="(50, 46)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                      </OtherNode>
                                      <AtomNode start="(50, 47)" end="(50, 48)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(50, 49)" end="(50, 50)" kind="num">
                                        <AtomNode start="(50, 49)" end="(50, 50)" leading="" trailing=" " val="1"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(50, 51)" end="(50, 53)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(50, 54)" end="(52, 12)">
                                  <AtomNode start="(50, 54)" end="(50, 56)" leading="" trailing="&#10;      " val="by"/>
                                  <TacticTacticseqNode start="(51, 7)" end="(52, 12)">
                                    <TacticTacticseq1IndentedNode start="(51, 7)" end="(52, 12)">
                                      <NullNode start="(51, 7)" end="(52, 12)">
                                        <OtherNode start="(51, 7)" end="(51, 41)" kind="Lean.Parser.Tactic.rwSeq" state_before="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : ¬i + r.step &amp;lt; r.stop&#10;⊢ (r.stop - i + r.step - 1) / r.step = 1" state_after="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : ¬i + r.step &amp;lt; r.stop&#10;⊢ r.step ≤ r.stop - i + r.step - 1 ∧ r.stop - i + r.step - 1 ≤ r.step + r.step - 1" tactic="rw [Nat.div_eq_iff w, Nat.one_mul]">
                                          <AtomNode start="(51, 7)" end="(51, 9)" leading="" trailing=" " val="rw"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <OtherNode start="(51, 10)" end="(51, 41)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                            <AtomNode start="(51, 10)" end="(51, 11)" leading="" trailing="" val="["/>
                                            <NullNode start="(51, 11)" end="(51, 40)">
                                              <OtherNode start="(51, 11)" end="(51, 27)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <OtherNode start="(51, 11)" end="(51, 27)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(51, 11)" end="(51, 25)" leading="" trailing=" " raw_val="Nat.div_eq_iff" val="Nat.div_eq_iff" full_name="Nat.div_eq_iff" mod_name="Init.Data.Nat.Div.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Div/Lemmas.lean"/>
                                                  <NullNode start="(51, 26)" end="(51, 27)">
                                                    <IdentNode start="(51, 26)" end="(51, 27)" leading="" trailing="" raw_val="w" val="w"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(51, 27)" end="(51, 28)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(51, 29)" end="(51, 40)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <IdentNode start="(51, 29)" end="(51, 40)" leading="" trailing="" raw_val="Nat.one_mul" val="Nat.one_mul" full_name="Nat.one_mul" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(51, 40)" end="(51, 41)" leading="" trailing="&#10;      " val="]"/>
                                          </OtherNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <OtherNode start="(52, 7)" end="(52, 12)" kind="Lean.Parser.Tactic.omega" state_before="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : ¬i + r.step &amp;lt; r.stop&#10;⊢ r.step ≤ r.stop - i + r.step - 1 ∧ r.stop - i + r.step - 1 ≤ r.step + r.step - 1" state_after="no goals" tactic="omega">
                                          <AtomNode start="(52, 7)" end="(52, 12)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(53, 5)" end="(54, 36)" kind="Lean.Parser.Tactic.tacticHave_" state_before="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : ¬i + r.step &amp;lt; r.stop&#10;this : (r.stop - i + r.step - 1) / r.step = 1&#10;⊢ (r.stop - i + r.step - 1) / r.step = (r.stop - (i + r.step) + r.step - 1) / r.step + 1" state_after="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : ¬i + r.step &amp;lt; r.stop&#10;this✝ : (r.stop - i + r.step - 1) / r.step = 1&#10;this : (r.stop - (i + r.step) + r.step - 1) / r.step = 0&#10;⊢ (r.stop - i + r.step - 1) / r.step = (r.stop - (i + r.step) + r.step - 1) / r.step + 1" tactic="have : (r.stop - (i + r.step) + r.step - 1) / r.step = 0 := by&#10;  rw [Nat.div_eq_iff] &amp;lt;;&amp;gt; omega">
                            <AtomNode start="(53, 5)" end="(53, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(53, 10)" end="(54, 36)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(53, 10)" end="(54, 36)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(53, 10)" end="(53, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(53, 10)" end="(53, 10)" kind="hygieneInfo">
                                    <IdentNode start="(53, 10)" end="(53, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(53, 10)" end="(53, 61)">
                                  <TermTypespecNode start="(53, 10)" end="(53, 61)">
                                    <AtomNode start="(53, 10)" end="(53, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(53, 12)" end="(53, 61)" kind="«term_=_»">
                                      <OtherNode start="(53, 12)" end="(53, 57)" kind="«term_/_»">
                                        <OtherNode start="(53, 12)" end="(53, 48)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(53, 12)" end="(53, 13)" leading="" trailing="" val="("/>
                                          <OtherNode start="(53, 13)" end="(53, 47)" kind="«term_-_»">
                                            <OtherNode start="(53, 13)" end="(53, 43)" kind="«term_+_»">
                                              <OtherNode start="(53, 13)" end="(53, 34)" kind="«term_-_»">
                                                <IdentNode start="(53, 13)" end="(53, 19)" leading="" trailing=" " raw_val="r.stop" val="r.stop"/>
                                                <AtomNode start="(53, 20)" end="(53, 21)" leading="" trailing=" " val="-"/>
                                                <OtherNode start="(53, 22)" end="(53, 34)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(53, 22)" end="(53, 23)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(53, 23)" end="(53, 33)" kind="«term_+_»">
                                                    <IdentNode start="(53, 23)" end="(53, 24)" leading="" trailing=" " raw_val="i" val="i"/>
                                                    <AtomNode start="(53, 25)" end="(53, 26)" leading="" trailing=" " val="+"/>
                                                    <IdentNode start="(53, 27)" end="(53, 33)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                                                  </OtherNode>
                                                  <AtomNode start="(53, 33)" end="(53, 34)" leading="" trailing=" " val=")"/>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(53, 35)" end="(53, 36)" leading="" trailing=" " val="+"/>
                                              <IdentNode start="(53, 37)" end="(53, 43)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                            </OtherNode>
                                            <AtomNode start="(53, 44)" end="(53, 45)" leading="" trailing=" " val="-"/>
                                            <OtherNode start="(53, 46)" end="(53, 47)" kind="num">
                                              <AtomNode start="(53, 46)" end="(53, 47)" leading="" trailing="" val="1"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(53, 47)" end="(53, 48)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                        <AtomNode start="(53, 49)" end="(53, 50)" leading="" trailing=" " val="/"/>
                                        <IdentNode start="(53, 51)" end="(53, 57)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                      </OtherNode>
                                      <AtomNode start="(53, 58)" end="(53, 59)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(53, 60)" end="(53, 61)" kind="num">
                                        <AtomNode start="(53, 60)" end="(53, 61)" leading="" trailing=" " val="0"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(53, 62)" end="(53, 64)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(53, 65)" end="(54, 36)">
                                  <AtomNode start="(53, 65)" end="(53, 67)" leading="" trailing="&#10;      " val="by"/>
                                  <TacticTacticseqNode start="(54, 7)" end="(54, 36)">
                                    <TacticTacticseq1IndentedNode start="(54, 7)" end="(54, 36)">
                                      <NullNode start="(54, 7)" end="(54, 36)">
                                        <OtherNode start="(54, 7)" end="(54, 36)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : ¬i + r.step &amp;lt; r.stop&#10;this : (r.stop - i + r.step - 1) / r.step = 1&#10;⊢ (r.stop - (i + r.step) + r.step - 1) / r.step = 0" state_after="no goals" tactic="rw [Nat.div_eq_iff] &amp;lt;;&amp;gt; omega">
                                          <OtherNode start="(54, 7)" end="(54, 26)" kind="Lean.Parser.Tactic.rwSeq">
                                            <AtomNode start="(54, 7)" end="(54, 9)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(54, 10)" end="(54, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(54, 10)" end="(54, 11)" leading="" trailing="" val="["/>
                                              <NullNode start="(54, 11)" end="(54, 25)">
                                                <OtherNode start="(54, 11)" end="(54, 25)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <IdentNode start="(54, 11)" end="(54, 25)" leading="" trailing="" raw_val="Nat.div_eq_iff" val="Nat.div_eq_iff" full_name="Nat.div_eq_iff" mod_name="Init.Data.Nat.Div.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Div/Lemmas.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(54, 25)" end="(54, 26)" leading="" trailing=" " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <AtomNode start="(54, 27)" end="(54, 30)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                          <OtherNode start="(54, 31)" end="(54, 36)" kind="Lean.Parser.Tactic.omega">
                                            <AtomNode start="(54, 31)" end="(54, 36)" leading="" trailing="&#10;    " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(55, 5)" end="(55, 10)" kind="Lean.Parser.Tactic.omega" state_before="i : Nat&#10;r : Range&#10;h : i &amp;lt; r.stop&#10;w : 0 &amp;lt; r.step&#10;h✝ : ¬i + r.step &amp;lt; r.stop&#10;this✝ : (r.stop - i + r.step - 1) / r.step = 1&#10;this : (r.stop - (i + r.step) + r.step - 1) / r.step = 0&#10;⊢ (r.stop - i + r.step - 1) / r.step = (r.stop - (i + r.step) + r.step - 1) / r.step + 1" state_after="no goals" tactic="omega">
                            <AtomNode start="(55, 5)" end="(55, 10)" leading="" trailing="&#10;&#10;" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(57, 1)" end="(73, 16)" name="forIn'_loop_eq_forIn'_range'" full_name="Std.Range.forIn'_loop_eq_forIn'_range'">
      <CommandDeclmodifiersNode start="(57, 1)" end="(57, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(57, 1)" end="(57, 8)">
          <CommandPrivateNode start="(57, 1)" end="(57, 8)">
            <AtomNode start="(57, 1)" end="(57, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(57, 9)" end="(73, 16)" name="forIn'_loop_eq_forIn'_range'" full_name="Std.Range.forIn'_loop_eq_forIn'_range'" _is_private_decl="True">
        <AtomNode start="(57, 9)" end="(57, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(57, 17)" end="(57, 45)">
          <IdentNode start="(57, 17)" end="(57, 45)" leading="" trailing=" " raw_val="forIn'_loop_eq_forIn'_range'" val="forIn'_loop_eq_forIn'_range'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(57, 46)" end="(61, 55)">
          <NullNode start="(57, 46)" end="(58, 75)">
            <OtherNode start="(57, 46)" end="(57, 55)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(57, 46)" end="(57, 47)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(57, 47)" end="(57, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(57, 47)" end="(57, 52)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(57, 53)" end="(57, 54)">
                  <IdentNode start="(57, 53)" end="(57, 54)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(57, 54)" end="(57, 55)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(57, 56)" end="(57, 71)">
              <AtomNode start="(57, 56)" end="(57, 57)" leading="" trailing="" val="("/>
              <NullNode start="(57, 57)" end="(57, 58)">
                <IdentNode start="(57, 57)" end="(57, 58)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(57, 59)" end="(57, 70)">
                <AtomNode start="(57, 59)" end="(57, 60)" leading="" trailing=" " val=":"/>
                <IdentNode start="(57, 61)" end="(57, 70)" leading="" trailing="" raw_val="Std.Range" val="Std.Range" full_name="Std.Range" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(57, 70)" end="(57, 71)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(58, 5)" end="(58, 15)">
              <AtomNode start="(58, 5)" end="(58, 6)" leading="" trailing="" val="("/>
              <NullNode start="(58, 6)" end="(58, 10)">
                <IdentNode start="(58, 6)" end="(58, 10)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(58, 11)" end="(58, 14)">
                <AtomNode start="(58, 11)" end="(58, 12)" leading="" trailing=" " val=":"/>
                <IdentNode start="(58, 13)" end="(58, 14)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(58, 14)" end="(58, 15)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(58, 16)" end="(58, 61)">
              <AtomNode start="(58, 16)" end="(58, 17)" leading="" trailing="" val="("/>
              <NullNode start="(58, 17)" end="(58, 18)">
                <IdentNode start="(58, 17)" end="(58, 18)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(58, 19)" end="(58, 60)">
                <AtomNode start="(58, 19)" end="(58, 20)" leading="" trailing=" " val=":"/>
                <OtherNode start="(58, 21)" end="(58, 60)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(58, 21)" end="(58, 30)">
                    <AtomNode start="(58, 21)" end="(58, 22)" leading="" trailing="" val="("/>
                    <NullNode start="(58, 22)" end="(58, 23)">
                      <IdentNode start="(58, 22)" end="(58, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(58, 24)" end="(58, 29)">
                      <AtomNode start="(58, 24)" end="(58, 25)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(58, 26)" end="(58, 29)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(58, 29)" end="(58, 30)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(58, 31)" end="(58, 32)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(58, 33)" end="(58, 60)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(58, 33)" end="(58, 38)" kind="«term_∈_»">
                      <IdentNode start="(58, 33)" end="(58, 34)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(58, 35)" end="(58, 36)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(58, 37)" end="(58, 38)" leading="" trailing=" " raw_val="r" val="r"/>
                    </OtherNode>
                    <AtomNode start="(58, 39)" end="(58, 40)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(58, 41)" end="(58, 60)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(58, 41)" end="(58, 42)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(58, 43)" end="(58, 44)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(58, 45)" end="(58, 60)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(58, 45)" end="(58, 46)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(58, 47)" end="(58, 60)">
                          <OtherNode start="(58, 47)" end="(58, 60)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(58, 47)" end="(58, 48)" leading="" trailing="" val="("/>
                            <OtherNode start="(58, 48)" end="(58, 59)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(58, 48)" end="(58, 57)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(58, 58)" end="(58, 59)">
                                <IdentNode start="(58, 58)" end="(58, 59)" leading="" trailing="" raw_val="β" val="β"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(58, 59)" end="(58, 60)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(58, 60)" end="(58, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(58, 62)" end="(58, 65)">
              <AtomNode start="(58, 62)" end="(58, 63)" leading="" trailing="" val="("/>
              <NullNode start="(58, 63)" end="(58, 64)">
                <IdentNode start="(58, 63)" end="(58, 64)" leading="" trailing="" raw_val="i" val="i"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(58, 64)" end="(58, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(58, 66)" end="(58, 70)">
              <AtomNode start="(58, 66)" end="(58, 67)" leading="" trailing="" val="("/>
              <NullNode start="(58, 67)" end="(58, 69)">
                <IdentNode start="(58, 67)" end="(58, 69)" leading="" trailing="" raw_val="w₁" val="w₁"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(58, 69)" end="(58, 70)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(58, 71)" end="(58, 75)">
              <AtomNode start="(58, 71)" end="(58, 72)" leading="" trailing="" val="("/>
              <NullNode start="(58, 72)" end="(58, 74)">
                <IdentNode start="(58, 72)" end="(58, 74)" leading="" trailing="" raw_val="w₂" val="w₂"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(58, 74)" end="(58, 75)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(58, 76)" end="(61, 55)">
            <AtomNode start="(58, 76)" end="(58, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(59, 5)" end="(61, 55)" kind="«term_=_»">
              <OtherNode start="(59, 5)" end="(59, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(59, 5)" end="(59, 16)" leading="" trailing=" " raw_val="forIn'.loop" val="forIn'.loop" full_name="Std.Range.forIn'.loop" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
                <NullNode start="(59, 17)" end="(59, 33)">
                  <IdentNode start="(59, 17)" end="(59, 18)" leading="" trailing=" " raw_val="r" val="r"/>
                  <IdentNode start="(59, 19)" end="(59, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(59, 21)" end="(59, 25)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(59, 26)" end="(59, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(59, 28)" end="(59, 30)" leading="" trailing=" " raw_val="w₁" val="w₁"/>
                  <IdentNode start="(59, 31)" end="(59, 33)" leading="" trailing=" " raw_val="w₂" val="w₂"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(59, 34)" end="(59, 35)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(60, 7)" end="(61, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(60, 7)" end="(60, 13)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(60, 14)" end="(61, 55)">
                  <OtherNode start="(60, 14)" end="(60, 73)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(60, 14)" end="(60, 15)" leading="" trailing="" val="("/>
                    <OtherNode start="(60, 15)" end="(60, 72)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(60, 15)" end="(60, 26)" leading="" trailing=" " raw_val="List.range'" val="List.range'" full_name="List.range'" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(60, 27)" end="(60, 72)">
                        <IdentNode start="(60, 27)" end="(60, 28)" leading="" trailing=" " raw_val="i" val="i"/>
                        <OtherNode start="(60, 29)" end="(60, 65)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(60, 29)" end="(60, 30)" leading="" trailing="" val="("/>
                          <OtherNode start="(60, 30)" end="(60, 64)" kind="«term_/_»">
                            <OtherNode start="(60, 30)" end="(60, 55)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(60, 30)" end="(60, 31)" leading="" trailing="" val="("/>
                              <OtherNode start="(60, 31)" end="(60, 54)" kind="«term_-_»">
                                <OtherNode start="(60, 31)" end="(60, 50)" kind="«term_+_»">
                                  <OtherNode start="(60, 31)" end="(60, 41)" kind="«term_-_»">
                                    <IdentNode start="(60, 31)" end="(60, 37)" leading="" trailing=" " raw_val="r.stop" val="r.stop"/>
                                    <AtomNode start="(60, 38)" end="(60, 39)" leading="" trailing=" " val="-"/>
                                    <IdentNode start="(60, 40)" end="(60, 41)" leading="" trailing=" " raw_val="i" val="i"/>
                                  </OtherNode>
                                  <AtomNode start="(60, 42)" end="(60, 43)" leading="" trailing=" " val="+"/>
                                  <IdentNode start="(60, 44)" end="(60, 50)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                </OtherNode>
                                <AtomNode start="(60, 51)" end="(60, 52)" leading="" trailing=" " val="-"/>
                                <OtherNode start="(60, 53)" end="(60, 54)" kind="num">
                                  <AtomNode start="(60, 53)" end="(60, 54)" leading="" trailing="" val="1"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(60, 54)" end="(60, 55)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <AtomNode start="(60, 56)" end="(60, 57)" leading="" trailing=" " val="/"/>
                            <IdentNode start="(60, 58)" end="(60, 64)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                          </OtherNode>
                          <AtomNode start="(60, 64)" end="(60, 65)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <IdentNode start="(60, 66)" end="(60, 72)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(60, 72)" end="(60, 73)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(60, 74)" end="(60, 78)" leading="" trailing="&#10;        " raw_val="init" val="init"/>
                  <OtherNode start="(61, 9)" end="(61, 55)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(61, 9)" end="(61, 12)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(61, 13)" end="(61, 55)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(61, 13)" end="(61, 16)">
                        <IdentNode start="(61, 13)" end="(61, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(61, 15)" end="(61, 16)" leading="" trailing=" " raw_val="h" val="h"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(61, 17)" end="(61, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(61, 20)" end="(61, 55)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(61, 20)" end="(61, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(61, 22)" end="(61, 55)">
                          <IdentNode start="(61, 22)" end="(61, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                          <OtherNode start="(61, 24)" end="(61, 55)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(61, 24)" end="(61, 25)" leading="" trailing="" val="("/>
                            <OtherNode start="(61, 25)" end="(61, 54)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(61, 25)" end="(61, 46)" leading="" trailing=" " raw_val="mem_of_mem_range'_aux" val="mem_of_mem_range'_aux" full_name="_private.Init.Data.Range.Lemmas.0.Std.Range.mem_of_mem_range'_aux" mod_name="Init.Data.Range.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Lemmas.lean" def_start="(23, 17)" def_end="(23, 38)"/>
                              <NullNode start="(61, 47)" end="(61, 54)">
                                <IdentNode start="(61, 47)" end="(61, 49)" leading="" trailing=" " raw_val="w₁" val="w₁"/>
                                <IdentNode start="(61, 50)" end="(61, 52)" leading="" trailing=" " raw_val="w₂" val="w₂"/>
                                <IdentNode start="(61, 53)" end="(61, 54)" leading="" trailing="" raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(61, 54)" end="(61, 55)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(61, 56)" end="(73, 16)">
          <AtomNode start="(61, 56)" end="(61, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(61, 59)" end="(73, 16)">
            <AtomNode start="(61, 59)" end="(61, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(62, 3)" end="(73, 16)">
              <TacticTacticseq1IndentedNode start="(62, 3)" end="(73, 16)">
                <NullNode start="(62, 3)" end="(73, 16)">
                  <OtherNode start="(62, 3)" end="(62, 23)" kind="Lean.Parser.Tactic.tacticHave_" state_before="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;⊢ forIn'.loop r f init i w₁ w₂ =&#10;    forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" state_after="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;⊢ forIn'.loop r f init i w₁ w₂ =&#10;    forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" tactic="have w := r.step_pos">
                    <AtomNode start="(62, 3)" end="(62, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(62, 8)" end="(62, 23)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(62, 8)" end="(62, 23)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(62, 8)" end="(62, 9)" kind="Lean.Parser.Term.haveId">
                          <IdentNode start="(62, 8)" end="(62, 9)" leading="" trailing=" " raw_val="w" val="w"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(62, 10)" end="(62, 12)" leading="" trailing=" " val=":="/>
                        <IdentNode start="(62, 13)" end="(62, 23)" leading="" trailing="&#10;  " raw_val="r.step_pos" val="r.step_pos"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(63, 3)" end="(63, 19)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;⊢ forIn'.loop r f init i w₁ w₂ =&#10;    forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" state_after="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;⊢ (if h : i &amp;lt; r.stop then do&#10;      let __do_lift ← f i ⋯ init&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt;&#10;          let_fun this := ⋯;&#10;          forIn'.loop r f b (i + r.step) ⋯ ⋯&#10;    else pure init) =&#10;    forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" tactic="rw [forIn'.loop]">
                    <AtomNode start="(63, 3)" end="(63, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(63, 6)" end="(63, 19)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(63, 6)" end="(63, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(63, 7)" end="(63, 18)">
                        <OtherNode start="(63, 7)" end="(63, 18)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(63, 7)" end="(63, 18)" leading="" trailing="" raw_val="forIn'.loop" val="forIn'.loop" full_name="Std.Range.forIn'.loop" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(63, 18)" end="(63, 19)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(64, 3)" end="(64, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;⊢ (if h : i &amp;lt; r.stop then do&#10;      let __do_lift ← f i ⋯ init&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt;&#10;          let_fun this := ⋯;&#10;          forIn'.loop r f b (i + r.step) ⋯ ⋯&#10;    else pure init) =&#10;    forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" state_after="case isTrue&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;⊢ (do&#10;      let __do_lift ← f i ⋯ init&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt;&#10;          let_fun this := ⋯;&#10;          forIn'.loop r f b (i + r.step) ⋯ ⋯) =&#10;    forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯&#10;&#10;case isFalse&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;⊢ pure init = forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(64, 3)" end="(64, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(64, 3)" end="(64, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(64, 9)" end="(64, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(64, 13)" end="(64, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(64, 13)" end="(64, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(64, 22)" end="(64, 23)">
                        <LeanBinderidentNode start="(64, 22)" end="(64, 23)">
                          <IdentNode start="(64, 22)" end="(64, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(65, 3)" end="(70, 40)" kind="Lean.cdot" state_before="case isTrue&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;⊢ (do&#10;      let __do_lift ← f i ⋯ init&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt;&#10;          let_fun this := ⋯;&#10;          forIn'.loop r f b (i + r.step) ⋯ ⋯) =&#10;    forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯&#10;&#10;case isFalse&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;⊢ pure init = forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" state_after="case isFalse&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;⊢ pure init = forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" tactic="· simp only [size_eq r h, List.range'_succ, List.forIn'_cons]&#10;  congr 1&#10;  funext step&#10;  split&#10;  · simp&#10;  · rw [forIn'_loop_eq_forIn'_range']">
                    <OtherNode start="(65, 3)" end="(65, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(65, 3)" end="(65, 4)" kind="patternIgnore">
                        <OtherNode start="(65, 3)" end="(65, 4)" kind="token.«· »">
                          <AtomNode start="(65, 3)" end="(65, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(65, 5)" end="(70, 40)">
                      <TacticTacticseq1IndentedNode start="(65, 5)" end="(70, 40)">
                        <NullNode start="(65, 5)" end="(70, 40)">
                          <OtherNode start="(65, 5)" end="(65, 64)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;⊢ (do&#10;      let __do_lift ← f i ⋯ init&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt;&#10;          let_fun this := ⋯;&#10;          forIn'.loop r f b (i + r.step) ⋯ ⋯) =&#10;    forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" state_after="case isTrue&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;⊢ (do&#10;      let __do_lift ← f i ⋯ init&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn'.loop r f b (i + r.step) ⋯ ⋯) =&#10;    do&#10;    let x ← f i ⋯ init&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt;&#10;        forIn' (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) b fun a' m b =&amp;gt;&#10;          f a' ⋯ b" tactic="simp only [size_eq r h, List.range'_succ, List.forIn'_cons]">
                            <AtomNode start="(65, 5)" end="(65, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(65, 10)" end="(65, 14)">
                              <AtomNode start="(65, 10)" end="(65, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(65, 15)" end="(65, 64)">
                              <AtomNode start="(65, 15)" end="(65, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(65, 16)" end="(65, 63)">
                                <OtherNode start="(65, 16)" end="(65, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(65, 16)" end="(65, 27)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(65, 16)" end="(65, 23)" leading="" trailing=" " raw_val="size_eq" val="size_eq" full_name="_private.Init.Data.Range.Lemmas.0.Std.Range.size_eq" mod_name="Init.Data.Range.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Lemmas.lean" def_start="(37, 17)" def_end="(37, 24)"/>
                                    <NullNode start="(65, 24)" end="(65, 27)">
                                      <IdentNode start="(65, 24)" end="(65, 25)" leading="" trailing=" " raw_val="r" val="r"/>
                                      <IdentNode start="(65, 26)" end="(65, 27)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(65, 27)" end="(65, 28)" leading="" trailing=" " val=","/>
                                <OtherNode start="(65, 29)" end="(65, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(65, 29)" end="(65, 45)" leading="" trailing="" raw_val="List.range'_succ" val="List.range'_succ" full_name="List.range'_succ" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                                </OtherNode>
                                <AtomNode start="(65, 45)" end="(65, 46)" leading="" trailing=" " val=","/>
                                <OtherNode start="(65, 47)" end="(65, 63)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(65, 47)" end="(65, 63)" leading="" trailing="" raw_val="List.forIn'_cons" val="List.forIn'_cons" full_name="List.forIn'_cons" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(65, 63)" end="(65, 64)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(66, 5)" end="(66, 12)" kind="Lean.Parser.Tactic.congr" state_before="case isTrue&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;⊢ (do&#10;      let __do_lift ← f i ⋯ init&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn'.loop r f b (i + r.step) ⋯ ⋯) =&#10;    do&#10;    let x ← f i ⋯ init&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt;&#10;        forIn' (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) b fun a' m b =&amp;gt;&#10;          f a' ⋯ b" state_after="case isTrue.e_a&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn'.loop r f b (i + r.step) ⋯ ⋯) =&#10;    fun x =&amp;gt;&#10;    match x with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt;&#10;      forIn' (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) b fun a' m b =&amp;gt; f a' ⋯ b" tactic="congr 1">
                            <AtomNode start="(66, 5)" end="(66, 10)" leading="" trailing=" " val="congr"/>
                            <NullNode start="(66, 11)" end="(66, 12)">
                              <OtherNode start="(66, 11)" end="(66, 12)" kind="num">
                                <AtomNode start="(66, 11)" end="(66, 12)" leading="" trailing="&#10;    " val="1"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(67, 5)" end="(67, 16)" kind="tacticFunext___" state_before="case isTrue.e_a&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn'.loop r f b (i + r.step) ⋯ ⋯) =&#10;    fun x =&amp;gt;&#10;    match x with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt;&#10;      forIn' (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) b fun a' m b =&amp;gt; f a' ⋯ b" state_after="case isTrue.e_a.h&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;step : ForInStep β&#10;⊢ (match step with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop r f b (i + r.step) ⋯ ⋯) =&#10;    match step with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt;&#10;      forIn' (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) b fun a' m b =&amp;gt; f a' ⋯ b" tactic="funext step">
                            <AtomNode start="(67, 5)" end="(67, 11)" leading="" trailing=" " val="funext"/>
                            <NullNode start="(67, 12)" end="(67, 16)">
                              <IdentNode start="(67, 12)" end="(67, 16)" leading="" trailing="&#10;    " raw_val="step" val="step"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(68, 5)" end="(68, 10)" kind="Lean.Parser.Tactic.split" state_before="case isTrue.e_a.h&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;step : ForInStep β&#10;⊢ (match step with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop r f b (i + r.step) ⋯ ⋯) =&#10;    match step with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt;&#10;      forIn' (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) b fun a' m b =&amp;gt; f a' ⋯ b" state_after="case isTrue.e_a.h.h_1&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;__do_lift✝ : ForInStep β&#10;b✝ : β&#10;⊢ pure b✝ =&#10;    match ForInStep.done b✝ with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt;&#10;      forIn' (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) b fun a' m b =&amp;gt; f a' ⋯ b&#10;&#10;case isTrue.e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;__do_lift✝ : ForInStep β&#10;b✝ : β&#10;⊢ forIn'.loop r f b✝ (i + r.step) ⋯ ⋯ =&#10;    match ForInStep.yield b✝ with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt;&#10;      forIn' (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) b fun a' m b =&amp;gt; f a' ⋯ b" tactic="split">
                            <AtomNode start="(68, 5)" end="(68, 10)" leading="" trailing="&#10;    " val="split"/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(69, 5)" end="(69, 11)" kind="Lean.cdot" state_before="case isTrue.e_a.h.h_1&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;__do_lift✝ : ForInStep β&#10;b✝ : β&#10;⊢ pure b✝ =&#10;    match ForInStep.done b✝ with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt;&#10;      forIn' (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) b fun a' m b =&amp;gt; f a' ⋯ b&#10;&#10;case isTrue.e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;__do_lift✝ : ForInStep β&#10;b✝ : β&#10;⊢ forIn'.loop r f b✝ (i + r.step) ⋯ ⋯ =&#10;    match ForInStep.yield b✝ with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt;&#10;      forIn' (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) b fun a' m b =&amp;gt; f a' ⋯ b" state_after="case isTrue.e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;__do_lift✝ : ForInStep β&#10;b✝ : β&#10;⊢ forIn'.loop r f b✝ (i + r.step) ⋯ ⋯ =&#10;    match ForInStep.yield b✝ with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt;&#10;      forIn' (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) b fun a' m b =&amp;gt; f a' ⋯ b" tactic="· simp">
                            <OtherNode start="(69, 5)" end="(69, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(69, 5)" end="(69, 6)" kind="patternIgnore">
                                <OtherNode start="(69, 5)" end="(69, 6)" kind="token.«· »">
                                  <AtomNode start="(69, 5)" end="(69, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(69, 7)" end="(69, 11)">
                              <TacticTacticseq1IndentedNode start="(69, 7)" end="(69, 11)">
                                <NullNode start="(69, 7)" end="(69, 11)">
                                  <OtherNode start="(69, 7)" end="(69, 11)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.e_a.h.h_1&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;__do_lift✝ : ForInStep β&#10;b✝ : β&#10;⊢ pure b✝ =&#10;    match ForInStep.done b✝ with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt;&#10;      forIn' (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) b fun a' m b =&amp;gt; f a' ⋯ b" state_after="no goals" tactic="simp">
                                    <AtomNode start="(69, 7)" end="(69, 11)" leading="" trailing="&#10;    " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(70, 5)" end="(70, 40)" kind="Lean.cdot" state_before="case isTrue.e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;__do_lift✝ : ForInStep β&#10;b✝ : β&#10;⊢ forIn'.loop r f b✝ (i + r.step) ⋯ ⋯ =&#10;    match ForInStep.yield b✝ with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt;&#10;      forIn' (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) b fun a' m b =&amp;gt; f a' ⋯ b" state_after="no goals" tactic="· rw [forIn'_loop_eq_forIn'_range']">
                            <OtherNode start="(70, 5)" end="(70, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(70, 5)" end="(70, 6)" kind="patternIgnore">
                                <OtherNode start="(70, 5)" end="(70, 6)" kind="token.«· »">
                                  <AtomNode start="(70, 5)" end="(70, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(70, 7)" end="(70, 40)">
                              <TacticTacticseq1IndentedNode start="(70, 7)" end="(70, 40)">
                                <NullNode start="(70, 7)" end="(70, 40)">
                                  <OtherNode start="(70, 7)" end="(70, 40)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue.e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;__do_lift✝ : ForInStep β&#10;b✝ : β&#10;⊢ forIn'.loop r f b✝ (i + r.step) ⋯ ⋯ =&#10;    match ForInStep.yield b✝ with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt;&#10;      forIn' (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) b fun a' m b =&amp;gt; f a' ⋯ b" state_after="no goals" tactic="rw [forIn'_loop_eq_forIn'_range']">
                                    <AtomNode start="(70, 7)" end="(70, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(70, 10)" end="(70, 40)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(70, 10)" end="(70, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(70, 11)" end="(70, 39)">
                                        <OtherNode start="(70, 11)" end="(70, 39)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(70, 11)" end="(70, 39)" leading="" trailing="" raw_val="forIn'_loop_eq_forIn'_range'" val="forIn'_loop_eq_forIn'_range'" full_name="PSigma.Lex.left" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(70, 39)" end="(70, 40)" leading="" trailing="&#10;  " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(71, 3)" end="(73, 16)" kind="Lean.cdot" state_before="case isFalse&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;⊢ pure init = forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" state_after="no goals" tactic="· have : (r.stop - i + r.step - 1) / r.step = 0 := by&#10;    rw [Nat.div_eq_iff] &amp;lt;;&amp;gt; omega&#10;  simp [this]">
                    <OtherNode start="(71, 3)" end="(71, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(71, 3)" end="(71, 4)" kind="patternIgnore">
                        <OtherNode start="(71, 3)" end="(71, 4)" kind="token.«· »">
                          <AtomNode start="(71, 3)" end="(71, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(71, 5)" end="(73, 16)">
                      <TacticTacticseq1IndentedNode start="(71, 5)" end="(73, 16)">
                        <NullNode start="(71, 5)" end="(73, 16)">
                          <OtherNode start="(71, 5)" end="(72, 36)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case isFalse&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;⊢ pure init = forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" state_after="case isFalse&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;this : (r.stop - i + r.step - 1) / r.step = 0&#10;⊢ pure init = forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" tactic="have : (r.stop - i + r.step - 1) / r.step = 0 := by&#10;  rw [Nat.div_eq_iff] &amp;lt;;&amp;gt; omega">
                            <AtomNode start="(71, 5)" end="(71, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(71, 10)" end="(72, 36)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(71, 10)" end="(72, 36)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(71, 10)" end="(71, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(71, 10)" end="(71, 10)" kind="hygieneInfo">
                                    <IdentNode start="(71, 10)" end="(71, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(71, 10)" end="(71, 50)">
                                  <TermTypespecNode start="(71, 10)" end="(71, 50)">
                                    <AtomNode start="(71, 10)" end="(71, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(71, 12)" end="(71, 50)" kind="«term_=_»">
                                      <OtherNode start="(71, 12)" end="(71, 46)" kind="«term_/_»">
                                        <OtherNode start="(71, 12)" end="(71, 37)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(71, 12)" end="(71, 13)" leading="" trailing="" val="("/>
                                          <OtherNode start="(71, 13)" end="(71, 36)" kind="«term_-_»">
                                            <OtherNode start="(71, 13)" end="(71, 32)" kind="«term_+_»">
                                              <OtherNode start="(71, 13)" end="(71, 23)" kind="«term_-_»">
                                                <IdentNode start="(71, 13)" end="(71, 19)" leading="" trailing=" " raw_val="r.stop" val="r.stop"/>
                                                <AtomNode start="(71, 20)" end="(71, 21)" leading="" trailing=" " val="-"/>
                                                <IdentNode start="(71, 22)" end="(71, 23)" leading="" trailing=" " raw_val="i" val="i"/>
                                              </OtherNode>
                                              <AtomNode start="(71, 24)" end="(71, 25)" leading="" trailing=" " val="+"/>
                                              <IdentNode start="(71, 26)" end="(71, 32)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                            </OtherNode>
                                            <AtomNode start="(71, 33)" end="(71, 34)" leading="" trailing=" " val="-"/>
                                            <OtherNode start="(71, 35)" end="(71, 36)" kind="num">
                                              <AtomNode start="(71, 35)" end="(71, 36)" leading="" trailing="" val="1"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(71, 36)" end="(71, 37)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                        <AtomNode start="(71, 38)" end="(71, 39)" leading="" trailing=" " val="/"/>
                                        <IdentNode start="(71, 40)" end="(71, 46)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                      </OtherNode>
                                      <AtomNode start="(71, 47)" end="(71, 48)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(71, 49)" end="(71, 50)" kind="num">
                                        <AtomNode start="(71, 49)" end="(71, 50)" leading="" trailing=" " val="0"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(71, 51)" end="(71, 53)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(71, 54)" end="(72, 36)">
                                  <AtomNode start="(71, 54)" end="(71, 56)" leading="" trailing="&#10;      " val="by"/>
                                  <TacticTacticseqNode start="(72, 7)" end="(72, 36)">
                                    <TacticTacticseq1IndentedNode start="(72, 7)" end="(72, 36)">
                                      <NullNode start="(72, 7)" end="(72, 36)">
                                        <OtherNode start="(72, 7)" end="(72, 36)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;⊢ (r.stop - i + r.step - 1) / r.step = 0" state_after="no goals" tactic="rw [Nat.div_eq_iff] &amp;lt;;&amp;gt; omega">
                                          <OtherNode start="(72, 7)" end="(72, 26)" kind="Lean.Parser.Tactic.rwSeq">
                                            <AtomNode start="(72, 7)" end="(72, 9)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(72, 10)" end="(72, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(72, 10)" end="(72, 11)" leading="" trailing="" val="["/>
                                              <NullNode start="(72, 11)" end="(72, 25)">
                                                <OtherNode start="(72, 11)" end="(72, 25)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <IdentNode start="(72, 11)" end="(72, 25)" leading="" trailing="" raw_val="Nat.div_eq_iff" val="Nat.div_eq_iff" full_name="Nat.div_eq_iff" mod_name="Init.Data.Nat.Div.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Div/Lemmas.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(72, 25)" end="(72, 26)" leading="" trailing=" " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <AtomNode start="(72, 27)" end="(72, 30)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                          <OtherNode start="(72, 31)" end="(72, 36)" kind="Lean.Parser.Tactic.omega">
                                            <AtomNode start="(72, 31)" end="(72, 36)" leading="" trailing="&#10;    " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(73, 5)" end="(73, 16)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;i : Nat&#10;w₁ : (i - r.start) % r.step = 0&#10;w₂ : r.start ≤ i&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;this : (r.stop - i + r.step - 1) / r.step = 0&#10;⊢ pure init = forIn' (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" state_after="no goals" tactic="simp [this]">
                            <AtomNode start="(73, 5)" end="(73, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(73, 10)" end="(73, 16)">
                              <AtomNode start="(73, 10)" end="(73, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(73, 11)" end="(73, 15)">
                                <OtherNode start="(73, 11)" end="(73, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(73, 11)" end="(73, 15)" leading="" trailing="" raw_val="this" val="this"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(73, 15)" end="(73, 16)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(75, 1)" end="(81, 36)" name="forIn'_eq_forIn'_range'" full_name="Std.Range.forIn'_eq_forIn'_range'">
      <CommandDeclmodifiersNode start="(75, 1)" end="(75, 8)">
        <NullNode/>
        <NullNode start="(75, 1)" end="(75, 8)">
          <OtherNode start="(75, 1)" end="(75, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(75, 1)" end="(75, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(75, 3)" end="(75, 7)">
              <OtherNode start="(75, 3)" end="(75, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(75, 3)" end="(75, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(75, 3)" end="(75, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(75, 7)" end="(75, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(75, 9)" end="(81, 36)" name="forIn'_eq_forIn'_range'" full_name="Std.Range.forIn'_eq_forIn'_range'" _is_private_decl="False">
        <AtomNode start="(75, 9)" end="(75, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(75, 17)" end="(75, 40)">
          <IdentNode start="(75, 17)" end="(75, 40)" leading="" trailing=" " raw_val="forIn'_eq_forIn'_range'" val="forIn'_eq_forIn'_range'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(75, 41)" end="(78, 93)">
          <NullNode start="(75, 41)" end="(76, 61)">
            <OtherNode start="(75, 41)" end="(75, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(75, 41)" end="(75, 42)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(75, 42)" end="(75, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(75, 42)" end="(75, 47)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(75, 48)" end="(75, 49)">
                  <IdentNode start="(75, 48)" end="(75, 49)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(75, 49)" end="(75, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(75, 51)" end="(75, 66)">
              <AtomNode start="(75, 51)" end="(75, 52)" leading="" trailing="" val="("/>
              <NullNode start="(75, 52)" end="(75, 53)">
                <IdentNode start="(75, 52)" end="(75, 53)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(75, 54)" end="(75, 65)">
                <AtomNode start="(75, 54)" end="(75, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(75, 56)" end="(75, 65)" leading="" trailing="" raw_val="Std.Range" val="Std.Range" full_name="Std.Range" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(75, 65)" end="(75, 66)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(76, 5)" end="(76, 15)">
              <AtomNode start="(76, 5)" end="(76, 6)" leading="" trailing="" val="("/>
              <NullNode start="(76, 6)" end="(76, 10)">
                <IdentNode start="(76, 6)" end="(76, 10)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(76, 11)" end="(76, 14)">
                <AtomNode start="(76, 11)" end="(76, 12)" leading="" trailing=" " val=":"/>
                <IdentNode start="(76, 13)" end="(76, 14)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(76, 14)" end="(76, 15)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(76, 16)" end="(76, 61)">
              <AtomNode start="(76, 16)" end="(76, 17)" leading="" trailing="" val="("/>
              <NullNode start="(76, 17)" end="(76, 18)">
                <IdentNode start="(76, 17)" end="(76, 18)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(76, 19)" end="(76, 60)">
                <AtomNode start="(76, 19)" end="(76, 20)" leading="" trailing=" " val=":"/>
                <OtherNode start="(76, 21)" end="(76, 60)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(76, 21)" end="(76, 30)">
                    <AtomNode start="(76, 21)" end="(76, 22)" leading="" trailing="" val="("/>
                    <NullNode start="(76, 22)" end="(76, 23)">
                      <IdentNode start="(76, 22)" end="(76, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(76, 24)" end="(76, 29)">
                      <AtomNode start="(76, 24)" end="(76, 25)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(76, 26)" end="(76, 29)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(76, 29)" end="(76, 30)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(76, 31)" end="(76, 32)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(76, 33)" end="(76, 60)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(76, 33)" end="(76, 38)" kind="«term_∈_»">
                      <IdentNode start="(76, 33)" end="(76, 34)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(76, 35)" end="(76, 36)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(76, 37)" end="(76, 38)" leading="" trailing=" " raw_val="r" val="r"/>
                    </OtherNode>
                    <AtomNode start="(76, 39)" end="(76, 40)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(76, 41)" end="(76, 60)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(76, 41)" end="(76, 42)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(76, 43)" end="(76, 44)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(76, 45)" end="(76, 60)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(76, 45)" end="(76, 46)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(76, 47)" end="(76, 60)">
                          <OtherNode start="(76, 47)" end="(76, 60)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(76, 47)" end="(76, 48)" leading="" trailing="" val="("/>
                            <OtherNode start="(76, 48)" end="(76, 59)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(76, 48)" end="(76, 57)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(76, 58)" end="(76, 59)">
                                <IdentNode start="(76, 58)" end="(76, 59)" leading="" trailing="" raw_val="β" val="β"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(76, 59)" end="(76, 60)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(76, 60)" end="(76, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(76, 62)" end="(78, 93)">
            <AtomNode start="(76, 62)" end="(76, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(77, 5)" end="(78, 93)" kind="«term_=_»">
              <OtherNode start="(77, 5)" end="(77, 20)" kind="Lean.Parser.Term.app">
                <IdentNode start="(77, 5)" end="(77, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(77, 12)" end="(77, 20)">
                  <IdentNode start="(77, 12)" end="(77, 13)" leading="" trailing=" " raw_val="r" val="r"/>
                  <IdentNode start="(77, 14)" end="(77, 18)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(77, 19)" end="(77, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(77, 21)" end="(77, 22)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(78, 7)" end="(78, 93)" kind="Lean.Parser.Term.app">
                <IdentNode start="(78, 7)" end="(78, 13)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(78, 14)" end="(78, 93)">
                  <OtherNode start="(78, 14)" end="(78, 49)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(78, 14)" end="(78, 15)" leading="" trailing="" val="("/>
                    <OtherNode start="(78, 15)" end="(78, 48)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(78, 15)" end="(78, 26)" leading="" trailing=" " raw_val="List.range'" val="List.range'" full_name="List.range'" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(78, 27)" end="(78, 48)">
                        <IdentNode start="(78, 27)" end="(78, 34)" leading="" trailing=" " raw_val="r.start" val="r.start"/>
                        <IdentNode start="(78, 35)" end="(78, 41)" leading="" trailing=" " raw_val="r.size" val="r.size"/>
                        <IdentNode start="(78, 42)" end="(78, 48)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(78, 48)" end="(78, 49)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(78, 50)" end="(78, 54)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(78, 55)" end="(78, 93)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(78, 55)" end="(78, 56)" leading="" trailing="" val="("/>
                    <OtherNode start="(78, 56)" end="(78, 92)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(78, 56)" end="(78, 59)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(78, 60)" end="(78, 92)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(78, 60)" end="(78, 63)">
                          <IdentNode start="(78, 60)" end="(78, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(78, 62)" end="(78, 63)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(78, 64)" end="(78, 66)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(78, 67)" end="(78, 92)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(78, 67)" end="(78, 68)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(78, 69)" end="(78, 92)">
                            <IdentNode start="(78, 69)" end="(78, 70)" leading="" trailing=" " raw_val="a" val="a"/>
                            <OtherNode start="(78, 71)" end="(78, 92)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(78, 71)" end="(78, 72)" leading="" trailing="" val="("/>
                              <OtherNode start="(78, 72)" end="(78, 91)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(78, 72)" end="(78, 89)" leading="" trailing=" " raw_val="mem_of_mem_range'" val="mem_of_mem_range'" full_name="Std.Range.mem_of_mem_range'" mod_name="Init.Data.Range.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Lemmas.lean" def_start="(33, 9)" def_end="(33, 26)"/>
                                <NullNode start="(78, 90)" end="(78, 91)">
                                  <IdentNode start="(78, 90)" end="(78, 91)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(78, 91)" end="(78, 92)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(78, 92)" end="(78, 93)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(78, 94)" end="(81, 36)">
          <AtomNode start="(78, 94)" end="(78, 96)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(78, 97)" end="(81, 36)">
            <AtomNode start="(78, 97)" end="(78, 99)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(79, 3)" end="(81, 36)">
              <TacticTacticseq1IndentedNode start="(79, 3)" end="(81, 36)">
                <NullNode start="(79, 3)" end="(81, 36)">
                  <OtherNode start="(79, 3)" end="(79, 48)" kind="Lean.Parser.Tactic.Conv.conv" state_before="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;⊢ forIn' r init f = forIn' (List.range' r.start r.size r.step) init fun a h =&amp;gt; f a ⋯" state_after="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;⊢ forIn'.loop r f init r.start ⋯ ⋯ = forIn' (List.range' r.start r.size r.step) init fun a h =&amp;gt; f a ⋯" tactic="conv =&amp;gt; lhs; simp only [forIn', Range.forIn']">
                    <AtomNode start="(79, 3)" end="(79, 7)" leading="" trailing=" " val="conv"/>
                    <NullNode/>
                    <NullNode/>
                    <AtomNode start="(79, 8)" end="(79, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(79, 11)" end="(79, 48)" kind="Lean.Parser.Tactic.Conv.convSeq">
                      <OtherNode start="(79, 11)" end="(79, 48)" kind="Lean.Parser.Tactic.Conv.convSeq1Indented">
                        <NullNode start="(79, 11)" end="(79, 48)">
                          <OtherNode start="(79, 11)" end="(79, 14)" kind="Lean.Parser.Tactic.Conv.lhs">
                            <AtomNode start="(79, 11)" end="(79, 14)" leading="" trailing="" val="lhs"/>
                          </OtherNode>
                          <AtomNode start="(79, 14)" end="(79, 15)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(79, 16)" end="(79, 48)" kind="Lean.Parser.Tactic.Conv.simp">
                            <AtomNode start="(79, 16)" end="(79, 20)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(79, 21)" end="(79, 25)">
                              <AtomNode start="(79, 21)" end="(79, 25)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(79, 26)" end="(79, 48)">
                              <AtomNode start="(79, 26)" end="(79, 27)" leading="" trailing="" val="["/>
                              <NullNode start="(79, 27)" end="(79, 47)">
                                <OtherNode start="(79, 27)" end="(79, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(79, 27)" end="(79, 33)" leading="" trailing="" raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                                <AtomNode start="(79, 33)" end="(79, 34)" leading="" trailing=" " val=","/>
                                <OtherNode start="(79, 35)" end="(79, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(79, 35)" end="(79, 47)" leading="" trailing="" raw_val="Range.forIn'" val="Range.forIn'" full_name="Std.Range.forIn'" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(79, 47)" end="(79, 48)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(80, 3)" end="(80, 19)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;⊢ forIn'.loop r f init r.start ⋯ ⋯ = forIn' (List.range' r.start r.size r.step) init fun a h =&amp;gt; f a ⋯" state_after="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;⊢ forIn'.loop r f init r.start ⋯ ⋯ =&#10;    forIn' (List.range' r.start ((r.stop - r.start + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" tactic="simp only [size]">
                    <AtomNode start="(80, 3)" end="(80, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(80, 8)" end="(80, 12)">
                      <AtomNode start="(80, 8)" end="(80, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(80, 13)" end="(80, 19)">
                      <AtomNode start="(80, 13)" end="(80, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(80, 14)" end="(80, 18)">
                        <OtherNode start="(80, 14)" end="(80, 18)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(80, 14)" end="(80, 18)" leading="" trailing="" raw_val="size" val="size" full_name="Std.Range.size" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(80, 18)" end="(80, 19)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(81, 3)" end="(81, 36)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : (a : Nat) → a ∈ r → β → m (ForInStep β)&#10;⊢ forIn'.loop r f init r.start ⋯ ⋯ =&#10;    forIn' (List.range' r.start ((r.stop - r.start + r.step - 1) / r.step) r.step) init fun a h =&amp;gt; f a ⋯" state_after="no goals" tactic="rw [forIn'_loop_eq_forIn'_range']">
                    <AtomNode start="(81, 3)" end="(81, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(81, 6)" end="(81, 36)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(81, 6)" end="(81, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(81, 7)" end="(81, 35)">
                        <OtherNode start="(81, 7)" end="(81, 35)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(81, 7)" end="(81, 35)" leading="" trailing="" raw_val="forIn'_loop_eq_forIn'_range'" val="forIn'_loop_eq_forIn'_range'" full_name="_private.Init.Data.Range.Lemmas.0.Std.Range.forIn'_loop_eq_forIn'_range'" mod_name="Init.Data.Range.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Lemmas.lean" def_start="(57, 17)" def_end="(57, 45)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(81, 35)" end="(81, 36)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(83, 1)" end="(86, 45)" name="forIn_eq_forIn_range'" full_name="Std.Range.forIn_eq_forIn_range'">
      <CommandDeclmodifiersNode start="(83, 1)" end="(83, 8)">
        <NullNode/>
        <NullNode start="(83, 1)" end="(83, 8)">
          <OtherNode start="(83, 1)" end="(83, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(83, 1)" end="(83, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(83, 3)" end="(83, 7)">
              <OtherNode start="(83, 3)" end="(83, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(83, 3)" end="(83, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(83, 3)" end="(83, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(83, 7)" end="(83, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(83, 9)" end="(86, 45)" name="forIn_eq_forIn_range'" full_name="Std.Range.forIn_eq_forIn_range'" _is_private_decl="False">
        <AtomNode start="(83, 9)" end="(83, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(83, 17)" end="(83, 38)">
          <IdentNode start="(83, 17)" end="(83, 38)" leading="" trailing=" " raw_val="forIn_eq_forIn_range'" val="forIn_eq_forIn_range'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(83, 39)" end="(85, 70)">
          <NullNode start="(83, 39)" end="(84, 47)">
            <OtherNode start="(83, 39)" end="(83, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(83, 39)" end="(83, 40)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(83, 40)" end="(83, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(83, 40)" end="(83, 45)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(83, 46)" end="(83, 47)">
                  <IdentNode start="(83, 46)" end="(83, 47)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(83, 47)" end="(83, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(83, 49)" end="(83, 64)">
              <AtomNode start="(83, 49)" end="(83, 50)" leading="" trailing="" val="("/>
              <NullNode start="(83, 50)" end="(83, 51)">
                <IdentNode start="(83, 50)" end="(83, 51)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(83, 52)" end="(83, 63)">
                <AtomNode start="(83, 52)" end="(83, 53)" leading="" trailing=" " val=":"/>
                <IdentNode start="(83, 54)" end="(83, 63)" leading="" trailing="" raw_val="Std.Range" val="Std.Range" full_name="Std.Range" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(83, 63)" end="(83, 64)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(84, 5)" end="(84, 15)">
              <AtomNode start="(84, 5)" end="(84, 6)" leading="" trailing="" val="("/>
              <NullNode start="(84, 6)" end="(84, 10)">
                <IdentNode start="(84, 6)" end="(84, 10)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(84, 11)" end="(84, 14)">
                <AtomNode start="(84, 11)" end="(84, 12)" leading="" trailing=" " val=":"/>
                <IdentNode start="(84, 13)" end="(84, 14)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(84, 14)" end="(84, 15)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(84, 16)" end="(84, 47)">
              <AtomNode start="(84, 16)" end="(84, 17)" leading="" trailing="" val="("/>
              <NullNode start="(84, 17)" end="(84, 18)">
                <IdentNode start="(84, 17)" end="(84, 18)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(84, 19)" end="(84, 46)">
                <AtomNode start="(84, 19)" end="(84, 20)" leading="" trailing=" " val=":"/>
                <OtherNode start="(84, 21)" end="(84, 46)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(84, 21)" end="(84, 24)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(84, 25)" end="(84, 26)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(84, 27)" end="(84, 46)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(84, 27)" end="(84, 28)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(84, 29)" end="(84, 30)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(84, 31)" end="(84, 46)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(84, 31)" end="(84, 32)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(84, 33)" end="(84, 46)">
                        <OtherNode start="(84, 33)" end="(84, 46)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(84, 33)" end="(84, 34)" leading="" trailing="" val="("/>
                          <OtherNode start="(84, 34)" end="(84, 45)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(84, 34)" end="(84, 43)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                            <NullNode start="(84, 44)" end="(84, 45)">
                              <IdentNode start="(84, 44)" end="(84, 45)" leading="" trailing="" raw_val="β" val="β"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(84, 45)" end="(84, 46)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(84, 46)" end="(84, 47)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(84, 48)" end="(85, 70)">
            <AtomNode start="(84, 48)" end="(84, 49)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(85, 5)" end="(85, 70)" kind="«term_=_»">
              <OtherNode start="(85, 5)" end="(85, 19)" kind="Lean.Parser.Term.app">
                <IdentNode start="(85, 5)" end="(85, 10)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(85, 11)" end="(85, 19)">
                  <IdentNode start="(85, 11)" end="(85, 12)" leading="" trailing=" " raw_val="r" val="r"/>
                  <IdentNode start="(85, 13)" end="(85, 17)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(85, 18)" end="(85, 19)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(85, 20)" end="(85, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(85, 22)" end="(85, 70)" kind="Lean.Parser.Term.app">
                <IdentNode start="(85, 22)" end="(85, 27)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(85, 28)" end="(85, 70)">
                  <OtherNode start="(85, 28)" end="(85, 63)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(85, 28)" end="(85, 29)" leading="" trailing="" val="("/>
                    <OtherNode start="(85, 29)" end="(85, 62)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(85, 29)" end="(85, 40)" leading="" trailing=" " raw_val="List.range'" val="List.range'" full_name="List.range'" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(85, 41)" end="(85, 62)">
                        <IdentNode start="(85, 41)" end="(85, 48)" leading="" trailing=" " raw_val="r.start" val="r.start"/>
                        <IdentNode start="(85, 49)" end="(85, 55)" leading="" trailing=" " raw_val="r.size" val="r.size"/>
                        <IdentNode start="(85, 56)" end="(85, 62)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(85, 62)" end="(85, 63)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(85, 64)" end="(85, 68)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(85, 69)" end="(85, 70)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(85, 71)" end="(86, 45)">
          <AtomNode start="(85, 71)" end="(85, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(85, 74)" end="(86, 45)">
            <AtomNode start="(85, 74)" end="(85, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(86, 3)" end="(86, 45)">
              <TacticTacticseq1IndentedNode start="(86, 3)" end="(86, 45)">
                <NullNode start="(86, 3)" end="(86, 45)">
                  <OtherNode start="(86, 3)" end="(86, 45)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;inst✝ : Monad m&#10;r : Range&#10;init : β&#10;f : Nat → β → m (ForInStep β)&#10;⊢ forIn r init f = forIn (List.range' r.start r.size r.step) init f" state_after="no goals" tactic="simp only [forIn, forIn'_eq_forIn'_range']">
                    <AtomNode start="(86, 3)" end="(86, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(86, 8)" end="(86, 12)">
                      <AtomNode start="(86, 8)" end="(86, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(86, 13)" end="(86, 45)">
                      <AtomNode start="(86, 13)" end="(86, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(86, 14)" end="(86, 44)">
                        <OtherNode start="(86, 14)" end="(86, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(86, 14)" end="(86, 19)" leading="" trailing="" raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                        <AtomNode start="(86, 19)" end="(86, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(86, 21)" end="(86, 44)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(86, 21)" end="(86, 44)" leading="" trailing="" raw_val="forIn'_eq_forIn'_range'" val="forIn'_eq_forIn'_range'" full_name="Std.Range.forIn'_eq_forIn'_range'" mod_name="Init.Data.Range.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Lemmas.lean" def_start="(75, 17)" def_end="(75, 40)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(86, 44)" end="(86, 45)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(88, 1)" end="(99, 16)" name="forM_loop_eq_forM_range'" full_name="Std.Range.forM_loop_eq_forM_range'">
      <CommandDeclmodifiersNode start="(88, 1)" end="(88, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(88, 1)" end="(88, 8)">
          <CommandPrivateNode start="(88, 1)" end="(88, 8)">
            <AtomNode start="(88, 1)" end="(88, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(88, 9)" end="(99, 16)" name="forM_loop_eq_forM_range'" full_name="Std.Range.forM_loop_eq_forM_range'" _is_private_decl="True">
        <AtomNode start="(88, 9)" end="(88, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(88, 17)" end="(88, 41)">
          <IdentNode start="(88, 17)" end="(88, 41)" leading="" trailing=" " raw_val="forM_loop_eq_forM_range'" val="forM_loop_eq_forM_range'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(88, 42)" end="(89, 89)">
          <NullNode start="(88, 42)" end="(88, 87)">
            <OtherNode start="(88, 42)" end="(88, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(88, 42)" end="(88, 43)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(88, 43)" end="(88, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(88, 43)" end="(88, 48)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(88, 49)" end="(88, 50)">
                  <IdentNode start="(88, 49)" end="(88, 50)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(88, 50)" end="(88, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(88, 52)" end="(88, 67)">
              <AtomNode start="(88, 52)" end="(88, 53)" leading="" trailing="" val="("/>
              <NullNode start="(88, 53)" end="(88, 54)">
                <IdentNode start="(88, 53)" end="(88, 54)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(88, 55)" end="(88, 66)">
                <AtomNode start="(88, 55)" end="(88, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(88, 57)" end="(88, 66)" leading="" trailing="" raw_val="Std.Range" val="Std.Range" full_name="Std.Range" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(88, 66)" end="(88, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(88, 68)" end="(88, 87)">
              <AtomNode start="(88, 68)" end="(88, 69)" leading="" trailing="" val="("/>
              <NullNode start="(88, 69)" end="(88, 70)">
                <IdentNode start="(88, 69)" end="(88, 70)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(88, 71)" end="(88, 86)">
                <AtomNode start="(88, 71)" end="(88, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 73)" end="(88, 86)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(88, 73)" end="(88, 76)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(88, 77)" end="(88, 78)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(88, 79)" end="(88, 86)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(88, 79)" end="(88, 80)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(88, 81)" end="(88, 86)">
                      <IdentNode start="(88, 81)" end="(88, 86)" leading="" trailing="" raw_val="PUnit" val="PUnit" full_name="PUnit" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(88, 86)" end="(88, 87)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(88, 88)" end="(89, 89)">
            <AtomNode start="(88, 88)" end="(88, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(89, 5)" end="(89, 89)" kind="«term_=_»">
              <OtherNode start="(89, 5)" end="(89, 20)" kind="Lean.Parser.Term.app">
                <IdentNode start="(89, 5)" end="(89, 14)" leading="" trailing=" " raw_val="forM.loop" val="forM.loop" full_name="Std.Range.forM.loop" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
                <NullNode start="(89, 15)" end="(89, 20)">
                  <IdentNode start="(89, 15)" end="(89, 16)" leading="" trailing=" " raw_val="r" val="r"/>
                  <IdentNode start="(89, 17)" end="(89, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(89, 19)" end="(89, 20)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(89, 21)" end="(89, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(89, 23)" end="(89, 89)" kind="Lean.Parser.Term.app">
                <IdentNode start="(89, 23)" end="(89, 27)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <NullNode start="(89, 28)" end="(89, 89)">
                  <OtherNode start="(89, 28)" end="(89, 87)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(89, 28)" end="(89, 29)" leading="" trailing="" val="("/>
                    <OtherNode start="(89, 29)" end="(89, 86)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(89, 29)" end="(89, 40)" leading="" trailing=" " raw_val="List.range'" val="List.range'" full_name="List.range'" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(89, 41)" end="(89, 86)">
                        <IdentNode start="(89, 41)" end="(89, 42)" leading="" trailing=" " raw_val="i" val="i"/>
                        <OtherNode start="(89, 43)" end="(89, 79)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(89, 43)" end="(89, 44)" leading="" trailing="" val="("/>
                          <OtherNode start="(89, 44)" end="(89, 78)" kind="«term_/_»">
                            <OtherNode start="(89, 44)" end="(89, 69)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(89, 44)" end="(89, 45)" leading="" trailing="" val="("/>
                              <OtherNode start="(89, 45)" end="(89, 68)" kind="«term_-_»">
                                <OtherNode start="(89, 45)" end="(89, 64)" kind="«term_+_»">
                                  <OtherNode start="(89, 45)" end="(89, 55)" kind="«term_-_»">
                                    <IdentNode start="(89, 45)" end="(89, 51)" leading="" trailing=" " raw_val="r.stop" val="r.stop"/>
                                    <AtomNode start="(89, 52)" end="(89, 53)" leading="" trailing=" " val="-"/>
                                    <IdentNode start="(89, 54)" end="(89, 55)" leading="" trailing=" " raw_val="i" val="i"/>
                                  </OtherNode>
                                  <AtomNode start="(89, 56)" end="(89, 57)" leading="" trailing=" " val="+"/>
                                  <IdentNode start="(89, 58)" end="(89, 64)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                </OtherNode>
                                <AtomNode start="(89, 65)" end="(89, 66)" leading="" trailing=" " val="-"/>
                                <OtherNode start="(89, 67)" end="(89, 68)" kind="num">
                                  <AtomNode start="(89, 67)" end="(89, 68)" leading="" trailing="" val="1"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(89, 68)" end="(89, 69)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <AtomNode start="(89, 70)" end="(89, 71)" leading="" trailing=" " val="/"/>
                            <IdentNode start="(89, 72)" end="(89, 78)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                          </OtherNode>
                          <AtomNode start="(89, 78)" end="(89, 79)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <IdentNode start="(89, 80)" end="(89, 86)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(89, 86)" end="(89, 87)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(89, 88)" end="(89, 89)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(89, 90)" end="(99, 16)">
          <AtomNode start="(89, 90)" end="(89, 92)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(89, 93)" end="(99, 16)">
            <AtomNode start="(89, 93)" end="(89, 95)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(90, 3)" end="(99, 16)">
              <TacticTacticseq1IndentedNode start="(90, 3)" end="(99, 16)">
                <NullNode start="(90, 3)" end="(99, 16)">
                  <OtherNode start="(90, 3)" end="(90, 23)" kind="Lean.Parser.Tactic.tacticHave_" state_before="m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;⊢ forM.loop r f i = forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f" state_after="m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;⊢ forM.loop r f i = forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f" tactic="have w := r.step_pos">
                    <AtomNode start="(90, 3)" end="(90, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(90, 8)" end="(90, 23)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(90, 8)" end="(90, 23)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(90, 8)" end="(90, 9)" kind="Lean.Parser.Term.haveId">
                          <IdentNode start="(90, 8)" end="(90, 9)" leading="" trailing=" " raw_val="w" val="w"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(90, 10)" end="(90, 12)" leading="" trailing=" " val=":="/>
                        <IdentNode start="(90, 13)" end="(90, 23)" leading="" trailing="&#10;  " raw_val="r.step_pos" val="r.step_pos"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(91, 3)" end="(91, 17)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;⊢ forM.loop r f i = forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f" state_after="m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;⊢ (if i &amp;lt; r.stop then do&#10;      f i&#10;      have this : 0 &amp;lt; r.step := ⋯&#10;      forM.loop r f (i + r.step)&#10;    else pure PUnit.unit) =&#10;    forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f" tactic="rw [forM.loop]">
                    <AtomNode start="(91, 3)" end="(91, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(91, 6)" end="(91, 17)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(91, 6)" end="(91, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(91, 7)" end="(91, 16)">
                        <OtherNode start="(91, 7)" end="(91, 16)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(91, 7)" end="(91, 16)" leading="" trailing="" raw_val="forM.loop" val="forM.loop" full_name="Std.Range.forM.loop" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(91, 16)" end="(91, 17)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(92, 3)" end="(92, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;⊢ (if i &amp;lt; r.stop then do&#10;      f i&#10;      have this : 0 &amp;lt; r.step := ⋯&#10;      forM.loop r f (i + r.step)&#10;    else pure PUnit.unit) =&#10;    forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f" state_after="case isTrue&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;⊢ (do&#10;      f i&#10;      have this : 0 &amp;lt; r.step := ⋯&#10;      forM.loop r f (i + r.step)) =&#10;    forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f&#10;&#10;case isFalse&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;⊢ pure PUnit.unit = forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(92, 3)" end="(92, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(92, 3)" end="(92, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(92, 9)" end="(92, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(92, 13)" end="(92, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(92, 13)" end="(92, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(92, 22)" end="(92, 23)">
                        <LeanBinderidentNode start="(92, 22)" end="(92, 23)">
                          <IdentNode start="(92, 22)" end="(92, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(93, 3)" end="(96, 34)" kind="Lean.cdot" state_before="case isTrue&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;⊢ (do&#10;      f i&#10;      have this : 0 &amp;lt; r.step := ⋯&#10;      forM.loop r f (i + r.step)) =&#10;    forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f&#10;&#10;case isFalse&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;⊢ pure PUnit.unit = forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f" state_after="case isFalse&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;⊢ pure PUnit.unit = forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f" tactic="· simp [size_eq r h, List.range'_succ, List.forM_cons]&#10;  congr 1&#10;  funext&#10;  rw [forM_loop_eq_forM_range']">
                    <OtherNode start="(93, 3)" end="(93, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(93, 3)" end="(93, 4)" kind="patternIgnore">
                        <OtherNode start="(93, 3)" end="(93, 4)" kind="token.«· »">
                          <AtomNode start="(93, 3)" end="(93, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(93, 5)" end="(96, 34)">
                      <TacticTacticseq1IndentedNode start="(93, 5)" end="(96, 34)">
                        <NullNode start="(93, 5)" end="(96, 34)">
                          <OtherNode start="(93, 5)" end="(93, 57)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;⊢ (do&#10;      f i&#10;      have this : 0 &amp;lt; r.step := ⋯&#10;      forM.loop r f (i + r.step)) =&#10;    forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f" state_after="case isTrue&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;⊢ (do&#10;      f i&#10;      forM.loop r f (i + r.step)) =&#10;    do&#10;    f i&#10;    forM (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) f" tactic="simp [size_eq r h, List.range'_succ, List.forM_cons]">
                            <AtomNode start="(93, 5)" end="(93, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(93, 10)" end="(93, 57)">
                              <AtomNode start="(93, 10)" end="(93, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(93, 11)" end="(93, 56)">
                                <OtherNode start="(93, 11)" end="(93, 22)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(93, 11)" end="(93, 22)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(93, 11)" end="(93, 18)" leading="" trailing=" " raw_val="size_eq" val="size_eq" full_name="_private.Init.Data.Range.Lemmas.0.Std.Range.size_eq" mod_name="Init.Data.Range.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Lemmas.lean" def_start="(37, 17)" def_end="(37, 24)"/>
                                    <NullNode start="(93, 19)" end="(93, 22)">
                                      <IdentNode start="(93, 19)" end="(93, 20)" leading="" trailing=" " raw_val="r" val="r"/>
                                      <IdentNode start="(93, 21)" end="(93, 22)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(93, 22)" end="(93, 23)" leading="" trailing=" " val=","/>
                                <OtherNode start="(93, 24)" end="(93, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(93, 24)" end="(93, 40)" leading="" trailing="" raw_val="List.range'_succ" val="List.range'_succ" full_name="List.range'_succ" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                                </OtherNode>
                                <AtomNode start="(93, 40)" end="(93, 41)" leading="" trailing=" " val=","/>
                                <OtherNode start="(93, 42)" end="(93, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(93, 42)" end="(93, 56)" leading="" trailing="" raw_val="List.forM_cons" val="List.forM_cons" full_name="List.forM_cons" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(93, 56)" end="(93, 57)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(94, 5)" end="(94, 12)" kind="Lean.Parser.Tactic.congr" state_before="case isTrue&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;⊢ (do&#10;      f i&#10;      forM.loop r f (i + r.step)) =&#10;    do&#10;    f i&#10;    forM (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) f" state_after="case isTrue.e_a&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;⊢ (fun x =&amp;gt; forM.loop r f (i + r.step)) = fun x =&amp;gt;&#10;    forM (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) f" tactic="congr 1">
                            <AtomNode start="(94, 5)" end="(94, 10)" leading="" trailing=" " val="congr"/>
                            <NullNode start="(94, 11)" end="(94, 12)">
                              <OtherNode start="(94, 11)" end="(94, 12)" kind="num">
                                <AtomNode start="(94, 11)" end="(94, 12)" leading="" trailing="&#10;    " val="1"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(95, 5)" end="(95, 11)" kind="tacticFunext___" state_before="case isTrue.e_a&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;⊢ (fun x =&amp;gt; forM.loop r f (i + r.step)) = fun x =&amp;gt;&#10;    forM (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) f" state_after="case isTrue.e_a.h&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;x✝ : PUnit&#10;⊢ forM.loop r f (i + r.step) = forM (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) f" tactic="funext">
                            <AtomNode start="(95, 5)" end="(95, 11)" leading="" trailing="&#10;    " val="funext"/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(96, 5)" end="(96, 34)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue.e_a.h&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : i &amp;lt; r.stop&#10;x✝ : PUnit&#10;⊢ forM.loop r f (i + r.step) = forM (List.range' (i + r.step) ((r.stop - (i + r.step) + r.step - 1) / r.step) r.step) f" state_after="no goals" tactic="rw [forM_loop_eq_forM_range']">
                            <AtomNode start="(96, 5)" end="(96, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(96, 8)" end="(96, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(96, 8)" end="(96, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(96, 9)" end="(96, 33)">
                                <OtherNode start="(96, 9)" end="(96, 33)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(96, 9)" end="(96, 33)" leading="" trailing="" raw_val="forM_loop_eq_forM_range'" val="forM_loop_eq_forM_range'" full_name="PSigma.Lex.left" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(96, 33)" end="(96, 34)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(97, 3)" end="(99, 16)" kind="Lean.cdot" state_before="case isFalse&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;⊢ pure PUnit.unit = forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f" state_after="no goals" tactic="· have : (r.stop - i + r.step - 1) / r.step = 0 := by&#10;    rw [Nat.div_eq_iff] &amp;lt;;&amp;gt; omega&#10;  simp [this]">
                    <OtherNode start="(97, 3)" end="(97, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(97, 3)" end="(97, 4)" kind="patternIgnore">
                        <OtherNode start="(97, 3)" end="(97, 4)" kind="token.«· »">
                          <AtomNode start="(97, 3)" end="(97, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(97, 5)" end="(99, 16)">
                      <TacticTacticseq1IndentedNode start="(97, 5)" end="(99, 16)">
                        <NullNode start="(97, 5)" end="(99, 16)">
                          <OtherNode start="(97, 5)" end="(98, 36)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case isFalse&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;⊢ pure PUnit.unit = forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f" state_after="case isFalse&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;this : (r.stop - i + r.step - 1) / r.step = 0&#10;⊢ pure PUnit.unit = forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f" tactic="have : (r.stop - i + r.step - 1) / r.step = 0 := by&#10;  rw [Nat.div_eq_iff] &amp;lt;;&amp;gt; omega">
                            <AtomNode start="(97, 5)" end="(97, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(97, 10)" end="(98, 36)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(97, 10)" end="(98, 36)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(97, 10)" end="(97, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(97, 10)" end="(97, 10)" kind="hygieneInfo">
                                    <IdentNode start="(97, 10)" end="(97, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(97, 10)" end="(97, 50)">
                                  <TermTypespecNode start="(97, 10)" end="(97, 50)">
                                    <AtomNode start="(97, 10)" end="(97, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(97, 12)" end="(97, 50)" kind="«term_=_»">
                                      <OtherNode start="(97, 12)" end="(97, 46)" kind="«term_/_»">
                                        <OtherNode start="(97, 12)" end="(97, 37)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(97, 12)" end="(97, 13)" leading="" trailing="" val="("/>
                                          <OtherNode start="(97, 13)" end="(97, 36)" kind="«term_-_»">
                                            <OtherNode start="(97, 13)" end="(97, 32)" kind="«term_+_»">
                                              <OtherNode start="(97, 13)" end="(97, 23)" kind="«term_-_»">
                                                <IdentNode start="(97, 13)" end="(97, 19)" leading="" trailing=" " raw_val="r.stop" val="r.stop"/>
                                                <AtomNode start="(97, 20)" end="(97, 21)" leading="" trailing=" " val="-"/>
                                                <IdentNode start="(97, 22)" end="(97, 23)" leading="" trailing=" " raw_val="i" val="i"/>
                                              </OtherNode>
                                              <AtomNode start="(97, 24)" end="(97, 25)" leading="" trailing=" " val="+"/>
                                              <IdentNode start="(97, 26)" end="(97, 32)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                            </OtherNode>
                                            <AtomNode start="(97, 33)" end="(97, 34)" leading="" trailing=" " val="-"/>
                                            <OtherNode start="(97, 35)" end="(97, 36)" kind="num">
                                              <AtomNode start="(97, 35)" end="(97, 36)" leading="" trailing="" val="1"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(97, 36)" end="(97, 37)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                        <AtomNode start="(97, 38)" end="(97, 39)" leading="" trailing=" " val="/"/>
                                        <IdentNode start="(97, 40)" end="(97, 46)" leading="" trailing=" " raw_val="r.step" val="r.step"/>
                                      </OtherNode>
                                      <AtomNode start="(97, 47)" end="(97, 48)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(97, 49)" end="(97, 50)" kind="num">
                                        <AtomNode start="(97, 49)" end="(97, 50)" leading="" trailing=" " val="0"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(97, 51)" end="(97, 53)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(97, 54)" end="(98, 36)">
                                  <AtomNode start="(97, 54)" end="(97, 56)" leading="" trailing="&#10;      " val="by"/>
                                  <TacticTacticseqNode start="(98, 7)" end="(98, 36)">
                                    <TacticTacticseq1IndentedNode start="(98, 7)" end="(98, 36)">
                                      <NullNode start="(98, 7)" end="(98, 36)">
                                        <OtherNode start="(98, 7)" end="(98, 36)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;⊢ (r.stop - i + r.step - 1) / r.step = 0" state_after="no goals" tactic="rw [Nat.div_eq_iff] &amp;lt;;&amp;gt; omega">
                                          <OtherNode start="(98, 7)" end="(98, 26)" kind="Lean.Parser.Tactic.rwSeq">
                                            <AtomNode start="(98, 7)" end="(98, 9)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(98, 10)" end="(98, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(98, 10)" end="(98, 11)" leading="" trailing="" val="["/>
                                              <NullNode start="(98, 11)" end="(98, 25)">
                                                <OtherNode start="(98, 11)" end="(98, 25)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <IdentNode start="(98, 11)" end="(98, 25)" leading="" trailing="" raw_val="Nat.div_eq_iff" val="Nat.div_eq_iff" full_name="Nat.div_eq_iff" mod_name="Init.Data.Nat.Div.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Div/Lemmas.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(98, 25)" end="(98, 26)" leading="" trailing=" " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <AtomNode start="(98, 27)" end="(98, 30)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                          <OtherNode start="(98, 31)" end="(98, 36)" kind="Lean.Parser.Tactic.omega">
                                            <AtomNode start="(98, 31)" end="(98, 36)" leading="" trailing="&#10;    " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(99, 5)" end="(99, 16)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;m : Type u_1 → Type u_2&#10;i : Nat&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;w : 0 &amp;lt; r.step&#10;h : ¬i &amp;lt; r.stop&#10;this : (r.stop - i + r.step - 1) / r.step = 0&#10;⊢ pure PUnit.unit = forM (List.range' i ((r.stop - i + r.step - 1) / r.step) r.step) f" state_after="no goals" tactic="simp [this]">
                            <AtomNode start="(99, 5)" end="(99, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(99, 10)" end="(99, 16)">
                              <AtomNode start="(99, 10)" end="(99, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(99, 11)" end="(99, 15)">
                                <OtherNode start="(99, 11)" end="(99, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(99, 11)" end="(99, 15)" leading="" trailing="" raw_val="this" val="this"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(99, 15)" end="(99, 16)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(101, 1)" end="(103, 63)" name="forM_eq_forM_range'" full_name="Std.Range.forM_eq_forM_range'">
      <CommandDeclmodifiersNode start="(101, 1)" end="(101, 8)">
        <NullNode/>
        <NullNode start="(101, 1)" end="(101, 8)">
          <OtherNode start="(101, 1)" end="(101, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(101, 1)" end="(101, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(101, 3)" end="(101, 7)">
              <OtherNode start="(101, 3)" end="(101, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(101, 3)" end="(101, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(101, 3)" end="(101, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(101, 7)" end="(101, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(101, 9)" end="(103, 63)" name="forM_eq_forM_range'" full_name="Std.Range.forM_eq_forM_range'" _is_private_decl="False">
        <AtomNode start="(101, 9)" end="(101, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(101, 17)" end="(101, 36)">
          <IdentNode start="(101, 17)" end="(101, 36)" leading="" trailing=" " raw_val="forM_eq_forM_range'" val="forM_eq_forM_range'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(101, 37)" end="(102, 58)">
          <NullNode start="(101, 37)" end="(101, 82)">
            <OtherNode start="(101, 37)" end="(101, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(101, 37)" end="(101, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(101, 38)" end="(101, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(101, 38)" end="(101, 43)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(101, 44)" end="(101, 45)">
                  <IdentNode start="(101, 44)" end="(101, 45)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(101, 45)" end="(101, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(101, 47)" end="(101, 62)">
              <AtomNode start="(101, 47)" end="(101, 48)" leading="" trailing="" val="("/>
              <NullNode start="(101, 48)" end="(101, 49)">
                <IdentNode start="(101, 48)" end="(101, 49)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(101, 50)" end="(101, 61)">
                <AtomNode start="(101, 50)" end="(101, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(101, 52)" end="(101, 61)" leading="" trailing="" raw_val="Std.Range" val="Std.Range" full_name="Std.Range" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(101, 61)" end="(101, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(101, 63)" end="(101, 82)">
              <AtomNode start="(101, 63)" end="(101, 64)" leading="" trailing="" val="("/>
              <NullNode start="(101, 64)" end="(101, 65)">
                <IdentNode start="(101, 64)" end="(101, 65)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(101, 66)" end="(101, 81)">
                <AtomNode start="(101, 66)" end="(101, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(101, 68)" end="(101, 81)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(101, 68)" end="(101, 71)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(101, 72)" end="(101, 73)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(101, 74)" end="(101, 81)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(101, 74)" end="(101, 75)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(101, 76)" end="(101, 81)">
                      <IdentNode start="(101, 76)" end="(101, 81)" leading="" trailing="" raw_val="PUnit" val="PUnit" full_name="PUnit" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(101, 81)" end="(101, 82)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(101, 83)" end="(102, 58)">
            <AtomNode start="(101, 83)" end="(101, 84)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(102, 5)" end="(102, 58)" kind="«term_=_»">
              <OtherNode start="(102, 5)" end="(102, 13)" kind="Lean.Parser.Term.app">
                <IdentNode start="(102, 5)" end="(102, 9)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <NullNode start="(102, 10)" end="(102, 13)">
                  <IdentNode start="(102, 10)" end="(102, 11)" leading="" trailing=" " raw_val="r" val="r"/>
                  <IdentNode start="(102, 12)" end="(102, 13)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(102, 14)" end="(102, 15)" leading="" trailing=" " val="="/>
              <OtherNode start="(102, 16)" end="(102, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(102, 16)" end="(102, 20)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <NullNode start="(102, 21)" end="(102, 58)">
                  <OtherNode start="(102, 21)" end="(102, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(102, 21)" end="(102, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(102, 22)" end="(102, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(102, 22)" end="(102, 33)" leading="" trailing=" " raw_val="List.range'" val="List.range'" full_name="List.range'" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(102, 34)" end="(102, 55)">
                        <IdentNode start="(102, 34)" end="(102, 41)" leading="" trailing=" " raw_val="r.start" val="r.start"/>
                        <IdentNode start="(102, 42)" end="(102, 48)" leading="" trailing=" " raw_val="r.size" val="r.size"/>
                        <IdentNode start="(102, 49)" end="(102, 55)" leading="" trailing="" raw_val="r.step" val="r.step"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(102, 55)" end="(102, 56)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(102, 57)" end="(102, 58)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(102, 59)" end="(103, 63)">
          <AtomNode start="(102, 59)" end="(102, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(102, 62)" end="(103, 63)">
            <AtomNode start="(102, 62)" end="(102, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(103, 3)" end="(103, 63)">
              <TacticTacticseq1IndentedNode start="(103, 3)" end="(103, 63)">
                <NullNode start="(103, 3)" end="(103, 63)">
                  <OtherNode start="(103, 3)" end="(103, 63)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;inst✝ : Monad m&#10;r : Range&#10;f : Nat → m PUnit&#10;⊢ forM r f = forM (List.range' r.start r.size r.step) f" state_after="no goals" tactic="simp only [forM, Range.forM, forM_loop_eq_forM_range', size]">
                    <AtomNode start="(103, 3)" end="(103, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(103, 8)" end="(103, 12)">
                      <AtomNode start="(103, 8)" end="(103, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(103, 13)" end="(103, 63)">
                      <AtomNode start="(103, 13)" end="(103, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(103, 14)" end="(103, 62)">
                        <OtherNode start="(103, 14)" end="(103, 18)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(103, 14)" end="(103, 18)" leading="" trailing="" raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(103, 18)" end="(103, 19)" leading="" trailing=" " val=","/>
                        <OtherNode start="(103, 20)" end="(103, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(103, 20)" end="(103, 30)" leading="" trailing="" raw_val="Range.forM" val="Range.forM" full_name="Std.Range.forM" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(103, 30)" end="(103, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(103, 32)" end="(103, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(103, 32)" end="(103, 56)" leading="" trailing="" raw_val="forM_loop_eq_forM_range'" val="forM_loop_eq_forM_range'" full_name="_private.Init.Data.Range.Lemmas.0.Std.Range.forM_loop_eq_forM_range'" mod_name="Init.Data.Range.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Lemmas.lean" def_start="(88, 17)" def_end="(88, 41)"/>
                        </OtherNode>
                        <AtomNode start="(103, 56)" end="(103, 57)" leading="" trailing=" " val=","/>
                        <OtherNode start="(103, 58)" end="(103, 62)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(103, 58)" end="(103, 62)" leading="" trailing="" raw_val="size" val="size" full_name="Std.Range.size" mod_name="Init.Data.Range.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Range/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(103, 62)" end="(103, 63)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(105, 1)" end="(105, 14)" name="Std.Range">
      <AtomNode start="(105, 1)" end="(105, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(105, 5)" end="(105, 14)">
        <IdentNode start="(105, 5)" end="(105, 14)" leading="" trailing="&#10;" raw_val="Std.Range" val="Std.Range"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(14, 1)" end="(18, 3)" text="# Lemmas about `Std.Range`&#10;&#10;We provide lemmas rewriting for loops over `Std.Range` in terms of `List.range'`.&#10;-/"/>
    <Comment start="(22, 1)" end="(22, 91)" text="Generalization of `mem_of_mem_range'` used in `forIn'_loop_eq_forIn'_range'` below. -/"/>
    <Comment start="(41, 31)" end="(42, 5)" text="-- Not sure this case split is strictly necessary.&#10;    "/>
  </Comments>
</TracedFile>
