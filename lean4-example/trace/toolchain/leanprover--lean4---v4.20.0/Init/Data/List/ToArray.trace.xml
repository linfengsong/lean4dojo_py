<TracedFile path="src/lean/Init/Data/List/ToArray.lean" md5="1340b46f27ce9a42e13bad53ae2d698a">
  <FileNode start="(1, 1)" end="(711, 9)">
    <ModuleHeaderNode start="(6, 1)" end="(13, 33)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(13, 33)">
        <ModuleImportNode start="(9, 1)" end="(9, 27)" module="Init.Data.List.Impl" path="src/lean/Init/Data/List/Impl.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 27)" leading="" trailing="&#10;" raw_val="Init.Data.List.Impl" val="Init.Data.List.Impl"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 32)" module="Init.Data.List.Nat.Erase" path="src/lean/Init/Data/List/Nat/Erase.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 32)" leading="" trailing="&#10;" raw_val="Init.Data.List.Nat.Erase" val="Init.Data.List.Nat.Erase"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 30)" module="Init.Data.List.Monadic" path="src/lean/Init/Data/List/Monadic.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 30)" leading="" trailing="&#10;" raw_val="Init.Data.List.Monadic" val="Init.Data.List.Monadic"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(12, 1)" end="(12, 36)" module="Init.Data.List.Nat.InsertIdx" path="src/lean/Init/Data/List/Nat/InsertIdx.lean">
          <NullNode/>
          <AtomNode start="(12, 1)" end="(12, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(12, 8)" end="(12, 36)" leading="" trailing="&#10;" raw_val="Init.Data.List.Nat.InsertIdx" val="Init.Data.List.Nat.InsertIdx"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(13, 1)" end="(13, 33)" module="Init.Data.Array.Lex.Basic" path="src/lean/Init/Data/Array/Lex/Basic.lean">
          <NullNode/>
          <AtomNode start="(13, 1)" end="(13, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(13, 8)" end="(13, 33)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.Array.Lex.Basic" val="Init.Data.Array.Lex.Basic"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(15, 1)" end="(18, 3)" comment="### Lemmas about `List.toArray`.&#10;&#10;We prefer to pull `List.toArray` outwards past `Array` operations.&#10;-/">
      <AtomNode start="(15, 1)" end="(15, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(15, 5)" end="(18, 3)" leading="" trailing="&#10;&#10;" val="### Lemmas about `List.toArray`.&#10;&#10;We prefer to pull `List.toArray` outwards past `Array` operations.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(20, 1)" end="(20, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(20, 1)" end="(20, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(20, 12)" end="(20, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(20, 33)" end="(20, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;-- TODO: restore after an update-stage0&#10;-- set_option linter.indexVariables true -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(24, 1)" end="(24, 16)" name="Array">
      <AtomNode start="(24, 1)" end="(24, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(24, 11)" end="(24, 16)" leading="" trailing="&#10;&#10;" raw_val="Array" val="Array"/>
    </CommandNamespaceNode>
    <CommandDeclarationNode start="(26, 1)" end="(27, 51)" name="toList_set" full_name="Array.toList_set">
      <CommandDeclmodifiersNode start="(26, 1)" end="(26, 8)">
        <NullNode/>
        <NullNode start="(26, 1)" end="(26, 8)">
          <OtherNode start="(26, 1)" end="(26, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(26, 1)" end="(26, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(26, 3)" end="(26, 7)">
              <OtherNode start="(26, 3)" end="(26, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(26, 3)" end="(26, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(26, 3)" end="(26, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(26, 7)" end="(26, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(26, 9)" end="(27, 51)" name="toList_set" full_name="Array.toList_set" _is_private_decl="False">
        <AtomNode start="(26, 9)" end="(26, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(26, 17)" end="(26, 27)">
          <IdentNode start="(26, 17)" end="(26, 27)" leading="" trailing=" " raw_val="toList_set" val="toList_set"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(26, 28)" end="(27, 44)">
          <NullNode start="(26, 28)" end="(26, 50)">
            <TermExplicitbinderNode start="(26, 28)" end="(26, 42)">
              <AtomNode start="(26, 28)" end="(26, 29)" leading="" trailing="" val="("/>
              <NullNode start="(26, 29)" end="(26, 31)">
                <IdentNode start="(26, 29)" end="(26, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(26, 32)" end="(26, 41)">
                <AtomNode start="(26, 32)" end="(26, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(26, 34)" end="(26, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(26, 34)" end="(26, 39)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(26, 40)" end="(26, 41)">
                    <IdentNode start="(26, 40)" end="(26, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(26, 41)" end="(26, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(26, 43)" end="(26, 50)">
              <AtomNode start="(26, 43)" end="(26, 44)" leading="" trailing="" val="("/>
              <NullNode start="(26, 44)" end="(26, 49)">
                <IdentNode start="(26, 44)" end="(26, 45)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(26, 46)" end="(26, 47)" leading="" trailing=" " raw_val="x" val="x"/>
                <IdentNode start="(26, 48)" end="(26, 49)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(26, 49)" end="(26, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(26, 51)" end="(27, 44)">
            <AtomNode start="(26, 51)" end="(26, 52)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(27, 5)" end="(27, 44)" kind="«term_=_»">
              <OtherNode start="(27, 5)" end="(27, 24)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(27, 5)" end="(27, 17)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(27, 5)" end="(27, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(27, 6)" end="(27, 16)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(27, 6)" end="(27, 12)" leading="" trailing=" " raw_val="xs.set" val="xs.set"/>
                    <NullNode start="(27, 13)" end="(27, 16)">
                      <IdentNode start="(27, 13)" end="(27, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(27, 15)" end="(27, 16)" leading="" trailing="" raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(27, 16)" end="(27, 17)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(27, 17)" end="(27, 18)" leading="" trailing="" val="."/>
                <IdentNode start="(27, 18)" end="(27, 24)" leading="" trailing=" " raw_val="toList" val="toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(27, 25)" end="(27, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(27, 27)" end="(27, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(27, 27)" end="(27, 40)" leading="" trailing=" " raw_val="xs.toList.set" val="xs.toList.set"/>
                <NullNode start="(27, 41)" end="(27, 44)">
                  <IdentNode start="(27, 41)" end="(27, 42)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(27, 43)" end="(27, 44)" leading="" trailing=" " raw_val="x" val="x"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(27, 45)" end="(27, 51)">
          <AtomNode start="(27, 45)" end="(27, 47)" leading="" trailing=" " val=":="/>
          <IdentNode start="(27, 48)" end="(27, 51)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(29, 1)" end="(31, 14)" name="swap_def" full_name="Array.swap_def">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(29, 1)" end="(31, 14)" name="swap_def" full_name="Array.swap_def" _is_private_decl="False">
        <AtomNode start="(29, 1)" end="(29, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(29, 9)" end="(29, 17)">
          <IdentNode start="(29, 9)" end="(29, 17)" leading="" trailing=" " raw_val="swap_def" val="swap_def"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(29, 18)" end="(30, 73)">
          <NullNode start="(29, 18)" end="(29, 52)">
            <TermExplicitbinderNode start="(29, 18)" end="(29, 32)">
              <AtomNode start="(29, 18)" end="(29, 19)" leading="" trailing="" val="("/>
              <NullNode start="(29, 19)" end="(29, 21)">
                <IdentNode start="(29, 19)" end="(29, 21)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(29, 22)" end="(29, 31)">
                <AtomNode start="(29, 22)" end="(29, 23)" leading="" trailing=" " val=":"/>
                <OtherNode start="(29, 24)" end="(29, 31)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(29, 24)" end="(29, 29)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(29, 30)" end="(29, 31)">
                    <IdentNode start="(29, 30)" end="(29, 31)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(29, 31)" end="(29, 32)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(29, 33)" end="(29, 44)">
              <AtomNode start="(29, 33)" end="(29, 34)" leading="" trailing="" val="("/>
              <NullNode start="(29, 34)" end="(29, 37)">
                <IdentNode start="(29, 34)" end="(29, 35)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(29, 36)" end="(29, 37)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(29, 38)" end="(29, 43)">
                <AtomNode start="(29, 38)" end="(29, 39)" leading="" trailing=" " val=":"/>
                <IdentNode start="(29, 40)" end="(29, 43)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(29, 43)" end="(29, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(29, 45)" end="(29, 52)">
              <AtomNode start="(29, 45)" end="(29, 46)" leading="" trailing="" val="("/>
              <NullNode start="(29, 46)" end="(29, 51)">
                <IdentNode start="(29, 46)" end="(29, 48)" leading="" trailing=" " raw_val="hi" val="hi"/>
                <IdentNode start="(29, 49)" end="(29, 51)" leading="" trailing="" raw_val="hj" val="hj"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(29, 51)" end="(29, 52)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(29, 53)" end="(30, 73)">
            <AtomNode start="(29, 53)" end="(29, 54)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(30, 5)" end="(30, 73)" kind="«term_=_»">
              <OtherNode start="(30, 5)" end="(30, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(30, 5)" end="(30, 12)" leading="" trailing=" " raw_val="xs.swap" val="xs.swap"/>
                <NullNode start="(30, 13)" end="(30, 22)">
                  <IdentNode start="(30, 13)" end="(30, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(30, 15)" end="(30, 16)" leading="" trailing=" " raw_val="j" val="j"/>
                  <IdentNode start="(30, 17)" end="(30, 19)" leading="" trailing=" " raw_val="hi" val="hi"/>
                  <IdentNode start="(30, 20)" end="(30, 22)" leading="" trailing=" " raw_val="hj" val="hj"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(30, 23)" end="(30, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(30, 25)" end="(30, 73)" kind="Lean.Parser.Term.app">
                <OtherNode start="(30, 25)" end="(30, 45)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(30, 25)" end="(30, 41)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(30, 25)" end="(30, 26)" leading="" trailing="" val="("/>
                    <OtherNode start="(30, 26)" end="(30, 40)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(30, 26)" end="(30, 32)" leading="" trailing=" " raw_val="xs.set" val="xs.set"/>
                      <NullNode start="(30, 33)" end="(30, 40)">
                        <IdentNode start="(30, 33)" end="(30, 34)" leading="" trailing=" " raw_val="i" val="i"/>
                        <OtherNode start="(30, 35)" end="(30, 40)" kind="«term__[_]»">
                          <IdentNode start="(30, 35)" end="(30, 37)" leading="" trailing="" raw_val="xs" val="xs"/>
                          <AtomNode start="(30, 37)" end="(30, 38)" leading="" trailing="" val="["/>
                          <IdentNode start="(30, 38)" end="(30, 39)" leading="" trailing="" raw_val="j" val="j"/>
                          <AtomNode start="(30, 39)" end="(30, 40)" leading="" trailing="" val="]"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(30, 40)" end="(30, 41)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(30, 41)" end="(30, 42)" leading="" trailing="" val="."/>
                  <IdentNode start="(30, 42)" end="(30, 45)" leading="" trailing=" " raw_val="set" val="set" full_name="Array.set" mod_name="Init.Data.Array.Set" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Set.lean"/>
                </OtherNode>
                <NullNode start="(30, 46)" end="(30, 73)">
                  <IdentNode start="(30, 46)" end="(30, 47)" leading="" trailing=" " raw_val="j" val="j"/>
                  <OtherNode start="(30, 48)" end="(30, 53)" kind="«term__[_]»">
                    <IdentNode start="(30, 48)" end="(30, 50)" leading="" trailing="" raw_val="xs" val="xs"/>
                    <AtomNode start="(30, 50)" end="(30, 51)" leading="" trailing="" val="["/>
                    <IdentNode start="(30, 51)" end="(30, 52)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(30, 52)" end="(30, 53)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                  <OtherNode start="(30, 54)" end="(30, 73)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(30, 54)" end="(30, 55)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(30, 55)" end="(30, 72)">
                      <AtomNode start="(30, 55)" end="(30, 57)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(30, 58)" end="(30, 72)">
                        <TacticTacticseq1IndentedNode start="(30, 58)" end="(30, 72)">
                          <NullNode start="(30, 58)" end="(30, 72)">
                            <OtherNode start="(30, 58)" end="(30, 72)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type ?u.89&#10;xs : Array α&#10;i j : Nat&#10;hi : i &amp;lt; xs.size&#10;hj : j &amp;lt; xs.size&#10;⊢ j &amp;lt; (xs.set i xs[j] hi).size" state_after="no goals" tactic="simpa using hj">
                              <AtomNode start="(30, 58)" end="(30, 63)" leading="" trailing=" " val="simpa"/>
                              <NullNode/>
                              <NullNode/>
                              <OtherNode start="(30, 64)" end="(30, 72)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(30, 64)" end="(30, 72)">
                                  <AtomNode start="(30, 64)" end="(30, 69)" leading="" trailing=" " val="using"/>
                                  <IdentNode start="(30, 70)" end="(30, 72)" leading="" trailing="" raw_val="hj" val="hj"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(30, 72)" end="(30, 73)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(30, 74)" end="(31, 14)">
          <AtomNode start="(30, 74)" end="(30, 76)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(30, 77)" end="(31, 14)">
            <AtomNode start="(30, 77)" end="(30, 79)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(31, 3)" end="(31, 14)">
              <TacticTacticseq1IndentedNode start="(31, 3)" end="(31, 14)">
                <NullNode start="(31, 3)" end="(31, 14)">
                  <OtherNode start="(31, 3)" end="(31, 14)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : Array α&#10;i j : Nat&#10;hi : i &amp;lt; xs.size&#10;hj : j &amp;lt; xs.size&#10;⊢ xs.swap i j hi hj = (xs.set i xs[j] hi).set j xs[i] ⋯" state_after="no goals" tactic="simp [swap]">
                    <AtomNode start="(31, 3)" end="(31, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(31, 8)" end="(31, 14)">
                      <AtomNode start="(31, 8)" end="(31, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(31, 9)" end="(31, 13)">
                        <OtherNode start="(31, 9)" end="(31, 13)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(31, 9)" end="(31, 13)" leading="" trailing="" raw_val="swap" val="swap" full_name="Array.swap" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(31, 13)" end="(31, 14)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(33, 1)" end="(34, 91)" name="toList_swap" full_name="Array.toList_swap">
      <CommandDeclmodifiersNode start="(33, 1)" end="(33, 8)">
        <NullNode/>
        <NullNode start="(33, 1)" end="(33, 8)">
          <OtherNode start="(33, 1)" end="(33, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(33, 1)" end="(33, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(33, 3)" end="(33, 7)">
              <OtherNode start="(33, 3)" end="(33, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(33, 3)" end="(33, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(33, 3)" end="(33, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(33, 7)" end="(33, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(33, 9)" end="(34, 91)" name="toList_swap" full_name="Array.toList_swap" _is_private_decl="False">
        <AtomNode start="(33, 9)" end="(33, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(33, 17)" end="(33, 28)">
          <IdentNode start="(33, 17)" end="(33, 28)" leading="" trailing=" " raw_val="toList_swap" val="toList_swap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(33, 29)" end="(34, 69)">
          <NullNode start="(33, 29)" end="(33, 63)">
            <TermExplicitbinderNode start="(33, 29)" end="(33, 43)">
              <AtomNode start="(33, 29)" end="(33, 30)" leading="" trailing="" val="("/>
              <NullNode start="(33, 30)" end="(33, 32)">
                <IdentNode start="(33, 30)" end="(33, 32)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(33, 33)" end="(33, 42)">
                <AtomNode start="(33, 33)" end="(33, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(33, 35)" end="(33, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(33, 35)" end="(33, 40)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(33, 41)" end="(33, 42)">
                    <IdentNode start="(33, 41)" end="(33, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(33, 42)" end="(33, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(33, 44)" end="(33, 55)">
              <AtomNode start="(33, 44)" end="(33, 45)" leading="" trailing="" val="("/>
              <NullNode start="(33, 45)" end="(33, 48)">
                <IdentNode start="(33, 45)" end="(33, 46)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(33, 47)" end="(33, 48)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(33, 49)" end="(33, 54)">
                <AtomNode start="(33, 49)" end="(33, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(33, 51)" end="(33, 54)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(33, 54)" end="(33, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(33, 56)" end="(33, 63)">
              <AtomNode start="(33, 56)" end="(33, 57)" leading="" trailing="" val="("/>
              <NullNode start="(33, 57)" end="(33, 62)">
                <IdentNode start="(33, 57)" end="(33, 59)" leading="" trailing=" " raw_val="hi" val="hi"/>
                <IdentNode start="(33, 60)" end="(33, 62)" leading="" trailing="" raw_val="hj" val="hj"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(33, 62)" end="(33, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(33, 64)" end="(34, 69)">
            <AtomNode start="(33, 64)" end="(33, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(34, 5)" end="(34, 69)" kind="«term_=_»">
              <OtherNode start="(34, 5)" end="(34, 31)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(34, 5)" end="(34, 24)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(34, 5)" end="(34, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(34, 6)" end="(34, 23)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(34, 6)" end="(34, 13)" leading="" trailing=" " raw_val="xs.swap" val="xs.swap"/>
                    <NullNode start="(34, 14)" end="(34, 23)">
                      <IdentNode start="(34, 14)" end="(34, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(34, 16)" end="(34, 17)" leading="" trailing=" " raw_val="j" val="j"/>
                      <IdentNode start="(34, 18)" end="(34, 20)" leading="" trailing=" " raw_val="hi" val="hi"/>
                      <IdentNode start="(34, 21)" end="(34, 23)" leading="" trailing="" raw_val="hj" val="hj"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(34, 23)" end="(34, 24)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(34, 24)" end="(34, 25)" leading="" trailing="" val="."/>
                <IdentNode start="(34, 25)" end="(34, 31)" leading="" trailing=" " raw_val="toList" val="toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(34, 32)" end="(34, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(34, 34)" end="(34, 69)" kind="Lean.Parser.Term.app">
                <OtherNode start="(34, 34)" end="(34, 61)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(34, 34)" end="(34, 57)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(34, 34)" end="(34, 35)" leading="" trailing="" val="("/>
                    <OtherNode start="(34, 35)" end="(34, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(34, 35)" end="(34, 48)" leading="" trailing=" " raw_val="xs.toList.set" val="xs.toList.set"/>
                      <NullNode start="(34, 49)" end="(34, 56)">
                        <IdentNode start="(34, 49)" end="(34, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                        <OtherNode start="(34, 51)" end="(34, 56)" kind="«term__[_]»">
                          <IdentNode start="(34, 51)" end="(34, 53)" leading="" trailing="" raw_val="xs" val="xs"/>
                          <AtomNode start="(34, 53)" end="(34, 54)" leading="" trailing="" val="["/>
                          <IdentNode start="(34, 54)" end="(34, 55)" leading="" trailing="" raw_val="j" val="j"/>
                          <AtomNode start="(34, 55)" end="(34, 56)" leading="" trailing="" val="]"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(34, 56)" end="(34, 57)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(34, 57)" end="(34, 58)" leading="" trailing="" val="."/>
                  <IdentNode start="(34, 58)" end="(34, 61)" leading="" trailing=" " raw_val="set" val="set" full_name="List.set" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(34, 62)" end="(34, 69)">
                  <IdentNode start="(34, 62)" end="(34, 63)" leading="" trailing=" " raw_val="j" val="j"/>
                  <OtherNode start="(34, 64)" end="(34, 69)" kind="«term__[_]»">
                    <IdentNode start="(34, 64)" end="(34, 66)" leading="" trailing="" raw_val="xs" val="xs"/>
                    <AtomNode start="(34, 66)" end="(34, 67)" leading="" trailing="" val="["/>
                    <IdentNode start="(34, 67)" end="(34, 68)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(34, 68)" end="(34, 69)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(34, 70)" end="(34, 91)">
          <AtomNode start="(34, 70)" end="(34, 72)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(34, 73)" end="(34, 91)">
            <AtomNode start="(34, 73)" end="(34, 75)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(34, 76)" end="(34, 91)">
              <TacticTacticseq1IndentedNode start="(34, 76)" end="(34, 91)">
                <NullNode start="(34, 76)" end="(34, 91)">
                  <OtherNode start="(34, 76)" end="(34, 91)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : Array α&#10;i j : Nat&#10;hi : i &amp;lt; xs.size&#10;hj : j &amp;lt; xs.size&#10;⊢ (xs.swap i j hi hj).toList = (xs.toList.set i xs[j]).set j xs[i]" state_after="no goals" tactic="simp [swap_def]">
                    <AtomNode start="(34, 76)" end="(34, 80)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(34, 81)" end="(34, 91)">
                      <AtomNode start="(34, 81)" end="(34, 82)" leading="" trailing="" val="["/>
                      <NullNode start="(34, 82)" end="(34, 90)">
                        <OtherNode start="(34, 82)" end="(34, 90)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(34, 82)" end="(34, 90)" leading="" trailing="" raw_val="swap_def" val="swap_def" full_name="Array.swap_def" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(29, 9)" def_end="(29, 17)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(34, 90)" end="(34, 91)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(36, 1)" end="(36, 10)" name="Array">
      <AtomNode start="(36, 1)" end="(36, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(36, 5)" end="(36, 10)">
        <IdentNode start="(36, 5)" end="(36, 10)" leading="" trailing="&#10;&#10;" raw_val="Array" val="Array"/>
      </NullNode>
    </CommandEndNode>
    <CommandNamespaceNode start="(38, 1)" end="(38, 15)" name="List">
      <AtomNode start="(38, 1)" end="(38, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(38, 11)" end="(38, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandOpenNode start="(40, 1)" end="(40, 11)">
      <AtomNode start="(40, 1)" end="(40, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(40, 6)" end="(40, 11)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(40, 6)" end="(40, 11)">
          <IdentNode start="(40, 6)" end="(40, 11)" leading="" trailing="&#10;&#10;" raw_val="Array" val="Array"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandDeclarationNode start="(42, 1)" end="(48, 33)" name="toArray_inj" full_name="List.toArray_inj">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(42, 1)" end="(48, 33)" name="toArray_inj" full_name="List.toArray_inj" _is_private_decl="False">
        <AtomNode start="(42, 1)" end="(42, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(42, 9)" end="(42, 20)">
          <IdentNode start="(42, 9)" end="(42, 20)" leading="" trailing=" " raw_val="toArray_inj" val="toArray_inj"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(42, 21)" end="(42, 77)">
          <NullNode start="(42, 21)" end="(42, 67)">
            <OtherNode start="(42, 21)" end="(42, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(42, 21)" end="(42, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(42, 22)" end="(42, 27)">
                <IdentNode start="(42, 22)" end="(42, 24)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(42, 25)" end="(42, 27)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(42, 28)" end="(42, 36)">
                <AtomNode start="(42, 28)" end="(42, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(42, 30)" end="(42, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(42, 30)" end="(42, 34)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(42, 35)" end="(42, 36)">
                    <IdentNode start="(42, 35)" end="(42, 36)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(42, 36)" end="(42, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(42, 38)" end="(42, 67)">
              <AtomNode start="(42, 38)" end="(42, 39)" leading="" trailing="" val="("/>
              <NullNode start="(42, 39)" end="(42, 40)">
                <IdentNode start="(42, 39)" end="(42, 40)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(42, 41)" end="(42, 66)">
                <AtomNode start="(42, 41)" end="(42, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(42, 43)" end="(42, 66)" kind="«term_=_»">
                  <IdentNode start="(42, 43)" end="(42, 53)" leading="" trailing=" " raw_val="as.toArray" val="as.toArray"/>
                  <AtomNode start="(42, 54)" end="(42, 55)" leading="" trailing=" " val="="/>
                  <IdentNode start="(42, 56)" end="(42, 66)" leading="" trailing="" raw_val="bs.toArray" val="bs.toArray"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(42, 66)" end="(42, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(42, 68)" end="(42, 77)">
            <AtomNode start="(42, 68)" end="(42, 69)" leading="" trailing=" " val=":"/>
            <OtherNode start="(42, 70)" end="(42, 77)" kind="«term_=_»">
              <IdentNode start="(42, 70)" end="(42, 72)" leading="" trailing=" " raw_val="as" val="as"/>
              <AtomNode start="(42, 73)" end="(42, 74)" leading="" trailing=" " val="="/>
              <IdentNode start="(42, 75)" end="(42, 77)" leading="" trailing=" " raw_val="bs" val="bs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(42, 78)" end="(48, 33)">
          <AtomNode start="(42, 78)" end="(42, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(42, 81)" end="(48, 33)">
            <AtomNode start="(42, 81)" end="(42, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(43, 3)" end="(48, 33)">
              <TacticTacticseq1IndentedNode start="(43, 3)" end="(48, 33)">
                <NullNode start="(43, 3)" end="(48, 33)">
                  <OtherNode start="(43, 3)" end="(48, 33)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;as bs : List α&#10;h : as.toArray = bs.toArray&#10;⊢ as = bs" state_after="no goals" tactic="cases as with&#10;| nil =&amp;gt; simpa using h&#10;| cons a as =&amp;gt;&#10;  cases bs with&#10;  | nil =&amp;gt; simp at h&#10;  | cons b bs =&amp;gt; simpa using h">
                    <AtomNode start="(43, 3)" end="(43, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(43, 9)" end="(43, 11)">
                      <OtherNode start="(43, 9)" end="(43, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(43, 9)" end="(43, 11)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(43, 12)" end="(48, 33)">
                      <OtherNode start="(43, 12)" end="(48, 33)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(43, 12)" end="(43, 16)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(44, 3)" end="(48, 33)">
                          <OtherNode start="(44, 3)" end="(44, 25)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(44, 3)" end="(44, 8)">
                              <OtherNode start="(44, 3)" end="(44, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(44, 3)" end="(44, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(44, 5)" end="(44, 8)">
                                  <NullNode/>
                                  <IdentNode start="(44, 5)" end="(44, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(44, 9)" end="(44, 25)">
                              <AtomNode start="(44, 9)" end="(44, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(44, 12)" end="(44, 25)">
                                <TacticTacticseq1IndentedNode start="(44, 12)" end="(44, 25)">
                                  <NullNode start="(44, 12)" end="(44, 25)">
                                    <OtherNode start="(44, 12)" end="(44, 25)" kind="Lean.Parser.Tactic.simpa" state_before="case nil&#10;α : Type u_1&#10;bs : List α&#10;h : #[] = bs.toArray&#10;⊢ [] = bs" state_after="no goals" tactic="simpa using h">
                                      <AtomNode start="(44, 12)" end="(44, 17)" leading="" trailing=" " val="simpa"/>
                                      <NullNode/>
                                      <NullNode/>
                                      <OtherNode start="(44, 18)" end="(44, 25)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(44, 18)" end="(44, 25)">
                                          <AtomNode start="(44, 18)" end="(44, 23)" leading="" trailing=" " val="using"/>
                                          <IdentNode start="(44, 24)" end="(44, 25)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(45, 3)" end="(48, 33)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(45, 3)" end="(45, 14)">
                              <OtherNode start="(45, 3)" end="(45, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(45, 3)" end="(45, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(45, 5)" end="(45, 9)">
                                  <NullNode/>
                                  <IdentNode start="(45, 5)" end="(45, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(45, 10)" end="(45, 14)">
                                  <IdentNode start="(45, 10)" end="(45, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(45, 12)" end="(45, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(45, 15)" end="(48, 33)">
                              <AtomNode start="(45, 15)" end="(45, 17)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(46, 5)" end="(48, 33)">
                                <TacticTacticseq1IndentedNode start="(46, 5)" end="(48, 33)">
                                  <NullNode start="(46, 5)" end="(48, 33)">
                                    <OtherNode start="(46, 5)" end="(48, 33)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;bs : List α&#10;a : α&#10;as : List α&#10;h : (a :: as).toArray = bs.toArray&#10;⊢ a :: as = bs" state_after="no goals" tactic="cases bs with&#10;| nil =&amp;gt; simp at h&#10;| cons b bs =&amp;gt; simpa using h">
                                      <AtomNode start="(46, 5)" end="(46, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(46, 11)" end="(46, 13)">
                                        <OtherNode start="(46, 11)" end="(46, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(46, 11)" end="(46, 13)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(46, 14)" end="(48, 33)">
                                        <OtherNode start="(46, 14)" end="(48, 33)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(46, 14)" end="(46, 18)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(47, 5)" end="(48, 33)">
                                            <OtherNode start="(47, 5)" end="(47, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(47, 5)" end="(47, 10)">
                                                <OtherNode start="(47, 5)" end="(47, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(47, 5)" end="(47, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(47, 7)" end="(47, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(47, 7)" end="(47, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(47, 11)" end="(47, 23)">
                                                <AtomNode start="(47, 11)" end="(47, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(47, 14)" end="(47, 23)">
                                                  <TacticTacticseq1IndentedNode start="(47, 14)" end="(47, 23)">
                                                    <NullNode start="(47, 14)" end="(47, 23)">
                                                      <OtherNode start="(47, 14)" end="(47, 23)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;α : Type u_1&#10;a : α&#10;as : List α&#10;h : (a :: as).toArray = #[]&#10;⊢ a :: as = []" state_after="no goals" tactic="simp at h">
                                                        <AtomNode start="(47, 14)" end="(47, 18)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(47, 19)" end="(47, 23)">
                                                          <OtherNode start="(47, 19)" end="(47, 23)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(47, 19)" end="(47, 21)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(47, 22)" end="(47, 23)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(47, 22)" end="(47, 23)">
                                                            <IdentNode start="(47, 22)" end="(47, 23)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(48, 5)" end="(48, 33)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(48, 5)" end="(48, 16)">
                                                <OtherNode start="(48, 5)" end="(48, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(48, 5)" end="(48, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(48, 7)" end="(48, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(48, 7)" end="(48, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(48, 12)" end="(48, 16)">
                                                    <IdentNode start="(48, 12)" end="(48, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                                    <IdentNode start="(48, 14)" end="(48, 16)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(48, 17)" end="(48, 33)">
                                                <AtomNode start="(48, 17)" end="(48, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(48, 20)" end="(48, 33)">
                                                  <TacticTacticseq1IndentedNode start="(48, 20)" end="(48, 33)">
                                                    <NullNode start="(48, 20)" end="(48, 33)">
                                                      <OtherNode start="(48, 20)" end="(48, 33)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.cons&#10;α : Type u_1&#10;a : α&#10;as : List α&#10;b : α&#10;bs : List α&#10;h : (a :: as).toArray = (b :: bs).toArray&#10;⊢ a :: as = b :: bs" state_after="no goals" tactic="simpa using h">
                                                        <AtomNode start="(48, 20)" end="(48, 25)" leading="" trailing=" " val="simpa"/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <OtherNode start="(48, 26)" end="(48, 33)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(48, 26)" end="(48, 33)">
                                                            <AtomNode start="(48, 26)" end="(48, 31)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(48, 32)" end="(48, 33)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(50, 1)" end="(52, 7)" name="toArray_eq_iff" full_name="List.toArray_eq_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(50, 1)" end="(52, 7)" name="toArray_eq_iff" full_name="List.toArray_eq_iff" _is_private_decl="False">
        <AtomNode start="(50, 1)" end="(50, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(50, 9)" end="(50, 23)">
          <IdentNode start="(50, 9)" end="(50, 23)" leading="" trailing=" " raw_val="toArray_eq_iff" val="toArray_eq_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(50, 24)" end="(50, 87)">
          <NullNode start="(50, 24)" end="(50, 52)">
            <OtherNode start="(50, 24)" end="(50, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(50, 24)" end="(50, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(50, 25)" end="(50, 27)">
                <IdentNode start="(50, 25)" end="(50, 27)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(50, 28)" end="(50, 36)">
                <AtomNode start="(50, 28)" end="(50, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(50, 30)" end="(50, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(50, 30)" end="(50, 34)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(50, 35)" end="(50, 36)">
                    <IdentNode start="(50, 35)" end="(50, 36)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(50, 36)" end="(50, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(50, 38)" end="(50, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(50, 38)" end="(50, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(50, 39)" end="(50, 41)">
                <IdentNode start="(50, 39)" end="(50, 41)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(50, 42)" end="(50, 51)">
                <AtomNode start="(50, 42)" end="(50, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(50, 44)" end="(50, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(50, 44)" end="(50, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(50, 50)" end="(50, 51)">
                    <IdentNode start="(50, 50)" end="(50, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(50, 51)" end="(50, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(50, 53)" end="(50, 87)">
            <AtomNode start="(50, 53)" end="(50, 54)" leading="" trailing=" " val=":"/>
            <OtherNode start="(50, 55)" end="(50, 87)" kind="«term_↔_»">
              <OtherNode start="(50, 55)" end="(50, 70)" kind="«term_=_»">
                <IdentNode start="(50, 55)" end="(50, 65)" leading="" trailing=" " raw_val="as.toArray" val="as.toArray"/>
                <AtomNode start="(50, 66)" end="(50, 67)" leading="" trailing=" " val="="/>
                <IdentNode start="(50, 68)" end="(50, 70)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </OtherNode>
              <AtomNode start="(50, 71)" end="(50, 72)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(50, 73)" end="(50, 87)" kind="«term_=_»">
                <IdentNode start="(50, 73)" end="(50, 75)" leading="" trailing=" " raw_val="as" val="as"/>
                <AtomNode start="(50, 76)" end="(50, 77)" leading="" trailing=" " val="="/>
                <IdentNode start="(50, 78)" end="(50, 87)" leading="" trailing=" " raw_val="bs.toList" val="bs.toList"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(50, 88)" end="(52, 7)">
          <AtomNode start="(50, 88)" end="(50, 90)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(50, 91)" end="(52, 7)">
            <AtomNode start="(50, 91)" end="(50, 93)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(51, 3)" end="(52, 7)">
              <TacticTacticseq1IndentedNode start="(51, 3)" end="(52, 7)">
                <NullNode start="(51, 3)" end="(52, 7)">
                  <OtherNode start="(51, 3)" end="(51, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;as : List α&#10;bs : Array α&#10;⊢ as.toArray = bs ↔ as = bs.toList" state_after="case mk&#10;α : Type u_1&#10;as toList✝ : List α&#10;⊢ as.toArray = { toList := toList✝ } ↔ as = { toList := toList✝ }.toList" tactic="cases bs">
                    <AtomNode start="(51, 3)" end="(51, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(51, 9)" end="(51, 11)">
                      <OtherNode start="(51, 9)" end="(51, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(51, 9)" end="(51, 11)" leading="" trailing="&#10;  " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(52, 3)" end="(52, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;as toList✝ : List α&#10;⊢ as.toArray = { toList := toList✝ } ↔ as = { toList := toList✝ }.toList" state_after="no goals" tactic="simp">
                    <AtomNode start="(52, 3)" end="(52, 7)" leading="" trailing="&#10;&#10;-- We can't make this a `@[simp]` lemma because `#[] = [].toArray` at reducible transparency,&#10;-- so this would loop with `toList_eq_nil_iff`&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(56, 1)" end="(58, 7)" name="eq_toArray_iff" full_name="List.eq_toArray_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(56, 1)" end="(58, 7)" name="eq_toArray_iff" full_name="List.eq_toArray_iff" _is_private_decl="False">
        <AtomNode start="(56, 1)" end="(56, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(56, 9)" end="(56, 23)">
          <IdentNode start="(56, 9)" end="(56, 23)" leading="" trailing=" " raw_val="eq_toArray_iff" val="eq_toArray_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(56, 24)" end="(56, 87)">
          <NullNode start="(56, 24)" end="(56, 52)">
            <OtherNode start="(56, 24)" end="(56, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(56, 24)" end="(56, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(56, 25)" end="(56, 27)">
                <IdentNode start="(56, 25)" end="(56, 27)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(56, 28)" end="(56, 37)">
                <AtomNode start="(56, 28)" end="(56, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(56, 30)" end="(56, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(56, 30)" end="(56, 35)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(56, 36)" end="(56, 37)">
                    <IdentNode start="(56, 36)" end="(56, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(56, 37)" end="(56, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(56, 39)" end="(56, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(56, 39)" end="(56, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(56, 40)" end="(56, 42)">
                <IdentNode start="(56, 40)" end="(56, 42)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(56, 43)" end="(56, 51)">
                <AtomNode start="(56, 43)" end="(56, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(56, 45)" end="(56, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(56, 45)" end="(56, 49)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(56, 50)" end="(56, 51)">
                    <IdentNode start="(56, 50)" end="(56, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(56, 51)" end="(56, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(56, 53)" end="(56, 87)">
            <AtomNode start="(56, 53)" end="(56, 54)" leading="" trailing=" " val=":"/>
            <OtherNode start="(56, 55)" end="(56, 87)" kind="«term_↔_»">
              <OtherNode start="(56, 55)" end="(56, 70)" kind="«term_=_»">
                <IdentNode start="(56, 55)" end="(56, 57)" leading="" trailing=" " raw_val="as" val="as"/>
                <AtomNode start="(56, 58)" end="(56, 59)" leading="" trailing=" " val="="/>
                <IdentNode start="(56, 60)" end="(56, 70)" leading="" trailing=" " raw_val="bs.toArray" val="bs.toArray"/>
              </OtherNode>
              <AtomNode start="(56, 71)" end="(56, 72)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(56, 73)" end="(56, 87)" kind="«term_=_»">
                <IdentNode start="(56, 73)" end="(56, 82)" leading="" trailing=" " raw_val="as.toList" val="as.toList"/>
                <AtomNode start="(56, 83)" end="(56, 84)" leading="" trailing=" " val="="/>
                <IdentNode start="(56, 85)" end="(56, 87)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(56, 88)" end="(58, 7)">
          <AtomNode start="(56, 88)" end="(56, 90)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(56, 91)" end="(58, 7)">
            <AtomNode start="(56, 91)" end="(56, 93)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(57, 3)" end="(58, 7)">
              <TacticTacticseq1IndentedNode start="(57, 3)" end="(58, 7)">
                <NullNode start="(57, 3)" end="(58, 7)">
                  <OtherNode start="(57, 3)" end="(57, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;as : Array α&#10;bs : List α&#10;⊢ as = bs.toArray ↔ as.toList = bs" state_after="case mk&#10;α : Type u_1&#10;bs toList✝ : List α&#10;⊢ { toList := toList✝ } = bs.toArray ↔ { toList := toList✝ }.toList = bs" tactic="cases as">
                    <AtomNode start="(57, 3)" end="(57, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(57, 9)" end="(57, 11)">
                      <OtherNode start="(57, 9)" end="(57, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(57, 9)" end="(57, 11)" leading="" trailing="&#10;  " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(58, 3)" end="(58, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;bs toList✝ : List α&#10;⊢ { toList := toList✝ } = bs.toArray ↔ { toList := toList✝ }.toList = bs" state_after="no goals" tactic="simp">
                    <AtomNode start="(58, 3)" end="(58, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(60, 1)" end="(62, 14)" name="size_toArrayAux" full_name="List.size_toArrayAux">
      <CommandDeclmodifiersNode start="(60, 1)" end="(60, 8)">
        <NullNode/>
        <NullNode start="(60, 1)" end="(60, 8)">
          <OtherNode start="(60, 1)" end="(60, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(60, 1)" end="(60, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(60, 3)" end="(60, 7)">
              <OtherNode start="(60, 3)" end="(60, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(60, 3)" end="(60, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(60, 3)" end="(60, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(60, 7)" end="(60, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(60, 9)" end="(62, 14)" name="size_toArrayAux" full_name="List.size_toArrayAux" _is_private_decl="False">
        <AtomNode start="(60, 9)" end="(60, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(60, 17)" end="(60, 32)">
          <IdentNode start="(60, 17)" end="(60, 32)" leading="" trailing=" " raw_val="size_toArrayAux" val="size_toArrayAux"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(60, 33)" end="(61, 50)">
          <NullNode start="(60, 33)" end="(60, 61)">
            <OtherNode start="(60, 33)" end="(60, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(60, 33)" end="(60, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(60, 34)" end="(60, 36)">
                <IdentNode start="(60, 34)" end="(60, 36)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(60, 37)" end="(60, 45)">
                <AtomNode start="(60, 37)" end="(60, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(60, 39)" end="(60, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(60, 39)" end="(60, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(60, 44)" end="(60, 45)">
                    <IdentNode start="(60, 44)" end="(60, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(60, 45)" end="(60, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(60, 47)" end="(60, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(60, 47)" end="(60, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(60, 48)" end="(60, 50)">
                <IdentNode start="(60, 48)" end="(60, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(60, 51)" end="(60, 60)">
                <AtomNode start="(60, 51)" end="(60, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(60, 53)" end="(60, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(60, 53)" end="(60, 58)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(60, 59)" end="(60, 60)">
                    <IdentNode start="(60, 59)" end="(60, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(60, 60)" end="(60, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(60, 62)" end="(61, 50)">
            <AtomNode start="(60, 62)" end="(60, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(61, 5)" end="(61, 50)" kind="«term_=_»">
              <OtherNode start="(61, 5)" end="(61, 28)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(61, 5)" end="(61, 23)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(61, 5)" end="(61, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(61, 6)" end="(61, 22)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(61, 6)" end="(61, 19)" leading="" trailing=" " raw_val="as.toArrayAux" val="as.toArrayAux"/>
                    <NullNode start="(61, 20)" end="(61, 22)">
                      <IdentNode start="(61, 20)" end="(61, 22)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(61, 22)" end="(61, 23)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(61, 23)" end="(61, 24)" leading="" trailing="" val="."/>
                <IdentNode start="(61, 24)" end="(61, 28)" leading="" trailing=" " raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(61, 29)" end="(61, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(61, 31)" end="(61, 50)" kind="«term_+_»">
                <IdentNode start="(61, 31)" end="(61, 38)" leading="" trailing=" " raw_val="xs.size" val="xs.size"/>
                <AtomNode start="(61, 39)" end="(61, 40)" leading="" trailing=" " val="+"/>
                <IdentNode start="(61, 41)" end="(61, 50)" leading="" trailing=" " raw_val="as.length" val="as.length"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(61, 51)" end="(62, 14)">
          <AtomNode start="(61, 51)" end="(61, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(61, 54)" end="(62, 14)">
            <AtomNode start="(61, 54)" end="(61, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(62, 3)" end="(62, 14)">
              <TacticTacticseq1IndentedNode start="(62, 3)" end="(62, 14)">
                <NullNode start="(62, 3)" end="(62, 14)">
                  <OtherNode start="(62, 3)" end="(62, 14)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;as : List α&#10;xs : Array α&#10;⊢ (as.toArrayAux xs).size = xs.size + as.length" state_after="no goals" tactic="simp [size]">
                    <AtomNode start="(62, 3)" end="(62, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(62, 8)" end="(62, 14)">
                      <AtomNode start="(62, 8)" end="(62, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(62, 9)" end="(62, 13)">
                        <OtherNode start="(62, 9)" end="(62, 13)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(62, 9)" end="(62, 13)" leading="" trailing="" raw_val="size" val="size" full_name="Array.size" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(62, 13)" end="(62, 14)" leading="" trailing="&#10;&#10;-- This is not a `@[simp]` lemma because it is pushing `toArray` inwards.&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(65, 1)" end="(67, 7)" name="toArray_cons" full_name="List.toArray_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(65, 1)" end="(67, 7)" name="toArray_cons" full_name="List.toArray_cons" _is_private_decl="False">
        <AtomNode start="(65, 1)" end="(65, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(65, 9)" end="(65, 21)">
          <IdentNode start="(65, 9)" end="(65, 21)" leading="" trailing=" " raw_val="toArray_cons" val="toArray_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(65, 22)" end="(65, 81)">
          <NullNode start="(65, 22)" end="(65, 42)">
            <TermExplicitbinderNode start="(65, 22)" end="(65, 29)">
              <AtomNode start="(65, 22)" end="(65, 23)" leading="" trailing="" val="("/>
              <NullNode start="(65, 23)" end="(65, 24)">
                <IdentNode start="(65, 23)" end="(65, 24)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(65, 25)" end="(65, 28)">
                <AtomNode start="(65, 25)" end="(65, 26)" leading="" trailing=" " val=":"/>
                <IdentNode start="(65, 27)" end="(65, 28)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(65, 28)" end="(65, 29)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(65, 30)" end="(65, 42)">
              <AtomNode start="(65, 30)" end="(65, 31)" leading="" trailing="" val="("/>
              <NullNode start="(65, 31)" end="(65, 32)">
                <IdentNode start="(65, 31)" end="(65, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(65, 33)" end="(65, 41)">
                <AtomNode start="(65, 33)" end="(65, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(65, 35)" end="(65, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(65, 35)" end="(65, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(65, 40)" end="(65, 41)">
                    <IdentNode start="(65, 40)" end="(65, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(65, 41)" end="(65, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(65, 43)" end="(65, 81)">
            <AtomNode start="(65, 43)" end="(65, 44)" leading="" trailing=" " val=":"/>
            <OtherNode start="(65, 45)" end="(65, 81)" kind="«term_=_»">
              <OtherNode start="(65, 45)" end="(65, 61)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(65, 45)" end="(65, 53)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(65, 45)" end="(65, 46)" leading="" trailing="" val="("/>
                  <OtherNode start="(65, 46)" end="(65, 52)" kind="«term_::_»">
                    <IdentNode start="(65, 46)" end="(65, 47)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(65, 48)" end="(65, 50)" leading="" trailing=" " val="::"/>
                    <IdentNode start="(65, 51)" end="(65, 52)" leading="" trailing="" raw_val="l" val="l"/>
                  </OtherNode>
                  <AtomNode start="(65, 52)" end="(65, 53)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(65, 53)" end="(65, 54)" leading="" trailing="" val="."/>
                <IdentNode start="(65, 54)" end="(65, 61)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(65, 62)" end="(65, 63)" leading="" trailing=" " val="="/>
              <OtherNode start="(65, 64)" end="(65, 81)" kind="«term_++_»">
                <OtherNode start="(65, 64)" end="(65, 68)" kind="«term#[_,]»">
                  <AtomNode start="(65, 64)" end="(65, 66)" leading="" trailing="" val="#["/>
                  <NullNode start="(65, 66)" end="(65, 67)">
                    <IdentNode start="(65, 66)" end="(65, 67)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                  <AtomNode start="(65, 67)" end="(65, 68)" leading="" trailing=" " val="]"/>
                </OtherNode>
                <AtomNode start="(65, 69)" end="(65, 71)" leading="" trailing=" " val="++"/>
                <IdentNode start="(65, 72)" end="(65, 81)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(65, 82)" end="(67, 7)">
          <AtomNode start="(65, 82)" end="(65, 84)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(65, 85)" end="(67, 7)">
            <AtomNode start="(65, 85)" end="(65, 87)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(66, 3)" end="(67, 7)">
              <TacticTacticseq1IndentedNode start="(66, 3)" end="(67, 7)">
                <NullNode start="(66, 3)" end="(67, 7)">
                  <OtherNode start="(66, 3)" end="(66, 13)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;a : α&#10;l : List α&#10;⊢ (a :: l).toArray = #[a] ++ l.toArray" state_after="case h&#10;α : Type u_1&#10;a : α&#10;l : List α&#10;⊢ (a :: l).toArray.toList = (#[a] ++ l.toArray).toList" tactic="apply ext'">
                    <AtomNode start="(66, 3)" end="(66, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(66, 9)" end="(66, 13)" leading="" trailing="&#10;  " raw_val="ext'" val="ext'" full_name="Array.ext'" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(67, 3)" end="(67, 7)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;a : α&#10;l : List α&#10;⊢ (a :: l).toArray.toList = (#[a] ++ l.toArray).toList" state_after="no goals" tactic="simp">
                    <AtomNode start="(67, 3)" end="(67, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(69, 1)" end="(71, 7)" name="push_toArray" full_name="List.push_toArray">
      <CommandDeclmodifiersNode start="(69, 1)" end="(69, 8)">
        <NullNode/>
        <NullNode start="(69, 1)" end="(69, 8)">
          <OtherNode start="(69, 1)" end="(69, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(69, 1)" end="(69, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(69, 3)" end="(69, 7)">
              <OtherNode start="(69, 3)" end="(69, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(69, 3)" end="(69, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(69, 3)" end="(69, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(69, 7)" end="(69, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(69, 9)" end="(71, 7)" name="push_toArray" full_name="List.push_toArray" _is_private_decl="False">
        <AtomNode start="(69, 9)" end="(69, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(69, 17)" end="(69, 29)">
          <IdentNode start="(69, 17)" end="(69, 29)" leading="" trailing=" " raw_val="push_toArray" val="push_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(69, 30)" end="(69, 90)">
          <NullNode start="(69, 30)" end="(69, 50)">
            <TermExplicitbinderNode start="(69, 30)" end="(69, 42)">
              <AtomNode start="(69, 30)" end="(69, 31)" leading="" trailing="" val="("/>
              <NullNode start="(69, 31)" end="(69, 32)">
                <IdentNode start="(69, 31)" end="(69, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(69, 33)" end="(69, 41)">
                <AtomNode start="(69, 33)" end="(69, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(69, 35)" end="(69, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(69, 35)" end="(69, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(69, 40)" end="(69, 41)">
                    <IdentNode start="(69, 40)" end="(69, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(69, 41)" end="(69, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(69, 43)" end="(69, 50)">
              <AtomNode start="(69, 43)" end="(69, 44)" leading="" trailing="" val="("/>
              <NullNode start="(69, 44)" end="(69, 45)">
                <IdentNode start="(69, 44)" end="(69, 45)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(69, 46)" end="(69, 49)">
                <AtomNode start="(69, 46)" end="(69, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(69, 48)" end="(69, 49)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(69, 49)" end="(69, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(69, 51)" end="(69, 90)">
            <AtomNode start="(69, 51)" end="(69, 52)" leading="" trailing=" " val=":"/>
            <OtherNode start="(69, 53)" end="(69, 90)" kind="«term_=_»">
              <OtherNode start="(69, 53)" end="(69, 69)" kind="Lean.Parser.Term.app">
                <IdentNode start="(69, 53)" end="(69, 67)" leading="" trailing=" " raw_val="l.toArray.push" val="l.toArray.push"/>
                <NullNode start="(69, 68)" end="(69, 69)">
                  <IdentNode start="(69, 68)" end="(69, 69)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(69, 70)" end="(69, 71)" leading="" trailing=" " val="="/>
              <OtherNode start="(69, 72)" end="(69, 90)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(69, 72)" end="(69, 82)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(69, 72)" end="(69, 73)" leading="" trailing="" val="("/>
                  <OtherNode start="(69, 73)" end="(69, 81)" kind="«term_++_»">
                    <IdentNode start="(69, 73)" end="(69, 74)" leading="" trailing=" " raw_val="l" val="l"/>
                    <AtomNode start="(69, 75)" end="(69, 77)" leading="" trailing=" " val="++"/>
                    <OtherNode start="(69, 78)" end="(69, 81)" kind="«term[_]»">
                      <AtomNode start="(69, 78)" end="(69, 79)" leading="" trailing="" val="["/>
                      <NullNode start="(69, 79)" end="(69, 80)">
                        <IdentNode start="(69, 79)" end="(69, 80)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                      <AtomNode start="(69, 80)" end="(69, 81)" leading="" trailing="" val="]"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(69, 81)" end="(69, 82)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(69, 82)" end="(69, 83)" leading="" trailing="" val="."/>
                <IdentNode start="(69, 83)" end="(69, 90)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(69, 91)" end="(71, 7)">
          <AtomNode start="(69, 91)" end="(69, 93)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(69, 94)" end="(71, 7)">
            <AtomNode start="(69, 94)" end="(69, 96)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(70, 3)" end="(71, 7)">
              <TacticTacticseq1IndentedNode start="(70, 3)" end="(71, 7)">
                <NullNode start="(70, 3)" end="(71, 7)">
                  <OtherNode start="(70, 3)" end="(70, 13)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;l : List α&#10;a : α&#10;⊢ l.toArray.push a = (l ++ [a]).toArray" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;a : α&#10;⊢ (l.toArray.push a).toList = (l ++ [a]).toArray.toList" tactic="apply ext'">
                    <AtomNode start="(70, 3)" end="(70, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(70, 9)" end="(70, 13)" leading="" trailing="&#10;  " raw_val="ext'" val="ext'" full_name="Array.ext'" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(71, 3)" end="(71, 7)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;a : α&#10;⊢ (l.toArray.push a).toList = (l ++ [a]).toArray.toList" state_after="no goals" tactic="simp">
                    <AtomNode start="(71, 3)" end="(71, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(73, 1)" end="(76, 7)" name="push_toArray_fun" full_name="List.push_toArray_fun">
      <CommandDeclmodifiersNode start="(73, 1)" end="(74, 8)">
        <NullNode start="(73, 1)" end="(73, 74)">
          <CommandDoccommentNode start="(73, 1)" end="(73, 74)" comment="Unapplied variant of `push_toArray`, useful for monadic reasoning. -/">
            <AtomNode start="(73, 1)" end="(73, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(73, 5)" end="(73, 74)" leading="" trailing="&#10;" val="Unapplied variant of `push_toArray`, useful for monadic reasoning. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(74, 1)" end="(74, 8)">
          <OtherNode start="(74, 1)" end="(74, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(74, 1)" end="(74, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(74, 3)" end="(74, 7)">
              <OtherNode start="(74, 3)" end="(74, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(74, 3)" end="(74, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(74, 3)" end="(74, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(74, 7)" end="(74, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(74, 9)" end="(76, 7)" name="push_toArray_fun" full_name="List.push_toArray_fun" _is_private_decl="False">
        <AtomNode start="(74, 9)" end="(74, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(74, 17)" end="(74, 33)">
          <IdentNode start="(74, 17)" end="(74, 33)" leading="" trailing=" " raw_val="push_toArray_fun" val="push_toArray_fun"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(74, 34)" end="(74, 93)">
          <NullNode start="(74, 34)" end="(74, 46)">
            <TermExplicitbinderNode start="(74, 34)" end="(74, 46)">
              <AtomNode start="(74, 34)" end="(74, 35)" leading="" trailing="" val="("/>
              <NullNode start="(74, 35)" end="(74, 36)">
                <IdentNode start="(74, 35)" end="(74, 36)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(74, 37)" end="(74, 45)">
                <AtomNode start="(74, 37)" end="(74, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(74, 39)" end="(74, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(74, 39)" end="(74, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(74, 44)" end="(74, 45)">
                    <IdentNode start="(74, 44)" end="(74, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(74, 45)" end="(74, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(74, 47)" end="(74, 93)">
            <AtomNode start="(74, 47)" end="(74, 48)" leading="" trailing=" " val=":"/>
            <OtherNode start="(74, 49)" end="(74, 93)" kind="«term_=_»">
              <IdentNode start="(74, 49)" end="(74, 63)" leading="" trailing=" " raw_val="l.toArray.push" val="l.toArray.push"/>
              <AtomNode start="(74, 64)" end="(74, 65)" leading="" trailing=" " val="="/>
              <OtherNode start="(74, 66)" end="(74, 93)" kind="Lean.Parser.Term.fun">
                <AtomNode start="(74, 66)" end="(74, 69)" leading="" trailing=" " val="fun"/>
                <OtherNode start="(74, 70)" end="(74, 93)" kind="Lean.Parser.Term.basicFun">
                  <NullNode start="(74, 70)" end="(74, 71)">
                    <IdentNode start="(74, 70)" end="(74, 71)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(74, 72)" end="(74, 74)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(74, 75)" end="(74, 93)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(74, 75)" end="(74, 85)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(74, 75)" end="(74, 76)" leading="" trailing="" val="("/>
                      <OtherNode start="(74, 76)" end="(74, 84)" kind="«term_++_»">
                        <IdentNode start="(74, 76)" end="(74, 77)" leading="" trailing=" " raw_val="l" val="l"/>
                        <AtomNode start="(74, 78)" end="(74, 80)" leading="" trailing=" " val="++"/>
                        <OtherNode start="(74, 81)" end="(74, 84)" kind="«term[_]»">
                          <AtomNode start="(74, 81)" end="(74, 82)" leading="" trailing="" val="["/>
                          <NullNode start="(74, 82)" end="(74, 83)">
                            <IdentNode start="(74, 82)" end="(74, 83)" leading="" trailing="" raw_val="a" val="a"/>
                          </NullNode>
                          <AtomNode start="(74, 83)" end="(74, 84)" leading="" trailing="" val="]"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(74, 84)" end="(74, 85)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(74, 85)" end="(74, 86)" leading="" trailing="" val="."/>
                    <IdentNode start="(74, 86)" end="(74, 93)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(74, 94)" end="(76, 7)">
          <AtomNode start="(74, 94)" end="(74, 96)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(74, 97)" end="(76, 7)">
            <AtomNode start="(74, 97)" end="(74, 99)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(75, 3)" end="(76, 7)">
              <TacticTacticseq1IndentedNode start="(75, 3)" end="(76, 7)">
                <NullNode start="(75, 3)" end="(76, 7)">
                  <OtherNode start="(75, 3)" end="(75, 11)" kind="tacticFunext___" state_before="α : Type u_1&#10;l : List α&#10;⊢ l.toArray.push = fun a =&amp;gt; (l ++ [a]).toArray" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;a : α&#10;⊢ l.toArray.push a = (l ++ [a]).toArray" tactic="funext a">
                    <AtomNode start="(75, 3)" end="(75, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(75, 10)" end="(75, 11)">
                      <IdentNode start="(75, 10)" end="(75, 11)" leading="" trailing="&#10;  " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(76, 3)" end="(76, 7)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;a : α&#10;⊢ l.toArray.push a = (l ++ [a]).toArray" state_after="no goals" tactic="simp">
                    <AtomNode start="(76, 3)" end="(76, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(78, 1)" end="(79, 35)" name="isEmpty_toArray" full_name="List.isEmpty_toArray">
      <CommandDeclmodifiersNode start="(78, 1)" end="(78, 8)">
        <NullNode/>
        <NullNode start="(78, 1)" end="(78, 8)">
          <OtherNode start="(78, 1)" end="(78, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(78, 1)" end="(78, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(78, 3)" end="(78, 7)">
              <OtherNode start="(78, 3)" end="(78, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(78, 3)" end="(78, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(78, 3)" end="(78, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(78, 7)" end="(78, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(78, 9)" end="(79, 35)" name="isEmpty_toArray" full_name="List.isEmpty_toArray" _is_private_decl="False">
        <AtomNode start="(78, 9)" end="(78, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(78, 17)" end="(78, 32)">
          <IdentNode start="(78, 17)" end="(78, 32)" leading="" trailing=" " raw_val="isEmpty_toArray" val="isEmpty_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(78, 33)" end="(78, 77)">
          <NullNode start="(78, 33)" end="(78, 45)">
            <TermExplicitbinderNode start="(78, 33)" end="(78, 45)">
              <AtomNode start="(78, 33)" end="(78, 34)" leading="" trailing="" val="("/>
              <NullNode start="(78, 34)" end="(78, 35)">
                <IdentNode start="(78, 34)" end="(78, 35)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(78, 36)" end="(78, 44)">
                <AtomNode start="(78, 36)" end="(78, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(78, 38)" end="(78, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(78, 38)" end="(78, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(78, 43)" end="(78, 44)">
                    <IdentNode start="(78, 43)" end="(78, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(78, 44)" end="(78, 45)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(78, 46)" end="(78, 77)">
            <AtomNode start="(78, 46)" end="(78, 47)" leading="" trailing=" " val=":"/>
            <OtherNode start="(78, 48)" end="(78, 77)" kind="«term_=_»">
              <IdentNode start="(78, 48)" end="(78, 65)" leading="" trailing=" " raw_val="l.toArray.isEmpty" val="l.toArray.isEmpty"/>
              <AtomNode start="(78, 66)" end="(78, 67)" leading="" trailing=" " val="="/>
              <IdentNode start="(78, 68)" end="(78, 77)" leading="" trailing=" " raw_val="l.isEmpty" val="l.isEmpty"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(78, 78)" end="(79, 35)">
          <AtomNode start="(78, 78)" end="(78, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(78, 81)" end="(79, 35)">
            <AtomNode start="(78, 81)" end="(78, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(79, 3)" end="(79, 35)">
              <TacticTacticseq1IndentedNode start="(79, 3)" end="(79, 35)">
                <NullNode start="(79, 3)" end="(79, 35)">
                  <OtherNode start="(79, 3)" end="(79, 35)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;l : List α&#10;⊢ l.toArray.isEmpty = l.isEmpty" state_after="no goals" tactic="cases l &amp;lt;;&amp;gt; simp [Array.isEmpty]">
                    <OtherNode start="(79, 3)" end="(79, 10)" kind="Lean.Parser.Tactic.cases">
                      <AtomNode start="(79, 3)" end="(79, 8)" leading="" trailing=" " val="cases"/>
                      <NullNode start="(79, 9)" end="(79, 10)">
                        <OtherNode start="(79, 9)" end="(79, 10)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(79, 9)" end="(79, 10)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(79, 11)" end="(79, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(79, 15)" end="(79, 35)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(79, 15)" end="(79, 19)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(79, 20)" end="(79, 35)">
                        <AtomNode start="(79, 20)" end="(79, 21)" leading="" trailing="" val="["/>
                        <NullNode start="(79, 21)" end="(79, 34)">
                          <OtherNode start="(79, 21)" end="(79, 34)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(79, 21)" end="(79, 34)" leading="" trailing="" raw_val="Array.isEmpty" val="Array.isEmpty" full_name="Array.isEmpty" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(79, 34)" end="(79, 35)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(81, 1)" end="(81, 98)" name="toArray_singleton" full_name="List.toArray_singleton">
      <CommandDeclmodifiersNode start="(81, 1)" end="(81, 8)">
        <NullNode/>
        <NullNode start="(81, 1)" end="(81, 8)">
          <OtherNode start="(81, 1)" end="(81, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(81, 1)" end="(81, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(81, 3)" end="(81, 7)">
              <OtherNode start="(81, 3)" end="(81, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(81, 3)" end="(81, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(81, 3)" end="(81, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(81, 7)" end="(81, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(81, 9)" end="(81, 98)" name="toArray_singleton" full_name="List.toArray_singleton" _is_private_decl="False">
        <AtomNode start="(81, 9)" end="(81, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(81, 17)" end="(81, 34)">
          <IdentNode start="(81, 17)" end="(81, 34)" leading="" trailing=" " raw_val="toArray_singleton" val="toArray_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(81, 35)" end="(81, 91)">
          <NullNode start="(81, 35)" end="(81, 42)">
            <TermExplicitbinderNode start="(81, 35)" end="(81, 42)">
              <AtomNode start="(81, 35)" end="(81, 36)" leading="" trailing="" val="("/>
              <NullNode start="(81, 36)" end="(81, 37)">
                <IdentNode start="(81, 36)" end="(81, 37)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(81, 38)" end="(81, 41)">
                <AtomNode start="(81, 38)" end="(81, 39)" leading="" trailing=" " val=":"/>
                <IdentNode start="(81, 40)" end="(81, 41)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(81, 41)" end="(81, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(81, 43)" end="(81, 91)">
            <AtomNode start="(81, 43)" end="(81, 44)" leading="" trailing=" " val=":"/>
            <OtherNode start="(81, 45)" end="(81, 91)" kind="«term_=_»">
              <OtherNode start="(81, 45)" end="(81, 71)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(81, 45)" end="(81, 63)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(81, 45)" end="(81, 46)" leading="" trailing="" val="("/>
                  <OtherNode start="(81, 46)" end="(81, 62)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(81, 46)" end="(81, 60)" leading="" trailing=" " raw_val="List.singleton" val="List.singleton" full_name="List.singleton" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(81, 61)" end="(81, 62)">
                      <IdentNode start="(81, 61)" end="(81, 62)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(81, 62)" end="(81, 63)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(81, 63)" end="(81, 64)" leading="" trailing="" val="."/>
                <IdentNode start="(81, 64)" end="(81, 71)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(81, 72)" end="(81, 73)" leading="" trailing=" " val="="/>
              <OtherNode start="(81, 74)" end="(81, 91)" kind="Lean.Parser.Term.app">
                <IdentNode start="(81, 74)" end="(81, 89)" leading="" trailing=" " raw_val="Array.singleton" val="Array.singleton" full_name="Array.singleton" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(81, 90)" end="(81, 91)">
                  <IdentNode start="(81, 90)" end="(81, 91)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(81, 92)" end="(81, 98)">
          <AtomNode start="(81, 92)" end="(81, 94)" leading="" trailing=" " val=":="/>
          <IdentNode start="(81, 95)" end="(81, 98)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(83, 1)" end="(84, 74)" name="back!_toArray" full_name="List.back!_toArray">
      <CommandDeclmodifiersNode start="(83, 1)" end="(83, 8)">
        <NullNode/>
        <NullNode start="(83, 1)" end="(83, 8)">
          <OtherNode start="(83, 1)" end="(83, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(83, 1)" end="(83, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(83, 3)" end="(83, 7)">
              <OtherNode start="(83, 3)" end="(83, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(83, 3)" end="(83, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(83, 3)" end="(83, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(83, 7)" end="(83, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(83, 9)" end="(84, 74)" name="back!_toArray" full_name="List.back!_toArray" _is_private_decl="False">
        <AtomNode start="(83, 9)" end="(83, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(83, 17)" end="(83, 30)">
          <IdentNode start="(83, 17)" end="(83, 30)" leading="" trailing=" " raw_val="back!_toArray" val="back!_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(83, 31)" end="(83, 88)">
          <NullNode start="(83, 31)" end="(83, 57)">
            <OtherNode start="(83, 31)" end="(83, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(83, 31)" end="(83, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(83, 32)" end="(83, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(83, 32)" end="(83, 41)" leading="" trailing=" " raw_val="Inhabited" val="Inhabited" full_name="Inhabited" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(83, 42)" end="(83, 43)">
                  <IdentNode start="(83, 42)" end="(83, 43)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(83, 43)" end="(83, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(83, 45)" end="(83, 57)">
              <AtomNode start="(83, 45)" end="(83, 46)" leading="" trailing="" val="("/>
              <NullNode start="(83, 46)" end="(83, 47)">
                <IdentNode start="(83, 46)" end="(83, 47)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(83, 48)" end="(83, 56)">
                <AtomNode start="(83, 48)" end="(83, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(83, 50)" end="(83, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(83, 50)" end="(83, 54)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(83, 55)" end="(83, 56)">
                    <IdentNode start="(83, 55)" end="(83, 56)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(83, 56)" end="(83, 57)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(83, 58)" end="(83, 88)">
            <AtomNode start="(83, 58)" end="(83, 59)" leading="" trailing=" " val=":"/>
            <OtherNode start="(83, 60)" end="(83, 88)" kind="«term_=_»">
              <IdentNode start="(83, 60)" end="(83, 75)" leading="" trailing=" " raw_val="l.toArray.back!" val="l.toArray.back!"/>
              <AtomNode start="(83, 76)" end="(83, 77)" leading="" trailing=" " val="="/>
              <IdentNode start="(83, 78)" end="(83, 88)" leading="" trailing=" " raw_val="l.getLast!" val="l.getLast!"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(83, 89)" end="(84, 74)">
          <AtomNode start="(83, 89)" end="(83, 91)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(83, 92)" end="(84, 74)">
            <AtomNode start="(83, 92)" end="(83, 94)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(84, 3)" end="(84, 74)">
              <TacticTacticseq1IndentedNode start="(84, 3)" end="(84, 74)">
                <NullNode start="(84, 3)" end="(84, 74)">
                  <OtherNode start="(84, 3)" end="(84, 74)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : Inhabited α&#10;l : List α&#10;⊢ l.toArray.back! = l.getLast!" state_after="no goals" tactic="simp only [back!, size_toArray, getElem!_toArray, getLast!_eq_getElem!]">
                    <AtomNode start="(84, 3)" end="(84, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(84, 8)" end="(84, 12)">
                      <AtomNode start="(84, 8)" end="(84, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(84, 13)" end="(84, 74)">
                      <AtomNode start="(84, 13)" end="(84, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(84, 14)" end="(84, 73)">
                        <OtherNode start="(84, 14)" end="(84, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(84, 14)" end="(84, 19)" leading="" trailing="" raw_val="back!" val="back!" full_name="Array.back!" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(84, 19)" end="(84, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(84, 21)" end="(84, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(84, 21)" end="(84, 33)" leading="" trailing="" raw_val="size_toArray" val="size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(84, 33)" end="(84, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(84, 35)" end="(84, 51)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(84, 35)" end="(84, 51)" leading="" trailing="" raw_val="getElem!_toArray" val="getElem!_toArray" full_name="List.getElem!_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(84, 51)" end="(84, 52)" leading="" trailing=" " val=","/>
                        <OtherNode start="(84, 53)" end="(84, 73)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(84, 53)" end="(84, 73)" leading="" trailing="" raw_val="getLast!_eq_getElem!" val="getLast!_eq_getElem!" full_name="List.getLast!_eq_getElem!" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(84, 73)" end="(84, 74)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(86, 1)" end="(87, 42)" name="back?_toArray" full_name="List.back?_toArray">
      <CommandDeclmodifiersNode start="(86, 1)" end="(86, 8)">
        <NullNode/>
        <NullNode start="(86, 1)" end="(86, 8)">
          <OtherNode start="(86, 1)" end="(86, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(86, 1)" end="(86, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(86, 3)" end="(86, 7)">
              <OtherNode start="(86, 3)" end="(86, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(86, 3)" end="(86, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(86, 3)" end="(86, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(86, 7)" end="(86, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(86, 9)" end="(87, 42)" name="back?_toArray" full_name="List.back?_toArray" _is_private_decl="False">
        <AtomNode start="(86, 9)" end="(86, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(86, 17)" end="(86, 30)">
          <IdentNode start="(86, 17)" end="(86, 30)" leading="" trailing=" " raw_val="back?_toArray" val="back?_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(86, 31)" end="(86, 74)">
          <NullNode start="(86, 31)" end="(86, 43)">
            <TermExplicitbinderNode start="(86, 31)" end="(86, 43)">
              <AtomNode start="(86, 31)" end="(86, 32)" leading="" trailing="" val="("/>
              <NullNode start="(86, 32)" end="(86, 33)">
                <IdentNode start="(86, 32)" end="(86, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(86, 34)" end="(86, 42)">
                <AtomNode start="(86, 34)" end="(86, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(86, 36)" end="(86, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(86, 36)" end="(86, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(86, 41)" end="(86, 42)">
                    <IdentNode start="(86, 41)" end="(86, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(86, 42)" end="(86, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(86, 44)" end="(86, 74)">
            <AtomNode start="(86, 44)" end="(86, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(86, 46)" end="(86, 74)" kind="«term_=_»">
              <IdentNode start="(86, 46)" end="(86, 61)" leading="" trailing=" " raw_val="l.toArray.back?" val="l.toArray.back?"/>
              <AtomNode start="(86, 62)" end="(86, 63)" leading="" trailing=" " val="="/>
              <IdentNode start="(86, 64)" end="(86, 74)" leading="" trailing=" " raw_val="l.getLast?" val="l.getLast?"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(86, 75)" end="(87, 42)">
          <AtomNode start="(86, 75)" end="(86, 77)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(86, 78)" end="(87, 42)">
            <AtomNode start="(86, 78)" end="(86, 80)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(87, 3)" end="(87, 42)">
              <TacticTacticseq1IndentedNode start="(87, 3)" end="(87, 42)">
                <NullNode start="(87, 3)" end="(87, 42)">
                  <OtherNode start="(87, 3)" end="(87, 42)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;⊢ l.toArray.back? = l.getLast?" state_after="no goals" tactic="simp [back?, List.getLast?_eq_getElem?]">
                    <AtomNode start="(87, 3)" end="(87, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(87, 8)" end="(87, 42)">
                      <AtomNode start="(87, 8)" end="(87, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(87, 9)" end="(87, 41)">
                        <OtherNode start="(87, 9)" end="(87, 14)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(87, 9)" end="(87, 14)" leading="" trailing="" raw_val="back?" val="back?" full_name="Array.back?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(87, 14)" end="(87, 15)" leading="" trailing=" " val=","/>
                        <OtherNode start="(87, 16)" end="(87, 41)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(87, 16)" end="(87, 41)" leading="" trailing="" raw_val="List.getLast?_eq_getElem?" val="List.getLast?_eq_getElem?" full_name="List.getLast?_eq_getElem?" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(87, 41)" end="(87, 42)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(89, 1)" end="(91, 39)" name="back_toArray" full_name="List.back_toArray">
      <CommandDeclmodifiersNode start="(89, 1)" end="(89, 8)">
        <NullNode/>
        <NullNode start="(89, 1)" end="(89, 8)">
          <OtherNode start="(89, 1)" end="(89, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(89, 1)" end="(89, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(89, 3)" end="(89, 7)">
              <OtherNode start="(89, 3)" end="(89, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(89, 3)" end="(89, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(89, 3)" end="(89, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(89, 7)" end="(89, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(89, 9)" end="(91, 39)" name="back_toArray" full_name="List.back_toArray" _is_private_decl="False">
        <AtomNode start="(89, 9)" end="(89, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(89, 17)" end="(89, 29)">
          <IdentNode start="(89, 17)" end="(89, 29)" leading="" trailing=" " raw_val="back_toArray" val="back_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(89, 30)" end="(90, 76)">
          <NullNode start="(89, 30)" end="(89, 46)">
            <TermExplicitbinderNode start="(89, 30)" end="(89, 42)">
              <AtomNode start="(89, 30)" end="(89, 31)" leading="" trailing="" val="("/>
              <NullNode start="(89, 31)" end="(89, 32)">
                <IdentNode start="(89, 31)" end="(89, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(89, 33)" end="(89, 41)">
                <AtomNode start="(89, 33)" end="(89, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(89, 35)" end="(89, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(89, 35)" end="(89, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(89, 40)" end="(89, 41)">
                    <IdentNode start="(89, 40)" end="(89, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(89, 41)" end="(89, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(89, 43)" end="(89, 46)">
              <AtomNode start="(89, 43)" end="(89, 44)" leading="" trailing="" val="("/>
              <NullNode start="(89, 44)" end="(89, 45)">
                <IdentNode start="(89, 44)" end="(89, 45)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(89, 45)" end="(89, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(89, 47)" end="(90, 76)">
            <AtomNode start="(89, 47)" end="(89, 48)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(90, 5)" end="(90, 76)" kind="«term_=_»">
              <IdentNode start="(90, 5)" end="(90, 19)" leading="" trailing=" " raw_val="l.toArray.back" val="l.toArray.back"/>
              <AtomNode start="(90, 20)" end="(90, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(90, 22)" end="(90, 76)" kind="Lean.Parser.Term.app">
                <IdentNode start="(90, 22)" end="(90, 31)" leading="" trailing=" " raw_val="l.getLast" val="l.getLast"/>
                <NullNode start="(90, 32)" end="(90, 76)">
                  <OtherNode start="(90, 32)" end="(90, 76)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(90, 32)" end="(90, 33)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(90, 33)" end="(90, 75)">
                      <AtomNode start="(90, 33)" end="(90, 35)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(90, 36)" end="(90, 75)">
                        <TacticTacticseq1IndentedNode start="(90, 36)" end="(90, 75)">
                          <NullNode start="(90, 36)" end="(90, 75)">
                            <OtherNode start="(90, 36)" end="(90, 45)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.3888&#10;l : List α&#10;h : 0 &amp;lt; l.toArray.size&#10;⊢ l ≠ []" state_after="α : Type ?u.3888&#10;l : List α&#10;h : 0 &amp;lt; l.length&#10;⊢ l ≠ []" tactic="simp at h">
                              <AtomNode start="(90, 36)" end="(90, 40)" leading="" trailing=" " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(90, 41)" end="(90, 45)">
                                <OtherNode start="(90, 41)" end="(90, 45)" kind="Lean.Parser.Tactic.location">
                                  <AtomNode start="(90, 41)" end="(90, 43)" leading="" trailing=" " val="at"/>
                                  <OtherNode start="(90, 44)" end="(90, 45)" kind="Lean.Parser.Tactic.locationHyp">
                                    <NullNode start="(90, 44)" end="(90, 45)">
                                      <IdentNode start="(90, 44)" end="(90, 45)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(90, 45)" end="(90, 46)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(90, 47)" end="(90, 75)" kind="Lean.Parser.Tactic.exact" state_before="α : Type ?u.3888&#10;l : List α&#10;h : 0 &amp;lt; l.length&#10;⊢ l ≠ []" state_after="no goals" tactic="exact ne_nil_of_length_pos h">
                              <AtomNode start="(90, 47)" end="(90, 52)" leading="" trailing=" " val="exact"/>
                              <OtherNode start="(90, 53)" end="(90, 75)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(90, 53)" end="(90, 73)" leading="" trailing=" " raw_val="ne_nil_of_length_pos" val="ne_nil_of_length_pos" full_name="List.ne_nil_of_length_pos" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                <NullNode start="(90, 74)" end="(90, 75)">
                                  <IdentNode start="(90, 74)" end="(90, 75)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(90, 75)" end="(90, 76)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(90, 77)" end="(91, 39)">
          <AtomNode start="(90, 77)" end="(90, 79)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(90, 80)" end="(91, 39)">
            <AtomNode start="(90, 80)" end="(90, 82)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(91, 3)" end="(91, 39)">
              <TacticTacticseq1IndentedNode start="(91, 3)" end="(91, 39)">
                <NullNode start="(91, 3)" end="(91, 39)">
                  <OtherNode start="(91, 3)" end="(91, 39)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;h : 0 &amp;lt; l.toArray.size&#10;⊢ l.toArray.back h = l.getLast ⋯" state_after="no goals" tactic="simp [back, List.getLast_eq_getElem]">
                    <AtomNode start="(91, 3)" end="(91, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(91, 8)" end="(91, 39)">
                      <AtomNode start="(91, 8)" end="(91, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(91, 9)" end="(91, 38)">
                        <OtherNode start="(91, 9)" end="(91, 13)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(91, 9)" end="(91, 13)" leading="" trailing="" raw_val="back" val="back" full_name="Array.back" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(91, 13)" end="(91, 14)" leading="" trailing=" " val=","/>
                        <OtherNode start="(91, 15)" end="(91, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(91, 15)" end="(91, 38)" leading="" trailing="" raw_val="List.getLast_eq_getElem" val="List.getLast_eq_getElem" full_name="List.getLast_eq_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(91, 38)" end="(91, 39)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(93, 1)" end="(96, 7)" name="_root_.Array.getLast!_toList" full_name="Array.getLast!_toList">
      <CommandDeclmodifiersNode start="(93, 1)" end="(93, 8)">
        <NullNode/>
        <NullNode start="(93, 1)" end="(93, 8)">
          <OtherNode start="(93, 1)" end="(93, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(93, 1)" end="(93, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(93, 3)" end="(93, 7)">
              <OtherNode start="(93, 3)" end="(93, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(93, 3)" end="(93, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(93, 3)" end="(93, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(93, 7)" end="(93, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(93, 9)" end="(96, 7)" name="_root_.Array.getLast!_toList" full_name="Array.getLast!_toList" _is_private_decl="False">
        <AtomNode start="(93, 9)" end="(93, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(93, 17)" end="(93, 45)">
          <IdentNode start="(93, 17)" end="(93, 45)" leading="" trailing=" " raw_val="_root_.Array.getLast!_toList" val="_root_.Array.getLast!_toList"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(93, 46)" end="(94, 34)">
          <NullNode start="(93, 46)" end="(93, 74)">
            <OtherNode start="(93, 46)" end="(93, 59)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(93, 46)" end="(93, 47)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(93, 47)" end="(93, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(93, 47)" end="(93, 56)" leading="" trailing=" " raw_val="Inhabited" val="Inhabited" full_name="Inhabited" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(93, 57)" end="(93, 58)">
                  <IdentNode start="(93, 57)" end="(93, 58)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(93, 58)" end="(93, 59)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(93, 60)" end="(93, 74)">
              <AtomNode start="(93, 60)" end="(93, 61)" leading="" trailing="" val="("/>
              <NullNode start="(93, 61)" end="(93, 63)">
                <IdentNode start="(93, 61)" end="(93, 63)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(93, 64)" end="(93, 73)">
                <AtomNode start="(93, 64)" end="(93, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(93, 66)" end="(93, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(93, 66)" end="(93, 71)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(93, 72)" end="(93, 73)">
                    <IdentNode start="(93, 72)" end="(93, 73)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(93, 73)" end="(93, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(93, 75)" end="(94, 34)">
            <AtomNode start="(93, 75)" end="(93, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(94, 5)" end="(94, 34)" kind="«term_=_»">
              <IdentNode start="(94, 5)" end="(94, 23)" leading="" trailing=" " raw_val="xs.toList.getLast!" val="xs.toList.getLast!"/>
              <AtomNode start="(94, 24)" end="(94, 25)" leading="" trailing=" " val="="/>
              <IdentNode start="(94, 26)" end="(94, 34)" leading="" trailing=" " raw_val="xs.back!" val="xs.back!"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(94, 35)" end="(96, 7)">
          <AtomNode start="(94, 35)" end="(94, 37)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(94, 38)" end="(96, 7)">
            <AtomNode start="(94, 38)" end="(94, 40)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(95, 3)" end="(96, 7)">
              <TacticTacticseq1IndentedNode start="(95, 3)" end="(96, 7)">
                <NullNode start="(95, 3)" end="(96, 7)">
                  <OtherNode start="(95, 3)" end="(95, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝ : Inhabited α&#10;xs : Array α&#10;⊢ xs.toList.getLast! = xs.back!" state_after="case mk&#10;α : Type u_1&#10;inst✝ : Inhabited α&#10;xs : List α&#10;⊢ { toList := xs }.toList.getLast! = { toList := xs }.back!" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(95, 3)" end="(95, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(95, 10)" end="(95, 12)">
                      <OtherNode start="(95, 10)" end="(95, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(95, 10)" end="(95, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(95, 13)" end="(95, 22)">
                      <AtomNode start="(95, 13)" end="(95, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(95, 18)" end="(95, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(95, 18)" end="(95, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(95, 18)" end="(95, 22)">
                            <OtherNode start="(95, 18)" end="(95, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(95, 18)" end="(95, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(95, 19)" end="(95, 21)">
                                <OtherNode start="(95, 19)" end="(95, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(95, 19)" end="(95, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(95, 19)" end="(95, 21)">
                                      <OtherNode start="(95, 19)" end="(95, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(95, 19)" end="(95, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(95, 21)" end="(95, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(96, 3)" end="(96, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;inst✝ : Inhabited α&#10;xs : List α&#10;⊢ { toList := xs }.toList.getLast! = { toList := xs }.back!" state_after="no goals" tactic="simp">
                    <AtomNode start="(96, 3)" end="(96, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(98, 1)" end="(101, 7)" name="_root_.Array.getLast?_toList" full_name="Array.getLast?_toList">
      <CommandDeclmodifiersNode start="(98, 1)" end="(98, 8)">
        <NullNode/>
        <NullNode start="(98, 1)" end="(98, 8)">
          <OtherNode start="(98, 1)" end="(98, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(98, 1)" end="(98, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(98, 3)" end="(98, 7)">
              <OtherNode start="(98, 3)" end="(98, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(98, 3)" end="(98, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(98, 3)" end="(98, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(98, 7)" end="(98, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(98, 9)" end="(101, 7)" name="_root_.Array.getLast?_toList" full_name="Array.getLast?_toList" _is_private_decl="False">
        <AtomNode start="(98, 9)" end="(98, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(98, 17)" end="(98, 45)">
          <IdentNode start="(98, 17)" end="(98, 45)" leading="" trailing=" " raw_val="_root_.Array.getLast?_toList" val="_root_.Array.getLast?_toList"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(98, 46)" end="(99, 34)">
          <NullNode start="(98, 46)" end="(98, 60)">
            <TermExplicitbinderNode start="(98, 46)" end="(98, 60)">
              <AtomNode start="(98, 46)" end="(98, 47)" leading="" trailing="" val="("/>
              <NullNode start="(98, 47)" end="(98, 49)">
                <IdentNode start="(98, 47)" end="(98, 49)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(98, 50)" end="(98, 59)">
                <AtomNode start="(98, 50)" end="(98, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(98, 52)" end="(98, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(98, 52)" end="(98, 57)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(98, 58)" end="(98, 59)">
                    <IdentNode start="(98, 58)" end="(98, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(98, 59)" end="(98, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(98, 61)" end="(99, 34)">
            <AtomNode start="(98, 61)" end="(98, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(99, 5)" end="(99, 34)" kind="«term_=_»">
              <IdentNode start="(99, 5)" end="(99, 23)" leading="" trailing=" " raw_val="xs.toList.getLast?" val="xs.toList.getLast?"/>
              <AtomNode start="(99, 24)" end="(99, 25)" leading="" trailing=" " val="="/>
              <IdentNode start="(99, 26)" end="(99, 34)" leading="" trailing=" " raw_val="xs.back?" val="xs.back?"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(99, 35)" end="(101, 7)">
          <AtomNode start="(99, 35)" end="(99, 37)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(99, 38)" end="(101, 7)">
            <AtomNode start="(99, 38)" end="(99, 40)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(100, 3)" end="(101, 7)">
              <TacticTacticseq1IndentedNode start="(100, 3)" end="(101, 7)">
                <NullNode start="(100, 3)" end="(101, 7)">
                  <OtherNode start="(100, 3)" end="(100, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;⊢ xs.toList.getLast? = xs.back?" state_after="case mk&#10;α : Type u_1&#10;xs : List α&#10;⊢ { toList := xs }.toList.getLast? = { toList := xs }.back?" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(100, 3)" end="(100, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(100, 10)" end="(100, 12)">
                      <OtherNode start="(100, 10)" end="(100, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(100, 10)" end="(100, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(100, 13)" end="(100, 22)">
                      <AtomNode start="(100, 13)" end="(100, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(100, 18)" end="(100, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(100, 18)" end="(100, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(100, 18)" end="(100, 22)">
                            <OtherNode start="(100, 18)" end="(100, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(100, 18)" end="(100, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(100, 19)" end="(100, 21)">
                                <OtherNode start="(100, 19)" end="(100, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(100, 19)" end="(100, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(100, 19)" end="(100, 21)">
                                      <OtherNode start="(100, 19)" end="(100, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(100, 19)" end="(100, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(100, 21)" end="(100, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(101, 3)" end="(101, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;xs : List α&#10;⊢ { toList := xs }.toList.getLast? = { toList := xs }.back?" state_after="no goals" tactic="simp">
                    <AtomNode start="(101, 3)" end="(101, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(103, 1)" end="(106, 7)" name="_root_.Array.getLast_toList" full_name="Array.getLast_toList">
      <CommandDeclmodifiersNode start="(103, 1)" end="(103, 8)">
        <NullNode/>
        <NullNode start="(103, 1)" end="(103, 8)">
          <OtherNode start="(103, 1)" end="(103, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(103, 1)" end="(103, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(103, 3)" end="(103, 7)">
              <OtherNode start="(103, 3)" end="(103, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(103, 3)" end="(103, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(103, 3)" end="(103, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(103, 7)" end="(103, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(103, 9)" end="(106, 7)" name="_root_.Array.getLast_toList" full_name="Array.getLast_toList" _is_private_decl="False">
        <AtomNode start="(103, 9)" end="(103, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(103, 17)" end="(103, 44)">
          <IdentNode start="(103, 17)" end="(103, 44)" leading="" trailing=" " raw_val="_root_.Array.getLast_toList" val="_root_.Array.getLast_toList"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(103, 45)" end="(104, 77)">
          <NullNode start="(103, 45)" end="(103, 63)">
            <TermExplicitbinderNode start="(103, 45)" end="(103, 59)">
              <AtomNode start="(103, 45)" end="(103, 46)" leading="" trailing="" val="("/>
              <NullNode start="(103, 46)" end="(103, 48)">
                <IdentNode start="(103, 46)" end="(103, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(103, 49)" end="(103, 58)">
                <AtomNode start="(103, 49)" end="(103, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(103, 51)" end="(103, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(103, 51)" end="(103, 56)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(103, 57)" end="(103, 58)">
                    <IdentNode start="(103, 57)" end="(103, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(103, 58)" end="(103, 59)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(103, 60)" end="(103, 63)">
              <AtomNode start="(103, 60)" end="(103, 61)" leading="" trailing="" val="("/>
              <NullNode start="(103, 61)" end="(103, 62)">
                <IdentNode start="(103, 61)" end="(103, 62)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(103, 62)" end="(103, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(103, 64)" end="(104, 77)">
            <AtomNode start="(103, 64)" end="(103, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(104, 5)" end="(104, 77)" kind="«term_=_»">
              <OtherNode start="(104, 5)" end="(104, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(104, 5)" end="(104, 22)" leading="" trailing=" " raw_val="xs.toList.getLast" val="xs.toList.getLast"/>
                <NullNode start="(104, 23)" end="(104, 24)">
                  <IdentNode start="(104, 23)" end="(104, 24)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(104, 25)" end="(104, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(104, 27)" end="(104, 77)" kind="Lean.Parser.Term.app">
                <IdentNode start="(104, 27)" end="(104, 34)" leading="" trailing=" " raw_val="xs.back" val="xs.back"/>
                <NullNode start="(104, 35)" end="(104, 77)">
                  <OtherNode start="(104, 35)" end="(104, 77)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(104, 35)" end="(104, 36)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(104, 36)" end="(104, 76)">
                      <AtomNode start="(104, 36)" end="(104, 38)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(104, 39)" end="(104, 76)">
                        <TacticTacticseq1IndentedNode start="(104, 39)" end="(104, 76)">
                          <NullNode start="(104, 39)" end="(104, 76)">
                            <OtherNode start="(104, 39)" end="(104, 76)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type ?u.4619&#10;xs : Array α&#10;h : xs.toList ≠ []&#10;⊢ 0 &amp;lt; xs.size" state_after="no goals" tactic="simpa [ne_nil_iff_length_pos] using h">
                              <AtomNode start="(104, 39)" end="(104, 44)" leading="" trailing=" " val="simpa"/>
                              <NullNode/>
                              <NullNode/>
                              <OtherNode start="(104, 45)" end="(104, 76)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(104, 45)" end="(104, 68)">
                                  <OtherNode start="(104, 45)" end="(104, 68)" kind="Lean.Parser.Tactic.simpArgs">
                                    <AtomNode start="(104, 45)" end="(104, 46)" leading="" trailing="" val="["/>
                                    <NullNode start="(104, 46)" end="(104, 67)">
                                      <OtherNode start="(104, 46)" end="(104, 67)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(104, 46)" end="(104, 67)" leading="" trailing="" raw_val="ne_nil_iff_length_pos" val="ne_nil_iff_length_pos" full_name="List.ne_nil_iff_length_pos" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(104, 67)" end="(104, 68)" leading="" trailing=" " val="]"/>
                                  </OtherNode>
                                </NullNode>
                                <NullNode start="(104, 69)" end="(104, 76)">
                                  <AtomNode start="(104, 69)" end="(104, 74)" leading="" trailing=" " val="using"/>
                                  <IdentNode start="(104, 75)" end="(104, 76)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(104, 76)" end="(104, 77)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(104, 78)" end="(106, 7)">
          <AtomNode start="(104, 78)" end="(104, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(104, 81)" end="(106, 7)">
            <AtomNode start="(104, 81)" end="(104, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(105, 3)" end="(106, 7)">
              <TacticTacticseq1IndentedNode start="(105, 3)" end="(106, 7)">
                <NullNode start="(105, 3)" end="(106, 7)">
                  <OtherNode start="(105, 3)" end="(105, 22)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;xs : Array α&#10;h : xs.toList ≠ []&#10;⊢ xs.toList.getLast h = xs.back ⋯" state_after="case mk&#10;α : Type u_1&#10;xs : List α&#10;h : { toList := xs }.toList ≠ []&#10;⊢ { toList := xs }.toList.getLast h = { toList := xs }.back ⋯" tactic="rcases xs with ⟨xs⟩">
                    <AtomNode start="(105, 3)" end="(105, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(105, 10)" end="(105, 12)">
                      <OtherNode start="(105, 10)" end="(105, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(105, 10)" end="(105, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(105, 13)" end="(105, 22)">
                      <AtomNode start="(105, 13)" end="(105, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(105, 18)" end="(105, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(105, 18)" end="(105, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(105, 18)" end="(105, 22)">
                            <OtherNode start="(105, 18)" end="(105, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(105, 18)" end="(105, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(105, 19)" end="(105, 21)">
                                <OtherNode start="(105, 19)" end="(105, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(105, 19)" end="(105, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(105, 19)" end="(105, 21)">
                                      <OtherNode start="(105, 19)" end="(105, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(105, 19)" end="(105, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(105, 21)" end="(105, 22)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(106, 3)" end="(106, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;xs : List α&#10;h : { toList := xs }.toList ≠ []&#10;⊢ { toList := xs }.toList.getLast h = { toList := xs }.back ⋯" state_after="no goals" tactic="simp">
                    <AtomNode start="(106, 3)" end="(106, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(108, 1)" end="(109, 53)" name="set_toArray" full_name="List.set_toArray">
      <CommandDeclmodifiersNode start="(108, 1)" end="(108, 8)">
        <NullNode/>
        <NullNode start="(108, 1)" end="(108, 8)">
          <OtherNode start="(108, 1)" end="(108, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(108, 1)" end="(108, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(108, 3)" end="(108, 7)">
              <OtherNode start="(108, 3)" end="(108, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(108, 3)" end="(108, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(108, 3)" end="(108, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(108, 7)" end="(108, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(108, 9)" end="(109, 53)" name="set_toArray" full_name="List.set_toArray" _is_private_decl="False">
        <AtomNode start="(108, 9)" end="(108, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(108, 17)" end="(108, 28)">
          <IdentNode start="(108, 17)" end="(108, 28)" leading="" trailing=" " raw_val="set_toArray" val="set_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(108, 29)" end="(109, 46)">
          <NullNode start="(108, 29)" end="(108, 78)">
            <TermExplicitbinderNode start="(108, 29)" end="(108, 41)">
              <AtomNode start="(108, 29)" end="(108, 30)" leading="" trailing="" val="("/>
              <NullNode start="(108, 30)" end="(108, 31)">
                <IdentNode start="(108, 30)" end="(108, 31)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(108, 32)" end="(108, 40)">
                <AtomNode start="(108, 32)" end="(108, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(108, 34)" end="(108, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(108, 34)" end="(108, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(108, 39)" end="(108, 40)">
                    <IdentNode start="(108, 39)" end="(108, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(108, 40)" end="(108, 41)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(108, 42)" end="(108, 51)">
              <AtomNode start="(108, 42)" end="(108, 43)" leading="" trailing="" val="("/>
              <NullNode start="(108, 43)" end="(108, 44)">
                <IdentNode start="(108, 43)" end="(108, 44)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(108, 45)" end="(108, 50)">
                <AtomNode start="(108, 45)" end="(108, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(108, 47)" end="(108, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(108, 50)" end="(108, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(108, 52)" end="(108, 59)">
              <AtomNode start="(108, 52)" end="(108, 53)" leading="" trailing="" val="("/>
              <NullNode start="(108, 53)" end="(108, 54)">
                <IdentNode start="(108, 53)" end="(108, 54)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(108, 55)" end="(108, 58)">
                <AtomNode start="(108, 55)" end="(108, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(108, 57)" end="(108, 58)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(108, 58)" end="(108, 59)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(108, 60)" end="(108, 78)">
              <AtomNode start="(108, 60)" end="(108, 61)" leading="" trailing="" val="("/>
              <NullNode start="(108, 61)" end="(108, 62)">
                <IdentNode start="(108, 61)" end="(108, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(108, 63)" end="(108, 77)">
                <AtomNode start="(108, 63)" end="(108, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(108, 65)" end="(108, 77)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(108, 65)" end="(108, 66)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(108, 67)" end="(108, 68)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(108, 69)" end="(108, 77)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(108, 77)" end="(108, 78)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(108, 79)" end="(109, 46)">
            <AtomNode start="(108, 79)" end="(108, 80)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(109, 5)" end="(109, 46)" kind="«term_=_»">
              <OtherNode start="(109, 5)" end="(109, 24)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(109, 5)" end="(109, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(109, 6)" end="(109, 23)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(109, 6)" end="(109, 19)" leading="" trailing=" " raw_val="l.toArray.set" val="l.toArray.set"/>
                  <NullNode start="(109, 20)" end="(109, 23)">
                    <IdentNode start="(109, 20)" end="(109, 21)" leading="" trailing=" " raw_val="i" val="i"/>
                    <IdentNode start="(109, 22)" end="(109, 23)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(109, 23)" end="(109, 24)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(109, 25)" end="(109, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(109, 27)" end="(109, 46)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(109, 27)" end="(109, 38)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(109, 27)" end="(109, 28)" leading="" trailing="" val="("/>
                  <OtherNode start="(109, 28)" end="(109, 37)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(109, 28)" end="(109, 33)" leading="" trailing=" " raw_val="l.set" val="l.set"/>
                    <NullNode start="(109, 34)" end="(109, 37)">
                      <IdentNode start="(109, 34)" end="(109, 35)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(109, 36)" end="(109, 37)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(109, 37)" end="(109, 38)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(109, 38)" end="(109, 39)" leading="" trailing="" val="."/>
                <IdentNode start="(109, 39)" end="(109, 46)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(109, 47)" end="(109, 53)">
          <AtomNode start="(109, 47)" end="(109, 49)" leading="" trailing=" " val=":="/>
          <IdentNode start="(109, 50)" end="(109, 53)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(111, 1)" end="(127, 10)" name="forIn'_loop_toArray" full_name="List.forIn'_loop_toArray">
      <CommandDeclmodifiersNode start="(111, 1)" end="(111, 8)">
        <NullNode/>
        <NullNode start="(111, 1)" end="(111, 8)">
          <OtherNode start="(111, 1)" end="(111, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(111, 1)" end="(111, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(111, 3)" end="(111, 7)">
              <OtherNode start="(111, 3)" end="(111, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(111, 3)" end="(111, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(111, 3)" end="(111, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(111, 7)" end="(111, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(111, 9)" end="(127, 10)" name="forIn'_loop_toArray" full_name="List.forIn'_loop_toArray" _is_private_decl="False">
        <AtomNode start="(111, 9)" end="(111, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(111, 17)" end="(111, 36)">
          <IdentNode start="(111, 17)" end="(111, 36)" leading="" trailing=" " raw_val="forIn'_loop_toArray" val="forIn'_loop_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(111, 37)" end="(114, 95)">
          <NullNode start="(111, 37)" end="(112, 31)">
            <OtherNode start="(111, 37)" end="(111, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(111, 37)" end="(111, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(111, 38)" end="(111, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(111, 38)" end="(111, 43)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(111, 44)" end="(111, 45)">
                  <IdentNode start="(111, 44)" end="(111, 45)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(111, 45)" end="(111, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(111, 47)" end="(111, 59)">
              <AtomNode start="(111, 47)" end="(111, 48)" leading="" trailing="" val="("/>
              <NullNode start="(111, 48)" end="(111, 49)">
                <IdentNode start="(111, 48)" end="(111, 49)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(111, 50)" end="(111, 58)">
                <AtomNode start="(111, 50)" end="(111, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(111, 52)" end="(111, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(111, 52)" end="(111, 56)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(111, 57)" end="(111, 58)">
                    <IdentNode start="(111, 57)" end="(111, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(111, 58)" end="(111, 59)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(111, 60)" end="(111, 111)">
              <AtomNode start="(111, 60)" end="(111, 61)" leading="" trailing="" val="("/>
              <NullNode start="(111, 61)" end="(111, 62)">
                <IdentNode start="(111, 61)" end="(111, 62)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(111, 63)" end="(111, 110)">
                <AtomNode start="(111, 63)" end="(111, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(111, 65)" end="(111, 110)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(111, 65)" end="(111, 72)">
                    <AtomNode start="(111, 65)" end="(111, 66)" leading="" trailing="" val="("/>
                    <NullNode start="(111, 66)" end="(111, 67)">
                      <IdentNode start="(111, 66)" end="(111, 67)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(111, 68)" end="(111, 71)">
                      <AtomNode start="(111, 68)" end="(111, 69)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(111, 70)" end="(111, 71)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(111, 71)" end="(111, 72)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(111, 73)" end="(111, 74)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(111, 75)" end="(111, 110)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(111, 75)" end="(111, 88)" kind="«term_∈_»">
                      <IdentNode start="(111, 75)" end="(111, 76)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(111, 77)" end="(111, 78)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(111, 79)" end="(111, 88)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
                    </OtherNode>
                    <AtomNode start="(111, 89)" end="(111, 90)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(111, 91)" end="(111, 110)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(111, 91)" end="(111, 92)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(111, 93)" end="(111, 94)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(111, 95)" end="(111, 110)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(111, 95)" end="(111, 96)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(111, 97)" end="(111, 110)">
                          <OtherNode start="(111, 97)" end="(111, 110)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(111, 97)" end="(111, 98)" leading="" trailing="" val="("/>
                            <OtherNode start="(111, 98)" end="(111, 109)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(111, 98)" end="(111, 107)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(111, 108)" end="(111, 109)">
                                <IdentNode start="(111, 108)" end="(111, 109)" leading="" trailing="" raw_val="β" val="β"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(111, 109)" end="(111, 110)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(111, 110)" end="(111, 111)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(111, 112)" end="(111, 121)">
              <AtomNode start="(111, 112)" end="(111, 113)" leading="" trailing="" val="("/>
              <NullNode start="(111, 113)" end="(111, 114)">
                <IdentNode start="(111, 113)" end="(111, 114)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(111, 115)" end="(111, 120)">
                <AtomNode start="(111, 115)" end="(111, 116)" leading="" trailing=" " val=":"/>
                <IdentNode start="(111, 117)" end="(111, 120)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(111, 120)" end="(111, 121)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(112, 5)" end="(112, 23)">
              <AtomNode start="(112, 5)" end="(112, 6)" leading="" trailing="" val="("/>
              <NullNode start="(112, 6)" end="(112, 7)">
                <IdentNode start="(112, 6)" end="(112, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(112, 8)" end="(112, 22)">
                <AtomNode start="(112, 8)" end="(112, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(112, 10)" end="(112, 22)" kind="«term_≤_»">
                  <IdentNode start="(112, 10)" end="(112, 11)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(112, 12)" end="(112, 13)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(112, 14)" end="(112, 22)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(112, 22)" end="(112, 23)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(112, 24)" end="(112, 31)">
              <AtomNode start="(112, 24)" end="(112, 25)" leading="" trailing="" val="("/>
              <NullNode start="(112, 25)" end="(112, 26)">
                <IdentNode start="(112, 25)" end="(112, 26)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(112, 27)" end="(112, 30)">
                <AtomNode start="(112, 27)" end="(112, 28)" leading="" trailing=" " val=":"/>
                <IdentNode start="(112, 29)" end="(112, 30)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(112, 30)" end="(112, 31)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(112, 32)" end="(114, 95)">
            <AtomNode start="(112, 32)" end="(112, 33)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(113, 5)" end="(114, 95)" kind="«term_=_»">
              <OtherNode start="(113, 5)" end="(113, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(113, 5)" end="(113, 22)" leading="" trailing=" " raw_val="Array.forIn'.loop" val="Array.forIn'.loop" full_name="Array.forIn'.loop" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(113, 23)" end="(113, 40)">
                  <IdentNode start="(113, 23)" end="(113, 32)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
                  <IdentNode start="(113, 33)" end="(113, 34)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(113, 35)" end="(113, 36)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(113, 37)" end="(113, 38)" leading="" trailing=" " raw_val="h" val="h"/>
                  <IdentNode start="(113, 39)" end="(113, 40)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(113, 41)" end="(113, 42)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(114, 7)" end="(114, 95)" kind="Lean.Parser.Term.app">
                <IdentNode start="(114, 7)" end="(114, 13)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(114, 14)" end="(114, 95)">
                  <OtherNode start="(114, 14)" end="(114, 37)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(114, 14)" end="(114, 15)" leading="" trailing="" val="("/>
                    <OtherNode start="(114, 15)" end="(114, 36)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(114, 15)" end="(114, 21)" leading="" trailing=" " raw_val="l.drop" val="l.drop"/>
                      <NullNode start="(114, 22)" end="(114, 36)">
                        <OtherNode start="(114, 22)" end="(114, 36)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(114, 22)" end="(114, 23)" leading="" trailing="" val="("/>
                          <OtherNode start="(114, 23)" end="(114, 35)" kind="«term_-_»">
                            <IdentNode start="(114, 23)" end="(114, 31)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                            <AtomNode start="(114, 32)" end="(114, 33)" leading="" trailing=" " val="-"/>
                            <IdentNode start="(114, 34)" end="(114, 35)" leading="" trailing="" raw_val="i" val="i"/>
                          </OtherNode>
                          <AtomNode start="(114, 35)" end="(114, 36)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(114, 36)" end="(114, 37)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(114, 38)" end="(114, 39)" leading="" trailing=" " raw_val="b" val="b"/>
                  <OtherNode start="(114, 40)" end="(114, 95)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(114, 40)" end="(114, 41)" leading="" trailing="" val="("/>
                    <OtherNode start="(114, 41)" end="(114, 94)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(114, 41)" end="(114, 44)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(114, 45)" end="(114, 94)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(114, 45)" end="(114, 50)">
                          <IdentNode start="(114, 45)" end="(114, 46)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(114, 47)" end="(114, 48)" leading="" trailing=" " raw_val="m" val="m"/>
                          <IdentNode start="(114, 49)" end="(114, 50)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(114, 51)" end="(114, 53)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(114, 54)" end="(114, 94)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(114, 54)" end="(114, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(114, 56)" end="(114, 94)">
                            <IdentNode start="(114, 56)" end="(114, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                            <OtherNode start="(114, 58)" end="(114, 92)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(114, 58)" end="(114, 59)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(114, 59)" end="(114, 91)">
                                <AtomNode start="(114, 59)" end="(114, 61)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(114, 62)" end="(114, 91)">
                                  <TacticTacticseq1IndentedNode start="(114, 62)" end="(114, 91)">
                                    <NullNode start="(114, 62)" end="(114, 91)">
                                      <OtherNode start="(114, 62)" end="(114, 91)" kind="Lean.Parser.Tactic.simpa" state_before="m✝ : Type ?u.5112 → Type ?u.5068&#10;α : Type ?u.5073&#10;β : Type ?u.5112&#10;inst✝ : Monad m✝&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m✝ (ForInStep β)&#10;i : Nat&#10;h : i ≤ l.length&#10;b✝ : β&#10;a : α&#10;m : a ∈ drop (l.length - i) l&#10;b : β&#10;⊢ a ∈ l.toArray" state_after="no goals" tactic="simpa using mem_of_mem_drop m">
                                        <AtomNode start="(114, 62)" end="(114, 67)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(114, 68)" end="(114, 91)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(114, 68)" end="(114, 91)">
                                            <AtomNode start="(114, 68)" end="(114, 73)" leading="" trailing=" " val="using"/>
                                            <OtherNode start="(114, 74)" end="(114, 91)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(114, 74)" end="(114, 89)" leading="" trailing=" " raw_val="mem_of_mem_drop" val="mem_of_mem_drop" full_name="List.mem_of_mem_drop" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                              <NullNode start="(114, 90)" end="(114, 91)">
                                                <IdentNode start="(114, 90)" end="(114, 91)" leading="" trailing="" raw_val="m" val="m"/>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(114, 91)" end="(114, 92)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <IdentNode start="(114, 93)" end="(114, 94)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(114, 94)" end="(114, 95)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(114, 96)" end="(127, 10)">
          <AtomNode start="(114, 96)" end="(114, 98)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(114, 99)" end="(127, 10)">
            <AtomNode start="(114, 99)" end="(114, 101)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(115, 3)" end="(127, 10)">
              <TacticTacticseq1IndentedNode start="(115, 3)" end="(127, 10)">
                <NullNode start="(115, 3)" end="(127, 10)">
                  <OtherNode start="(115, 3)" end="(127, 10)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;i : Nat&#10;h : i ≤ l.length&#10;b : β&#10;⊢ Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b" state_after="no goals" tactic="induction i generalizing l b with&#10;| zero =&amp;gt;&#10;  simp [Array.forIn'.loop]&#10;| succ i ih =&amp;gt;&#10;  simp only [Array.forIn'.loop, size_toArray, getElem_toArray, ih]&#10;  have t : drop (l.length - (i + 1)) l = l[l.length - i - 1] :: drop (l.length - i) l := by&#10;    simp only [Nat.sub_add_eq]&#10;    rw [List.drop_sub_one (by omega), List.getElem?_eq_getElem (by omega)]&#10;    simp only [Option.toList_some, singleton_append]&#10;  simp [t]&#10;  have t : l.length - 1 - i = l.length - i - 1 := by omega&#10;  simp only [t]&#10;  congr">
                    <AtomNode start="(115, 3)" end="(115, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(115, 13)" end="(115, 14)">
                      <OtherNode start="(115, 13)" end="(115, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(115, 13)" end="(115, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(115, 15)" end="(115, 31)">
                      <AtomNode start="(115, 15)" end="(115, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(115, 28)" end="(115, 31)">
                        <IdentNode start="(115, 28)" end="(115, 29)" leading="" trailing=" " raw_val="l" val="l"/>
                        <IdentNode start="(115, 30)" end="(115, 31)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(115, 32)" end="(127, 10)">
                      <OtherNode start="(115, 32)" end="(127, 10)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(115, 32)" end="(115, 36)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(116, 3)" end="(127, 10)">
                          <OtherNode start="(116, 3)" end="(117, 29)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(116, 3)" end="(116, 9)">
                              <OtherNode start="(116, 3)" end="(116, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(116, 3)" end="(116, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(116, 5)" end="(116, 9)">
                                  <NullNode/>
                                  <IdentNode start="(116, 5)" end="(116, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(116, 10)" end="(117, 29)">
                              <AtomNode start="(116, 10)" end="(116, 12)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(117, 5)" end="(117, 29)">
                                <TacticTacticseq1IndentedNode start="(117, 5)" end="(117, 29)">
                                  <NullNode start="(117, 5)" end="(117, 29)">
                                    <OtherNode start="(117, 5)" end="(117, 29)" kind="Lean.Parser.Tactic.simp" state_before="case zero&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : 0 ≤ l.length&#10;b : β&#10;⊢ Array.forIn'.loop l.toArray f 0 h b = forIn' (drop (l.length - 0) l) b fun a m b =&amp;gt; f a ⋯ b" state_after="no goals" tactic="simp [Array.forIn'.loop]">
                                      <AtomNode start="(117, 5)" end="(117, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(117, 10)" end="(117, 29)">
                                        <AtomNode start="(117, 10)" end="(117, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(117, 11)" end="(117, 28)">
                                          <OtherNode start="(117, 11)" end="(117, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(117, 11)" end="(117, 28)" leading="" trailing="" raw_val="Array.forIn'.loop" val="Array.forIn'.loop" full_name="Array.forIn'.loop" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(117, 28)" end="(117, 29)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(118, 3)" end="(127, 10)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(118, 3)" end="(118, 14)">
                              <OtherNode start="(118, 3)" end="(118, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(118, 3)" end="(118, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(118, 5)" end="(118, 9)">
                                  <NullNode/>
                                  <IdentNode start="(118, 5)" end="(118, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(118, 10)" end="(118, 14)">
                                  <IdentNode start="(118, 10)" end="(118, 11)" leading="" trailing=" " raw_val="i" val="i"/>
                                  <IdentNode start="(118, 12)" end="(118, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(118, 15)" end="(127, 10)">
                              <AtomNode start="(118, 15)" end="(118, 17)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(119, 5)" end="(127, 10)">
                                <TacticTacticseq1IndentedNode start="(119, 5)" end="(127, 10)">
                                  <NullNode start="(119, 5)" end="(127, 10)">
                                    <OtherNode start="(119, 5)" end="(119, 69)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;⊢ Array.forIn'.loop l.toArray f (i + 1) h b = forIn' (drop (l.length - (i + 1)) l) b fun a m b =&amp;gt; f a ⋯ b" state_after="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;⊢ (do&#10;      let __do_lift ← f l[l.length - 1 - i] ⋯ b&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b) =&#10;    forIn' (drop (l.length - (i + 1)) l) b fun a m b =&amp;gt; f a ⋯ b" tactic="simp only [Array.forIn'.loop, size_toArray, getElem_toArray, ih]">
                                      <AtomNode start="(119, 5)" end="(119, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(119, 10)" end="(119, 14)">
                                        <AtomNode start="(119, 10)" end="(119, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(119, 15)" end="(119, 69)">
                                        <AtomNode start="(119, 15)" end="(119, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(119, 16)" end="(119, 68)">
                                          <OtherNode start="(119, 16)" end="(119, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(119, 16)" end="(119, 33)" leading="" trailing="" raw_val="Array.forIn'.loop" val="Array.forIn'.loop" full_name="Array.forIn'.loop" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(119, 33)" end="(119, 34)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(119, 35)" end="(119, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(119, 35)" end="(119, 47)" leading="" trailing="" raw_val="size_toArray" val="size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(119, 47)" end="(119, 48)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(119, 49)" end="(119, 64)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(119, 49)" end="(119, 64)" leading="" trailing="" raw_val="getElem_toArray" val="getElem_toArray" full_name="List.getElem_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(119, 64)" end="(119, 65)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(119, 66)" end="(119, 68)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(119, 66)" end="(119, 68)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(119, 68)" end="(119, 69)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(120, 5)" end="(123, 55)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;⊢ (do&#10;      let __do_lift ← f l[l.length - 1 - i] ⋯ b&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b) =&#10;    forIn' (drop (l.length - (i + 1)) l) b fun a m b =&amp;gt; f a ⋯ b" state_after="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;t : drop (l.length - (i + 1)) l = l[l.length - i - 1] :: drop (l.length - i) l&#10;⊢ (do&#10;      let __do_lift ← f l[l.length - 1 - i] ⋯ b&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b) =&#10;    forIn' (drop (l.length - (i + 1)) l) b fun a m b =&amp;gt; f a ⋯ b" tactic="have t : drop (l.length - (i + 1)) l = l[l.length - i - 1] :: drop (l.length - i) l := by&#10;  simp only [Nat.sub_add_eq]&#10;  rw [List.drop_sub_one (by omega), List.getElem?_eq_getElem (by omega)]&#10;  simp only [Option.toList_some, singleton_append]">
                                      <AtomNode start="(120, 5)" end="(120, 9)" leading="" trailing=" " val="have"/>
                                      <OtherNode start="(120, 10)" end="(123, 55)" kind="Lean.Parser.Term.haveDecl">
                                        <OtherNode start="(120, 10)" end="(123, 55)" kind="Lean.Parser.Term.haveIdDecl">
                                          <OtherNode start="(120, 10)" end="(120, 11)" kind="Lean.Parser.Term.haveId">
                                            <IdentNode start="(120, 10)" end="(120, 11)" leading="" trailing=" " raw_val="t" val="t"/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode start="(120, 12)" end="(120, 88)">
                                            <TermTypespecNode start="(120, 12)" end="(120, 88)">
                                              <AtomNode start="(120, 12)" end="(120, 13)" leading="" trailing=" " val=":"/>
                                              <OtherNode start="(120, 14)" end="(120, 88)" kind="«term_=_»">
                                                <OtherNode start="(120, 14)" end="(120, 41)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(120, 14)" end="(120, 18)" leading="" trailing=" " raw_val="drop" val="drop" full_name="List.drop" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  <NullNode start="(120, 19)" end="(120, 41)">
                                                    <OtherNode start="(120, 19)" end="(120, 39)" kind="Lean.Parser.Term.paren">
                                                      <AtomNode start="(120, 19)" end="(120, 20)" leading="" trailing="" val="("/>
                                                      <OtherNode start="(120, 20)" end="(120, 38)" kind="«term_-_»">
                                                        <IdentNode start="(120, 20)" end="(120, 28)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                                        <AtomNode start="(120, 29)" end="(120, 30)" leading="" trailing=" " val="-"/>
                                                        <OtherNode start="(120, 31)" end="(120, 38)" kind="Lean.Parser.Term.paren">
                                                          <AtomNode start="(120, 31)" end="(120, 32)" leading="" trailing="" val="("/>
                                                          <OtherNode start="(120, 32)" end="(120, 37)" kind="«term_+_»">
                                                            <IdentNode start="(120, 32)" end="(120, 33)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            <AtomNode start="(120, 34)" end="(120, 35)" leading="" trailing=" " val="+"/>
                                                            <OtherNode start="(120, 36)" end="(120, 37)" kind="num">
                                                            <AtomNode start="(120, 36)" end="(120, 37)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                          <AtomNode start="(120, 37)" end="(120, 38)" leading="" trailing="" val=")"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <AtomNode start="(120, 38)" end="(120, 39)" leading="" trailing=" " val=")"/>
                                                    </OtherNode>
                                                    <IdentNode start="(120, 40)" end="(120, 41)" leading="" trailing=" " raw_val="l" val="l"/>
                                                  </NullNode>
                                                </OtherNode>
                                                <AtomNode start="(120, 42)" end="(120, 43)" leading="" trailing=" " val="="/>
                                                <OtherNode start="(120, 44)" end="(120, 88)" kind="«term_::_»">
                                                  <OtherNode start="(120, 44)" end="(120, 63)" kind="«term__[_]»">
                                                    <IdentNode start="(120, 44)" end="(120, 45)" leading="" trailing="" raw_val="l" val="l"/>
                                                    <AtomNode start="(120, 45)" end="(120, 46)" leading="" trailing="" val="["/>
                                                    <OtherNode start="(120, 46)" end="(120, 62)" kind="«term_-_»">
                                                      <OtherNode start="(120, 46)" end="(120, 58)" kind="«term_-_»">
                                                        <IdentNode start="(120, 46)" end="(120, 54)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                                        <AtomNode start="(120, 55)" end="(120, 56)" leading="" trailing=" " val="-"/>
                                                        <IdentNode start="(120, 57)" end="(120, 58)" leading="" trailing=" " raw_val="i" val="i"/>
                                                      </OtherNode>
                                                      <AtomNode start="(120, 59)" end="(120, 60)" leading="" trailing=" " val="-"/>
                                                      <OtherNode start="(120, 61)" end="(120, 62)" kind="num">
                                                        <AtomNode start="(120, 61)" end="(120, 62)" leading="" trailing="" val="1"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <AtomNode start="(120, 62)" end="(120, 63)" leading="" trailing=" " val="]"/>
                                                  </OtherNode>
                                                  <AtomNode start="(120, 64)" end="(120, 66)" leading="" trailing=" " val="::"/>
                                                  <OtherNode start="(120, 67)" end="(120, 88)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(120, 67)" end="(120, 71)" leading="" trailing=" " raw_val="drop" val="drop" full_name="List.drop" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                    <NullNode start="(120, 72)" end="(120, 88)">
                                                      <OtherNode start="(120, 72)" end="(120, 86)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(120, 72)" end="(120, 73)" leading="" trailing="" val="("/>
                                                        <OtherNode start="(120, 73)" end="(120, 85)" kind="«term_-_»">
                                                          <IdentNode start="(120, 73)" end="(120, 81)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                                          <AtomNode start="(120, 82)" end="(120, 83)" leading="" trailing=" " val="-"/>
                                                          <IdentNode start="(120, 84)" end="(120, 85)" leading="" trailing="" raw_val="i" val="i"/>
                                                        </OtherNode>
                                                        <AtomNode start="(120, 85)" end="(120, 86)" leading="" trailing=" " val=")"/>
                                                      </OtherNode>
                                                      <IdentNode start="(120, 87)" end="(120, 88)" leading="" trailing=" " raw_val="l" val="l"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </TermTypespecNode>
                                          </NullNode>
                                          <AtomNode start="(120, 89)" end="(120, 91)" leading="" trailing=" " val=":="/>
                                          <TermBytacticNode start="(120, 92)" end="(123, 55)">
                                            <AtomNode start="(120, 92)" end="(120, 94)" leading="" trailing="&#10;      " val="by"/>
                                            <TacticTacticseqNode start="(121, 7)" end="(123, 55)">
                                              <TacticTacticseq1IndentedNode start="(121, 7)" end="(123, 55)">
                                                <NullNode start="(121, 7)" end="(123, 55)">
                                                  <OtherNode start="(121, 7)" end="(121, 33)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;⊢ drop (l.length - (i + 1)) l = l[l.length - i - 1] :: drop (l.length - i) l" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;⊢ drop (l.length - i - 1) l = l[l.length - i - 1] :: drop (l.length - i) l" tactic="simp only [Nat.sub_add_eq]">
                                                    <AtomNode start="(121, 7)" end="(121, 11)" leading="" trailing=" " val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode start="(121, 12)" end="(121, 16)">
                                                      <AtomNode start="(121, 12)" end="(121, 16)" leading="" trailing=" " val="only"/>
                                                    </NullNode>
                                                    <NullNode start="(121, 17)" end="(121, 33)">
                                                      <AtomNode start="(121, 17)" end="(121, 18)" leading="" trailing="" val="["/>
                                                      <NullNode start="(121, 18)" end="(121, 32)">
                                                        <OtherNode start="(121, 18)" end="(121, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(121, 18)" end="(121, 32)" leading="" trailing="" raw_val="Nat.sub_add_eq" val="Nat.sub_add_eq" full_name="Nat.sub_add_eq" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(121, 32)" end="(121, 33)" leading="" trailing="&#10;      " val="]"/>
                                                    </NullNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(122, 7)" end="(122, 77)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;⊢ drop (l.length - i - 1) l = l[l.length - i - 1] :: drop (l.length - i) l" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;⊢ (some l[l.length - i - 1]).toList ++ drop (l.length - i) l = l[l.length - i - 1] :: drop (l.length - i) l" tactic="rw [List.drop_sub_one (by omega), List.getElem?_eq_getElem (by omega)]">
                                                    <AtomNode start="(122, 7)" end="(122, 9)" leading="" trailing=" " val="rw"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <OtherNode start="(122, 10)" end="(122, 77)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                      <AtomNode start="(122, 10)" end="(122, 11)" leading="" trailing="" val="["/>
                                                      <NullNode start="(122, 11)" end="(122, 76)">
                                                        <OtherNode start="(122, 11)" end="(122, 39)" kind="Lean.Parser.Tactic.rwRule">
                                                          <NullNode/>
                                                          <OtherNode start="(122, 11)" end="(122, 39)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(122, 11)" end="(122, 28)" leading="" trailing=" " raw_val="List.drop_sub_one" val="List.drop_sub_one" full_name="List.drop_sub_one" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                                            <NullNode start="(122, 29)" end="(122, 39)">
                                                            <OtherNode start="(122, 29)" end="(122, 39)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(122, 29)" end="(122, 30)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(122, 30)" end="(122, 38)">
                                                            <AtomNode start="(122, 30)" end="(122, 32)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(122, 33)" end="(122, 38)">
                                                            <TacticTacticseq1IndentedNode start="(122, 33)" end="(122, 38)">
                                                            <NullNode start="(122, 33)" end="(122, 38)">
                                                            <OtherNode start="(122, 33)" end="(122, 38)" kind="Lean.Parser.Tactic.omega" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;⊢ 0 &amp;lt; l.length - i" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(122, 33)" end="(122, 38)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(122, 38)" end="(122, 39)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <AtomNode start="(122, 39)" end="(122, 40)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(122, 41)" end="(122, 76)" kind="Lean.Parser.Tactic.rwRule">
                                                          <NullNode/>
                                                          <OtherNode start="(122, 41)" end="(122, 76)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(122, 41)" end="(122, 65)" leading="" trailing=" " raw_val="List.getElem?_eq_getElem" val="List.getElem?_eq_getElem" full_name="List.getElem?_eq_getElem" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                            <NullNode start="(122, 66)" end="(122, 76)">
                                                            <OtherNode start="(122, 66)" end="(122, 76)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(122, 66)" end="(122, 67)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(122, 67)" end="(122, 75)">
                                                            <AtomNode start="(122, 67)" end="(122, 69)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(122, 70)" end="(122, 75)">
                                                            <TacticTacticseq1IndentedNode start="(122, 70)" end="(122, 75)">
                                                            <NullNode start="(122, 70)" end="(122, 75)">
                                                            <OtherNode start="(122, 70)" end="(122, 75)" kind="Lean.Parser.Tactic.omega" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;⊢ l.length - i - 1 &amp;lt; l.length" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(122, 70)" end="(122, 75)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(122, 75)" end="(122, 76)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(122, 76)" end="(122, 77)" leading="" trailing="&#10;      " val="]"/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(123, 7)" end="(123, 55)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;⊢ (some l[l.length - i - 1]).toList ++ drop (l.length - i) l = l[l.length - i - 1] :: drop (l.length - i) l" state_after="no goals" tactic="simp only [Option.toList_some, singleton_append]">
                                                    <AtomNode start="(123, 7)" end="(123, 11)" leading="" trailing=" " val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode start="(123, 12)" end="(123, 16)">
                                                      <AtomNode start="(123, 12)" end="(123, 16)" leading="" trailing=" " val="only"/>
                                                    </NullNode>
                                                    <NullNode start="(123, 17)" end="(123, 55)">
                                                      <AtomNode start="(123, 17)" end="(123, 18)" leading="" trailing="" val="["/>
                                                      <NullNode start="(123, 18)" end="(123, 54)">
                                                        <OtherNode start="(123, 18)" end="(123, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(123, 18)" end="(123, 36)" leading="" trailing="" raw_val="Option.toList_some" val="Option.toList_some" full_name="Option.toList_some" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                                        </OtherNode>
                                                        <AtomNode start="(123, 36)" end="(123, 37)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(123, 38)" end="(123, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(123, 38)" end="(123, 54)" leading="" trailing="" raw_val="singleton_append" val="singleton_append" full_name="List.singleton_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(123, 54)" end="(123, 55)" leading="" trailing="&#10;    " val="]"/>
                                                    </NullNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </TermBytacticNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(124, 5)" end="(124, 13)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;t : drop (l.length - (i + 1)) l = l[l.length - i - 1] :: drop (l.length - i) l&#10;⊢ (do&#10;      let __do_lift ← f l[l.length - 1 - i] ⋯ b&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b) =&#10;    forIn' (drop (l.length - (i + 1)) l) b fun a m b =&amp;gt; f a ⋯ b" state_after="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;t : drop (l.length - (i + 1)) l = l[l.length - i - 1] :: drop (l.length - i) l&#10;⊢ (do&#10;      let __do_lift ← f l[l.length - 1 - i] ⋯ b&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b) =&#10;    do&#10;    let x ← f l[l.length - i - 1] ⋯ b&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a' m b =&amp;gt; f a' ⋯ b" tactic="simp [t]">
                                      <AtomNode start="(124, 5)" end="(124, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(124, 10)" end="(124, 13)">
                                        <AtomNode start="(124, 10)" end="(124, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(124, 11)" end="(124, 12)">
                                          <OtherNode start="(124, 11)" end="(124, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(124, 11)" end="(124, 12)" leading="" trailing="" raw_val="t" val="t"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(124, 12)" end="(124, 13)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(125, 5)" end="(125, 61)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;t : drop (l.length - (i + 1)) l = l[l.length - i - 1] :: drop (l.length - i) l&#10;⊢ (do&#10;      let __do_lift ← f l[l.length - 1 - i] ⋯ b&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b) =&#10;    do&#10;    let x ← f l[l.length - i - 1] ⋯ b&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a' m b =&amp;gt; f a' ⋯ b" state_after="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;t✝ : drop (l.length - (i + 1)) l = l[l.length - i - 1] :: drop (l.length - i) l&#10;t : l.length - 1 - i = l.length - i - 1&#10;⊢ (do&#10;      let __do_lift ← f l[l.length - 1 - i] ⋯ b&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b) =&#10;    do&#10;    let x ← f l[l.length - i - 1] ⋯ b&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a' m b =&amp;gt; f a' ⋯ b" tactic="have t : l.length - 1 - i = l.length - i - 1 := by omega">
                                      <AtomNode start="(125, 5)" end="(125, 9)" leading="" trailing=" " val="have"/>
                                      <OtherNode start="(125, 10)" end="(125, 61)" kind="Lean.Parser.Term.haveDecl">
                                        <OtherNode start="(125, 10)" end="(125, 61)" kind="Lean.Parser.Term.haveIdDecl">
                                          <OtherNode start="(125, 10)" end="(125, 11)" kind="Lean.Parser.Term.haveId">
                                            <IdentNode start="(125, 10)" end="(125, 11)" leading="" trailing=" " raw_val="t" val="t"/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode start="(125, 12)" end="(125, 49)">
                                            <TermTypespecNode start="(125, 12)" end="(125, 49)">
                                              <AtomNode start="(125, 12)" end="(125, 13)" leading="" trailing=" " val=":"/>
                                              <OtherNode start="(125, 14)" end="(125, 49)" kind="«term_=_»">
                                                <OtherNode start="(125, 14)" end="(125, 30)" kind="«term_-_»">
                                                  <OtherNode start="(125, 14)" end="(125, 26)" kind="«term_-_»">
                                                    <IdentNode start="(125, 14)" end="(125, 22)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                                    <AtomNode start="(125, 23)" end="(125, 24)" leading="" trailing=" " val="-"/>
                                                    <OtherNode start="(125, 25)" end="(125, 26)" kind="num">
                                                      <AtomNode start="(125, 25)" end="(125, 26)" leading="" trailing=" " val="1"/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <AtomNode start="(125, 27)" end="(125, 28)" leading="" trailing=" " val="-"/>
                                                  <IdentNode start="(125, 29)" end="(125, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                                                </OtherNode>
                                                <AtomNode start="(125, 31)" end="(125, 32)" leading="" trailing=" " val="="/>
                                                <OtherNode start="(125, 33)" end="(125, 49)" kind="«term_-_»">
                                                  <OtherNode start="(125, 33)" end="(125, 45)" kind="«term_-_»">
                                                    <IdentNode start="(125, 33)" end="(125, 41)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                                    <AtomNode start="(125, 42)" end="(125, 43)" leading="" trailing=" " val="-"/>
                                                    <IdentNode start="(125, 44)" end="(125, 45)" leading="" trailing=" " raw_val="i" val="i"/>
                                                  </OtherNode>
                                                  <AtomNode start="(125, 46)" end="(125, 47)" leading="" trailing=" " val="-"/>
                                                  <OtherNode start="(125, 48)" end="(125, 49)" kind="num">
                                                    <AtomNode start="(125, 48)" end="(125, 49)" leading="" trailing=" " val="1"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </TermTypespecNode>
                                          </NullNode>
                                          <AtomNode start="(125, 50)" end="(125, 52)" leading="" trailing=" " val=":="/>
                                          <TermBytacticNode start="(125, 53)" end="(125, 61)">
                                            <AtomNode start="(125, 53)" end="(125, 55)" leading="" trailing=" " val="by"/>
                                            <TacticTacticseqNode start="(125, 56)" end="(125, 61)">
                                              <TacticTacticseq1IndentedNode start="(125, 56)" end="(125, 61)">
                                                <NullNode start="(125, 56)" end="(125, 61)">
                                                  <OtherNode start="(125, 56)" end="(125, 61)" kind="Lean.Parser.Tactic.omega" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;t : drop (l.length - (i + 1)) l = l[l.length - i - 1] :: drop (l.length - i) l&#10;⊢ l.length - 1 - i = l.length - i - 1" state_after="no goals" tactic="omega">
                                                    <AtomNode start="(125, 56)" end="(125, 61)" leading="" trailing="&#10;    " val="omega"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </TermBytacticNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(126, 5)" end="(126, 18)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;t✝ : drop (l.length - (i + 1)) l = l[l.length - i - 1] :: drop (l.length - i) l&#10;t : l.length - 1 - i = l.length - i - 1&#10;⊢ (do&#10;      let __do_lift ← f l[l.length - 1 - i] ⋯ b&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b) =&#10;    do&#10;    let x ← f l[l.length - i - 1] ⋯ b&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a' m b =&amp;gt; f a' ⋯ b" state_after="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;t✝ : drop (l.length - (i + 1)) l = l[l.length - i - 1] :: drop (l.length - i) l&#10;t : l.length - 1 - i = l.length - i - 1&#10;⊢ (do&#10;      let __do_lift ← f l[l.length - i - 1] ⋯ b&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b) =&#10;    do&#10;    let x ← f l[l.length - i - 1] ⋯ b&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a' m b =&amp;gt; f a' ⋯ b" tactic="simp only [t]">
                                      <AtomNode start="(126, 5)" end="(126, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(126, 10)" end="(126, 14)">
                                        <AtomNode start="(126, 10)" end="(126, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(126, 15)" end="(126, 18)">
                                        <AtomNode start="(126, 15)" end="(126, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(126, 16)" end="(126, 17)">
                                          <OtherNode start="(126, 16)" end="(126, 17)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(126, 16)" end="(126, 17)" leading="" trailing="" raw_val="t" val="t"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(126, 17)" end="(126, 18)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(127, 5)" end="(127, 10)" kind="Lean.Parser.Tactic.congr" state_before="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;i : Nat&#10;ih :&#10;  ∀ (l : List α) (f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)) (h : i ≤ l.length) (b : β),&#10;    Array.forIn'.loop l.toArray f i h b = forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b&#10;l : List α&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;h : i + 1 ≤ l.length&#10;b : β&#10;t✝ : drop (l.length - (i + 1)) l = l[l.length - i - 1] :: drop (l.length - i) l&#10;t : l.length - 1 - i = l.length - i - 1&#10;⊢ (do&#10;      let __do_lift ← f l[l.length - i - 1] ⋯ b&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a m b =&amp;gt; f a ⋯ b) =&#10;    do&#10;    let x ← f l[l.length - i - 1] ⋯ b&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' (drop (l.length - i) l) b fun a' m b =&amp;gt; f a' ⋯ b" state_after="no goals" tactic="congr">
                                      <AtomNode start="(127, 5)" end="(127, 10)" leading="" trailing="&#10;&#10;" val="congr"/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(129, 1)" end="(133, 7)" name="forIn'_toArray" full_name="List.forIn'_toArray">
      <CommandDeclmodifiersNode start="(129, 1)" end="(129, 8)">
        <NullNode/>
        <NullNode start="(129, 1)" end="(129, 8)">
          <OtherNode start="(129, 1)" end="(129, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(129, 1)" end="(129, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(129, 3)" end="(129, 7)">
              <OtherNode start="(129, 3)" end="(129, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(129, 3)" end="(129, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(129, 3)" end="(129, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(129, 7)" end="(129, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(129, 9)" end="(133, 7)" name="forIn'_toArray" full_name="List.forIn'_toArray" _is_private_decl="False">
        <AtomNode start="(129, 9)" end="(129, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(129, 17)" end="(129, 31)">
          <IdentNode start="(129, 17)" end="(129, 31)" leading="" trailing=" " raw_val="forIn'_toArray" val="forIn'_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(129, 32)" end="(130, 79)">
          <NullNode start="(129, 32)" end="(129, 114)">
            <OtherNode start="(129, 32)" end="(129, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(129, 32)" end="(129, 33)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(129, 33)" end="(129, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(129, 33)" end="(129, 38)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(129, 39)" end="(129, 40)">
                  <IdentNode start="(129, 39)" end="(129, 40)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(129, 40)" end="(129, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(129, 42)" end="(129, 54)">
              <AtomNode start="(129, 42)" end="(129, 43)" leading="" trailing="" val="("/>
              <NullNode start="(129, 43)" end="(129, 44)">
                <IdentNode start="(129, 43)" end="(129, 44)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(129, 45)" end="(129, 53)">
                <AtomNode start="(129, 45)" end="(129, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(129, 47)" end="(129, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(129, 47)" end="(129, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(129, 52)" end="(129, 53)">
                    <IdentNode start="(129, 52)" end="(129, 53)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(129, 53)" end="(129, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(129, 55)" end="(129, 62)">
              <AtomNode start="(129, 55)" end="(129, 56)" leading="" trailing="" val="("/>
              <NullNode start="(129, 56)" end="(129, 57)">
                <IdentNode start="(129, 56)" end="(129, 57)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(129, 58)" end="(129, 61)">
                <AtomNode start="(129, 58)" end="(129, 59)" leading="" trailing=" " val=":"/>
                <IdentNode start="(129, 60)" end="(129, 61)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(129, 61)" end="(129, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(129, 63)" end="(129, 114)">
              <AtomNode start="(129, 63)" end="(129, 64)" leading="" trailing="" val="("/>
              <NullNode start="(129, 64)" end="(129, 65)">
                <IdentNode start="(129, 64)" end="(129, 65)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(129, 66)" end="(129, 113)">
                <AtomNode start="(129, 66)" end="(129, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(129, 68)" end="(129, 113)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(129, 68)" end="(129, 75)">
                    <AtomNode start="(129, 68)" end="(129, 69)" leading="" trailing="" val="("/>
                    <NullNode start="(129, 69)" end="(129, 70)">
                      <IdentNode start="(129, 69)" end="(129, 70)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(129, 71)" end="(129, 74)">
                      <AtomNode start="(129, 71)" end="(129, 72)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(129, 73)" end="(129, 74)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(129, 74)" end="(129, 75)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(129, 76)" end="(129, 77)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(129, 78)" end="(129, 113)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(129, 78)" end="(129, 91)" kind="«term_∈_»">
                      <IdentNode start="(129, 78)" end="(129, 79)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(129, 80)" end="(129, 81)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(129, 82)" end="(129, 91)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
                    </OtherNode>
                    <AtomNode start="(129, 92)" end="(129, 93)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(129, 94)" end="(129, 113)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(129, 94)" end="(129, 95)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(129, 96)" end="(129, 97)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(129, 98)" end="(129, 113)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(129, 98)" end="(129, 99)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(129, 100)" end="(129, 113)">
                          <OtherNode start="(129, 100)" end="(129, 113)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(129, 100)" end="(129, 101)" leading="" trailing="" val="("/>
                            <OtherNode start="(129, 101)" end="(129, 112)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(129, 101)" end="(129, 110)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(129, 111)" end="(129, 112)">
                                <IdentNode start="(129, 111)" end="(129, 112)" leading="" trailing="" raw_val="β" val="β"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(129, 112)" end="(129, 113)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(129, 113)" end="(129, 114)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(129, 115)" end="(130, 79)">
            <AtomNode start="(129, 115)" end="(129, 116)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(130, 5)" end="(130, 79)" kind="«term_=_»">
              <OtherNode start="(130, 5)" end="(130, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(130, 5)" end="(130, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(130, 12)" end="(130, 25)">
                  <IdentNode start="(130, 12)" end="(130, 21)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
                  <IdentNode start="(130, 22)" end="(130, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                  <IdentNode start="(130, 24)" end="(130, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(130, 26)" end="(130, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(130, 28)" end="(130, 79)" kind="Lean.Parser.Term.app">
                <IdentNode start="(130, 28)" end="(130, 34)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(130, 35)" end="(130, 79)">
                  <IdentNode start="(130, 35)" end="(130, 36)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(130, 37)" end="(130, 38)" leading="" trailing=" " raw_val="b" val="b"/>
                  <OtherNode start="(130, 39)" end="(130, 79)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(130, 39)" end="(130, 40)" leading="" trailing="" val="("/>
                    <OtherNode start="(130, 40)" end="(130, 78)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(130, 40)" end="(130, 43)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(130, 44)" end="(130, 78)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(130, 44)" end="(130, 49)">
                          <IdentNode start="(130, 44)" end="(130, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(130, 46)" end="(130, 47)" leading="" trailing=" " raw_val="m" val="m"/>
                          <IdentNode start="(130, 48)" end="(130, 49)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(130, 50)" end="(130, 52)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(130, 53)" end="(130, 78)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(130, 53)" end="(130, 54)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(130, 55)" end="(130, 78)">
                            <IdentNode start="(130, 55)" end="(130, 56)" leading="" trailing=" " raw_val="a" val="a"/>
                            <OtherNode start="(130, 57)" end="(130, 76)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(130, 57)" end="(130, 58)" leading="" trailing="" val="("/>
                              <OtherNode start="(130, 58)" end="(130, 75)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(130, 58)" end="(130, 73)" leading="" trailing=" " raw_val="mem_toArray.mpr" val="mem_toArray.mpr"/>
                                <NullNode start="(130, 74)" end="(130, 75)">
                                  <IdentNode start="(130, 74)" end="(130, 75)" leading="" trailing="" raw_val="m" val="m"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(130, 75)" end="(130, 76)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <IdentNode start="(130, 77)" end="(130, 78)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(130, 78)" end="(130, 79)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(130, 80)" end="(133, 7)">
          <AtomNode start="(130, 80)" end="(130, 82)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(130, 83)" end="(133, 7)">
            <AtomNode start="(130, 83)" end="(130, 85)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(131, 3)" end="(133, 7)">
              <TacticTacticseq1IndentedNode start="(131, 3)" end="(133, 7)">
                <NullNode start="(131, 3)" end="(133, 7)">
                  <OtherNode start="(131, 3)" end="(131, 48)" kind="Lean.Parser.Tactic.change" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;l : List α&#10;b : β&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;⊢ forIn' l.toArray b f = forIn' l b fun a m b =&amp;gt; f a ⋯ b" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;l : List α&#10;b : β&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;⊢ l.toArray.forIn' b f = l.forIn' b fun a m b =&amp;gt; f a ⋯ b" tactic="change Array.forIn' _ _ _ = List.forIn' _ _ _">
                    <AtomNode start="(131, 3)" end="(131, 9)" leading="" trailing=" " val="change"/>
                    <OtherNode start="(131, 10)" end="(131, 48)" kind="«term_=_»">
                      <OtherNode start="(131, 10)" end="(131, 28)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(131, 10)" end="(131, 22)" leading="" trailing=" " raw_val="Array.forIn'" val="Array.forIn'" full_name="Array.forIn'" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        <NullNode start="(131, 23)" end="(131, 28)">
                          <TermHoleNode start="(131, 23)" end="(131, 24)">
                            <AtomNode start="(131, 23)" end="(131, 24)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                          <TermHoleNode start="(131, 25)" end="(131, 26)">
                            <AtomNode start="(131, 25)" end="(131, 26)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                          <TermHoleNode start="(131, 27)" end="(131, 28)">
                            <AtomNode start="(131, 27)" end="(131, 28)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(131, 29)" end="(131, 30)" leading="" trailing=" " val="="/>
                      <OtherNode start="(131, 31)" end="(131, 48)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(131, 31)" end="(131, 42)" leading="" trailing=" " raw_val="List.forIn'" val="List.forIn'" full_name="List.forIn'" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                        <NullNode start="(131, 43)" end="(131, 48)">
                          <TermHoleNode start="(131, 43)" end="(131, 44)">
                            <AtomNode start="(131, 43)" end="(131, 44)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                          <TermHoleNode start="(131, 45)" end="(131, 46)">
                            <AtomNode start="(131, 45)" end="(131, 46)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                          <TermHoleNode start="(131, 47)" end="(131, 48)">
                            <AtomNode start="(131, 47)" end="(131, 48)" leading="" trailing="&#10;  " val="_"/>
                          </TermHoleNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(132, 3)" end="(132, 41)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;l : List α&#10;b : β&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;⊢ l.toArray.forIn' b f = l.forIn' b fun a m b =&amp;gt; f a ⋯ b" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;l : List α&#10;b : β&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;⊢ (forIn' (drop (l.length - l.toArray.size) l) b fun a m b =&amp;gt; f a ⋯ b) = l.forIn' b fun a m b =&amp;gt; f a ⋯ b" tactic="rw [Array.forIn', forIn'_loop_toArray]">
                    <AtomNode start="(132, 3)" end="(132, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(132, 6)" end="(132, 41)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(132, 6)" end="(132, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(132, 7)" end="(132, 40)">
                        <OtherNode start="(132, 7)" end="(132, 19)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(132, 7)" end="(132, 19)" leading="" trailing="" raw_val="Array.forIn'" val="Array.forIn'" full_name="Array.forIn'" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(132, 19)" end="(132, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(132, 21)" end="(132, 40)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(132, 21)" end="(132, 40)" leading="" trailing="" raw_val="forIn'_loop_toArray" val="forIn'_loop_toArray" full_name="List.forIn'_loop_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(111, 17)" def_end="(111, 36)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(132, 40)" end="(132, 41)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(133, 3)" end="(133, 7)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;l : List α&#10;b : β&#10;f : (a : α) → a ∈ l.toArray → β → m (ForInStep β)&#10;⊢ (forIn' (drop (l.length - l.toArray.size) l) b fun a m b =&amp;gt; f a ⋯ b) = l.forIn' b fun a m b =&amp;gt; f a ⋯ b" state_after="no goals" tactic="simp">
                    <AtomNode start="(133, 3)" end="(133, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(135, 1)" end="(137, 52)" name="forIn_toArray" full_name="List.forIn_toArray">
      <CommandDeclmodifiersNode start="(135, 1)" end="(135, 8)">
        <NullNode/>
        <NullNode start="(135, 1)" end="(135, 8)">
          <OtherNode start="(135, 1)" end="(135, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(135, 1)" end="(135, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(135, 3)" end="(135, 7)">
              <OtherNode start="(135, 3)" end="(135, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(135, 3)" end="(135, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(135, 3)" end="(135, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(135, 7)" end="(135, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(135, 9)" end="(137, 52)" name="forIn_toArray" full_name="List.forIn_toArray" _is_private_decl="False">
        <AtomNode start="(135, 9)" end="(135, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(135, 17)" end="(135, 30)">
          <IdentNode start="(135, 17)" end="(135, 30)" leading="" trailing=" " raw_val="forIn_toArray" val="forIn_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(135, 31)" end="(136, 38)">
          <NullNode start="(135, 31)" end="(135, 91)">
            <OtherNode start="(135, 31)" end="(135, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(135, 31)" end="(135, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(135, 32)" end="(135, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(135, 32)" end="(135, 37)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(135, 38)" end="(135, 39)">
                  <IdentNode start="(135, 38)" end="(135, 39)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(135, 39)" end="(135, 40)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(135, 41)" end="(135, 53)">
              <AtomNode start="(135, 41)" end="(135, 42)" leading="" trailing="" val="("/>
              <NullNode start="(135, 42)" end="(135, 43)">
                <IdentNode start="(135, 42)" end="(135, 43)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(135, 44)" end="(135, 52)">
                <AtomNode start="(135, 44)" end="(135, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(135, 46)" end="(135, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(135, 46)" end="(135, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(135, 51)" end="(135, 52)">
                    <IdentNode start="(135, 51)" end="(135, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(135, 52)" end="(135, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(135, 54)" end="(135, 61)">
              <AtomNode start="(135, 54)" end="(135, 55)" leading="" trailing="" val="("/>
              <NullNode start="(135, 55)" end="(135, 56)">
                <IdentNode start="(135, 55)" end="(135, 56)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(135, 57)" end="(135, 60)">
                <AtomNode start="(135, 57)" end="(135, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(135, 59)" end="(135, 60)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(135, 60)" end="(135, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(135, 62)" end="(135, 91)">
              <AtomNode start="(135, 62)" end="(135, 63)" leading="" trailing="" val="("/>
              <NullNode start="(135, 63)" end="(135, 64)">
                <IdentNode start="(135, 63)" end="(135, 64)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(135, 65)" end="(135, 90)">
                <AtomNode start="(135, 65)" end="(135, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(135, 67)" end="(135, 90)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(135, 67)" end="(135, 68)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(135, 69)" end="(135, 70)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(135, 71)" end="(135, 90)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(135, 71)" end="(135, 72)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(135, 73)" end="(135, 74)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(135, 75)" end="(135, 90)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(135, 75)" end="(135, 76)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(135, 77)" end="(135, 90)">
                        <OtherNode start="(135, 77)" end="(135, 90)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(135, 77)" end="(135, 78)" leading="" trailing="" val="("/>
                          <OtherNode start="(135, 78)" end="(135, 89)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(135, 78)" end="(135, 87)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                            <NullNode start="(135, 88)" end="(135, 89)">
                              <IdentNode start="(135, 88)" end="(135, 89)" leading="" trailing="" raw_val="β" val="β"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(135, 89)" end="(135, 90)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(135, 90)" end="(135, 91)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(135, 92)" end="(136, 38)">
            <AtomNode start="(135, 92)" end="(135, 93)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(136, 5)" end="(136, 38)" kind="«term_=_»">
              <OtherNode start="(136, 5)" end="(136, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(136, 5)" end="(136, 10)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(136, 11)" end="(136, 24)">
                  <IdentNode start="(136, 11)" end="(136, 20)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
                  <IdentNode start="(136, 21)" end="(136, 22)" leading="" trailing=" " raw_val="b" val="b"/>
                  <IdentNode start="(136, 23)" end="(136, 24)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(136, 25)" end="(136, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(136, 27)" end="(136, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(136, 27)" end="(136, 32)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(136, 33)" end="(136, 38)">
                  <IdentNode start="(136, 33)" end="(136, 34)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(136, 35)" end="(136, 36)" leading="" trailing=" " raw_val="b" val="b"/>
                  <IdentNode start="(136, 37)" end="(136, 38)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(136, 39)" end="(137, 52)">
          <AtomNode start="(136, 39)" end="(136, 41)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(136, 42)" end="(137, 52)">
            <AtomNode start="(136, 42)" end="(136, 44)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(137, 3)" end="(137, 52)">
              <TacticTacticseq1IndentedNode start="(137, 3)" end="(137, 52)">
                <NullNode start="(137, 3)" end="(137, 52)">
                  <OtherNode start="(137, 3)" end="(137, 52)" kind="Lean.Parser.Tactic.simpa" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;l : List α&#10;b : β&#10;f : α → β → m (ForInStep β)&#10;⊢ forIn l.toArray b f = forIn l b f" state_after="no goals" tactic="simpa using forIn'_toArray l b fun a m b =&amp;gt; f a b">
                    <AtomNode start="(137, 3)" end="(137, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(137, 9)" end="(137, 52)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(137, 9)" end="(137, 52)">
                        <AtomNode start="(137, 9)" end="(137, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(137, 15)" end="(137, 52)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(137, 15)" end="(137, 29)" leading="" trailing=" " raw_val="forIn'_toArray" val="forIn'_toArray" full_name="List.forIn'_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(129, 17)" def_end="(129, 31)"/>
                          <NullNode start="(137, 30)" end="(137, 52)">
                            <IdentNode start="(137, 30)" end="(137, 31)" leading="" trailing=" " raw_val="l" val="l"/>
                            <IdentNode start="(137, 32)" end="(137, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                            <OtherNode start="(137, 34)" end="(137, 52)" kind="Lean.Parser.Term.fun">
                              <AtomNode start="(137, 34)" end="(137, 37)" leading="" trailing=" " val="fun"/>
                              <OtherNode start="(137, 38)" end="(137, 52)" kind="Lean.Parser.Term.basicFun">
                                <NullNode start="(137, 38)" end="(137, 43)">
                                  <IdentNode start="(137, 38)" end="(137, 39)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(137, 40)" end="(137, 41)" leading="" trailing=" " raw_val="m" val="m"/>
                                  <IdentNode start="(137, 42)" end="(137, 43)" leading="" trailing=" " raw_val="b" val="b"/>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(137, 44)" end="(137, 46)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(137, 47)" end="(137, 52)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(137, 47)" end="(137, 48)" leading="" trailing=" " raw_val="f" val="f"/>
                                  <NullNode start="(137, 49)" end="(137, 52)">
                                    <IdentNode start="(137, 49)" end="(137, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                                    <IdentNode start="(137, 51)" end="(137, 52)" leading="" trailing="&#10;&#10;" raw_val="b" val="b"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(139, 1)" end="(142, 7)" name="foldrM_toArray" full_name="List.foldrM_toArray">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(139, 1)" end="(142, 7)" name="foldrM_toArray" full_name="List.foldrM_toArray" _is_private_decl="False">
        <AtomNode start="(139, 1)" end="(139, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(139, 9)" end="(139, 23)">
          <IdentNode start="(139, 9)" end="(139, 23)" leading="" trailing=" " raw_val="foldrM_toArray" val="foldrM_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(139, 24)" end="(140, 46)">
          <NullNode start="(139, 24)" end="(139, 75)">
            <OtherNode start="(139, 24)" end="(139, 33)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(139, 24)" end="(139, 25)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(139, 25)" end="(139, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(139, 25)" end="(139, 30)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(139, 31)" end="(139, 32)">
                  <IdentNode start="(139, 31)" end="(139, 32)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(139, 32)" end="(139, 33)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(139, 34)" end="(139, 51)">
              <AtomNode start="(139, 34)" end="(139, 35)" leading="" trailing="" val="("/>
              <NullNode start="(139, 35)" end="(139, 36)">
                <IdentNode start="(139, 35)" end="(139, 36)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(139, 37)" end="(139, 50)">
                <AtomNode start="(139, 37)" end="(139, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(139, 39)" end="(139, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(139, 39)" end="(139, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(139, 41)" end="(139, 42)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(139, 43)" end="(139, 50)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(139, 43)" end="(139, 44)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(139, 45)" end="(139, 46)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(139, 47)" end="(139, 50)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(139, 47)" end="(139, 48)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(139, 49)" end="(139, 50)">
                        <IdentNode start="(139, 49)" end="(139, 50)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(139, 50)" end="(139, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(139, 52)" end="(139, 62)">
              <AtomNode start="(139, 52)" end="(139, 53)" leading="" trailing="" val="("/>
              <NullNode start="(139, 53)" end="(139, 57)">
                <IdentNode start="(139, 53)" end="(139, 57)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(139, 58)" end="(139, 61)">
                <AtomNode start="(139, 58)" end="(139, 59)" leading="" trailing=" " val=":"/>
                <IdentNode start="(139, 60)" end="(139, 61)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(139, 61)" end="(139, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(139, 63)" end="(139, 75)">
              <AtomNode start="(139, 63)" end="(139, 64)" leading="" trailing="" val="("/>
              <NullNode start="(139, 64)" end="(139, 65)">
                <IdentNode start="(139, 64)" end="(139, 65)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(139, 66)" end="(139, 74)">
                <AtomNode start="(139, 66)" end="(139, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(139, 68)" end="(139, 74)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(139, 68)" end="(139, 72)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(139, 73)" end="(139, 74)">
                    <IdentNode start="(139, 73)" end="(139, 74)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(139, 74)" end="(139, 75)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(139, 76)" end="(140, 46)">
            <AtomNode start="(139, 76)" end="(139, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(140, 5)" end="(140, 46)" kind="«term_=_»">
              <OtherNode start="(140, 5)" end="(140, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(140, 5)" end="(140, 21)" leading="" trailing=" " raw_val="l.toArray.foldrM" val="l.toArray.foldrM"/>
                <NullNode start="(140, 22)" end="(140, 28)">
                  <IdentNode start="(140, 22)" end="(140, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(140, 24)" end="(140, 28)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(140, 29)" end="(140, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(140, 31)" end="(140, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(140, 31)" end="(140, 39)" leading="" trailing=" " raw_val="l.foldrM" val="l.foldrM"/>
                <NullNode start="(140, 40)" end="(140, 46)">
                  <IdentNode start="(140, 40)" end="(140, 41)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(140, 42)" end="(140, 46)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(140, 47)" end="(142, 7)">
          <AtomNode start="(140, 47)" end="(140, 49)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(140, 50)" end="(142, 7)">
            <AtomNode start="(140, 50)" end="(140, 52)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(141, 3)" end="(142, 7)">
              <TacticTacticseq1IndentedNode start="(141, 3)" end="(142, 7)">
                <NullNode start="(141, 3)" end="(142, 7)">
                  <OtherNode start="(141, 3)" end="(141, 39)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;f : α → β → m β&#10;init : β&#10;l : List α&#10;⊢ Array.foldrM f init l.toArray = foldrM f init l" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;f : α → β → m β&#10;init : β&#10;l : List α&#10;⊢ foldlM (fun x y =&amp;gt; f y x) init l.toArray.toList.reverse = foldrM f init l" tactic="rw [foldrM_eq_reverse_foldlM_toList]">
                    <AtomNode start="(141, 3)" end="(141, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(141, 6)" end="(141, 39)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(141, 6)" end="(141, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(141, 7)" end="(141, 38)">
                        <OtherNode start="(141, 7)" end="(141, 38)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(141, 7)" end="(141, 38)" leading="" trailing="" raw_val="foldrM_eq_reverse_foldlM_toList" val="foldrM_eq_reverse_foldlM_toList" full_name="Array.foldrM_eq_reverse_foldlM_toList" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(141, 38)" end="(141, 39)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(142, 3)" end="(142, 7)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;f : α → β → m β&#10;init : β&#10;l : List α&#10;⊢ foldlM (fun x y =&amp;gt; f y x) init l.toArray.toList.reverse = foldrM f init l" state_after="no goals" tactic="simp">
                    <AtomNode start="(142, 3)" end="(142, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(144, 1)" end="(146, 21)" name="foldlM_toArray" full_name="List.foldlM_toArray">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(144, 1)" end="(146, 21)" name="foldlM_toArray" full_name="List.foldlM_toArray" _is_private_decl="False">
        <AtomNode start="(144, 1)" end="(144, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(144, 9)" end="(144, 23)">
          <IdentNode start="(144, 9)" end="(144, 23)" leading="" trailing=" " raw_val="foldlM_toArray" val="foldlM_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(144, 24)" end="(145, 46)">
          <NullNode start="(144, 24)" end="(144, 75)">
            <OtherNode start="(144, 24)" end="(144, 33)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(144, 24)" end="(144, 25)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(144, 25)" end="(144, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(144, 25)" end="(144, 30)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(144, 31)" end="(144, 32)">
                  <IdentNode start="(144, 31)" end="(144, 32)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(144, 32)" end="(144, 33)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(144, 34)" end="(144, 51)">
              <AtomNode start="(144, 34)" end="(144, 35)" leading="" trailing="" val="("/>
              <NullNode start="(144, 35)" end="(144, 36)">
                <IdentNode start="(144, 35)" end="(144, 36)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(144, 37)" end="(144, 50)">
                <AtomNode start="(144, 37)" end="(144, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(144, 39)" end="(144, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(144, 39)" end="(144, 40)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(144, 41)" end="(144, 42)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(144, 43)" end="(144, 50)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(144, 43)" end="(144, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(144, 45)" end="(144, 46)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(144, 47)" end="(144, 50)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(144, 47)" end="(144, 48)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(144, 49)" end="(144, 50)">
                        <IdentNode start="(144, 49)" end="(144, 50)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(144, 50)" end="(144, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(144, 52)" end="(144, 62)">
              <AtomNode start="(144, 52)" end="(144, 53)" leading="" trailing="" val="("/>
              <NullNode start="(144, 53)" end="(144, 57)">
                <IdentNode start="(144, 53)" end="(144, 57)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(144, 58)" end="(144, 61)">
                <AtomNode start="(144, 58)" end="(144, 59)" leading="" trailing=" " val=":"/>
                <IdentNode start="(144, 60)" end="(144, 61)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(144, 61)" end="(144, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(144, 63)" end="(144, 75)">
              <AtomNode start="(144, 63)" end="(144, 64)" leading="" trailing="" val="("/>
              <NullNode start="(144, 64)" end="(144, 65)">
                <IdentNode start="(144, 64)" end="(144, 65)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(144, 66)" end="(144, 74)">
                <AtomNode start="(144, 66)" end="(144, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(144, 68)" end="(144, 74)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(144, 68)" end="(144, 72)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(144, 73)" end="(144, 74)">
                    <IdentNode start="(144, 73)" end="(144, 74)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(144, 74)" end="(144, 75)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(144, 76)" end="(145, 46)">
            <AtomNode start="(144, 76)" end="(144, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(145, 5)" end="(145, 46)" kind="«term_=_»">
              <OtherNode start="(145, 5)" end="(145, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(145, 5)" end="(145, 21)" leading="" trailing=" " raw_val="l.toArray.foldlM" val="l.toArray.foldlM"/>
                <NullNode start="(145, 22)" end="(145, 28)">
                  <IdentNode start="(145, 22)" end="(145, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(145, 24)" end="(145, 28)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(145, 29)" end="(145, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(145, 31)" end="(145, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(145, 31)" end="(145, 39)" leading="" trailing=" " raw_val="l.foldlM" val="l.foldlM"/>
                <NullNode start="(145, 40)" end="(145, 46)">
                  <IdentNode start="(145, 40)" end="(145, 41)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(145, 42)" end="(145, 46)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(145, 47)" end="(146, 21)">
          <AtomNode start="(145, 47)" end="(145, 49)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(145, 50)" end="(146, 21)">
            <AtomNode start="(145, 50)" end="(145, 52)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(146, 3)" end="(146, 21)">
              <TacticTacticseq1IndentedNode start="(146, 3)" end="(146, 21)">
                <NullNode start="(146, 3)" end="(146, 21)">
                  <OtherNode start="(146, 3)" end="(146, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;α : Type u_3&#10;inst✝ : Monad m&#10;f : β → α → m β&#10;init : β&#10;l : List α&#10;⊢ Array.foldlM f init l.toArray = foldlM f init l" state_after="no goals" tactic="rw [foldlM_toList]">
                    <AtomNode start="(146, 3)" end="(146, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(146, 6)" end="(146, 21)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(146, 6)" end="(146, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(146, 7)" end="(146, 20)">
                        <OtherNode start="(146, 7)" end="(146, 20)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(146, 7)" end="(146, 20)" leading="" trailing="" raw_val="foldlM_toList" val="foldlM_toList" full_name="Array.foldlM_toList" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(146, 20)" end="(146, 21)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(148, 1)" end="(150, 20)" name="foldr_toArray" full_name="List.foldr_toArray">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(148, 1)" end="(150, 20)" name="foldr_toArray" full_name="List.foldr_toArray" _is_private_decl="False">
        <AtomNode start="(148, 1)" end="(148, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(148, 9)" end="(148, 22)">
          <IdentNode start="(148, 9)" end="(148, 22)" leading="" trailing=" " raw_val="foldr_toArray" val="foldr_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(148, 23)" end="(149, 44)">
          <NullNode start="(148, 23)" end="(148, 62)">
            <TermExplicitbinderNode start="(148, 23)" end="(148, 38)">
              <AtomNode start="(148, 23)" end="(148, 24)" leading="" trailing="" val="("/>
              <NullNode start="(148, 24)" end="(148, 25)">
                <IdentNode start="(148, 24)" end="(148, 25)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(148, 26)" end="(148, 37)">
                <AtomNode start="(148, 26)" end="(148, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(148, 28)" end="(148, 37)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(148, 28)" end="(148, 29)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(148, 30)" end="(148, 31)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(148, 32)" end="(148, 37)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(148, 32)" end="(148, 33)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(148, 34)" end="(148, 35)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(148, 36)" end="(148, 37)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(148, 37)" end="(148, 38)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(148, 39)" end="(148, 49)">
              <AtomNode start="(148, 39)" end="(148, 40)" leading="" trailing="" val="("/>
              <NullNode start="(148, 40)" end="(148, 44)">
                <IdentNode start="(148, 40)" end="(148, 44)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(148, 45)" end="(148, 48)">
                <AtomNode start="(148, 45)" end="(148, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(148, 47)" end="(148, 48)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(148, 48)" end="(148, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(148, 50)" end="(148, 62)">
              <AtomNode start="(148, 50)" end="(148, 51)" leading="" trailing="" val="("/>
              <NullNode start="(148, 51)" end="(148, 52)">
                <IdentNode start="(148, 51)" end="(148, 52)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(148, 53)" end="(148, 61)">
                <AtomNode start="(148, 53)" end="(148, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(148, 55)" end="(148, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(148, 55)" end="(148, 59)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(148, 60)" end="(148, 61)">
                    <IdentNode start="(148, 60)" end="(148, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(148, 61)" end="(148, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(148, 63)" end="(149, 44)">
            <AtomNode start="(148, 63)" end="(148, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(149, 5)" end="(149, 44)" kind="«term_=_»">
              <OtherNode start="(149, 5)" end="(149, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(149, 5)" end="(149, 20)" leading="" trailing=" " raw_val="l.toArray.foldr" val="l.toArray.foldr"/>
                <NullNode start="(149, 21)" end="(149, 27)">
                  <IdentNode start="(149, 21)" end="(149, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(149, 23)" end="(149, 27)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(149, 28)" end="(149, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(149, 30)" end="(149, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(149, 30)" end="(149, 37)" leading="" trailing=" " raw_val="l.foldr" val="l.foldr"/>
                <NullNode start="(149, 38)" end="(149, 44)">
                  <IdentNode start="(149, 38)" end="(149, 39)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(149, 40)" end="(149, 44)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(149, 45)" end="(150, 20)">
          <AtomNode start="(149, 45)" end="(149, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(149, 48)" end="(150, 20)">
            <AtomNode start="(149, 48)" end="(149, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(150, 3)" end="(150, 20)">
              <TacticTacticseq1IndentedNode start="(150, 3)" end="(150, 20)">
                <NullNode start="(150, 3)" end="(150, 20)">
                  <OtherNode start="(150, 3)" end="(150, 20)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → β → β&#10;init : β&#10;l : List α&#10;⊢ Array.foldr f init l.toArray = foldr f init l" state_after="no goals" tactic="rw [foldr_toList]">
                    <AtomNode start="(150, 3)" end="(150, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(150, 6)" end="(150, 20)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(150, 6)" end="(150, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(150, 7)" end="(150, 19)">
                        <OtherNode start="(150, 7)" end="(150, 19)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(150, 7)" end="(150, 19)" leading="" trailing="" raw_val="foldr_toList" val="foldr_toList" full_name="Array.foldr_toList" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(150, 19)" end="(150, 20)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(152, 1)" end="(154, 20)" name="foldl_toArray" full_name="List.foldl_toArray">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(152, 1)" end="(154, 20)" name="foldl_toArray" full_name="List.foldl_toArray" _is_private_decl="False">
        <AtomNode start="(152, 1)" end="(152, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(152, 9)" end="(152, 22)">
          <IdentNode start="(152, 9)" end="(152, 22)" leading="" trailing=" " raw_val="foldl_toArray" val="foldl_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(152, 23)" end="(153, 44)">
          <NullNode start="(152, 23)" end="(152, 62)">
            <TermExplicitbinderNode start="(152, 23)" end="(152, 38)">
              <AtomNode start="(152, 23)" end="(152, 24)" leading="" trailing="" val="("/>
              <NullNode start="(152, 24)" end="(152, 25)">
                <IdentNode start="(152, 24)" end="(152, 25)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(152, 26)" end="(152, 37)">
                <AtomNode start="(152, 26)" end="(152, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(152, 28)" end="(152, 37)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(152, 28)" end="(152, 29)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(152, 30)" end="(152, 31)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(152, 32)" end="(152, 37)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(152, 32)" end="(152, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(152, 34)" end="(152, 35)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(152, 36)" end="(152, 37)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(152, 37)" end="(152, 38)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(152, 39)" end="(152, 49)">
              <AtomNode start="(152, 39)" end="(152, 40)" leading="" trailing="" val="("/>
              <NullNode start="(152, 40)" end="(152, 44)">
                <IdentNode start="(152, 40)" end="(152, 44)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(152, 45)" end="(152, 48)">
                <AtomNode start="(152, 45)" end="(152, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(152, 47)" end="(152, 48)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(152, 48)" end="(152, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(152, 50)" end="(152, 62)">
              <AtomNode start="(152, 50)" end="(152, 51)" leading="" trailing="" val="("/>
              <NullNode start="(152, 51)" end="(152, 52)">
                <IdentNode start="(152, 51)" end="(152, 52)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(152, 53)" end="(152, 61)">
                <AtomNode start="(152, 53)" end="(152, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(152, 55)" end="(152, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(152, 55)" end="(152, 59)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(152, 60)" end="(152, 61)">
                    <IdentNode start="(152, 60)" end="(152, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(152, 61)" end="(152, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(152, 63)" end="(153, 44)">
            <AtomNode start="(152, 63)" end="(152, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(153, 5)" end="(153, 44)" kind="«term_=_»">
              <OtherNode start="(153, 5)" end="(153, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(153, 5)" end="(153, 20)" leading="" trailing=" " raw_val="l.toArray.foldl" val="l.toArray.foldl"/>
                <NullNode start="(153, 21)" end="(153, 27)">
                  <IdentNode start="(153, 21)" end="(153, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(153, 23)" end="(153, 27)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(153, 28)" end="(153, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(153, 30)" end="(153, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(153, 30)" end="(153, 37)" leading="" trailing=" " raw_val="l.foldl" val="l.foldl"/>
                <NullNode start="(153, 38)" end="(153, 44)">
                  <IdentNode start="(153, 38)" end="(153, 39)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(153, 40)" end="(153, 44)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(153, 45)" end="(154, 20)">
          <AtomNode start="(153, 45)" end="(153, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(153, 48)" end="(154, 20)">
            <AtomNode start="(153, 48)" end="(153, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(154, 3)" end="(154, 20)">
              <TacticTacticseq1IndentedNode start="(154, 3)" end="(154, 20)">
                <NullNode start="(154, 3)" end="(154, 20)">
                  <OtherNode start="(154, 3)" end="(154, 20)" kind="Lean.Parser.Tactic.rwSeq" state_before="β : Type u_1&#10;α : Type u_2&#10;f : β → α → β&#10;init : β&#10;l : List α&#10;⊢ Array.foldl f init l.toArray = foldl f init l" state_after="no goals" tactic="rw [foldl_toList]">
                    <AtomNode start="(154, 3)" end="(154, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(154, 6)" end="(154, 20)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(154, 6)" end="(154, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(154, 7)" end="(154, 19)">
                        <OtherNode start="(154, 7)" end="(154, 19)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(154, 7)" end="(154, 19)" leading="" trailing="" raw_val="foldl_toList" val="foldl_toList" full_name="Array.foldl_toList" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(154, 19)" end="(154, 20)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(156, 1)" end="(162, 7)" name="foldrM_toArray'" full_name="List.foldrM_toArray'">
      <CommandDeclmodifiersNode start="(156, 1)" end="(157, 8)">
        <NullNode start="(156, 1)" end="(156, 83)">
          <CommandDoccommentNode start="(156, 1)" end="(156, 83)" comment="Variant of `foldrM_toArray` with a side condition for the `start` argument. -/">
            <AtomNode start="(156, 1)" end="(156, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(156, 5)" end="(156, 83)" leading="" trailing="&#10;" val="Variant of `foldrM_toArray` with a side condition for the `start` argument. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(157, 1)" end="(157, 8)">
          <OtherNode start="(157, 1)" end="(157, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(157, 1)" end="(157, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(157, 3)" end="(157, 7)">
              <OtherNode start="(157, 3)" end="(157, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(157, 3)" end="(157, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(157, 3)" end="(157, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(157, 7)" end="(157, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(157, 9)" end="(162, 7)" name="foldrM_toArray'" full_name="List.foldrM_toArray'" _is_private_decl="False">
        <AtomNode start="(157, 9)" end="(157, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(157, 17)" end="(157, 32)">
          <IdentNode start="(157, 17)" end="(157, 32)" leading="" trailing=" " raw_val="foldrM_toArray'" val="foldrM_toArray'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(157, 33)" end="(159, 54)">
          <NullNode start="(157, 33)" end="(158, 33)">
            <OtherNode start="(157, 33)" end="(157, 42)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(157, 33)" end="(157, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(157, 34)" end="(157, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(157, 34)" end="(157, 39)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(157, 40)" end="(157, 41)">
                  <IdentNode start="(157, 40)" end="(157, 41)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(157, 41)" end="(157, 42)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(157, 43)" end="(157, 60)">
              <AtomNode start="(157, 43)" end="(157, 44)" leading="" trailing="" val="("/>
              <NullNode start="(157, 44)" end="(157, 45)">
                <IdentNode start="(157, 44)" end="(157, 45)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(157, 46)" end="(157, 59)">
                <AtomNode start="(157, 46)" end="(157, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(157, 48)" end="(157, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(157, 48)" end="(157, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(157, 50)" end="(157, 51)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(157, 52)" end="(157, 59)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(157, 52)" end="(157, 53)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(157, 54)" end="(157, 55)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(157, 56)" end="(157, 59)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(157, 56)" end="(157, 57)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(157, 58)" end="(157, 59)">
                        <IdentNode start="(157, 58)" end="(157, 59)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(157, 59)" end="(157, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(157, 61)" end="(157, 71)">
              <AtomNode start="(157, 61)" end="(157, 62)" leading="" trailing="" val="("/>
              <NullNode start="(157, 62)" end="(157, 66)">
                <IdentNode start="(157, 62)" end="(157, 66)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(157, 67)" end="(157, 70)">
                <AtomNode start="(157, 67)" end="(157, 68)" leading="" trailing=" " val=":"/>
                <IdentNode start="(157, 69)" end="(157, 70)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(157, 70)" end="(157, 71)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(157, 72)" end="(157, 84)">
              <AtomNode start="(157, 72)" end="(157, 73)" leading="" trailing="" val="("/>
              <NullNode start="(157, 73)" end="(157, 74)">
                <IdentNode start="(157, 73)" end="(157, 74)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(157, 75)" end="(157, 83)">
                <AtomNode start="(157, 75)" end="(157, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(157, 77)" end="(157, 83)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(157, 77)" end="(157, 81)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(157, 82)" end="(157, 83)">
                    <IdentNode start="(157, 82)" end="(157, 83)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(157, 83)" end="(157, 84)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(158, 5)" end="(158, 33)">
              <AtomNode start="(158, 5)" end="(158, 6)" leading="" trailing="" val="("/>
              <NullNode start="(158, 6)" end="(158, 7)">
                <IdentNode start="(158, 6)" end="(158, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(158, 8)" end="(158, 32)">
                <AtomNode start="(158, 8)" end="(158, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(158, 10)" end="(158, 32)" kind="«term_=_»">
                  <IdentNode start="(158, 10)" end="(158, 15)" leading="" trailing=" " raw_val="start" val="start"/>
                  <AtomNode start="(158, 16)" end="(158, 17)" leading="" trailing=" " val="="/>
                  <IdentNode start="(158, 18)" end="(158, 32)" leading="" trailing="" raw_val="l.toArray.size" val="l.toArray.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(158, 32)" end="(158, 33)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(158, 34)" end="(159, 54)">
            <AtomNode start="(158, 34)" end="(158, 35)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(159, 5)" end="(159, 54)" kind="«term_=_»">
              <OtherNode start="(159, 5)" end="(159, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(159, 5)" end="(159, 21)" leading="" trailing=" " raw_val="l.toArray.foldrM" val="l.toArray.foldrM"/>
                <NullNode start="(159, 22)" end="(159, 36)">
                  <IdentNode start="(159, 22)" end="(159, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(159, 24)" end="(159, 28)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(159, 29)" end="(159, 34)" leading="" trailing=" " raw_val="start" val="start"/>
                  <OtherNode start="(159, 35)" end="(159, 36)" kind="num">
                    <AtomNode start="(159, 35)" end="(159, 36)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(159, 37)" end="(159, 38)" leading="" trailing=" " val="="/>
              <OtherNode start="(159, 39)" end="(159, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(159, 39)" end="(159, 47)" leading="" trailing=" " raw_val="l.foldrM" val="l.foldrM"/>
                <NullNode start="(159, 48)" end="(159, 54)">
                  <IdentNode start="(159, 48)" end="(159, 49)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(159, 50)" end="(159, 54)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(159, 55)" end="(162, 7)">
          <AtomNode start="(159, 55)" end="(159, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(159, 58)" end="(162, 7)">
            <AtomNode start="(159, 58)" end="(159, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(160, 3)" end="(162, 7)">
              <TacticTacticseq1IndentedNode start="(160, 3)" end="(162, 7)">
                <NullNode start="(160, 3)" end="(162, 7)">
                  <OtherNode start="(160, 3)" end="(160, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;start : Nat&#10;inst✝ : Monad m&#10;f : α → β → m β&#10;init : β&#10;l : List α&#10;h : start = l.toArray.size&#10;⊢ Array.foldrM f init l.toArray start = foldrM f init l" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;f : α → β → m β&#10;init : β&#10;l : List α&#10;⊢ Array.foldrM f init l.toArray = foldrM f init l" tactic="subst h">
                    <AtomNode start="(160, 3)" end="(160, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(160, 9)" end="(160, 10)">
                      <IdentNode start="(160, 9)" end="(160, 10)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(161, 3)" end="(161, 39)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;f : α → β → m β&#10;init : β&#10;l : List α&#10;⊢ Array.foldrM f init l.toArray = foldrM f init l" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;f : α → β → m β&#10;init : β&#10;l : List α&#10;⊢ foldlM (fun x y =&amp;gt; f y x) init l.toArray.toList.reverse = foldrM f init l" tactic="rw [foldrM_eq_reverse_foldlM_toList]">
                    <AtomNode start="(161, 3)" end="(161, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(161, 6)" end="(161, 39)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(161, 6)" end="(161, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(161, 7)" end="(161, 38)">
                        <OtherNode start="(161, 7)" end="(161, 38)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(161, 7)" end="(161, 38)" leading="" trailing="" raw_val="foldrM_eq_reverse_foldlM_toList" val="foldrM_eq_reverse_foldlM_toList" full_name="Array.foldrM_eq_reverse_foldlM_toList" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(161, 38)" end="(161, 39)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(162, 3)" end="(162, 7)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;f : α → β → m β&#10;init : β&#10;l : List α&#10;⊢ foldlM (fun x y =&amp;gt; f y x) init l.toArray.toList.reverse = foldrM f init l" state_after="no goals" tactic="simp">
                    <AtomNode start="(162, 3)" end="(162, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(164, 1)" end="(169, 21)" name="foldlM_toArray'" full_name="List.foldlM_toArray'">
      <CommandDeclmodifiersNode start="(164, 1)" end="(165, 8)">
        <NullNode start="(164, 1)" end="(164, 82)">
          <CommandDoccommentNode start="(164, 1)" end="(164, 82)" comment="Variant of `foldlM_toArray` with a side condition for the `stop` argument. -/">
            <AtomNode start="(164, 1)" end="(164, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(164, 5)" end="(164, 82)" leading="" trailing="&#10;" val="Variant of `foldlM_toArray` with a side condition for the `stop` argument. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(165, 1)" end="(165, 8)">
          <OtherNode start="(165, 1)" end="(165, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(165, 1)" end="(165, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(165, 3)" end="(165, 7)">
              <OtherNode start="(165, 3)" end="(165, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(165, 3)" end="(165, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(165, 3)" end="(165, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(165, 7)" end="(165, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(165, 9)" end="(169, 21)" name="foldlM_toArray'" full_name="List.foldlM_toArray'" _is_private_decl="False">
        <AtomNode start="(165, 9)" end="(165, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(165, 17)" end="(165, 32)">
          <IdentNode start="(165, 17)" end="(165, 32)" leading="" trailing=" " raw_val="foldlM_toArray'" val="foldlM_toArray'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(165, 33)" end="(167, 53)">
          <NullNode start="(165, 33)" end="(166, 32)">
            <OtherNode start="(165, 33)" end="(165, 42)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(165, 33)" end="(165, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(165, 34)" end="(165, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(165, 34)" end="(165, 39)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(165, 40)" end="(165, 41)">
                  <IdentNode start="(165, 40)" end="(165, 41)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(165, 41)" end="(165, 42)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(165, 43)" end="(165, 60)">
              <AtomNode start="(165, 43)" end="(165, 44)" leading="" trailing="" val="("/>
              <NullNode start="(165, 44)" end="(165, 45)">
                <IdentNode start="(165, 44)" end="(165, 45)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(165, 46)" end="(165, 59)">
                <AtomNode start="(165, 46)" end="(165, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(165, 48)" end="(165, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(165, 48)" end="(165, 49)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(165, 50)" end="(165, 51)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(165, 52)" end="(165, 59)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(165, 52)" end="(165, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(165, 54)" end="(165, 55)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(165, 56)" end="(165, 59)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(165, 56)" end="(165, 57)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(165, 58)" end="(165, 59)">
                        <IdentNode start="(165, 58)" end="(165, 59)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(165, 59)" end="(165, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(165, 61)" end="(165, 71)">
              <AtomNode start="(165, 61)" end="(165, 62)" leading="" trailing="" val="("/>
              <NullNode start="(165, 62)" end="(165, 66)">
                <IdentNode start="(165, 62)" end="(165, 66)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(165, 67)" end="(165, 70)">
                <AtomNode start="(165, 67)" end="(165, 68)" leading="" trailing=" " val=":"/>
                <IdentNode start="(165, 69)" end="(165, 70)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(165, 70)" end="(165, 71)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(165, 72)" end="(165, 84)">
              <AtomNode start="(165, 72)" end="(165, 73)" leading="" trailing="" val="("/>
              <NullNode start="(165, 73)" end="(165, 74)">
                <IdentNode start="(165, 73)" end="(165, 74)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(165, 75)" end="(165, 83)">
                <AtomNode start="(165, 75)" end="(165, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(165, 77)" end="(165, 83)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(165, 77)" end="(165, 81)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(165, 82)" end="(165, 83)">
                    <IdentNode start="(165, 82)" end="(165, 83)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(165, 83)" end="(165, 84)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(166, 5)" end="(166, 32)">
              <AtomNode start="(166, 5)" end="(166, 6)" leading="" trailing="" val="("/>
              <NullNode start="(166, 6)" end="(166, 7)">
                <IdentNode start="(166, 6)" end="(166, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(166, 8)" end="(166, 31)">
                <AtomNode start="(166, 8)" end="(166, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(166, 10)" end="(166, 31)" kind="«term_=_»">
                  <IdentNode start="(166, 10)" end="(166, 14)" leading="" trailing=" " raw_val="stop" val="stop"/>
                  <AtomNode start="(166, 15)" end="(166, 16)" leading="" trailing=" " val="="/>
                  <IdentNode start="(166, 17)" end="(166, 31)" leading="" trailing="" raw_val="l.toArray.size" val="l.toArray.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(166, 31)" end="(166, 32)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(166, 33)" end="(167, 53)">
            <AtomNode start="(166, 33)" end="(166, 34)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(167, 5)" end="(167, 53)" kind="«term_=_»">
              <OtherNode start="(167, 5)" end="(167, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(167, 5)" end="(167, 21)" leading="" trailing=" " raw_val="l.toArray.foldlM" val="l.toArray.foldlM"/>
                <NullNode start="(167, 22)" end="(167, 35)">
                  <IdentNode start="(167, 22)" end="(167, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(167, 24)" end="(167, 28)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(167, 29)" end="(167, 30)" kind="num">
                    <AtomNode start="(167, 29)" end="(167, 30)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(167, 31)" end="(167, 35)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(167, 36)" end="(167, 37)" leading="" trailing=" " val="="/>
              <OtherNode start="(167, 38)" end="(167, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(167, 38)" end="(167, 46)" leading="" trailing=" " raw_val="l.foldlM" val="l.foldlM"/>
                <NullNode start="(167, 47)" end="(167, 53)">
                  <IdentNode start="(167, 47)" end="(167, 48)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(167, 49)" end="(167, 53)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(167, 54)" end="(169, 21)">
          <AtomNode start="(167, 54)" end="(167, 56)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(167, 57)" end="(169, 21)">
            <AtomNode start="(167, 57)" end="(167, 59)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(168, 3)" end="(169, 21)">
              <TacticTacticseq1IndentedNode start="(168, 3)" end="(169, 21)">
                <NullNode start="(168, 3)" end="(169, 21)">
                  <OtherNode start="(168, 3)" end="(168, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;α : Type u_3&#10;stop : Nat&#10;inst✝ : Monad m&#10;f : β → α → m β&#10;init : β&#10;l : List α&#10;h : stop = l.toArray.size&#10;⊢ Array.foldlM f init l.toArray 0 stop = foldlM f init l" state_after="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;α : Type u_3&#10;inst✝ : Monad m&#10;f : β → α → m β&#10;init : β&#10;l : List α&#10;⊢ Array.foldlM f init l.toArray = foldlM f init l" tactic="subst h">
                    <AtomNode start="(168, 3)" end="(168, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(168, 9)" end="(168, 10)">
                      <IdentNode start="(168, 9)" end="(168, 10)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(169, 3)" end="(169, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;β : Type u_1&#10;α : Type u_3&#10;inst✝ : Monad m&#10;f : β → α → m β&#10;init : β&#10;l : List α&#10;⊢ Array.foldlM f init l.toArray = foldlM f init l" state_after="no goals" tactic="rw [foldlM_toList]">
                    <AtomNode start="(169, 3)" end="(169, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(169, 6)" end="(169, 21)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(169, 6)" end="(169, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(169, 7)" end="(169, 20)">
                        <OtherNode start="(169, 7)" end="(169, 20)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(169, 7)" end="(169, 20)" leading="" trailing="" raw_val="foldlM_toList" val="foldlM_toList" full_name="Array.foldlM_toList" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(169, 20)" end="(169, 21)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(171, 1)" end="(177, 27)" name="forM_toArray'" full_name="List.forM_toArray'">
      <CommandDeclmodifiersNode start="(171, 1)" end="(172, 8)">
        <NullNode start="(171, 1)" end="(171, 80)">
          <CommandDoccommentNode start="(171, 1)" end="(171, 80)" comment="Variant of `forM_toArray` with a side condition for the `stop` argument. -/">
            <AtomNode start="(171, 1)" end="(171, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(171, 5)" end="(171, 80)" leading="" trailing="&#10;" val="Variant of `forM_toArray` with a side condition for the `stop` argument. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(172, 1)" end="(172, 8)">
          <OtherNode start="(172, 1)" end="(172, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(172, 1)" end="(172, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(172, 3)" end="(172, 7)">
              <OtherNode start="(172, 3)" end="(172, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(172, 3)" end="(172, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(172, 3)" end="(172, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(172, 7)" end="(172, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(172, 9)" end="(177, 27)" name="forM_toArray'" full_name="List.forM_toArray'" _is_private_decl="False">
        <AtomNode start="(172, 9)" end="(172, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(172, 17)" end="(172, 30)">
          <IdentNode start="(172, 17)" end="(172, 30)" leading="" trailing=" " raw_val="forM_toArray'" val="forM_toArray'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(172, 31)" end="(173, 41)">
          <NullNode start="(172, 31)" end="(172, 99)">
            <OtherNode start="(172, 31)" end="(172, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(172, 31)" end="(172, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(172, 32)" end="(172, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(172, 32)" end="(172, 37)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(172, 38)" end="(172, 39)">
                  <IdentNode start="(172, 38)" end="(172, 39)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(172, 39)" end="(172, 40)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(172, 41)" end="(172, 53)">
              <AtomNode start="(172, 41)" end="(172, 42)" leading="" trailing="" val="("/>
              <NullNode start="(172, 42)" end="(172, 43)">
                <IdentNode start="(172, 42)" end="(172, 43)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(172, 44)" end="(172, 52)">
                <AtomNode start="(172, 44)" end="(172, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(172, 46)" end="(172, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(172, 46)" end="(172, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(172, 51)" end="(172, 52)">
                    <IdentNode start="(172, 51)" end="(172, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(172, 52)" end="(172, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(172, 54)" end="(172, 71)">
              <AtomNode start="(172, 54)" end="(172, 55)" leading="" trailing="" val="("/>
              <NullNode start="(172, 55)" end="(172, 56)">
                <IdentNode start="(172, 55)" end="(172, 56)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(172, 57)" end="(172, 70)">
                <AtomNode start="(172, 57)" end="(172, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(172, 59)" end="(172, 70)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(172, 59)" end="(172, 60)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(172, 61)" end="(172, 62)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(172, 63)" end="(172, 70)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(172, 63)" end="(172, 64)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(172, 65)" end="(172, 70)">
                      <IdentNode start="(172, 65)" end="(172, 70)" leading="" trailing="" raw_val="PUnit" val="PUnit" full_name="PUnit" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(172, 70)" end="(172, 71)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(172, 72)" end="(172, 99)">
              <AtomNode start="(172, 72)" end="(172, 73)" leading="" trailing="" val="("/>
              <NullNode start="(172, 73)" end="(172, 74)">
                <IdentNode start="(172, 73)" end="(172, 74)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(172, 75)" end="(172, 98)">
                <AtomNode start="(172, 75)" end="(172, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(172, 77)" end="(172, 98)" kind="«term_=_»">
                  <IdentNode start="(172, 77)" end="(172, 81)" leading="" trailing=" " raw_val="stop" val="stop"/>
                  <AtomNode start="(172, 82)" end="(172, 83)" leading="" trailing=" " val="="/>
                  <IdentNode start="(172, 84)" end="(172, 98)" leading="" trailing="" raw_val="l.toArray.size" val="l.toArray.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(172, 98)" end="(172, 99)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(172, 100)" end="(173, 41)">
            <AtomNode start="(172, 100)" end="(172, 101)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(173, 5)" end="(173, 41)" kind="«term_=_»">
              <OtherNode start="(173, 5)" end="(173, 30)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(173, 5)" end="(173, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(173, 6)" end="(173, 29)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(173, 6)" end="(173, 20)" leading="" trailing=" " raw_val="l.toArray.forM" val="l.toArray.forM"/>
                  <NullNode start="(173, 21)" end="(173, 29)">
                    <IdentNode start="(173, 21)" end="(173, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                    <OtherNode start="(173, 23)" end="(173, 24)" kind="num">
                      <AtomNode start="(173, 23)" end="(173, 24)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                    <IdentNode start="(173, 25)" end="(173, 29)" leading="" trailing="" raw_val="stop" val="stop"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(173, 29)" end="(173, 30)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(173, 31)" end="(173, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(173, 33)" end="(173, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(173, 33)" end="(173, 39)" leading="" trailing=" " raw_val="l.forM" val="l.forM"/>
                <NullNode start="(173, 40)" end="(173, 41)">
                  <IdentNode start="(173, 40)" end="(173, 41)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(173, 42)" end="(177, 27)">
          <AtomNode start="(173, 42)" end="(173, 44)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(173, 45)" end="(177, 27)">
            <AtomNode start="(173, 45)" end="(173, 47)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(174, 3)" end="(177, 27)">
              <TacticTacticseq1IndentedNode start="(174, 3)" end="(177, 27)">
                <NullNode start="(174, 3)" end="(177, 27)">
                  <OtherNode start="(174, 3)" end="(174, 10)" kind="Lean.Parser.Tactic.subst" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;stop : Nat&#10;inst✝ : Monad m&#10;l : List α&#10;f : α → m PUnit&#10;h : stop = l.toArray.size&#10;⊢ Array.forM f l.toArray 0 stop = l.forM f" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝ : Monad m&#10;l : List α&#10;f : α → m PUnit&#10;⊢ Array.forM f l.toArray = l.forM f" tactic="subst h">
                    <AtomNode start="(174, 3)" end="(174, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(174, 9)" end="(174, 10)">
                      <IdentNode start="(174, 9)" end="(174, 10)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(175, 3)" end="(175, 18)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝ : Monad m&#10;l : List α&#10;f : α → m PUnit&#10;⊢ Array.forM f l.toArray = l.forM f" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝ : Monad m&#10;l : List α&#10;f : α → m PUnit&#10;⊢ Array.foldlM (fun x =&amp;gt; f) PUnit.unit l.toArray = l.forM f" tactic="rw [Array.forM]">
                    <AtomNode start="(175, 3)" end="(175, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(175, 6)" end="(175, 18)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(175, 6)" end="(175, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(175, 7)" end="(175, 17)">
                        <OtherNode start="(175, 7)" end="(175, 17)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(175, 7)" end="(175, 17)" leading="" trailing="" raw_val="Array.forM" val="Array.forM" full_name="Array.forM" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(175, 17)" end="(175, 18)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(176, 3)" end="(176, 44)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝ : Monad m&#10;l : List α&#10;f : α → m PUnit&#10;⊢ Array.foldlM (fun x =&amp;gt; f) PUnit.unit l.toArray = l.forM f" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝ : Monad m&#10;l : List α&#10;f : α → m PUnit&#10;⊢ foldlM (fun x =&amp;gt; f) PUnit.unit l = l.forM f" tactic="simp only [size_toArray, foldlM_toArray']">
                    <AtomNode start="(176, 3)" end="(176, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(176, 8)" end="(176, 12)">
                      <AtomNode start="(176, 8)" end="(176, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(176, 13)" end="(176, 44)">
                      <AtomNode start="(176, 13)" end="(176, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(176, 14)" end="(176, 43)">
                        <OtherNode start="(176, 14)" end="(176, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(176, 14)" end="(176, 26)" leading="" trailing="" raw_val="size_toArray" val="size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(176, 26)" end="(176, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(176, 28)" end="(176, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(176, 28)" end="(176, 43)" leading="" trailing="" raw_val="foldlM_toArray'" val="foldlM_toArray'" full_name="List.foldlM_toArray'" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(165, 17)" def_end="(165, 32)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(176, 43)" end="(176, 44)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(177, 3)" end="(177, 27)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝ : Monad m&#10;l : List α&#10;f : α → m PUnit&#10;⊢ foldlM (fun x =&amp;gt; f) PUnit.unit l = l.forM f" state_after="no goals" tactic="induction l &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(177, 3)" end="(177, 14)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(177, 3)" end="(177, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(177, 13)" end="(177, 14)">
                        <OtherNode start="(177, 13)" end="(177, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(177, 13)" end="(177, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(177, 15)" end="(177, 18)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(177, 19)" end="(177, 27)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(177, 19)" end="(177, 27)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(179, 1)" end="(182, 24)" name="forM_toArray" full_name="List.forM_toArray">
      <CommandDeclmodifiersNode start="(179, 1)" end="(179, 8)">
        <NullNode/>
        <NullNode start="(179, 1)" end="(179, 8)">
          <OtherNode start="(179, 1)" end="(179, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(179, 1)" end="(179, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(179, 3)" end="(179, 7)">
              <OtherNode start="(179, 3)" end="(179, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(179, 3)" end="(179, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(179, 3)" end="(179, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(179, 7)" end="(179, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(180, 1)" end="(182, 24)" name="forM_toArray" full_name="List.forM_toArray" _is_private_decl="False">
        <AtomNode start="(180, 1)" end="(180, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(180, 9)" end="(180, 21)">
          <IdentNode start="(180, 9)" end="(180, 21)" leading="" trailing=" " raw_val="forM_toArray" val="forM_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(180, 22)" end="(181, 34)">
          <NullNode start="(180, 22)" end="(180, 62)">
            <OtherNode start="(180, 22)" end="(180, 31)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(180, 22)" end="(180, 23)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(180, 23)" end="(180, 30)" kind="Lean.Parser.Term.app">
                <IdentNode start="(180, 23)" end="(180, 28)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(180, 29)" end="(180, 30)">
                  <IdentNode start="(180, 29)" end="(180, 30)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(180, 30)" end="(180, 31)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(180, 32)" end="(180, 44)">
              <AtomNode start="(180, 32)" end="(180, 33)" leading="" trailing="" val="("/>
              <NullNode start="(180, 33)" end="(180, 34)">
                <IdentNode start="(180, 33)" end="(180, 34)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(180, 35)" end="(180, 43)">
                <AtomNode start="(180, 35)" end="(180, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(180, 37)" end="(180, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(180, 37)" end="(180, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(180, 42)" end="(180, 43)">
                    <IdentNode start="(180, 42)" end="(180, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(180, 43)" end="(180, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(180, 45)" end="(180, 62)">
              <AtomNode start="(180, 45)" end="(180, 46)" leading="" trailing="" val="("/>
              <NullNode start="(180, 46)" end="(180, 47)">
                <IdentNode start="(180, 46)" end="(180, 47)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(180, 48)" end="(180, 61)">
                <AtomNode start="(180, 48)" end="(180, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(180, 50)" end="(180, 61)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(180, 50)" end="(180, 51)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(180, 52)" end="(180, 53)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(180, 54)" end="(180, 61)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(180, 54)" end="(180, 55)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(180, 56)" end="(180, 61)">
                      <IdentNode start="(180, 56)" end="(180, 61)" leading="" trailing="" raw_val="PUnit" val="PUnit" full_name="PUnit" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(180, 61)" end="(180, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(180, 63)" end="(181, 34)">
            <AtomNode start="(180, 63)" end="(180, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(181, 5)" end="(181, 34)" kind="«term_=_»">
              <OtherNode start="(181, 5)" end="(181, 23)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(181, 5)" end="(181, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(181, 6)" end="(181, 22)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(181, 6)" end="(181, 10)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                  <NullNode start="(181, 11)" end="(181, 22)">
                    <IdentNode start="(181, 11)" end="(181, 20)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
                    <IdentNode start="(181, 21)" end="(181, 22)" leading="" trailing="" raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(181, 22)" end="(181, 23)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(181, 24)" end="(181, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(181, 26)" end="(181, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(181, 26)" end="(181, 32)" leading="" trailing=" " raw_val="l.forM" val="l.forM"/>
                <NullNode start="(181, 33)" end="(181, 34)">
                  <IdentNode start="(181, 33)" end="(181, 34)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(181, 35)" end="(182, 24)">
          <AtomNode start="(181, 35)" end="(181, 37)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(182, 3)" end="(182, 24)" kind="Lean.Parser.Term.app">
            <IdentNode start="(182, 3)" end="(182, 16)" leading="" trailing=" " raw_val="forM_toArray'" val="forM_toArray'" full_name="List.forM_toArray'" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(172, 17)" def_end="(172, 30)"/>
            <NullNode start="(182, 17)" end="(182, 24)">
              <IdentNode start="(182, 17)" end="(182, 18)" leading="" trailing=" " raw_val="l" val="l"/>
              <IdentNode start="(182, 19)" end="(182, 20)" leading="" trailing=" " raw_val="f" val="f"/>
              <IdentNode start="(182, 21)" end="(182, 24)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(184, 1)" end="(189, 20)" name="foldr_toArray'" full_name="List.foldr_toArray'">
      <CommandDeclmodifiersNode start="(184, 1)" end="(185, 8)">
        <NullNode start="(184, 1)" end="(184, 82)">
          <CommandDoccommentNode start="(184, 1)" end="(184, 82)" comment="Variant of `foldr_toArray` with a side condition for the `start` argument. -/">
            <AtomNode start="(184, 1)" end="(184, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(184, 5)" end="(184, 82)" leading="" trailing="&#10;" val="Variant of `foldr_toArray` with a side condition for the `start` argument. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(185, 1)" end="(185, 8)">
          <OtherNode start="(185, 1)" end="(185, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(185, 1)" end="(185, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(185, 3)" end="(185, 7)">
              <OtherNode start="(185, 3)" end="(185, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(185, 3)" end="(185, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(185, 3)" end="(185, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(185, 7)" end="(185, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(185, 9)" end="(189, 20)" name="foldr_toArray'" full_name="List.foldr_toArray'" _is_private_decl="False">
        <AtomNode start="(185, 9)" end="(185, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(185, 17)" end="(185, 31)">
          <IdentNode start="(185, 17)" end="(185, 31)" leading="" trailing=" " raw_val="foldr_toArray'" val="foldr_toArray'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(185, 32)" end="(187, 52)">
          <NullNode start="(185, 32)" end="(186, 33)">
            <TermExplicitbinderNode start="(185, 32)" end="(185, 47)">
              <AtomNode start="(185, 32)" end="(185, 33)" leading="" trailing="" val="("/>
              <NullNode start="(185, 33)" end="(185, 34)">
                <IdentNode start="(185, 33)" end="(185, 34)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(185, 35)" end="(185, 46)">
                <AtomNode start="(185, 35)" end="(185, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(185, 37)" end="(185, 46)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(185, 37)" end="(185, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(185, 39)" end="(185, 40)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(185, 41)" end="(185, 46)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(185, 41)" end="(185, 42)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(185, 43)" end="(185, 44)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(185, 45)" end="(185, 46)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(185, 46)" end="(185, 47)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(185, 48)" end="(185, 58)">
              <AtomNode start="(185, 48)" end="(185, 49)" leading="" trailing="" val="("/>
              <NullNode start="(185, 49)" end="(185, 53)">
                <IdentNode start="(185, 49)" end="(185, 53)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(185, 54)" end="(185, 57)">
                <AtomNode start="(185, 54)" end="(185, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(185, 56)" end="(185, 57)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(185, 57)" end="(185, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(185, 59)" end="(185, 71)">
              <AtomNode start="(185, 59)" end="(185, 60)" leading="" trailing="" val="("/>
              <NullNode start="(185, 60)" end="(185, 61)">
                <IdentNode start="(185, 60)" end="(185, 61)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(185, 62)" end="(185, 70)">
                <AtomNode start="(185, 62)" end="(185, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(185, 64)" end="(185, 70)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(185, 64)" end="(185, 68)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(185, 69)" end="(185, 70)">
                    <IdentNode start="(185, 69)" end="(185, 70)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(185, 70)" end="(185, 71)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(186, 5)" end="(186, 33)">
              <AtomNode start="(186, 5)" end="(186, 6)" leading="" trailing="" val="("/>
              <NullNode start="(186, 6)" end="(186, 7)">
                <IdentNode start="(186, 6)" end="(186, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(186, 8)" end="(186, 32)">
                <AtomNode start="(186, 8)" end="(186, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(186, 10)" end="(186, 32)" kind="«term_=_»">
                  <IdentNode start="(186, 10)" end="(186, 15)" leading="" trailing=" " raw_val="start" val="start"/>
                  <AtomNode start="(186, 16)" end="(186, 17)" leading="" trailing=" " val="="/>
                  <IdentNode start="(186, 18)" end="(186, 32)" leading="" trailing="" raw_val="l.toArray.size" val="l.toArray.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(186, 32)" end="(186, 33)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(186, 34)" end="(187, 52)">
            <AtomNode start="(186, 34)" end="(186, 35)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(187, 5)" end="(187, 52)" kind="«term_=_»">
              <OtherNode start="(187, 5)" end="(187, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(187, 5)" end="(187, 20)" leading="" trailing=" " raw_val="l.toArray.foldr" val="l.toArray.foldr"/>
                <NullNode start="(187, 21)" end="(187, 35)">
                  <IdentNode start="(187, 21)" end="(187, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(187, 23)" end="(187, 27)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(187, 28)" end="(187, 33)" leading="" trailing=" " raw_val="start" val="start"/>
                  <OtherNode start="(187, 34)" end="(187, 35)" kind="num">
                    <AtomNode start="(187, 34)" end="(187, 35)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(187, 36)" end="(187, 37)" leading="" trailing=" " val="="/>
              <OtherNode start="(187, 38)" end="(187, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(187, 38)" end="(187, 45)" leading="" trailing=" " raw_val="l.foldr" val="l.foldr"/>
                <NullNode start="(187, 46)" end="(187, 52)">
                  <IdentNode start="(187, 46)" end="(187, 47)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(187, 48)" end="(187, 52)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(187, 53)" end="(189, 20)">
          <AtomNode start="(187, 53)" end="(187, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(187, 56)" end="(189, 20)">
            <AtomNode start="(187, 56)" end="(187, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(188, 3)" end="(189, 20)">
              <TacticTacticseq1IndentedNode start="(188, 3)" end="(189, 20)">
                <NullNode start="(188, 3)" end="(189, 20)">
                  <OtherNode start="(188, 3)" end="(188, 10)" kind="Lean.Parser.Tactic.subst" state_before="α : Type u_1&#10;β : Type u_2&#10;start : Nat&#10;f : α → β → β&#10;init : β&#10;l : List α&#10;h : start = l.toArray.size&#10;⊢ Array.foldr f init l.toArray start = foldr f init l" state_after="α : Type u_1&#10;β : Type u_2&#10;f : α → β → β&#10;init : β&#10;l : List α&#10;⊢ Array.foldr f init l.toArray = foldr f init l" tactic="subst h">
                    <AtomNode start="(188, 3)" end="(188, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(188, 9)" end="(188, 10)">
                      <IdentNode start="(188, 9)" end="(188, 10)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(189, 3)" end="(189, 20)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → β → β&#10;init : β&#10;l : List α&#10;⊢ Array.foldr f init l.toArray = foldr f init l" state_after="no goals" tactic="rw [foldr_toList]">
                    <AtomNode start="(189, 3)" end="(189, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(189, 6)" end="(189, 20)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(189, 6)" end="(189, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(189, 7)" end="(189, 19)">
                        <OtherNode start="(189, 7)" end="(189, 19)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(189, 7)" end="(189, 19)" leading="" trailing="" raw_val="foldr_toList" val="foldr_toList" full_name="Array.foldr_toList" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(189, 19)" end="(189, 20)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(191, 1)" end="(196, 20)" name="foldl_toArray'" full_name="List.foldl_toArray'">
      <CommandDeclmodifiersNode start="(191, 1)" end="(192, 8)">
        <NullNode start="(191, 1)" end="(191, 81)">
          <CommandDoccommentNode start="(191, 1)" end="(191, 81)" comment="Variant of `foldl_toArray` with a side condition for the `stop` argument. -/">
            <AtomNode start="(191, 1)" end="(191, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(191, 5)" end="(191, 81)" leading="" trailing="&#10;" val="Variant of `foldl_toArray` with a side condition for the `stop` argument. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(192, 1)" end="(192, 8)">
          <OtherNode start="(192, 1)" end="(192, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(192, 1)" end="(192, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(192, 3)" end="(192, 7)">
              <OtherNode start="(192, 3)" end="(192, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(192, 3)" end="(192, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(192, 3)" end="(192, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(192, 7)" end="(192, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(192, 9)" end="(196, 20)" name="foldl_toArray'" full_name="List.foldl_toArray'" _is_private_decl="False">
        <AtomNode start="(192, 9)" end="(192, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(192, 17)" end="(192, 31)">
          <IdentNode start="(192, 17)" end="(192, 31)" leading="" trailing=" " raw_val="foldl_toArray'" val="foldl_toArray'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(192, 32)" end="(194, 51)">
          <NullNode start="(192, 32)" end="(193, 32)">
            <TermExplicitbinderNode start="(192, 32)" end="(192, 47)">
              <AtomNode start="(192, 32)" end="(192, 33)" leading="" trailing="" val="("/>
              <NullNode start="(192, 33)" end="(192, 34)">
                <IdentNode start="(192, 33)" end="(192, 34)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(192, 35)" end="(192, 46)">
                <AtomNode start="(192, 35)" end="(192, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(192, 37)" end="(192, 46)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(192, 37)" end="(192, 38)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(192, 39)" end="(192, 40)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(192, 41)" end="(192, 46)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(192, 41)" end="(192, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(192, 43)" end="(192, 44)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(192, 45)" end="(192, 46)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(192, 46)" end="(192, 47)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(192, 48)" end="(192, 58)">
              <AtomNode start="(192, 48)" end="(192, 49)" leading="" trailing="" val="("/>
              <NullNode start="(192, 49)" end="(192, 53)">
                <IdentNode start="(192, 49)" end="(192, 53)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(192, 54)" end="(192, 57)">
                <AtomNode start="(192, 54)" end="(192, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(192, 56)" end="(192, 57)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(192, 57)" end="(192, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(192, 59)" end="(192, 71)">
              <AtomNode start="(192, 59)" end="(192, 60)" leading="" trailing="" val="("/>
              <NullNode start="(192, 60)" end="(192, 61)">
                <IdentNode start="(192, 60)" end="(192, 61)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(192, 62)" end="(192, 70)">
                <AtomNode start="(192, 62)" end="(192, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(192, 64)" end="(192, 70)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(192, 64)" end="(192, 68)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(192, 69)" end="(192, 70)">
                    <IdentNode start="(192, 69)" end="(192, 70)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(192, 70)" end="(192, 71)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(193, 5)" end="(193, 32)">
              <AtomNode start="(193, 5)" end="(193, 6)" leading="" trailing="" val="("/>
              <NullNode start="(193, 6)" end="(193, 7)">
                <IdentNode start="(193, 6)" end="(193, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(193, 8)" end="(193, 31)">
                <AtomNode start="(193, 8)" end="(193, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(193, 10)" end="(193, 31)" kind="«term_=_»">
                  <IdentNode start="(193, 10)" end="(193, 14)" leading="" trailing=" " raw_val="stop" val="stop"/>
                  <AtomNode start="(193, 15)" end="(193, 16)" leading="" trailing=" " val="="/>
                  <IdentNode start="(193, 17)" end="(193, 31)" leading="" trailing="" raw_val="l.toArray.size" val="l.toArray.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(193, 31)" end="(193, 32)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(193, 33)" end="(194, 51)">
            <AtomNode start="(193, 33)" end="(193, 34)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(194, 5)" end="(194, 51)" kind="«term_=_»">
              <OtherNode start="(194, 5)" end="(194, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(194, 5)" end="(194, 20)" leading="" trailing=" " raw_val="l.toArray.foldl" val="l.toArray.foldl"/>
                <NullNode start="(194, 21)" end="(194, 34)">
                  <IdentNode start="(194, 21)" end="(194, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(194, 23)" end="(194, 27)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(194, 28)" end="(194, 29)" kind="num">
                    <AtomNode start="(194, 28)" end="(194, 29)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(194, 30)" end="(194, 34)" leading="" trailing=" " raw_val="stop" val="stop"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(194, 35)" end="(194, 36)" leading="" trailing=" " val="="/>
              <OtherNode start="(194, 37)" end="(194, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(194, 37)" end="(194, 44)" leading="" trailing=" " raw_val="l.foldl" val="l.foldl"/>
                <NullNode start="(194, 45)" end="(194, 51)">
                  <IdentNode start="(194, 45)" end="(194, 46)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(194, 47)" end="(194, 51)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(194, 52)" end="(196, 20)">
          <AtomNode start="(194, 52)" end="(194, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(194, 55)" end="(196, 20)">
            <AtomNode start="(194, 55)" end="(194, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(195, 3)" end="(196, 20)">
              <TacticTacticseq1IndentedNode start="(195, 3)" end="(196, 20)">
                <NullNode start="(195, 3)" end="(196, 20)">
                  <OtherNode start="(195, 3)" end="(195, 10)" kind="Lean.Parser.Tactic.subst" state_before="β : Type u_1&#10;α : Type u_2&#10;stop : Nat&#10;f : β → α → β&#10;init : β&#10;l : List α&#10;h : stop = l.toArray.size&#10;⊢ Array.foldl f init l.toArray 0 stop = foldl f init l" state_after="β : Type u_1&#10;α : Type u_2&#10;f : β → α → β&#10;init : β&#10;l : List α&#10;⊢ Array.foldl f init l.toArray = foldl f init l" tactic="subst h">
                    <AtomNode start="(195, 3)" end="(195, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(195, 9)" end="(195, 10)">
                      <IdentNode start="(195, 9)" end="(195, 10)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(196, 3)" end="(196, 20)" kind="Lean.Parser.Tactic.rwSeq" state_before="β : Type u_1&#10;α : Type u_2&#10;f : β → α → β&#10;init : β&#10;l : List α&#10;⊢ Array.foldl f init l.toArray = foldl f init l" state_after="no goals" tactic="rw [foldl_toList]">
                    <AtomNode start="(196, 3)" end="(196, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(196, 6)" end="(196, 20)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(196, 6)" end="(196, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(196, 7)" end="(196, 19)">
                        <OtherNode start="(196, 7)" end="(196, 19)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(196, 7)" end="(196, 19)" leading="" trailing="" raw_val="foldl_toList" val="foldl_toList" full_name="Array.foldl_toList" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(196, 19)" end="(196, 20)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(198, 1)" end="(199, 29)" name="sum_toArray" full_name="List.sum_toArray">
      <CommandDeclmodifiersNode start="(198, 1)" end="(198, 8)">
        <NullNode/>
        <NullNode start="(198, 1)" end="(198, 8)">
          <OtherNode start="(198, 1)" end="(198, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(198, 1)" end="(198, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(198, 3)" end="(198, 7)">
              <OtherNode start="(198, 3)" end="(198, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(198, 3)" end="(198, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(198, 3)" end="(198, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(198, 7)" end="(198, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(198, 9)" end="(199, 29)" name="sum_toArray" full_name="List.sum_toArray" _is_private_decl="False">
        <AtomNode start="(198, 9)" end="(198, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(198, 17)" end="(198, 28)">
          <IdentNode start="(198, 17)" end="(198, 28)" leading="" trailing=" " raw_val="sum_toArray" val="sum_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(198, 29)" end="(198, 82)">
          <NullNode start="(198, 29)" end="(198, 58)">
            <OtherNode start="(198, 29)" end="(198, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(198, 29)" end="(198, 30)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(198, 30)" end="(198, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(198, 30)" end="(198, 33)" leading="" trailing=" " raw_val="Add" val="Add" full_name="Add" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(198, 34)" end="(198, 35)">
                  <IdentNode start="(198, 34)" end="(198, 35)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(198, 35)" end="(198, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(198, 37)" end="(198, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(198, 37)" end="(198, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(198, 38)" end="(198, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(198, 38)" end="(198, 42)" leading="" trailing=" " raw_val="Zero" val="Zero" full_name="Zero" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(198, 43)" end="(198, 44)">
                  <IdentNode start="(198, 43)" end="(198, 44)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(198, 44)" end="(198, 45)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(198, 46)" end="(198, 58)">
              <AtomNode start="(198, 46)" end="(198, 47)" leading="" trailing="" val="("/>
              <NullNode start="(198, 47)" end="(198, 48)">
                <IdentNode start="(198, 47)" end="(198, 48)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(198, 49)" end="(198, 57)">
                <AtomNode start="(198, 49)" end="(198, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(198, 51)" end="(198, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(198, 51)" end="(198, 55)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(198, 56)" end="(198, 57)">
                    <IdentNode start="(198, 56)" end="(198, 57)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(198, 57)" end="(198, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(198, 59)" end="(198, 82)">
            <AtomNode start="(198, 59)" end="(198, 60)" leading="" trailing=" " val=":"/>
            <OtherNode start="(198, 61)" end="(198, 82)" kind="«term_=_»">
              <IdentNode start="(198, 61)" end="(198, 74)" leading="" trailing=" " raw_val="l.toArray.sum" val="l.toArray.sum"/>
              <AtomNode start="(198, 75)" end="(198, 76)" leading="" trailing=" " val="="/>
              <IdentNode start="(198, 77)" end="(198, 82)" leading="" trailing=" " raw_val="l.sum" val="l.sum"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(198, 83)" end="(199, 29)">
          <AtomNode start="(198, 83)" end="(198, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(198, 86)" end="(199, 29)">
            <AtomNode start="(198, 86)" end="(198, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(199, 3)" end="(199, 29)">
              <TacticTacticseq1IndentedNode start="(199, 3)" end="(199, 29)">
                <NullNode start="(199, 3)" end="(199, 29)">
                  <OtherNode start="(199, 3)" end="(199, 29)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : Add α&#10;inst✝ : Zero α&#10;l : List α&#10;⊢ l.toArray.sum = l.sum" state_after="no goals" tactic="simp [Array.sum, List.sum]">
                    <AtomNode start="(199, 3)" end="(199, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(199, 8)" end="(199, 29)">
                      <AtomNode start="(199, 8)" end="(199, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(199, 9)" end="(199, 28)">
                        <OtherNode start="(199, 9)" end="(199, 18)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(199, 9)" end="(199, 18)" leading="" trailing="" raw_val="Array.sum" val="Array.sum" full_name="Array.sum" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(199, 18)" end="(199, 19)" leading="" trailing=" " val=","/>
                        <OtherNode start="(199, 20)" end="(199, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(199, 20)" end="(199, 28)" leading="" trailing="" raw_val="List.sum" val="List.sum" full_name="List.sum" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(199, 28)" end="(199, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(201, 1)" end="(204, 7)" name="append_toArray" full_name="List.append_toArray">
      <CommandDeclmodifiersNode start="(201, 1)" end="(201, 8)">
        <NullNode/>
        <NullNode start="(201, 1)" end="(201, 8)">
          <OtherNode start="(201, 1)" end="(201, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(201, 1)" end="(201, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(201, 3)" end="(201, 7)">
              <OtherNode start="(201, 3)" end="(201, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(201, 3)" end="(201, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(201, 3)" end="(201, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(201, 7)" end="(201, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(201, 9)" end="(204, 7)" name="append_toArray" full_name="List.append_toArray" _is_private_decl="False">
        <AtomNode start="(201, 9)" end="(201, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(201, 17)" end="(201, 31)">
          <IdentNode start="(201, 17)" end="(201, 31)" leading="" trailing=" " raw_val="append_toArray" val="append_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(201, 32)" end="(202, 50)">
          <NullNode start="(201, 32)" end="(201, 48)">
            <TermExplicitbinderNode start="(201, 32)" end="(201, 48)">
              <AtomNode start="(201, 32)" end="(201, 33)" leading="" trailing="" val="("/>
              <NullNode start="(201, 33)" end="(201, 38)">
                <IdentNode start="(201, 33)" end="(201, 35)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(201, 36)" end="(201, 38)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(201, 39)" end="(201, 47)">
                <AtomNode start="(201, 39)" end="(201, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(201, 41)" end="(201, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(201, 41)" end="(201, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(201, 46)" end="(201, 47)">
                    <IdentNode start="(201, 46)" end="(201, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(201, 47)" end="(201, 48)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(201, 49)" end="(202, 50)">
            <AtomNode start="(201, 49)" end="(201, 50)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(202, 5)" end="(202, 50)" kind="«term_=_»">
              <OtherNode start="(202, 5)" end="(202, 29)" kind="«term_++_»">
                <IdentNode start="(202, 5)" end="(202, 15)" leading="" trailing=" " raw_val="l₁.toArray" val="l₁.toArray"/>
                <AtomNode start="(202, 16)" end="(202, 18)" leading="" trailing=" " val="++"/>
                <IdentNode start="(202, 19)" end="(202, 29)" leading="" trailing=" " raw_val="l₂.toArray" val="l₂.toArray"/>
              </OtherNode>
              <AtomNode start="(202, 30)" end="(202, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(202, 32)" end="(202, 50)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(202, 32)" end="(202, 42)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(202, 32)" end="(202, 33)" leading="" trailing="" val="("/>
                  <OtherNode start="(202, 33)" end="(202, 41)" kind="«term_++_»">
                    <IdentNode start="(202, 33)" end="(202, 35)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <AtomNode start="(202, 36)" end="(202, 38)" leading="" trailing=" " val="++"/>
                    <IdentNode start="(202, 39)" end="(202, 41)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                  </OtherNode>
                  <AtomNode start="(202, 41)" end="(202, 42)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(202, 42)" end="(202, 43)" leading="" trailing="" val="."/>
                <IdentNode start="(202, 43)" end="(202, 50)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(202, 51)" end="(204, 7)">
          <AtomNode start="(202, 51)" end="(202, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(202, 54)" end="(204, 7)">
            <AtomNode start="(202, 54)" end="(202, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(203, 3)" end="(204, 7)">
              <TacticTacticseq1IndentedNode start="(203, 3)" end="(204, 7)">
                <NullNode start="(203, 3)" end="(204, 7)">
                  <OtherNode start="(203, 3)" end="(203, 13)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;l₁ l₂ : List α&#10;⊢ l₁.toArray ++ l₂.toArray = (l₁ ++ l₂).toArray" state_after="case h&#10;α : Type u_1&#10;l₁ l₂ : List α&#10;⊢ (l₁.toArray ++ l₂.toArray).toList = (l₁ ++ l₂).toArray.toList" tactic="apply ext'">
                    <AtomNode start="(203, 3)" end="(203, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(203, 9)" end="(203, 13)" leading="" trailing="&#10;  " raw_val="ext'" val="ext'" full_name="Array.ext'" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(204, 3)" end="(204, 7)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;l₁ l₂ : List α&#10;⊢ (l₁.toArray ++ l₂.toArray).toList = (l₁ ++ l₂).toArray.toList" state_after="no goals" tactic="simp">
                    <AtomNode start="(204, 3)" end="(204, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(206, 1)" end="(208, 7)" name="push_append_toArray" full_name="List.push_append_toArray">
      <CommandDeclmodifiersNode start="(206, 1)" end="(206, 8)">
        <NullNode/>
        <NullNode start="(206, 1)" end="(206, 8)">
          <OtherNode start="(206, 1)" end="(206, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(206, 1)" end="(206, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(206, 3)" end="(206, 7)">
              <OtherNode start="(206, 3)" end="(206, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(206, 3)" end="(206, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(206, 3)" end="(206, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(206, 7)" end="(206, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(206, 9)" end="(208, 7)" name="push_append_toArray" full_name="List.push_append_toArray" _is_private_decl="False">
        <AtomNode start="(206, 9)" end="(206, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(206, 17)" end="(206, 36)">
          <IdentNode start="(206, 17)" end="(206, 36)" leading="" trailing=" " raw_val="push_append_toArray" val="push_append_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(206, 37)" end="(206, 124)">
          <NullNode start="(206, 37)" end="(206, 73)">
            <OtherNode start="(206, 37)" end="(206, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(206, 37)" end="(206, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(206, 38)" end="(206, 40)">
                <IdentNode start="(206, 38)" end="(206, 40)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(206, 41)" end="(206, 50)">
                <AtomNode start="(206, 41)" end="(206, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(206, 43)" end="(206, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(206, 43)" end="(206, 48)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(206, 49)" end="(206, 50)">
                    <IdentNode start="(206, 49)" end="(206, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(206, 50)" end="(206, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(206, 52)" end="(206, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(206, 52)" end="(206, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(206, 53)" end="(206, 54)">
                <IdentNode start="(206, 53)" end="(206, 54)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(206, 55)" end="(206, 58)">
                <AtomNode start="(206, 55)" end="(206, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(206, 57)" end="(206, 58)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(206, 58)" end="(206, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(206, 60)" end="(206, 73)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(206, 60)" end="(206, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(206, 61)" end="(206, 63)">
                <IdentNode start="(206, 61)" end="(206, 63)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(206, 64)" end="(206, 72)">
                <AtomNode start="(206, 64)" end="(206, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(206, 66)" end="(206, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(206, 66)" end="(206, 70)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(206, 71)" end="(206, 72)">
                    <IdentNode start="(206, 71)" end="(206, 72)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(206, 72)" end="(206, 73)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(206, 74)" end="(206, 124)">
            <AtomNode start="(206, 74)" end="(206, 75)" leading="" trailing=" " val=":"/>
            <OtherNode start="(206, 76)" end="(206, 124)" kind="«term_=_»">
              <OtherNode start="(206, 76)" end="(206, 99)" kind="«term_++_»">
                <OtherNode start="(206, 76)" end="(206, 85)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(206, 76)" end="(206, 83)" leading="" trailing=" " raw_val="as.push" val="as.push"/>
                  <NullNode start="(206, 84)" end="(206, 85)">
                    <IdentNode start="(206, 84)" end="(206, 85)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(206, 86)" end="(206, 88)" leading="" trailing=" " val="++"/>
                <IdentNode start="(206, 89)" end="(206, 99)" leading="" trailing=" " raw_val="bs.toArray" val="bs.toArray"/>
              </OtherNode>
              <AtomNode start="(206, 100)" end="(206, 101)" leading="" trailing=" " val="="/>
              <OtherNode start="(206, 102)" end="(206, 124)" kind="«term_++_»">
                <IdentNode start="(206, 102)" end="(206, 104)" leading="" trailing=" " raw_val="as" val="as"/>
                <AtomNode start="(206, 105)" end="(206, 107)" leading="" trailing=" " val="++"/>
                <OtherNode start="(206, 108)" end="(206, 124)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(206, 108)" end="(206, 116)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(206, 108)" end="(206, 109)" leading="" trailing="" val="("/>
                    <OtherNode start="(206, 109)" end="(206, 115)" kind="«term_::_»">
                      <IdentNode start="(206, 109)" end="(206, 110)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(206, 111)" end="(206, 113)" leading="" trailing="" val="::"/>
                      <IdentNode start="(206, 113)" end="(206, 115)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </OtherNode>
                    <AtomNode start="(206, 115)" end="(206, 116)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(206, 116)" end="(206, 117)" leading="" trailing="" val="."/>
                  <IdentNode start="(206, 117)" end="(206, 124)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(206, 125)" end="(208, 7)">
          <AtomNode start="(206, 125)" end="(206, 127)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(206, 128)" end="(208, 7)">
            <AtomNode start="(206, 128)" end="(206, 130)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(207, 3)" end="(208, 7)">
              <TacticTacticseq1IndentedNode start="(207, 3)" end="(208, 7)">
                <NullNode start="(207, 3)" end="(208, 7)">
                  <OtherNode start="(207, 3)" end="(207, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;as : Array α&#10;a : α&#10;bs : List α&#10;⊢ as.push a ++ bs.toArray = as ++ (a :: bs).toArray" state_after="case mk&#10;α : Type u_1&#10;a : α&#10;bs toList✝ : List α&#10;⊢ { toList := toList✝ }.push a ++ bs.toArray = { toList := toList✝ } ++ (a :: bs).toArray" tactic="cases as">
                    <AtomNode start="(207, 3)" end="(207, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(207, 9)" end="(207, 11)">
                      <OtherNode start="(207, 9)" end="(207, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(207, 9)" end="(207, 11)" leading="" trailing="&#10;  " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(208, 3)" end="(208, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;a : α&#10;bs toList✝ : List α&#10;⊢ { toList := toList✝ }.push a ++ bs.toArray = { toList := toList✝ } ++ (a :: bs).toArray" state_after="no goals" tactic="simp">
                    <AtomNode start="(208, 3)" end="(208, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(210, 1)" end="(211, 43)" name="foldl_push" full_name="List.foldl_push">
      <CommandDeclmodifiersNode start="(210, 1)" end="(210, 8)">
        <NullNode/>
        <NullNode start="(210, 1)" end="(210, 8)">
          <OtherNode start="(210, 1)" end="(210, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(210, 1)" end="(210, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(210, 3)" end="(210, 7)">
              <OtherNode start="(210, 3)" end="(210, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(210, 3)" end="(210, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(210, 3)" end="(210, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(210, 7)" end="(210, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(210, 9)" end="(211, 43)" name="foldl_push" full_name="List.foldl_push" _is_private_decl="False">
        <AtomNode start="(210, 9)" end="(210, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(210, 17)" end="(210, 27)">
          <IdentNode start="(210, 17)" end="(210, 27)" leading="" trailing=" " raw_val="foldl_push" val="foldl_push"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(210, 28)" end="(210, 97)">
          <NullNode start="(210, 28)" end="(210, 55)">
            <OtherNode start="(210, 28)" end="(210, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(210, 28)" end="(210, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(210, 29)" end="(210, 30)">
                <IdentNode start="(210, 29)" end="(210, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(210, 31)" end="(210, 39)">
                <AtomNode start="(210, 31)" end="(210, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(210, 33)" end="(210, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(210, 33)" end="(210, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(210, 38)" end="(210, 39)">
                    <IdentNode start="(210, 38)" end="(210, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(210, 39)" end="(210, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(210, 41)" end="(210, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(210, 41)" end="(210, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(210, 42)" end="(210, 44)">
                <IdentNode start="(210, 42)" end="(210, 44)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(210, 45)" end="(210, 54)">
                <AtomNode start="(210, 45)" end="(210, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(210, 47)" end="(210, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(210, 47)" end="(210, 52)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(210, 53)" end="(210, 54)">
                    <IdentNode start="(210, 53)" end="(210, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(210, 54)" end="(210, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(210, 56)" end="(210, 97)">
            <AtomNode start="(210, 56)" end="(210, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(210, 58)" end="(210, 97)" kind="«term_=_»">
              <OtherNode start="(210, 58)" end="(210, 79)" kind="Lean.Parser.Term.app">
                <IdentNode start="(210, 58)" end="(210, 65)" leading="" trailing=" " raw_val="l.foldl" val="l.foldl"/>
                <NullNode start="(210, 66)" end="(210, 79)">
                  <IdentNode start="(210, 66)" end="(210, 76)" leading="" trailing=" " raw_val="Array.push" val="Array.push" full_name="Array.push" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <IdentNode start="(210, 77)" end="(210, 79)" leading="" trailing=" " raw_val="as" val="as"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(210, 80)" end="(210, 81)" leading="" trailing=" " val="="/>
              <OtherNode start="(210, 82)" end="(210, 97)" kind="«term_++_»">
                <IdentNode start="(210, 82)" end="(210, 84)" leading="" trailing=" " raw_val="as" val="as"/>
                <AtomNode start="(210, 85)" end="(210, 87)" leading="" trailing=" " val="++"/>
                <IdentNode start="(210, 88)" end="(210, 97)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(210, 98)" end="(211, 43)">
          <AtomNode start="(210, 98)" end="(210, 100)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(210, 101)" end="(211, 43)">
            <AtomNode start="(210, 101)" end="(210, 103)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(211, 3)" end="(211, 43)">
              <TacticTacticseq1IndentedNode start="(211, 3)" end="(211, 43)">
                <NullNode start="(211, 3)" end="(211, 43)">
                  <OtherNode start="(211, 3)" end="(211, 43)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;l : List α&#10;as : Array α&#10;⊢ foldl push as l = as ++ l.toArray" state_after="no goals" tactic="induction l generalizing as &amp;lt;;&amp;gt; simp [*]">
                    <OtherNode start="(211, 3)" end="(211, 30)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(211, 3)" end="(211, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(211, 13)" end="(211, 14)">
                        <OtherNode start="(211, 13)" end="(211, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(211, 13)" end="(211, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode start="(211, 15)" end="(211, 30)">
                        <AtomNode start="(211, 15)" end="(211, 27)" leading="" trailing=" " val="generalizing"/>
                        <NullNode start="(211, 28)" end="(211, 30)">
                          <IdentNode start="(211, 28)" end="(211, 30)" leading="" trailing=" " raw_val="as" val="as"/>
                        </NullNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(211, 31)" end="(211, 34)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(211, 35)" end="(211, 43)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(211, 35)" end="(211, 39)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(211, 40)" end="(211, 43)">
                        <AtomNode start="(211, 40)" end="(211, 41)" leading="" trailing="" val="["/>
                        <NullNode start="(211, 41)" end="(211, 42)">
                          <OtherNode start="(211, 41)" end="(211, 42)" kind="Lean.Parser.Tactic.simpStar">
                            <AtomNode start="(211, 41)" end="(211, 42)" leading="" trailing="" val="*"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(211, 42)" end="(211, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(213, 1)" end="(214, 42)" name="foldr_push" full_name="List.foldr_push">
      <CommandDeclmodifiersNode start="(213, 1)" end="(213, 8)">
        <NullNode/>
        <NullNode start="(213, 1)" end="(213, 8)">
          <OtherNode start="(213, 1)" end="(213, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(213, 1)" end="(213, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(213, 3)" end="(213, 7)">
              <OtherNode start="(213, 3)" end="(213, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(213, 3)" end="(213, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(213, 3)" end="(213, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(213, 7)" end="(213, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(213, 9)" end="(214, 42)" name="foldr_push" full_name="List.foldr_push" _is_private_decl="False">
        <AtomNode start="(213, 9)" end="(213, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(213, 17)" end="(213, 27)">
          <IdentNode start="(213, 17)" end="(213, 27)" leading="" trailing=" " raw_val="foldr_push" val="foldr_push"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(213, 28)" end="(213, 118)">
          <NullNode start="(213, 28)" end="(213, 55)">
            <OtherNode start="(213, 28)" end="(213, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(213, 28)" end="(213, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(213, 29)" end="(213, 30)">
                <IdentNode start="(213, 29)" end="(213, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(213, 31)" end="(213, 39)">
                <AtomNode start="(213, 31)" end="(213, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(213, 33)" end="(213, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(213, 33)" end="(213, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(213, 38)" end="(213, 39)">
                    <IdentNode start="(213, 38)" end="(213, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(213, 39)" end="(213, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(213, 41)" end="(213, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(213, 41)" end="(213, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(213, 42)" end="(213, 44)">
                <IdentNode start="(213, 42)" end="(213, 44)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(213, 45)" end="(213, 54)">
                <AtomNode start="(213, 45)" end="(213, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(213, 47)" end="(213, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(213, 47)" end="(213, 52)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(213, 53)" end="(213, 54)">
                    <IdentNode start="(213, 53)" end="(213, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(213, 54)" end="(213, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(213, 56)" end="(213, 118)">
            <AtomNode start="(213, 56)" end="(213, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(213, 58)" end="(213, 118)" kind="«term_=_»">
              <OtherNode start="(213, 58)" end="(213, 92)" kind="Lean.Parser.Term.app">
                <IdentNode start="(213, 58)" end="(213, 65)" leading="" trailing=" " raw_val="l.foldr" val="l.foldr"/>
                <NullNode start="(213, 66)" end="(213, 92)">
                  <OtherNode start="(213, 66)" end="(213, 89)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(213, 66)" end="(213, 67)" leading="" trailing="" val="("/>
                    <OtherNode start="(213, 67)" end="(213, 88)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(213, 67)" end="(213, 70)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(213, 71)" end="(213, 88)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(213, 71)" end="(213, 75)">
                          <IdentNode start="(213, 71)" end="(213, 72)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(213, 73)" end="(213, 75)" leading="" trailing=" " raw_val="bs" val="bs"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(213, 76)" end="(213, 78)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(213, 79)" end="(213, 88)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(213, 79)" end="(213, 83)" leading="" trailing=" " raw_val="push" val="push" full_name="Array.push" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(213, 84)" end="(213, 88)">
                            <IdentNode start="(213, 84)" end="(213, 86)" leading="" trailing=" " raw_val="bs" val="bs"/>
                            <IdentNode start="(213, 87)" end="(213, 88)" leading="" trailing="" raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(213, 88)" end="(213, 89)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(213, 90)" end="(213, 92)" leading="" trailing=" " raw_val="as" val="as"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(213, 93)" end="(213, 94)" leading="" trailing=" " val="="/>
              <OtherNode start="(213, 95)" end="(213, 118)" kind="«term_++_»">
                <IdentNode start="(213, 95)" end="(213, 97)" leading="" trailing=" " raw_val="as" val="as"/>
                <AtomNode start="(213, 98)" end="(213, 100)" leading="" trailing=" " val="++"/>
                <IdentNode start="(213, 101)" end="(213, 118)" leading="" trailing=" " raw_val="l.reverse.toArray" val="l.reverse.toArray"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(213, 119)" end="(214, 42)">
          <AtomNode start="(213, 119)" end="(213, 121)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(213, 122)" end="(214, 42)">
            <AtomNode start="(213, 122)" end="(213, 124)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(214, 3)" end="(214, 42)">
              <TacticTacticseq1IndentedNode start="(214, 3)" end="(214, 42)">
                <NullNode start="(214, 3)" end="(214, 42)">
                  <OtherNode start="(214, 3)" end="(214, 42)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;as : Array α&#10;⊢ foldr (fun a bs =&amp;gt; bs.push a) as l = as ++ l.reverse.toArray" state_after="no goals" tactic="rw [foldr_eq_foldl_reverse, foldl_push]">
                    <AtomNode start="(214, 3)" end="(214, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(214, 6)" end="(214, 42)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(214, 6)" end="(214, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(214, 7)" end="(214, 41)">
                        <OtherNode start="(214, 7)" end="(214, 29)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(214, 7)" end="(214, 29)" leading="" trailing="" raw_val="foldr_eq_foldl_reverse" val="foldr_eq_foldl_reverse" full_name="List.foldr_eq_foldl_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(214, 29)" end="(214, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(214, 31)" end="(214, 41)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(214, 31)" end="(214, 41)" leading="" trailing="" raw_val="foldl_push" val="foldl_push" full_name="List.foldl_push" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(210, 17)" def_end="(210, 27)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(214, 41)" end="(214, 42)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(216, 1)" end="(225, 29)" name="findSomeM?_toArray" full_name="List.findSomeM?_toArray">
      <CommandDeclmodifiersNode start="(216, 1)" end="(216, 8)">
        <NullNode/>
        <NullNode start="(216, 1)" end="(216, 8)">
          <OtherNode start="(216, 1)" end="(216, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(216, 1)" end="(216, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(216, 3)" end="(216, 7)">
              <OtherNode start="(216, 3)" end="(216, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(216, 3)" end="(216, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(216, 3)" end="(216, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(216, 7)" end="(216, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(216, 9)" end="(225, 29)" name="findSomeM?_toArray" full_name="List.findSomeM?_toArray" _is_private_decl="False">
        <AtomNode start="(216, 9)" end="(216, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(216, 17)" end="(216, 35)">
          <IdentNode start="(216, 17)" end="(216, 35)" leading="" trailing=" " raw_val="findSomeM?_toArray" val="findSomeM?_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(216, 36)" end="(217, 44)">
          <NullNode start="(216, 36)" end="(216, 97)">
            <OtherNode start="(216, 36)" end="(216, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(216, 36)" end="(216, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(216, 37)" end="(216, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(216, 37)" end="(216, 42)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(216, 43)" end="(216, 44)">
                  <IdentNode start="(216, 43)" end="(216, 44)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(216, 44)" end="(216, 45)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(216, 46)" end="(216, 61)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(216, 46)" end="(216, 47)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(216, 47)" end="(216, 60)" kind="Lean.Parser.Term.app">
                <IdentNode start="(216, 47)" end="(216, 58)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(216, 59)" end="(216, 60)">
                  <IdentNode start="(216, 59)" end="(216, 60)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(216, 60)" end="(216, 61)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(216, 62)" end="(216, 84)">
              <AtomNode start="(216, 62)" end="(216, 63)" leading="" trailing="" val="("/>
              <NullNode start="(216, 63)" end="(216, 64)">
                <IdentNode start="(216, 63)" end="(216, 64)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(216, 65)" end="(216, 83)">
                <AtomNode start="(216, 65)" end="(216, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(216, 67)" end="(216, 83)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(216, 67)" end="(216, 68)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(216, 69)" end="(216, 70)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(216, 71)" end="(216, 83)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(216, 71)" end="(216, 72)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(216, 73)" end="(216, 83)">
                      <OtherNode start="(216, 73)" end="(216, 83)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(216, 73)" end="(216, 74)" leading="" trailing="" val="("/>
                        <OtherNode start="(216, 74)" end="(216, 82)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(216, 74)" end="(216, 80)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(216, 81)" end="(216, 82)">
                            <IdentNode start="(216, 81)" end="(216, 82)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(216, 82)" end="(216, 83)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(216, 83)" end="(216, 84)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(216, 85)" end="(216, 97)">
              <AtomNode start="(216, 85)" end="(216, 86)" leading="" trailing="" val="("/>
              <NullNode start="(216, 86)" end="(216, 87)">
                <IdentNode start="(216, 86)" end="(216, 87)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(216, 88)" end="(216, 96)">
                <AtomNode start="(216, 88)" end="(216, 89)" leading="" trailing=" " val=":"/>
                <OtherNode start="(216, 90)" end="(216, 96)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(216, 90)" end="(216, 94)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(216, 95)" end="(216, 96)">
                    <IdentNode start="(216, 95)" end="(216, 96)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(216, 96)" end="(216, 97)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(216, 98)" end="(217, 44)">
            <AtomNode start="(216, 98)" end="(216, 99)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(217, 5)" end="(217, 44)" kind="«term_=_»">
              <OtherNode start="(217, 5)" end="(217, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(217, 5)" end="(217, 25)" leading="" trailing=" " raw_val="l.toArray.findSomeM?" val="l.toArray.findSomeM?"/>
                <NullNode start="(217, 26)" end="(217, 27)">
                  <IdentNode start="(217, 26)" end="(217, 27)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(217, 28)" end="(217, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(217, 30)" end="(217, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(217, 30)" end="(217, 42)" leading="" trailing=" " raw_val="l.findSomeM?" val="l.findSomeM?"/>
                <NullNode start="(217, 43)" end="(217, 44)">
                  <IdentNode start="(217, 43)" end="(217, 44)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(217, 45)" end="(225, 29)">
          <AtomNode start="(217, 45)" end="(217, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(217, 48)" end="(225, 29)">
            <AtomNode start="(217, 48)" end="(217, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(218, 3)" end="(225, 29)">
              <TacticTacticseq1IndentedNode start="(218, 3)" end="(225, 29)">
                <NullNode start="(218, 3)" end="(225, 29)">
                  <OtherNode start="(218, 3)" end="(218, 24)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;l : List α&#10;⊢ Array.findSomeM? f l.toArray = findSomeM? f l" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;l : List α&#10;⊢ (do&#10;      let r ←&#10;        forIn l.toArray ⟨none, PUnit.unit⟩ fun a r =&amp;gt;&#10;            let r := r.snd;&#10;            do&#10;            let __do_lift ← f a&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;              | x =&amp;gt; do&#10;                pure PUnit.unit&#10;                pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      let __do_jp : PUnit → m (Option β) := fun y =&amp;gt; pure none&#10;      match r.fst with&#10;        | none =&amp;gt; do&#10;          let y ← pure PUnit.unit&#10;          __do_jp y&#10;        | some a =&amp;gt; pure a) =&#10;    findSomeM? f l" tactic="rw [Array.findSomeM?]">
                    <AtomNode start="(218, 3)" end="(218, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(218, 6)" end="(218, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(218, 6)" end="(218, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(218, 7)" end="(218, 23)">
                        <OtherNode start="(218, 7)" end="(218, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(218, 7)" end="(218, 23)" leading="" trailing="" raw_val="Array.findSomeM?" val="Array.findSomeM?" full_name="Array.findSomeM?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(218, 23)" end="(218, 24)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(219, 3)" end="(219, 54)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;l : List α&#10;⊢ (do&#10;      let r ←&#10;        forIn l.toArray ⟨none, PUnit.unit⟩ fun a r =&amp;gt;&#10;            let r := r.snd;&#10;            do&#10;            let __do_lift ← f a&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;              | x =&amp;gt; do&#10;                pure PUnit.unit&#10;                pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      let __do_jp : PUnit → m (Option β) := fun y =&amp;gt; pure none&#10;      match r.fst with&#10;        | none =&amp;gt; do&#10;          let y ← pure PUnit.unit&#10;          __do_jp y&#10;        | some a =&amp;gt; pure a) =&#10;    findSomeM? f l" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;l : List α&#10;⊢ (do&#10;      let r ←&#10;        forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;              | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findSomeM? f l" tactic="simp only [bind_pure_comp, map_pure, forIn_toArray]">
                    <AtomNode start="(219, 3)" end="(219, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(219, 8)" end="(219, 12)">
                      <AtomNode start="(219, 8)" end="(219, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(219, 13)" end="(219, 54)">
                      <AtomNode start="(219, 13)" end="(219, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(219, 14)" end="(219, 53)">
                        <OtherNode start="(219, 14)" end="(219, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(219, 14)" end="(219, 28)" leading="" trailing="" raw_val="bind_pure_comp" val="bind_pure_comp" full_name="LawfulMonad.bind_pure_comp" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(219, 28)" end="(219, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(219, 30)" end="(219, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(219, 30)" end="(219, 38)" leading="" trailing="" raw_val="map_pure" val="map_pure" full_name="LawfulApplicative.map_pure" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(219, 38)" end="(219, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(219, 40)" end="(219, 53)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(219, 40)" end="(219, 53)" leading="" trailing="" raw_val="forIn_toArray" val="forIn_toArray" full_name="List.forIn_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(135, 17)" def_end="(135, 30)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(219, 53)" end="(219, 54)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(220, 3)" end="(225, 29)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;l : List α&#10;⊢ (do&#10;      let r ←&#10;        forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;              | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findSomeM? f l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt;&#10;  simp only [forIn_cons, LawfulMonad.bind_assoc, findSomeM?]&#10;  congr&#10;  ext1 (_|_) &amp;lt;;&amp;gt; simp [ih]">
                    <AtomNode start="(220, 3)" end="(220, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(220, 13)" end="(220, 14)">
                      <OtherNode start="(220, 13)" end="(220, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(220, 13)" end="(220, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(220, 15)" end="(225, 29)">
                      <OtherNode start="(220, 15)" end="(225, 29)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(220, 15)" end="(220, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(221, 3)" end="(225, 29)">
                          <OtherNode start="(221, 3)" end="(221, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(221, 3)" end="(221, 8)">
                              <OtherNode start="(221, 3)" end="(221, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(221, 3)" end="(221, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(221, 5)" end="(221, 8)">
                                  <NullNode/>
                                  <IdentNode start="(221, 5)" end="(221, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(221, 9)" end="(221, 16)">
                              <AtomNode start="(221, 9)" end="(221, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(221, 12)" end="(221, 16)">
                                <TacticTacticseq1IndentedNode start="(221, 12)" end="(221, 16)">
                                  <NullNode start="(221, 12)" end="(221, 16)">
                                    <OtherNode start="(221, 12)" end="(221, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;⊢ (do&#10;      let r ←&#10;        forIn [] ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;              | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findSomeM? f []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(221, 12)" end="(221, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(222, 3)" end="(225, 29)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(222, 3)" end="(222, 16)">
                              <OtherNode start="(222, 3)" end="(222, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(222, 3)" end="(222, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(222, 5)" end="(222, 9)">
                                  <NullNode/>
                                  <IdentNode start="(222, 5)" end="(222, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(222, 10)" end="(222, 16)">
                                  <IdentNode start="(222, 10)" end="(222, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(222, 12)" end="(222, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(222, 14)" end="(222, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(222, 17)" end="(225, 29)">
                              <AtomNode start="(222, 17)" end="(222, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(223, 5)" end="(225, 29)">
                                <TacticTacticseq1IndentedNode start="(223, 5)" end="(225, 29)">
                                  <NullNode start="(223, 5)" end="(225, 29)">
                                    <OtherNode start="(223, 5)" end="(223, 63)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih :&#10;  (do&#10;      let r ←&#10;        forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;              | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findSomeM? f l&#10;⊢ (do&#10;      let r ←&#10;        forIn (a :: l) ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;              | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findSomeM? f (a :: l)" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih :&#10;  (do&#10;      let r ←&#10;        forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;              | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findSomeM? f l&#10;⊢ (do&#10;      let x ← f a&#10;      let x ←&#10;        match x with&#10;          | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;          | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      let r ←&#10;        match x with&#10;          | ForInStep.done b =&amp;gt; pure b&#10;          | ForInStep.yield b =&amp;gt;&#10;            forIn l b fun a r =&amp;gt; do&#10;              let __do_lift ← f a&#10;              match __do_lift with&#10;                | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;                | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    do&#10;    let __do_lift ← f a&#10;    match __do_lift with&#10;      | some b =&amp;gt; pure (some b)&#10;      | none =&amp;gt; findSomeM? f l" tactic="simp only [forIn_cons, LawfulMonad.bind_assoc, findSomeM?]">
                                      <AtomNode start="(223, 5)" end="(223, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(223, 10)" end="(223, 14)">
                                        <AtomNode start="(223, 10)" end="(223, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(223, 15)" end="(223, 63)">
                                        <AtomNode start="(223, 15)" end="(223, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(223, 16)" end="(223, 62)">
                                          <OtherNode start="(223, 16)" end="(223, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(223, 16)" end="(223, 26)" leading="" trailing="" raw_val="forIn_cons" val="forIn_cons" full_name="List.forIn_cons" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(223, 26)" end="(223, 27)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(223, 28)" end="(223, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(223, 28)" end="(223, 50)" leading="" trailing="" raw_val="LawfulMonad.bind_assoc" val="LawfulMonad.bind_assoc" full_name="LawfulMonad.bind_assoc" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(223, 50)" end="(223, 51)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(223, 52)" end="(223, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(223, 52)" end="(223, 62)" leading="" trailing="" raw_val="findSomeM?" val="findSomeM?" full_name="List.findSomeM?" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(223, 62)" end="(223, 63)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(224, 5)" end="(224, 10)" kind="Lean.Parser.Tactic.congr" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih :&#10;  (do&#10;      let r ←&#10;        forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;              | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findSomeM? f l&#10;⊢ (do&#10;      let x ← f a&#10;      let x ←&#10;        match x with&#10;          | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;          | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      let r ←&#10;        match x with&#10;          | ForInStep.done b =&amp;gt; pure b&#10;          | ForInStep.yield b =&amp;gt;&#10;            forIn l b fun a r =&amp;gt; do&#10;              let __do_lift ← f a&#10;              match __do_lift with&#10;                | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;                | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    do&#10;    let __do_lift ← f a&#10;    match __do_lift with&#10;      | some b =&amp;gt; pure (some b)&#10;      | none =&amp;gt; findSomeM? f l" state_after="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih :&#10;  (do&#10;      let r ←&#10;        forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;              | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findSomeM? f l&#10;⊢ (fun x =&amp;gt; do&#10;      let x ←&#10;        match x with&#10;          | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;          | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      let r ←&#10;        match x with&#10;          | ForInStep.done b =&amp;gt; pure b&#10;          | ForInStep.yield b =&amp;gt;&#10;            forIn l b fun a r =&amp;gt; do&#10;              let __do_lift ← f a&#10;              match __do_lift with&#10;                | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;                | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    fun __do_lift =&amp;gt;&#10;    match __do_lift with&#10;    | some b =&amp;gt; pure (some b)&#10;    | none =&amp;gt; findSomeM? f l" tactic="congr">
                                      <AtomNode start="(224, 5)" end="(224, 10)" leading="" trailing="&#10;    " val="congr"/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(225, 5)" end="(225, 29)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih :&#10;  (do&#10;      let r ←&#10;        forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            match __do_lift with&#10;              | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;              | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findSomeM? f l&#10;⊢ (fun x =&amp;gt; do&#10;      let x ←&#10;        match x with&#10;          | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;          | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      let r ←&#10;        match x with&#10;          | ForInStep.done b =&amp;gt; pure b&#10;          | ForInStep.yield b =&amp;gt;&#10;            forIn l b fun a r =&amp;gt; do&#10;              let __do_lift ← f a&#10;              match __do_lift with&#10;                | some b =&amp;gt; pure (ForInStep.done ⟨some (some b), PUnit.unit⟩)&#10;                | x =&amp;gt; pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    fun __do_lift =&amp;gt;&#10;    match __do_lift with&#10;    | some b =&amp;gt; pure (some b)&#10;    | none =&amp;gt; findSomeM? f l" state_after="no goals" tactic="ext1 (_|_) &amp;lt;;&amp;gt; simp [ih]">
                                      <OtherNode start="(225, 5)" end="(225, 15)" kind="Lean.Elab.Tactic.Ext.tacticExt1___">
                                        <AtomNode start="(225, 5)" end="(225, 9)" leading="" trailing=" " val="ext1"/>
                                        <NullNode start="(225, 10)" end="(225, 15)">
                                          <OtherNode start="(225, 10)" end="(225, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                            <OtherNode start="(225, 10)" end="(225, 15)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                              <AtomNode start="(225, 10)" end="(225, 11)" leading="" trailing="" val="("/>
                                              <OtherNode start="(225, 11)" end="(225, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(225, 11)" end="(225, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(225, 11)" end="(225, 14)">
                                                    <OtherNode start="(225, 11)" end="(225, 12)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                      <AtomNode start="(225, 11)" end="(225, 12)" leading="" trailing="" val="_"/>
                                                    </OtherNode>
                                                    <AtomNode start="(225, 12)" end="(225, 13)" leading="" trailing="" val="|"/>
                                                    <OtherNode start="(225, 13)" end="(225, 14)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                      <AtomNode start="(225, 13)" end="(225, 14)" leading="" trailing="" val="_"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(225, 14)" end="(225, 15)" leading="" trailing=" " val=")"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(225, 16)" end="(225, 19)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(225, 20)" end="(225, 29)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(225, 20)" end="(225, 24)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(225, 25)" end="(225, 29)">
                                          <AtomNode start="(225, 25)" end="(225, 26)" leading="" trailing="" val="["/>
                                          <NullNode start="(225, 26)" end="(225, 28)">
                                            <OtherNode start="(225, 26)" end="(225, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(225, 26)" end="(225, 28)" leading="" trailing="" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(225, 28)" end="(225, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(227, 1)" end="(237, 24)" name="findSomeRevM?_find_toArray" full_name="List.findSomeRevM?_find_toArray">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(227, 1)" end="(237, 24)" name="findSomeRevM?_find_toArray" full_name="List.findSomeRevM?_find_toArray" _is_private_decl="False">
        <AtomNode start="(227, 1)" end="(227, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(227, 9)" end="(227, 35)">
          <IdentNode start="(227, 9)" end="(227, 35)" leading="" trailing=" " raw_val="findSomeRevM?_find_toArray" val="findSomeRevM?_find_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(227, 36)" end="(229, 73)">
          <NullNode start="(227, 36)" end="(228, 18)">
            <OtherNode start="(227, 36)" end="(227, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(227, 36)" end="(227, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(227, 37)" end="(227, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(227, 37)" end="(227, 42)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(227, 43)" end="(227, 44)">
                  <IdentNode start="(227, 43)" end="(227, 44)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(227, 44)" end="(227, 45)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(227, 46)" end="(227, 61)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(227, 46)" end="(227, 47)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(227, 47)" end="(227, 60)" kind="Lean.Parser.Term.app">
                <IdentNode start="(227, 47)" end="(227, 58)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(227, 59)" end="(227, 60)">
                  <IdentNode start="(227, 59)" end="(227, 60)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(227, 60)" end="(227, 61)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(227, 62)" end="(227, 84)">
              <AtomNode start="(227, 62)" end="(227, 63)" leading="" trailing="" val="("/>
              <NullNode start="(227, 63)" end="(227, 64)">
                <IdentNode start="(227, 63)" end="(227, 64)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(227, 65)" end="(227, 83)">
                <AtomNode start="(227, 65)" end="(227, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(227, 67)" end="(227, 83)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(227, 67)" end="(227, 68)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(227, 69)" end="(227, 70)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(227, 71)" end="(227, 83)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(227, 71)" end="(227, 72)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(227, 73)" end="(227, 83)">
                      <OtherNode start="(227, 73)" end="(227, 83)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(227, 73)" end="(227, 74)" leading="" trailing="" val="("/>
                        <OtherNode start="(227, 74)" end="(227, 82)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(227, 74)" end="(227, 80)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(227, 81)" end="(227, 82)">
                            <IdentNode start="(227, 81)" end="(227, 82)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(227, 82)" end="(227, 83)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(227, 83)" end="(227, 84)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(227, 85)" end="(227, 97)">
              <AtomNode start="(227, 85)" end="(227, 86)" leading="" trailing="" val="("/>
              <NullNode start="(227, 86)" end="(227, 87)">
                <IdentNode start="(227, 86)" end="(227, 87)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(227, 88)" end="(227, 96)">
                <AtomNode start="(227, 88)" end="(227, 89)" leading="" trailing=" " val=":"/>
                <OtherNode start="(227, 90)" end="(227, 96)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(227, 90)" end="(227, 94)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(227, 95)" end="(227, 96)">
                    <IdentNode start="(227, 95)" end="(227, 96)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(227, 96)" end="(227, 97)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(228, 5)" end="(228, 14)">
              <AtomNode start="(228, 5)" end="(228, 6)" leading="" trailing="" val="("/>
              <NullNode start="(228, 6)" end="(228, 7)">
                <IdentNode start="(228, 6)" end="(228, 7)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(228, 8)" end="(228, 13)">
                <AtomNode start="(228, 8)" end="(228, 9)" leading="" trailing=" " val=":"/>
                <IdentNode start="(228, 10)" end="(228, 13)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(228, 13)" end="(228, 14)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(228, 15)" end="(228, 18)">
              <AtomNode start="(228, 15)" end="(228, 16)" leading="" trailing="" val="("/>
              <NullNode start="(228, 16)" end="(228, 17)">
                <IdentNode start="(228, 16)" end="(228, 17)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(228, 17)" end="(228, 18)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(228, 19)" end="(229, 73)">
            <AtomNode start="(228, 19)" end="(228, 20)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(229, 5)" end="(229, 73)" kind="«term_=_»">
              <OtherNode start="(229, 5)" end="(229, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(229, 5)" end="(229, 23)" leading="" trailing=" " raw_val="findSomeRevM?.find" val="findSomeRevM?.find" full_name="Array.findSomeRevM?.find" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(229, 24)" end="(229, 39)">
                  <IdentNode start="(229, 24)" end="(229, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(229, 26)" end="(229, 35)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
                  <IdentNode start="(229, 36)" end="(229, 37)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(229, 38)" end="(229, 39)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(229, 40)" end="(229, 41)" leading="" trailing=" " val="="/>
              <OtherNode start="(229, 42)" end="(229, 73)" kind="Lean.Parser.Term.app">
                <OtherNode start="(229, 42)" end="(229, 71)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(229, 42)" end="(229, 52)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(229, 42)" end="(229, 43)" leading="" trailing="" val="("/>
                    <OtherNode start="(229, 43)" end="(229, 51)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(229, 43)" end="(229, 49)" leading="" trailing=" " raw_val="l.take" val="l.take"/>
                      <NullNode start="(229, 50)" end="(229, 51)">
                        <IdentNode start="(229, 50)" end="(229, 51)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(229, 51)" end="(229, 52)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(229, 52)" end="(229, 53)" leading="" trailing="" val="."/>
                  <IdentNode start="(229, 53)" end="(229, 71)" leading="" trailing=" " raw_val="reverse.findSomeM?" val="reverse.findSomeM?"/>
                </OtherNode>
                <NullNode start="(229, 72)" end="(229, 73)">
                  <IdentNode start="(229, 72)" end="(229, 73)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(229, 74)" end="(237, 24)">
          <AtomNode start="(229, 74)" end="(229, 76)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(229, 77)" end="(237, 24)">
            <AtomNode start="(229, 77)" end="(229, 79)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(230, 3)" end="(237, 24)">
              <TacticTacticseq1IndentedNode start="(230, 3)" end="(237, 24)">
                <NullNode start="(230, 3)" end="(237, 24)">
                  <OtherNode start="(230, 3)" end="(237, 24)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;l : List α&#10;i : Nat&#10;h : i ≤ l.toArray.size&#10;⊢ findSomeRevM?.find f l.toArray i h = findSomeM? f (take i l).reverse" state_after="no goals" tactic="induction i generalizing l with&#10;| zero =&amp;gt; simp [Array.findSomeRevM?.find.eq_def]&#10;| succ i ih =&amp;gt;&#10;  rw [size_toArray] at h&#10;  rw [Array.findSomeRevM?.find, take_succ, getElem?_eq_getElem (by omega)]&#10;  simp only [ih, reverse_append]&#10;  congr&#10;  ext1 (_|_) &amp;lt;;&amp;gt; simp">
                    <AtomNode start="(230, 3)" end="(230, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(230, 13)" end="(230, 14)">
                      <OtherNode start="(230, 13)" end="(230, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(230, 13)" end="(230, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(230, 15)" end="(230, 29)">
                      <AtomNode start="(230, 15)" end="(230, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(230, 28)" end="(230, 29)">
                        <IdentNode start="(230, 28)" end="(230, 29)" leading="" trailing=" " raw_val="l" val="l"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(230, 30)" end="(237, 24)">
                      <OtherNode start="(230, 30)" end="(237, 24)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(230, 30)" end="(230, 34)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(231, 3)" end="(237, 24)">
                          <OtherNode start="(231, 3)" end="(231, 51)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(231, 3)" end="(231, 9)">
                              <OtherNode start="(231, 3)" end="(231, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(231, 3)" end="(231, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(231, 5)" end="(231, 9)">
                                  <NullNode/>
                                  <IdentNode start="(231, 5)" end="(231, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(231, 10)" end="(231, 51)">
                              <AtomNode start="(231, 10)" end="(231, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(231, 13)" end="(231, 51)">
                                <TacticTacticseq1IndentedNode start="(231, 13)" end="(231, 51)">
                                  <NullNode start="(231, 13)" end="(231, 51)">
                                    <OtherNode start="(231, 13)" end="(231, 51)" kind="Lean.Parser.Tactic.simp" state_before="case zero&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;l : List α&#10;h : 0 ≤ l.toArray.size&#10;⊢ findSomeRevM?.find f l.toArray 0 h = findSomeM? f (take 0 l).reverse" state_after="no goals" tactic="simp [Array.findSomeRevM?.find.eq_def]">
                                      <AtomNode start="(231, 13)" end="(231, 17)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(231, 18)" end="(231, 51)">
                                        <AtomNode start="(231, 18)" end="(231, 19)" leading="" trailing="" val="["/>
                                        <NullNode start="(231, 19)" end="(231, 50)">
                                          <OtherNode start="(231, 19)" end="(231, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(231, 19)" end="(231, 50)" leading="" trailing="" raw_val="Array.findSomeRevM?.find.eq_def" val="Array.findSomeRevM?.find.eq_def" full_name="Array.findSomeRevM?.find.eq_def" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(231, 50)" end="(231, 51)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(232, 3)" end="(237, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(232, 3)" end="(232, 14)">
                              <OtherNode start="(232, 3)" end="(232, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(232, 3)" end="(232, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(232, 5)" end="(232, 9)">
                                  <NullNode/>
                                  <IdentNode start="(232, 5)" end="(232, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(232, 10)" end="(232, 14)">
                                  <IdentNode start="(232, 10)" end="(232, 11)" leading="" trailing=" " raw_val="i" val="i"/>
                                  <IdentNode start="(232, 12)" end="(232, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(232, 15)" end="(237, 24)">
                              <AtomNode start="(232, 15)" end="(232, 17)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(233, 5)" end="(237, 24)">
                                <TacticTacticseq1IndentedNode start="(233, 5)" end="(237, 24)">
                                  <NullNode start="(233, 5)" end="(237, 24)">
                                    <OtherNode start="(233, 5)" end="(233, 27)" kind="Lean.Parser.Tactic.rwSeq" state_before="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;i : Nat&#10;ih : ∀ (l : List α) (h : i ≤ l.toArray.size), findSomeRevM?.find f l.toArray i h = findSomeM? f (take i l).reverse&#10;l : List α&#10;h : i + 1 ≤ l.toArray.size&#10;⊢ findSomeRevM?.find f l.toArray (i + 1) h = findSomeM? f (take (i + 1) l).reverse" state_after="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;i : Nat&#10;ih : ∀ (l : List α) (h : i ≤ l.toArray.size), findSomeRevM?.find f l.toArray i h = findSomeM? f (take i l).reverse&#10;l : List α&#10;h✝ : i + 1 ≤ l.toArray.size&#10;h : i + 1 ≤ l.length&#10;⊢ findSomeRevM?.find f l.toArray (i + 1) h✝ = findSomeM? f (take (i + 1) l).reverse" tactic="rw [size_toArray] at h">
                                      <AtomNode start="(233, 5)" end="(233, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(233, 8)" end="(233, 22)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(233, 8)" end="(233, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(233, 9)" end="(233, 21)">
                                          <OtherNode start="(233, 9)" end="(233, 21)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(233, 9)" end="(233, 21)" leading="" trailing="" raw_val="size_toArray" val="size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(233, 21)" end="(233, 22)" leading="" trailing=" " val="]"/>
                                      </OtherNode>
                                      <NullNode start="(233, 23)" end="(233, 27)">
                                        <OtherNode start="(233, 23)" end="(233, 27)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(233, 23)" end="(233, 25)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(233, 26)" end="(233, 27)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(233, 26)" end="(233, 27)">
                                              <IdentNode start="(233, 26)" end="(233, 27)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(234, 5)" end="(234, 77)" kind="Lean.Parser.Tactic.rwSeq" state_before="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;i : Nat&#10;ih : ∀ (l : List α) (h : i ≤ l.toArray.size), findSomeRevM?.find f l.toArray i h = findSomeM? f (take i l).reverse&#10;l : List α&#10;h✝ : i + 1 ≤ l.toArray.size&#10;h : i + 1 ≤ l.length&#10;⊢ findSomeRevM?.find f l.toArray (i + 1) h✝ = findSomeM? f (take (i + 1) l).reverse" state_after="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;i : Nat&#10;ih : ∀ (l : List α) (h : i ≤ l.toArray.size), findSomeRevM?.find f l.toArray i h = findSomeM? f (take i l).reverse&#10;l : List α&#10;h✝ : i + 1 ≤ l.toArray.size&#10;h : i + 1 ≤ l.length&#10;⊢ (do&#10;      let r ← f l.toArray[i]&#10;      match r with&#10;        | some val =&amp;gt; pure r&#10;        | none =&amp;gt;&#10;          let_fun this := ⋯;&#10;          findSomeRevM?.find f l.toArray i this) =&#10;    findSomeM? f (take i l ++ (some l[i]).toList).reverse" tactic="rw [Array.findSomeRevM?.find, take_succ, getElem?_eq_getElem (by omega)]">
                                      <AtomNode start="(234, 5)" end="(234, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(234, 8)" end="(234, 77)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(234, 8)" end="(234, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(234, 9)" end="(234, 76)">
                                          <OtherNode start="(234, 9)" end="(234, 33)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(234, 9)" end="(234, 33)" leading="" trailing="" raw_val="Array.findSomeRevM?.find" val="Array.findSomeRevM?.find" full_name="Array.findSomeRevM?.find" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(234, 33)" end="(234, 34)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(234, 35)" end="(234, 44)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(234, 35)" end="(234, 44)" leading="" trailing="" raw_val="take_succ" val="take_succ" full_name="List.take_succ" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(234, 44)" end="(234, 45)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(234, 46)" end="(234, 76)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <OtherNode start="(234, 46)" end="(234, 76)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(234, 46)" end="(234, 65)" leading="" trailing=" " raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="List.getElem?_eq_getElem" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                              <NullNode start="(234, 66)" end="(234, 76)">
                                                <OtherNode start="(234, 66)" end="(234, 76)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(234, 66)" end="(234, 67)" leading="" trailing="" val="("/>
                                                  <TermBytacticNode start="(234, 67)" end="(234, 75)">
                                                    <AtomNode start="(234, 67)" end="(234, 69)" leading="" trailing=" " val="by"/>
                                                    <TacticTacticseqNode start="(234, 70)" end="(234, 75)">
                                                      <TacticTacticseq1IndentedNode start="(234, 70)" end="(234, 75)">
                                                        <NullNode start="(234, 70)" end="(234, 75)">
                                                          <OtherNode start="(234, 70)" end="(234, 75)" kind="Lean.Parser.Tactic.omega" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;i : Nat&#10;ih : ∀ (l : List α) (h : i ≤ l.toArray.size), findSomeRevM?.find f l.toArray i h = findSomeM? f (take i l).reverse&#10;l : List α&#10;h✝ : i + 1 ≤ l.toArray.size&#10;h : i + 1 ≤ l.length&#10;⊢ i &amp;lt; l.length" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(234, 70)" end="(234, 75)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </TermBytacticNode>
                                                  <AtomNode start="(234, 75)" end="(234, 76)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(234, 76)" end="(234, 77)" leading="" trailing="&#10;    " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(235, 5)" end="(235, 35)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;i : Nat&#10;ih : ∀ (l : List α) (h : i ≤ l.toArray.size), findSomeRevM?.find f l.toArray i h = findSomeM? f (take i l).reverse&#10;l : List α&#10;h✝ : i + 1 ≤ l.toArray.size&#10;h : i + 1 ≤ l.length&#10;⊢ (do&#10;      let r ← f l.toArray[i]&#10;      match r with&#10;        | some val =&amp;gt; pure r&#10;        | none =&amp;gt;&#10;          let_fun this := ⋯;&#10;          findSomeRevM?.find f l.toArray i this) =&#10;    findSomeM? f (take i l ++ (some l[i]).toList).reverse" state_after="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;i : Nat&#10;ih : ∀ (l : List α) (h : i ≤ l.toArray.size), findSomeRevM?.find f l.toArray i h = findSomeM? f (take i l).reverse&#10;l : List α&#10;h✝ : i + 1 ≤ l.toArray.size&#10;h : i + 1 ≤ l.length&#10;⊢ (do&#10;      let r ← f l.toArray[i]&#10;      match r with&#10;        | some val =&amp;gt; pure r&#10;        | none =&amp;gt; findSomeM? f (take i l).reverse) =&#10;    findSomeM? f ((some l[i]).toList.reverse ++ (take i l).reverse)" tactic="simp only [ih, reverse_append]">
                                      <AtomNode start="(235, 5)" end="(235, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(235, 10)" end="(235, 14)">
                                        <AtomNode start="(235, 10)" end="(235, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(235, 15)" end="(235, 35)">
                                        <AtomNode start="(235, 15)" end="(235, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(235, 16)" end="(235, 34)">
                                          <OtherNode start="(235, 16)" end="(235, 18)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(235, 16)" end="(235, 18)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(235, 18)" end="(235, 19)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(235, 20)" end="(235, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(235, 20)" end="(235, 34)" leading="" trailing="" raw_val="reverse_append" val="reverse_append" full_name="List.reverse_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(235, 34)" end="(235, 35)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(236, 5)" end="(236, 10)" kind="Lean.Parser.Tactic.congr" state_before="case succ&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;i : Nat&#10;ih : ∀ (l : List α) (h : i ≤ l.toArray.size), findSomeRevM?.find f l.toArray i h = findSomeM? f (take i l).reverse&#10;l : List α&#10;h✝ : i + 1 ≤ l.toArray.size&#10;h : i + 1 ≤ l.length&#10;⊢ (do&#10;      let r ← f l.toArray[i]&#10;      match r with&#10;        | some val =&amp;gt; pure r&#10;        | none =&amp;gt; findSomeM? f (take i l).reverse) =&#10;    findSomeM? f ((some l[i]).toList.reverse ++ (take i l).reverse)" state_after="case succ.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;i : Nat&#10;ih : ∀ (l : List α) (h : i ≤ l.toArray.size), findSomeRevM?.find f l.toArray i h = findSomeM? f (take i l).reverse&#10;l : List α&#10;h✝ : i + 1 ≤ l.toArray.size&#10;h : i + 1 ≤ l.length&#10;⊢ (fun r =&amp;gt;&#10;      match r with&#10;      | some val =&amp;gt; pure r&#10;      | none =&amp;gt; findSomeM? f (take i l).reverse) =&#10;    fun __do_lift =&amp;gt;&#10;    match __do_lift with&#10;    | some b =&amp;gt; pure (some b)&#10;    | none =&amp;gt; findSomeM? f ([].append (take i l).reverse)" tactic="congr">
                                      <AtomNode start="(236, 5)" end="(236, 10)" leading="" trailing="&#10;    " val="congr"/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(237, 5)" end="(237, 24)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case succ.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;i : Nat&#10;ih : ∀ (l : List α) (h : i ≤ l.toArray.size), findSomeRevM?.find f l.toArray i h = findSomeM? f (take i l).reverse&#10;l : List α&#10;h✝ : i + 1 ≤ l.toArray.size&#10;h : i + 1 ≤ l.length&#10;⊢ (fun r =&amp;gt;&#10;      match r with&#10;      | some val =&amp;gt; pure r&#10;      | none =&amp;gt; findSomeM? f (take i l).reverse) =&#10;    fun __do_lift =&amp;gt;&#10;    match __do_lift with&#10;    | some b =&amp;gt; pure (some b)&#10;    | none =&amp;gt; findSomeM? f ([].append (take i l).reverse)" state_after="no goals" tactic="ext1 (_|_) &amp;lt;;&amp;gt; simp">
                                      <OtherNode start="(237, 5)" end="(237, 15)" kind="Lean.Elab.Tactic.Ext.tacticExt1___">
                                        <AtomNode start="(237, 5)" end="(237, 9)" leading="" trailing=" " val="ext1"/>
                                        <NullNode start="(237, 10)" end="(237, 15)">
                                          <OtherNode start="(237, 10)" end="(237, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                            <OtherNode start="(237, 10)" end="(237, 15)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                              <AtomNode start="(237, 10)" end="(237, 11)" leading="" trailing="" val="("/>
                                              <OtherNode start="(237, 11)" end="(237, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(237, 11)" end="(237, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(237, 11)" end="(237, 14)">
                                                    <OtherNode start="(237, 11)" end="(237, 12)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                      <AtomNode start="(237, 11)" end="(237, 12)" leading="" trailing="" val="_"/>
                                                    </OtherNode>
                                                    <AtomNode start="(237, 12)" end="(237, 13)" leading="" trailing="" val="|"/>
                                                    <OtherNode start="(237, 13)" end="(237, 14)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                      <AtomNode start="(237, 13)" end="(237, 14)" leading="" trailing="" val="_"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(237, 14)" end="(237, 15)" leading="" trailing=" " val=")"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(237, 16)" end="(237, 19)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(237, 20)" end="(237, 24)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(237, 20)" end="(237, 24)" leading="" trailing="&#10;&#10;-- This is not marked as `@[simp]` as later we simplify all occurrences of `findSomeRevM?`.&#10;" val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(240, 1)" end="(242, 57)" name="findSomeRevM?_toArray" full_name="List.findSomeRevM?_toArray">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(240, 1)" end="(242, 57)" name="findSomeRevM?_toArray" full_name="List.findSomeRevM?_toArray" _is_private_decl="False">
        <AtomNode start="(240, 1)" end="(240, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(240, 9)" end="(240, 30)">
          <IdentNode start="(240, 9)" end="(240, 30)" leading="" trailing=" " raw_val="findSomeRevM?_toArray" val="findSomeRevM?_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(240, 31)" end="(241, 55)">
          <NullNode start="(240, 31)" end="(240, 92)">
            <OtherNode start="(240, 31)" end="(240, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(240, 31)" end="(240, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(240, 32)" end="(240, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(240, 32)" end="(240, 37)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(240, 38)" end="(240, 39)">
                  <IdentNode start="(240, 38)" end="(240, 39)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(240, 39)" end="(240, 40)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(240, 41)" end="(240, 56)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(240, 41)" end="(240, 42)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(240, 42)" end="(240, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(240, 42)" end="(240, 53)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(240, 54)" end="(240, 55)">
                  <IdentNode start="(240, 54)" end="(240, 55)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(240, 55)" end="(240, 56)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(240, 57)" end="(240, 79)">
              <AtomNode start="(240, 57)" end="(240, 58)" leading="" trailing="" val="("/>
              <NullNode start="(240, 58)" end="(240, 59)">
                <IdentNode start="(240, 58)" end="(240, 59)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(240, 60)" end="(240, 78)">
                <AtomNode start="(240, 60)" end="(240, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(240, 62)" end="(240, 78)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(240, 62)" end="(240, 63)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(240, 64)" end="(240, 65)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(240, 66)" end="(240, 78)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(240, 66)" end="(240, 67)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(240, 68)" end="(240, 78)">
                      <OtherNode start="(240, 68)" end="(240, 78)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(240, 68)" end="(240, 69)" leading="" trailing="" val="("/>
                        <OtherNode start="(240, 69)" end="(240, 77)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(240, 69)" end="(240, 75)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(240, 76)" end="(240, 77)">
                            <IdentNode start="(240, 76)" end="(240, 77)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(240, 77)" end="(240, 78)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(240, 78)" end="(240, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(240, 80)" end="(240, 92)">
              <AtomNode start="(240, 80)" end="(240, 81)" leading="" trailing="" val="("/>
              <NullNode start="(240, 81)" end="(240, 82)">
                <IdentNode start="(240, 81)" end="(240, 82)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(240, 83)" end="(240, 91)">
                <AtomNode start="(240, 83)" end="(240, 84)" leading="" trailing=" " val=":"/>
                <OtherNode start="(240, 85)" end="(240, 91)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(240, 85)" end="(240, 89)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(240, 90)" end="(240, 91)">
                    <IdentNode start="(240, 90)" end="(240, 91)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(240, 91)" end="(240, 92)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(240, 93)" end="(241, 55)">
            <AtomNode start="(240, 93)" end="(240, 94)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(241, 5)" end="(241, 55)" kind="«term_=_»">
              <OtherNode start="(241, 5)" end="(241, 30)" kind="Lean.Parser.Term.app">
                <IdentNode start="(241, 5)" end="(241, 28)" leading="" trailing=" " raw_val="l.toArray.findSomeRevM?" val="l.toArray.findSomeRevM?"/>
                <NullNode start="(241, 29)" end="(241, 30)">
                  <IdentNode start="(241, 29)" end="(241, 30)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(241, 31)" end="(241, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(241, 33)" end="(241, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(241, 33)" end="(241, 53)" leading="" trailing=" " raw_val="l.reverse.findSomeM?" val="l.reverse.findSomeM?"/>
                <NullNode start="(241, 54)" end="(241, 55)">
                  <IdentNode start="(241, 54)" end="(241, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(241, 56)" end="(242, 57)">
          <AtomNode start="(241, 56)" end="(241, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(241, 59)" end="(242, 57)">
            <AtomNode start="(241, 59)" end="(241, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(242, 3)" end="(242, 57)">
              <TacticTacticseq1IndentedNode start="(242, 3)" end="(242, 57)">
                <NullNode start="(242, 3)" end="(242, 57)">
                  <OtherNode start="(242, 3)" end="(242, 57)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;l : List α&#10;⊢ findSomeRevM? f l.toArray = findSomeM? f l.reverse" state_after="no goals" tactic="simp [Array.findSomeRevM?, findSomeRevM?_find_toArray]">
                    <AtomNode start="(242, 3)" end="(242, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(242, 8)" end="(242, 57)">
                      <AtomNode start="(242, 8)" end="(242, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(242, 9)" end="(242, 56)">
                        <OtherNode start="(242, 9)" end="(242, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(242, 9)" end="(242, 28)" leading="" trailing="" raw_val="Array.findSomeRevM?" val="Array.findSomeRevM?" full_name="Array.findSomeRevM?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(242, 28)" end="(242, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(242, 30)" end="(242, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(242, 30)" end="(242, 56)" leading="" trailing="" raw_val="findSomeRevM?_find_toArray" val="findSomeRevM?_find_toArray" full_name="List.findSomeRevM?_find_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(227, 9)" def_end="(227, 35)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(242, 56)" end="(242, 57)" leading="" trailing="&#10;&#10;-- This is not marked as `@[simp]` as later we simplify all occurrences of `findRevM?`.&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(245, 1)" end="(247, 68)" name="findRevM?_toArray" full_name="List.findRevM?_toArray">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(245, 1)" end="(247, 68)" name="findRevM?_toArray" full_name="List.findRevM?_toArray" _is_private_decl="False">
        <AtomNode start="(245, 1)" end="(245, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(245, 9)" end="(245, 26)">
          <IdentNode start="(245, 9)" end="(245, 26)" leading="" trailing=" " raw_val="findRevM?_toArray" val="findRevM?_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(245, 27)" end="(246, 47)">
          <NullNode start="(245, 27)" end="(245, 82)">
            <OtherNode start="(245, 27)" end="(245, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(245, 27)" end="(245, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(245, 28)" end="(245, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(245, 28)" end="(245, 33)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(245, 34)" end="(245, 35)">
                  <IdentNode start="(245, 34)" end="(245, 35)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(245, 35)" end="(245, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(245, 37)" end="(245, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(245, 37)" end="(245, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(245, 38)" end="(245, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(245, 38)" end="(245, 49)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(245, 50)" end="(245, 51)">
                  <IdentNode start="(245, 50)" end="(245, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(245, 51)" end="(245, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(245, 53)" end="(245, 69)">
              <AtomNode start="(245, 53)" end="(245, 54)" leading="" trailing="" val="("/>
              <NullNode start="(245, 54)" end="(245, 55)">
                <IdentNode start="(245, 54)" end="(245, 55)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(245, 56)" end="(245, 68)">
                <AtomNode start="(245, 56)" end="(245, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(245, 58)" end="(245, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(245, 58)" end="(245, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(245, 60)" end="(245, 61)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(245, 62)" end="(245, 68)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(245, 62)" end="(245, 63)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(245, 64)" end="(245, 68)">
                      <IdentNode start="(245, 64)" end="(245, 68)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(245, 68)" end="(245, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(245, 70)" end="(245, 82)">
              <AtomNode start="(245, 70)" end="(245, 71)" leading="" trailing="" val="("/>
              <NullNode start="(245, 71)" end="(245, 72)">
                <IdentNode start="(245, 71)" end="(245, 72)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(245, 73)" end="(245, 81)">
                <AtomNode start="(245, 73)" end="(245, 74)" leading="" trailing=" " val=":"/>
                <OtherNode start="(245, 75)" end="(245, 81)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(245, 75)" end="(245, 79)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(245, 80)" end="(245, 81)">
                    <IdentNode start="(245, 80)" end="(245, 81)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(245, 81)" end="(245, 82)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(245, 83)" end="(246, 47)">
            <AtomNode start="(245, 83)" end="(245, 84)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(246, 5)" end="(246, 47)" kind="«term_=_»">
              <OtherNode start="(246, 5)" end="(246, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(246, 5)" end="(246, 24)" leading="" trailing=" " raw_val="l.toArray.findRevM?" val="l.toArray.findRevM?"/>
                <NullNode start="(246, 25)" end="(246, 26)">
                  <IdentNode start="(246, 25)" end="(246, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(246, 27)" end="(246, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(246, 29)" end="(246, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(246, 29)" end="(246, 45)" leading="" trailing=" " raw_val="l.reverse.findM?" val="l.reverse.findM?"/>
                <NullNode start="(246, 46)" end="(246, 47)">
                  <IdentNode start="(246, 46)" end="(246, 47)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(246, 48)" end="(247, 68)">
          <AtomNode start="(246, 48)" end="(246, 50)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(246, 51)" end="(247, 68)">
            <AtomNode start="(246, 51)" end="(246, 53)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(247, 3)" end="(247, 68)">
              <TacticTacticseq1IndentedNode start="(247, 3)" end="(247, 68)">
                <NullNode start="(247, 3)" end="(247, 68)">
                  <OtherNode start="(247, 3)" end="(247, 68)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m Bool&#10;l : List α&#10;⊢ findRevM? f l.toArray = findM? f l.reverse" state_after="no goals" tactic="rw [Array.findRevM?, findSomeRevM?_toArray, findM?_eq_findSomeM?]">
                    <AtomNode start="(247, 3)" end="(247, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(247, 6)" end="(247, 68)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(247, 6)" end="(247, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(247, 7)" end="(247, 67)">
                        <OtherNode start="(247, 7)" end="(247, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(247, 7)" end="(247, 22)" leading="" trailing="" raw_val="Array.findRevM?" val="Array.findRevM?" full_name="Array.findRevM?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(247, 22)" end="(247, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(247, 24)" end="(247, 45)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(247, 24)" end="(247, 45)" leading="" trailing="" raw_val="findSomeRevM?_toArray" val="findSomeRevM?_toArray" full_name="List.findSomeRevM?_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(240, 9)" def_end="(240, 30)"/>
                        </OtherNode>
                        <AtomNode start="(247, 45)" end="(247, 46)" leading="" trailing=" " val=","/>
                        <OtherNode start="(247, 47)" end="(247, 67)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(247, 47)" end="(247, 67)" leading="" trailing="" raw_val="findM?_eq_findSomeM?" val="findM?_eq_findSomeM?" full_name="List.findM?_eq_findSomeM?" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(247, 67)" end="(247, 68)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(249, 1)" end="(258, 29)" name="findM?_toArray" full_name="List.findM?_toArray">
      <CommandDeclmodifiersNode start="(249, 1)" end="(249, 8)">
        <NullNode/>
        <NullNode start="(249, 1)" end="(249, 8)">
          <OtherNode start="(249, 1)" end="(249, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(249, 1)" end="(249, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(249, 3)" end="(249, 7)">
              <OtherNode start="(249, 3)" end="(249, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(249, 3)" end="(249, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(249, 3)" end="(249, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(249, 7)" end="(249, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(249, 9)" end="(258, 29)" name="findM?_toArray" full_name="List.findM?_toArray" _is_private_decl="False">
        <AtomNode start="(249, 9)" end="(249, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(249, 17)" end="(249, 31)">
          <IdentNode start="(249, 17)" end="(249, 31)" leading="" trailing=" " raw_val="findM?_toArray" val="findM?_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(249, 32)" end="(250, 36)">
          <NullNode start="(249, 32)" end="(249, 87)">
            <OtherNode start="(249, 32)" end="(249, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(249, 32)" end="(249, 33)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(249, 33)" end="(249, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(249, 33)" end="(249, 38)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(249, 39)" end="(249, 40)">
                  <IdentNode start="(249, 39)" end="(249, 40)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(249, 40)" end="(249, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(249, 42)" end="(249, 57)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(249, 42)" end="(249, 43)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(249, 43)" end="(249, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(249, 43)" end="(249, 54)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(249, 55)" end="(249, 56)">
                  <IdentNode start="(249, 55)" end="(249, 56)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(249, 56)" end="(249, 57)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(249, 58)" end="(249, 74)">
              <AtomNode start="(249, 58)" end="(249, 59)" leading="" trailing="" val="("/>
              <NullNode start="(249, 59)" end="(249, 60)">
                <IdentNode start="(249, 59)" end="(249, 60)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(249, 61)" end="(249, 73)">
                <AtomNode start="(249, 61)" end="(249, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(249, 63)" end="(249, 73)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(249, 63)" end="(249, 64)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(249, 65)" end="(249, 66)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(249, 67)" end="(249, 73)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(249, 67)" end="(249, 68)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(249, 69)" end="(249, 73)">
                      <IdentNode start="(249, 69)" end="(249, 73)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(249, 73)" end="(249, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(249, 75)" end="(249, 87)">
              <AtomNode start="(249, 75)" end="(249, 76)" leading="" trailing="" val="("/>
              <NullNode start="(249, 76)" end="(249, 77)">
                <IdentNode start="(249, 76)" end="(249, 77)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(249, 78)" end="(249, 86)">
                <AtomNode start="(249, 78)" end="(249, 79)" leading="" trailing=" " val=":"/>
                <OtherNode start="(249, 80)" end="(249, 86)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(249, 80)" end="(249, 84)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(249, 85)" end="(249, 86)">
                    <IdentNode start="(249, 85)" end="(249, 86)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(249, 86)" end="(249, 87)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(249, 88)" end="(250, 36)">
            <AtomNode start="(249, 88)" end="(249, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(250, 5)" end="(250, 36)" kind="«term_=_»">
              <OtherNode start="(250, 5)" end="(250, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(250, 5)" end="(250, 21)" leading="" trailing=" " raw_val="l.toArray.findM?" val="l.toArray.findM?"/>
                <NullNode start="(250, 22)" end="(250, 23)">
                  <IdentNode start="(250, 22)" end="(250, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(250, 24)" end="(250, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(250, 26)" end="(250, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(250, 26)" end="(250, 34)" leading="" trailing=" " raw_val="l.findM?" val="l.findM?"/>
                <NullNode start="(250, 35)" end="(250, 36)">
                  <IdentNode start="(250, 35)" end="(250, 36)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(250, 37)" end="(258, 29)">
          <AtomNode start="(250, 37)" end="(250, 39)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(250, 40)" end="(258, 29)">
            <AtomNode start="(250, 40)" end="(250, 42)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(251, 3)" end="(258, 29)">
              <TacticTacticseq1IndentedNode start="(251, 3)" end="(258, 29)">
                <NullNode start="(251, 3)" end="(258, 29)">
                  <OtherNode start="(251, 3)" end="(251, 20)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m Bool&#10;l : List α&#10;⊢ Array.findM? f l.toArray = findM? f l" state_after="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m Bool&#10;l : List α&#10;⊢ (do&#10;      let r ←&#10;        forIn l.toArray ⟨none, PUnit.unit⟩ fun a r =&amp;gt;&#10;            let r := r.snd;&#10;            do&#10;            let __do_lift ← f a&#10;            if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;              else do&#10;                pure PUnit.unit&#10;                pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      let __do_jp : PUnit → m (Option α) := fun y =&amp;gt; pure none&#10;      match r.fst with&#10;        | none =&amp;gt; do&#10;          let y ← pure PUnit.unit&#10;          __do_jp y&#10;        | some a =&amp;gt; pure a) =&#10;    findM? f l" tactic="rw [Array.findM?]">
                    <AtomNode start="(251, 3)" end="(251, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(251, 6)" end="(251, 20)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(251, 6)" end="(251, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(251, 7)" end="(251, 19)">
                        <OtherNode start="(251, 7)" end="(251, 19)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(251, 7)" end="(251, 19)" leading="" trailing="" raw_val="Array.findM?" val="Array.findM?" full_name="Array.findM?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(251, 19)" end="(251, 20)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(252, 3)" end="(252, 54)" kind="Lean.Parser.Tactic.simp" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m Bool&#10;l : List α&#10;⊢ (do&#10;      let r ←&#10;        forIn l.toArray ⟨none, PUnit.unit⟩ fun a r =&amp;gt;&#10;            let r := r.snd;&#10;            do&#10;            let __do_lift ← f a&#10;            if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;              else do&#10;                pure PUnit.unit&#10;                pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      let __do_jp : PUnit → m (Option α) := fun y =&amp;gt; pure none&#10;      match r.fst with&#10;        | none =&amp;gt; do&#10;          let y ← pure PUnit.unit&#10;          __do_jp y&#10;        | some a =&amp;gt; pure a) =&#10;    findM? f l" state_after="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m Bool&#10;l : List α&#10;⊢ (do&#10;      let r ←&#10;        forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;              else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findM? f l" tactic="simp only [bind_pure_comp, map_pure, forIn_toArray]">
                    <AtomNode start="(252, 3)" end="(252, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(252, 8)" end="(252, 12)">
                      <AtomNode start="(252, 8)" end="(252, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(252, 13)" end="(252, 54)">
                      <AtomNode start="(252, 13)" end="(252, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(252, 14)" end="(252, 53)">
                        <OtherNode start="(252, 14)" end="(252, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(252, 14)" end="(252, 28)" leading="" trailing="" raw_val="bind_pure_comp" val="bind_pure_comp" full_name="LawfulMonad.bind_pure_comp" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(252, 28)" end="(252, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(252, 30)" end="(252, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(252, 30)" end="(252, 38)" leading="" trailing="" raw_val="map_pure" val="map_pure" full_name="LawfulApplicative.map_pure" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(252, 38)" end="(252, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(252, 40)" end="(252, 53)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(252, 40)" end="(252, 53)" leading="" trailing="" raw_val="forIn_toArray" val="forIn_toArray" full_name="List.forIn_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(135, 17)" def_end="(135, 30)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(252, 53)" end="(252, 54)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(253, 3)" end="(258, 29)" kind="Lean.Parser.Tactic.induction" state_before="m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m Bool&#10;l : List α&#10;⊢ (do&#10;      let r ←&#10;        forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;              else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findM? f l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt;&#10;  simp only [forIn_cons, LawfulMonad.bind_assoc, findM?]&#10;  congr&#10;  ext1 (_|_) &amp;lt;;&amp;gt; simp [ih]">
                    <AtomNode start="(253, 3)" end="(253, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(253, 13)" end="(253, 14)">
                      <OtherNode start="(253, 13)" end="(253, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(253, 13)" end="(253, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(253, 15)" end="(258, 29)">
                      <OtherNode start="(253, 15)" end="(258, 29)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(253, 15)" end="(253, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(254, 3)" end="(258, 29)">
                          <OtherNode start="(254, 3)" end="(254, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(254, 3)" end="(254, 8)">
                              <OtherNode start="(254, 3)" end="(254, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(254, 3)" end="(254, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(254, 5)" end="(254, 8)">
                                  <NullNode/>
                                  <IdentNode start="(254, 5)" end="(254, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(254, 9)" end="(254, 16)">
                              <AtomNode start="(254, 9)" end="(254, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(254, 12)" end="(254, 16)">
                                <TacticTacticseq1IndentedNode start="(254, 12)" end="(254, 16)">
                                  <NullNode start="(254, 12)" end="(254, 16)">
                                    <OtherNode start="(254, 12)" end="(254, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m Bool&#10;⊢ (do&#10;      let r ←&#10;        forIn [] ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;              else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findM? f []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(254, 12)" end="(254, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(255, 3)" end="(258, 29)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(255, 3)" end="(255, 16)">
                              <OtherNode start="(255, 3)" end="(255, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(255, 3)" end="(255, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(255, 5)" end="(255, 9)">
                                  <NullNode/>
                                  <IdentNode start="(255, 5)" end="(255, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(255, 10)" end="(255, 16)">
                                  <IdentNode start="(255, 10)" end="(255, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(255, 12)" end="(255, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(255, 14)" end="(255, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(255, 17)" end="(258, 29)">
                              <AtomNode start="(255, 17)" end="(255, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(256, 5)" end="(258, 29)">
                                <TacticTacticseq1IndentedNode start="(256, 5)" end="(258, 29)">
                                  <NullNode start="(256, 5)" end="(258, 29)">
                                    <OtherNode start="(256, 5)" end="(256, 59)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m Bool&#10;a : α&#10;l : List α&#10;ih :&#10;  (do&#10;      let r ←&#10;        forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;              else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findM? f l&#10;⊢ (do&#10;      let r ←&#10;        forIn (a :: l) ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;              else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findM? f (a :: l)" state_after="case cons&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m Bool&#10;a : α&#10;l : List α&#10;ih :&#10;  (do&#10;      let r ←&#10;        forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;              else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findM? f l&#10;⊢ (do&#10;      let x ← f a&#10;      let x ←&#10;        if x = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;          else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      let r ←&#10;        match x with&#10;          | ForInStep.done b =&amp;gt; pure b&#10;          | ForInStep.yield b =&amp;gt;&#10;            forIn l b fun a r =&amp;gt; do&#10;              let __do_lift ← f a&#10;              if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;                else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    do&#10;    let __do_lift ← f a&#10;    match __do_lift with&#10;      | true =&amp;gt; pure (some a)&#10;      | false =&amp;gt; findM? f l" tactic="simp only [forIn_cons, LawfulMonad.bind_assoc, findM?]">
                                      <AtomNode start="(256, 5)" end="(256, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(256, 10)" end="(256, 14)">
                                        <AtomNode start="(256, 10)" end="(256, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(256, 15)" end="(256, 59)">
                                        <AtomNode start="(256, 15)" end="(256, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(256, 16)" end="(256, 58)">
                                          <OtherNode start="(256, 16)" end="(256, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(256, 16)" end="(256, 26)" leading="" trailing="" raw_val="forIn_cons" val="forIn_cons" full_name="List.forIn_cons" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(256, 26)" end="(256, 27)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(256, 28)" end="(256, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(256, 28)" end="(256, 50)" leading="" trailing="" raw_val="LawfulMonad.bind_assoc" val="LawfulMonad.bind_assoc" full_name="LawfulMonad.bind_assoc" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(256, 50)" end="(256, 51)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(256, 52)" end="(256, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(256, 52)" end="(256, 58)" leading="" trailing="" raw_val="findM?" val="findM?" full_name="List.findM?" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(256, 58)" end="(256, 59)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(257, 5)" end="(257, 10)" kind="Lean.Parser.Tactic.congr" state_before="case cons&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m Bool&#10;a : α&#10;l : List α&#10;ih :&#10;  (do&#10;      let r ←&#10;        forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;              else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findM? f l&#10;⊢ (do&#10;      let x ← f a&#10;      let x ←&#10;        if x = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;          else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      let r ←&#10;        match x with&#10;          | ForInStep.done b =&amp;gt; pure b&#10;          | ForInStep.yield b =&amp;gt;&#10;            forIn l b fun a r =&amp;gt; do&#10;              let __do_lift ← f a&#10;              if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;                else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    do&#10;    let __do_lift ← f a&#10;    match __do_lift with&#10;      | true =&amp;gt; pure (some a)&#10;      | false =&amp;gt; findM? f l" state_after="case cons.e_a&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m Bool&#10;a : α&#10;l : List α&#10;ih :&#10;  (do&#10;      let r ←&#10;        forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;              else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findM? f l&#10;⊢ (fun x =&amp;gt; do&#10;      let x ←&#10;        if x = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;          else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      let r ←&#10;        match x with&#10;          | ForInStep.done b =&amp;gt; pure b&#10;          | ForInStep.yield b =&amp;gt;&#10;            forIn l b fun a r =&amp;gt; do&#10;              let __do_lift ← f a&#10;              if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;                else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    fun __do_lift =&amp;gt;&#10;    match __do_lift with&#10;    | true =&amp;gt; pure (some a)&#10;    | false =&amp;gt; findM? f l" tactic="congr">
                                      <AtomNode start="(257, 5)" end="(257, 10)" leading="" trailing="&#10;    " val="congr"/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(258, 5)" end="(258, 29)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.e_a&#10;m : Type → Type u_1&#10;α : Type&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m Bool&#10;a : α&#10;l : List α&#10;ih :&#10;  (do&#10;      let r ←&#10;        forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt; do&#10;            let __do_lift ← f a&#10;            if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;              else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    findM? f l&#10;⊢ (fun x =&amp;gt; do&#10;      let x ←&#10;        if x = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;          else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      let r ←&#10;        match x with&#10;          | ForInStep.done b =&amp;gt; pure b&#10;          | ForInStep.yield b =&amp;gt;&#10;            forIn l b fun a r =&amp;gt; do&#10;              let __do_lift ← f a&#10;              if __do_lift = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;                else pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;      match r.fst with&#10;        | none =&amp;gt; pure none&#10;        | some a =&amp;gt; pure a) =&#10;    fun __do_lift =&amp;gt;&#10;    match __do_lift with&#10;    | true =&amp;gt; pure (some a)&#10;    | false =&amp;gt; findM? f l" state_after="no goals" tactic="ext1 (_|_) &amp;lt;;&amp;gt; simp [ih]">
                                      <OtherNode start="(258, 5)" end="(258, 15)" kind="Lean.Elab.Tactic.Ext.tacticExt1___">
                                        <AtomNode start="(258, 5)" end="(258, 9)" leading="" trailing=" " val="ext1"/>
                                        <NullNode start="(258, 10)" end="(258, 15)">
                                          <OtherNode start="(258, 10)" end="(258, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                            <OtherNode start="(258, 10)" end="(258, 15)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                              <AtomNode start="(258, 10)" end="(258, 11)" leading="" trailing="" val="("/>
                                              <OtherNode start="(258, 11)" end="(258, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(258, 11)" end="(258, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(258, 11)" end="(258, 14)">
                                                    <OtherNode start="(258, 11)" end="(258, 12)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                      <AtomNode start="(258, 11)" end="(258, 12)" leading="" trailing="" val="_"/>
                                                    </OtherNode>
                                                    <AtomNode start="(258, 12)" end="(258, 13)" leading="" trailing="" val="|"/>
                                                    <OtherNode start="(258, 13)" end="(258, 14)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                      <AtomNode start="(258, 13)" end="(258, 14)" leading="" trailing="" val="_"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(258, 14)" end="(258, 15)" leading="" trailing=" " val=")"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(258, 16)" end="(258, 19)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(258, 20)" end="(258, 29)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(258, 20)" end="(258, 24)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(258, 25)" end="(258, 29)">
                                          <AtomNode start="(258, 25)" end="(258, 26)" leading="" trailing="" val="["/>
                                          <NullNode start="(258, 26)" end="(258, 28)">
                                            <OtherNode start="(258, 26)" end="(258, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(258, 26)" end="(258, 28)" leading="" trailing="" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(258, 28)" end="(258, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(260, 1)" end="(262, 68)" name="findSome?_toArray" full_name="List.findSome?_toArray">
      <CommandDeclmodifiersNode start="(260, 1)" end="(260, 8)">
        <NullNode/>
        <NullNode start="(260, 1)" end="(260, 8)">
          <OtherNode start="(260, 1)" end="(260, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(260, 1)" end="(260, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(260, 3)" end="(260, 7)">
              <OtherNode start="(260, 3)" end="(260, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(260, 3)" end="(260, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(260, 3)" end="(260, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(260, 7)" end="(260, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(260, 9)" end="(262, 68)" name="findSome?_toArray" full_name="List.findSome?_toArray" _is_private_decl="False">
        <AtomNode start="(260, 9)" end="(260, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(260, 17)" end="(260, 34)">
          <IdentNode start="(260, 17)" end="(260, 34)" leading="" trailing=" " raw_val="findSome?_toArray" val="findSome?_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(260, 35)" end="(261, 42)">
          <NullNode start="(260, 35)" end="(260, 66)">
            <TermExplicitbinderNode start="(260, 35)" end="(260, 53)">
              <AtomNode start="(260, 35)" end="(260, 36)" leading="" trailing="" val="("/>
              <NullNode start="(260, 36)" end="(260, 37)">
                <IdentNode start="(260, 36)" end="(260, 37)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(260, 38)" end="(260, 52)">
                <AtomNode start="(260, 38)" end="(260, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(260, 40)" end="(260, 52)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(260, 40)" end="(260, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(260, 42)" end="(260, 43)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(260, 44)" end="(260, 52)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(260, 44)" end="(260, 50)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(260, 51)" end="(260, 52)">
                      <IdentNode start="(260, 51)" end="(260, 52)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(260, 52)" end="(260, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(260, 54)" end="(260, 66)">
              <AtomNode start="(260, 54)" end="(260, 55)" leading="" trailing="" val="("/>
              <NullNode start="(260, 55)" end="(260, 56)">
                <IdentNode start="(260, 55)" end="(260, 56)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(260, 57)" end="(260, 65)">
                <AtomNode start="(260, 57)" end="(260, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(260, 59)" end="(260, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(260, 59)" end="(260, 63)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(260, 64)" end="(260, 65)">
                    <IdentNode start="(260, 64)" end="(260, 65)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(260, 65)" end="(260, 66)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(260, 67)" end="(261, 42)">
            <AtomNode start="(260, 67)" end="(260, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(261, 5)" end="(261, 42)" kind="«term_=_»">
              <OtherNode start="(261, 5)" end="(261, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(261, 5)" end="(261, 24)" leading="" trailing=" " raw_val="l.toArray.findSome?" val="l.toArray.findSome?"/>
                <NullNode start="(261, 25)" end="(261, 26)">
                  <IdentNode start="(261, 25)" end="(261, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(261, 27)" end="(261, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(261, 29)" end="(261, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(261, 29)" end="(261, 40)" leading="" trailing=" " raw_val="l.findSome?" val="l.findSome?"/>
                <NullNode start="(261, 41)" end="(261, 42)">
                  <IdentNode start="(261, 41)" end="(261, 42)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(261, 43)" end="(262, 68)">
          <AtomNode start="(261, 43)" end="(261, 45)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(261, 46)" end="(262, 68)">
            <AtomNode start="(261, 46)" end="(261, 48)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(262, 3)" end="(262, 68)">
              <TacticTacticseq1IndentedNode start="(262, 3)" end="(262, 68)">
                <NullNode start="(262, 3)" end="(262, 68)">
                  <OtherNode start="(262, 3)" end="(262, 68)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;l : List α&#10;⊢ Array.findSome? f l.toArray = findSome? f l" state_after="no goals" tactic="rw [Array.findSome?, ← findSomeM?_id, findSomeM?_toArray, Id.run]">
                    <AtomNode start="(262, 3)" end="(262, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(262, 6)" end="(262, 68)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(262, 6)" end="(262, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(262, 7)" end="(262, 67)">
                        <OtherNode start="(262, 7)" end="(262, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(262, 7)" end="(262, 22)" leading="" trailing="" raw_val="Array.findSome?" val="Array.findSome?" full_name="Array.findSome?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(262, 22)" end="(262, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(262, 24)" end="(262, 39)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(262, 24)" end="(262, 25)">
                            <OtherNode start="(262, 24)" end="(262, 25)" kind="patternIgnore">
                              <OtherNode start="(262, 24)" end="(262, 25)" kind="token.«← »">
                                <AtomNode start="(262, 24)" end="(262, 25)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(262, 26)" end="(262, 39)" leading="" trailing="" raw_val="findSomeM?_id" val="findSomeM?_id" full_name="List.findSomeM?_id" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                        </OtherNode>
                        <AtomNode start="(262, 39)" end="(262, 40)" leading="" trailing=" " val=","/>
                        <OtherNode start="(262, 41)" end="(262, 59)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(262, 41)" end="(262, 59)" leading="" trailing="" raw_val="findSomeM?_toArray" val="findSomeM?_toArray" full_name="List.findSomeM?_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(216, 17)" def_end="(216, 35)"/>
                        </OtherNode>
                        <AtomNode start="(262, 59)" end="(262, 60)" leading="" trailing=" " val=","/>
                        <OtherNode start="(262, 61)" end="(262, 67)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(262, 61)" end="(262, 67)" leading="" trailing="" raw_val="Id.run" val="Id.run" full_name="Id.run" mod_name="Init.Control.Id" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Id.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(262, 67)" end="(262, 68)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(264, 1)" end="(272, 30)" name="find?_toArray" full_name="List.find?_toArray">
      <CommandDeclmodifiersNode start="(264, 1)" end="(264, 8)">
        <NullNode/>
        <NullNode start="(264, 1)" end="(264, 8)">
          <OtherNode start="(264, 1)" end="(264, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(264, 1)" end="(264, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(264, 3)" end="(264, 7)">
              <OtherNode start="(264, 3)" end="(264, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(264, 3)" end="(264, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(264, 3)" end="(264, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(264, 7)" end="(264, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(264, 9)" end="(272, 30)" name="find?_toArray" full_name="List.find?_toArray" _is_private_decl="False">
        <AtomNode start="(264, 9)" end="(264, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(264, 17)" end="(264, 30)">
          <IdentNode start="(264, 17)" end="(264, 30)" leading="" trailing=" " raw_val="find?_toArray" val="find?_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(264, 31)" end="(265, 34)">
          <NullNode start="(264, 31)" end="(264, 58)">
            <TermExplicitbinderNode start="(264, 31)" end="(264, 45)">
              <AtomNode start="(264, 31)" end="(264, 32)" leading="" trailing="" val="("/>
              <NullNode start="(264, 32)" end="(264, 33)">
                <IdentNode start="(264, 32)" end="(264, 33)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(264, 34)" end="(264, 44)">
                <AtomNode start="(264, 34)" end="(264, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(264, 36)" end="(264, 44)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(264, 36)" end="(264, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(264, 38)" end="(264, 39)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(264, 40)" end="(264, 44)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(264, 44)" end="(264, 45)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(264, 46)" end="(264, 58)">
              <AtomNode start="(264, 46)" end="(264, 47)" leading="" trailing="" val="("/>
              <NullNode start="(264, 47)" end="(264, 48)">
                <IdentNode start="(264, 47)" end="(264, 48)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(264, 49)" end="(264, 57)">
                <AtomNode start="(264, 49)" end="(264, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(264, 51)" end="(264, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(264, 51)" end="(264, 55)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(264, 56)" end="(264, 57)">
                    <IdentNode start="(264, 56)" end="(264, 57)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(264, 57)" end="(264, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(264, 59)" end="(265, 34)">
            <AtomNode start="(264, 59)" end="(264, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(265, 5)" end="(265, 34)" kind="«term_=_»">
              <OtherNode start="(265, 5)" end="(265, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(265, 5)" end="(265, 20)" leading="" trailing=" " raw_val="l.toArray.find?" val="l.toArray.find?"/>
                <NullNode start="(265, 21)" end="(265, 22)">
                  <IdentNode start="(265, 21)" end="(265, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(265, 23)" end="(265, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(265, 25)" end="(265, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(265, 25)" end="(265, 32)" leading="" trailing=" " raw_val="l.find?" val="l.find?"/>
                <NullNode start="(265, 33)" end="(265, 34)">
                  <IdentNode start="(265, 33)" end="(265, 34)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(265, 35)" end="(272, 30)">
          <AtomNode start="(265, 35)" end="(265, 37)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(265, 38)" end="(272, 30)">
            <AtomNode start="(265, 38)" end="(265, 40)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(266, 3)" end="(272, 30)">
              <TacticTacticseq1IndentedNode start="(266, 3)" end="(272, 30)">
                <NullNode start="(266, 3)" end="(272, 30)">
                  <OtherNode start="(266, 3)" end="(266, 19)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;f : α → Bool&#10;l : List α&#10;⊢ Array.find? f l.toArray = find? f l" state_after="α : Type u_1&#10;f : α → Bool&#10;l : List α&#10;⊢ (do&#10;        let r ←&#10;          forIn l.toArray ⟨none, PUnit.unit⟩ fun a r =&amp;gt;&#10;              let r := r.snd;&#10;              if f a = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;              else do&#10;                pure PUnit.unit&#10;                pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;        let __do_jp : PUnit → Id (Option α) := fun y =&amp;gt; pure none&#10;        match r.fst with&#10;          | none =&amp;gt; do&#10;            let y ← pure PUnit.unit&#10;            __do_jp y&#10;          | some a =&amp;gt; pure a).run =&#10;    find? f l" tactic="rw [Array.find?]">
                    <AtomNode start="(266, 3)" end="(266, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(266, 6)" end="(266, 19)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(266, 6)" end="(266, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(266, 7)" end="(266, 18)">
                        <OtherNode start="(266, 7)" end="(266, 18)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(266, 7)" end="(266, 18)" leading="" trailing="" raw_val="Array.find?" val="Array.find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(266, 18)" end="(266, 19)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(267, 3)" end="(267, 64)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;f : α → Bool&#10;l : List α&#10;⊢ (do&#10;        let r ←&#10;          forIn l.toArray ⟨none, PUnit.unit⟩ fun a r =&amp;gt;&#10;              let r := r.snd;&#10;              if f a = true then pure (ForInStep.done ⟨some (some a), PUnit.unit⟩)&#10;              else do&#10;                pure PUnit.unit&#10;                pure (ForInStep.yield ⟨none, PUnit.unit⟩)&#10;        let __do_jp : PUnit → Id (Option α) := fun y =&amp;gt; pure none&#10;        match r.fst with&#10;          | none =&amp;gt; do&#10;            let y ← pure PUnit.unit&#10;            __do_jp y&#10;          | some a =&amp;gt; pure a).run =&#10;    find? f l" state_after="α : Type u_1&#10;f : α → Bool&#10;l : List α&#10;⊢ (match&#10;      (forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt;&#10;          if f a = true then ForInStep.done ⟨some (some a), PUnit.unit⟩&#10;          else ForInStep.yield ⟨none, PUnit.unit⟩).fst with&#10;    | none =&amp;gt; none&#10;    | some a =&amp;gt; a) =&#10;    find? f l" tactic="simp only [Id.run, Id, Id.pure_eq, Id.bind_eq, forIn_toArray]">
                    <AtomNode start="(267, 3)" end="(267, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(267, 8)" end="(267, 12)">
                      <AtomNode start="(267, 8)" end="(267, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(267, 13)" end="(267, 64)">
                      <AtomNode start="(267, 13)" end="(267, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(267, 14)" end="(267, 63)">
                        <OtherNode start="(267, 14)" end="(267, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(267, 14)" end="(267, 20)" leading="" trailing="" raw_val="Id.run" val="Id.run" full_name="Id.run" mod_name="Init.Control.Id" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Id.lean"/>
                        </OtherNode>
                        <AtomNode start="(267, 20)" end="(267, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(267, 22)" end="(267, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(267, 22)" end="(267, 24)" leading="" trailing="" raw_val="Id" val="Id" full_name="Id" mod_name="Init.Control.Id" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Id.lean"/>
                        </OtherNode>
                        <AtomNode start="(267, 24)" end="(267, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(267, 26)" end="(267, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(267, 26)" end="(267, 36)" leading="" trailing="" raw_val="Id.pure_eq" val="Id.pure_eq" full_name="Id.pure_eq" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(267, 36)" end="(267, 37)" leading="" trailing=" " val=","/>
                        <OtherNode start="(267, 38)" end="(267, 48)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(267, 38)" end="(267, 48)" leading="" trailing="" raw_val="Id.bind_eq" val="Id.bind_eq" full_name="Id.bind_eq" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(267, 48)" end="(267, 49)" leading="" trailing=" " val=","/>
                        <OtherNode start="(267, 50)" end="(267, 63)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(267, 50)" end="(267, 63)" leading="" trailing="" raw_val="forIn_toArray" val="forIn_toArray" full_name="List.forIn_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(135, 17)" def_end="(135, 30)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(267, 63)" end="(267, 64)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(268, 3)" end="(272, 30)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;f : α → Bool&#10;l : List α&#10;⊢ (match&#10;      (forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt;&#10;          if f a = true then ForInStep.done ⟨some (some a), PUnit.unit⟩&#10;          else ForInStep.yield ⟨none, PUnit.unit⟩).fst with&#10;    | none =&amp;gt; none&#10;    | some a =&amp;gt; a) =&#10;    find? f l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt;&#10;  simp only [forIn_cons, Id.pure_eq, Id.bind_eq, find?]&#10;  by_cases f a &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(268, 3)" end="(268, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(268, 13)" end="(268, 14)">
                      <OtherNode start="(268, 13)" end="(268, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(268, 13)" end="(268, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(268, 15)" end="(272, 30)">
                      <OtherNode start="(268, 15)" end="(272, 30)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(268, 15)" end="(268, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(269, 3)" end="(272, 30)">
                          <OtherNode start="(269, 3)" end="(269, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(269, 3)" end="(269, 8)">
                              <OtherNode start="(269, 3)" end="(269, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(269, 3)" end="(269, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(269, 5)" end="(269, 8)">
                                  <NullNode/>
                                  <IdentNode start="(269, 5)" end="(269, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(269, 9)" end="(269, 16)">
                              <AtomNode start="(269, 9)" end="(269, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(269, 12)" end="(269, 16)">
                                <TacticTacticseq1IndentedNode start="(269, 12)" end="(269, 16)">
                                  <NullNode start="(269, 12)" end="(269, 16)">
                                    <OtherNode start="(269, 12)" end="(269, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;f : α → Bool&#10;⊢ (match&#10;      (forIn [] ⟨none, PUnit.unit⟩ fun a r =&amp;gt;&#10;          if f a = true then ForInStep.done ⟨some (some a), PUnit.unit⟩&#10;          else ForInStep.yield ⟨none, PUnit.unit⟩).fst with&#10;    | none =&amp;gt; none&#10;    | some a =&amp;gt; a) =&#10;    find? f []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(269, 12)" end="(269, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(270, 3)" end="(272, 30)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(270, 3)" end="(270, 16)">
                              <OtherNode start="(270, 3)" end="(270, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(270, 3)" end="(270, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(270, 5)" end="(270, 9)">
                                  <NullNode/>
                                  <IdentNode start="(270, 5)" end="(270, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(270, 10)" end="(270, 16)">
                                  <IdentNode start="(270, 10)" end="(270, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(270, 12)" end="(270, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(270, 14)" end="(270, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(270, 17)" end="(272, 30)">
                              <AtomNode start="(270, 17)" end="(270, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(271, 5)" end="(272, 30)">
                                <TacticTacticseq1IndentedNode start="(271, 5)" end="(272, 30)">
                                  <NullNode start="(271, 5)" end="(272, 30)">
                                    <OtherNode start="(271, 5)" end="(271, 58)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;f : α → Bool&#10;a : α&#10;l : List α&#10;ih :&#10;  (match&#10;      (forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt;&#10;          if f a = true then ForInStep.done ⟨some (some a), PUnit.unit⟩&#10;          else ForInStep.yield ⟨none, PUnit.unit⟩).fst with&#10;    | none =&amp;gt; none&#10;    | some a =&amp;gt; a) =&#10;    find? f l&#10;⊢ (match&#10;      (forIn (a :: l) ⟨none, PUnit.unit⟩ fun a r =&amp;gt;&#10;          if f a = true then ForInStep.done ⟨some (some a), PUnit.unit⟩&#10;          else ForInStep.yield ⟨none, PUnit.unit⟩).fst with&#10;    | none =&amp;gt; none&#10;    | some a =&amp;gt; a) =&#10;    find? f (a :: l)" state_after="case cons&#10;α : Type u_1&#10;f : α → Bool&#10;a : α&#10;l : List α&#10;ih :&#10;  (match&#10;      (forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt;&#10;          if f a = true then ForInStep.done ⟨some (some a), PUnit.unit⟩&#10;          else ForInStep.yield ⟨none, PUnit.unit⟩).fst with&#10;    | none =&amp;gt; none&#10;    | some a =&amp;gt; a) =&#10;    find? f l&#10;⊢ (match&#10;      (match if f a = true then ForInStep.done ⟨some (some a), PUnit.unit⟩ else ForInStep.yield ⟨none, PUnit.unit⟩ with&#10;        | ForInStep.done b =&amp;gt; b&#10;        | ForInStep.yield b =&amp;gt;&#10;          forIn l b fun a r =&amp;gt;&#10;            if f a = true then ForInStep.done ⟨some (some a), PUnit.unit⟩&#10;            else ForInStep.yield ⟨none, PUnit.unit⟩).fst with&#10;    | none =&amp;gt; none&#10;    | some a =&amp;gt; a) =&#10;    match f a with&#10;    | true =&amp;gt; some a&#10;    | false =&amp;gt; find? f l" tactic="simp only [forIn_cons, Id.pure_eq, Id.bind_eq, find?]">
                                      <AtomNode start="(271, 5)" end="(271, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(271, 10)" end="(271, 14)">
                                        <AtomNode start="(271, 10)" end="(271, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(271, 15)" end="(271, 58)">
                                        <AtomNode start="(271, 15)" end="(271, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(271, 16)" end="(271, 57)">
                                          <OtherNode start="(271, 16)" end="(271, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(271, 16)" end="(271, 26)" leading="" trailing="" raw_val="forIn_cons" val="forIn_cons" full_name="List.forIn_cons" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(271, 26)" end="(271, 27)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(271, 28)" end="(271, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(271, 28)" end="(271, 38)" leading="" trailing="" raw_val="Id.pure_eq" val="Id.pure_eq" full_name="Id.pure_eq" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(271, 38)" end="(271, 39)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(271, 40)" end="(271, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(271, 40)" end="(271, 50)" leading="" trailing="" raw_val="Id.bind_eq" val="Id.bind_eq" full_name="Id.bind_eq" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(271, 50)" end="(271, 51)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(271, 52)" end="(271, 57)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(271, 52)" end="(271, 57)" leading="" trailing="" raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(271, 57)" end="(271, 58)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(272, 5)" end="(272, 30)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;f : α → Bool&#10;a : α&#10;l : List α&#10;ih :&#10;  (match&#10;      (forIn l ⟨none, PUnit.unit⟩ fun a r =&amp;gt;&#10;          if f a = true then ForInStep.done ⟨some (some a), PUnit.unit⟩&#10;          else ForInStep.yield ⟨none, PUnit.unit⟩).fst with&#10;    | none =&amp;gt; none&#10;    | some a =&amp;gt; a) =&#10;    find? f l&#10;⊢ (match&#10;      (match if f a = true then ForInStep.done ⟨some (some a), PUnit.unit⟩ else ForInStep.yield ⟨none, PUnit.unit⟩ with&#10;        | ForInStep.done b =&amp;gt; b&#10;        | ForInStep.yield b =&amp;gt;&#10;          forIn l b fun a r =&amp;gt;&#10;            if f a = true then ForInStep.done ⟨some (some a), PUnit.unit⟩&#10;            else ForInStep.yield ⟨none, PUnit.unit⟩).fst with&#10;    | none =&amp;gt; none&#10;    | some a =&amp;gt; a) =&#10;    match f a with&#10;    | true =&amp;gt; some a&#10;    | false =&amp;gt; find? f l" state_after="no goals" tactic="by_cases f a &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(272, 5)" end="(272, 17)" kind="«tacticBy_cases_:_»">
                                        <AtomNode start="(272, 5)" end="(272, 13)" leading="" trailing=" " val="by_cases"/>
                                        <NullNode/>
                                        <OtherNode start="(272, 14)" end="(272, 17)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(272, 14)" end="(272, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                                          <NullNode start="(272, 16)" end="(272, 17)">
                                            <IdentNode start="(272, 16)" end="(272, 17)" leading="" trailing=" " raw_val="a" val="a"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(272, 18)" end="(272, 21)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(272, 22)" end="(272, 30)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(272, 22)" end="(272, 30)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(274, 1)" end="(298, 28)" name="findFinIdx?_loop_toArray" full_name="List.findFinIdx?_loop_toArray">
      <CommandDeclmodifiersNode start="(274, 1)" end="(274, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(274, 1)" end="(274, 8)">
          <CommandPrivateNode start="(274, 1)" end="(274, 8)">
            <AtomNode start="(274, 1)" end="(274, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(274, 9)" end="(298, 28)" name="findFinIdx?_loop_toArray" full_name="List.findFinIdx?_loop_toArray" _is_private_decl="True">
        <AtomNode start="(274, 9)" end="(274, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(274, 17)" end="(274, 41)">
          <IdentNode start="(274, 17)" end="(274, 41)" leading="" trailing=" " raw_val="findFinIdx?_loop_toArray" val="findFinIdx?_loop_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(274, 42)" end="(275, 74)">
          <NullNode start="(274, 42)" end="(274, 61)">
            <TermExplicitbinderNode start="(274, 42)" end="(274, 61)">
              <AtomNode start="(274, 42)" end="(274, 43)" leading="" trailing="" val="("/>
              <NullNode start="(274, 43)" end="(274, 44)">
                <IdentNode start="(274, 43)" end="(274, 44)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(274, 45)" end="(274, 60)">
                <AtomNode start="(274, 45)" end="(274, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(274, 47)" end="(274, 60)" kind="«term_=_»">
                  <IdentNode start="(274, 47)" end="(274, 49)" leading="" trailing=" " raw_val="l'" val="l'"/>
                  <AtomNode start="(274, 50)" end="(274, 51)" leading="" trailing=" " val="="/>
                  <OtherNode start="(274, 52)" end="(274, 60)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(274, 52)" end="(274, 58)" leading="" trailing=" " raw_val="l.drop" val="l.drop"/>
                    <NullNode start="(274, 59)" end="(274, 60)">
                      <IdentNode start="(274, 59)" end="(274, 60)" leading="" trailing="" raw_val="j" val="j"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(274, 60)" end="(274, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(274, 62)" end="(275, 74)">
            <AtomNode start="(274, 62)" end="(274, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(275, 5)" end="(275, 74)" kind="«term_=_»">
              <OtherNode start="(275, 5)" end="(275, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(275, 5)" end="(275, 27)" leading="" trailing=" " raw_val="Array.findFinIdx?.loop" val="Array.findFinIdx?.loop" full_name="Array.findFinIdx?.loop" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(275, 28)" end="(275, 41)">
                  <IdentNode start="(275, 28)" end="(275, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(275, 30)" end="(275, 39)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
                  <IdentNode start="(275, 40)" end="(275, 41)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(275, 42)" end="(275, 43)" leading="" trailing=" " val="="/>
              <OtherNode start="(275, 44)" end="(275, 74)" kind="Lean.Parser.Term.app">
                <IdentNode start="(275, 44)" end="(275, 63)" leading="" trailing=" " raw_val="List.findFinIdx?.go" val="List.findFinIdx?.go" full_name="List.findFinIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(275, 64)" end="(275, 74)">
                  <IdentNode start="(275, 64)" end="(275, 65)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(275, 66)" end="(275, 67)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(275, 68)" end="(275, 70)" leading="" trailing=" " raw_val="l'" val="l'"/>
                  <IdentNode start="(275, 71)" end="(275, 72)" leading="" trailing=" " raw_val="j" val="j"/>
                  <IdentNode start="(275, 73)" end="(275, 74)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(275, 75)" end="(298, 28)">
          <AtomNode start="(275, 75)" end="(275, 77)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(275, 78)" end="(297, 9)">
            <AtomNode start="(275, 78)" end="(275, 80)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(276, 3)" end="(297, 9)">
              <TacticTacticseq1IndentedNode start="(276, 3)" end="(297, 9)">
                <NullNode start="(276, 3)" end="(297, 9)">
                  <OtherNode start="(276, 3)" end="(276, 26)" kind="Lean.Parser.Tactic.unfold" state_before="α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;⊢ findFinIdx?.loop p l.toArray j = findFinIdx?.go p l l' j h" state_after="α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;⊢ (if h : j &amp;lt; l.toArray.size then if p l.toArray[j] = true then some ⟨j, h⟩ else findFinIdx?.loop p l.toArray (j + 1)&#10;    else none) =&#10;    findFinIdx?.go p l l' j h" tactic="unfold findFinIdx?.loop">
                    <AtomNode start="(276, 3)" end="(276, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(276, 10)" end="(276, 26)">
                      <IdentNode start="(276, 10)" end="(276, 26)" leading="" trailing="&#10;  " raw_val="findFinIdx?.loop" val="findFinIdx?.loop" full_name="Array.findFinIdx?.loop" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(277, 3)" end="(277, 24)" kind="Lean.Parser.Tactic.unfold" state_before="α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;⊢ (if h : j &amp;lt; l.toArray.size then if p l.toArray[j] = true then some ⟨j, h⟩ else findFinIdx?.loop p l.toArray (j + 1)&#10;    else none) =&#10;    findFinIdx?.go p l l' j h" state_after="α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;⊢ (if h : j &amp;lt; l.toArray.size then if p l.toArray[j] = true then some ⟨j, h⟩ else findFinIdx?.loop p l.toArray (j + 1)&#10;    else none) =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" tactic="unfold findFinIdx?.go">
                    <AtomNode start="(277, 3)" end="(277, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(277, 10)" end="(277, 24)">
                      <IdentNode start="(277, 10)" end="(277, 24)" leading="" trailing="&#10;  " raw_val="findFinIdx?.go" val="findFinIdx?.go" full_name="List.findFinIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(278, 3)" end="(278, 24)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;⊢ (if h : j &amp;lt; l.toArray.size then if p l.toArray[j] = true then some ⟨j, h⟩ else findFinIdx?.loop p l.toArray (j + 1)&#10;    else none) =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" state_after="case isTrue&#10;α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;h' : j &amp;lt; l.toArray.size&#10;⊢ (if p l.toArray[j] = true then some ⟨j, h'⟩ else findFinIdx?.loop p l.toArray (j + 1)) =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯&#10;&#10;case isFalse&#10;α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;h' : ¬j &amp;lt; l.toArray.size&#10;⊢ none =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" tactic="split &amp;lt;;&amp;gt; rename_i h'">
                    <OtherNode start="(278, 3)" end="(278, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(278, 3)" end="(278, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(278, 9)" end="(278, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(278, 13)" end="(278, 24)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(278, 13)" end="(278, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(278, 22)" end="(278, 24)">
                        <LeanBinderidentNode start="(278, 22)" end="(278, 24)">
                          <IdentNode start="(278, 22)" end="(278, 24)" leading="" trailing="&#10;  " raw_val="h'" val="h'"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(279, 3)" end="(294, 55)" kind="Lean.cdot" state_before="case isTrue&#10;α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;h' : j &amp;lt; l.toArray.size&#10;⊢ (if p l.toArray[j] = true then some ⟨j, h'⟩ else findFinIdx?.loop p l.toArray (j + 1)) =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯&#10;&#10;case isFalse&#10;α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;h' : ¬j &amp;lt; l.toArray.size&#10;⊢ none =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" state_after="case isFalse&#10;α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;h' : ¬j &amp;lt; l.toArray.size&#10;⊢ none =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" tactic="· cases l' with&#10;  | nil =&amp;gt;&#10;    simp at h h'&#10;    omega&#10;  | cons a l' =&amp;gt;&#10;    have : l[j] = a := by&#10;      rw [drop_eq_getElem_cons] at w&#10;      simp only [cons.injEq] at w&#10;      exact w.1.symm&#10;    simp only [getElem_toArray, this]&#10;    split&#10;    · rfl&#10;    · simp only [length_cons] at h&#10;      have : l.length - (j + 1) &amp;lt; l.length - j := by omega&#10;      rw [findFinIdx?_loop_toArray]&#10;      rw [drop_add_one_eq_tail_drop, ← w, tail_cons]">
                    <OtherNode start="(279, 3)" end="(279, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(279, 3)" end="(279, 4)" kind="patternIgnore">
                        <OtherNode start="(279, 3)" end="(279, 4)" kind="token.«· »">
                          <AtomNode start="(279, 3)" end="(279, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(279, 5)" end="(294, 55)">
                      <TacticTacticseq1IndentedNode start="(279, 5)" end="(294, 55)">
                        <NullNode start="(279, 5)" end="(294, 55)">
                          <OtherNode start="(279, 5)" end="(294, 55)" kind="Lean.Parser.Tactic.cases" state_before="case isTrue&#10;α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;h' : j &amp;lt; l.toArray.size&#10;⊢ (if p l.toArray[j] = true then some ⟨j, h'⟩ else findFinIdx?.loop p l.toArray (j + 1)) =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" state_after="no goals" tactic="cases l' with&#10;| nil =&amp;gt;&#10;  simp at h h'&#10;  omega&#10;| cons a l' =&amp;gt;&#10;  have : l[j] = a := by&#10;    rw [drop_eq_getElem_cons] at w&#10;    simp only [cons.injEq] at w&#10;    exact w.1.symm&#10;  simp only [getElem_toArray, this]&#10;  split&#10;  · rfl&#10;  · simp only [length_cons] at h&#10;    have : l.length - (j + 1) &amp;lt; l.length - j := by omega&#10;    rw [findFinIdx?_loop_toArray]&#10;    rw [drop_add_one_eq_tail_drop, ← w, tail_cons]">
                            <AtomNode start="(279, 5)" end="(279, 10)" leading="" trailing=" " val="cases"/>
                            <NullNode start="(279, 11)" end="(279, 13)">
                              <OtherNode start="(279, 11)" end="(279, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                <NullNode/>
                                <IdentNode start="(279, 11)" end="(279, 13)" leading="" trailing=" " raw_val="l'" val="l'"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(279, 14)" end="(294, 55)">
                              <OtherNode start="(279, 14)" end="(294, 55)" kind="Lean.Parser.Tactic.inductionAlts">
                                <AtomNode start="(279, 14)" end="(279, 18)" leading="" trailing="&#10;    " val="with"/>
                                <NullNode/>
                                <NullNode start="(280, 5)" end="(294, 55)">
                                  <OtherNode start="(280, 5)" end="(282, 12)" kind="Lean.Parser.Tactic.inductionAlt">
                                    <NullNode start="(280, 5)" end="(280, 10)">
                                      <OtherNode start="(280, 5)" end="(280, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                        <AtomNode start="(280, 5)" end="(280, 6)" leading="" trailing=" " val="|"/>
                                        <GroupNode start="(280, 7)" end="(280, 10)">
                                          <NullNode/>
                                          <IdentNode start="(280, 7)" end="(280, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        </GroupNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode start="(280, 11)" end="(282, 12)">
                                      <AtomNode start="(280, 11)" end="(280, 13)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                      <TacticTacticseqNode start="(281, 7)" end="(282, 12)">
                                        <TacticTacticseq1IndentedNode start="(281, 7)" end="(282, 12)">
                                          <NullNode start="(281, 7)" end="(282, 12)">
                                            <OtherNode start="(281, 7)" end="(281, 19)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.nil&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;h : [].length + j = l.length&#10;w : [] = drop j l&#10;⊢ (if p l.toArray[j] = true then some ⟨j, h'⟩ else findFinIdx?.loop p l.toArray (j + 1)) =&#10;    match [], j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" state_after="case isTrue.nil&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h'✝ : j &amp;lt; l.toArray.size&#10;h✝ : [].length + j = l.length&#10;w : [] = drop j l&#10;h : j = l.length&#10;h' : j &amp;lt; l.length&#10;⊢ (if p l.toArray[j] = true then some ⟨j, h'✝⟩ else findFinIdx?.loop p l.toArray (j + 1)) =&#10;    match [], j, h✝ with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" tactic="simp at h h'">
                                              <AtomNode start="(281, 7)" end="(281, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(281, 12)" end="(281, 19)">
                                                <OtherNode start="(281, 12)" end="(281, 19)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(281, 12)" end="(281, 14)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(281, 15)" end="(281, 19)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(281, 15)" end="(281, 19)">
                                                      <IdentNode start="(281, 15)" end="(281, 16)" leading="" trailing=" " raw_val="h" val="h"/>
                                                      <IdentNode start="(281, 17)" end="(281, 19)" leading="" trailing="&#10;      " raw_val="h'" val="h'"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(282, 7)" end="(282, 12)" kind="Lean.Parser.Tactic.omega" state_before="case isTrue.nil&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h'✝ : j &amp;lt; l.toArray.size&#10;h✝ : [].length + j = l.length&#10;w : [] = drop j l&#10;h : j = l.length&#10;h' : j &amp;lt; l.length&#10;⊢ (if p l.toArray[j] = true then some ⟨j, h'✝⟩ else findFinIdx?.loop p l.toArray (j + 1)) =&#10;    match [], j, h✝ with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" state_after="no goals" tactic="omega">
                                              <AtomNode start="(282, 7)" end="(282, 12)" leading="" trailing="&#10;    " val="omega"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </NullNode>
                                  </OtherNode>
                                  <OtherNode start="(283, 5)" end="(294, 55)" kind="Lean.Parser.Tactic.inductionAlt">
                                    <NullNode start="(283, 5)" end="(283, 16)">
                                      <OtherNode start="(283, 5)" end="(283, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                        <AtomNode start="(283, 5)" end="(283, 6)" leading="" trailing=" " val="|"/>
                                        <GroupNode start="(283, 7)" end="(283, 11)">
                                          <NullNode/>
                                          <IdentNode start="(283, 7)" end="(283, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        </GroupNode>
                                        <NullNode start="(283, 12)" end="(283, 16)">
                                          <IdentNode start="(283, 12)" end="(283, 13)" leading="" trailing=" " raw_val="a" val="a"/>
                                          <IdentNode start="(283, 14)" end="(283, 16)" leading="" trailing=" " raw_val="l'" val="l'"/>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode start="(283, 17)" end="(294, 55)">
                                      <AtomNode start="(283, 17)" end="(283, 19)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                      <TacticTacticseqNode start="(284, 7)" end="(294, 55)">
                                        <TacticTacticseq1IndentedNode start="(284, 7)" end="(294, 55)">
                                          <NullNode start="(284, 7)" end="(294, 55)">
                                            <OtherNode start="(284, 7)" end="(287, 23)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case isTrue.cons&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;⊢ (if p l.toArray[j] = true then some ⟨j, h'⟩ else findFinIdx?.loop p l.toArray (j + 1)) =&#10;    match a :: l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" state_after="case isTrue.cons&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;⊢ (if p l.toArray[j] = true then some ⟨j, h'⟩ else findFinIdx?.loop p l.toArray (j + 1)) =&#10;    match a :: l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" tactic="have : l[j] = a := by&#10;  rw [drop_eq_getElem_cons] at w&#10;  simp only [cons.injEq] at w&#10;  exact w.1.symm">
                                              <AtomNode start="(284, 7)" end="(284, 11)" leading="" trailing=" " val="have"/>
                                              <OtherNode start="(284, 12)" end="(287, 23)" kind="Lean.Parser.Term.haveDecl">
                                                <OtherNode start="(284, 12)" end="(287, 23)" kind="Lean.Parser.Term.haveIdDecl">
                                                  <OtherNode start="(284, 12)" end="(284, 12)" kind="Lean.Parser.Term.haveId">
                                                    <OtherNode start="(284, 12)" end="(284, 12)" kind="hygieneInfo">
                                                      <IdentNode start="(284, 12)" end="(284, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode start="(284, 12)" end="(284, 22)">
                                                    <TermTypespecNode start="(284, 12)" end="(284, 22)">
                                                      <AtomNode start="(284, 12)" end="(284, 13)" leading="" trailing=" " val=":"/>
                                                      <OtherNode start="(284, 14)" end="(284, 22)" kind="«term_=_»">
                                                        <OtherNode start="(284, 14)" end="(284, 18)" kind="«term__[_]»">
                                                          <IdentNode start="(284, 14)" end="(284, 15)" leading="" trailing="" raw_val="l" val="l"/>
                                                          <AtomNode start="(284, 15)" end="(284, 16)" leading="" trailing="" val="["/>
                                                          <IdentNode start="(284, 16)" end="(284, 17)" leading="" trailing="" raw_val="j" val="j"/>
                                                          <AtomNode start="(284, 17)" end="(284, 18)" leading="" trailing=" " val="]"/>
                                                        </OtherNode>
                                                        <AtomNode start="(284, 19)" end="(284, 20)" leading="" trailing=" " val="="/>
                                                        <IdentNode start="(284, 21)" end="(284, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                                                      </OtherNode>
                                                    </TermTypespecNode>
                                                  </NullNode>
                                                  <AtomNode start="(284, 23)" end="(284, 25)" leading="" trailing=" " val=":="/>
                                                  <TermBytacticNode start="(284, 26)" end="(287, 23)">
                                                    <AtomNode start="(284, 26)" end="(284, 28)" leading="" trailing="&#10;        " val="by"/>
                                                    <TacticTacticseqNode start="(285, 9)" end="(287, 23)">
                                                      <TacticTacticseq1IndentedNode start="(285, 9)" end="(287, 23)">
                                                        <NullNode start="(285, 9)" end="(287, 23)">
                                                          <OtherNode start="(285, 9)" end="(285, 39)" kind="Lean.Parser.Tactic.rwSeq" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;⊢ l[j] = a" state_after="α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w✝ : a :: l' = drop j l&#10;w : a :: l' = l[j] :: drop (j + 1) l&#10;⊢ l[j] = a&#10;&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;⊢ j &amp;lt; l.length" tactic="rw [drop_eq_getElem_cons] at w">
                                                            <AtomNode start="(285, 9)" end="(285, 11)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(285, 12)" end="(285, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(285, 12)" end="(285, 13)" leading="" trailing="" val="["/>
                                                            <NullNode start="(285, 13)" end="(285, 33)">
                                                            <OtherNode start="(285, 13)" end="(285, 33)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(285, 13)" end="(285, 33)" leading="" trailing="" raw_val="drop_eq_getElem_cons" val="drop_eq_getElem_cons" full_name="List.drop_eq_getElem_cons" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(285, 33)" end="(285, 34)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            <NullNode start="(285, 35)" end="(285, 39)">
                                                            <OtherNode start="(285, 35)" end="(285, 39)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(285, 35)" end="(285, 37)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(285, 38)" end="(285, 39)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(285, 38)" end="(285, 39)">
                                                            <IdentNode start="(285, 38)" end="(285, 39)" leading="" trailing="&#10;        " raw_val="w" val="w"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <OtherNode start="(286, 9)" end="(286, 36)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w✝ : a :: l' = drop j l&#10;w : a :: l' = l[j] :: drop (j + 1) l&#10;⊢ l[j] = a&#10;&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;⊢ j &amp;lt; l.length" state_after="α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w✝ : a :: l' = drop j l&#10;w : a = l[j] ∧ l' = drop (j + 1) l&#10;⊢ l[j] = a&#10;&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;⊢ j &amp;lt; l.length" tactic="simp only [cons.injEq] at w">
                                                            <AtomNode start="(286, 9)" end="(286, 13)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(286, 14)" end="(286, 18)">
                                                            <AtomNode start="(286, 14)" end="(286, 18)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(286, 19)" end="(286, 31)">
                                                            <AtomNode start="(286, 19)" end="(286, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(286, 20)" end="(286, 30)">
                                                            <OtherNode start="(286, 20)" end="(286, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(286, 20)" end="(286, 30)" leading="" trailing="" raw_val="cons.injEq" val="cons.injEq" full_name="List.cons.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(286, 30)" end="(286, 31)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(286, 32)" end="(286, 36)">
                                                            <OtherNode start="(286, 32)" end="(286, 36)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(286, 32)" end="(286, 34)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(286, 35)" end="(286, 36)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(286, 35)" end="(286, 36)">
                                                            <IdentNode start="(286, 35)" end="(286, 36)" leading="" trailing="&#10;        " raw_val="w" val="w"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <OtherNode start="(287, 9)" end="(287, 23)" kind="Lean.Parser.Tactic.exact" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w✝ : a :: l' = drop j l&#10;w : a = l[j] ∧ l' = drop (j + 1) l&#10;⊢ l[j] = a&#10;&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;⊢ j &amp;lt; l.length" state_after="no goals" tactic="exact w.1.symm">
                                                            <AtomNode start="(287, 9)" end="(287, 14)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(287, 15)" end="(287, 23)" kind="Lean.Parser.Term.proj">
                                                            <OtherNode start="(287, 15)" end="(287, 18)" kind="Lean.Parser.Term.proj">
                                                            <IdentNode start="(287, 15)" end="(287, 16)" leading="" trailing="" raw_val="w" val="w"/>
                                                            <AtomNode start="(287, 16)" end="(287, 17)" leading="" trailing="" val="."/>
                                                            <OtherNode start="(287, 17)" end="(287, 18)" kind="fieldIdx">
                                                            <AtomNode start="(287, 17)" end="(287, 18)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(287, 18)" end="(287, 19)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(287, 19)" end="(287, 23)" leading="" trailing="&#10;      " raw_val="symm" val="symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </TermBytacticNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(288, 7)" end="(288, 40)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.cons&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;⊢ (if p l.toArray[j] = true then some ⟨j, h'⟩ else findFinIdx?.loop p l.toArray (j + 1)) =&#10;    match a :: l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" state_after="case isTrue.cons&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;⊢ (if p a = true then some ⟨j, h'⟩ else findFinIdx?.loop p l.toArray (j + 1)) =&#10;    if p a = true then some ⟨j, ⋯⟩ else findFinIdx?.go p l l' (j + 1) ⋯" tactic="simp only [getElem_toArray, this]">
                                              <AtomNode start="(288, 7)" end="(288, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(288, 12)" end="(288, 16)">
                                                <AtomNode start="(288, 12)" end="(288, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(288, 17)" end="(288, 40)">
                                                <AtomNode start="(288, 17)" end="(288, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(288, 18)" end="(288, 39)">
                                                  <OtherNode start="(288, 18)" end="(288, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(288, 18)" end="(288, 33)" leading="" trailing="" raw_val="getElem_toArray" val="getElem_toArray" full_name="List.getElem_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(288, 33)" end="(288, 34)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(288, 35)" end="(288, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(288, 35)" end="(288, 39)" leading="" trailing="" raw_val="this" val="this"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(288, 39)" end="(288, 40)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(289, 7)" end="(289, 12)" kind="Lean.Parser.Tactic.split" state_before="case isTrue.cons&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;⊢ (if p a = true then some ⟨j, h'⟩ else findFinIdx?.loop p l.toArray (j + 1)) =&#10;    if p a = true then some ⟨j, ⋯⟩ else findFinIdx?.go p l l' (j + 1) ⋯" state_after="case isTrue.cons.isTrue&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;h✝ : p a = true&#10;⊢ some ⟨j, h'⟩ = some ⟨j, ⋯⟩&#10;&#10;case isTrue.cons.isFalse&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;h✝ : ¬p a = true&#10;⊢ findFinIdx?.loop p l.toArray (j + 1) = findFinIdx?.go p l l' (j + 1) ⋯" tactic="split">
                                              <AtomNode start="(289, 7)" end="(289, 12)" leading="" trailing="&#10;      " val="split"/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(290, 7)" end="(290, 12)" kind="Lean.cdot" state_before="case isTrue.cons.isTrue&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;h✝ : p a = true&#10;⊢ some ⟨j, h'⟩ = some ⟨j, ⋯⟩&#10;&#10;case isTrue.cons.isFalse&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;h✝ : ¬p a = true&#10;⊢ findFinIdx?.loop p l.toArray (j + 1) = findFinIdx?.go p l l' (j + 1) ⋯" state_after="case isTrue.cons.isFalse&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;h✝ : ¬p a = true&#10;⊢ findFinIdx?.loop p l.toArray (j + 1) = findFinIdx?.go p l l' (j + 1) ⋯" tactic="· rfl">
                                              <OtherNode start="(290, 7)" end="(290, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(290, 7)" end="(290, 8)" kind="patternIgnore">
                                                  <OtherNode start="(290, 7)" end="(290, 8)" kind="token.«· »">
                                                    <AtomNode start="(290, 7)" end="(290, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(290, 9)" end="(290, 12)">
                                                <TacticTacticseq1IndentedNode start="(290, 9)" end="(290, 12)">
                                                  <NullNode start="(290, 9)" end="(290, 12)">
                                                    <OtherNode start="(290, 9)" end="(290, 12)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case isTrue.cons.isTrue&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;h✝ : p a = true&#10;⊢ some ⟨j, h'⟩ = some ⟨j, ⋯⟩" state_after="no goals" tactic="rfl">
                                                      <AtomNode start="(290, 9)" end="(290, 12)" leading="" trailing="&#10;      " val="rfl"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(291, 7)" end="(294, 55)" kind="Lean.cdot" state_before="case isTrue.cons.isFalse&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;h✝ : ¬p a = true&#10;⊢ findFinIdx?.loop p l.toArray (j + 1) = findFinIdx?.go p l l' (j + 1) ⋯" state_after="no goals" tactic="· simp only [length_cons] at h&#10;  have : l.length - (j + 1) &amp;lt; l.length - j := by omega&#10;  rw [findFinIdx?_loop_toArray]&#10;  rw [drop_add_one_eq_tail_drop, ← w, tail_cons]">
                                              <OtherNode start="(291, 7)" end="(291, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(291, 7)" end="(291, 8)" kind="patternIgnore">
                                                  <OtherNode start="(291, 7)" end="(291, 8)" kind="token.«· »">
                                                    <AtomNode start="(291, 7)" end="(291, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(291, 9)" end="(294, 55)">
                                                <TacticTacticseq1IndentedNode start="(291, 9)" end="(294, 55)">
                                                  <NullNode start="(291, 9)" end="(294, 55)">
                                                    <OtherNode start="(291, 9)" end="(291, 37)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.cons.isFalse&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : (a :: l').length + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;h✝ : ¬p a = true&#10;⊢ findFinIdx?.loop p l.toArray (j + 1) = findFinIdx?.go p l l' (j + 1) ⋯" state_after="case isTrue.cons.isFalse&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : l'.length + 1 + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;h✝ : ¬p a = true&#10;⊢ findFinIdx?.loop p l.toArray (j + 1) = findFinIdx?.go p l l' (j + 1) ⋯" tactic="simp only [length_cons] at h">
                                                      <AtomNode start="(291, 9)" end="(291, 13)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode start="(291, 14)" end="(291, 18)">
                                                        <AtomNode start="(291, 14)" end="(291, 18)" leading="" trailing=" " val="only"/>
                                                      </NullNode>
                                                      <NullNode start="(291, 19)" end="(291, 32)">
                                                        <AtomNode start="(291, 19)" end="(291, 20)" leading="" trailing="" val="["/>
                                                        <NullNode start="(291, 20)" end="(291, 31)">
                                                          <OtherNode start="(291, 20)" end="(291, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(291, 20)" end="(291, 31)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(291, 31)" end="(291, 32)" leading="" trailing=" " val="]"/>
                                                      </NullNode>
                                                      <NullNode start="(291, 33)" end="(291, 37)">
                                                        <OtherNode start="(291, 33)" end="(291, 37)" kind="Lean.Parser.Tactic.location">
                                                          <AtomNode start="(291, 33)" end="(291, 35)" leading="" trailing=" " val="at"/>
                                                          <OtherNode start="(291, 36)" end="(291, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(291, 36)" end="(291, 37)">
                                                            <IdentNode start="(291, 36)" end="(291, 37)" leading="" trailing="&#10;        " raw_val="h" val="h"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(292, 9)" end="(292, 61)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case isTrue.cons.isFalse&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : l'.length + 1 + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;h✝ : ¬p a = true&#10;⊢ findFinIdx?.loop p l.toArray (j + 1) = findFinIdx?.go p l l' (j + 1) ⋯" state_after="case isTrue.cons.isFalse&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : l'.length + 1 + j = l.length&#10;w : a :: l' = drop j l&#10;this✝ : l[j] = a&#10;h✝ : ¬p a = true&#10;this : l.length - (j + 1) &amp;lt; l.length - j&#10;⊢ findFinIdx?.loop p l.toArray (j + 1) = findFinIdx?.go p l l' (j + 1) ⋯" tactic="have : l.length - (j + 1) &amp;lt; l.length - j := by omega">
                                                      <AtomNode start="(292, 9)" end="(292, 13)" leading="" trailing=" " val="have"/>
                                                      <OtherNode start="(292, 14)" end="(292, 61)" kind="Lean.Parser.Term.haveDecl">
                                                        <OtherNode start="(292, 14)" end="(292, 61)" kind="Lean.Parser.Term.haveIdDecl">
                                                          <OtherNode start="(292, 14)" end="(292, 14)" kind="Lean.Parser.Term.haveId">
                                                            <OtherNode start="(292, 14)" end="(292, 14)" kind="hygieneInfo">
                                                            <IdentNode start="(292, 14)" end="(292, 14)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode start="(292, 14)" end="(292, 49)">
                                                            <TermTypespecNode start="(292, 14)" end="(292, 49)">
                                                            <AtomNode start="(292, 14)" end="(292, 15)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(292, 16)" end="(292, 49)" kind="«term_&amp;lt;_»">
                                                            <OtherNode start="(292, 16)" end="(292, 34)" kind="«term_-_»">
                                                            <IdentNode start="(292, 16)" end="(292, 24)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                                            <AtomNode start="(292, 25)" end="(292, 26)" leading="" trailing=" " val="-"/>
                                                            <OtherNode start="(292, 27)" end="(292, 34)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(292, 27)" end="(292, 28)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(292, 28)" end="(292, 33)" kind="«term_+_»">
                                                            <IdentNode start="(292, 28)" end="(292, 29)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            <AtomNode start="(292, 30)" end="(292, 31)" leading="" trailing=" " val="+"/>
                                                            <OtherNode start="(292, 32)" end="(292, 33)" kind="num">
                                                            <AtomNode start="(292, 32)" end="(292, 33)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(292, 33)" end="(292, 34)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(292, 35)" end="(292, 36)" leading="" trailing=" " val="&amp;lt;"/>
                                                            <OtherNode start="(292, 37)" end="(292, 49)" kind="«term_-_»">
                                                            <IdentNode start="(292, 37)" end="(292, 45)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                                            <AtomNode start="(292, 46)" end="(292, 47)" leading="" trailing=" " val="-"/>
                                                            <IdentNode start="(292, 48)" end="(292, 49)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                          </NullNode>
                                                          <AtomNode start="(292, 50)" end="(292, 52)" leading="" trailing=" " val=":="/>
                                                          <TermBytacticNode start="(292, 53)" end="(292, 61)">
                                                            <AtomNode start="(292, 53)" end="(292, 55)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(292, 56)" end="(292, 61)">
                                                            <TacticTacticseq1IndentedNode start="(292, 56)" end="(292, 61)">
                                                            <NullNode start="(292, 56)" end="(292, 61)">
                                                            <OtherNode start="(292, 56)" end="(292, 61)" kind="Lean.Parser.Tactic.omega" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : l'.length + 1 + j = l.length&#10;w : a :: l' = drop j l&#10;this : l[j] = a&#10;h✝ : ¬p a = true&#10;⊢ l.length - (j + 1) &amp;lt; l.length - j" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(292, 56)" end="(292, 61)" leading="" trailing="&#10;        " val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </TermBytacticNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(293, 9)" end="(293, 38)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue.cons.isFalse&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : l'.length + 1 + j = l.length&#10;w : a :: l' = drop j l&#10;this✝ : l[j] = a&#10;h✝ : ¬p a = true&#10;this : l.length - (j + 1) &amp;lt; l.length - j&#10;⊢ findFinIdx?.loop p l.toArray (j + 1) = findFinIdx?.go p l l' (j + 1) ⋯" state_after="case isTrue.cons.isFalse&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : l'.length + 1 + j = l.length&#10;w : a :: l' = drop j l&#10;this✝ : l[j] = a&#10;h✝ : ¬p a = true&#10;this : l.length - (j + 1) &amp;lt; l.length - j&#10;⊢ l' = drop (j + 1) l" tactic="rw [findFinIdx?_loop_toArray]">
                                                      <AtomNode start="(293, 9)" end="(293, 11)" leading="" trailing=" " val="rw"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <OtherNode start="(293, 12)" end="(293, 38)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                        <AtomNode start="(293, 12)" end="(293, 13)" leading="" trailing="" val="["/>
                                                        <NullNode start="(293, 13)" end="(293, 37)">
                                                          <OtherNode start="(293, 13)" end="(293, 37)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(293, 13)" end="(293, 37)" leading="" trailing="" raw_val="findFinIdx?_loop_toArray" val="findFinIdx?_loop_toArray" full_name="PSigma.Lex.left" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(293, 37)" end="(293, 38)" leading="" trailing="&#10;        " val="]"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(294, 9)" end="(294, 55)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue.cons.isFalse&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : j &amp;lt; l.toArray.size&#10;a : α✝&#10;l' : List α✝&#10;h : l'.length + 1 + j = l.length&#10;w : a :: l' = drop j l&#10;this✝ : l[j] = a&#10;h✝ : ¬p a = true&#10;this : l.length - (j + 1) &amp;lt; l.length - j&#10;⊢ l' = drop (j + 1) l" state_after="no goals" tactic="rw [drop_add_one_eq_tail_drop, ← w, tail_cons]">
                                                      <AtomNode start="(294, 9)" end="(294, 11)" leading="" trailing=" " val="rw"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <OtherNode start="(294, 12)" end="(294, 55)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                        <AtomNode start="(294, 12)" end="(294, 13)" leading="" trailing="" val="["/>
                                                        <NullNode start="(294, 13)" end="(294, 54)">
                                                          <OtherNode start="(294, 13)" end="(294, 38)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(294, 13)" end="(294, 38)" leading="" trailing="" raw_val="drop_add_one_eq_tail_drop" val="drop_add_one_eq_tail_drop" full_name="List.drop_add_one_eq_tail_drop" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                          </OtherNode>
                                                          <AtomNode start="(294, 38)" end="(294, 39)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(294, 40)" end="(294, 43)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(294, 40)" end="(294, 41)">
                                                            <OtherNode start="(294, 40)" end="(294, 41)" kind="patternIgnore">
                                                            <OtherNode start="(294, 40)" end="(294, 41)" kind="token.«← »">
                                                            <AtomNode start="(294, 40)" end="(294, 41)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(294, 42)" end="(294, 43)" leading="" trailing="" raw_val="w" val="w"/>
                                                          </OtherNode>
                                                          <AtomNode start="(294, 43)" end="(294, 44)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(294, 45)" end="(294, 54)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(294, 45)" end="(294, 54)" leading="" trailing="" raw_val="tail_cons" val="tail_cons" full_name="List.tail_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(294, 54)" end="(294, 55)" leading="" trailing="&#10;  " val="]"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(295, 3)" end="(297, 9)" kind="Lean.cdot" state_before="case isFalse&#10;α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;h' : ¬j &amp;lt; l.toArray.size&#10;⊢ none =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" state_after="no goals" tactic="· have : l' = [] := by simp_all&#10;  subst this&#10;  simp">
                    <OtherNode start="(295, 3)" end="(295, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(295, 3)" end="(295, 4)" kind="patternIgnore">
                        <OtherNode start="(295, 3)" end="(295, 4)" kind="token.«· »">
                          <AtomNode start="(295, 3)" end="(295, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(295, 5)" end="(297, 9)">
                      <TacticTacticseq1IndentedNode start="(295, 5)" end="(297, 9)">
                        <NullNode start="(295, 5)" end="(297, 9)">
                          <OtherNode start="(295, 5)" end="(295, 34)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case isFalse&#10;α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;h' : ¬j &amp;lt; l.toArray.size&#10;⊢ none =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" state_after="case isFalse&#10;α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;h' : ¬j &amp;lt; l.toArray.size&#10;this : l' = []&#10;⊢ none =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" tactic="have : l' = [] := by simp_all">
                            <AtomNode start="(295, 5)" end="(295, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(295, 10)" end="(295, 34)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(295, 10)" end="(295, 34)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(295, 10)" end="(295, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(295, 10)" end="(295, 10)" kind="hygieneInfo">
                                    <IdentNode start="(295, 10)" end="(295, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(295, 10)" end="(295, 19)">
                                  <TermTypespecNode start="(295, 10)" end="(295, 19)">
                                    <AtomNode start="(295, 10)" end="(295, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(295, 12)" end="(295, 19)" kind="«term_=_»">
                                      <IdentNode start="(295, 12)" end="(295, 14)" leading="" trailing=" " raw_val="l'" val="l'"/>
                                      <AtomNode start="(295, 15)" end="(295, 16)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(295, 17)" end="(295, 19)" kind="«term[_]»">
                                        <AtomNode start="(295, 17)" end="(295, 18)" leading="" trailing="" val="["/>
                                        <NullNode/>
                                        <AtomNode start="(295, 18)" end="(295, 19)" leading="" trailing=" " val="]"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(295, 20)" end="(295, 22)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(295, 23)" end="(295, 34)">
                                  <AtomNode start="(295, 23)" end="(295, 25)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(295, 26)" end="(295, 34)">
                                    <TacticTacticseq1IndentedNode start="(295, 26)" end="(295, 34)">
                                      <NullNode start="(295, 26)" end="(295, 34)">
                                        <OtherNode start="(295, 26)" end="(295, 34)" kind="Lean.Parser.Tactic.simpAll" state_before="α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;h' : ¬j &amp;lt; l.toArray.size&#10;⊢ l' = []" state_after="no goals" tactic="simp_all">
                                          <AtomNode start="(295, 26)" end="(295, 34)" leading="" trailing="&#10;    " val="simp_all"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(296, 5)" end="(296, 15)" kind="Lean.Parser.Tactic.subst" state_before="case isFalse&#10;α✝ : Type u_1&#10;l' : List α✝&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h : l'.length + j = l.length&#10;w : l' = drop j l&#10;h' : ¬j &amp;lt; l.toArray.size&#10;this : l' = []&#10;⊢ none =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" state_after="case isFalse&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : ¬j &amp;lt; l.toArray.size&#10;h : [].length + j = l.length&#10;w : [] = drop j l&#10;⊢ none =&#10;    match [], j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" tactic="subst this">
                            <AtomNode start="(296, 5)" end="(296, 10)" leading="" trailing=" " val="subst"/>
                            <NullNode start="(296, 11)" end="(296, 15)">
                              <IdentNode start="(296, 11)" end="(296, 15)" leading="" trailing="&#10;    " raw_val="this" val="this"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(297, 5)" end="(297, 9)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;j : Nat&#10;l : List α✝&#10;h' : ¬j &amp;lt; l.toArray.size&#10;h : [].length + j = l.length&#10;w : [] = drop j l&#10;⊢ none =&#10;    match [], j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯" state_after="no goals" tactic="simp">
                            <AtomNode start="(297, 5)" end="(297, 9)" leading="" trailing="&#10;" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode start="(298, 1)" end="(298, 28)" kind="Lean.Parser.Termination.suffix">
            <NullNode start="(298, 1)" end="(298, 28)">
              <OtherNode start="(298, 1)" end="(298, 28)" kind="Lean.Parser.Termination.terminationBy">
                <AtomNode start="(298, 1)" end="(298, 15)" leading="" trailing=" " val="termination_by"/>
                <NullNode/>
                <NullNode/>
                <OtherNode start="(298, 16)" end="(298, 28)" kind="«term_-_»">
                  <IdentNode start="(298, 16)" end="(298, 24)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                  <AtomNode start="(298, 25)" end="(298, 26)" leading="" trailing=" " val="-"/>
                  <IdentNode start="(298, 27)" end="(298, 28)" leading="" trailing="&#10;&#10;" raw_val="j" val="j"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(300, 1)" end="(303, 7)" name="findFinIdx?_toArray" full_name="List.findFinIdx?_toArray">
      <CommandDeclmodifiersNode start="(300, 1)" end="(300, 8)">
        <NullNode/>
        <NullNode start="(300, 1)" end="(300, 8)">
          <OtherNode start="(300, 1)" end="(300, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(300, 1)" end="(300, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(300, 3)" end="(300, 7)">
              <OtherNode start="(300, 3)" end="(300, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(300, 3)" end="(300, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(300, 3)" end="(300, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(300, 7)" end="(300, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(300, 9)" end="(303, 7)" name="findFinIdx?_toArray" full_name="List.findFinIdx?_toArray" _is_private_decl="False">
        <AtomNode start="(300, 9)" end="(300, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(300, 17)" end="(300, 36)">
          <IdentNode start="(300, 17)" end="(300, 36)" leading="" trailing=" " raw_val="findFinIdx?_toArray" val="findFinIdx?_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(300, 37)" end="(301, 46)">
          <NullNode start="(300, 37)" end="(300, 64)">
            <TermExplicitbinderNode start="(300, 37)" end="(300, 51)">
              <AtomNode start="(300, 37)" end="(300, 38)" leading="" trailing="" val="("/>
              <NullNode start="(300, 38)" end="(300, 39)">
                <IdentNode start="(300, 38)" end="(300, 39)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(300, 40)" end="(300, 50)">
                <AtomNode start="(300, 40)" end="(300, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(300, 42)" end="(300, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(300, 42)" end="(300, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(300, 44)" end="(300, 45)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(300, 46)" end="(300, 50)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(300, 50)" end="(300, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(300, 52)" end="(300, 64)">
              <AtomNode start="(300, 52)" end="(300, 53)" leading="" trailing="" val="("/>
              <NullNode start="(300, 53)" end="(300, 54)">
                <IdentNode start="(300, 53)" end="(300, 54)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(300, 55)" end="(300, 63)">
                <AtomNode start="(300, 55)" end="(300, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(300, 57)" end="(300, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(300, 57)" end="(300, 61)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(300, 62)" end="(300, 63)">
                    <IdentNode start="(300, 62)" end="(300, 63)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(300, 63)" end="(300, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(300, 65)" end="(301, 46)">
            <AtomNode start="(300, 65)" end="(300, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(301, 5)" end="(301, 46)" kind="«term_=_»">
              <OtherNode start="(301, 5)" end="(301, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(301, 5)" end="(301, 26)" leading="" trailing=" " raw_val="l.toArray.findFinIdx?" val="l.toArray.findFinIdx?"/>
                <NullNode start="(301, 27)" end="(301, 28)">
                  <IdentNode start="(301, 27)" end="(301, 28)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(301, 29)" end="(301, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(301, 31)" end="(301, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(301, 31)" end="(301, 44)" leading="" trailing=" " raw_val="l.findFinIdx?" val="l.findFinIdx?"/>
                <NullNode start="(301, 45)" end="(301, 46)">
                  <IdentNode start="(301, 45)" end="(301, 46)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(301, 47)" end="(303, 7)">
          <AtomNode start="(301, 47)" end="(301, 49)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(301, 50)" end="(303, 7)">
            <AtomNode start="(301, 50)" end="(301, 52)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(302, 3)" end="(303, 7)">
              <TacticTacticseq1IndentedNode start="(302, 3)" end="(303, 7)">
                <NullNode start="(302, 3)" end="(303, 7)">
                  <OtherNode start="(302, 3)" end="(302, 64)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ Array.findFinIdx? p l.toArray = findFinIdx? p l" state_after="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ l = drop 0 l" tactic="rw [Array.findFinIdx?, findFinIdx?, findFinIdx?_loop_toArray]">
                    <AtomNode start="(302, 3)" end="(302, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(302, 6)" end="(302, 64)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(302, 6)" end="(302, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(302, 7)" end="(302, 63)">
                        <OtherNode start="(302, 7)" end="(302, 24)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(302, 7)" end="(302, 24)" leading="" trailing="" raw_val="Array.findFinIdx?" val="Array.findFinIdx?" full_name="Array.findFinIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(302, 24)" end="(302, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(302, 26)" end="(302, 37)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(302, 26)" end="(302, 37)" leading="" trailing="" raw_val="findFinIdx?" val="findFinIdx?" full_name="List.findFinIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(302, 37)" end="(302, 38)" leading="" trailing=" " val=","/>
                        <OtherNode start="(302, 39)" end="(302, 63)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(302, 39)" end="(302, 63)" leading="" trailing="" raw_val="findFinIdx?_loop_toArray" val="findFinIdx?_loop_toArray" full_name="_private.Init.Data.List.ToArray.0.List.findFinIdx?_loop_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(274, 17)" def_end="(274, 41)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(302, 63)" end="(302, 64)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(303, 3)" end="(303, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ l = drop 0 l" state_after="no goals" tactic="simp">
                    <AtomNode start="(303, 3)" end="(303, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(305, 1)" end="(308, 7)" name="findIdx?_toArray" full_name="List.findIdx?_toArray">
      <CommandDeclmodifiersNode start="(305, 1)" end="(305, 8)">
        <NullNode/>
        <NullNode start="(305, 1)" end="(305, 8)">
          <OtherNode start="(305, 1)" end="(305, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(305, 1)" end="(305, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(305, 3)" end="(305, 7)">
              <OtherNode start="(305, 3)" end="(305, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(305, 3)" end="(305, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(305, 3)" end="(305, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(305, 7)" end="(305, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(305, 9)" end="(308, 7)" name="findIdx?_toArray" full_name="List.findIdx?_toArray" _is_private_decl="False">
        <AtomNode start="(305, 9)" end="(305, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(305, 17)" end="(305, 33)">
          <IdentNode start="(305, 17)" end="(305, 33)" leading="" trailing=" " raw_val="findIdx?_toArray" val="findIdx?_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(305, 34)" end="(306, 40)">
          <NullNode start="(305, 34)" end="(305, 61)">
            <TermExplicitbinderNode start="(305, 34)" end="(305, 48)">
              <AtomNode start="(305, 34)" end="(305, 35)" leading="" trailing="" val="("/>
              <NullNode start="(305, 35)" end="(305, 36)">
                <IdentNode start="(305, 35)" end="(305, 36)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(305, 37)" end="(305, 47)">
                <AtomNode start="(305, 37)" end="(305, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(305, 39)" end="(305, 47)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(305, 39)" end="(305, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(305, 41)" end="(305, 42)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(305, 43)" end="(305, 47)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(305, 47)" end="(305, 48)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(305, 49)" end="(305, 61)">
              <AtomNode start="(305, 49)" end="(305, 50)" leading="" trailing="" val="("/>
              <NullNode start="(305, 50)" end="(305, 51)">
                <IdentNode start="(305, 50)" end="(305, 51)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(305, 52)" end="(305, 60)">
                <AtomNode start="(305, 52)" end="(305, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(305, 54)" end="(305, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(305, 54)" end="(305, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(305, 59)" end="(305, 60)">
                    <IdentNode start="(305, 59)" end="(305, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(305, 60)" end="(305, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(305, 62)" end="(306, 40)">
            <AtomNode start="(305, 62)" end="(305, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(306, 5)" end="(306, 40)" kind="«term_=_»">
              <OtherNode start="(306, 5)" end="(306, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(306, 5)" end="(306, 23)" leading="" trailing=" " raw_val="l.toArray.findIdx?" val="l.toArray.findIdx?"/>
                <NullNode start="(306, 24)" end="(306, 25)">
                  <IdentNode start="(306, 24)" end="(306, 25)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(306, 26)" end="(306, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(306, 28)" end="(306, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(306, 28)" end="(306, 38)" leading="" trailing=" " raw_val="l.findIdx?" val="l.findIdx?"/>
                <NullNode start="(306, 39)" end="(306, 40)">
                  <IdentNode start="(306, 39)" end="(306, 40)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(306, 41)" end="(308, 7)">
          <AtomNode start="(306, 41)" end="(306, 43)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(306, 44)" end="(308, 7)">
            <AtomNode start="(306, 44)" end="(306, 46)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(307, 3)" end="(308, 7)">
              <TacticTacticseq1IndentedNode start="(307, 3)" end="(308, 7)">
                <NullNode start="(307, 3)" end="(308, 7)">
                  <OtherNode start="(307, 3)" end="(307, 78)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ Array.findIdx? p l.toArray = findIdx? p l" state_after="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ Option.map (fun x =&amp;gt; ↑x) (Array.findFinIdx? p l.toArray) = Option.map (fun x =&amp;gt; ↑x) (findFinIdx? p l)" tactic="rw [Array.findIdx?_eq_map_findFinIdx?_val, findIdx?_eq_map_findFinIdx?_val]">
                    <AtomNode start="(307, 3)" end="(307, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(307, 6)" end="(307, 78)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(307, 6)" end="(307, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(307, 7)" end="(307, 77)">
                        <OtherNode start="(307, 7)" end="(307, 44)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(307, 7)" end="(307, 44)" leading="" trailing="" raw_val="Array.findIdx?_eq_map_findFinIdx?_val" val="Array.findIdx?_eq_map_findFinIdx?_val" full_name="Array.findIdx?_eq_map_findFinIdx?_val" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(307, 44)" end="(307, 45)" leading="" trailing=" " val=","/>
                        <OtherNode start="(307, 46)" end="(307, 77)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(307, 46)" end="(307, 77)" leading="" trailing="" raw_val="findIdx?_eq_map_findFinIdx?_val" val="findIdx?_eq_map_findFinIdx?_val" full_name="List.findIdx?_eq_map_findFinIdx?_val" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(307, 77)" end="(307, 78)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(308, 3)" end="(308, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ Option.map (fun x =&amp;gt; ↑x) (Array.findFinIdx? p l.toArray) = Option.map (fun x =&amp;gt; ↑x) (findFinIdx? p l)" state_after="no goals" tactic="simp">
                    <AtomNode start="(308, 3)" end="(308, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(310, 1)" end="(335, 28)" name="idxAuxOf_toArray" full_name="List.idxAuxOf_toArray">
      <CommandDeclmodifiersNode start="(310, 1)" end="(310, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(310, 1)" end="(310, 8)">
          <CommandPrivateNode start="(310, 1)" end="(310, 8)">
            <AtomNode start="(310, 1)" end="(310, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(310, 9)" end="(335, 28)" name="idxAuxOf_toArray" full_name="List.idxAuxOf_toArray" _is_private_decl="True">
        <AtomNode start="(310, 9)" end="(310, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(310, 17)" end="(310, 33)">
          <IdentNode start="(310, 17)" end="(310, 33)" leading="" trailing=" " raw_val="idxAuxOf_toArray" val="idxAuxOf_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(310, 34)" end="(311, 71)">
          <NullNode start="(310, 34)" end="(310, 96)">
            <OtherNode start="(310, 34)" end="(310, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(310, 34)" end="(310, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(310, 35)" end="(310, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(310, 35)" end="(310, 38)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(310, 39)" end="(310, 40)">
                  <IdentNode start="(310, 39)" end="(310, 40)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(310, 40)" end="(310, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(310, 42)" end="(310, 49)">
              <AtomNode start="(310, 42)" end="(310, 43)" leading="" trailing="" val="("/>
              <NullNode start="(310, 43)" end="(310, 44)">
                <IdentNode start="(310, 43)" end="(310, 44)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(310, 45)" end="(310, 48)">
                <AtomNode start="(310, 45)" end="(310, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(310, 47)" end="(310, 48)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(310, 48)" end="(310, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(310, 50)" end="(310, 62)">
              <AtomNode start="(310, 50)" end="(310, 51)" leading="" trailing="" val="("/>
              <NullNode start="(310, 51)" end="(310, 52)">
                <IdentNode start="(310, 51)" end="(310, 52)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(310, 53)" end="(310, 61)">
                <AtomNode start="(310, 53)" end="(310, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(310, 55)" end="(310, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(310, 55)" end="(310, 59)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(310, 60)" end="(310, 61)">
                    <IdentNode start="(310, 60)" end="(310, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(310, 61)" end="(310, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(310, 63)" end="(310, 72)">
              <AtomNode start="(310, 63)" end="(310, 64)" leading="" trailing="" val="("/>
              <NullNode start="(310, 64)" end="(310, 65)">
                <IdentNode start="(310, 64)" end="(310, 65)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(310, 66)" end="(310, 71)">
                <AtomNode start="(310, 66)" end="(310, 67)" leading="" trailing=" " val=":"/>
                <IdentNode start="(310, 68)" end="(310, 71)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(310, 71)" end="(310, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(310, 73)" end="(310, 92)">
              <AtomNode start="(310, 73)" end="(310, 74)" leading="" trailing="" val="("/>
              <NullNode start="(310, 74)" end="(310, 75)">
                <IdentNode start="(310, 74)" end="(310, 75)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(310, 76)" end="(310, 91)">
                <AtomNode start="(310, 76)" end="(310, 77)" leading="" trailing=" " val=":"/>
                <OtherNode start="(310, 78)" end="(310, 91)" kind="«term_=_»">
                  <IdentNode start="(310, 78)" end="(310, 80)" leading="" trailing=" " raw_val="l'" val="l'"/>
                  <AtomNode start="(310, 81)" end="(310, 82)" leading="" trailing=" " val="="/>
                  <OtherNode start="(310, 83)" end="(310, 91)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(310, 83)" end="(310, 89)" leading="" trailing=" " raw_val="l.drop" val="l.drop"/>
                    <NullNode start="(310, 90)" end="(310, 91)">
                      <IdentNode start="(310, 90)" end="(310, 91)" leading="" trailing="" raw_val="j" val="j"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(310, 91)" end="(310, 92)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(310, 93)" end="(310, 96)">
              <AtomNode start="(310, 93)" end="(310, 94)" leading="" trailing="" val="("/>
              <NullNode start="(310, 94)" end="(310, 95)">
                <IdentNode start="(310, 94)" end="(310, 95)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(310, 95)" end="(310, 96)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(310, 97)" end="(311, 71)">
            <AtomNode start="(310, 97)" end="(310, 98)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(311, 5)" end="(311, 71)" kind="«term_=_»">
              <OtherNode start="(311, 5)" end="(311, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(311, 5)" end="(311, 23)" leading="" trailing=" " raw_val="l.toArray.idxOfAux" val="l.toArray.idxOfAux"/>
                <NullNode start="(311, 24)" end="(311, 27)">
                  <IdentNode start="(311, 24)" end="(311, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                  <IdentNode start="(311, 26)" end="(311, 27)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(311, 28)" end="(311, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(311, 30)" end="(311, 71)" kind="Lean.Parser.Term.app">
                <IdentNode start="(311, 30)" end="(311, 44)" leading="" trailing=" " raw_val="findFinIdx?.go" val="findFinIdx?.go" full_name="List.findFinIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(311, 45)" end="(311, 71)">
                  <OtherNode start="(311, 45)" end="(311, 62)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(311, 45)" end="(311, 46)" leading="" trailing="" val="("/>
                    <OtherNode start="(311, 46)" end="(311, 61)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(311, 46)" end="(311, 49)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(311, 50)" end="(311, 61)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(311, 50)" end="(311, 51)">
                          <IdentNode start="(311, 50)" end="(311, 51)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(311, 52)" end="(311, 54)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(311, 55)" end="(311, 61)" kind="«term_==_»">
                          <IdentNode start="(311, 55)" end="(311, 56)" leading="" trailing=" " raw_val="x" val="x"/>
                          <AtomNode start="(311, 57)" end="(311, 59)" leading="" trailing=" " val="=="/>
                          <IdentNode start="(311, 60)" end="(311, 61)" leading="" trailing="" raw_val="a" val="a"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(311, 61)" end="(311, 62)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(311, 63)" end="(311, 64)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(311, 65)" end="(311, 67)" leading="" trailing=" " raw_val="l'" val="l'"/>
                  <IdentNode start="(311, 68)" end="(311, 69)" leading="" trailing=" " raw_val="j" val="j"/>
                  <IdentNode start="(311, 70)" end="(311, 71)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(311, 72)" end="(335, 28)">
          <AtomNode start="(311, 72)" end="(311, 74)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(311, 75)" end="(334, 9)">
            <AtomNode start="(311, 75)" end="(311, 77)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(312, 3)" end="(334, 9)">
              <TacticTacticseq1IndentedNode start="(312, 3)" end="(334, 9)">
                <NullNode start="(312, 3)" end="(334, 9)">
                  <OtherNode start="(312, 3)" end="(312, 18)" kind="Lean.Parser.Tactic.unfold" state_before="α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;⊢ l.toArray.idxOfAux a j = findFinIdx?.go (fun x =&amp;gt; x == a) l l' j h" state_after="α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;⊢ (if h : j &amp;lt; l.toArray.size then if (l.toArray[j] == a) = true then some ⟨j, h⟩ else l.toArray.idxOfAux a (j + 1)&#10;    else none) =&#10;    findFinIdx?.go (fun x =&amp;gt; x == a) l l' j h" tactic="unfold idxOfAux">
                    <AtomNode start="(312, 3)" end="(312, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(312, 10)" end="(312, 18)">
                      <IdentNode start="(312, 10)" end="(312, 18)" leading="" trailing="&#10;  " raw_val="idxOfAux" val="idxOfAux" full_name="Array.idxOfAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(313, 3)" end="(313, 24)" kind="Lean.Parser.Tactic.unfold" state_before="α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;⊢ (if h : j &amp;lt; l.toArray.size then if (l.toArray[j] == a) = true then some ⟨j, h⟩ else l.toArray.idxOfAux a (j + 1)&#10;    else none) =&#10;    findFinIdx?.go (fun x =&amp;gt; x == a) l l' j h" state_after="α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;⊢ (if h : j &amp;lt; l.toArray.size then if (l.toArray[j] == a) = true then some ⟨j, h⟩ else l.toArray.idxOfAux a (j + 1)&#10;    else none) =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" tactic="unfold findFinIdx?.go">
                    <AtomNode start="(313, 3)" end="(313, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(313, 10)" end="(313, 24)">
                      <IdentNode start="(313, 10)" end="(313, 24)" leading="" trailing="&#10;  " raw_val="findFinIdx?.go" val="findFinIdx?.go" full_name="List.findFinIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(314, 3)" end="(314, 24)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;⊢ (if h : j &amp;lt; l.toArray.size then if (l.toArray[j] == a) = true then some ⟨j, h⟩ else l.toArray.idxOfAux a (j + 1)&#10;    else none) =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" state_after="case isTrue&#10;α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;h' : j &amp;lt; l.toArray.size&#10;⊢ (if (l.toArray[j] == a) = true then some ⟨j, h'⟩ else l.toArray.idxOfAux a (j + 1)) =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯&#10;&#10;case isFalse&#10;α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;h' : ¬j &amp;lt; l.toArray.size&#10;⊢ none =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" tactic="split &amp;lt;;&amp;gt; rename_i h'">
                    <OtherNode start="(314, 3)" end="(314, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(314, 3)" end="(314, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(314, 9)" end="(314, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(314, 13)" end="(314, 24)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(314, 13)" end="(314, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(314, 22)" end="(314, 24)">
                        <LeanBinderidentNode start="(314, 22)" end="(314, 24)">
                          <IdentNode start="(314, 22)" end="(314, 24)" leading="" trailing="&#10;  " raw_val="h'" val="h'"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(315, 3)" end="(331, 55)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;h' : j &amp;lt; l.toArray.size&#10;⊢ (if (l.toArray[j] == a) = true then some ⟨j, h'⟩ else l.toArray.idxOfAux a (j + 1)) =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯&#10;&#10;case isFalse&#10;α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;h' : ¬j &amp;lt; l.toArray.size&#10;⊢ none =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" state_after="case isFalse&#10;α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;h' : ¬j &amp;lt; l.toArray.size&#10;⊢ none =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" tactic="· cases l' with&#10;  | nil =&amp;gt;&#10;    simp at h h'&#10;    omega&#10;  | cons b l' =&amp;gt;&#10;    simp at h'&#10;    have : l[j] = b := by&#10;      rw [drop_eq_getElem_cons h'] at w&#10;      simp only [cons.injEq] at w&#10;      exact w.1.symm&#10;    simp only [getElem_toArray, this]&#10;    split&#10;    · rfl&#10;    · simp only [length_cons] at h&#10;      have : l.length - (j + 1) &amp;lt; l.length - j := by omega&#10;      rw [idxAuxOf_toArray]&#10;      rw [drop_add_one_eq_tail_drop, ← w, tail_cons]">
                    <OtherNode start="(315, 3)" end="(315, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(315, 3)" end="(315, 4)" kind="patternIgnore">
                        <OtherNode start="(315, 3)" end="(315, 4)" kind="token.«· »">
                          <AtomNode start="(315, 3)" end="(315, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(315, 5)" end="(331, 55)">
                      <TacticTacticseq1IndentedNode start="(315, 5)" end="(331, 55)">
                        <NullNode start="(315, 5)" end="(331, 55)">
                          <OtherNode start="(315, 5)" end="(331, 55)" kind="Lean.Parser.Tactic.cases" state_before="case isTrue&#10;α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;h' : j &amp;lt; l.toArray.size&#10;⊢ (if (l.toArray[j] == a) = true then some ⟨j, h'⟩ else l.toArray.idxOfAux a (j + 1)) =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" state_after="no goals" tactic="cases l' with&#10;| nil =&amp;gt;&#10;  simp at h h'&#10;  omega&#10;| cons b l' =&amp;gt;&#10;  simp at h'&#10;  have : l[j] = b := by&#10;    rw [drop_eq_getElem_cons h'] at w&#10;    simp only [cons.injEq] at w&#10;    exact w.1.symm&#10;  simp only [getElem_toArray, this]&#10;  split&#10;  · rfl&#10;  · simp only [length_cons] at h&#10;    have : l.length - (j + 1) &amp;lt; l.length - j := by omega&#10;    rw [idxAuxOf_toArray]&#10;    rw [drop_add_one_eq_tail_drop, ← w, tail_cons]">
                            <AtomNode start="(315, 5)" end="(315, 10)" leading="" trailing=" " val="cases"/>
                            <NullNode start="(315, 11)" end="(315, 13)">
                              <OtherNode start="(315, 11)" end="(315, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                <NullNode/>
                                <IdentNode start="(315, 11)" end="(315, 13)" leading="" trailing=" " raw_val="l'" val="l'"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(315, 14)" end="(331, 55)">
                              <OtherNode start="(315, 14)" end="(331, 55)" kind="Lean.Parser.Tactic.inductionAlts">
                                <AtomNode start="(315, 14)" end="(315, 18)" leading="" trailing="&#10;    " val="with"/>
                                <NullNode/>
                                <NullNode start="(316, 5)" end="(331, 55)">
                                  <OtherNode start="(316, 5)" end="(318, 12)" kind="Lean.Parser.Tactic.inductionAlt">
                                    <NullNode start="(316, 5)" end="(316, 10)">
                                      <OtherNode start="(316, 5)" end="(316, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                        <AtomNode start="(316, 5)" end="(316, 6)" leading="" trailing=" " val="|"/>
                                        <GroupNode start="(316, 7)" end="(316, 10)">
                                          <NullNode/>
                                          <IdentNode start="(316, 7)" end="(316, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        </GroupNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode start="(316, 11)" end="(318, 12)">
                                      <AtomNode start="(316, 11)" end="(316, 13)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                      <TacticTacticseqNode start="(317, 7)" end="(318, 12)">
                                        <TacticTacticseq1IndentedNode start="(317, 7)" end="(318, 12)">
                                          <NullNode start="(317, 7)" end="(318, 12)">
                                            <OtherNode start="(317, 7)" end="(317, 19)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.nil&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h' : j &amp;lt; l.toArray.size&#10;w : [] = drop j l&#10;h : [].length + j = l.length&#10;⊢ (if (l.toArray[j] == a) = true then some ⟨j, h'⟩ else l.toArray.idxOfAux a (j + 1)) =&#10;    match [], j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" state_after="case isTrue.nil&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;w : [] = drop j l&#10;h✝ : [].length + j = l.length&#10;h : j = l.length&#10;h' : j &amp;lt; l.length&#10;⊢ (if (l.toArray[j] == a) = true then some ⟨j, h'✝⟩ else l.toArray.idxOfAux a (j + 1)) =&#10;    match [], j, h✝ with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" tactic="simp at h h'">
                                              <AtomNode start="(317, 7)" end="(317, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(317, 12)" end="(317, 19)">
                                                <OtherNode start="(317, 12)" end="(317, 19)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(317, 12)" end="(317, 14)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(317, 15)" end="(317, 19)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(317, 15)" end="(317, 19)">
                                                      <IdentNode start="(317, 15)" end="(317, 16)" leading="" trailing=" " raw_val="h" val="h"/>
                                                      <IdentNode start="(317, 17)" end="(317, 19)" leading="" trailing="&#10;      " raw_val="h'" val="h'"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(318, 7)" end="(318, 12)" kind="Lean.Parser.Tactic.omega" state_before="case isTrue.nil&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;w : [] = drop j l&#10;h✝ : [].length + j = l.length&#10;h : j = l.length&#10;h' : j &amp;lt; l.length&#10;⊢ (if (l.toArray[j] == a) = true then some ⟨j, h'✝⟩ else l.toArray.idxOfAux a (j + 1)) =&#10;    match [], j, h✝ with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" state_after="no goals" tactic="omega">
                                              <AtomNode start="(318, 7)" end="(318, 12)" leading="" trailing="&#10;    " val="omega"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </NullNode>
                                  </OtherNode>
                                  <OtherNode start="(319, 5)" end="(331, 55)" kind="Lean.Parser.Tactic.inductionAlt">
                                    <NullNode start="(319, 5)" end="(319, 16)">
                                      <OtherNode start="(319, 5)" end="(319, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                        <AtomNode start="(319, 5)" end="(319, 6)" leading="" trailing=" " val="|"/>
                                        <GroupNode start="(319, 7)" end="(319, 11)">
                                          <NullNode/>
                                          <IdentNode start="(319, 7)" end="(319, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        </GroupNode>
                                        <NullNode start="(319, 12)" end="(319, 16)">
                                          <IdentNode start="(319, 12)" end="(319, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                          <IdentNode start="(319, 14)" end="(319, 16)" leading="" trailing=" " raw_val="l'" val="l'"/>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode start="(319, 17)" end="(331, 55)">
                                      <AtomNode start="(319, 17)" end="(319, 19)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                      <TacticTacticseqNode start="(320, 7)" end="(331, 55)">
                                        <TacticTacticseq1IndentedNode start="(320, 7)" end="(331, 55)">
                                          <NullNode start="(320, 7)" end="(331, 55)">
                                            <OtherNode start="(320, 7)" end="(320, 17)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h' : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;⊢ (if (l.toArray[j] == a) = true then some ⟨j, h'⟩ else l.toArray.idxOfAux a (j + 1)) =&#10;    match b :: l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" state_after="case isTrue.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;⊢ (if (l.toArray[j] == a) = true then some ⟨j, h'✝⟩ else l.toArray.idxOfAux a (j + 1)) =&#10;    match b :: l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" tactic="simp at h'">
                                              <AtomNode start="(320, 7)" end="(320, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(320, 12)" end="(320, 17)">
                                                <OtherNode start="(320, 12)" end="(320, 17)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(320, 12)" end="(320, 14)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(320, 15)" end="(320, 17)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(320, 15)" end="(320, 17)">
                                                      <IdentNode start="(320, 15)" end="(320, 17)" leading="" trailing="&#10;      " raw_val="h'" val="h'"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(321, 7)" end="(324, 23)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case isTrue.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;⊢ (if (l.toArray[j] == a) = true then some ⟨j, h'✝⟩ else l.toArray.idxOfAux a (j + 1)) =&#10;    match b :: l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" state_after="case isTrue.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;⊢ (if (l.toArray[j] == a) = true then some ⟨j, h'✝⟩ else l.toArray.idxOfAux a (j + 1)) =&#10;    match b :: l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" tactic="have : l[j] = b := by&#10;  rw [drop_eq_getElem_cons h'] at w&#10;  simp only [cons.injEq] at w&#10;  exact w.1.symm">
                                              <AtomNode start="(321, 7)" end="(321, 11)" leading="" trailing=" " val="have"/>
                                              <OtherNode start="(321, 12)" end="(324, 23)" kind="Lean.Parser.Term.haveDecl">
                                                <OtherNode start="(321, 12)" end="(324, 23)" kind="Lean.Parser.Term.haveIdDecl">
                                                  <OtherNode start="(321, 12)" end="(321, 12)" kind="Lean.Parser.Term.haveId">
                                                    <OtherNode start="(321, 12)" end="(321, 12)" kind="hygieneInfo">
                                                      <IdentNode start="(321, 12)" end="(321, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode start="(321, 12)" end="(321, 22)">
                                                    <TermTypespecNode start="(321, 12)" end="(321, 22)">
                                                      <AtomNode start="(321, 12)" end="(321, 13)" leading="" trailing=" " val=":"/>
                                                      <OtherNode start="(321, 14)" end="(321, 22)" kind="«term_=_»">
                                                        <OtherNode start="(321, 14)" end="(321, 18)" kind="«term__[_]»">
                                                          <IdentNode start="(321, 14)" end="(321, 15)" leading="" trailing="" raw_val="l" val="l"/>
                                                          <AtomNode start="(321, 15)" end="(321, 16)" leading="" trailing="" val="["/>
                                                          <IdentNode start="(321, 16)" end="(321, 17)" leading="" trailing="" raw_val="j" val="j"/>
                                                          <AtomNode start="(321, 17)" end="(321, 18)" leading="" trailing=" " val="]"/>
                                                        </OtherNode>
                                                        <AtomNode start="(321, 19)" end="(321, 20)" leading="" trailing=" " val="="/>
                                                        <IdentNode start="(321, 21)" end="(321, 22)" leading="" trailing=" " raw_val="b" val="b"/>
                                                      </OtherNode>
                                                    </TermTypespecNode>
                                                  </NullNode>
                                                  <AtomNode start="(321, 23)" end="(321, 25)" leading="" trailing=" " val=":="/>
                                                  <TermBytacticNode start="(321, 26)" end="(324, 23)">
                                                    <AtomNode start="(321, 26)" end="(321, 28)" leading="" trailing="&#10;        " val="by"/>
                                                    <TacticTacticseqNode start="(322, 9)" end="(324, 23)">
                                                      <TacticTacticseq1IndentedNode start="(322, 9)" end="(324, 23)">
                                                        <NullNode start="(322, 9)" end="(324, 23)">
                                                          <OtherNode start="(322, 9)" end="(322, 42)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;⊢ l[j] = b" state_after="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;w : b :: l' = l[j] :: drop (j + 1) l&#10;⊢ l[j] = b" tactic="rw [drop_eq_getElem_cons h'] at w">
                                                            <AtomNode start="(322, 9)" end="(322, 11)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(322, 12)" end="(322, 37)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(322, 12)" end="(322, 13)" leading="" trailing="" val="["/>
                                                            <NullNode start="(322, 13)" end="(322, 36)">
                                                            <OtherNode start="(322, 13)" end="(322, 36)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <OtherNode start="(322, 13)" end="(322, 36)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(322, 13)" end="(322, 33)" leading="" trailing=" " raw_val="drop_eq_getElem_cons" val="drop_eq_getElem_cons" full_name="List.drop_eq_getElem_cons" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                            <NullNode start="(322, 34)" end="(322, 36)">
                                                            <IdentNode start="(322, 34)" end="(322, 36)" leading="" trailing="" raw_val="h'" val="h'"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(322, 36)" end="(322, 37)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            <NullNode start="(322, 38)" end="(322, 42)">
                                                            <OtherNode start="(322, 38)" end="(322, 42)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(322, 38)" end="(322, 40)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(322, 41)" end="(322, 42)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(322, 41)" end="(322, 42)">
                                                            <IdentNode start="(322, 41)" end="(322, 42)" leading="" trailing="&#10;        " raw_val="w" val="w"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <OtherNode start="(323, 9)" end="(323, 36)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;w : b :: l' = l[j] :: drop (j + 1) l&#10;⊢ l[j] = b" state_after="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;w : b = l[j] ∧ l' = drop (j + 1) l&#10;⊢ l[j] = b" tactic="simp only [cons.injEq] at w">
                                                            <AtomNode start="(323, 9)" end="(323, 13)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(323, 14)" end="(323, 18)">
                                                            <AtomNode start="(323, 14)" end="(323, 18)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(323, 19)" end="(323, 31)">
                                                            <AtomNode start="(323, 19)" end="(323, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(323, 20)" end="(323, 30)">
                                                            <OtherNode start="(323, 20)" end="(323, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(323, 20)" end="(323, 30)" leading="" trailing="" raw_val="cons.injEq" val="cons.injEq" full_name="List.cons.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(323, 30)" end="(323, 31)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(323, 32)" end="(323, 36)">
                                                            <OtherNode start="(323, 32)" end="(323, 36)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(323, 32)" end="(323, 34)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(323, 35)" end="(323, 36)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(323, 35)" end="(323, 36)">
                                                            <IdentNode start="(323, 35)" end="(323, 36)" leading="" trailing="&#10;        " raw_val="w" val="w"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <OtherNode start="(324, 9)" end="(324, 23)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;w : b = l[j] ∧ l' = drop (j + 1) l&#10;⊢ l[j] = b" state_after="no goals" tactic="exact w.1.symm">
                                                            <AtomNode start="(324, 9)" end="(324, 14)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(324, 15)" end="(324, 23)" kind="Lean.Parser.Term.proj">
                                                            <OtherNode start="(324, 15)" end="(324, 18)" kind="Lean.Parser.Term.proj">
                                                            <IdentNode start="(324, 15)" end="(324, 16)" leading="" trailing="" raw_val="w" val="w"/>
                                                            <AtomNode start="(324, 16)" end="(324, 17)" leading="" trailing="" val="."/>
                                                            <OtherNode start="(324, 17)" end="(324, 18)" kind="fieldIdx">
                                                            <AtomNode start="(324, 17)" end="(324, 18)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(324, 18)" end="(324, 19)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(324, 19)" end="(324, 23)" leading="" trailing="&#10;      " raw_val="symm" val="symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </TermBytacticNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(325, 7)" end="(325, 40)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;⊢ (if (l.toArray[j] == a) = true then some ⟨j, h'✝⟩ else l.toArray.idxOfAux a (j + 1)) =&#10;    match b :: l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" state_after="case isTrue.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;⊢ (if (b == a) = true then some ⟨j, h'✝⟩ else l.toArray.idxOfAux a (j + 1)) =&#10;    if (b == a) = true then some ⟨j, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l' (j + 1) ⋯" tactic="simp only [getElem_toArray, this]">
                                              <AtomNode start="(325, 7)" end="(325, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(325, 12)" end="(325, 16)">
                                                <AtomNode start="(325, 12)" end="(325, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(325, 17)" end="(325, 40)">
                                                <AtomNode start="(325, 17)" end="(325, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(325, 18)" end="(325, 39)">
                                                  <OtherNode start="(325, 18)" end="(325, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(325, 18)" end="(325, 33)" leading="" trailing="" raw_val="getElem_toArray" val="getElem_toArray" full_name="List.getElem_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(325, 33)" end="(325, 34)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(325, 35)" end="(325, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(325, 35)" end="(325, 39)" leading="" trailing="" raw_val="this" val="this"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(325, 39)" end="(325, 40)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(326, 7)" end="(326, 12)" kind="Lean.Parser.Tactic.split" state_before="case isTrue.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;⊢ (if (b == a) = true then some ⟨j, h'✝⟩ else l.toArray.idxOfAux a (j + 1)) =&#10;    if (b == a) = true then some ⟨j, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l' (j + 1) ⋯" state_after="case isTrue.cons.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;h✝ : (b == a) = true&#10;⊢ some ⟨j, h'✝⟩ = some ⟨j, ⋯⟩&#10;&#10;case isTrue.cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;h✝ : ¬(b == a) = true&#10;⊢ l.toArray.idxOfAux a (j + 1) = findFinIdx?.go (fun x =&amp;gt; x == a) l l' (j + 1) ⋯" tactic="split">
                                              <AtomNode start="(326, 7)" end="(326, 12)" leading="" trailing="&#10;      " val="split"/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(327, 7)" end="(327, 12)" kind="Lean.cdot" state_before="case isTrue.cons.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;h✝ : (b == a) = true&#10;⊢ some ⟨j, h'✝⟩ = some ⟨j, ⋯⟩&#10;&#10;case isTrue.cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;h✝ : ¬(b == a) = true&#10;⊢ l.toArray.idxOfAux a (j + 1) = findFinIdx?.go (fun x =&amp;gt; x == a) l l' (j + 1) ⋯" state_after="case isTrue.cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;h✝ : ¬(b == a) = true&#10;⊢ l.toArray.idxOfAux a (j + 1) = findFinIdx?.go (fun x =&amp;gt; x == a) l l' (j + 1) ⋯" tactic="· rfl">
                                              <OtherNode start="(327, 7)" end="(327, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(327, 7)" end="(327, 8)" kind="patternIgnore">
                                                  <OtherNode start="(327, 7)" end="(327, 8)" kind="token.«· »">
                                                    <AtomNode start="(327, 7)" end="(327, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(327, 9)" end="(327, 12)">
                                                <TacticTacticseq1IndentedNode start="(327, 9)" end="(327, 12)">
                                                  <NullNode start="(327, 9)" end="(327, 12)">
                                                    <OtherNode start="(327, 9)" end="(327, 12)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case isTrue.cons.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;h✝ : (b == a) = true&#10;⊢ some ⟨j, h'✝⟩ = some ⟨j, ⋯⟩" state_after="no goals" tactic="rfl">
                                                      <AtomNode start="(327, 9)" end="(327, 12)" leading="" trailing="&#10;      " val="rfl"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(328, 7)" end="(331, 55)" kind="Lean.cdot" state_before="case isTrue.cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;h✝ : ¬(b == a) = true&#10;⊢ l.toArray.idxOfAux a (j + 1) = findFinIdx?.go (fun x =&amp;gt; x == a) l l' (j + 1) ⋯" state_after="no goals" tactic="· simp only [length_cons] at h&#10;  have : l.length - (j + 1) &amp;lt; l.length - j := by omega&#10;  rw [idxAuxOf_toArray]&#10;  rw [drop_add_one_eq_tail_drop, ← w, tail_cons]">
                                              <OtherNode start="(328, 7)" end="(328, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(328, 7)" end="(328, 8)" kind="patternIgnore">
                                                  <OtherNode start="(328, 7)" end="(328, 8)" kind="token.«· »">
                                                    <AtomNode start="(328, 7)" end="(328, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(328, 9)" end="(331, 55)">
                                                <TacticTacticseq1IndentedNode start="(328, 9)" end="(331, 55)">
                                                  <NullNode start="(328, 9)" end="(331, 55)">
                                                    <OtherNode start="(328, 9)" end="(328, 37)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : (b :: l').length + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;h✝ : ¬(b == a) = true&#10;⊢ l.toArray.idxOfAux a (j + 1) = findFinIdx?.go (fun x =&amp;gt; x == a) l l' (j + 1) ⋯" state_after="case isTrue.cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : l'.length + 1 + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;h✝ : ¬(b == a) = true&#10;⊢ l.toArray.idxOfAux a (j + 1) = findFinIdx?.go (fun x =&amp;gt; x == a) l l' (j + 1) ⋯" tactic="simp only [length_cons] at h">
                                                      <AtomNode start="(328, 9)" end="(328, 13)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode start="(328, 14)" end="(328, 18)">
                                                        <AtomNode start="(328, 14)" end="(328, 18)" leading="" trailing=" " val="only"/>
                                                      </NullNode>
                                                      <NullNode start="(328, 19)" end="(328, 32)">
                                                        <AtomNode start="(328, 19)" end="(328, 20)" leading="" trailing="" val="["/>
                                                        <NullNode start="(328, 20)" end="(328, 31)">
                                                          <OtherNode start="(328, 20)" end="(328, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(328, 20)" end="(328, 31)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(328, 31)" end="(328, 32)" leading="" trailing=" " val="]"/>
                                                      </NullNode>
                                                      <NullNode start="(328, 33)" end="(328, 37)">
                                                        <OtherNode start="(328, 33)" end="(328, 37)" kind="Lean.Parser.Tactic.location">
                                                          <AtomNode start="(328, 33)" end="(328, 35)" leading="" trailing=" " val="at"/>
                                                          <OtherNode start="(328, 36)" end="(328, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(328, 36)" end="(328, 37)">
                                                            <IdentNode start="(328, 36)" end="(328, 37)" leading="" trailing="&#10;        " raw_val="h" val="h"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(329, 9)" end="(329, 61)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case isTrue.cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : l'.length + 1 + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;h✝ : ¬(b == a) = true&#10;⊢ l.toArray.idxOfAux a (j + 1) = findFinIdx?.go (fun x =&amp;gt; x == a) l l' (j + 1) ⋯" state_after="case isTrue.cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : l'.length + 1 + j = l.length&#10;h' : j &amp;lt; l.length&#10;this✝ : l[j] = b&#10;h✝ : ¬(b == a) = true&#10;this : l.length - (j + 1) &amp;lt; l.length - j&#10;⊢ l.toArray.idxOfAux a (j + 1) = findFinIdx?.go (fun x =&amp;gt; x == a) l l' (j + 1) ⋯" tactic="have : l.length - (j + 1) &amp;lt; l.length - j := by omega">
                                                      <AtomNode start="(329, 9)" end="(329, 13)" leading="" trailing=" " val="have"/>
                                                      <OtherNode start="(329, 14)" end="(329, 61)" kind="Lean.Parser.Term.haveDecl">
                                                        <OtherNode start="(329, 14)" end="(329, 61)" kind="Lean.Parser.Term.haveIdDecl">
                                                          <OtherNode start="(329, 14)" end="(329, 14)" kind="Lean.Parser.Term.haveId">
                                                            <OtherNode start="(329, 14)" end="(329, 14)" kind="hygieneInfo">
                                                            <IdentNode start="(329, 14)" end="(329, 14)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode start="(329, 14)" end="(329, 49)">
                                                            <TermTypespecNode start="(329, 14)" end="(329, 49)">
                                                            <AtomNode start="(329, 14)" end="(329, 15)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(329, 16)" end="(329, 49)" kind="«term_&amp;lt;_»">
                                                            <OtherNode start="(329, 16)" end="(329, 34)" kind="«term_-_»">
                                                            <IdentNode start="(329, 16)" end="(329, 24)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                                            <AtomNode start="(329, 25)" end="(329, 26)" leading="" trailing=" " val="-"/>
                                                            <OtherNode start="(329, 27)" end="(329, 34)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(329, 27)" end="(329, 28)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(329, 28)" end="(329, 33)" kind="«term_+_»">
                                                            <IdentNode start="(329, 28)" end="(329, 29)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            <AtomNode start="(329, 30)" end="(329, 31)" leading="" trailing=" " val="+"/>
                                                            <OtherNode start="(329, 32)" end="(329, 33)" kind="num">
                                                            <AtomNode start="(329, 32)" end="(329, 33)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(329, 33)" end="(329, 34)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(329, 35)" end="(329, 36)" leading="" trailing=" " val="&amp;lt;"/>
                                                            <OtherNode start="(329, 37)" end="(329, 49)" kind="«term_-_»">
                                                            <IdentNode start="(329, 37)" end="(329, 45)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                                            <AtomNode start="(329, 46)" end="(329, 47)" leading="" trailing=" " val="-"/>
                                                            <IdentNode start="(329, 48)" end="(329, 49)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                          </NullNode>
                                                          <AtomNode start="(329, 50)" end="(329, 52)" leading="" trailing=" " val=":="/>
                                                          <TermBytacticNode start="(329, 53)" end="(329, 61)">
                                                            <AtomNode start="(329, 53)" end="(329, 55)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(329, 56)" end="(329, 61)">
                                                            <TacticTacticseq1IndentedNode start="(329, 56)" end="(329, 61)">
                                                            <NullNode start="(329, 56)" end="(329, 61)">
                                                            <OtherNode start="(329, 56)" end="(329, 61)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : l'.length + 1 + j = l.length&#10;h' : j &amp;lt; l.length&#10;this : l[j] = b&#10;h✝ : ¬(b == a) = true&#10;⊢ l.length - (j + 1) &amp;lt; l.length - j" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(329, 56)" end="(329, 61)" leading="" trailing="&#10;        " val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </TermBytacticNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(330, 9)" end="(330, 30)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue.cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : l'.length + 1 + j = l.length&#10;h' : j &amp;lt; l.length&#10;this✝ : l[j] = b&#10;h✝ : ¬(b == a) = true&#10;this : l.length - (j + 1) &amp;lt; l.length - j&#10;⊢ l.toArray.idxOfAux a (j + 1) = findFinIdx?.go (fun x =&amp;gt; x == a) l l' (j + 1) ⋯" state_after="case isTrue.cons.isFalse.w&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : l'.length + 1 + j = l.length&#10;h' : j &amp;lt; l.length&#10;this✝ : l[j] = b&#10;h✝ : ¬(b == a) = true&#10;this : l.length - (j + 1) &amp;lt; l.length - j&#10;⊢ l' = drop (j + 1) l" tactic="rw [idxAuxOf_toArray]">
                                                      <AtomNode start="(330, 9)" end="(330, 11)" leading="" trailing=" " val="rw"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <OtherNode start="(330, 12)" end="(330, 30)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                        <AtomNode start="(330, 12)" end="(330, 13)" leading="" trailing="" val="["/>
                                                        <NullNode start="(330, 13)" end="(330, 29)">
                                                          <OtherNode start="(330, 13)" end="(330, 29)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(330, 13)" end="(330, 29)" leading="" trailing="" raw_val="idxAuxOf_toArray" val="idxAuxOf_toArray" full_name="PSigma.Lex.left" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(330, 29)" end="(330, 30)" leading="" trailing="&#10;        " val="]"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(331, 9)" end="(331, 55)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue.cons.isFalse.w&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h'✝ : j &amp;lt; l.toArray.size&#10;b : α&#10;l' : List α&#10;w : b :: l' = drop j l&#10;h : l'.length + 1 + j = l.length&#10;h' : j &amp;lt; l.length&#10;this✝ : l[j] = b&#10;h✝ : ¬(b == a) = true&#10;this : l.length - (j + 1) &amp;lt; l.length - j&#10;⊢ l' = drop (j + 1) l" state_after="no goals" tactic="rw [drop_add_one_eq_tail_drop, ← w, tail_cons]">
                                                      <AtomNode start="(331, 9)" end="(331, 11)" leading="" trailing=" " val="rw"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <OtherNode start="(331, 12)" end="(331, 55)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                        <AtomNode start="(331, 12)" end="(331, 13)" leading="" trailing="" val="["/>
                                                        <NullNode start="(331, 13)" end="(331, 54)">
                                                          <OtherNode start="(331, 13)" end="(331, 38)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(331, 13)" end="(331, 38)" leading="" trailing="" raw_val="drop_add_one_eq_tail_drop" val="drop_add_one_eq_tail_drop" full_name="List.drop_add_one_eq_tail_drop" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                          </OtherNode>
                                                          <AtomNode start="(331, 38)" end="(331, 39)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(331, 40)" end="(331, 43)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(331, 40)" end="(331, 41)">
                                                            <OtherNode start="(331, 40)" end="(331, 41)" kind="patternIgnore">
                                                            <OtherNode start="(331, 40)" end="(331, 41)" kind="token.«← »">
                                                            <AtomNode start="(331, 40)" end="(331, 41)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(331, 42)" end="(331, 43)" leading="" trailing="" raw_val="w" val="w"/>
                                                          </OtherNode>
                                                          <AtomNode start="(331, 43)" end="(331, 44)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(331, 45)" end="(331, 54)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(331, 45)" end="(331, 54)" leading="" trailing="" raw_val="tail_cons" val="tail_cons" full_name="List.tail_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(331, 54)" end="(331, 55)" leading="" trailing="&#10;  " val="]"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(332, 3)" end="(334, 9)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;h' : ¬j &amp;lt; l.toArray.size&#10;⊢ none =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" state_after="no goals" tactic="· have : l' = [] := by simp_all&#10;  subst this&#10;  simp">
                    <OtherNode start="(332, 3)" end="(332, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(332, 3)" end="(332, 4)" kind="patternIgnore">
                        <OtherNode start="(332, 3)" end="(332, 4)" kind="token.«· »">
                          <AtomNode start="(332, 3)" end="(332, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(332, 5)" end="(334, 9)">
                      <TacticTacticseq1IndentedNode start="(332, 5)" end="(334, 9)">
                        <NullNode start="(332, 5)" end="(334, 9)">
                          <OtherNode start="(332, 5)" end="(332, 34)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case isFalse&#10;α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;h' : ¬j &amp;lt; l.toArray.size&#10;⊢ none =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" state_after="case isFalse&#10;α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;h' : ¬j &amp;lt; l.toArray.size&#10;this : l' = []&#10;⊢ none =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" tactic="have : l' = [] := by simp_all">
                            <AtomNode start="(332, 5)" end="(332, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(332, 10)" end="(332, 34)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(332, 10)" end="(332, 34)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(332, 10)" end="(332, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(332, 10)" end="(332, 10)" kind="hygieneInfo">
                                    <IdentNode start="(332, 10)" end="(332, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(332, 10)" end="(332, 19)">
                                  <TermTypespecNode start="(332, 10)" end="(332, 19)">
                                    <AtomNode start="(332, 10)" end="(332, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(332, 12)" end="(332, 19)" kind="«term_=_»">
                                      <IdentNode start="(332, 12)" end="(332, 14)" leading="" trailing=" " raw_val="l'" val="l'"/>
                                      <AtomNode start="(332, 15)" end="(332, 16)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(332, 17)" end="(332, 19)" kind="«term[_]»">
                                        <AtomNode start="(332, 17)" end="(332, 18)" leading="" trailing="" val="["/>
                                        <NullNode/>
                                        <AtomNode start="(332, 18)" end="(332, 19)" leading="" trailing=" " val="]"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(332, 20)" end="(332, 22)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(332, 23)" end="(332, 34)">
                                  <AtomNode start="(332, 23)" end="(332, 25)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(332, 26)" end="(332, 34)">
                                    <TacticTacticseq1IndentedNode start="(332, 26)" end="(332, 34)">
                                      <NullNode start="(332, 26)" end="(332, 34)">
                                        <OtherNode start="(332, 26)" end="(332, 34)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;h' : ¬j &amp;lt; l.toArray.size&#10;⊢ l' = []" state_after="no goals" tactic="simp_all">
                                          <AtomNode start="(332, 26)" end="(332, 34)" leading="" trailing="&#10;    " val="simp_all"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(333, 5)" end="(333, 15)" kind="Lean.Parser.Tactic.subst" state_before="case isFalse&#10;α : Type u_1&#10;l' : List α&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;w : l' = drop j l&#10;h : l'.length + j = l.length&#10;h' : ¬j &amp;lt; l.toArray.size&#10;this : l' = []&#10;⊢ none =&#10;    match l', j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" state_after="case isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h' : ¬j &amp;lt; l.toArray.size&#10;w : [] = drop j l&#10;h : [].length + j = l.length&#10;⊢ none =&#10;    match [], j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" tactic="subst this">
                            <AtomNode start="(333, 5)" end="(333, 10)" leading="" trailing=" " val="subst"/>
                            <NullNode start="(333, 11)" end="(333, 15)">
                              <IdentNode start="(333, 11)" end="(333, 15)" leading="" trailing="&#10;    " raw_val="this" val="this"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(334, 5)" end="(334, 9)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;j : Nat&#10;h' : ¬j &amp;lt; l.toArray.size&#10;w : [] = drop j l&#10;h : [].length + j = l.length&#10;⊢ none =&#10;    match [], j, h with&#10;    | [], x, x_1 =&amp;gt; none&#10;    | a_1 :: l_1, i, h =&amp;gt; if (a_1 == a) = true then some ⟨i, ⋯⟩ else findFinIdx?.go (fun x =&amp;gt; x == a) l l_1 (i + 1) ⋯" state_after="no goals" tactic="simp">
                            <AtomNode start="(334, 5)" end="(334, 9)" leading="" trailing="&#10;" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode start="(335, 1)" end="(335, 28)" kind="Lean.Parser.Termination.suffix">
            <NullNode start="(335, 1)" end="(335, 28)">
              <OtherNode start="(335, 1)" end="(335, 28)" kind="Lean.Parser.Termination.terminationBy">
                <AtomNode start="(335, 1)" end="(335, 15)" leading="" trailing=" " val="termination_by"/>
                <NullNode/>
                <NullNode/>
                <OtherNode start="(335, 16)" end="(335, 28)" kind="«term_-_»">
                  <IdentNode start="(335, 16)" end="(335, 24)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                  <AtomNode start="(335, 25)" end="(335, 26)" leading="" trailing=" " val="-"/>
                  <IdentNode start="(335, 27)" end="(335, 28)" leading="" trailing="&#10;&#10;" raw_val="j" val="j"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(337, 1)" end="(340, 26)" name="finIdxOf?_toArray" full_name="List.finIdxOf?_toArray">
      <CommandDeclmodifiersNode start="(337, 1)" end="(337, 8)">
        <NullNode/>
        <NullNode start="(337, 1)" end="(337, 8)">
          <OtherNode start="(337, 1)" end="(337, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(337, 1)" end="(337, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(337, 3)" end="(337, 7)">
              <OtherNode start="(337, 3)" end="(337, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(337, 3)" end="(337, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(337, 3)" end="(337, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(337, 7)" end="(337, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(337, 9)" end="(340, 26)" name="finIdxOf?_toArray" full_name="List.finIdxOf?_toArray" _is_private_decl="False">
        <AtomNode start="(337, 9)" end="(337, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(337, 17)" end="(337, 34)">
          <IdentNode start="(337, 17)" end="(337, 34)" leading="" trailing=" " raw_val="finIdxOf?_toArray" val="finIdxOf?_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(337, 35)" end="(338, 42)">
          <NullNode start="(337, 35)" end="(337, 63)">
            <OtherNode start="(337, 35)" end="(337, 42)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(337, 35)" end="(337, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(337, 36)" end="(337, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(337, 36)" end="(337, 39)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(337, 40)" end="(337, 41)">
                  <IdentNode start="(337, 40)" end="(337, 41)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(337, 41)" end="(337, 42)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(337, 43)" end="(337, 50)">
              <AtomNode start="(337, 43)" end="(337, 44)" leading="" trailing="" val="("/>
              <NullNode start="(337, 44)" end="(337, 45)">
                <IdentNode start="(337, 44)" end="(337, 45)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(337, 46)" end="(337, 49)">
                <AtomNode start="(337, 46)" end="(337, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(337, 48)" end="(337, 49)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(337, 49)" end="(337, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(337, 51)" end="(337, 63)">
              <AtomNode start="(337, 51)" end="(337, 52)" leading="" trailing="" val="("/>
              <NullNode start="(337, 52)" end="(337, 53)">
                <IdentNode start="(337, 52)" end="(337, 53)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(337, 54)" end="(337, 62)">
                <AtomNode start="(337, 54)" end="(337, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(337, 56)" end="(337, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(337, 56)" end="(337, 60)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(337, 61)" end="(337, 62)">
                    <IdentNode start="(337, 61)" end="(337, 62)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(337, 62)" end="(337, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(337, 64)" end="(338, 42)">
            <AtomNode start="(337, 64)" end="(337, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(338, 5)" end="(338, 42)" kind="«term_=_»">
              <OtherNode start="(338, 5)" end="(338, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(338, 5)" end="(338, 24)" leading="" trailing=" " raw_val="l.toArray.finIdxOf?" val="l.toArray.finIdxOf?"/>
                <NullNode start="(338, 25)" end="(338, 26)">
                  <IdentNode start="(338, 25)" end="(338, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(338, 27)" end="(338, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(338, 29)" end="(338, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(338, 29)" end="(338, 40)" leading="" trailing=" " raw_val="l.finIdxOf?" val="l.finIdxOf?"/>
                <NullNode start="(338, 41)" end="(338, 42)">
                  <IdentNode start="(338, 41)" end="(338, 42)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(338, 43)" end="(340, 26)">
          <AtomNode start="(338, 43)" end="(338, 45)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(338, 46)" end="(340, 26)">
            <AtomNode start="(338, 46)" end="(338, 48)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(339, 3)" end="(340, 26)">
              <TacticTacticseq1IndentedNode start="(339, 3)" end="(340, 26)">
                <NullNode start="(339, 3)" end="(340, 26)">
                  <OtherNode start="(339, 3)" end="(339, 47)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;⊢ l.toArray.finIdxOf? a = finIdxOf? a l" state_after="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;⊢ l.toArray.idxOfAux a 0 = findFinIdx?.go (fun x =&amp;gt; x == a) l l 0 ⋯" tactic="rw [Array.finIdxOf?, finIdxOf?, findFinIdx?]">
                    <AtomNode start="(339, 3)" end="(339, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(339, 6)" end="(339, 47)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(339, 6)" end="(339, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(339, 7)" end="(339, 46)">
                        <OtherNode start="(339, 7)" end="(339, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(339, 7)" end="(339, 22)" leading="" trailing="" raw_val="Array.finIdxOf?" val="Array.finIdxOf?" full_name="Array.finIdxOf?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(339, 22)" end="(339, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(339, 24)" end="(339, 33)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(339, 24)" end="(339, 33)" leading="" trailing="" raw_val="finIdxOf?" val="finIdxOf?" full_name="List.finIdxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(339, 33)" end="(339, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(339, 35)" end="(339, 46)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(339, 35)" end="(339, 46)" leading="" trailing="" raw_val="findFinIdx?" val="findFinIdx?" full_name="List.findFinIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(339, 46)" end="(339, 47)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(340, 3)" end="(340, 26)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;⊢ l.toArray.idxOfAux a 0 = findFinIdx?.go (fun x =&amp;gt; x == a) l l 0 ⋯" state_after="no goals" tactic="simp [idxAuxOf_toArray]">
                    <AtomNode start="(340, 3)" end="(340, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(340, 8)" end="(340, 26)">
                      <AtomNode start="(340, 8)" end="(340, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(340, 9)" end="(340, 25)">
                        <OtherNode start="(340, 9)" end="(340, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(340, 9)" end="(340, 25)" leading="" trailing="" raw_val="idxAuxOf_toArray" val="idxAuxOf_toArray" full_name="_private.Init.Data.List.ToArray.0.List.idxAuxOf_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(310, 17)" def_end="(310, 33)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(340, 25)" end="(340, 26)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(342, 1)" end="(345, 52)" name="idxOf?_toArray" full_name="List.idxOf?_toArray">
      <CommandDeclmodifiersNode start="(342, 1)" end="(342, 8)">
        <NullNode/>
        <NullNode start="(342, 1)" end="(342, 8)">
          <OtherNode start="(342, 1)" end="(342, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(342, 1)" end="(342, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(342, 3)" end="(342, 7)">
              <OtherNode start="(342, 3)" end="(342, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(342, 3)" end="(342, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(342, 3)" end="(342, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(342, 7)" end="(342, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(342, 9)" end="(345, 52)" name="idxOf?_toArray" full_name="List.idxOf?_toArray" _is_private_decl="False">
        <AtomNode start="(342, 9)" end="(342, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(342, 17)" end="(342, 31)">
          <IdentNode start="(342, 17)" end="(342, 31)" leading="" trailing=" " raw_val="idxOf?_toArray" val="idxOf?_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(342, 32)" end="(343, 36)">
          <NullNode start="(342, 32)" end="(342, 60)">
            <OtherNode start="(342, 32)" end="(342, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(342, 32)" end="(342, 33)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(342, 33)" end="(342, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(342, 33)" end="(342, 36)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(342, 37)" end="(342, 38)">
                  <IdentNode start="(342, 37)" end="(342, 38)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(342, 38)" end="(342, 39)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(342, 40)" end="(342, 47)">
              <AtomNode start="(342, 40)" end="(342, 41)" leading="" trailing="" val="("/>
              <NullNode start="(342, 41)" end="(342, 42)">
                <IdentNode start="(342, 41)" end="(342, 42)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(342, 43)" end="(342, 46)">
                <AtomNode start="(342, 43)" end="(342, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(342, 45)" end="(342, 46)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(342, 46)" end="(342, 47)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(342, 48)" end="(342, 60)">
              <AtomNode start="(342, 48)" end="(342, 49)" leading="" trailing="" val="("/>
              <NullNode start="(342, 49)" end="(342, 50)">
                <IdentNode start="(342, 49)" end="(342, 50)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(342, 51)" end="(342, 59)">
                <AtomNode start="(342, 51)" end="(342, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(342, 53)" end="(342, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(342, 53)" end="(342, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(342, 58)" end="(342, 59)">
                    <IdentNode start="(342, 58)" end="(342, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(342, 59)" end="(342, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(342, 61)" end="(343, 36)">
            <AtomNode start="(342, 61)" end="(342, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(343, 5)" end="(343, 36)" kind="«term_=_»">
              <OtherNode start="(343, 5)" end="(343, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(343, 5)" end="(343, 21)" leading="" trailing=" " raw_val="l.toArray.idxOf?" val="l.toArray.idxOf?"/>
                <NullNode start="(343, 22)" end="(343, 23)">
                  <IdentNode start="(343, 22)" end="(343, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(343, 24)" end="(343, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(343, 26)" end="(343, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(343, 26)" end="(343, 34)" leading="" trailing=" " raw_val="l.idxOf?" val="l.idxOf?"/>
                <NullNode start="(343, 35)" end="(343, 36)">
                  <IdentNode start="(343, 35)" end="(343, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(343, 37)" end="(345, 52)">
          <AtomNode start="(343, 37)" end="(343, 39)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(343, 40)" end="(345, 52)">
            <AtomNode start="(343, 40)" end="(343, 42)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(344, 3)" end="(345, 52)">
              <TacticTacticseq1IndentedNode start="(344, 3)" end="(345, 52)">
                <NullNode start="(344, 3)" end="(345, 52)">
                  <OtherNode start="(344, 3)" end="(344, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;⊢ l.toArray.idxOf? a = idxOf? a l" state_after="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;⊢ Option.map (fun x =&amp;gt; ↑x) (l.toArray.finIdxOf? a) = findIdx? (fun x =&amp;gt; x == a) l" tactic="rw [Array.idxOf?, idxOf?]">
                    <AtomNode start="(344, 3)" end="(344, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(344, 6)" end="(344, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(344, 6)" end="(344, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(344, 7)" end="(344, 27)">
                        <OtherNode start="(344, 7)" end="(344, 19)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(344, 7)" end="(344, 19)" leading="" trailing="" raw_val="Array.idxOf?" val="Array.idxOf?" full_name="Array.idxOf?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(344, 19)" end="(344, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(344, 21)" end="(344, 27)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(344, 21)" end="(344, 27)" leading="" trailing="" raw_val="idxOf?" val="idxOf?" full_name="List.idxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(344, 27)" end="(344, 28)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(345, 3)" end="(345, 52)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;⊢ Option.map (fun x =&amp;gt; ↑x) (l.toArray.finIdxOf? a) = findIdx? (fun x =&amp;gt; x == a) l" state_after="no goals" tactic="simp [finIdxOf?, findIdx?_eq_map_findFinIdx?_val]">
                    <AtomNode start="(345, 3)" end="(345, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(345, 8)" end="(345, 52)">
                      <AtomNode start="(345, 8)" end="(345, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(345, 9)" end="(345, 51)">
                        <OtherNode start="(345, 9)" end="(345, 18)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(345, 9)" end="(345, 18)" leading="" trailing="" raw_val="finIdxOf?" val="finIdxOf?" full_name="List.finIdxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(345, 18)" end="(345, 19)" leading="" trailing=" " val=","/>
                        <OtherNode start="(345, 20)" end="(345, 51)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(345, 20)" end="(345, 51)" leading="" trailing="" raw_val="findIdx?_eq_map_findFinIdx?_val" val="findIdx?_eq_map_findFinIdx?_val" full_name="List.findIdx?_eq_map_findFinIdx?_val" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(345, 51)" end="(345, 52)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(347, 1)" end="(349, 65)" name="findIdx_toArray" full_name="List.findIdx_toArray">
      <CommandDeclmodifiersNode start="(347, 1)" end="(347, 8)">
        <NullNode/>
        <NullNode start="(347, 1)" end="(347, 8)">
          <OtherNode start="(347, 1)" end="(347, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(347, 1)" end="(347, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(347, 3)" end="(347, 7)">
              <OtherNode start="(347, 3)" end="(347, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(347, 3)" end="(347, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(347, 3)" end="(347, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(347, 7)" end="(347, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(347, 9)" end="(349, 65)" name="findIdx_toArray" full_name="List.findIdx_toArray" _is_private_decl="False">
        <AtomNode start="(347, 9)" end="(347, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(347, 17)" end="(347, 32)">
          <IdentNode start="(347, 17)" end="(347, 32)" leading="" trailing=" " raw_val="findIdx_toArray" val="findIdx_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(347, 33)" end="(348, 40)">
          <NullNode start="(347, 33)" end="(347, 61)">
            <OtherNode start="(347, 33)" end="(347, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(347, 33)" end="(347, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(347, 34)" end="(347, 36)">
                <IdentNode start="(347, 34)" end="(347, 36)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(347, 37)" end="(347, 45)">
                <AtomNode start="(347, 37)" end="(347, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(347, 39)" end="(347, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(347, 39)" end="(347, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(347, 44)" end="(347, 45)">
                    <IdentNode start="(347, 44)" end="(347, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(347, 45)" end="(347, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(347, 47)" end="(347, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(347, 47)" end="(347, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(347, 48)" end="(347, 49)">
                <IdentNode start="(347, 48)" end="(347, 49)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(347, 50)" end="(347, 60)">
                <AtomNode start="(347, 50)" end="(347, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(347, 52)" end="(347, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(347, 52)" end="(347, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(347, 54)" end="(347, 55)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(347, 56)" end="(347, 60)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(347, 60)" end="(347, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(347, 62)" end="(348, 40)">
            <AtomNode start="(347, 62)" end="(347, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(348, 5)" end="(348, 40)" kind="«term_=_»">
              <OtherNode start="(348, 5)" end="(348, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(348, 5)" end="(348, 23)" leading="" trailing=" " raw_val="as.toArray.findIdx" val="as.toArray.findIdx"/>
                <NullNode start="(348, 24)" end="(348, 25)">
                  <IdentNode start="(348, 24)" end="(348, 25)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(348, 26)" end="(348, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(348, 28)" end="(348, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(348, 28)" end="(348, 38)" leading="" trailing=" " raw_val="as.findIdx" val="as.findIdx"/>
                <NullNode start="(348, 39)" end="(348, 40)">
                  <IdentNode start="(348, 39)" end="(348, 40)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(348, 41)" end="(349, 65)">
          <AtomNode start="(348, 41)" end="(348, 43)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(348, 44)" end="(349, 65)">
            <AtomNode start="(348, 44)" end="(348, 46)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(349, 3)" end="(349, 65)">
              <TacticTacticseq1IndentedNode start="(349, 3)" end="(349, 65)">
                <NullNode start="(349, 3)" end="(349, 65)">
                  <OtherNode start="(349, 3)" end="(349, 65)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;as : List α&#10;p : α → Bool&#10;⊢ Array.findIdx p as.toArray = findIdx p as" state_after="no goals" tactic="rw [Array.findIdx, findIdx?_toArray, findIdx_eq_getD_findIdx?]">
                    <AtomNode start="(349, 3)" end="(349, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(349, 6)" end="(349, 65)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(349, 6)" end="(349, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(349, 7)" end="(349, 64)">
                        <OtherNode start="(349, 7)" end="(349, 20)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(349, 7)" end="(349, 20)" leading="" trailing="" raw_val="Array.findIdx" val="Array.findIdx" full_name="Array.findIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(349, 20)" end="(349, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(349, 22)" end="(349, 38)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(349, 22)" end="(349, 38)" leading="" trailing="" raw_val="findIdx?_toArray" val="findIdx?_toArray" full_name="List.findIdx?_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(305, 17)" def_end="(305, 33)"/>
                        </OtherNode>
                        <AtomNode start="(349, 38)" end="(349, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(349, 40)" end="(349, 64)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(349, 40)" end="(349, 64)" leading="" trailing="" raw_val="findIdx_eq_getD_findIdx?" val="findIdx_eq_getD_findIdx?" full_name="List.findIdx_eq_getD_findIdx?" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(349, 64)" end="(349, 65)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(351, 1)" end="(353, 43)" name="idxOf_toArray" full_name="List.idxOf_toArray">
      <CommandDeclmodifiersNode start="(351, 1)" end="(351, 8)">
        <NullNode/>
        <NullNode start="(351, 1)" end="(351, 8)">
          <OtherNode start="(351, 1)" end="(351, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(351, 1)" end="(351, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(351, 3)" end="(351, 7)">
              <OtherNode start="(351, 3)" end="(351, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(351, 3)" end="(351, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(351, 3)" end="(351, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(351, 7)" end="(351, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(351, 9)" end="(353, 43)" name="idxOf_toArray" full_name="List.idxOf_toArray" _is_private_decl="False">
        <AtomNode start="(351, 9)" end="(351, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(351, 17)" end="(351, 30)">
          <IdentNode start="(351, 17)" end="(351, 30)" leading="" trailing=" " raw_val="idxOf_toArray" val="idxOf_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(351, 31)" end="(352, 36)">
          <NullNode start="(351, 31)" end="(351, 60)">
            <OtherNode start="(351, 31)" end="(351, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(351, 31)" end="(351, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(351, 32)" end="(351, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(351, 32)" end="(351, 35)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(351, 36)" end="(351, 37)">
                  <IdentNode start="(351, 36)" end="(351, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(351, 37)" end="(351, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(351, 39)" end="(351, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(351, 39)" end="(351, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(351, 40)" end="(351, 42)">
                <IdentNode start="(351, 40)" end="(351, 42)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(351, 43)" end="(351, 51)">
                <AtomNode start="(351, 43)" end="(351, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(351, 45)" end="(351, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(351, 45)" end="(351, 49)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(351, 50)" end="(351, 51)">
                    <IdentNode start="(351, 50)" end="(351, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(351, 51)" end="(351, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(351, 53)" end="(351, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(351, 53)" end="(351, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(351, 54)" end="(351, 55)">
                <IdentNode start="(351, 54)" end="(351, 55)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(351, 56)" end="(351, 59)">
                <AtomNode start="(351, 56)" end="(351, 57)" leading="" trailing=" " val=":"/>
                <IdentNode start="(351, 58)" end="(351, 59)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(351, 59)" end="(351, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(351, 61)" end="(352, 36)">
            <AtomNode start="(351, 61)" end="(351, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(352, 5)" end="(352, 36)" kind="«term_=_»">
              <OtherNode start="(352, 5)" end="(352, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(352, 5)" end="(352, 21)" leading="" trailing=" " raw_val="as.toArray.idxOf" val="as.toArray.idxOf"/>
                <NullNode start="(352, 22)" end="(352, 23)">
                  <IdentNode start="(352, 22)" end="(352, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(352, 24)" end="(352, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(352, 26)" end="(352, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(352, 26)" end="(352, 34)" leading="" trailing=" " raw_val="as.idxOf" val="as.idxOf"/>
                <NullNode start="(352, 35)" end="(352, 36)">
                  <IdentNode start="(352, 35)" end="(352, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(352, 37)" end="(353, 43)">
          <AtomNode start="(352, 37)" end="(352, 39)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(352, 40)" end="(353, 43)">
            <AtomNode start="(352, 40)" end="(352, 42)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(353, 3)" end="(353, 43)">
              <TacticTacticseq1IndentedNode start="(353, 3)" end="(353, 43)">
                <NullNode start="(353, 3)" end="(353, 43)">
                  <OtherNode start="(353, 3)" end="(353, 43)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;as : List α&#10;a : α&#10;⊢ Array.idxOf a as.toArray = idxOf a as" state_after="no goals" tactic="rw [Array.idxOf, findIdx_toArray, idxOf]">
                    <AtomNode start="(353, 3)" end="(353, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(353, 6)" end="(353, 43)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(353, 6)" end="(353, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(353, 7)" end="(353, 42)">
                        <OtherNode start="(353, 7)" end="(353, 18)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(353, 7)" end="(353, 18)" leading="" trailing="" raw_val="Array.idxOf" val="Array.idxOf" full_name="Array.idxOf" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(353, 18)" end="(353, 19)" leading="" trailing=" " val=","/>
                        <OtherNode start="(353, 20)" end="(353, 35)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(353, 20)" end="(353, 35)" leading="" trailing="" raw_val="findIdx_toArray" val="findIdx_toArray" full_name="List.findIdx_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(347, 17)" def_end="(347, 32)"/>
                        </OtherNode>
                        <AtomNode start="(353, 35)" end="(353, 36)" leading="" trailing=" " val=","/>
                        <OtherNode start="(353, 37)" end="(353, 42)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(353, 37)" end="(353, 42)" leading="" trailing="" raw_val="idxOf" val="idxOf" full_name="List.idxOf" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(353, 42)" end="(353, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(355, 1)" end="(365, 8)" name="isPrefixOfAux_toArray_succ" full_name="List.isPrefixOfAux_toArray_succ">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(355, 1)" end="(365, 8)" name="isPrefixOfAux_toArray_succ" full_name="List.isPrefixOfAux_toArray_succ" _is_private_decl="False">
        <AtomNode start="(355, 1)" end="(355, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(355, 9)" end="(355, 35)">
          <IdentNode start="(355, 9)" end="(355, 35)" leading="" trailing=" " raw_val="isPrefixOfAux_toArray_succ" val="isPrefixOfAux_toArray_succ"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(355, 36)" end="(357, 77)">
          <NullNode start="(355, 36)" end="(355, 100)">
            <OtherNode start="(355, 36)" end="(355, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(355, 36)" end="(355, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(355, 37)" end="(355, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(355, 37)" end="(355, 40)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(355, 41)" end="(355, 42)">
                  <IdentNode start="(355, 41)" end="(355, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(355, 42)" end="(355, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(355, 44)" end="(355, 60)">
              <AtomNode start="(355, 44)" end="(355, 45)" leading="" trailing="" val="("/>
              <NullNode start="(355, 45)" end="(355, 50)">
                <IdentNode start="(355, 45)" end="(355, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(355, 48)" end="(355, 50)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(355, 51)" end="(355, 59)">
                <AtomNode start="(355, 51)" end="(355, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(355, 53)" end="(355, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(355, 53)" end="(355, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(355, 58)" end="(355, 59)">
                    <IdentNode start="(355, 58)" end="(355, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(355, 59)" end="(355, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(355, 61)" end="(355, 90)">
              <AtomNode start="(355, 61)" end="(355, 62)" leading="" trailing="" val="("/>
              <NullNode start="(355, 62)" end="(355, 65)">
                <IdentNode start="(355, 62)" end="(355, 65)" leading="" trailing=" " raw_val="hle" val="hle"/>
              </NullNode>
              <NullNode start="(355, 66)" end="(355, 89)">
                <AtomNode start="(355, 66)" end="(355, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(355, 68)" end="(355, 89)" kind="«term_≤_»">
                  <IdentNode start="(355, 68)" end="(355, 77)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                  <AtomNode start="(355, 78)" end="(355, 79)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(355, 80)" end="(355, 89)" leading="" trailing="" raw_val="l₂.length" val="l₂.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(355, 89)" end="(355, 90)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(355, 91)" end="(355, 100)">
              <AtomNode start="(355, 91)" end="(355, 92)" leading="" trailing="" val="("/>
              <NullNode start="(355, 92)" end="(355, 93)">
                <IdentNode start="(355, 92)" end="(355, 93)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(355, 94)" end="(355, 99)">
                <AtomNode start="(355, 94)" end="(355, 95)" leading="" trailing=" " val=":"/>
                <IdentNode start="(355, 96)" end="(355, 99)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(355, 99)" end="(355, 100)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(355, 101)" end="(357, 77)">
            <AtomNode start="(355, 101)" end="(355, 102)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(356, 5)" end="(357, 77)" kind="«term_=_»">
              <OtherNode start="(356, 5)" end="(356, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(356, 5)" end="(356, 24)" leading="" trailing=" " raw_val="Array.isPrefixOfAux" val="Array.isPrefixOfAux" full_name="Array.isPrefixOfAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(356, 25)" end="(356, 58)">
                  <IdentNode start="(356, 25)" end="(356, 35)" leading="" trailing=" " raw_val="l₁.toArray" val="l₁.toArray"/>
                  <IdentNode start="(356, 36)" end="(356, 46)" leading="" trailing=" " raw_val="l₂.toArray" val="l₂.toArray"/>
                  <IdentNode start="(356, 47)" end="(356, 50)" leading="" trailing=" " raw_val="hle" val="hle"/>
                  <OtherNode start="(356, 51)" end="(356, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(356, 51)" end="(356, 52)" leading="" trailing="" val="("/>
                    <OtherNode start="(356, 52)" end="(356, 57)" kind="«term_+_»">
                      <IdentNode start="(356, 52)" end="(356, 53)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(356, 54)" end="(356, 55)" leading="" trailing=" " val="+"/>
                      <OtherNode start="(356, 56)" end="(356, 57)" kind="num">
                        <AtomNode start="(356, 56)" end="(356, 57)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(356, 57)" end="(356, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(356, 59)" end="(356, 60)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(357, 7)" end="(357, 77)" kind="Lean.Parser.Term.app">
                <IdentNode start="(357, 7)" end="(357, 26)" leading="" trailing=" " raw_val="Array.isPrefixOfAux" val="Array.isPrefixOfAux" full_name="Array.isPrefixOfAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(357, 27)" end="(357, 77)">
                  <IdentNode start="(357, 27)" end="(357, 42)" leading="" trailing=" " raw_val="l₁.tail.toArray" val="l₁.tail.toArray"/>
                  <IdentNode start="(357, 43)" end="(357, 58)" leading="" trailing=" " raw_val="l₂.tail.toArray" val="l₂.tail.toArray"/>
                  <OtherNode start="(357, 59)" end="(357, 75)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(357, 59)" end="(357, 60)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(357, 60)" end="(357, 74)">
                      <AtomNode start="(357, 60)" end="(357, 62)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(357, 63)" end="(357, 74)">
                        <TacticTacticseq1IndentedNode start="(357, 63)" end="(357, 74)">
                          <NullNode start="(357, 63)" end="(357, 74)">
                            <OtherNode start="(357, 63)" end="(357, 67)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.63438&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;⊢ l₁.tail.toArray.size ≤ l₂.tail.toArray.size" state_after="α : Type ?u.63438&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;⊢ l₁.length ≤ l₂.length - 1 + 1" tactic="simp">
                              <AtomNode start="(357, 63)" end="(357, 67)" leading="" trailing="" val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(357, 67)" end="(357, 68)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(357, 69)" end="(357, 74)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.63438&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;⊢ l₁.length ≤ l₂.length - 1 + 1" state_after="no goals" tactic="omega">
                              <AtomNode start="(357, 69)" end="(357, 74)" leading="" trailing="" val="omega"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(357, 74)" end="(357, 75)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(357, 76)" end="(357, 77)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(357, 78)" end="(365, 8)">
          <AtomNode start="(357, 78)" end="(357, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(357, 81)" end="(365, 8)">
            <AtomNode start="(357, 81)" end="(357, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(358, 3)" end="(365, 8)">
              <TacticTacticseq1IndentedNode start="(358, 3)" end="(365, 8)">
                <NullNode start="(358, 3)" end="(365, 8)">
                  <OtherNode start="(358, 3)" end="(358, 27)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;⊢ l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1) = l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ i" state_after="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;⊢ (if h : i + 1 &amp;lt; l₁.toArray.size then&#10;      let a := l₁.toArray[i + 1];&#10;      let_fun this := ⋯;&#10;      let b := l₂.toArray[i + 1];&#10;      if (a == b) = true then l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1) else false&#10;    else true) =&#10;    l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ i" tactic="rw [Array.isPrefixOfAux]">
                    <AtomNode start="(358, 3)" end="(358, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(358, 6)" end="(358, 27)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(358, 6)" end="(358, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(358, 7)" end="(358, 26)">
                        <OtherNode start="(358, 7)" end="(358, 26)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(358, 7)" end="(358, 26)" leading="" trailing="" raw_val="Array.isPrefixOfAux" val="Array.isPrefixOfAux" full_name="Array.isPrefixOfAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(358, 26)" end="(358, 27)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(359, 3)" end="(359, 40)" kind="Lean.Parser.Tactic.Conv.conv" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;⊢ (if h : i + 1 &amp;lt; l₁.toArray.size then&#10;      let a := l₁.toArray[i + 1];&#10;      let_fun this := ⋯;&#10;      let b := l₂.toArray[i + 1];&#10;      if (a == b) = true then l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1) else false&#10;    else true) =&#10;    l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ i" state_after="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;⊢ (if h : i + 1 &amp;lt; l₁.toArray.size then&#10;      let a := l₁.toArray[i + 1];&#10;      let_fun this := ⋯;&#10;      let b := l₂.toArray[i + 1];&#10;      if (a == b) = true then l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1) else false&#10;    else true) =&#10;    if h : i &amp;lt; l₁.tail.toArray.size then&#10;      let a := l₁.tail.toArray[i];&#10;      let_fun this := ⋯;&#10;      let b := l₂.tail.toArray[i];&#10;      if (a == b) = true then l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ (i + 1) else false&#10;    else true" tactic="conv =&amp;gt; rhs; rw [Array.isPrefixOfAux]">
                    <AtomNode start="(359, 3)" end="(359, 7)" leading="" trailing=" " val="conv"/>
                    <NullNode/>
                    <NullNode/>
                    <AtomNode start="(359, 8)" end="(359, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(359, 11)" end="(359, 40)" kind="Lean.Parser.Tactic.Conv.convSeq">
                      <OtherNode start="(359, 11)" end="(359, 40)" kind="Lean.Parser.Tactic.Conv.convSeq1Indented">
                        <NullNode start="(359, 11)" end="(359, 40)">
                          <OtherNode start="(359, 11)" end="(359, 14)" kind="Lean.Parser.Tactic.Conv.rhs">
                            <AtomNode start="(359, 11)" end="(359, 14)" leading="" trailing="" val="rhs"/>
                          </OtherNode>
                          <AtomNode start="(359, 14)" end="(359, 15)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(359, 16)" end="(359, 40)" kind="Lean.Parser.Tactic.Conv.convRw__">
                            <AtomNode start="(359, 16)" end="(359, 18)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(359, 19)" end="(359, 40)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(359, 19)" end="(359, 20)" leading="" trailing="" val="["/>
                              <NullNode start="(359, 20)" end="(359, 39)">
                                <OtherNode start="(359, 20)" end="(359, 39)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(359, 20)" end="(359, 39)" leading="" trailing="" raw_val="Array.isPrefixOfAux" val="Array.isPrefixOfAux" full_name="Array.isPrefixOfAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(359, 39)" end="(359, 40)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(360, 3)" end="(360, 92)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;⊢ (if h : i + 1 &amp;lt; l₁.toArray.size then&#10;      let a := l₁.toArray[i + 1];&#10;      let_fun this := ⋯;&#10;      let b := l₂.toArray[i + 1];&#10;      if (a == b) = true then l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1) else false&#10;    else true) =&#10;    if h : i &amp;lt; l₁.tail.toArray.size then&#10;      let a := l₁.tail.toArray[i];&#10;      let_fun this := ⋯;&#10;      let b := l₂.tail.toArray[i];&#10;      if (a == b) = true then l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ (i + 1) else false&#10;    else true" state_after="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;⊢ (if h : i + 1 &amp;lt; l₁.length then&#10;      decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1)&#10;    else true) =&#10;    if h : i &amp;lt; l₁.length - 1 then&#10;      decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ (i + 1)&#10;    else true" tactic="simp only [size_toArray, getElem_toArray, Bool.if_false_right, length_tail, getElem_tail]">
                    <AtomNode start="(360, 3)" end="(360, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(360, 8)" end="(360, 12)">
                      <AtomNode start="(360, 8)" end="(360, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(360, 13)" end="(360, 92)">
                      <AtomNode start="(360, 13)" end="(360, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(360, 14)" end="(360, 91)">
                        <OtherNode start="(360, 14)" end="(360, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(360, 14)" end="(360, 26)" leading="" trailing="" raw_val="size_toArray" val="size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(360, 26)" end="(360, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(360, 28)" end="(360, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(360, 28)" end="(360, 43)" leading="" trailing="" raw_val="getElem_toArray" val="getElem_toArray" full_name="List.getElem_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(360, 43)" end="(360, 44)" leading="" trailing=" " val=","/>
                        <OtherNode start="(360, 45)" end="(360, 64)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(360, 45)" end="(360, 64)" leading="" trailing="" raw_val="Bool.if_false_right" val="Bool.if_false_right" full_name="Bool.if_false_right" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                        </OtherNode>
                        <AtomNode start="(360, 64)" end="(360, 65)" leading="" trailing=" " val=","/>
                        <OtherNode start="(360, 66)" end="(360, 77)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(360, 66)" end="(360, 77)" leading="" trailing="" raw_val="length_tail" val="length_tail" full_name="List.length_tail" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(360, 77)" end="(360, 78)" leading="" trailing=" " val=","/>
                        <OtherNode start="(360, 79)" end="(360, 91)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(360, 79)" end="(360, 91)" leading="" trailing="" raw_val="getElem_tail" val="getElem_tail" full_name="List.getElem_tail" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(360, 91)" end="(360, 92)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(361, 3)" end="(361, 50)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;⊢ (if h : i + 1 &amp;lt; l₁.length then&#10;      decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1)&#10;    else true) =&#10;    if h : i &amp;lt; l₁.length - 1 then&#10;      decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ (i + 1)&#10;    else true" state_after="case isTrue.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₁.length - 1&#10;⊢ (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1)) =&#10;    (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ (i + 1))&#10;&#10;case isTrue.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length&#10;h₂ : ¬i &amp;lt; l₁.length - 1&#10;⊢ (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1)) = true&#10;&#10;case isFalse.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₁.length - 1&#10;⊢ true = (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ (i + 1))&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : ¬i &amp;lt; l₁.length - 1&#10;⊢ true = true" tactic="split &amp;lt;;&amp;gt; rename_i h₁ &amp;lt;;&amp;gt; split &amp;lt;;&amp;gt; rename_i h₂">
                    <OtherNode start="(361, 3)" end="(361, 34)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(361, 3)" end="(361, 24)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                        <OtherNode start="(361, 3)" end="(361, 8)" kind="Lean.Parser.Tactic.split">
                          <AtomNode start="(361, 3)" end="(361, 8)" leading="" trailing=" " val="split"/>
                          <NullNode/>
                          <NullNode/>
                        </OtherNode>
                        <AtomNode start="(361, 9)" end="(361, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                        <OtherNode start="(361, 13)" end="(361, 24)" kind="Lean.Parser.Tactic.renameI">
                          <AtomNode start="(361, 13)" end="(361, 21)" leading="" trailing=" " val="rename_i"/>
                          <NullNode start="(361, 22)" end="(361, 24)">
                            <LeanBinderidentNode start="(361, 22)" end="(361, 24)">
                              <IdentNode start="(361, 22)" end="(361, 24)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                            </LeanBinderidentNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(361, 25)" end="(361, 28)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(361, 29)" end="(361, 34)" kind="Lean.Parser.Tactic.split">
                        <AtomNode start="(361, 29)" end="(361, 34)" leading="" trailing=" " val="split"/>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(361, 35)" end="(361, 38)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(361, 39)" end="(361, 50)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(361, 39)" end="(361, 47)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(361, 48)" end="(361, 50)">
                        <LeanBinderidentNode start="(361, 48)" end="(361, 50)">
                          <IdentNode start="(361, 48)" end="(361, 50)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(362, 3)" end="(362, 36)" kind="Lean.cdot" state_before="case isTrue.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₁.length - 1&#10;⊢ (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1)) =&#10;    (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ (i + 1))&#10;&#10;case isTrue.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length&#10;h₂ : ¬i &amp;lt; l₁.length - 1&#10;⊢ (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1)) = true&#10;&#10;case isFalse.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₁.length - 1&#10;⊢ true = (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ (i + 1))&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : ¬i &amp;lt; l₁.length - 1&#10;⊢ true = true" state_after="case isTrue.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length&#10;h₂ : ¬i &amp;lt; l₁.length - 1&#10;⊢ (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1)) = true&#10;&#10;case isFalse.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₁.length - 1&#10;⊢ true = (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ (i + 1))&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : ¬i &amp;lt; l₁.length - 1&#10;⊢ true = true" tactic="· rw [isPrefixOfAux_toArray_succ]">
                    <OtherNode start="(362, 3)" end="(362, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(362, 3)" end="(362, 4)" kind="patternIgnore">
                        <OtherNode start="(362, 3)" end="(362, 4)" kind="token.«· »">
                          <AtomNode start="(362, 3)" end="(362, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(362, 5)" end="(362, 36)">
                      <TacticTacticseq1IndentedNode start="(362, 5)" end="(362, 36)">
                        <NullNode start="(362, 5)" end="(362, 36)">
                          <OtherNode start="(362, 5)" end="(362, 36)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₁.length - 1&#10;⊢ (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1)) =&#10;    (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ (i + 1))" state_after="no goals" tactic="rw [isPrefixOfAux_toArray_succ]">
                            <AtomNode start="(362, 5)" end="(362, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(362, 8)" end="(362, 36)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(362, 8)" end="(362, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(362, 9)" end="(362, 35)">
                                <OtherNode start="(362, 9)" end="(362, 35)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(362, 9)" end="(362, 35)" leading="" trailing="" raw_val="isPrefixOfAux_toArray_succ" val="isPrefixOfAux_toArray_succ" full_name="PSigma.Lex.left" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(362, 35)" end="(362, 36)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(363, 3)" end="(363, 10)" kind="Lean.cdot" state_before="case isTrue.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length&#10;h₂ : ¬i &amp;lt; l₁.length - 1&#10;⊢ (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1)) = true&#10;&#10;case isFalse.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₁.length - 1&#10;⊢ true = (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ (i + 1))&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : ¬i &amp;lt; l₁.length - 1&#10;⊢ true = true" state_after="case isFalse.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₁.length - 1&#10;⊢ true = (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ (i + 1))&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : ¬i &amp;lt; l₁.length - 1&#10;⊢ true = true" tactic="· omega">
                    <OtherNode start="(363, 3)" end="(363, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(363, 3)" end="(363, 4)" kind="patternIgnore">
                        <OtherNode start="(363, 3)" end="(363, 4)" kind="token.«· »">
                          <AtomNode start="(363, 3)" end="(363, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(363, 5)" end="(363, 10)">
                      <TacticTacticseq1IndentedNode start="(363, 5)" end="(363, 10)">
                        <NullNode start="(363, 5)" end="(363, 10)">
                          <OtherNode start="(363, 5)" end="(363, 10)" kind="Lean.Parser.Tactic.omega" state_before="case isTrue.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length&#10;h₂ : ¬i &amp;lt; l₁.length - 1&#10;⊢ (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1)) = true" state_after="no goals" tactic="omega">
                            <AtomNode start="(363, 5)" end="(363, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(364, 3)" end="(364, 10)" kind="Lean.cdot" state_before="case isFalse.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₁.length - 1&#10;⊢ true = (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ (i + 1))&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : ¬i &amp;lt; l₁.length - 1&#10;⊢ true = true" state_after="case isFalse.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : ¬i &amp;lt; l₁.length - 1&#10;⊢ true = true" tactic="· omega">
                    <OtherNode start="(364, 3)" end="(364, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(364, 3)" end="(364, 4)" kind="patternIgnore">
                        <OtherNode start="(364, 3)" end="(364, 4)" kind="token.«· »">
                          <AtomNode start="(364, 3)" end="(364, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(364, 5)" end="(364, 10)">
                      <TacticTacticseq1IndentedNode start="(364, 5)" end="(364, 10)">
                        <NullNode start="(364, 5)" end="(364, 10)">
                          <OtherNode start="(364, 5)" end="(364, 10)" kind="Lean.Parser.Tactic.omega" state_before="case isFalse.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₁.length - 1&#10;⊢ true = (decide ((l₁[i + 1] == l₂[i + 1]) = true) &amp;amp;&amp;amp; l₁.tail.toArray.isPrefixOfAux l₂.tail.toArray ⋯ (i + 1))" state_after="no goals" tactic="omega">
                            <AtomNode start="(364, 5)" end="(364, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(365, 3)" end="(365, 8)" kind="Lean.cdot" state_before="case isFalse.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : ¬i &amp;lt; l₁.length - 1&#10;⊢ true = true" state_after="no goals" tactic="· rfl">
                    <OtherNode start="(365, 3)" end="(365, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(365, 3)" end="(365, 4)" kind="patternIgnore">
                        <OtherNode start="(365, 3)" end="(365, 4)" kind="token.«· »">
                          <AtomNode start="(365, 3)" end="(365, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(365, 5)" end="(365, 8)">
                      <TacticTacticseq1IndentedNode start="(365, 5)" end="(365, 8)">
                        <NullNode start="(365, 5)" end="(365, 8)">
                          <OtherNode start="(365, 5)" end="(365, 8)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case isFalse.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;h₁ : ¬i + 1 &amp;lt; l₁.length&#10;h₂ : ¬i &amp;lt; l₁.length - 1&#10;⊢ true = true" state_after="no goals" tactic="rfl">
                            <AtomNode start="(365, 5)" end="(365, 8)" leading="" trailing="&#10;&#10;" val="rfl"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(367, 1)" end="(374, 9)" name="isPrefixOfAux_toArray_succ'" full_name="List.isPrefixOfAux_toArray_succ'">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(367, 1)" end="(374, 9)" name="isPrefixOfAux_toArray_succ'" full_name="List.isPrefixOfAux_toArray_succ'" _is_private_decl="False">
        <AtomNode start="(367, 1)" end="(367, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(367, 9)" end="(367, 36)">
          <IdentNode start="(367, 9)" end="(367, 36)" leading="" trailing=" " raw_val="isPrefixOfAux_toArray_succ'" val="isPrefixOfAux_toArray_succ'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(367, 37)" end="(369, 93)">
          <NullNode start="(367, 37)" end="(367, 101)">
            <OtherNode start="(367, 37)" end="(367, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(367, 37)" end="(367, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(367, 38)" end="(367, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(367, 38)" end="(367, 41)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(367, 42)" end="(367, 43)">
                  <IdentNode start="(367, 42)" end="(367, 43)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(367, 43)" end="(367, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(367, 45)" end="(367, 61)">
              <AtomNode start="(367, 45)" end="(367, 46)" leading="" trailing="" val="("/>
              <NullNode start="(367, 46)" end="(367, 51)">
                <IdentNode start="(367, 46)" end="(367, 48)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(367, 49)" end="(367, 51)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(367, 52)" end="(367, 60)">
                <AtomNode start="(367, 52)" end="(367, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(367, 54)" end="(367, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(367, 54)" end="(367, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(367, 59)" end="(367, 60)">
                    <IdentNode start="(367, 59)" end="(367, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(367, 60)" end="(367, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(367, 62)" end="(367, 91)">
              <AtomNode start="(367, 62)" end="(367, 63)" leading="" trailing="" val="("/>
              <NullNode start="(367, 63)" end="(367, 66)">
                <IdentNode start="(367, 63)" end="(367, 66)" leading="" trailing=" " raw_val="hle" val="hle"/>
              </NullNode>
              <NullNode start="(367, 67)" end="(367, 90)">
                <AtomNode start="(367, 67)" end="(367, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(367, 69)" end="(367, 90)" kind="«term_≤_»">
                  <IdentNode start="(367, 69)" end="(367, 78)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                  <AtomNode start="(367, 79)" end="(367, 80)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(367, 81)" end="(367, 90)" leading="" trailing="" raw_val="l₂.length" val="l₂.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(367, 90)" end="(367, 91)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(367, 92)" end="(367, 101)">
              <AtomNode start="(367, 92)" end="(367, 93)" leading="" trailing="" val="("/>
              <NullNode start="(367, 93)" end="(367, 94)">
                <IdentNode start="(367, 93)" end="(367, 94)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(367, 95)" end="(367, 100)">
                <AtomNode start="(367, 95)" end="(367, 96)" leading="" trailing=" " val=":"/>
                <IdentNode start="(367, 97)" end="(367, 100)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(367, 100)" end="(367, 101)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(367, 102)" end="(369, 93)">
            <AtomNode start="(367, 102)" end="(367, 103)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(368, 5)" end="(369, 93)" kind="«term_=_»">
              <OtherNode start="(368, 5)" end="(368, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(368, 5)" end="(368, 24)" leading="" trailing=" " raw_val="Array.isPrefixOfAux" val="Array.isPrefixOfAux" full_name="Array.isPrefixOfAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(368, 25)" end="(368, 58)">
                  <IdentNode start="(368, 25)" end="(368, 35)" leading="" trailing=" " raw_val="l₁.toArray" val="l₁.toArray"/>
                  <IdentNode start="(368, 36)" end="(368, 46)" leading="" trailing=" " raw_val="l₂.toArray" val="l₂.toArray"/>
                  <IdentNode start="(368, 47)" end="(368, 50)" leading="" trailing=" " raw_val="hle" val="hle"/>
                  <OtherNode start="(368, 51)" end="(368, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(368, 51)" end="(368, 52)" leading="" trailing="" val="("/>
                    <OtherNode start="(368, 52)" end="(368, 57)" kind="«term_+_»">
                      <IdentNode start="(368, 52)" end="(368, 53)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(368, 54)" end="(368, 55)" leading="" trailing=" " val="+"/>
                      <OtherNode start="(368, 56)" end="(368, 57)" kind="num">
                        <AtomNode start="(368, 56)" end="(368, 57)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(368, 57)" end="(368, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(368, 59)" end="(368, 60)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(369, 7)" end="(369, 93)" kind="Lean.Parser.Term.app">
                <IdentNode start="(369, 7)" end="(369, 26)" leading="" trailing=" " raw_val="Array.isPrefixOfAux" val="Array.isPrefixOfAux" full_name="Array.isPrefixOfAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(369, 27)" end="(369, 93)">
                  <OtherNode start="(369, 27)" end="(369, 50)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(369, 27)" end="(369, 42)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(369, 27)" end="(369, 28)" leading="" trailing="" val="("/>
                      <OtherNode start="(369, 28)" end="(369, 41)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(369, 28)" end="(369, 35)" leading="" trailing=" " raw_val="l₁.drop" val="l₁.drop"/>
                        <NullNode start="(369, 36)" end="(369, 41)">
                          <OtherNode start="(369, 36)" end="(369, 41)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(369, 36)" end="(369, 37)" leading="" trailing="" val="("/>
                            <OtherNode start="(369, 37)" end="(369, 40)" kind="«term_+_»">
                              <IdentNode start="(369, 37)" end="(369, 38)" leading="" trailing="" raw_val="i" val="i"/>
                              <AtomNode start="(369, 38)" end="(369, 39)" leading="" trailing="" val="+"/>
                              <OtherNode start="(369, 39)" end="(369, 40)" kind="num">
                                <AtomNode start="(369, 39)" end="(369, 40)" leading="" trailing="" val="1"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(369, 40)" end="(369, 41)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(369, 41)" end="(369, 42)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(369, 42)" end="(369, 43)" leading="" trailing="" val="."/>
                    <IdentNode start="(369, 43)" end="(369, 50)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                  <OtherNode start="(369, 51)" end="(369, 74)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(369, 51)" end="(369, 66)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(369, 51)" end="(369, 52)" leading="" trailing="" val="("/>
                      <OtherNode start="(369, 52)" end="(369, 65)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(369, 52)" end="(369, 59)" leading="" trailing=" " raw_val="l₂.drop" val="l₂.drop"/>
                        <NullNode start="(369, 60)" end="(369, 65)">
                          <OtherNode start="(369, 60)" end="(369, 65)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(369, 60)" end="(369, 61)" leading="" trailing="" val="("/>
                            <OtherNode start="(369, 61)" end="(369, 64)" kind="«term_+_»">
                              <IdentNode start="(369, 61)" end="(369, 62)" leading="" trailing="" raw_val="i" val="i"/>
                              <AtomNode start="(369, 62)" end="(369, 63)" leading="" trailing="" val="+"/>
                              <OtherNode start="(369, 63)" end="(369, 64)" kind="num">
                                <AtomNode start="(369, 63)" end="(369, 64)" leading="" trailing="" val="1"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(369, 64)" end="(369, 65)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(369, 65)" end="(369, 66)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(369, 66)" end="(369, 67)" leading="" trailing="" val="."/>
                    <IdentNode start="(369, 67)" end="(369, 74)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                  <OtherNode start="(369, 75)" end="(369, 91)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(369, 75)" end="(369, 76)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(369, 76)" end="(369, 90)">
                      <AtomNode start="(369, 76)" end="(369, 78)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(369, 79)" end="(369, 90)">
                        <TacticTacticseq1IndentedNode start="(369, 79)" end="(369, 90)">
                          <NullNode start="(369, 79)" end="(369, 90)">
                            <OtherNode start="(369, 79)" end="(369, 83)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.74900&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;⊢ (drop (i + 1) l₁).toArray.size ≤ (drop (i + 1) l₂).toArray.size" state_after="α : Type ?u.74900&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;⊢ l₁.length ≤ l₂.length - (i + 1) + (i + 1)" tactic="simp">
                              <AtomNode start="(369, 79)" end="(369, 83)" leading="" trailing="" val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(369, 83)" end="(369, 84)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(369, 85)" end="(369, 90)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.74900&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;⊢ l₁.length ≤ l₂.length - (i + 1) + (i + 1)" state_after="no goals" tactic="omega">
                              <AtomNode start="(369, 85)" end="(369, 90)" leading="" trailing="" val="omega"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(369, 90)" end="(369, 91)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(369, 92)" end="(369, 93)" kind="num">
                    <AtomNode start="(369, 92)" end="(369, 93)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(369, 94)" end="(374, 9)">
          <AtomNode start="(369, 94)" end="(369, 96)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(369, 97)" end="(374, 9)">
            <AtomNode start="(369, 97)" end="(369, 99)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(370, 3)" end="(374, 9)">
              <TacticTacticseq1IndentedNode start="(370, 3)" end="(374, 9)">
                <NullNode start="(370, 3)" end="(374, 9)">
                  <OtherNode start="(370, 3)" end="(374, 9)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;i : Nat&#10;⊢ l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1) =&#10;    (drop (i + 1) l₁).toArray.isPrefixOfAux (drop (i + 1) l₂).toArray ⋯ 0" state_after="no goals" tactic="induction i generalizing l₁ l₂ with&#10;| zero =&amp;gt; simp [isPrefixOfAux_toArray_succ]&#10;| succ i ih =&amp;gt;&#10;  rw [isPrefixOfAux_toArray_succ, ih]&#10;  simp">
                    <AtomNode start="(370, 3)" end="(370, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(370, 13)" end="(370, 14)">
                      <OtherNode start="(370, 13)" end="(370, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(370, 13)" end="(370, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(370, 15)" end="(370, 33)">
                      <AtomNode start="(370, 15)" end="(370, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(370, 28)" end="(370, 33)">
                        <IdentNode start="(370, 28)" end="(370, 30)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        <IdentNode start="(370, 31)" end="(370, 33)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(370, 34)" end="(374, 9)">
                      <OtherNode start="(370, 34)" end="(374, 9)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(370, 34)" end="(370, 38)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(371, 3)" end="(374, 9)">
                          <OtherNode start="(371, 3)" end="(371, 46)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(371, 3)" end="(371, 9)">
                              <OtherNode start="(371, 3)" end="(371, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(371, 3)" end="(371, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(371, 5)" end="(371, 9)">
                                  <NullNode/>
                                  <IdentNode start="(371, 5)" end="(371, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(371, 10)" end="(371, 46)">
                              <AtomNode start="(371, 10)" end="(371, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(371, 13)" end="(371, 46)">
                                <TacticTacticseq1IndentedNode start="(371, 13)" end="(371, 46)">
                                  <NullNode start="(371, 13)" end="(371, 46)">
                                    <OtherNode start="(371, 13)" end="(371, 46)" kind="Lean.Parser.Tactic.simp" state_before="case zero&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;⊢ l₁.toArray.isPrefixOfAux l₂.toArray hle (0 + 1) =&#10;    (drop (0 + 1) l₁).toArray.isPrefixOfAux (drop (0 + 1) l₂).toArray ⋯ 0" state_after="no goals" tactic="simp [isPrefixOfAux_toArray_succ]">
                                      <AtomNode start="(371, 13)" end="(371, 17)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(371, 18)" end="(371, 46)">
                                        <AtomNode start="(371, 18)" end="(371, 19)" leading="" trailing="" val="["/>
                                        <NullNode start="(371, 19)" end="(371, 45)">
                                          <OtherNode start="(371, 19)" end="(371, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(371, 19)" end="(371, 45)" leading="" trailing="" raw_val="isPrefixOfAux_toArray_succ" val="isPrefixOfAux_toArray_succ" full_name="List.isPrefixOfAux_toArray_succ" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(355, 9)" def_end="(355, 35)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(371, 45)" end="(371, 46)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(372, 3)" end="(374, 9)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(372, 3)" end="(372, 14)">
                              <OtherNode start="(372, 3)" end="(372, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(372, 3)" end="(372, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(372, 5)" end="(372, 9)">
                                  <NullNode/>
                                  <IdentNode start="(372, 5)" end="(372, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(372, 10)" end="(372, 14)">
                                  <IdentNode start="(372, 10)" end="(372, 11)" leading="" trailing=" " raw_val="i" val="i"/>
                                  <IdentNode start="(372, 12)" end="(372, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(372, 15)" end="(374, 9)">
                              <AtomNode start="(372, 15)" end="(372, 17)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(373, 5)" end="(374, 9)">
                                <TacticTacticseq1IndentedNode start="(373, 5)" end="(374, 9)">
                                  <NullNode start="(373, 5)" end="(374, 9)">
                                    <OtherNode start="(373, 5)" end="(373, 40)" kind="Lean.Parser.Tactic.rwSeq" state_before="case succ&#10;α : Type u_1&#10;inst✝ : BEq α&#10;i : Nat&#10;ih :&#10;  ∀ (l₁ l₂ : List α) (hle : l₁.length ≤ l₂.length),&#10;    l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1) =&#10;      (drop (i + 1) l₁).toArray.isPrefixOfAux (drop (i + 1) l₂).toArray ⋯ 0&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;⊢ l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1 + 1) =&#10;    (drop (i + 1 + 1) l₁).toArray.isPrefixOfAux (drop (i + 1 + 1) l₂).toArray ⋯ 0" state_after="case succ&#10;α : Type u_1&#10;inst✝ : BEq α&#10;i : Nat&#10;ih :&#10;  ∀ (l₁ l₂ : List α) (hle : l₁.length ≤ l₂.length),&#10;    l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1) =&#10;      (drop (i + 1) l₁).toArray.isPrefixOfAux (drop (i + 1) l₂).toArray ⋯ 0&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;⊢ (drop (i + 1) l₁.tail).toArray.isPrefixOfAux (drop (i + 1) l₂.tail).toArray ⋯ 0 =&#10;    (drop (i + 1 + 1) l₁).toArray.isPrefixOfAux (drop (i + 1 + 1) l₂).toArray ⋯ 0" tactic="rw [isPrefixOfAux_toArray_succ, ih]">
                                      <AtomNode start="(373, 5)" end="(373, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(373, 8)" end="(373, 40)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(373, 8)" end="(373, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(373, 9)" end="(373, 39)">
                                          <OtherNode start="(373, 9)" end="(373, 35)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(373, 9)" end="(373, 35)" leading="" trailing="" raw_val="isPrefixOfAux_toArray_succ" val="isPrefixOfAux_toArray_succ" full_name="List.isPrefixOfAux_toArray_succ" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(355, 9)" def_end="(355, 35)"/>
                                          </OtherNode>
                                          <AtomNode start="(373, 35)" end="(373, 36)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(373, 37)" end="(373, 39)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(373, 37)" end="(373, 39)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(373, 39)" end="(373, 40)" leading="" trailing="&#10;    " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(374, 5)" end="(374, 9)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;α : Type u_1&#10;inst✝ : BEq α&#10;i : Nat&#10;ih :&#10;  ∀ (l₁ l₂ : List α) (hle : l₁.length ≤ l₂.length),&#10;    l₁.toArray.isPrefixOfAux l₂.toArray hle (i + 1) =&#10;      (drop (i + 1) l₁).toArray.isPrefixOfAux (drop (i + 1) l₂).toArray ⋯ 0&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;⊢ (drop (i + 1) l₁.tail).toArray.isPrefixOfAux (drop (i + 1) l₂.tail).toArray ⋯ 0 =&#10;    (drop (i + 1 + 1) l₁).toArray.isPrefixOfAux (drop (i + 1 + 1) l₂).toArray ⋯ 0" state_after="no goals" tactic="simp">
                                      <AtomNode start="(374, 5)" end="(374, 9)" leading="" trailing="&#10;&#10;" val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(376, 1)" end="(384, 85)" name="isPrefixOfAux_toArray_zero" full_name="List.isPrefixOfAux_toArray_zero">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(376, 1)" end="(384, 85)" name="isPrefixOfAux_toArray_zero" full_name="List.isPrefixOfAux_toArray_zero" _is_private_decl="False">
        <AtomNode start="(376, 1)" end="(376, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(376, 9)" end="(376, 35)">
          <IdentNode start="(376, 9)" end="(376, 35)" leading="" trailing=" " raw_val="isPrefixOfAux_toArray_zero" val="isPrefixOfAux_toArray_zero"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(376, 36)" end="(378, 23)">
          <NullNode start="(376, 36)" end="(376, 90)">
            <OtherNode start="(376, 36)" end="(376, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(376, 36)" end="(376, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(376, 37)" end="(376, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(376, 37)" end="(376, 40)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(376, 41)" end="(376, 42)">
                  <IdentNode start="(376, 41)" end="(376, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(376, 42)" end="(376, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(376, 44)" end="(376, 60)">
              <AtomNode start="(376, 44)" end="(376, 45)" leading="" trailing="" val="("/>
              <NullNode start="(376, 45)" end="(376, 50)">
                <IdentNode start="(376, 45)" end="(376, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(376, 48)" end="(376, 50)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(376, 51)" end="(376, 59)">
                <AtomNode start="(376, 51)" end="(376, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(376, 53)" end="(376, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(376, 53)" end="(376, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(376, 58)" end="(376, 59)">
                    <IdentNode start="(376, 58)" end="(376, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(376, 59)" end="(376, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(376, 61)" end="(376, 90)">
              <AtomNode start="(376, 61)" end="(376, 62)" leading="" trailing="" val="("/>
              <NullNode start="(376, 62)" end="(376, 65)">
                <IdentNode start="(376, 62)" end="(376, 65)" leading="" trailing=" " raw_val="hle" val="hle"/>
              </NullNode>
              <NullNode start="(376, 66)" end="(376, 89)">
                <AtomNode start="(376, 66)" end="(376, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(376, 68)" end="(376, 89)" kind="«term_≤_»">
                  <IdentNode start="(376, 68)" end="(376, 77)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                  <AtomNode start="(376, 78)" end="(376, 79)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(376, 80)" end="(376, 89)" leading="" trailing="" raw_val="l₂.length" val="l₂.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(376, 89)" end="(376, 90)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(376, 91)" end="(378, 23)">
            <AtomNode start="(376, 91)" end="(376, 92)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(377, 5)" end="(378, 23)" kind="«term_=_»">
              <OtherNode start="(377, 5)" end="(377, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(377, 5)" end="(377, 24)" leading="" trailing=" " raw_val="Array.isPrefixOfAux" val="Array.isPrefixOfAux" full_name="Array.isPrefixOfAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(377, 25)" end="(377, 52)">
                  <IdentNode start="(377, 25)" end="(377, 35)" leading="" trailing=" " raw_val="l₁.toArray" val="l₁.toArray"/>
                  <IdentNode start="(377, 36)" end="(377, 46)" leading="" trailing=" " raw_val="l₂.toArray" val="l₂.toArray"/>
                  <IdentNode start="(377, 47)" end="(377, 50)" leading="" trailing=" " raw_val="hle" val="hle"/>
                  <OtherNode start="(377, 51)" end="(377, 52)" kind="num">
                    <AtomNode start="(377, 51)" end="(377, 52)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(377, 53)" end="(377, 54)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(378, 7)" end="(378, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(378, 7)" end="(378, 20)" leading="" trailing=" " raw_val="l₁.isPrefixOf" val="l₁.isPrefixOf"/>
                <NullNode start="(378, 21)" end="(378, 23)">
                  <IdentNode start="(378, 21)" end="(378, 23)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(378, 24)" end="(384, 85)">
          <AtomNode start="(378, 24)" end="(378, 26)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(378, 27)" end="(384, 85)">
            <AtomNode start="(378, 27)" end="(378, 29)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(379, 3)" end="(384, 85)">
              <TacticTacticseq1IndentedNode start="(379, 3)" end="(384, 85)">
                <NullNode start="(379, 3)" end="(384, 85)">
                  <OtherNode start="(379, 3)" end="(379, 27)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;⊢ l₁.toArray.isPrefixOfAux l₂.toArray hle 0 = l₁.isPrefixOf l₂" state_after="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;⊢ (if h : 0 &amp;lt; l₁.toArray.size then&#10;      let a := l₁.toArray[0];&#10;      let_fun this := ⋯;&#10;      let b := l₂.toArray[0];&#10;      if (a == b) = true then l₁.toArray.isPrefixOfAux l₂.toArray hle (0 + 1) else false&#10;    else true) =&#10;    l₁.isPrefixOf l₂" tactic="rw [Array.isPrefixOfAux]">
                    <AtomNode start="(379, 3)" end="(379, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(379, 6)" end="(379, 27)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(379, 6)" end="(379, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(379, 7)" end="(379, 26)">
                        <OtherNode start="(379, 7)" end="(379, 26)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(379, 7)" end="(379, 26)" leading="" trailing="" raw_val="Array.isPrefixOfAux" val="Array.isPrefixOfAux" full_name="Array.isPrefixOfAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(379, 26)" end="(379, 27)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(380, 3)" end="(384, 85)" kind="Lean.Parser.Tactic.match" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;hle : l₁.length ≤ l₂.length&#10;⊢ (if h : 0 &amp;lt; l₁.toArray.size then&#10;      let a := l₁.toArray[0];&#10;      let_fun this := ⋯;&#10;      let b := l₂.toArray[0];&#10;      if (a == b) = true then l₁.toArray.isPrefixOfAux l₂.toArray hle (0 + 1) else false&#10;    else true) =&#10;    l₁.isPrefixOf l₂" state_after="no goals" tactic="match l₁, l₂ with&#10;| [], _ =&amp;gt; rw [dif_neg] &amp;lt;;&amp;gt; simp&#10;| _::_, [] =&amp;gt; simp at hle&#10;| a::l₁, b::l₂ =&amp;gt;&#10;  simp [isPrefixOf_cons₂, isPrefixOfAux_toArray_succ', isPrefixOfAux_toArray_zero]">
                    <AtomNode start="(380, 3)" end="(380, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(380, 9)" end="(380, 15)">
                      <OtherNode start="(380, 9)" end="(380, 11)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(380, 9)" end="(380, 11)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(380, 11)" end="(380, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(380, 13)" end="(380, 15)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(380, 13)" end="(380, 15)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(380, 16)" end="(380, 20)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(381, 3)" end="(384, 85)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(381, 3)" end="(384, 85)">
                        <OtherNode start="(381, 3)" end="(381, 35)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(381, 3)" end="(381, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(381, 5)" end="(381, 10)">
                            <NullNode start="(381, 5)" end="(381, 10)">
                              <OtherNode start="(381, 5)" end="(381, 7)" kind="«term[_]»">
                                <AtomNode start="(381, 5)" end="(381, 6)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(381, 6)" end="(381, 7)" leading="" trailing="" val="]"/>
                              </OtherNode>
                              <AtomNode start="(381, 7)" end="(381, 8)" leading="" trailing=" " val=","/>
                              <TermHoleNode start="(381, 9)" end="(381, 10)">
                                <AtomNode start="(381, 9)" end="(381, 10)" leading="" trailing=" " val="_"/>
                              </TermHoleNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(381, 11)" end="(381, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(381, 14)" end="(381, 35)">
                            <TacticTacticseq1IndentedNode start="(381, 14)" end="(381, 35)">
                              <NullNode start="(381, 14)" end="(381, 35)">
                                <OtherNode start="(381, 14)" end="(381, 35)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ x✝ : List α&#10;hle : [].length ≤ x✝.length&#10;⊢ (if h : 0 &amp;lt; #[].size then&#10;      let a := #[][0];&#10;      let_fun this := ⋯;&#10;      let b := x✝.toArray[0];&#10;      if (a == b) = true then #[].isPrefixOfAux x✝.toArray hle (0 + 1) else false&#10;    else true) =&#10;    [].isPrefixOf x✝" state_after="no goals" tactic="rw [dif_neg] &amp;lt;;&amp;gt; simp">
                                  <OtherNode start="(381, 14)" end="(381, 26)" kind="Lean.Parser.Tactic.rwSeq">
                                    <AtomNode start="(381, 14)" end="(381, 16)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(381, 17)" end="(381, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(381, 17)" end="(381, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(381, 18)" end="(381, 25)">
                                        <OtherNode start="(381, 18)" end="(381, 25)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(381, 18)" end="(381, 25)" leading="" trailing="" raw_val="dif_neg" val="dif_neg" full_name="dif_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(381, 25)" end="(381, 26)" leading="" trailing=" " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(381, 27)" end="(381, 30)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                  <OtherNode start="(381, 31)" end="(381, 35)" kind="Lean.Parser.Tactic.simp">
                                    <AtomNode start="(381, 31)" end="(381, 35)" leading="" trailing="&#10;  " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(382, 3)" end="(382, 28)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(382, 3)" end="(382, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(382, 5)" end="(382, 13)">
                            <NullNode start="(382, 5)" end="(382, 13)">
                              <OtherNode start="(382, 5)" end="(382, 9)" kind="«term_::_»">
                                <TermHoleNode start="(382, 5)" end="(382, 6)">
                                  <AtomNode start="(382, 5)" end="(382, 6)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(382, 6)" end="(382, 8)" leading="" trailing="" val="::"/>
                                <TermHoleNode start="(382, 8)" end="(382, 9)">
                                  <AtomNode start="(382, 8)" end="(382, 9)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                              </OtherNode>
                              <AtomNode start="(382, 9)" end="(382, 10)" leading="" trailing=" " val=","/>
                              <OtherNode start="(382, 11)" end="(382, 13)" kind="«term[_]»">
                                <AtomNode start="(382, 11)" end="(382, 12)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(382, 12)" end="(382, 13)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(382, 14)" end="(382, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(382, 17)" end="(382, 28)">
                            <TacticTacticseq1IndentedNode start="(382, 17)" end="(382, 28)">
                              <NullNode start="(382, 17)" end="(382, 28)">
                                <OtherNode start="(382, 17)" end="(382, 28)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hle : (head✝ :: tail✝).length ≤ [].length&#10;⊢ (if h : 0 &amp;lt; (head✝ :: tail✝).toArray.size then&#10;      let a := (head✝ :: tail✝).toArray[0];&#10;      let_fun this := ⋯;&#10;      let b := #[][0];&#10;      if (a == b) = true then (head✝ :: tail✝).toArray.isPrefixOfAux #[] hle (0 + 1) else false&#10;    else true) =&#10;    (head✝ :: tail✝).isPrefixOf []" state_after="no goals" tactic="simp at hle">
                                  <AtomNode start="(382, 17)" end="(382, 21)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(382, 22)" end="(382, 28)">
                                    <OtherNode start="(382, 22)" end="(382, 28)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(382, 22)" end="(382, 24)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(382, 25)" end="(382, 28)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(382, 25)" end="(382, 28)">
                                          <IdentNode start="(382, 25)" end="(382, 28)" leading="" trailing="&#10;  " raw_val="hle" val="hle"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(383, 3)" end="(384, 85)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(383, 3)" end="(383, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(383, 5)" end="(383, 17)">
                            <NullNode start="(383, 5)" end="(383, 17)">
                              <OtherNode start="(383, 5)" end="(383, 10)" kind="«term_::_»">
                                <IdentNode start="(383, 5)" end="(383, 6)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(383, 6)" end="(383, 8)" leading="" trailing="" val="::"/>
                                <IdentNode start="(383, 8)" end="(383, 10)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                              </OtherNode>
                              <AtomNode start="(383, 10)" end="(383, 11)" leading="" trailing=" " val=","/>
                              <OtherNode start="(383, 12)" end="(383, 17)" kind="«term_::_»">
                                <IdentNode start="(383, 12)" end="(383, 13)" leading="" trailing="" raw_val="b" val="b"/>
                                <AtomNode start="(383, 13)" end="(383, 15)" leading="" trailing="" val="::"/>
                                <IdentNode start="(383, 15)" end="(383, 17)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(383, 18)" end="(383, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(384, 5)" end="(384, 85)">
                            <TacticTacticseq1IndentedNode start="(384, 5)" end="(384, 85)">
                              <NullNode start="(384, 5)" end="(384, 85)">
                                <OtherNode start="(384, 5)" end="(384, 85)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;l₁✝ l₂✝ : List α&#10;a : α&#10;l₁ : List α&#10;b : α&#10;l₂ : List α&#10;hle : (a :: l₁).length ≤ (b :: l₂).length&#10;⊢ (if h : 0 &amp;lt; (a :: l₁).toArray.size then&#10;      let a_1 := (a :: l₁).toArray[0];&#10;      let_fun this := ⋯;&#10;      let b_1 := (b :: l₂).toArray[0];&#10;      if (a_1 == b_1) = true then (a :: l₁).toArray.isPrefixOfAux (b :: l₂).toArray hle (0 + 1) else false&#10;    else true) =&#10;    (a :: l₁).isPrefixOf (b :: l₂)" state_after="no goals" tactic="simp [isPrefixOf_cons₂, isPrefixOfAux_toArray_succ', isPrefixOfAux_toArray_zero]">
                                  <AtomNode start="(384, 5)" end="(384, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(384, 10)" end="(384, 85)">
                                    <AtomNode start="(384, 10)" end="(384, 11)" leading="" trailing="" val="["/>
                                    <NullNode start="(384, 11)" end="(384, 84)">
                                      <OtherNode start="(384, 11)" end="(384, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(384, 11)" end="(384, 27)" leading="" trailing="" raw_val="isPrefixOf_cons₂" val="isPrefixOf_cons₂" full_name="List.isPrefixOf_cons₂" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                      </OtherNode>
                                      <AtomNode start="(384, 27)" end="(384, 28)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(384, 29)" end="(384, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(384, 29)" end="(384, 56)" leading="" trailing="" raw_val="isPrefixOfAux_toArray_succ'" val="isPrefixOfAux_toArray_succ'" full_name="List.isPrefixOfAux_toArray_succ'" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(367, 9)" def_end="(367, 36)"/>
                                      </OtherNode>
                                      <AtomNode start="(384, 56)" end="(384, 57)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(384, 58)" end="(384, 84)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(384, 58)" end="(384, 84)" leading="" trailing="" raw_val="isPrefixOfAux_toArray_zero" val="isPrefixOfAux_toArray_zero"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(384, 84)" end="(384, 85)" leading="" trailing="&#10;&#10;" val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(386, 1)" end="(401, 17)" name="isPrefixOf_toArray" full_name="List.isPrefixOf_toArray">
      <CommandDeclmodifiersNode start="(386, 1)" end="(386, 8)">
        <NullNode/>
        <NullNode start="(386, 1)" end="(386, 8)">
          <OtherNode start="(386, 1)" end="(386, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(386, 1)" end="(386, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(386, 3)" end="(386, 7)">
              <OtherNode start="(386, 3)" end="(386, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(386, 3)" end="(386, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(386, 3)" end="(386, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(386, 7)" end="(386, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(386, 9)" end="(401, 17)" name="isPrefixOf_toArray" full_name="List.isPrefixOf_toArray" _is_private_decl="False">
        <AtomNode start="(386, 9)" end="(386, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(386, 17)" end="(386, 35)">
          <IdentNode start="(386, 17)" end="(386, 35)" leading="" trailing=" " raw_val="isPrefixOf_toArray" val="isPrefixOf_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(386, 36)" end="(387, 56)">
          <NullNode start="(386, 36)" end="(386, 60)">
            <OtherNode start="(386, 36)" end="(386, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(386, 36)" end="(386, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(386, 37)" end="(386, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(386, 37)" end="(386, 40)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(386, 41)" end="(386, 42)">
                  <IdentNode start="(386, 41)" end="(386, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(386, 42)" end="(386, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(386, 44)" end="(386, 60)">
              <AtomNode start="(386, 44)" end="(386, 45)" leading="" trailing="" val="("/>
              <NullNode start="(386, 45)" end="(386, 50)">
                <IdentNode start="(386, 45)" end="(386, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(386, 48)" end="(386, 50)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(386, 51)" end="(386, 59)">
                <AtomNode start="(386, 51)" end="(386, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(386, 53)" end="(386, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(386, 53)" end="(386, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(386, 58)" end="(386, 59)">
                    <IdentNode start="(386, 58)" end="(386, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(386, 59)" end="(386, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(386, 61)" end="(387, 56)">
            <AtomNode start="(386, 61)" end="(386, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(387, 5)" end="(387, 56)" kind="«term_=_»">
              <OtherNode start="(387, 5)" end="(387, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(387, 5)" end="(387, 26)" leading="" trailing=" " raw_val="l₁.toArray.isPrefixOf" val="l₁.toArray.isPrefixOf"/>
                <NullNode start="(387, 27)" end="(387, 37)">
                  <IdentNode start="(387, 27)" end="(387, 37)" leading="" trailing=" " raw_val="l₂.toArray" val="l₂.toArray"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(387, 38)" end="(387, 39)" leading="" trailing=" " val="="/>
              <OtherNode start="(387, 40)" end="(387, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(387, 40)" end="(387, 53)" leading="" trailing=" " raw_val="l₁.isPrefixOf" val="l₁.isPrefixOf"/>
                <NullNode start="(387, 54)" end="(387, 56)">
                  <IdentNode start="(387, 54)" end="(387, 56)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(387, 57)" end="(401, 17)">
          <AtomNode start="(387, 57)" end="(387, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(387, 60)" end="(401, 17)">
            <AtomNode start="(387, 60)" end="(387, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(388, 3)" end="(401, 17)">
              <TacticTacticseq1IndentedNode start="(388, 3)" end="(401, 17)">
                <NullNode start="(388, 3)" end="(401, 17)">
                  <OtherNode start="(388, 3)" end="(388, 24)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;⊢ l₁.toArray.isPrefixOf l₂.toArray = l₁.isPrefixOf l₂" state_after="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;⊢ (if h : l₁.toArray.size ≤ l₂.toArray.size then l₁.toArray.isPrefixOfAux l₂.toArray h 0 else false) = l₁.isPrefixOf l₂" tactic="rw [Array.isPrefixOf]">
                    <AtomNode start="(388, 3)" end="(388, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(388, 6)" end="(388, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(388, 6)" end="(388, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(388, 7)" end="(388, 23)">
                        <OtherNode start="(388, 7)" end="(388, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(388, 7)" end="(388, 23)" leading="" trailing="" raw_val="Array.isPrefixOf" val="Array.isPrefixOf" full_name="Array.isPrefixOf" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(388, 23)" end="(388, 24)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(389, 3)" end="(389, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;⊢ (if h : l₁.toArray.size ≤ l₂.toArray.size then l₁.toArray.isPrefixOfAux l₂.toArray h 0 else false) = l₁.isPrefixOf l₂" state_after="case isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;h : l₁.toArray.size ≤ l₂.toArray.size&#10;⊢ l₁.toArray.isPrefixOfAux l₂.toArray h 0 = l₁.isPrefixOf l₂&#10;&#10;case isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;h : ¬l₁.toArray.size ≤ l₂.toArray.size&#10;⊢ false = l₁.isPrefixOf l₂" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(389, 3)" end="(389, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(389, 3)" end="(389, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(389, 9)" end="(389, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(389, 13)" end="(389, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(389, 13)" end="(389, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(389, 22)" end="(389, 23)">
                        <LeanBinderidentNode start="(389, 22)" end="(389, 23)">
                          <IdentNode start="(389, 22)" end="(389, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(390, 3)" end="(390, 38)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;h : l₁.toArray.size ≤ l₂.toArray.size&#10;⊢ l₁.toArray.isPrefixOfAux l₂.toArray h 0 = l₁.isPrefixOf l₂&#10;&#10;case isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;h : ¬l₁.toArray.size ≤ l₂.toArray.size&#10;⊢ false = l₁.isPrefixOf l₂" state_after="case isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;h : ¬l₁.toArray.size ≤ l₂.toArray.size&#10;⊢ false = l₁.isPrefixOf l₂" tactic="· simp [isPrefixOfAux_toArray_zero]">
                    <OtherNode start="(390, 3)" end="(390, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(390, 3)" end="(390, 4)" kind="patternIgnore">
                        <OtherNode start="(390, 3)" end="(390, 4)" kind="token.«· »">
                          <AtomNode start="(390, 3)" end="(390, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(390, 5)" end="(390, 38)">
                      <TacticTacticseq1IndentedNode start="(390, 5)" end="(390, 38)">
                        <NullNode start="(390, 5)" end="(390, 38)">
                          <OtherNode start="(390, 5)" end="(390, 38)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;h : l₁.toArray.size ≤ l₂.toArray.size&#10;⊢ l₁.toArray.isPrefixOfAux l₂.toArray h 0 = l₁.isPrefixOf l₂" state_after="no goals" tactic="simp [isPrefixOfAux_toArray_zero]">
                            <AtomNode start="(390, 5)" end="(390, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(390, 10)" end="(390, 38)">
                              <AtomNode start="(390, 10)" end="(390, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(390, 11)" end="(390, 37)">
                                <OtherNode start="(390, 11)" end="(390, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(390, 11)" end="(390, 37)" leading="" trailing="" raw_val="isPrefixOfAux_toArray_zero" val="isPrefixOfAux_toArray_zero" full_name="List.isPrefixOfAux_toArray_zero" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(376, 9)" def_end="(376, 35)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(390, 37)" end="(390, 38)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(391, 3)" end="(401, 17)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;h : ¬l₁.toArray.size ≤ l₂.toArray.size&#10;⊢ false = l₁.isPrefixOf l₂" state_after="no goals" tactic="· simp only [Bool.false_eq]&#10;  induction l₁ generalizing l₂ with&#10;  | nil =&amp;gt; simp at h&#10;  | cons a l₁ ih =&amp;gt;&#10;    cases l₂ with&#10;    | nil =&amp;gt; simp&#10;    | cons b l₂ =&amp;gt;&#10;      simp only [isPrefixOf_cons₂, Bool.and_eq_false_imp]&#10;      intro w&#10;      rw [ih]&#10;      simp_all">
                    <OtherNode start="(391, 3)" end="(391, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(391, 3)" end="(391, 4)" kind="patternIgnore">
                        <OtherNode start="(391, 3)" end="(391, 4)" kind="token.«· »">
                          <AtomNode start="(391, 3)" end="(391, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(391, 5)" end="(401, 17)">
                      <TacticTacticseq1IndentedNode start="(391, 5)" end="(401, 17)">
                        <NullNode start="(391, 5)" end="(401, 17)">
                          <OtherNode start="(391, 5)" end="(391, 30)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;h : ¬l₁.toArray.size ≤ l₂.toArray.size&#10;⊢ false = l₁.isPrefixOf l₂" state_after="case isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;h : ¬l₁.toArray.size ≤ l₂.toArray.size&#10;⊢ l₁.isPrefixOf l₂ = false" tactic="simp only [Bool.false_eq]">
                            <AtomNode start="(391, 5)" end="(391, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(391, 10)" end="(391, 14)">
                              <AtomNode start="(391, 10)" end="(391, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(391, 15)" end="(391, 30)">
                              <AtomNode start="(391, 15)" end="(391, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(391, 16)" end="(391, 29)">
                                <OtherNode start="(391, 16)" end="(391, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(391, 16)" end="(391, 29)" leading="" trailing="" raw_val="Bool.false_eq" val="Bool.false_eq" full_name="Bool.false_eq" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(391, 29)" end="(391, 30)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(392, 5)" end="(401, 17)" kind="Lean.Parser.Tactic.induction" state_before="case isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₁ l₂ : List α&#10;h : ¬l₁.toArray.size ≤ l₂.toArray.size&#10;⊢ l₁.isPrefixOf l₂ = false" state_after="no goals" tactic="induction l₁ generalizing l₂ with&#10;| nil =&amp;gt; simp at h&#10;| cons a l₁ ih =&amp;gt;&#10;  cases l₂ with&#10;  | nil =&amp;gt; simp&#10;  | cons b l₂ =&amp;gt;&#10;    simp only [isPrefixOf_cons₂, Bool.and_eq_false_imp]&#10;    intro w&#10;    rw [ih]&#10;    simp_all">
                            <AtomNode start="(392, 5)" end="(392, 14)" leading="" trailing=" " val="induction"/>
                            <NullNode start="(392, 15)" end="(392, 17)">
                              <OtherNode start="(392, 15)" end="(392, 17)" kind="Lean.Parser.Tactic.elimTarget">
                                <NullNode/>
                                <IdentNode start="(392, 15)" end="(392, 17)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(392, 18)" end="(392, 33)">
                              <AtomNode start="(392, 18)" end="(392, 30)" leading="" trailing=" " val="generalizing"/>
                              <NullNode start="(392, 31)" end="(392, 33)">
                                <IdentNode start="(392, 31)" end="(392, 33)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                              </NullNode>
                            </NullNode>
                            <NullNode start="(392, 34)" end="(401, 17)">
                              <OtherNode start="(392, 34)" end="(401, 17)" kind="Lean.Parser.Tactic.inductionAlts">
                                <AtomNode start="(392, 34)" end="(392, 38)" leading="" trailing="&#10;    " val="with"/>
                                <NullNode/>
                                <NullNode start="(393, 5)" end="(401, 17)">
                                  <OtherNode start="(393, 5)" end="(393, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                                    <NullNode start="(393, 5)" end="(393, 10)">
                                      <OtherNode start="(393, 5)" end="(393, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                        <AtomNode start="(393, 5)" end="(393, 6)" leading="" trailing=" " val="|"/>
                                        <GroupNode start="(393, 7)" end="(393, 10)">
                                          <NullNode/>
                                          <IdentNode start="(393, 7)" end="(393, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        </GroupNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode start="(393, 11)" end="(393, 23)">
                                      <AtomNode start="(393, 11)" end="(393, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                      <TacticTacticseqNode start="(393, 14)" end="(393, 23)">
                                        <TacticTacticseq1IndentedNode start="(393, 14)" end="(393, 23)">
                                          <NullNode start="(393, 14)" end="(393, 23)">
                                            <OtherNode start="(393, 14)" end="(393, 23)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse.nil&#10;α : Type u_1&#10;inst✝ : BEq α&#10;l₂ : List α&#10;h : ¬#[].size ≤ l₂.toArray.size&#10;⊢ [].isPrefixOf l₂ = false" state_after="no goals" tactic="simp at h">
                                              <AtomNode start="(393, 14)" end="(393, 18)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(393, 19)" end="(393, 23)">
                                                <OtherNode start="(393, 19)" end="(393, 23)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(393, 19)" end="(393, 21)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(393, 22)" end="(393, 23)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(393, 22)" end="(393, 23)">
                                                      <IdentNode start="(393, 22)" end="(393, 23)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </NullNode>
                                  </OtherNode>
                                  <OtherNode start="(394, 5)" end="(401, 17)" kind="Lean.Parser.Tactic.inductionAlt">
                                    <NullNode start="(394, 5)" end="(394, 19)">
                                      <OtherNode start="(394, 5)" end="(394, 19)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                        <AtomNode start="(394, 5)" end="(394, 6)" leading="" trailing=" " val="|"/>
                                        <GroupNode start="(394, 7)" end="(394, 11)">
                                          <NullNode/>
                                          <IdentNode start="(394, 7)" end="(394, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        </GroupNode>
                                        <NullNode start="(394, 12)" end="(394, 19)">
                                          <IdentNode start="(394, 12)" end="(394, 13)" leading="" trailing=" " raw_val="a" val="a"/>
                                          <IdentNode start="(394, 14)" end="(394, 16)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                          <IdentNode start="(394, 17)" end="(394, 19)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode start="(394, 20)" end="(401, 17)">
                                      <AtomNode start="(394, 20)" end="(394, 22)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                      <TacticTacticseqNode start="(395, 7)" end="(401, 17)">
                                        <TacticTacticseq1IndentedNode start="(395, 7)" end="(401, 17)">
                                          <NullNode start="(395, 7)" end="(401, 17)">
                                            <OtherNode start="(395, 7)" end="(401, 17)" kind="Lean.Parser.Tactic.cases" state_before="case isFalse.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ : List α&#10;ih : ∀ (l₂ : List α), ¬l₁.toArray.size ≤ l₂.toArray.size → l₁.isPrefixOf l₂ = false&#10;l₂ : List α&#10;h : ¬(a :: l₁).toArray.size ≤ l₂.toArray.size&#10;⊢ (a :: l₁).isPrefixOf l₂ = false" state_after="no goals" tactic="cases l₂ with&#10;| nil =&amp;gt; simp&#10;| cons b l₂ =&amp;gt;&#10;  simp only [isPrefixOf_cons₂, Bool.and_eq_false_imp]&#10;  intro w&#10;  rw [ih]&#10;  simp_all">
                                              <AtomNode start="(395, 7)" end="(395, 12)" leading="" trailing=" " val="cases"/>
                                              <NullNode start="(395, 13)" end="(395, 15)">
                                                <OtherNode start="(395, 13)" end="(395, 15)" kind="Lean.Parser.Tactic.elimTarget">
                                                  <NullNode/>
                                                  <IdentNode start="(395, 13)" end="(395, 15)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                              <NullNode start="(395, 16)" end="(401, 17)">
                                                <OtherNode start="(395, 16)" end="(401, 17)" kind="Lean.Parser.Tactic.inductionAlts">
                                                  <AtomNode start="(395, 16)" end="(395, 20)" leading="" trailing="&#10;      " val="with"/>
                                                  <NullNode/>
                                                  <NullNode start="(396, 7)" end="(401, 17)">
                                                    <OtherNode start="(396, 7)" end="(396, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                                                      <NullNode start="(396, 7)" end="(396, 12)">
                                                        <OtherNode start="(396, 7)" end="(396, 12)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                          <AtomNode start="(396, 7)" end="(396, 8)" leading="" trailing=" " val="|"/>
                                                          <GroupNode start="(396, 9)" end="(396, 12)">
                                                            <NullNode/>
                                                            <IdentNode start="(396, 9)" end="(396, 12)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                          </GroupNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode start="(396, 13)" end="(396, 20)">
                                                        <AtomNode start="(396, 13)" end="(396, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                                                        <TacticTacticseqNode start="(396, 16)" end="(396, 20)">
                                                          <TacticTacticseq1IndentedNode start="(396, 16)" end="(396, 20)">
                                                            <NullNode start="(396, 16)" end="(396, 20)">
                                                            <OtherNode start="(396, 16)" end="(396, 20)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse.cons.nil&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ : List α&#10;ih : ∀ (l₂ : List α), ¬l₁.toArray.size ≤ l₂.toArray.size → l₁.isPrefixOf l₂ = false&#10;h : ¬(a :: l₁).toArray.size ≤ #[].size&#10;⊢ (a :: l₁).isPrefixOf [] = false" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(396, 16)" end="(396, 20)" leading="" trailing="&#10;      " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <OtherNode start="(397, 7)" end="(401, 17)" kind="Lean.Parser.Tactic.inductionAlt">
                                                      <NullNode start="(397, 7)" end="(397, 18)">
                                                        <OtherNode start="(397, 7)" end="(397, 18)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                          <AtomNode start="(397, 7)" end="(397, 8)" leading="" trailing=" " val="|"/>
                                                          <GroupNode start="(397, 9)" end="(397, 13)">
                                                            <NullNode/>
                                                            <IdentNode start="(397, 9)" end="(397, 13)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                          </GroupNode>
                                                          <NullNode start="(397, 14)" end="(397, 18)">
                                                            <IdentNode start="(397, 14)" end="(397, 15)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            <IdentNode start="(397, 16)" end="(397, 18)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode start="(397, 19)" end="(401, 17)">
                                                        <AtomNode start="(397, 19)" end="(397, 21)" leading="" trailing="&#10;        " val="=&amp;gt;"/>
                                                        <TacticTacticseqNode start="(398, 9)" end="(401, 17)">
                                                          <TacticTacticseq1IndentedNode start="(398, 9)" end="(401, 17)">
                                                            <NullNode start="(398, 9)" end="(401, 17)">
                                                            <OtherNode start="(398, 9)" end="(398, 60)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse.cons.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ : List α&#10;ih : ∀ (l₂ : List α), ¬l₁.toArray.size ≤ l₂.toArray.size → l₁.isPrefixOf l₂ = false&#10;b : α&#10;l₂ : List α&#10;h : ¬(a :: l₁).toArray.size ≤ (b :: l₂).toArray.size&#10;⊢ (a :: l₁).isPrefixOf (b :: l₂) = false" state_after="case isFalse.cons.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ : List α&#10;ih : ∀ (l₂ : List α), ¬l₁.toArray.size ≤ l₂.toArray.size → l₁.isPrefixOf l₂ = false&#10;b : α&#10;l₂ : List α&#10;h : ¬(a :: l₁).toArray.size ≤ (b :: l₂).toArray.size&#10;⊢ (a == b) = true → l₁.isPrefixOf l₂ = false" tactic="simp only [isPrefixOf_cons₂, Bool.and_eq_false_imp]">
                                                            <AtomNode start="(398, 9)" end="(398, 13)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(398, 14)" end="(398, 18)">
                                                            <AtomNode start="(398, 14)" end="(398, 18)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(398, 19)" end="(398, 60)">
                                                            <AtomNode start="(398, 19)" end="(398, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(398, 20)" end="(398, 59)">
                                                            <OtherNode start="(398, 20)" end="(398, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(398, 20)" end="(398, 36)" leading="" trailing="" raw_val="isPrefixOf_cons₂" val="isPrefixOf_cons₂" full_name="List.isPrefixOf_cons₂" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(398, 36)" end="(398, 37)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(398, 38)" end="(398, 59)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(398, 38)" end="(398, 59)" leading="" trailing="" raw_val="Bool.and_eq_false_imp" val="Bool.and_eq_false_imp" full_name="Bool.and_eq_false_imp" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(398, 59)" end="(398, 60)" leading="" trailing="&#10;        " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(399, 9)" end="(399, 16)" kind="Lean.Parser.Tactic.intro" state_before="case isFalse.cons.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ : List α&#10;ih : ∀ (l₂ : List α), ¬l₁.toArray.size ≤ l₂.toArray.size → l₁.isPrefixOf l₂ = false&#10;b : α&#10;l₂ : List α&#10;h : ¬(a :: l₁).toArray.size ≤ (b :: l₂).toArray.size&#10;⊢ (a == b) = true → l₁.isPrefixOf l₂ = false" state_after="case isFalse.cons.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ : List α&#10;ih : ∀ (l₂ : List α), ¬l₁.toArray.size ≤ l₂.toArray.size → l₁.isPrefixOf l₂ = false&#10;b : α&#10;l₂ : List α&#10;h : ¬(a :: l₁).toArray.size ≤ (b :: l₂).toArray.size&#10;w : (a == b) = true&#10;⊢ l₁.isPrefixOf l₂ = false" tactic="intro w">
                                                            <AtomNode start="(399, 9)" end="(399, 14)" leading="" trailing=" " val="intro"/>
                                                            <NullNode start="(399, 15)" end="(399, 16)">
                                                            <IdentNode start="(399, 15)" end="(399, 16)" leading="" trailing="&#10;        " raw_val="w" val="w"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(400, 9)" end="(400, 16)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse.cons.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ : List α&#10;ih : ∀ (l₂ : List α), ¬l₁.toArray.size ≤ l₂.toArray.size → l₁.isPrefixOf l₂ = false&#10;b : α&#10;l₂ : List α&#10;h : ¬(a :: l₁).toArray.size ≤ (b :: l₂).toArray.size&#10;w : (a == b) = true&#10;⊢ l₁.isPrefixOf l₂ = false" state_after="case isFalse.cons.cons.h&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ : List α&#10;ih : ∀ (l₂ : List α), ¬l₁.toArray.size ≤ l₂.toArray.size → l₁.isPrefixOf l₂ = false&#10;b : α&#10;l₂ : List α&#10;h : ¬(a :: l₁).toArray.size ≤ (b :: l₂).toArray.size&#10;w : (a == b) = true&#10;⊢ ¬l₁.toArray.size ≤ l₂.toArray.size" tactic="rw [ih]">
                                                            <AtomNode start="(400, 9)" end="(400, 11)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(400, 12)" end="(400, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(400, 12)" end="(400, 13)" leading="" trailing="" val="["/>
                                                            <NullNode start="(400, 13)" end="(400, 15)">
                                                            <OtherNode start="(400, 13)" end="(400, 15)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(400, 13)" end="(400, 15)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(400, 15)" end="(400, 16)" leading="" trailing="&#10;        " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(401, 9)" end="(401, 17)" kind="Lean.Parser.Tactic.simpAll" state_before="case isFalse.cons.cons.h&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ : List α&#10;ih : ∀ (l₂ : List α), ¬l₁.toArray.size ≤ l₂.toArray.size → l₁.isPrefixOf l₂ = false&#10;b : α&#10;l₂ : List α&#10;h : ¬(a :: l₁).toArray.size ≤ (b :: l₂).toArray.size&#10;w : (a == b) = true&#10;⊢ ¬l₁.toArray.size ≤ l₂.toArray.size" state_after="no goals" tactic="simp_all">
                                                            <AtomNode start="(401, 9)" end="(401, 17)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(403, 1)" end="(413, 28)" name="zipWithAux_toArray_succ" full_name="List.zipWithAux_toArray_succ">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(403, 1)" end="(413, 28)" name="zipWithAux_toArray_succ" full_name="List.zipWithAux_toArray_succ" _is_private_decl="False">
        <AtomNode start="(403, 1)" end="(403, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(403, 9)" end="(403, 32)">
          <IdentNode start="(403, 9)" end="(403, 32)" leading="" trailing=" " raw_val="zipWithAux_toArray_succ" val="zipWithAux_toArray_succ"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(403, 33)" end="(404, 102)">
          <NullNode start="(403, 33)" end="(403, 101)">
            <TermExplicitbinderNode start="(403, 33)" end="(403, 46)">
              <AtomNode start="(403, 33)" end="(403, 34)" leading="" trailing="" val="("/>
              <NullNode start="(403, 34)" end="(403, 36)">
                <IdentNode start="(403, 34)" end="(403, 36)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(403, 37)" end="(403, 45)">
                <AtomNode start="(403, 37)" end="(403, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(403, 39)" end="(403, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(403, 39)" end="(403, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(403, 44)" end="(403, 45)">
                    <IdentNode start="(403, 44)" end="(403, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(403, 45)" end="(403, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(403, 47)" end="(403, 60)">
              <AtomNode start="(403, 47)" end="(403, 48)" leading="" trailing="" val="("/>
              <NullNode start="(403, 48)" end="(403, 50)">
                <IdentNode start="(403, 48)" end="(403, 50)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(403, 51)" end="(403, 59)">
                <AtomNode start="(403, 51)" end="(403, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(403, 53)" end="(403, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(403, 53)" end="(403, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(403, 58)" end="(403, 59)">
                    <IdentNode start="(403, 58)" end="(403, 59)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(403, 59)" end="(403, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(403, 61)" end="(403, 76)">
              <AtomNode start="(403, 61)" end="(403, 62)" leading="" trailing="" val="("/>
              <NullNode start="(403, 62)" end="(403, 63)">
                <IdentNode start="(403, 62)" end="(403, 63)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(403, 64)" end="(403, 75)">
                <AtomNode start="(403, 64)" end="(403, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(403, 66)" end="(403, 75)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(403, 66)" end="(403, 67)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(403, 68)" end="(403, 69)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(403, 70)" end="(403, 75)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(403, 70)" end="(403, 71)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(403, 72)" end="(403, 73)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(403, 74)" end="(403, 75)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(403, 75)" end="(403, 76)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(403, 77)" end="(403, 86)">
              <AtomNode start="(403, 77)" end="(403, 78)" leading="" trailing="" val="("/>
              <NullNode start="(403, 78)" end="(403, 79)">
                <IdentNode start="(403, 78)" end="(403, 79)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(403, 80)" end="(403, 85)">
                <AtomNode start="(403, 80)" end="(403, 81)" leading="" trailing=" " val=":"/>
                <IdentNode start="(403, 82)" end="(403, 85)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(403, 85)" end="(403, 86)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(403, 87)" end="(403, 101)">
              <AtomNode start="(403, 87)" end="(403, 88)" leading="" trailing="" val="("/>
              <NullNode start="(403, 88)" end="(403, 90)">
                <IdentNode start="(403, 88)" end="(403, 90)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(403, 91)" end="(403, 100)">
                <AtomNode start="(403, 91)" end="(403, 92)" leading="" trailing=" " val=":"/>
                <OtherNode start="(403, 93)" end="(403, 100)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(403, 93)" end="(403, 98)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(403, 99)" end="(403, 100)">
                    <IdentNode start="(403, 99)" end="(403, 100)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(403, 100)" end="(403, 101)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(403, 102)" end="(404, 102)">
            <AtomNode start="(403, 102)" end="(403, 103)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(404, 5)" end="(404, 102)" kind="«term_=_»">
              <OtherNode start="(404, 5)" end="(404, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(404, 5)" end="(404, 15)" leading="" trailing=" " raw_val="zipWithAux" val="zipWithAux" full_name="Array.zipWithAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(404, 16)" end="(404, 50)">
                  <IdentNode start="(404, 16)" end="(404, 26)" leading="" trailing=" " raw_val="as.toArray" val="as.toArray"/>
                  <IdentNode start="(404, 27)" end="(404, 37)" leading="" trailing=" " raw_val="bs.toArray" val="bs.toArray"/>
                  <IdentNode start="(404, 38)" end="(404, 39)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(404, 40)" end="(404, 47)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(404, 40)" end="(404, 41)" leading="" trailing="" val="("/>
                    <OtherNode start="(404, 41)" end="(404, 46)" kind="«term_+_»">
                      <IdentNode start="(404, 41)" end="(404, 42)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(404, 43)" end="(404, 44)" leading="" trailing=" " val="+"/>
                      <OtherNode start="(404, 45)" end="(404, 46)" kind="num">
                        <AtomNode start="(404, 45)" end="(404, 46)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(404, 46)" end="(404, 47)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(404, 48)" end="(404, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(404, 51)" end="(404, 52)" leading="" trailing=" " val="="/>
              <OtherNode start="(404, 53)" end="(404, 102)" kind="Lean.Parser.Term.app">
                <IdentNode start="(404, 53)" end="(404, 63)" leading="" trailing=" " raw_val="zipWithAux" val="zipWithAux" full_name="Array.zipWithAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(404, 64)" end="(404, 102)">
                  <IdentNode start="(404, 64)" end="(404, 79)" leading="" trailing=" " raw_val="as.tail.toArray" val="as.tail.toArray"/>
                  <IdentNode start="(404, 80)" end="(404, 95)" leading="" trailing=" " raw_val="bs.tail.toArray" val="bs.tail.toArray"/>
                  <IdentNode start="(404, 96)" end="(404, 97)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(404, 98)" end="(404, 99)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(404, 100)" end="(404, 102)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(404, 103)" end="(413, 28)">
          <AtomNode start="(404, 103)" end="(404, 105)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(404, 106)" end="(413, 28)">
            <AtomNode start="(404, 106)" end="(404, 108)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(405, 3)" end="(413, 28)">
              <TacticTacticseq1IndentedNode start="(405, 3)" end="(413, 28)">
                <NullNode start="(405, 3)" end="(413, 28)">
                  <OtherNode start="(405, 3)" end="(405, 18)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;⊢ as.toArray.zipWithAux bs.toArray f (i + 1) xs = as.tail.toArray.zipWithAux bs.tail.toArray f i xs" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;⊢ (if h : i + 1 &amp;lt; as.toArray.size then&#10;      let a := as.toArray[i + 1];&#10;      if h : i + 1 &amp;lt; bs.toArray.size then&#10;        let b := bs.toArray[i + 1];&#10;        as.toArray.zipWithAux bs.toArray f (i + 1 + 1) (xs.push (f a b))&#10;      else xs&#10;    else xs) =&#10;    as.tail.toArray.zipWithAux bs.tail.toArray f i xs" tactic="rw [zipWithAux]">
                    <AtomNode start="(405, 3)" end="(405, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(405, 6)" end="(405, 18)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(405, 6)" end="(405, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(405, 7)" end="(405, 17)">
                        <OtherNode start="(405, 7)" end="(405, 17)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(405, 7)" end="(405, 17)" leading="" trailing="" raw_val="zipWithAux" val="zipWithAux" full_name="Array.zipWithAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(405, 17)" end="(405, 18)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(406, 3)" end="(406, 31)" kind="Lean.Parser.Tactic.Conv.conv" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;⊢ (if h : i + 1 &amp;lt; as.toArray.size then&#10;      let a := as.toArray[i + 1];&#10;      if h : i + 1 &amp;lt; bs.toArray.size then&#10;        let b := bs.toArray[i + 1];&#10;        as.toArray.zipWithAux bs.toArray f (i + 1 + 1) (xs.push (f a b))&#10;      else xs&#10;    else xs) =&#10;    as.tail.toArray.zipWithAux bs.tail.toArray f i xs" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;⊢ (if h : i + 1 &amp;lt; as.toArray.size then&#10;      let a := as.toArray[i + 1];&#10;      if h : i + 1 &amp;lt; bs.toArray.size then&#10;        let b := bs.toArray[i + 1];&#10;        as.toArray.zipWithAux bs.toArray f (i + 1 + 1) (xs.push (f a b))&#10;      else xs&#10;    else xs) =&#10;    if h : i &amp;lt; as.tail.toArray.size then&#10;      let a := as.tail.toArray[i];&#10;      if h : i &amp;lt; bs.tail.toArray.size then&#10;        let b := bs.tail.toArray[i];&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f a b))&#10;      else xs&#10;    else xs" tactic="conv =&amp;gt; rhs; rw [zipWithAux]">
                    <AtomNode start="(406, 3)" end="(406, 7)" leading="" trailing=" " val="conv"/>
                    <NullNode/>
                    <NullNode/>
                    <AtomNode start="(406, 8)" end="(406, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(406, 11)" end="(406, 31)" kind="Lean.Parser.Tactic.Conv.convSeq">
                      <OtherNode start="(406, 11)" end="(406, 31)" kind="Lean.Parser.Tactic.Conv.convSeq1Indented">
                        <NullNode start="(406, 11)" end="(406, 31)">
                          <OtherNode start="(406, 11)" end="(406, 14)" kind="Lean.Parser.Tactic.Conv.rhs">
                            <AtomNode start="(406, 11)" end="(406, 14)" leading="" trailing="" val="rhs"/>
                          </OtherNode>
                          <AtomNode start="(406, 14)" end="(406, 15)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(406, 16)" end="(406, 31)" kind="Lean.Parser.Tactic.Conv.convRw__">
                            <AtomNode start="(406, 16)" end="(406, 18)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(406, 19)" end="(406, 31)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(406, 19)" end="(406, 20)" leading="" trailing="" val="["/>
                              <NullNode start="(406, 20)" end="(406, 30)">
                                <OtherNode start="(406, 20)" end="(406, 30)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(406, 20)" end="(406, 30)" leading="" trailing="" raw_val="zipWithAux" val="zipWithAux" full_name="Array.zipWithAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(406, 30)" end="(406, 31)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(407, 3)" end="(407, 71)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;⊢ (if h : i + 1 &amp;lt; as.toArray.size then&#10;      let a := as.toArray[i + 1];&#10;      if h : i + 1 &amp;lt; bs.toArray.size then&#10;        let b := bs.toArray[i + 1];&#10;        as.toArray.zipWithAux bs.toArray f (i + 1 + 1) (xs.push (f a b))&#10;      else xs&#10;    else xs) =&#10;    if h : i &amp;lt; as.tail.toArray.size then&#10;      let a := as.tail.toArray[i];&#10;      if h : i &amp;lt; bs.tail.toArray.size then&#10;        let b := bs.tail.toArray[i];&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f a b))&#10;      else xs&#10;    else xs" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;⊢ (if h : i + 1 &amp;lt; as.length then&#10;      if h_1 : i + 1 &amp;lt; bs.length then as.toArray.zipWithAux bs.toArray f (i + 1 + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs) =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs" tactic="simp only [size_toArray, getElem_toArray, length_tail, getElem_tail]">
                    <AtomNode start="(407, 3)" end="(407, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(407, 8)" end="(407, 12)">
                      <AtomNode start="(407, 8)" end="(407, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(407, 13)" end="(407, 71)">
                      <AtomNode start="(407, 13)" end="(407, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(407, 14)" end="(407, 70)">
                        <OtherNode start="(407, 14)" end="(407, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(407, 14)" end="(407, 26)" leading="" trailing="" raw_val="size_toArray" val="size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(407, 26)" end="(407, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(407, 28)" end="(407, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(407, 28)" end="(407, 43)" leading="" trailing="" raw_val="getElem_toArray" val="getElem_toArray" full_name="List.getElem_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(407, 43)" end="(407, 44)" leading="" trailing=" " val=","/>
                        <OtherNode start="(407, 45)" end="(407, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(407, 45)" end="(407, 56)" leading="" trailing="" raw_val="length_tail" val="length_tail" full_name="List.length_tail" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(407, 56)" end="(407, 57)" leading="" trailing=" " val=","/>
                        <OtherNode start="(407, 58)" end="(407, 70)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(407, 58)" end="(407, 70)" leading="" trailing="" raw_val="getElem_tail" val="getElem_tail" full_name="List.getElem_tail" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(407, 70)" end="(407, 71)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(408, 3)" end="(408, 24)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;⊢ (if h : i + 1 &amp;lt; as.length then&#10;      if h_1 : i + 1 &amp;lt; bs.length then as.toArray.zipWithAux bs.toArray f (i + 1 + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs) =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs" state_after="case isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;⊢ (if h : i + 1 &amp;lt; bs.length then as.toArray.zipWithAux bs.toArray f (i + 1 + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;    else xs) =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs&#10;&#10;case isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : ¬i + 1 &amp;lt; as.length&#10;⊢ xs =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs" tactic="split &amp;lt;;&amp;gt; rename_i h₁">
                    <OtherNode start="(408, 3)" end="(408, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(408, 3)" end="(408, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(408, 9)" end="(408, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(408, 13)" end="(408, 24)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(408, 13)" end="(408, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(408, 22)" end="(408, 24)">
                        <LeanBinderidentNode start="(408, 22)" end="(408, 24)">
                          <IdentNode start="(408, 22)" end="(408, 24)" leading="" trailing="&#10;  " raw_val="h₁" val="h₁"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(409, 3)" end="(412, 30)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;⊢ (if h : i + 1 &amp;lt; bs.length then as.toArray.zipWithAux bs.toArray f (i + 1 + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;    else xs) =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs&#10;&#10;case isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : ¬i + 1 &amp;lt; as.length&#10;⊢ xs =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs" state_after="case isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : ¬i + 1 &amp;lt; as.length&#10;⊢ xs =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs" tactic="· split &amp;lt;;&amp;gt; rename_i h₂&#10;  · rw [dif_pos (by omega), dif_pos (by omega), zipWithAux_toArray_succ]&#10;  · rw [dif_pos (by omega)]&#10;    rw [dif_neg (by omega)]">
                    <OtherNode start="(409, 3)" end="(409, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(409, 3)" end="(409, 4)" kind="patternIgnore">
                        <OtherNode start="(409, 3)" end="(409, 4)" kind="token.«· »">
                          <AtomNode start="(409, 3)" end="(409, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(409, 5)" end="(412, 30)">
                      <TacticTacticseq1IndentedNode start="(409, 5)" end="(412, 30)">
                        <NullNode start="(409, 5)" end="(412, 30)">
                          <OtherNode start="(409, 5)" end="(409, 26)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;⊢ (if h : i + 1 &amp;lt; bs.length then as.toArray.zipWithAux bs.toArray f (i + 1 + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;    else xs) =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs" state_after="case isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;h₂ : i + 1 &amp;lt; bs.length&#10;⊢ as.toArray.zipWithAux bs.toArray f (i + 1 + 1) (xs.push (f as[i + 1] bs[i + 1])) =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs&#10;&#10;case isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;h₂ : ¬i + 1 &amp;lt; bs.length&#10;⊢ xs =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs" tactic="split &amp;lt;;&amp;gt; rename_i h₂">
                            <OtherNode start="(409, 5)" end="(409, 10)" kind="Lean.Parser.Tactic.split">
                              <AtomNode start="(409, 5)" end="(409, 10)" leading="" trailing=" " val="split"/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(409, 11)" end="(409, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(409, 15)" end="(409, 26)" kind="Lean.Parser.Tactic.renameI">
                              <AtomNode start="(409, 15)" end="(409, 23)" leading="" trailing=" " val="rename_i"/>
                              <NullNode start="(409, 24)" end="(409, 26)">
                                <LeanBinderidentNode start="(409, 24)" end="(409, 26)">
                                  <IdentNode start="(409, 24)" end="(409, 26)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                </LeanBinderidentNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(410, 5)" end="(410, 75)" kind="Lean.cdot" state_before="case isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;h₂ : i + 1 &amp;lt; bs.length&#10;⊢ as.toArray.zipWithAux bs.toArray f (i + 1 + 1) (xs.push (f as[i + 1] bs[i + 1])) =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs&#10;&#10;case isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;h₂ : ¬i + 1 &amp;lt; bs.length&#10;⊢ xs =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs" state_after="case isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;h₂ : ¬i + 1 &amp;lt; bs.length&#10;⊢ xs =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs" tactic="· rw [dif_pos (by omega), dif_pos (by omega), zipWithAux_toArray_succ]">
                            <OtherNode start="(410, 5)" end="(410, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(410, 5)" end="(410, 6)" kind="patternIgnore">
                                <OtherNode start="(410, 5)" end="(410, 6)" kind="token.«· »">
                                  <AtomNode start="(410, 5)" end="(410, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(410, 7)" end="(410, 75)">
                              <TacticTacticseq1IndentedNode start="(410, 7)" end="(410, 75)">
                                <NullNode start="(410, 7)" end="(410, 75)">
                                  <OtherNode start="(410, 7)" end="(410, 75)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;h₂ : i + 1 &amp;lt; bs.length&#10;⊢ as.toArray.zipWithAux bs.toArray f (i + 1 + 1) (xs.push (f as[i + 1] bs[i + 1])) =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs" state_after="no goals" tactic="rw [dif_pos (by omega), dif_pos (by omega), zipWithAux_toArray_succ]">
                                    <AtomNode start="(410, 7)" end="(410, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(410, 10)" end="(410, 75)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(410, 10)" end="(410, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(410, 11)" end="(410, 74)">
                                        <OtherNode start="(410, 11)" end="(410, 29)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <OtherNode start="(410, 11)" end="(410, 29)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(410, 11)" end="(410, 18)" leading="" trailing=" " raw_val="dif_pos" val="dif_pos" full_name="dif_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                            <NullNode start="(410, 19)" end="(410, 29)">
                                              <OtherNode start="(410, 19)" end="(410, 29)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(410, 19)" end="(410, 20)" leading="" trailing="" val="("/>
                                                <TermBytacticNode start="(410, 20)" end="(410, 28)">
                                                  <AtomNode start="(410, 20)" end="(410, 22)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(410, 23)" end="(410, 28)">
                                                    <TacticTacticseq1IndentedNode start="(410, 23)" end="(410, 28)">
                                                      <NullNode start="(410, 23)" end="(410, 28)">
                                                        <OtherNode start="(410, 23)" end="(410, 28)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;h₂ : i + 1 &amp;lt; bs.length&#10;⊢ i &amp;lt; as.length - 1" state_after="no goals" tactic="omega">
                                                          <AtomNode start="(410, 23)" end="(410, 28)" leading="" trailing="" val="omega"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                                <AtomNode start="(410, 28)" end="(410, 29)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(410, 29)" end="(410, 30)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(410, 31)" end="(410, 49)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <OtherNode start="(410, 31)" end="(410, 49)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(410, 31)" end="(410, 38)" leading="" trailing=" " raw_val="dif_pos" val="dif_pos" full_name="dif_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                            <NullNode start="(410, 39)" end="(410, 49)">
                                              <OtherNode start="(410, 39)" end="(410, 49)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(410, 39)" end="(410, 40)" leading="" trailing="" val="("/>
                                                <TermBytacticNode start="(410, 40)" end="(410, 48)">
                                                  <AtomNode start="(410, 40)" end="(410, 42)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(410, 43)" end="(410, 48)">
                                                    <TacticTacticseq1IndentedNode start="(410, 43)" end="(410, 48)">
                                                      <NullNode start="(410, 43)" end="(410, 48)">
                                                        <OtherNode start="(410, 43)" end="(410, 48)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;h₂ : i + 1 &amp;lt; bs.length&#10;⊢ i &amp;lt; bs.length - 1" state_after="no goals" tactic="omega">
                                                          <AtomNode start="(410, 43)" end="(410, 48)" leading="" trailing="" val="omega"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                                <AtomNode start="(410, 48)" end="(410, 49)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(410, 49)" end="(410, 50)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(410, 51)" end="(410, 74)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(410, 51)" end="(410, 74)" leading="" trailing="" raw_val="zipWithAux_toArray_succ" val="zipWithAux_toArray_succ" full_name="PSigma.Lex.left" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(410, 74)" end="(410, 75)" leading="" trailing="&#10;    " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(411, 5)" end="(412, 30)" kind="Lean.cdot" state_before="case isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;h₂ : ¬i + 1 &amp;lt; bs.length&#10;⊢ xs =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs" state_after="no goals" tactic="· rw [dif_pos (by omega)]&#10;  rw [dif_neg (by omega)]">
                            <OtherNode start="(411, 5)" end="(411, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(411, 5)" end="(411, 6)" kind="patternIgnore">
                                <OtherNode start="(411, 5)" end="(411, 6)" kind="token.«· »">
                                  <AtomNode start="(411, 5)" end="(411, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(411, 7)" end="(412, 30)">
                              <TacticTacticseq1IndentedNode start="(411, 7)" end="(412, 30)">
                                <NullNode start="(411, 7)" end="(412, 30)">
                                  <OtherNode start="(411, 7)" end="(411, 30)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;h₂ : ¬i + 1 &amp;lt; bs.length&#10;⊢ xs =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs" state_after="case isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;h₂ : ¬i + 1 &amp;lt; bs.length&#10;⊢ xs =&#10;    if h : i &amp;lt; bs.length - 1 then as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;    else xs" tactic="rw [dif_pos (by omega)]">
                                    <AtomNode start="(411, 7)" end="(411, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(411, 10)" end="(411, 30)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(411, 10)" end="(411, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(411, 11)" end="(411, 29)">
                                        <OtherNode start="(411, 11)" end="(411, 29)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <OtherNode start="(411, 11)" end="(411, 29)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(411, 11)" end="(411, 18)" leading="" trailing=" " raw_val="dif_pos" val="dif_pos" full_name="dif_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                            <NullNode start="(411, 19)" end="(411, 29)">
                                              <OtherNode start="(411, 19)" end="(411, 29)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(411, 19)" end="(411, 20)" leading="" trailing="" val="("/>
                                                <TermBytacticNode start="(411, 20)" end="(411, 28)">
                                                  <AtomNode start="(411, 20)" end="(411, 22)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(411, 23)" end="(411, 28)">
                                                    <TacticTacticseq1IndentedNode start="(411, 23)" end="(411, 28)">
                                                      <NullNode start="(411, 23)" end="(411, 28)">
                                                        <OtherNode start="(411, 23)" end="(411, 28)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;h₂ : ¬i + 1 &amp;lt; bs.length&#10;⊢ i &amp;lt; as.length - 1" state_after="no goals" tactic="omega">
                                                          <AtomNode start="(411, 23)" end="(411, 28)" leading="" trailing="" val="omega"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                                <AtomNode start="(411, 28)" end="(411, 29)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(411, 29)" end="(411, 30)" leading="" trailing="&#10;      " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(412, 7)" end="(412, 30)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;h₂ : ¬i + 1 &amp;lt; bs.length&#10;⊢ xs =&#10;    if h : i &amp;lt; bs.length - 1 then as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;    else xs" state_after="no goals" tactic="rw [dif_neg (by omega)]">
                                    <AtomNode start="(412, 7)" end="(412, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(412, 10)" end="(412, 30)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(412, 10)" end="(412, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(412, 11)" end="(412, 29)">
                                        <OtherNode start="(412, 11)" end="(412, 29)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <OtherNode start="(412, 11)" end="(412, 29)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(412, 11)" end="(412, 18)" leading="" trailing=" " raw_val="dif_neg" val="dif_neg" full_name="dif_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                            <NullNode start="(412, 19)" end="(412, 29)">
                                              <OtherNode start="(412, 19)" end="(412, 29)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(412, 19)" end="(412, 20)" leading="" trailing="" val="("/>
                                                <TermBytacticNode start="(412, 20)" end="(412, 28)">
                                                  <AtomNode start="(412, 20)" end="(412, 22)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(412, 23)" end="(412, 28)">
                                                    <TacticTacticseq1IndentedNode start="(412, 23)" end="(412, 28)">
                                                      <NullNode start="(412, 23)" end="(412, 28)">
                                                        <OtherNode start="(412, 23)" end="(412, 28)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : i + 1 &amp;lt; as.length&#10;h₂ : ¬i + 1 &amp;lt; bs.length&#10;⊢ ¬i &amp;lt; bs.length - 1" state_after="no goals" tactic="omega">
                                                          <AtomNode start="(412, 23)" end="(412, 28)" leading="" trailing="" val="omega"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                                <AtomNode start="(412, 28)" end="(412, 29)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(412, 29)" end="(412, 30)" leading="" trailing="&#10;  " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(413, 3)" end="(413, 28)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : ¬i + 1 &amp;lt; as.length&#10;⊢ xs =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs" state_after="no goals" tactic="· rw [dif_neg (by omega)]">
                    <OtherNode start="(413, 3)" end="(413, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(413, 3)" end="(413, 4)" kind="patternIgnore">
                        <OtherNode start="(413, 3)" end="(413, 4)" kind="token.«· »">
                          <AtomNode start="(413, 3)" end="(413, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(413, 5)" end="(413, 28)">
                      <TacticTacticseq1IndentedNode start="(413, 5)" end="(413, 28)">
                        <NullNode start="(413, 5)" end="(413, 28)">
                          <OtherNode start="(413, 5)" end="(413, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : ¬i + 1 &amp;lt; as.length&#10;⊢ xs =&#10;    if h : i &amp;lt; as.length - 1 then&#10;      if h_1 : i &amp;lt; bs.length - 1 then&#10;        as.tail.toArray.zipWithAux bs.tail.toArray f (i + 1) (xs.push (f as[i + 1] bs[i + 1]))&#10;      else xs&#10;    else xs" state_after="no goals" tactic="rw [dif_neg (by omega)]">
                            <AtomNode start="(413, 5)" end="(413, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(413, 8)" end="(413, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(413, 8)" end="(413, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(413, 9)" end="(413, 27)">
                                <OtherNode start="(413, 9)" end="(413, 27)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(413, 9)" end="(413, 27)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(413, 9)" end="(413, 16)" leading="" trailing=" " raw_val="dif_neg" val="dif_neg" full_name="dif_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                    <NullNode start="(413, 17)" end="(413, 27)">
                                      <OtherNode start="(413, 17)" end="(413, 27)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(413, 17)" end="(413, 18)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(413, 18)" end="(413, 26)">
                                          <AtomNode start="(413, 18)" end="(413, 20)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(413, 21)" end="(413, 26)">
                                            <TacticTacticseq1IndentedNode start="(413, 21)" end="(413, 26)">
                                              <NullNode start="(413, 21)" end="(413, 26)">
                                                <OtherNode start="(413, 21)" end="(413, 26)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;h₁ : ¬i + 1 &amp;lt; as.length&#10;⊢ ¬i &amp;lt; as.length - 1" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(413, 21)" end="(413, 26)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(413, 26)" end="(413, 27)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(413, 27)" end="(413, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(415, 1)" end="(421, 9)" name="zipWithAux_toArray_succ'" full_name="List.zipWithAux_toArray_succ'">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(415, 1)" end="(421, 9)" name="zipWithAux_toArray_succ'" full_name="List.zipWithAux_toArray_succ'" _is_private_decl="False">
        <AtomNode start="(415, 1)" end="(415, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(415, 9)" end="(415, 33)">
          <IdentNode start="(415, 9)" end="(415, 33)" leading="" trailing=" " raw_val="zipWithAux_toArray_succ'" val="zipWithAux_toArray_succ'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(415, 34)" end="(416, 118)">
          <NullNode start="(415, 34)" end="(415, 102)">
            <TermExplicitbinderNode start="(415, 34)" end="(415, 47)">
              <AtomNode start="(415, 34)" end="(415, 35)" leading="" trailing="" val="("/>
              <NullNode start="(415, 35)" end="(415, 37)">
                <IdentNode start="(415, 35)" end="(415, 37)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(415, 38)" end="(415, 46)">
                <AtomNode start="(415, 38)" end="(415, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(415, 40)" end="(415, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(415, 40)" end="(415, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(415, 45)" end="(415, 46)">
                    <IdentNode start="(415, 45)" end="(415, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(415, 46)" end="(415, 47)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(415, 48)" end="(415, 61)">
              <AtomNode start="(415, 48)" end="(415, 49)" leading="" trailing="" val="("/>
              <NullNode start="(415, 49)" end="(415, 51)">
                <IdentNode start="(415, 49)" end="(415, 51)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(415, 52)" end="(415, 60)">
                <AtomNode start="(415, 52)" end="(415, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(415, 54)" end="(415, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(415, 54)" end="(415, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(415, 59)" end="(415, 60)">
                    <IdentNode start="(415, 59)" end="(415, 60)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(415, 60)" end="(415, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(415, 62)" end="(415, 77)">
              <AtomNode start="(415, 62)" end="(415, 63)" leading="" trailing="" val="("/>
              <NullNode start="(415, 63)" end="(415, 64)">
                <IdentNode start="(415, 63)" end="(415, 64)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(415, 65)" end="(415, 76)">
                <AtomNode start="(415, 65)" end="(415, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(415, 67)" end="(415, 76)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(415, 67)" end="(415, 68)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(415, 69)" end="(415, 70)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(415, 71)" end="(415, 76)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(415, 71)" end="(415, 72)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(415, 73)" end="(415, 74)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(415, 75)" end="(415, 76)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(415, 76)" end="(415, 77)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(415, 78)" end="(415, 87)">
              <AtomNode start="(415, 78)" end="(415, 79)" leading="" trailing="" val="("/>
              <NullNode start="(415, 79)" end="(415, 80)">
                <IdentNode start="(415, 79)" end="(415, 80)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(415, 81)" end="(415, 86)">
                <AtomNode start="(415, 81)" end="(415, 82)" leading="" trailing=" " val=":"/>
                <IdentNode start="(415, 83)" end="(415, 86)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(415, 86)" end="(415, 87)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(415, 88)" end="(415, 102)">
              <AtomNode start="(415, 88)" end="(415, 89)" leading="" trailing="" val="("/>
              <NullNode start="(415, 89)" end="(415, 91)">
                <IdentNode start="(415, 89)" end="(415, 91)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(415, 92)" end="(415, 101)">
                <AtomNode start="(415, 92)" end="(415, 93)" leading="" trailing=" " val=":"/>
                <OtherNode start="(415, 94)" end="(415, 101)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(415, 94)" end="(415, 99)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(415, 100)" end="(415, 101)">
                    <IdentNode start="(415, 100)" end="(415, 101)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(415, 101)" end="(415, 102)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(415, 103)" end="(416, 118)">
            <AtomNode start="(415, 103)" end="(415, 104)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(416, 5)" end="(416, 118)" kind="«term_=_»">
              <OtherNode start="(416, 5)" end="(416, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(416, 5)" end="(416, 15)" leading="" trailing=" " raw_val="zipWithAux" val="zipWithAux" full_name="Array.zipWithAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(416, 16)" end="(416, 50)">
                  <IdentNode start="(416, 16)" end="(416, 26)" leading="" trailing=" " raw_val="as.toArray" val="as.toArray"/>
                  <IdentNode start="(416, 27)" end="(416, 37)" leading="" trailing=" " raw_val="bs.toArray" val="bs.toArray"/>
                  <IdentNode start="(416, 38)" end="(416, 39)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(416, 40)" end="(416, 47)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(416, 40)" end="(416, 41)" leading="" trailing="" val="("/>
                    <OtherNode start="(416, 41)" end="(416, 46)" kind="«term_+_»">
                      <IdentNode start="(416, 41)" end="(416, 42)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(416, 43)" end="(416, 44)" leading="" trailing=" " val="+"/>
                      <OtherNode start="(416, 45)" end="(416, 46)" kind="num">
                        <AtomNode start="(416, 45)" end="(416, 46)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(416, 46)" end="(416, 47)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(416, 48)" end="(416, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(416, 51)" end="(416, 52)" leading="" trailing=" " val="="/>
              <OtherNode start="(416, 53)" end="(416, 118)" kind="Lean.Parser.Term.app">
                <IdentNode start="(416, 53)" end="(416, 63)" leading="" trailing=" " raw_val="zipWithAux" val="zipWithAux" full_name="Array.zipWithAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(416, 64)" end="(416, 118)">
                  <OtherNode start="(416, 64)" end="(416, 87)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(416, 64)" end="(416, 79)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(416, 64)" end="(416, 65)" leading="" trailing="" val="("/>
                      <OtherNode start="(416, 65)" end="(416, 78)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(416, 65)" end="(416, 72)" leading="" trailing=" " raw_val="as.drop" val="as.drop"/>
                        <NullNode start="(416, 73)" end="(416, 78)">
                          <OtherNode start="(416, 73)" end="(416, 78)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(416, 73)" end="(416, 74)" leading="" trailing="" val="("/>
                            <OtherNode start="(416, 74)" end="(416, 77)" kind="«term_+_»">
                              <IdentNode start="(416, 74)" end="(416, 75)" leading="" trailing="" raw_val="i" val="i"/>
                              <AtomNode start="(416, 75)" end="(416, 76)" leading="" trailing="" val="+"/>
                              <OtherNode start="(416, 76)" end="(416, 77)" kind="num">
                                <AtomNode start="(416, 76)" end="(416, 77)" leading="" trailing="" val="1"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(416, 77)" end="(416, 78)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(416, 78)" end="(416, 79)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(416, 79)" end="(416, 80)" leading="" trailing="" val="."/>
                    <IdentNode start="(416, 80)" end="(416, 87)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                  <OtherNode start="(416, 88)" end="(416, 111)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(416, 88)" end="(416, 103)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(416, 88)" end="(416, 89)" leading="" trailing="" val="("/>
                      <OtherNode start="(416, 89)" end="(416, 102)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(416, 89)" end="(416, 96)" leading="" trailing=" " raw_val="bs.drop" val="bs.drop"/>
                        <NullNode start="(416, 97)" end="(416, 102)">
                          <OtherNode start="(416, 97)" end="(416, 102)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(416, 97)" end="(416, 98)" leading="" trailing="" val="("/>
                            <OtherNode start="(416, 98)" end="(416, 101)" kind="«term_+_»">
                              <IdentNode start="(416, 98)" end="(416, 99)" leading="" trailing="" raw_val="i" val="i"/>
                              <AtomNode start="(416, 99)" end="(416, 100)" leading="" trailing="" val="+"/>
                              <OtherNode start="(416, 100)" end="(416, 101)" kind="num">
                                <AtomNode start="(416, 100)" end="(416, 101)" leading="" trailing="" val="1"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(416, 101)" end="(416, 102)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(416, 102)" end="(416, 103)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(416, 103)" end="(416, 104)" leading="" trailing="" val="."/>
                    <IdentNode start="(416, 104)" end="(416, 111)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                  <IdentNode start="(416, 112)" end="(416, 113)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(416, 114)" end="(416, 115)" kind="num">
                    <AtomNode start="(416, 114)" end="(416, 115)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(416, 116)" end="(416, 118)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(416, 119)" end="(421, 9)">
          <AtomNode start="(416, 119)" end="(416, 121)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(416, 122)" end="(421, 9)">
            <AtomNode start="(416, 122)" end="(416, 124)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(417, 3)" end="(421, 9)">
              <TacticTacticseq1IndentedNode start="(417, 3)" end="(421, 9)">
                <NullNode start="(417, 3)" end="(421, 9)">
                  <OtherNode start="(417, 3)" end="(421, 9)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;i : Nat&#10;xs : Array γ&#10;⊢ as.toArray.zipWithAux bs.toArray f (i + 1) xs = (drop (i + 1) as).toArray.zipWithAux (drop (i + 1) bs).toArray f 0 xs" state_after="no goals" tactic="induction i generalizing as bs xs with&#10;| zero =&amp;gt; simp [zipWithAux_toArray_succ]&#10;| succ i ih =&amp;gt;&#10;  rw [zipWithAux_toArray_succ, ih]&#10;  simp">
                    <AtomNode start="(417, 3)" end="(417, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(417, 13)" end="(417, 14)">
                      <OtherNode start="(417, 13)" end="(417, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(417, 13)" end="(417, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(417, 15)" end="(417, 36)">
                      <AtomNode start="(417, 15)" end="(417, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(417, 28)" end="(417, 36)">
                        <IdentNode start="(417, 28)" end="(417, 30)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(417, 31)" end="(417, 33)" leading="" trailing=" " raw_val="bs" val="bs"/>
                        <IdentNode start="(417, 34)" end="(417, 36)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(417, 37)" end="(421, 9)">
                      <OtherNode start="(417, 37)" end="(421, 9)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(417, 37)" end="(417, 41)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(418, 3)" end="(421, 9)">
                          <OtherNode start="(418, 3)" end="(418, 43)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(418, 3)" end="(418, 9)">
                              <OtherNode start="(418, 3)" end="(418, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(418, 3)" end="(418, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(418, 5)" end="(418, 9)">
                                  <NullNode/>
                                  <IdentNode start="(418, 5)" end="(418, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(418, 10)" end="(418, 43)">
                              <AtomNode start="(418, 10)" end="(418, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(418, 13)" end="(418, 43)">
                                <TacticTacticseq1IndentedNode start="(418, 13)" end="(418, 43)">
                                  <NullNode start="(418, 13)" end="(418, 43)">
                                    <OtherNode start="(418, 13)" end="(418, 43)" kind="Lean.Parser.Tactic.simp" state_before="case zero&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : List α&#10;bs : List β&#10;xs : Array γ&#10;⊢ as.toArray.zipWithAux bs.toArray f (0 + 1) xs = (drop (0 + 1) as).toArray.zipWithAux (drop (0 + 1) bs).toArray f 0 xs" state_after="no goals" tactic="simp [zipWithAux_toArray_succ]">
                                      <AtomNode start="(418, 13)" end="(418, 17)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(418, 18)" end="(418, 43)">
                                        <AtomNode start="(418, 18)" end="(418, 19)" leading="" trailing="" val="["/>
                                        <NullNode start="(418, 19)" end="(418, 42)">
                                          <OtherNode start="(418, 19)" end="(418, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(418, 19)" end="(418, 42)" leading="" trailing="" raw_val="zipWithAux_toArray_succ" val="zipWithAux_toArray_succ" full_name="List.zipWithAux_toArray_succ" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(403, 9)" def_end="(403, 32)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(418, 42)" end="(418, 43)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(419, 3)" end="(421, 9)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(419, 3)" end="(419, 14)">
                              <OtherNode start="(419, 3)" end="(419, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(419, 3)" end="(419, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(419, 5)" end="(419, 9)">
                                  <NullNode/>
                                  <IdentNode start="(419, 5)" end="(419, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(419, 10)" end="(419, 14)">
                                  <IdentNode start="(419, 10)" end="(419, 11)" leading="" trailing=" " raw_val="i" val="i"/>
                                  <IdentNode start="(419, 12)" end="(419, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(419, 15)" end="(421, 9)">
                              <AtomNode start="(419, 15)" end="(419, 17)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(420, 5)" end="(421, 9)">
                                <TacticTacticseq1IndentedNode start="(420, 5)" end="(421, 9)">
                                  <NullNode start="(420, 5)" end="(421, 9)">
                                    <OtherNode start="(420, 5)" end="(420, 37)" kind="Lean.Parser.Tactic.rwSeq" state_before="case succ&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;i : Nat&#10;ih :&#10;  ∀ (as : List α) (bs : List β) (xs : Array γ),&#10;    as.toArray.zipWithAux bs.toArray f (i + 1) xs =&#10;      (drop (i + 1) as).toArray.zipWithAux (drop (i + 1) bs).toArray f 0 xs&#10;as : List α&#10;bs : List β&#10;xs : Array γ&#10;⊢ as.toArray.zipWithAux bs.toArray f (i + 1 + 1) xs =&#10;    (drop (i + 1 + 1) as).toArray.zipWithAux (drop (i + 1 + 1) bs).toArray f 0 xs" state_after="case succ&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;i : Nat&#10;ih :&#10;  ∀ (as : List α) (bs : List β) (xs : Array γ),&#10;    as.toArray.zipWithAux bs.toArray f (i + 1) xs =&#10;      (drop (i + 1) as).toArray.zipWithAux (drop (i + 1) bs).toArray f 0 xs&#10;as : List α&#10;bs : List β&#10;xs : Array γ&#10;⊢ (drop (i + 1) as.tail).toArray.zipWithAux (drop (i + 1) bs.tail).toArray f 0 xs =&#10;    (drop (i + 1 + 1) as).toArray.zipWithAux (drop (i + 1 + 1) bs).toArray f 0 xs" tactic="rw [zipWithAux_toArray_succ, ih]">
                                      <AtomNode start="(420, 5)" end="(420, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(420, 8)" end="(420, 37)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(420, 8)" end="(420, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(420, 9)" end="(420, 36)">
                                          <OtherNode start="(420, 9)" end="(420, 32)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(420, 9)" end="(420, 32)" leading="" trailing="" raw_val="zipWithAux_toArray_succ" val="zipWithAux_toArray_succ" full_name="List.zipWithAux_toArray_succ" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(403, 9)" def_end="(403, 32)"/>
                                          </OtherNode>
                                          <AtomNode start="(420, 32)" end="(420, 33)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(420, 34)" end="(420, 36)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(420, 34)" end="(420, 36)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(420, 36)" end="(420, 37)" leading="" trailing="&#10;    " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(421, 5)" end="(421, 9)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;i : Nat&#10;ih :&#10;  ∀ (as : List α) (bs : List β) (xs : Array γ),&#10;    as.toArray.zipWithAux bs.toArray f (i + 1) xs =&#10;      (drop (i + 1) as).toArray.zipWithAux (drop (i + 1) bs).toArray f 0 xs&#10;as : List α&#10;bs : List β&#10;xs : Array γ&#10;⊢ (drop (i + 1) as.tail).toArray.zipWithAux (drop (i + 1) bs.tail).toArray f 0 xs =&#10;    (drop (i + 1 + 1) as).toArray.zipWithAux (drop (i + 1 + 1) bs).toArray f 0 xs" state_after="no goals" tactic="simp">
                                      <AtomNode start="(421, 5)" end="(421, 9)" leading="" trailing="&#10;&#10;" val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(423, 1)" end="(430, 101)" name="zipWithAux_toArray_zero" full_name="List.zipWithAux_toArray_zero">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(423, 1)" end="(430, 101)" name="zipWithAux_toArray_zero" full_name="List.zipWithAux_toArray_zero" _is_private_decl="False">
        <AtomNode start="(423, 1)" end="(423, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(423, 9)" end="(423, 32)">
          <IdentNode start="(423, 9)" end="(423, 32)" leading="" trailing=" " raw_val="zipWithAux_toArray_zero" val="zipWithAux_toArray_zero"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(423, 33)" end="(424, 83)">
          <NullNode start="(423, 33)" end="(423, 91)">
            <TermExplicitbinderNode start="(423, 33)" end="(423, 48)">
              <AtomNode start="(423, 33)" end="(423, 34)" leading="" trailing="" val="("/>
              <NullNode start="(423, 34)" end="(423, 35)">
                <IdentNode start="(423, 34)" end="(423, 35)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(423, 36)" end="(423, 47)">
                <AtomNode start="(423, 36)" end="(423, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(423, 38)" end="(423, 47)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(423, 38)" end="(423, 39)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(423, 40)" end="(423, 41)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(423, 42)" end="(423, 47)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(423, 42)" end="(423, 43)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(423, 44)" end="(423, 45)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(423, 46)" end="(423, 47)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(423, 47)" end="(423, 48)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(423, 49)" end="(423, 62)">
              <AtomNode start="(423, 49)" end="(423, 50)" leading="" trailing="" val="("/>
              <NullNode start="(423, 50)" end="(423, 52)">
                <IdentNode start="(423, 50)" end="(423, 52)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(423, 53)" end="(423, 61)">
                <AtomNode start="(423, 53)" end="(423, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(423, 55)" end="(423, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(423, 55)" end="(423, 59)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(423, 60)" end="(423, 61)">
                    <IdentNode start="(423, 60)" end="(423, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(423, 61)" end="(423, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(423, 63)" end="(423, 76)">
              <AtomNode start="(423, 63)" end="(423, 64)" leading="" trailing="" val="("/>
              <NullNode start="(423, 64)" end="(423, 66)">
                <IdentNode start="(423, 64)" end="(423, 66)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(423, 67)" end="(423, 75)">
                <AtomNode start="(423, 67)" end="(423, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(423, 69)" end="(423, 75)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(423, 69)" end="(423, 73)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(423, 74)" end="(423, 75)">
                    <IdentNode start="(423, 74)" end="(423, 75)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(423, 75)" end="(423, 76)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(423, 77)" end="(423, 91)">
              <AtomNode start="(423, 77)" end="(423, 78)" leading="" trailing="" val="("/>
              <NullNode start="(423, 78)" end="(423, 80)">
                <IdentNode start="(423, 78)" end="(423, 80)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(423, 81)" end="(423, 90)">
                <AtomNode start="(423, 81)" end="(423, 82)" leading="" trailing=" " val=":"/>
                <OtherNode start="(423, 83)" end="(423, 90)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(423, 83)" end="(423, 88)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(423, 89)" end="(423, 90)">
                    <IdentNode start="(423, 89)" end="(423, 90)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(423, 90)" end="(423, 91)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(423, 92)" end="(424, 83)">
            <AtomNode start="(423, 92)" end="(423, 93)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(424, 5)" end="(424, 83)" kind="«term_=_»">
              <OtherNode start="(424, 5)" end="(424, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(424, 5)" end="(424, 15)" leading="" trailing=" " raw_val="zipWithAux" val="zipWithAux" full_name="Array.zipWithAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(424, 16)" end="(424, 44)">
                  <IdentNode start="(424, 16)" end="(424, 26)" leading="" trailing=" " raw_val="as.toArray" val="as.toArray"/>
                  <IdentNode start="(424, 27)" end="(424, 37)" leading="" trailing=" " raw_val="bs.toArray" val="bs.toArray"/>
                  <IdentNode start="(424, 38)" end="(424, 39)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(424, 40)" end="(424, 41)" kind="num">
                    <AtomNode start="(424, 40)" end="(424, 41)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <IdentNode start="(424, 42)" end="(424, 44)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(424, 45)" end="(424, 46)" leading="" trailing=" " val="="/>
              <OtherNode start="(424, 47)" end="(424, 83)" kind="«term_++_»">
                <IdentNode start="(424, 47)" end="(424, 49)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <AtomNode start="(424, 50)" end="(424, 52)" leading="" trailing=" " val="++"/>
                <OtherNode start="(424, 53)" end="(424, 83)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(424, 53)" end="(424, 75)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(424, 53)" end="(424, 54)" leading="" trailing="" val="("/>
                    <OtherNode start="(424, 54)" end="(424, 74)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(424, 54)" end="(424, 66)" leading="" trailing=" " raw_val="List.zipWith" val="List.zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(424, 67)" end="(424, 74)">
                        <IdentNode start="(424, 67)" end="(424, 68)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(424, 69)" end="(424, 71)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(424, 72)" end="(424, 74)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(424, 74)" end="(424, 75)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(424, 75)" end="(424, 76)" leading="" trailing="" val="."/>
                  <IdentNode start="(424, 76)" end="(424, 83)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(424, 84)" end="(430, 101)">
          <AtomNode start="(424, 84)" end="(424, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(424, 87)" end="(430, 101)">
            <AtomNode start="(424, 87)" end="(424, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(425, 3)" end="(430, 101)">
              <TacticTacticseq1IndentedNode start="(425, 3)" end="(430, 101)">
                <NullNode start="(425, 3)" end="(430, 101)">
                  <OtherNode start="(425, 3)" end="(425, 24)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : List α&#10;bs : List β&#10;xs : Array γ&#10;⊢ as.toArray.zipWithAux bs.toArray f 0 xs = xs ++ (zipWith f as bs).toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : List α&#10;bs : List β&#10;xs : Array γ&#10;⊢ (if h : 0 &amp;lt; as.toArray.size then&#10;      let a := as.toArray[0];&#10;      if h : 0 &amp;lt; bs.toArray.size then&#10;        let b := bs.toArray[0];&#10;        as.toArray.zipWithAux bs.toArray f (0 + 1) (xs.push (f a b))&#10;      else xs&#10;    else xs) =&#10;    xs ++ (zipWith f as bs).toArray" tactic="rw [Array.zipWithAux]">
                    <AtomNode start="(425, 3)" end="(425, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(425, 6)" end="(425, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(425, 6)" end="(425, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(425, 7)" end="(425, 23)">
                        <OtherNode start="(425, 7)" end="(425, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(425, 7)" end="(425, 23)" leading="" trailing="" raw_val="Array.zipWithAux" val="Array.zipWithAux" full_name="Array.zipWithAux" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(425, 23)" end="(425, 24)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(426, 3)" end="(430, 101)" kind="Lean.Parser.Tactic.match" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : List α&#10;bs : List β&#10;xs : Array γ&#10;⊢ (if h : 0 &amp;lt; as.toArray.size then&#10;      let a := as.toArray[0];&#10;      if h : 0 &amp;lt; bs.toArray.size then&#10;        let b := bs.toArray[0];&#10;        as.toArray.zipWithAux bs.toArray f (0 + 1) (xs.push (f a b))&#10;      else xs&#10;    else xs) =&#10;    xs ++ (zipWith f as bs).toArray" state_after="no goals" tactic="match as, bs with&#10;| [], _ =&amp;gt; simp&#10;| _, [] =&amp;gt; simp&#10;| a :: as, b :: bs =&amp;gt;&#10;  simp [zipWith_cons_cons, zipWithAux_toArray_succ', zipWithAux_toArray_zero, push_append_toArray]">
                    <AtomNode start="(426, 3)" end="(426, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(426, 9)" end="(426, 15)">
                      <OtherNode start="(426, 9)" end="(426, 11)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(426, 9)" end="(426, 11)" leading="" trailing="" raw_val="as" val="as"/>
                      </OtherNode>
                      <AtomNode start="(426, 11)" end="(426, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(426, 13)" end="(426, 15)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(426, 13)" end="(426, 15)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(426, 16)" end="(426, 20)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(427, 3)" end="(430, 101)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(427, 3)" end="(430, 101)">
                        <OtherNode start="(427, 3)" end="(427, 18)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(427, 3)" end="(427, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(427, 5)" end="(427, 10)">
                            <NullNode start="(427, 5)" end="(427, 10)">
                              <OtherNode start="(427, 5)" end="(427, 7)" kind="«term[_]»">
                                <AtomNode start="(427, 5)" end="(427, 6)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(427, 6)" end="(427, 7)" leading="" trailing="" val="]"/>
                              </OtherNode>
                              <AtomNode start="(427, 7)" end="(427, 8)" leading="" trailing=" " val=","/>
                              <TermHoleNode start="(427, 9)" end="(427, 10)">
                                <AtomNode start="(427, 9)" end="(427, 10)" leading="" trailing=" " val="_"/>
                              </TermHoleNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(427, 11)" end="(427, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(427, 14)" end="(427, 18)">
                            <TacticTacticseq1IndentedNode start="(427, 14)" end="(427, 18)">
                              <NullNode start="(427, 14)" end="(427, 18)">
                                <OtherNode start="(427, 14)" end="(427, 18)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : List α&#10;bs : List β&#10;xs : Array γ&#10;x✝ : List β&#10;⊢ (if h : 0 &amp;lt; #[].size then&#10;      let a := #[][0];&#10;      if h : 0 &amp;lt; x✝.toArray.size then&#10;        let b := x✝.toArray[0];&#10;        #[].zipWithAux x✝.toArray f (0 + 1) (xs.push (f a b))&#10;      else xs&#10;    else xs) =&#10;    xs ++ (zipWith f [] x✝).toArray" state_after="no goals" tactic="simp">
                                  <AtomNode start="(427, 14)" end="(427, 18)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(428, 3)" end="(428, 18)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(428, 3)" end="(428, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(428, 5)" end="(428, 10)">
                            <NullNode start="(428, 5)" end="(428, 10)">
                              <TermHoleNode start="(428, 5)" end="(428, 6)">
                                <AtomNode start="(428, 5)" end="(428, 6)" leading="" trailing="" val="_"/>
                              </TermHoleNode>
                              <AtomNode start="(428, 6)" end="(428, 7)" leading="" trailing=" " val=","/>
                              <OtherNode start="(428, 8)" end="(428, 10)" kind="«term[_]»">
                                <AtomNode start="(428, 8)" end="(428, 9)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(428, 9)" end="(428, 10)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(428, 11)" end="(428, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(428, 14)" end="(428, 18)">
                            <TacticTacticseq1IndentedNode start="(428, 14)" end="(428, 18)">
                              <NullNode start="(428, 14)" end="(428, 18)">
                                <OtherNode start="(428, 14)" end="(428, 18)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : List α&#10;bs : List β&#10;xs : Array γ&#10;x✝ : List α&#10;⊢ (if h : 0 &amp;lt; x✝.toArray.size then&#10;      let a := x✝.toArray[0];&#10;      if h : 0 &amp;lt; #[].size then&#10;        let b := #[][0];&#10;        x✝.toArray.zipWithAux #[] f (0 + 1) (xs.push (f a b))&#10;      else xs&#10;    else xs) =&#10;    xs ++ (zipWith f x✝ []).toArray" state_after="no goals" tactic="simp">
                                  <AtomNode start="(428, 14)" end="(428, 18)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(429, 3)" end="(430, 101)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(429, 3)" end="(429, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(429, 5)" end="(429, 21)">
                            <NullNode start="(429, 5)" end="(429, 21)">
                              <OtherNode start="(429, 5)" end="(429, 12)" kind="«term_::_»">
                                <IdentNode start="(429, 5)" end="(429, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                                <AtomNode start="(429, 7)" end="(429, 9)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(429, 10)" end="(429, 12)" leading="" trailing="" raw_val="as" val="as"/>
                              </OtherNode>
                              <AtomNode start="(429, 12)" end="(429, 13)" leading="" trailing=" " val=","/>
                              <OtherNode start="(429, 14)" end="(429, 21)" kind="«term_::_»">
                                <IdentNode start="(429, 14)" end="(429, 15)" leading="" trailing=" " raw_val="b" val="b"/>
                                <AtomNode start="(429, 16)" end="(429, 18)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(429, 19)" end="(429, 21)" leading="" trailing=" " raw_val="bs" val="bs"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(429, 22)" end="(429, 24)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(430, 5)" end="(430, 101)">
                            <TacticTacticseq1IndentedNode start="(430, 5)" end="(430, 101)">
                              <NullNode start="(430, 5)" end="(430, 101)">
                                <OtherNode start="(430, 5)" end="(430, 101)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as✝ : List α&#10;bs✝ : List β&#10;xs : Array γ&#10;a : α&#10;as : List α&#10;b : β&#10;bs : List β&#10;⊢ (if h : 0 &amp;lt; (a :: as).toArray.size then&#10;      let a_1 := (a :: as).toArray[0];&#10;      if h : 0 &amp;lt; (b :: bs).toArray.size then&#10;        let b_1 := (b :: bs).toArray[0];&#10;        (a :: as).toArray.zipWithAux (b :: bs).toArray f (0 + 1) (xs.push (f a_1 b_1))&#10;      else xs&#10;    else xs) =&#10;    xs ++ (zipWith f (a :: as) (b :: bs)).toArray" state_after="no goals" tactic="simp [zipWith_cons_cons, zipWithAux_toArray_succ', zipWithAux_toArray_zero, push_append_toArray]">
                                  <AtomNode start="(430, 5)" end="(430, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(430, 10)" end="(430, 101)">
                                    <AtomNode start="(430, 10)" end="(430, 11)" leading="" trailing="" val="["/>
                                    <NullNode start="(430, 11)" end="(430, 100)">
                                      <OtherNode start="(430, 11)" end="(430, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(430, 11)" end="(430, 28)" leading="" trailing="" raw_val="zipWith_cons_cons" val="zipWith_cons_cons" full_name="List.zipWith_cons_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                      </OtherNode>
                                      <AtomNode start="(430, 28)" end="(430, 29)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(430, 30)" end="(430, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(430, 30)" end="(430, 54)" leading="" trailing="" raw_val="zipWithAux_toArray_succ'" val="zipWithAux_toArray_succ'" full_name="List.zipWithAux_toArray_succ'" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(415, 9)" def_end="(415, 33)"/>
                                      </OtherNode>
                                      <AtomNode start="(430, 54)" end="(430, 55)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(430, 56)" end="(430, 79)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(430, 56)" end="(430, 79)" leading="" trailing="" raw_val="zipWithAux_toArray_zero" val="zipWithAux_toArray_zero"/>
                                      </OtherNode>
                                      <AtomNode start="(430, 79)" end="(430, 80)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(430, 81)" end="(430, 100)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(430, 81)" end="(430, 100)" leading="" trailing="" raw_val="push_append_toArray" val="push_append_toArray" full_name="List.push_append_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(206, 17)" def_end="(206, 36)"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(430, 100)" end="(430, 101)" leading="" trailing="&#10;&#10;" val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(432, 1)" end="(435, 33)" name="zipWith_toArray" full_name="List.zipWith_toArray">
      <CommandDeclmodifiersNode start="(432, 1)" end="(432, 8)">
        <NullNode/>
        <NullNode start="(432, 1)" end="(432, 8)">
          <OtherNode start="(432, 1)" end="(432, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(432, 1)" end="(432, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(432, 3)" end="(432, 7)">
              <OtherNode start="(432, 3)" end="(432, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(432, 3)" end="(432, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(432, 3)" end="(432, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(432, 7)" end="(432, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(432, 9)" end="(435, 33)" name="zipWith_toArray" full_name="List.zipWith_toArray" _is_private_decl="False">
        <AtomNode start="(432, 9)" end="(432, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(432, 17)" end="(432, 32)">
          <IdentNode start="(432, 17)" end="(432, 32)" leading="" trailing=" " raw_val="zipWith_toArray" val="zipWith_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(432, 33)" end="(433, 75)">
          <NullNode start="(432, 33)" end="(432, 76)">
            <TermExplicitbinderNode start="(432, 33)" end="(432, 46)">
              <AtomNode start="(432, 33)" end="(432, 34)" leading="" trailing="" val="("/>
              <NullNode start="(432, 34)" end="(432, 36)">
                <IdentNode start="(432, 34)" end="(432, 36)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(432, 37)" end="(432, 45)">
                <AtomNode start="(432, 37)" end="(432, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(432, 39)" end="(432, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(432, 39)" end="(432, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(432, 44)" end="(432, 45)">
                    <IdentNode start="(432, 44)" end="(432, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(432, 45)" end="(432, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(432, 47)" end="(432, 60)">
              <AtomNode start="(432, 47)" end="(432, 48)" leading="" trailing="" val="("/>
              <NullNode start="(432, 48)" end="(432, 50)">
                <IdentNode start="(432, 48)" end="(432, 50)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(432, 51)" end="(432, 59)">
                <AtomNode start="(432, 51)" end="(432, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(432, 53)" end="(432, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(432, 53)" end="(432, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(432, 58)" end="(432, 59)">
                    <IdentNode start="(432, 58)" end="(432, 59)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(432, 59)" end="(432, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(432, 61)" end="(432, 76)">
              <AtomNode start="(432, 61)" end="(432, 62)" leading="" trailing="" val="("/>
              <NullNode start="(432, 62)" end="(432, 63)">
                <IdentNode start="(432, 62)" end="(432, 63)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(432, 64)" end="(432, 75)">
                <AtomNode start="(432, 64)" end="(432, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(432, 66)" end="(432, 75)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(432, 66)" end="(432, 67)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(432, 68)" end="(432, 69)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(432, 70)" end="(432, 75)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(432, 70)" end="(432, 71)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(432, 72)" end="(432, 73)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(432, 74)" end="(432, 75)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(432, 75)" end="(432, 76)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(432, 77)" end="(433, 75)">
            <AtomNode start="(432, 77)" end="(432, 78)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(433, 5)" end="(433, 75)" kind="«term_=_»">
              <OtherNode start="(433, 5)" end="(433, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(433, 5)" end="(433, 18)" leading="" trailing=" " raw_val="Array.zipWith" val="Array.zipWith" full_name="Array.zipWith" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(433, 19)" end="(433, 42)">
                  <IdentNode start="(433, 19)" end="(433, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(433, 21)" end="(433, 31)" leading="" trailing=" " raw_val="as.toArray" val="as.toArray"/>
                  <IdentNode start="(433, 32)" end="(433, 42)" leading="" trailing=" " raw_val="bs.toArray" val="bs.toArray"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(433, 43)" end="(433, 44)" leading="" trailing=" " val="="/>
              <OtherNode start="(433, 45)" end="(433, 75)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(433, 45)" end="(433, 67)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(433, 45)" end="(433, 46)" leading="" trailing="" val="("/>
                  <OtherNode start="(433, 46)" end="(433, 66)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(433, 46)" end="(433, 58)" leading="" trailing=" " raw_val="List.zipWith" val="List.zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(433, 59)" end="(433, 66)">
                      <IdentNode start="(433, 59)" end="(433, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(433, 61)" end="(433, 63)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(433, 64)" end="(433, 66)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(433, 66)" end="(433, 67)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(433, 67)" end="(433, 68)" leading="" trailing="" val="."/>
                <IdentNode start="(433, 68)" end="(433, 75)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(433, 76)" end="(435, 33)">
          <AtomNode start="(433, 76)" end="(433, 78)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(433, 79)" end="(435, 33)">
            <AtomNode start="(433, 79)" end="(433, 81)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(434, 3)" end="(435, 33)">
              <TacticTacticseq1IndentedNode start="(434, 3)" end="(435, 33)">
                <NullNode start="(434, 3)" end="(435, 33)">
                  <OtherNode start="(434, 3)" end="(434, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;⊢ Array.zipWith f as.toArray bs.toArray = (zipWith f as bs).toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;⊢ as.toArray.zipWithAux bs.toArray f 0 #[] = (zipWith f as bs).toArray" tactic="rw [Array.zipWith]">
                    <AtomNode start="(434, 3)" end="(434, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(434, 6)" end="(434, 21)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(434, 6)" end="(434, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(434, 7)" end="(434, 20)">
                        <OtherNode start="(434, 7)" end="(434, 20)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(434, 7)" end="(434, 20)" leading="" trailing="" raw_val="Array.zipWith" val="Array.zipWith" full_name="Array.zipWith" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(434, 20)" end="(434, 21)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(435, 3)" end="(435, 33)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : α → β → γ&#10;⊢ as.toArray.zipWithAux bs.toArray f 0 #[] = (zipWith f as bs).toArray" state_after="no goals" tactic="simp [zipWithAux_toArray_zero]">
                    <AtomNode start="(435, 3)" end="(435, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(435, 8)" end="(435, 33)">
                      <AtomNode start="(435, 8)" end="(435, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(435, 9)" end="(435, 32)">
                        <OtherNode start="(435, 9)" end="(435, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(435, 9)" end="(435, 32)" leading="" trailing="" raw_val="zipWithAux_toArray_zero" val="zipWithAux_toArray_zero" full_name="List.zipWithAux_toArray_zero" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(423, 9)" def_end="(423, 32)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(435, 32)" end="(435, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(437, 1)" end="(439, 41)" name="zip_toArray" full_name="List.zip_toArray">
      <CommandDeclmodifiersNode start="(437, 1)" end="(437, 8)">
        <NullNode/>
        <NullNode start="(437, 1)" end="(437, 8)">
          <OtherNode start="(437, 1)" end="(437, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(437, 1)" end="(437, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(437, 3)" end="(437, 7)">
              <OtherNode start="(437, 3)" end="(437, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(437, 3)" end="(437, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(437, 3)" end="(437, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(437, 7)" end="(437, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(437, 9)" end="(439, 41)" name="zip_toArray" full_name="List.zip_toArray" _is_private_decl="False">
        <AtomNode start="(437, 9)" end="(437, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(437, 17)" end="(437, 28)">
          <IdentNode start="(437, 17)" end="(437, 28)" leading="" trailing=" " raw_val="zip_toArray" val="zip_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(437, 29)" end="(438, 63)">
          <NullNode start="(437, 29)" end="(437, 56)">
            <TermExplicitbinderNode start="(437, 29)" end="(437, 42)">
              <AtomNode start="(437, 29)" end="(437, 30)" leading="" trailing="" val="("/>
              <NullNode start="(437, 30)" end="(437, 32)">
                <IdentNode start="(437, 30)" end="(437, 32)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(437, 33)" end="(437, 41)">
                <AtomNode start="(437, 33)" end="(437, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(437, 35)" end="(437, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(437, 35)" end="(437, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(437, 40)" end="(437, 41)">
                    <IdentNode start="(437, 40)" end="(437, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(437, 41)" end="(437, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(437, 43)" end="(437, 56)">
              <AtomNode start="(437, 43)" end="(437, 44)" leading="" trailing="" val="("/>
              <NullNode start="(437, 44)" end="(437, 46)">
                <IdentNode start="(437, 44)" end="(437, 46)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(437, 47)" end="(437, 55)">
                <AtomNode start="(437, 47)" end="(437, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(437, 49)" end="(437, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(437, 49)" end="(437, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(437, 54)" end="(437, 55)">
                    <IdentNode start="(437, 54)" end="(437, 55)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(437, 55)" end="(437, 56)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(437, 57)" end="(438, 63)">
            <AtomNode start="(437, 57)" end="(437, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(438, 5)" end="(438, 63)" kind="«term_=_»">
              <OtherNode start="(438, 5)" end="(438, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(438, 5)" end="(438, 14)" leading="" trailing=" " raw_val="Array.zip" val="Array.zip" full_name="Array.zip" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(438, 15)" end="(438, 36)">
                  <IdentNode start="(438, 15)" end="(438, 25)" leading="" trailing=" " raw_val="as.toArray" val="as.toArray"/>
                  <IdentNode start="(438, 26)" end="(438, 36)" leading="" trailing=" " raw_val="bs.toArray" val="bs.toArray"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(438, 37)" end="(438, 38)" leading="" trailing=" " val="="/>
              <OtherNode start="(438, 39)" end="(438, 63)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(438, 39)" end="(438, 55)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(438, 39)" end="(438, 40)" leading="" trailing="" val="("/>
                  <OtherNode start="(438, 40)" end="(438, 54)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(438, 40)" end="(438, 48)" leading="" trailing=" " raw_val="List.zip" val="List.zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(438, 49)" end="(438, 54)">
                      <IdentNode start="(438, 49)" end="(438, 51)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(438, 52)" end="(438, 54)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(438, 54)" end="(438, 55)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(438, 55)" end="(438, 56)" leading="" trailing="" val="."/>
                <IdentNode start="(438, 56)" end="(438, 63)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(438, 64)" end="(439, 41)">
          <AtomNode start="(438, 64)" end="(438, 66)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(438, 67)" end="(439, 41)">
            <AtomNode start="(438, 67)" end="(438, 69)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(439, 3)" end="(439, 41)">
              <TacticTacticseq1IndentedNode start="(439, 3)" end="(439, 41)">
                <NullNode start="(439, 3)" end="(439, 41)">
                  <OtherNode start="(439, 3)" end="(439, 41)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;bs : List β&#10;⊢ as.toArray.zip bs.toArray = (as.zip bs).toArray" state_after="no goals" tactic="simp [Array.zip, zipWith_toArray, zip]">
                    <AtomNode start="(439, 3)" end="(439, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(439, 8)" end="(439, 41)">
                      <AtomNode start="(439, 8)" end="(439, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(439, 9)" end="(439, 40)">
                        <OtherNode start="(439, 9)" end="(439, 18)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(439, 9)" end="(439, 18)" leading="" trailing="" raw_val="Array.zip" val="Array.zip" full_name="Array.zip" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(439, 18)" end="(439, 19)" leading="" trailing=" " val=","/>
                        <OtherNode start="(439, 20)" end="(439, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(439, 20)" end="(439, 35)" leading="" trailing="" raw_val="zipWith_toArray" val="zipWith_toArray" full_name="List.zipWith_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(432, 17)" def_end="(432, 32)"/>
                        </OtherNode>
                        <AtomNode start="(439, 35)" end="(439, 36)" leading="" trailing=" " val=","/>
                        <OtherNode start="(439, 37)" end="(439, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(439, 37)" end="(439, 40)" leading="" trailing="" raw_val="zip" val="zip" full_name="List.zip" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(439, 40)" end="(439, 41)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(441, 1)" end="(473, 54)" name="zipWithAll_go_toArray" full_name="List.zipWithAll_go_toArray">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(441, 1)" end="(473, 54)" name="zipWithAll_go_toArray" full_name="List.zipWithAll_go_toArray" _is_private_decl="False">
        <AtomNode start="(441, 1)" end="(441, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(441, 9)" end="(441, 30)">
          <IdentNode start="(441, 9)" end="(441, 30)" leading="" trailing=" " raw_val="zipWithAll_go_toArray" val="zipWithAll_go_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(441, 31)" end="(442, 107)">
          <NullNode start="(441, 31)" end="(441, 113)">
            <TermExplicitbinderNode start="(441, 31)" end="(441, 44)">
              <AtomNode start="(441, 31)" end="(441, 32)" leading="" trailing="" val="("/>
              <NullNode start="(441, 32)" end="(441, 34)">
                <IdentNode start="(441, 32)" end="(441, 34)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(441, 35)" end="(441, 43)">
                <AtomNode start="(441, 35)" end="(441, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(441, 37)" end="(441, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(441, 37)" end="(441, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(441, 42)" end="(441, 43)">
                    <IdentNode start="(441, 42)" end="(441, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(441, 43)" end="(441, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(441, 45)" end="(441, 58)">
              <AtomNode start="(441, 45)" end="(441, 46)" leading="" trailing="" val="("/>
              <NullNode start="(441, 46)" end="(441, 48)">
                <IdentNode start="(441, 46)" end="(441, 48)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(441, 49)" end="(441, 57)">
                <AtomNode start="(441, 49)" end="(441, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(441, 51)" end="(441, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(441, 51)" end="(441, 55)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(441, 56)" end="(441, 57)">
                    <IdentNode start="(441, 56)" end="(441, 57)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(441, 57)" end="(441, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(441, 59)" end="(441, 88)">
              <AtomNode start="(441, 59)" end="(441, 60)" leading="" trailing="" val="("/>
              <NullNode start="(441, 60)" end="(441, 61)">
                <IdentNode start="(441, 60)" end="(441, 61)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(441, 62)" end="(441, 87)">
                <AtomNode start="(441, 62)" end="(441, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(441, 64)" end="(441, 87)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(441, 64)" end="(441, 72)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(441, 64)" end="(441, 70)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(441, 71)" end="(441, 72)">
                      <IdentNode start="(441, 71)" end="(441, 72)" leading="" trailing=" " raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(441, 73)" end="(441, 74)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(441, 75)" end="(441, 87)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(441, 75)" end="(441, 83)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(441, 75)" end="(441, 81)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(441, 82)" end="(441, 83)">
                        <IdentNode start="(441, 82)" end="(441, 83)" leading="" trailing=" " raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(441, 84)" end="(441, 85)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(441, 86)" end="(441, 87)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(441, 87)" end="(441, 88)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(441, 89)" end="(441, 98)">
              <AtomNode start="(441, 89)" end="(441, 90)" leading="" trailing="" val="("/>
              <NullNode start="(441, 90)" end="(441, 91)">
                <IdentNode start="(441, 90)" end="(441, 91)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(441, 92)" end="(441, 97)">
                <AtomNode start="(441, 92)" end="(441, 93)" leading="" trailing=" " val=":"/>
                <IdentNode start="(441, 94)" end="(441, 97)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(441, 97)" end="(441, 98)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(441, 99)" end="(441, 113)">
              <AtomNode start="(441, 99)" end="(441, 100)" leading="" trailing="" val="("/>
              <NullNode start="(441, 100)" end="(441, 102)">
                <IdentNode start="(441, 100)" end="(441, 102)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(441, 103)" end="(441, 112)">
                <AtomNode start="(441, 103)" end="(441, 104)" leading="" trailing=" " val=":"/>
                <OtherNode start="(441, 105)" end="(441, 112)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(441, 105)" end="(441, 110)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(441, 111)" end="(441, 112)">
                    <IdentNode start="(441, 111)" end="(441, 112)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(441, 112)" end="(441, 113)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(441, 114)" end="(442, 107)">
            <AtomNode start="(441, 114)" end="(441, 115)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(442, 5)" end="(442, 107)" kind="«term_=_»">
              <OtherNode start="(442, 5)" end="(442, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(442, 5)" end="(442, 18)" leading="" trailing=" " raw_val="zipWithAll.go" val="zipWithAll.go" full_name="Array.zipWithAll.go" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(442, 19)" end="(442, 47)">
                  <IdentNode start="(442, 19)" end="(442, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(442, 21)" end="(442, 31)" leading="" trailing=" " raw_val="as.toArray" val="as.toArray"/>
                  <IdentNode start="(442, 32)" end="(442, 42)" leading="" trailing=" " raw_val="bs.toArray" val="bs.toArray"/>
                  <IdentNode start="(442, 43)" end="(442, 44)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(442, 45)" end="(442, 47)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(442, 48)" end="(442, 49)" leading="" trailing=" " val="="/>
              <OtherNode start="(442, 50)" end="(442, 107)" kind="«term_++_»">
                <IdentNode start="(442, 50)" end="(442, 52)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <AtomNode start="(442, 53)" end="(442, 55)" leading="" trailing=" " val="++"/>
                <OtherNode start="(442, 56)" end="(442, 107)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(442, 56)" end="(442, 99)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(442, 56)" end="(442, 57)" leading="" trailing="" val="("/>
                    <OtherNode start="(442, 57)" end="(442, 98)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(442, 57)" end="(442, 72)" leading="" trailing=" " raw_val="List.zipWithAll" val="List.zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(442, 73)" end="(442, 98)">
                        <IdentNode start="(442, 73)" end="(442, 74)" leading="" trailing=" " raw_val="f" val="f"/>
                        <OtherNode start="(442, 75)" end="(442, 86)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(442, 75)" end="(442, 76)" leading="" trailing="" val="("/>
                          <OtherNode start="(442, 76)" end="(442, 85)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(442, 76)" end="(442, 83)" leading="" trailing=" " raw_val="as.drop" val="as.drop"/>
                            <NullNode start="(442, 84)" end="(442, 85)">
                              <IdentNode start="(442, 84)" end="(442, 85)" leading="" trailing="" raw_val="i" val="i"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(442, 85)" end="(442, 86)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <OtherNode start="(442, 87)" end="(442, 98)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(442, 87)" end="(442, 88)" leading="" trailing="" val="("/>
                          <OtherNode start="(442, 88)" end="(442, 97)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(442, 88)" end="(442, 95)" leading="" trailing=" " raw_val="bs.drop" val="bs.drop"/>
                            <NullNode start="(442, 96)" end="(442, 97)">
                              <IdentNode start="(442, 96)" end="(442, 97)" leading="" trailing="" raw_val="i" val="i"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(442, 97)" end="(442, 98)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(442, 98)" end="(442, 99)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(442, 99)" end="(442, 100)" leading="" trailing="" val="."/>
                  <IdentNode start="(442, 100)" end="(442, 107)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(442, 108)" end="(473, 54)">
          <AtomNode start="(442, 108)" end="(442, 110)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(442, 111)" end="(471, 9)">
            <AtomNode start="(442, 111)" end="(442, 113)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(443, 3)" end="(471, 9)">
              <TacticTacticseq1IndentedNode start="(443, 3)" end="(471, 9)">
                <NullNode start="(443, 3)" end="(471, 9)">
                  <OtherNode start="(443, 3)" end="(443, 23)" kind="Lean.Parser.Tactic.unfold" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;⊢ zipWithAll.go f as.toArray bs.toArray i xs = xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;⊢ (if i &amp;lt; max as.toArray.size bs.toArray.size then&#10;      let a := as.toArray[i]?;&#10;      let b := bs.toArray[i]?;&#10;      zipWithAll.go f as.toArray bs.toArray (i + 1) (xs.push (f a b))&#10;    else xs) =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" tactic="unfold zipWithAll.go">
                    <AtomNode start="(443, 3)" end="(443, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(443, 10)" end="(443, 23)">
                      <IdentNode start="(443, 10)" end="(443, 23)" leading="" trailing="&#10;  " raw_val="zipWithAll.go" val="zipWithAll.go" full_name="Array.zipWithAll.go" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(444, 3)" end="(444, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;⊢ (if i &amp;lt; max as.toArray.size bs.toArray.size then&#10;      let a := as.toArray[i]?;&#10;      let b := bs.toArray[i]?;&#10;      zipWithAll.go f as.toArray bs.toArray (i + 1) (xs.push (f a b))&#10;    else xs) =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="case isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.toArray.size bs.toArray.size&#10;⊢ (let a := as.toArray[i]?;&#10;    let b := bs.toArray[i]?;&#10;    zipWithAll.go f as.toArray bs.toArray (i + 1) (xs.push (f a b))) =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray&#10;&#10;case isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : ¬i &amp;lt; max as.toArray.size bs.toArray.size&#10;⊢ xs = xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(444, 3)" end="(444, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(444, 3)" end="(444, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(444, 9)" end="(444, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(444, 13)" end="(444, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(444, 13)" end="(444, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(444, 22)" end="(444, 23)">
                        <LeanBinderidentNode start="(444, 22)" end="(444, 23)">
                          <IdentNode start="(444, 22)" end="(444, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(445, 3)" end="(468, 14)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.toArray.size bs.toArray.size&#10;⊢ (let a := as.toArray[i]?;&#10;    let b := bs.toArray[i]?;&#10;    zipWithAll.go f as.toArray bs.toArray (i + 1) (xs.push (f a b))) =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray&#10;&#10;case isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : ¬i &amp;lt; max as.toArray.size bs.toArray.size&#10;⊢ xs = xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="case isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : ¬i &amp;lt; max as.toArray.size bs.toArray.size&#10;⊢ xs = xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" tactic="· rw [zipWithAll_go_toArray]&#10;  simp at h&#10;  simp only [getElem?_toArray, push_append_toArray]&#10;  if ha : i &amp;lt; as.length then&#10;    if hb : i &amp;lt; bs.length then&#10;      rw [List.drop_eq_getElem_cons ha, List.drop_eq_getElem_cons hb]&#10;      simp only [ha, hb, getElem?_eq_getElem, zipWithAll_cons_cons]&#10;    else&#10;      simp only [Nat.not_lt] at hb&#10;      rw [List.drop_eq_getElem_cons ha]&#10;      rw [(drop_eq_nil_iff (l := bs)).mpr (by omega), (drop_eq_nil_iff (l := bs)).mpr (by omega)]&#10;      simp only [zipWithAll_nil, map_drop, map_cons]&#10;      rw [getElem?_eq_getElem ha]&#10;      rw [getElem?_eq_none hb]&#10;  else&#10;    if hb : i &amp;lt; bs.length then&#10;      simp only [Nat.not_lt] at ha&#10;      rw [List.drop_eq_getElem_cons hb]&#10;      rw [(drop_eq_nil_iff (l := as)).mpr (by omega), (drop_eq_nil_iff (l := as)).mpr (by omega)]&#10;      simp only [nil_zipWithAll, map_drop, map_cons]&#10;      rw [getElem?_eq_getElem hb]&#10;      rw [getElem?_eq_none ha]&#10;    else&#10;      omega">
                    <OtherNode start="(445, 3)" end="(445, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(445, 3)" end="(445, 4)" kind="patternIgnore">
                        <OtherNode start="(445, 3)" end="(445, 4)" kind="token.«· »">
                          <AtomNode start="(445, 3)" end="(445, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(445, 5)" end="(468, 14)">
                      <TacticTacticseq1IndentedNode start="(445, 5)" end="(468, 14)">
                        <NullNode start="(445, 5)" end="(468, 14)">
                          <OtherNode start="(445, 5)" end="(445, 31)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.toArray.size bs.toArray.size&#10;⊢ (let a := as.toArray[i]?;&#10;    let b := bs.toArray[i]?;&#10;    zipWithAll.go f as.toArray bs.toArray (i + 1) (xs.push (f a b))) =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="case isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.toArray.size bs.toArray.size&#10;⊢ xs.push (f as.toArray[i]? bs.toArray[i]?) ++ (zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" tactic="rw [zipWithAll_go_toArray]">
                            <AtomNode start="(445, 5)" end="(445, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(445, 8)" end="(445, 31)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(445, 8)" end="(445, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(445, 9)" end="(445, 30)">
                                <OtherNode start="(445, 9)" end="(445, 30)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(445, 9)" end="(445, 30)" leading="" trailing="" raw_val="zipWithAll_go_toArray" val="zipWithAll_go_toArray"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(445, 30)" end="(445, 31)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(446, 5)" end="(446, 14)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.toArray.size bs.toArray.size&#10;⊢ xs.push (f as.toArray[i]? bs.toArray[i]?) ++ (zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="case isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;⊢ xs.push (f as.toArray[i]? bs.toArray[i]?) ++ (zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" tactic="simp at h">
                            <AtomNode start="(446, 5)" end="(446, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(446, 10)" end="(446, 14)">
                              <OtherNode start="(446, 10)" end="(446, 14)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(446, 10)" end="(446, 12)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(446, 13)" end="(446, 14)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(446, 13)" end="(446, 14)">
                                    <IdentNode start="(446, 13)" end="(446, 14)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(447, 5)" end="(447, 54)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;⊢ xs.push (f as.toArray[i]? bs.toArray[i]?) ++ (zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="case isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" tactic="simp only [getElem?_toArray, push_append_toArray]">
                            <AtomNode start="(447, 5)" end="(447, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(447, 10)" end="(447, 14)">
                              <AtomNode start="(447, 10)" end="(447, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(447, 15)" end="(447, 54)">
                              <AtomNode start="(447, 15)" end="(447, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(447, 16)" end="(447, 53)">
                                <OtherNode start="(447, 16)" end="(447, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(447, 16)" end="(447, 32)" leading="" trailing="" raw_val="getElem?_toArray" val="getElem?_toArray" full_name="List.getElem?_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(447, 32)" end="(447, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(447, 34)" end="(447, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(447, 34)" end="(447, 53)" leading="" trailing="" raw_val="push_append_toArray" val="push_append_toArray" full_name="List.push_append_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(206, 17)" def_end="(206, 36)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(447, 53)" end="(447, 54)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(448, 5)" end="(468, 14)" kind="Lean.Parser.Tactic.tacDepIfThenElse" state_before="case isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="no goals" tactic="if ha : i &amp;lt; as.length then&#10;  if hb : i &amp;lt; bs.length then&#10;    rw [List.drop_eq_getElem_cons ha, List.drop_eq_getElem_cons hb]&#10;    simp only [ha, hb, getElem?_eq_getElem, zipWithAll_cons_cons]&#10;  else&#10;    simp only [Nat.not_lt] at hb&#10;    rw [List.drop_eq_getElem_cons ha]&#10;    rw [(drop_eq_nil_iff (l := bs)).mpr (by omega), (drop_eq_nil_iff (l := bs)).mpr (by omega)]&#10;    simp only [zipWithAll_nil, map_drop, map_cons]&#10;    rw [getElem?_eq_getElem ha]&#10;    rw [getElem?_eq_none hb]&#10;else&#10;  if hb : i &amp;lt; bs.length then&#10;    simp only [Nat.not_lt] at ha&#10;    rw [List.drop_eq_getElem_cons hb]&#10;    rw [(drop_eq_nil_iff (l := as)).mpr (by omega), (drop_eq_nil_iff (l := as)).mpr (by omega)]&#10;    simp only [nil_zipWithAll, map_drop, map_cons]&#10;    rw [getElem?_eq_getElem hb]&#10;    rw [getElem?_eq_none ha]&#10;  else&#10;    omega">
                            <AtomNode start="(448, 5)" end="(448, 7)" leading="" trailing=" " val="if"/>
                            <LeanBinderidentNode start="(448, 8)" end="(448, 10)">
                              <IdentNode start="(448, 8)" end="(448, 10)" leading="" trailing=" " raw_val="ha" val="ha"/>
                            </LeanBinderidentNode>
                            <AtomNode start="(448, 11)" end="(448, 12)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(448, 13)" end="(448, 26)" kind="«term_&amp;lt;_»">
                              <IdentNode start="(448, 13)" end="(448, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                              <AtomNode start="(448, 15)" end="(448, 16)" leading="" trailing=" " val="&amp;lt;"/>
                              <IdentNode start="(448, 17)" end="(448, 26)" leading="" trailing=" " raw_val="as.length" val="as.length"/>
                            </OtherNode>
                            <AtomNode start="(448, 27)" end="(448, 31)" leading="" trailing="&#10;      " val="then"/>
                            <TacticTacticseqNode start="(449, 7)" end="(458, 33)">
                              <TacticTacticseq1IndentedNode start="(449, 7)" end="(458, 33)">
                                <NullNode start="(449, 7)" end="(458, 33)">
                                  <OtherNode start="(449, 7)" end="(458, 33)" kind="Lean.Parser.Tactic.tacDepIfThenElse" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="no goals" tactic="if hb : i &amp;lt; bs.length then&#10;  rw [List.drop_eq_getElem_cons ha, List.drop_eq_getElem_cons hb]&#10;  simp only [ha, hb, getElem?_eq_getElem, zipWithAll_cons_cons]&#10;else&#10;  simp only [Nat.not_lt] at hb&#10;  rw [List.drop_eq_getElem_cons ha]&#10;  rw [(drop_eq_nil_iff (l := bs)).mpr (by omega), (drop_eq_nil_iff (l := bs)).mpr (by omega)]&#10;  simp only [zipWithAll_nil, map_drop, map_cons]&#10;  rw [getElem?_eq_getElem ha]&#10;  rw [getElem?_eq_none hb]">
                                    <AtomNode start="(449, 7)" end="(449, 9)" leading="" trailing=" " val="if"/>
                                    <LeanBinderidentNode start="(449, 10)" end="(449, 12)">
                                      <IdentNode start="(449, 10)" end="(449, 12)" leading="" trailing=" " raw_val="hb" val="hb"/>
                                    </LeanBinderidentNode>
                                    <AtomNode start="(449, 13)" end="(449, 14)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(449, 15)" end="(449, 28)" kind="«term_&amp;lt;_»">
                                      <IdentNode start="(449, 15)" end="(449, 16)" leading="" trailing=" " raw_val="i" val="i"/>
                                      <AtomNode start="(449, 17)" end="(449, 18)" leading="" trailing=" " val="&amp;lt;"/>
                                      <IdentNode start="(449, 19)" end="(449, 28)" leading="" trailing=" " raw_val="bs.length" val="bs.length"/>
                                    </OtherNode>
                                    <AtomNode start="(449, 29)" end="(449, 33)" leading="" trailing="&#10;        " val="then"/>
                                    <TacticTacticseqNode start="(450, 9)" end="(451, 70)">
                                      <TacticTacticseq1IndentedNode start="(450, 9)" end="(451, 70)">
                                        <NullNode start="(450, 9)" end="(451, 70)">
                                          <OtherNode start="(450, 9)" end="(450, 72)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : i &amp;lt; bs.length&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : i &amp;lt; bs.length&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (as[i] :: drop (i + 1) as) (bs[i] :: drop (i + 1) bs)).toArray" tactic="rw [List.drop_eq_getElem_cons ha, List.drop_eq_getElem_cons hb]">
                                            <AtomNode start="(450, 9)" end="(450, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(450, 12)" end="(450, 72)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(450, 12)" end="(450, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(450, 13)" end="(450, 71)">
                                                <OtherNode start="(450, 13)" end="(450, 41)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(450, 13)" end="(450, 41)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(450, 13)" end="(450, 38)" leading="" trailing=" " raw_val="List.drop_eq_getElem_cons" val="List.drop_eq_getElem_cons" full_name="List.drop_eq_getElem_cons" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                    <NullNode start="(450, 39)" end="(450, 41)">
                                                      <IdentNode start="(450, 39)" end="(450, 41)" leading="" trailing="" raw_val="ha" val="ha"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(450, 41)" end="(450, 42)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(450, 43)" end="(450, 71)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(450, 43)" end="(450, 71)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(450, 43)" end="(450, 68)" leading="" trailing=" " raw_val="List.drop_eq_getElem_cons" val="List.drop_eq_getElem_cons" full_name="List.drop_eq_getElem_cons" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                    <NullNode start="(450, 69)" end="(450, 71)">
                                                      <IdentNode start="(450, 69)" end="(450, 71)" leading="" trailing="" raw_val="hb" val="hb"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(450, 71)" end="(450, 72)" leading="" trailing="&#10;        " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(451, 9)" end="(451, 70)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : i &amp;lt; bs.length&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (as[i] :: drop (i + 1) as) (bs[i] :: drop (i + 1) bs)).toArray" state_after="no goals" tactic="simp only [ha, hb, getElem?_eq_getElem, zipWithAll_cons_cons]">
                                            <AtomNode start="(451, 9)" end="(451, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode start="(451, 14)" end="(451, 18)">
                                              <AtomNode start="(451, 14)" end="(451, 18)" leading="" trailing=" " val="only"/>
                                            </NullNode>
                                            <NullNode start="(451, 19)" end="(451, 70)">
                                              <AtomNode start="(451, 19)" end="(451, 20)" leading="" trailing="" val="["/>
                                              <NullNode start="(451, 20)" end="(451, 69)">
                                                <OtherNode start="(451, 20)" end="(451, 22)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(451, 20)" end="(451, 22)" leading="" trailing="" raw_val="ha" val="ha"/>
                                                </OtherNode>
                                                <AtomNode start="(451, 22)" end="(451, 23)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(451, 24)" end="(451, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(451, 24)" end="(451, 26)" leading="" trailing="" raw_val="hb" val="hb"/>
                                                </OtherNode>
                                                <AtomNode start="(451, 26)" end="(451, 27)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(451, 28)" end="(451, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(451, 28)" end="(451, 47)" leading="" trailing="" raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="List.getElem?_eq_getElem" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                </OtherNode>
                                                <AtomNode start="(451, 47)" end="(451, 48)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(451, 49)" end="(451, 69)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(451, 49)" end="(451, 69)" leading="" trailing="" raw_val="zipWithAll_cons_cons" val="zipWithAll_cons_cons" full_name="List.zipWithAll_cons_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(451, 69)" end="(451, 70)" leading="" trailing="&#10;      " val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                    <AtomNode start="(452, 7)" end="(452, 11)" leading="" trailing="&#10;        " val="else"/>
                                    <TacticTacticseqNode start="(453, 9)" end="(458, 33)">
                                      <TacticTacticseq1IndentedNode start="(453, 9)" end="(458, 33)">
                                        <NullNode start="(453, 9)" end="(458, 33)">
                                          <OtherNode start="(453, 9)" end="(453, 37)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : ¬i &amp;lt; bs.length&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : bs.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" tactic="simp only [Nat.not_lt] at hb">
                                            <AtomNode start="(453, 9)" end="(453, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode start="(453, 14)" end="(453, 18)">
                                              <AtomNode start="(453, 14)" end="(453, 18)" leading="" trailing=" " val="only"/>
                                            </NullNode>
                                            <NullNode start="(453, 19)" end="(453, 31)">
                                              <AtomNode start="(453, 19)" end="(453, 20)" leading="" trailing="" val="["/>
                                              <NullNode start="(453, 20)" end="(453, 30)">
                                                <OtherNode start="(453, 20)" end="(453, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(453, 20)" end="(453, 30)" leading="" trailing="" raw_val="Nat.not_lt" val="Nat.not_lt" full_name="Nat.not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(453, 30)" end="(453, 31)" leading="" trailing=" " val="]"/>
                                            </NullNode>
                                            <NullNode start="(453, 32)" end="(453, 37)">
                                              <OtherNode start="(453, 32)" end="(453, 37)" kind="Lean.Parser.Tactic.location">
                                                <AtomNode start="(453, 32)" end="(453, 34)" leading="" trailing=" " val="at"/>
                                                <OtherNode start="(453, 35)" end="(453, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                                  <NullNode start="(453, 35)" end="(453, 37)">
                                                    <IdentNode start="(453, 35)" end="(453, 37)" leading="" trailing="&#10;        " raw_val="hb" val="hb"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(454, 9)" end="(454, 42)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : bs.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : bs.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (as[i] :: drop (i + 1) as) (drop i bs)).toArray" tactic="rw [List.drop_eq_getElem_cons ha]">
                                            <AtomNode start="(454, 9)" end="(454, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(454, 12)" end="(454, 42)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(454, 12)" end="(454, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(454, 13)" end="(454, 41)">
                                                <OtherNode start="(454, 13)" end="(454, 41)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(454, 13)" end="(454, 41)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(454, 13)" end="(454, 38)" leading="" trailing=" " raw_val="List.drop_eq_getElem_cons" val="List.drop_eq_getElem_cons" full_name="List.drop_eq_getElem_cons" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                    <NullNode start="(454, 39)" end="(454, 41)">
                                                      <IdentNode start="(454, 39)" end="(454, 41)" leading="" trailing="" raw_val="ha" val="ha"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(454, 41)" end="(454, 42)" leading="" trailing="&#10;        " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(455, 9)" end="(455, 100)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : bs.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (as[i] :: drop (i + 1) as) (drop i bs)).toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : bs.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) []).toArray =&#10;    xs ++ (zipWithAll f (as[i] :: drop (i + 1) as) []).toArray" tactic="rw [(drop_eq_nil_iff (l := bs)).mpr (by omega), (drop_eq_nil_iff (l := bs)).mpr (by omega)]">
                                            <AtomNode start="(455, 9)" end="(455, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(455, 12)" end="(455, 100)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(455, 12)" end="(455, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(455, 13)" end="(455, 99)">
                                                <OtherNode start="(455, 13)" end="(455, 55)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(455, 13)" end="(455, 55)" kind="Lean.Parser.Term.app">
                                                    <OtherNode start="(455, 13)" end="(455, 44)" kind="Lean.Parser.Term.proj">
                                                      <OtherNode start="(455, 13)" end="(455, 40)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(455, 13)" end="(455, 14)" leading="" trailing="" val="("/>
                                                        <OtherNode start="(455, 14)" end="(455, 39)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(455, 14)" end="(455, 29)" leading="" trailing=" " raw_val="drop_eq_nil_iff" val="drop_eq_nil_iff" full_name="List.drop_eq_nil_iff" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                          <NullNode start="(455, 30)" end="(455, 39)">
                                                            <OtherNode start="(455, 30)" end="(455, 39)" kind="Lean.Parser.Term.namedArgument">
                                                            <AtomNode start="(455, 30)" end="(455, 31)" leading="" trailing="" val="("/>
                                                            <IdentNode start="(455, 31)" end="(455, 32)" leading="" trailing=" " raw_val="l" val="l"/>
                                                            <AtomNode start="(455, 33)" end="(455, 35)" leading="" trailing=" " val=":="/>
                                                            <IdentNode start="(455, 36)" end="(455, 38)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                            <AtomNode start="(455, 38)" end="(455, 39)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <AtomNode start="(455, 39)" end="(455, 40)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                      <AtomNode start="(455, 40)" end="(455, 41)" leading="" trailing="" val="."/>
                                                      <IdentNode start="(455, 41)" end="(455, 44)" leading="" trailing=" " raw_val="mpr" val="mpr" full_name="Iff.mpr" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                    </OtherNode>
                                                    <NullNode start="(455, 45)" end="(455, 55)">
                                                      <OtherNode start="(455, 45)" end="(455, 55)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(455, 45)" end="(455, 46)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(455, 46)" end="(455, 54)">
                                                          <AtomNode start="(455, 46)" end="(455, 48)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(455, 49)" end="(455, 54)">
                                                            <TacticTacticseq1IndentedNode start="(455, 49)" end="(455, 54)">
                                                            <NullNode start="(455, 49)" end="(455, 54)">
                                                            <OtherNode start="(455, 49)" end="(455, 54)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : bs.length ≤ i&#10;⊢ bs.length ≤ i + 1" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(455, 49)" end="(455, 54)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(455, 54)" end="(455, 55)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(455, 55)" end="(455, 56)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(455, 57)" end="(455, 99)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(455, 57)" end="(455, 99)" kind="Lean.Parser.Term.app">
                                                    <OtherNode start="(455, 57)" end="(455, 88)" kind="Lean.Parser.Term.proj">
                                                      <OtherNode start="(455, 57)" end="(455, 84)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(455, 57)" end="(455, 58)" leading="" trailing="" val="("/>
                                                        <OtherNode start="(455, 58)" end="(455, 83)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(455, 58)" end="(455, 73)" leading="" trailing=" " raw_val="drop_eq_nil_iff" val="drop_eq_nil_iff" full_name="List.drop_eq_nil_iff" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                          <NullNode start="(455, 74)" end="(455, 83)">
                                                            <OtherNode start="(455, 74)" end="(455, 83)" kind="Lean.Parser.Term.namedArgument">
                                                            <AtomNode start="(455, 74)" end="(455, 75)" leading="" trailing="" val="("/>
                                                            <IdentNode start="(455, 75)" end="(455, 76)" leading="" trailing=" " raw_val="l" val="l"/>
                                                            <AtomNode start="(455, 77)" end="(455, 79)" leading="" trailing=" " val=":="/>
                                                            <IdentNode start="(455, 80)" end="(455, 82)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                            <AtomNode start="(455, 82)" end="(455, 83)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <AtomNode start="(455, 83)" end="(455, 84)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                      <AtomNode start="(455, 84)" end="(455, 85)" leading="" trailing="" val="."/>
                                                      <IdentNode start="(455, 85)" end="(455, 88)" leading="" trailing=" " raw_val="mpr" val="mpr" full_name="Iff.mpr" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                    </OtherNode>
                                                    <NullNode start="(455, 89)" end="(455, 99)">
                                                      <OtherNode start="(455, 89)" end="(455, 99)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(455, 89)" end="(455, 90)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(455, 90)" end="(455, 98)">
                                                          <AtomNode start="(455, 90)" end="(455, 92)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(455, 93)" end="(455, 98)">
                                                            <TacticTacticseq1IndentedNode start="(455, 93)" end="(455, 98)">
                                                            <NullNode start="(455, 93)" end="(455, 98)">
                                                            <OtherNode start="(455, 93)" end="(455, 98)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : bs.length ≤ i&#10;⊢ bs.length ≤ i" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(455, 93)" end="(455, 98)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(455, 98)" end="(455, 99)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(455, 99)" end="(455, 100)" leading="" trailing="&#10;        " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(456, 9)" end="(456, 55)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : bs.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) []).toArray =&#10;    xs ++ (zipWithAll f (as[i] :: drop (i + 1) as) []).toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : bs.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: drop (i + 1) (map (fun a =&amp;gt; f (some a) none) as)).toArray =&#10;    xs ++ (f (some as[i]) none :: drop (i + 1) (map (fun a =&amp;gt; f (some a) none) as)).toArray" tactic="simp only [zipWithAll_nil, map_drop, map_cons]">
                                            <AtomNode start="(456, 9)" end="(456, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode start="(456, 14)" end="(456, 18)">
                                              <AtomNode start="(456, 14)" end="(456, 18)" leading="" trailing=" " val="only"/>
                                            </NullNode>
                                            <NullNode start="(456, 19)" end="(456, 55)">
                                              <AtomNode start="(456, 19)" end="(456, 20)" leading="" trailing="" val="["/>
                                              <NullNode start="(456, 20)" end="(456, 54)">
                                                <OtherNode start="(456, 20)" end="(456, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(456, 20)" end="(456, 34)" leading="" trailing="" raw_val="zipWithAll_nil" val="zipWithAll_nil" full_name="List.zipWithAll_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                </OtherNode>
                                                <AtomNode start="(456, 34)" end="(456, 35)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(456, 36)" end="(456, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(456, 36)" end="(456, 44)" leading="" trailing="" raw_val="map_drop" val="map_drop" full_name="List.map_drop" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                </OtherNode>
                                                <AtomNode start="(456, 44)" end="(456, 45)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(456, 46)" end="(456, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(456, 46)" end="(456, 54)" leading="" trailing="" raw_val="map_cons" val="map_cons" full_name="List.map_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(456, 54)" end="(456, 55)" leading="" trailing="&#10;        " val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(457, 9)" end="(457, 36)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : bs.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: drop (i + 1) (map (fun a =&amp;gt; f (some a) none) as)).toArray =&#10;    xs ++ (f (some as[i]) none :: drop (i + 1) (map (fun a =&amp;gt; f (some a) none) as)).toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : bs.length ≤ i&#10;⊢ xs ++ (f (some as[i]) bs[i]? :: drop (i + 1) (map (fun a =&amp;gt; f (some a) none) as)).toArray =&#10;    xs ++ (f (some as[i]) none :: drop (i + 1) (map (fun a =&amp;gt; f (some a) none) as)).toArray" tactic="rw [getElem?_eq_getElem ha]">
                                            <AtomNode start="(457, 9)" end="(457, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(457, 12)" end="(457, 36)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(457, 12)" end="(457, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(457, 13)" end="(457, 35)">
                                                <OtherNode start="(457, 13)" end="(457, 35)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(457, 13)" end="(457, 35)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(457, 13)" end="(457, 32)" leading="" trailing=" " raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="List.getElem?_eq_getElem" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                    <NullNode start="(457, 33)" end="(457, 35)">
                                                      <IdentNode start="(457, 33)" end="(457, 35)" leading="" trailing="" raw_val="ha" val="ha"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(457, 35)" end="(457, 36)" leading="" trailing="&#10;        " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(458, 9)" end="(458, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : i &amp;lt; as.length&#10;hb : bs.length ≤ i&#10;⊢ xs ++ (f (some as[i]) bs[i]? :: drop (i + 1) (map (fun a =&amp;gt; f (some a) none) as)).toArray =&#10;    xs ++ (f (some as[i]) none :: drop (i + 1) (map (fun a =&amp;gt; f (some a) none) as)).toArray" state_after="no goals" tactic="rw [getElem?_eq_none hb]">
                                            <AtomNode start="(458, 9)" end="(458, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(458, 12)" end="(458, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(458, 12)" end="(458, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(458, 13)" end="(458, 32)">
                                                <OtherNode start="(458, 13)" end="(458, 32)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(458, 13)" end="(458, 32)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(458, 13)" end="(458, 29)" leading="" trailing=" " raw_val="getElem?_eq_none" val="getElem?_eq_none" full_name="List.getElem?_eq_none" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                    <NullNode start="(458, 30)" end="(458, 32)">
                                                      <IdentNode start="(458, 30)" end="(458, 32)" leading="" trailing="" raw_val="hb" val="hb"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(458, 32)" end="(458, 33)" leading="" trailing="&#10;    " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                            <AtomNode start="(459, 5)" end="(459, 9)" leading="" trailing="&#10;      " val="else"/>
                            <TacticTacticseqNode start="(460, 7)" end="(468, 14)">
                              <TacticTacticseq1IndentedNode start="(460, 7)" end="(468, 14)">
                                <NullNode start="(460, 7)" end="(468, 14)">
                                  <OtherNode start="(460, 7)" end="(468, 14)" kind="Lean.Parser.Tactic.tacDepIfThenElse" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : ¬i &amp;lt; as.length&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="no goals" tactic="if hb : i &amp;lt; bs.length then&#10;  simp only [Nat.not_lt] at ha&#10;  rw [List.drop_eq_getElem_cons hb]&#10;  rw [(drop_eq_nil_iff (l := as)).mpr (by omega), (drop_eq_nil_iff (l := as)).mpr (by omega)]&#10;  simp only [nil_zipWithAll, map_drop, map_cons]&#10;  rw [getElem?_eq_getElem hb]&#10;  rw [getElem?_eq_none ha]&#10;else&#10;  omega">
                                    <AtomNode start="(460, 7)" end="(460, 9)" leading="" trailing=" " val="if"/>
                                    <LeanBinderidentNode start="(460, 10)" end="(460, 12)">
                                      <IdentNode start="(460, 10)" end="(460, 12)" leading="" trailing=" " raw_val="hb" val="hb"/>
                                    </LeanBinderidentNode>
                                    <AtomNode start="(460, 13)" end="(460, 14)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(460, 15)" end="(460, 28)" kind="«term_&amp;lt;_»">
                                      <IdentNode start="(460, 15)" end="(460, 16)" leading="" trailing=" " raw_val="i" val="i"/>
                                      <AtomNode start="(460, 17)" end="(460, 18)" leading="" trailing=" " val="&amp;lt;"/>
                                      <IdentNode start="(460, 19)" end="(460, 28)" leading="" trailing=" " raw_val="bs.length" val="bs.length"/>
                                    </OtherNode>
                                    <AtomNode start="(460, 29)" end="(460, 33)" leading="" trailing="&#10;        " val="then"/>
                                    <TacticTacticseqNode start="(461, 9)" end="(466, 33)">
                                      <TacticTacticseq1IndentedNode start="(461, 9)" end="(466, 33)">
                                        <NullNode start="(461, 9)" end="(466, 33)">
                                          <OtherNode start="(461, 9)" end="(461, 37)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : ¬i &amp;lt; as.length&#10;hb : i &amp;lt; bs.length&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;hb : i &amp;lt; bs.length&#10;ha : as.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" tactic="simp only [Nat.not_lt] at ha">
                                            <AtomNode start="(461, 9)" end="(461, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode start="(461, 14)" end="(461, 18)">
                                              <AtomNode start="(461, 14)" end="(461, 18)" leading="" trailing=" " val="only"/>
                                            </NullNode>
                                            <NullNode start="(461, 19)" end="(461, 31)">
                                              <AtomNode start="(461, 19)" end="(461, 20)" leading="" trailing="" val="["/>
                                              <NullNode start="(461, 20)" end="(461, 30)">
                                                <OtherNode start="(461, 20)" end="(461, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(461, 20)" end="(461, 30)" leading="" trailing="" raw_val="Nat.not_lt" val="Nat.not_lt" full_name="Nat.not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(461, 30)" end="(461, 31)" leading="" trailing=" " val="]"/>
                                            </NullNode>
                                            <NullNode start="(461, 32)" end="(461, 37)">
                                              <OtherNode start="(461, 32)" end="(461, 37)" kind="Lean.Parser.Tactic.location">
                                                <AtomNode start="(461, 32)" end="(461, 34)" leading="" trailing=" " val="at"/>
                                                <OtherNode start="(461, 35)" end="(461, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                                  <NullNode start="(461, 35)" end="(461, 37)">
                                                    <IdentNode start="(461, 35)" end="(461, 37)" leading="" trailing="&#10;        " raw_val="ha" val="ha"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(462, 9)" end="(462, 42)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;hb : i &amp;lt; bs.length&#10;ha : as.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;hb : i &amp;lt; bs.length&#10;ha : as.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (bs[i] :: drop (i + 1) bs)).toArray" tactic="rw [List.drop_eq_getElem_cons hb]">
                                            <AtomNode start="(462, 9)" end="(462, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(462, 12)" end="(462, 42)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(462, 12)" end="(462, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(462, 13)" end="(462, 41)">
                                                <OtherNode start="(462, 13)" end="(462, 41)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(462, 13)" end="(462, 41)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(462, 13)" end="(462, 38)" leading="" trailing=" " raw_val="List.drop_eq_getElem_cons" val="List.drop_eq_getElem_cons" full_name="List.drop_eq_getElem_cons" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                    <NullNode start="(462, 39)" end="(462, 41)">
                                                      <IdentNode start="(462, 39)" end="(462, 41)" leading="" trailing="" raw_val="hb" val="hb"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(462, 41)" end="(462, 42)" leading="" trailing="&#10;        " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(463, 9)" end="(463, 100)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;hb : i &amp;lt; bs.length&#10;ha : as.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (bs[i] :: drop (i + 1) bs)).toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;hb : i &amp;lt; bs.length&#10;ha : as.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f [] (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f [] (bs[i] :: drop (i + 1) bs)).toArray" tactic="rw [(drop_eq_nil_iff (l := as)).mpr (by omega), (drop_eq_nil_iff (l := as)).mpr (by omega)]">
                                            <AtomNode start="(463, 9)" end="(463, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(463, 12)" end="(463, 100)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(463, 12)" end="(463, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(463, 13)" end="(463, 99)">
                                                <OtherNode start="(463, 13)" end="(463, 55)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(463, 13)" end="(463, 55)" kind="Lean.Parser.Term.app">
                                                    <OtherNode start="(463, 13)" end="(463, 44)" kind="Lean.Parser.Term.proj">
                                                      <OtherNode start="(463, 13)" end="(463, 40)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(463, 13)" end="(463, 14)" leading="" trailing="" val="("/>
                                                        <OtherNode start="(463, 14)" end="(463, 39)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(463, 14)" end="(463, 29)" leading="" trailing=" " raw_val="drop_eq_nil_iff" val="drop_eq_nil_iff" full_name="List.drop_eq_nil_iff" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                          <NullNode start="(463, 30)" end="(463, 39)">
                                                            <OtherNode start="(463, 30)" end="(463, 39)" kind="Lean.Parser.Term.namedArgument">
                                                            <AtomNode start="(463, 30)" end="(463, 31)" leading="" trailing="" val="("/>
                                                            <IdentNode start="(463, 31)" end="(463, 32)" leading="" trailing=" " raw_val="l" val="l"/>
                                                            <AtomNode start="(463, 33)" end="(463, 35)" leading="" trailing=" " val=":="/>
                                                            <IdentNode start="(463, 36)" end="(463, 38)" leading="" trailing="" raw_val="as" val="as"/>
                                                            <AtomNode start="(463, 38)" end="(463, 39)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <AtomNode start="(463, 39)" end="(463, 40)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                      <AtomNode start="(463, 40)" end="(463, 41)" leading="" trailing="" val="."/>
                                                      <IdentNode start="(463, 41)" end="(463, 44)" leading="" trailing=" " raw_val="mpr" val="mpr" full_name="Iff.mpr" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                    </OtherNode>
                                                    <NullNode start="(463, 45)" end="(463, 55)">
                                                      <OtherNode start="(463, 45)" end="(463, 55)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(463, 45)" end="(463, 46)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(463, 46)" end="(463, 54)">
                                                          <AtomNode start="(463, 46)" end="(463, 48)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(463, 49)" end="(463, 54)">
                                                            <TacticTacticseq1IndentedNode start="(463, 49)" end="(463, 54)">
                                                            <NullNode start="(463, 49)" end="(463, 54)">
                                                            <OtherNode start="(463, 49)" end="(463, 54)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;hb : i &amp;lt; bs.length&#10;ha : as.length ≤ i&#10;⊢ as.length ≤ i + 1" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(463, 49)" end="(463, 54)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(463, 54)" end="(463, 55)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(463, 55)" end="(463, 56)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(463, 57)" end="(463, 99)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(463, 57)" end="(463, 99)" kind="Lean.Parser.Term.app">
                                                    <OtherNode start="(463, 57)" end="(463, 88)" kind="Lean.Parser.Term.proj">
                                                      <OtherNode start="(463, 57)" end="(463, 84)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(463, 57)" end="(463, 58)" leading="" trailing="" val="("/>
                                                        <OtherNode start="(463, 58)" end="(463, 83)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(463, 58)" end="(463, 73)" leading="" trailing=" " raw_val="drop_eq_nil_iff" val="drop_eq_nil_iff" full_name="List.drop_eq_nil_iff" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                          <NullNode start="(463, 74)" end="(463, 83)">
                                                            <OtherNode start="(463, 74)" end="(463, 83)" kind="Lean.Parser.Term.namedArgument">
                                                            <AtomNode start="(463, 74)" end="(463, 75)" leading="" trailing="" val="("/>
                                                            <IdentNode start="(463, 75)" end="(463, 76)" leading="" trailing=" " raw_val="l" val="l"/>
                                                            <AtomNode start="(463, 77)" end="(463, 79)" leading="" trailing=" " val=":="/>
                                                            <IdentNode start="(463, 80)" end="(463, 82)" leading="" trailing="" raw_val="as" val="as"/>
                                                            <AtomNode start="(463, 82)" end="(463, 83)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <AtomNode start="(463, 83)" end="(463, 84)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                      <AtomNode start="(463, 84)" end="(463, 85)" leading="" trailing="" val="."/>
                                                      <IdentNode start="(463, 85)" end="(463, 88)" leading="" trailing=" " raw_val="mpr" val="mpr" full_name="Iff.mpr" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                    </OtherNode>
                                                    <NullNode start="(463, 89)" end="(463, 99)">
                                                      <OtherNode start="(463, 89)" end="(463, 99)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(463, 89)" end="(463, 90)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(463, 90)" end="(463, 98)">
                                                          <AtomNode start="(463, 90)" end="(463, 92)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(463, 93)" end="(463, 98)">
                                                            <TacticTacticseq1IndentedNode start="(463, 93)" end="(463, 98)">
                                                            <NullNode start="(463, 93)" end="(463, 98)">
                                                            <OtherNode start="(463, 93)" end="(463, 98)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;hb : i &amp;lt; bs.length&#10;ha : as.length ≤ i&#10;⊢ as.length ≤ i" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(463, 93)" end="(463, 98)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(463, 98)" end="(463, 99)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(463, 99)" end="(463, 100)" leading="" trailing="&#10;        " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(464, 9)" end="(464, 55)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;hb : i &amp;lt; bs.length&#10;ha : as.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f [] (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f [] (bs[i] :: drop (i + 1) bs)).toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;hb : i &amp;lt; bs.length&#10;ha : as.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: drop (i + 1) (map (fun b =&amp;gt; f none (some b)) bs)).toArray =&#10;    xs ++ (f none (some bs[i]) :: drop (i + 1) (map (fun b =&amp;gt; f none (some b)) bs)).toArray" tactic="simp only [nil_zipWithAll, map_drop, map_cons]">
                                            <AtomNode start="(464, 9)" end="(464, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode start="(464, 14)" end="(464, 18)">
                                              <AtomNode start="(464, 14)" end="(464, 18)" leading="" trailing=" " val="only"/>
                                            </NullNode>
                                            <NullNode start="(464, 19)" end="(464, 55)">
                                              <AtomNode start="(464, 19)" end="(464, 20)" leading="" trailing="" val="["/>
                                              <NullNode start="(464, 20)" end="(464, 54)">
                                                <OtherNode start="(464, 20)" end="(464, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(464, 20)" end="(464, 34)" leading="" trailing="" raw_val="nil_zipWithAll" val="nil_zipWithAll" full_name="List.nil_zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                </OtherNode>
                                                <AtomNode start="(464, 34)" end="(464, 35)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(464, 36)" end="(464, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(464, 36)" end="(464, 44)" leading="" trailing="" raw_val="map_drop" val="map_drop" full_name="List.map_drop" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                </OtherNode>
                                                <AtomNode start="(464, 44)" end="(464, 45)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(464, 46)" end="(464, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(464, 46)" end="(464, 54)" leading="" trailing="" raw_val="map_cons" val="map_cons" full_name="List.map_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(464, 54)" end="(464, 55)" leading="" trailing="&#10;        " val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(465, 9)" end="(465, 36)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;hb : i &amp;lt; bs.length&#10;ha : as.length ≤ i&#10;⊢ xs ++ (f as[i]? bs[i]? :: drop (i + 1) (map (fun b =&amp;gt; f none (some b)) bs)).toArray =&#10;    xs ++ (f none (some bs[i]) :: drop (i + 1) (map (fun b =&amp;gt; f none (some b)) bs)).toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;hb : i &amp;lt; bs.length&#10;ha : as.length ≤ i&#10;⊢ xs ++ (f as[i]? (some bs[i]) :: drop (i + 1) (map (fun b =&amp;gt; f none (some b)) bs)).toArray =&#10;    xs ++ (f none (some bs[i]) :: drop (i + 1) (map (fun b =&amp;gt; f none (some b)) bs)).toArray" tactic="rw [getElem?_eq_getElem hb]">
                                            <AtomNode start="(465, 9)" end="(465, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(465, 12)" end="(465, 36)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(465, 12)" end="(465, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(465, 13)" end="(465, 35)">
                                                <OtherNode start="(465, 13)" end="(465, 35)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(465, 13)" end="(465, 35)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(465, 13)" end="(465, 32)" leading="" trailing=" " raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="List.getElem?_eq_getElem" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                    <NullNode start="(465, 33)" end="(465, 35)">
                                                      <IdentNode start="(465, 33)" end="(465, 35)" leading="" trailing="" raw_val="hb" val="hb"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(465, 35)" end="(465, 36)" leading="" trailing="&#10;        " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(466, 9)" end="(466, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;hb : i &amp;lt; bs.length&#10;ha : as.length ≤ i&#10;⊢ xs ++ (f as[i]? (some bs[i]) :: drop (i + 1) (map (fun b =&amp;gt; f none (some b)) bs)).toArray =&#10;    xs ++ (f none (some bs[i]) :: drop (i + 1) (map (fun b =&amp;gt; f none (some b)) bs)).toArray" state_after="no goals" tactic="rw [getElem?_eq_none ha]">
                                            <AtomNode start="(466, 9)" end="(466, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(466, 12)" end="(466, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(466, 12)" end="(466, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(466, 13)" end="(466, 32)">
                                                <OtherNode start="(466, 13)" end="(466, 32)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(466, 13)" end="(466, 32)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(466, 13)" end="(466, 29)" leading="" trailing=" " raw_val="getElem?_eq_none" val="getElem?_eq_none" full_name="List.getElem?_eq_none" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                    <NullNode start="(466, 30)" end="(466, 32)">
                                                      <IdentNode start="(466, 30)" end="(466, 32)" leading="" trailing="" raw_val="ha" val="ha"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(466, 32)" end="(466, 33)" leading="" trailing="&#10;      " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                    <AtomNode start="(467, 7)" end="(467, 11)" leading="" trailing="&#10;        " val="else"/>
                                    <TacticTacticseqNode start="(468, 9)" end="(468, 14)">
                                      <TacticTacticseq1IndentedNode start="(468, 9)" end="(468, 14)">
                                        <NullNode start="(468, 9)" end="(468, 14)">
                                          <OtherNode start="(468, 9)" end="(468, 14)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : i &amp;lt; max as.length bs.length&#10;ha : ¬i &amp;lt; as.length&#10;hb : ¬i &amp;lt; bs.length&#10;⊢ xs ++ (f as[i]? bs[i]? :: zipWithAll f (drop (i + 1) as) (drop (i + 1) bs)).toArray =&#10;    xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="no goals" tactic="omega">
                                            <AtomNode start="(468, 9)" end="(468, 14)" leading="" trailing="&#10;  " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(469, 3)" end="(471, 9)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : ¬i &amp;lt; max as.toArray.size bs.toArray.size&#10;⊢ xs = xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="no goals" tactic="· simp only [size_toArray, Nat.not_lt] at h&#10;  rw [drop_eq_nil_of_le (by omega), drop_eq_nil_of_le (by omega)]&#10;  simp">
                    <OtherNode start="(469, 3)" end="(469, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(469, 3)" end="(469, 4)" kind="patternIgnore">
                        <OtherNode start="(469, 3)" end="(469, 4)" kind="token.«· »">
                          <AtomNode start="(469, 3)" end="(469, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(469, 5)" end="(471, 9)">
                      <TacticTacticseq1IndentedNode start="(469, 5)" end="(471, 9)">
                        <NullNode start="(469, 5)" end="(471, 9)">
                          <OtherNode start="(469, 5)" end="(469, 46)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : ¬i &amp;lt; max as.toArray.size bs.toArray.size&#10;⊢ xs = xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="case isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : max as.length bs.length ≤ i&#10;⊢ xs = xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" tactic="simp only [size_toArray, Nat.not_lt] at h">
                            <AtomNode start="(469, 5)" end="(469, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(469, 10)" end="(469, 14)">
                              <AtomNode start="(469, 10)" end="(469, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(469, 15)" end="(469, 41)">
                              <AtomNode start="(469, 15)" end="(469, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(469, 16)" end="(469, 40)">
                                <OtherNode start="(469, 16)" end="(469, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(469, 16)" end="(469, 28)" leading="" trailing="" raw_val="size_toArray" val="size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(469, 28)" end="(469, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(469, 30)" end="(469, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(469, 30)" end="(469, 40)" leading="" trailing="" raw_val="Nat.not_lt" val="Nat.not_lt" full_name="Nat.not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(469, 40)" end="(469, 41)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(469, 42)" end="(469, 46)">
                              <OtherNode start="(469, 42)" end="(469, 46)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(469, 42)" end="(469, 44)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(469, 45)" end="(469, 46)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(469, 45)" end="(469, 46)">
                                    <IdentNode start="(469, 45)" end="(469, 46)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(470, 5)" end="(470, 68)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : max as.length bs.length ≤ i&#10;⊢ xs = xs ++ (zipWithAll f (drop i as) (drop i bs)).toArray" state_after="case isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : max as.length bs.length ≤ i&#10;⊢ xs = xs ++ (zipWithAll f [] []).toArray" tactic="rw [drop_eq_nil_of_le (by omega), drop_eq_nil_of_le (by omega)]">
                            <AtomNode start="(470, 5)" end="(470, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(470, 8)" end="(470, 68)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(470, 8)" end="(470, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(470, 9)" end="(470, 67)">
                                <OtherNode start="(470, 9)" end="(470, 37)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(470, 9)" end="(470, 37)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(470, 9)" end="(470, 26)" leading="" trailing=" " raw_val="drop_eq_nil_of_le" val="drop_eq_nil_of_le" full_name="List.drop_eq_nil_of_le" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                    <NullNode start="(470, 27)" end="(470, 37)">
                                      <OtherNode start="(470, 27)" end="(470, 37)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(470, 27)" end="(470, 28)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(470, 28)" end="(470, 36)">
                                          <AtomNode start="(470, 28)" end="(470, 30)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(470, 31)" end="(470, 36)">
                                            <TacticTacticseq1IndentedNode start="(470, 31)" end="(470, 36)">
                                              <NullNode start="(470, 31)" end="(470, 36)">
                                                <OtherNode start="(470, 31)" end="(470, 36)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : max as.length bs.length ≤ i&#10;⊢ as.length ≤ i" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(470, 31)" end="(470, 36)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(470, 36)" end="(470, 37)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(470, 37)" end="(470, 38)" leading="" trailing=" " val=","/>
                                <OtherNode start="(470, 39)" end="(470, 67)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(470, 39)" end="(470, 67)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(470, 39)" end="(470, 56)" leading="" trailing=" " raw_val="drop_eq_nil_of_le" val="drop_eq_nil_of_le" full_name="List.drop_eq_nil_of_le" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                    <NullNode start="(470, 57)" end="(470, 67)">
                                      <OtherNode start="(470, 57)" end="(470, 67)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(470, 57)" end="(470, 58)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(470, 58)" end="(470, 66)">
                                          <AtomNode start="(470, 58)" end="(470, 60)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(470, 61)" end="(470, 66)">
                                            <TacticTacticseq1IndentedNode start="(470, 61)" end="(470, 66)">
                                              <NullNode start="(470, 61)" end="(470, 66)">
                                                <OtherNode start="(470, 61)" end="(470, 66)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : max as.length bs.length ≤ i&#10;⊢ bs.length ≤ i" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(470, 61)" end="(470, 66)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(470, 66)" end="(470, 67)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(470, 67)" end="(470, 68)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(471, 5)" end="(471, 9)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;i : Nat&#10;xs : Array γ&#10;h : max as.length bs.length ≤ i&#10;⊢ xs = xs ++ (zipWithAll f [] []).toArray" state_after="no goals" tactic="simp">
                            <AtomNode start="(471, 5)" end="(471, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode start="(472, 3)" end="(473, 54)" kind="Lean.Parser.Termination.suffix">
            <NullNode start="(472, 3)" end="(472, 45)">
              <OtherNode start="(472, 3)" end="(472, 45)" kind="Lean.Parser.Termination.terminationBy">
                <AtomNode start="(472, 3)" end="(472, 17)" leading="" trailing=" " val="termination_by"/>
                <NullNode/>
                <NullNode/>
                <OtherNode start="(472, 18)" end="(472, 45)" kind="«term_-_»">
                  <OtherNode start="(472, 18)" end="(472, 41)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(472, 18)" end="(472, 21)" leading="" trailing=" " raw_val="max" val="max" full_name="Max.max" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(472, 22)" end="(472, 41)">
                      <IdentNode start="(472, 22)" end="(472, 31)" leading="" trailing=" " raw_val="as.length" val="as.length"/>
                      <IdentNode start="(472, 32)" end="(472, 41)" leading="" trailing=" " raw_val="bs.length" val="bs.length"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(472, 42)" end="(472, 43)" leading="" trailing=" " val="-"/>
                  <IdentNode start="(472, 44)" end="(472, 45)" leading="" trailing="&#10;  " raw_val="i" val="i"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <NullNode start="(473, 3)" end="(473, 54)">
              <OtherNode start="(473, 3)" end="(473, 54)" kind="Lean.Parser.Termination.decreasingBy">
                <AtomNode start="(473, 3)" end="(473, 16)" leading="" trailing=" " val="decreasing_by"/>
                <TacticTacticseqNode start="(473, 17)" end="(473, 54)">
                  <TacticTacticseq1IndentedNode start="(473, 17)" end="(473, 54)">
                    <NullNode start="(473, 17)" end="(473, 54)">
                      <OtherNode start="(473, 17)" end="(473, 24)" kind="tacticSimp_wf">
                        <AtomNode start="(473, 17)" end="(473, 24)" leading="" trailing="" val="simp_wf"/>
                      </OtherNode>
                      <AtomNode start="(473, 24)" end="(473, 25)" leading="" trailing=" " val=";"/>
                      <OtherNode start="(473, 26)" end="(473, 54)" kind="tacticDecreasing_trivial_pre_omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;as : List α&#10;bs : List β&#10;f : Option α → Option β → γ&#10;_x : (_ : Nat) ×' Array γ&#10;a✝¹ :&#10;  ∀ (y : (_ : Nat) ×' Array γ),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun i xs =&amp;gt; max as.length bs.length - i) instWellFoundedRelationOfSizeOf).1 y&#10;        _x →&#10;      zipWithAll.go f as.toArray bs.toArray y.1 y.2 = y.2 ++ (zipWithAll f (drop y.1 as) (drop y.1 bs)).toArray&#10;i : Nat&#10;xs : Array γ&#10;a✝ :&#10;  ∀ (y : (_ : Nat) ×' Array γ),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun i xs =&amp;gt; max as.length bs.length - i) instWellFoundedRelationOfSizeOf).1 y&#10;        ⟨i, xs⟩ →&#10;      zipWithAll.go f as.toArray bs.toArray y.1 y.2 = y.2 ++ (zipWithAll f (drop y.1 as) (drop y.1 bs)).toArray&#10;h✝ : i &amp;lt; max as.toArray.size bs.toArray.size&#10;⊢ max as.length bs.length - (i + 1) &amp;lt; max as.length bs.length - i" state_after="no goals" tactic="decreasing_trivial_pre_omega">
                        <AtomNode start="(473, 26)" end="(473, 54)" leading="" trailing="&#10;&#10;" val="decreasing_trivial_pre_omega"/>
                      </OtherNode>
                    </NullNode>
                  </TacticTacticseq1IndentedNode>
                </TacticTacticseqNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(475, 1)" end="(477, 49)" name="zipWithAll_toArray" full_name="List.zipWithAll_toArray">
      <CommandDeclmodifiersNode start="(475, 1)" end="(475, 8)">
        <NullNode/>
        <NullNode start="(475, 1)" end="(475, 8)">
          <OtherNode start="(475, 1)" end="(475, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(475, 1)" end="(475, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(475, 3)" end="(475, 7)">
              <OtherNode start="(475, 3)" end="(475, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(475, 3)" end="(475, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(475, 3)" end="(475, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(475, 7)" end="(475, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(475, 9)" end="(477, 49)" name="zipWithAll_toArray" full_name="List.zipWithAll_toArray" _is_private_decl="False">
        <AtomNode start="(475, 9)" end="(475, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(475, 17)" end="(475, 35)">
          <IdentNode start="(475, 17)" end="(475, 35)" leading="" trailing=" " raw_val="zipWithAll_toArray" val="zipWithAll_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(475, 36)" end="(476, 81)">
          <NullNode start="(475, 36)" end="(475, 93)">
            <TermExplicitbinderNode start="(475, 36)" end="(475, 65)">
              <AtomNode start="(475, 36)" end="(475, 37)" leading="" trailing="" val="("/>
              <NullNode start="(475, 37)" end="(475, 38)">
                <IdentNode start="(475, 37)" end="(475, 38)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(475, 39)" end="(475, 64)">
                <AtomNode start="(475, 39)" end="(475, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(475, 41)" end="(475, 64)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(475, 41)" end="(475, 49)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(475, 41)" end="(475, 47)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(475, 48)" end="(475, 49)">
                      <IdentNode start="(475, 48)" end="(475, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(475, 50)" end="(475, 51)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(475, 52)" end="(475, 64)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(475, 52)" end="(475, 60)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(475, 52)" end="(475, 58)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(475, 59)" end="(475, 60)">
                        <IdentNode start="(475, 59)" end="(475, 60)" leading="" trailing=" " raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(475, 61)" end="(475, 62)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(475, 63)" end="(475, 64)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(475, 64)" end="(475, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(475, 66)" end="(475, 79)">
              <AtomNode start="(475, 66)" end="(475, 67)" leading="" trailing="" val="("/>
              <NullNode start="(475, 67)" end="(475, 69)">
                <IdentNode start="(475, 67)" end="(475, 69)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(475, 70)" end="(475, 78)">
                <AtomNode start="(475, 70)" end="(475, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(475, 72)" end="(475, 78)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(475, 72)" end="(475, 76)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(475, 77)" end="(475, 78)">
                    <IdentNode start="(475, 77)" end="(475, 78)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(475, 78)" end="(475, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(475, 80)" end="(475, 93)">
              <AtomNode start="(475, 80)" end="(475, 81)" leading="" trailing="" val="("/>
              <NullNode start="(475, 81)" end="(475, 83)">
                <IdentNode start="(475, 81)" end="(475, 83)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(475, 84)" end="(475, 92)">
                <AtomNode start="(475, 84)" end="(475, 85)" leading="" trailing=" " val=":"/>
                <OtherNode start="(475, 86)" end="(475, 92)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(475, 86)" end="(475, 90)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(475, 91)" end="(475, 92)">
                    <IdentNode start="(475, 91)" end="(475, 92)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(475, 92)" end="(475, 93)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(475, 94)" end="(476, 81)">
            <AtomNode start="(475, 94)" end="(475, 95)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(476, 5)" end="(476, 81)" kind="«term_=_»">
              <OtherNode start="(476, 5)" end="(476, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(476, 5)" end="(476, 21)" leading="" trailing=" " raw_val="Array.zipWithAll" val="Array.zipWithAll" full_name="Array.zipWithAll" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(476, 22)" end="(476, 45)">
                  <IdentNode start="(476, 22)" end="(476, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(476, 24)" end="(476, 34)" leading="" trailing=" " raw_val="as.toArray" val="as.toArray"/>
                  <IdentNode start="(476, 35)" end="(476, 45)" leading="" trailing=" " raw_val="bs.toArray" val="bs.toArray"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(476, 46)" end="(476, 47)" leading="" trailing=" " val="="/>
              <OtherNode start="(476, 48)" end="(476, 81)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(476, 48)" end="(476, 73)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(476, 48)" end="(476, 49)" leading="" trailing="" val="("/>
                  <OtherNode start="(476, 49)" end="(476, 72)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(476, 49)" end="(476, 64)" leading="" trailing=" " raw_val="List.zipWithAll" val="List.zipWithAll" full_name="List.zipWithAll" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(476, 65)" end="(476, 72)">
                      <IdentNode start="(476, 65)" end="(476, 66)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(476, 67)" end="(476, 69)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(476, 70)" end="(476, 72)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(476, 72)" end="(476, 73)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(476, 73)" end="(476, 74)" leading="" trailing="" val="."/>
                <IdentNode start="(476, 74)" end="(476, 81)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(476, 82)" end="(477, 49)">
          <AtomNode start="(476, 82)" end="(476, 84)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(476, 85)" end="(477, 49)">
            <AtomNode start="(476, 85)" end="(476, 87)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(477, 3)" end="(477, 49)">
              <TacticTacticseq1IndentedNode start="(477, 3)" end="(477, 49)">
                <NullNode start="(477, 3)" end="(477, 49)">
                  <OtherNode start="(477, 3)" end="(477, 49)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : Option α → Option β → γ&#10;as : List α&#10;bs : List β&#10;⊢ Array.zipWithAll f as.toArray bs.toArray = (zipWithAll f as bs).toArray" state_after="no goals" tactic="simp [Array.zipWithAll, zipWithAll_go_toArray]">
                    <AtomNode start="(477, 3)" end="(477, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(477, 8)" end="(477, 49)">
                      <AtomNode start="(477, 8)" end="(477, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(477, 9)" end="(477, 48)">
                        <OtherNode start="(477, 9)" end="(477, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(477, 9)" end="(477, 25)" leading="" trailing="" raw_val="Array.zipWithAll" val="Array.zipWithAll" full_name="Array.zipWithAll" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(477, 25)" end="(477, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(477, 27)" end="(477, 48)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(477, 27)" end="(477, 48)" leading="" trailing="" raw_val="zipWithAll_go_toArray" val="zipWithAll_go_toArray" full_name="List.zipWithAll_go_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(441, 9)" def_end="(441, 30)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(477, 48)" end="(477, 49)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(479, 1)" end="(482, 7)" name="toArray_appendList" full_name="List.toArray_appendList">
      <CommandDeclmodifiersNode start="(479, 1)" end="(479, 8)">
        <NullNode/>
        <NullNode start="(479, 1)" end="(479, 8)">
          <OtherNode start="(479, 1)" end="(479, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(479, 1)" end="(479, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(479, 3)" end="(479, 7)">
              <OtherNode start="(479, 3)" end="(479, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(479, 3)" end="(479, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(479, 3)" end="(479, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(479, 7)" end="(479, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(479, 9)" end="(482, 7)" name="toArray_appendList" full_name="List.toArray_appendList" _is_private_decl="False">
        <AtomNode start="(479, 9)" end="(479, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(479, 17)" end="(479, 35)">
          <IdentNode start="(479, 17)" end="(479, 35)" leading="" trailing=" " raw_val="toArray_appendList" val="toArray_appendList"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(479, 36)" end="(480, 42)">
          <NullNode start="(479, 36)" end="(479, 52)">
            <TermExplicitbinderNode start="(479, 36)" end="(479, 52)">
              <AtomNode start="(479, 36)" end="(479, 37)" leading="" trailing="" val="("/>
              <NullNode start="(479, 37)" end="(479, 42)">
                <IdentNode start="(479, 37)" end="(479, 39)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(479, 40)" end="(479, 42)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(479, 43)" end="(479, 51)">
                <AtomNode start="(479, 43)" end="(479, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(479, 45)" end="(479, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(479, 45)" end="(479, 49)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(479, 50)" end="(479, 51)">
                    <IdentNode start="(479, 50)" end="(479, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(479, 51)" end="(479, 52)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(479, 53)" end="(480, 42)">
            <AtomNode start="(479, 53)" end="(479, 54)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(480, 5)" end="(480, 42)" kind="«term_=_»">
              <OtherNode start="(480, 5)" end="(480, 21)" kind="«term_++_»">
                <IdentNode start="(480, 5)" end="(480, 15)" leading="" trailing=" " raw_val="l₁.toArray" val="l₁.toArray"/>
                <AtomNode start="(480, 16)" end="(480, 18)" leading="" trailing=" " val="++"/>
                <IdentNode start="(480, 19)" end="(480, 21)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
              <AtomNode start="(480, 22)" end="(480, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(480, 24)" end="(480, 42)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(480, 24)" end="(480, 34)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(480, 24)" end="(480, 25)" leading="" trailing="" val="("/>
                  <OtherNode start="(480, 25)" end="(480, 33)" kind="«term_++_»">
                    <IdentNode start="(480, 25)" end="(480, 27)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <AtomNode start="(480, 28)" end="(480, 30)" leading="" trailing=" " val="++"/>
                    <IdentNode start="(480, 31)" end="(480, 33)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                  </OtherNode>
                  <AtomNode start="(480, 33)" end="(480, 34)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(480, 34)" end="(480, 35)" leading="" trailing="" val="."/>
                <IdentNode start="(480, 35)" end="(480, 42)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(480, 43)" end="(482, 7)">
          <AtomNode start="(480, 43)" end="(480, 45)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(480, 46)" end="(482, 7)">
            <AtomNode start="(480, 46)" end="(480, 48)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(481, 3)" end="(482, 7)">
              <TacticTacticseq1IndentedNode start="(481, 3)" end="(482, 7)">
                <NullNode start="(481, 3)" end="(482, 7)">
                  <OtherNode start="(481, 3)" end="(481, 13)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;l₁ l₂ : List α&#10;⊢ l₁.toArray ++ l₂ = (l₁ ++ l₂).toArray" state_after="case h&#10;α : Type u_1&#10;l₁ l₂ : List α&#10;⊢ (l₁.toArray ++ l₂).toList = (l₁ ++ l₂).toArray.toList" tactic="apply ext'">
                    <AtomNode start="(481, 3)" end="(481, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(481, 9)" end="(481, 13)" leading="" trailing="&#10;  " raw_val="ext'" val="ext'" full_name="Array.ext'" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(482, 3)" end="(482, 7)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;l₁ l₂ : List α&#10;⊢ (l₁.toArray ++ l₂).toList = (l₁ ++ l₂).toArray.toList" state_after="no goals" tactic="simp">
                    <AtomNode start="(482, 3)" end="(482, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(484, 1)" end="(486, 7)" name="pop_toArray" full_name="List.pop_toArray">
      <CommandDeclmodifiersNode start="(484, 1)" end="(484, 8)">
        <NullNode/>
        <NullNode start="(484, 1)" end="(484, 8)">
          <OtherNode start="(484, 1)" end="(484, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(484, 1)" end="(484, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(484, 3)" end="(484, 7)">
              <OtherNode start="(484, 3)" end="(484, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(484, 3)" end="(484, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(484, 3)" end="(484, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(484, 7)" end="(484, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(484, 9)" end="(486, 7)" name="pop_toArray" full_name="List.pop_toArray" _is_private_decl="False">
        <AtomNode start="(484, 9)" end="(484, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(484, 17)" end="(484, 28)">
          <IdentNode start="(484, 17)" end="(484, 28)" leading="" trailing=" " raw_val="pop_toArray" val="pop_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(484, 29)" end="(484, 78)">
          <NullNode start="(484, 29)" end="(484, 41)">
            <TermExplicitbinderNode start="(484, 29)" end="(484, 41)">
              <AtomNode start="(484, 29)" end="(484, 30)" leading="" trailing="" val="("/>
              <NullNode start="(484, 30)" end="(484, 31)">
                <IdentNode start="(484, 30)" end="(484, 31)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(484, 32)" end="(484, 40)">
                <AtomNode start="(484, 32)" end="(484, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(484, 34)" end="(484, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(484, 34)" end="(484, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(484, 39)" end="(484, 40)">
                    <IdentNode start="(484, 39)" end="(484, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(484, 40)" end="(484, 41)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(484, 42)" end="(484, 78)">
            <AtomNode start="(484, 42)" end="(484, 43)" leading="" trailing=" " val=":"/>
            <OtherNode start="(484, 44)" end="(484, 78)" kind="«term_=_»">
              <IdentNode start="(484, 44)" end="(484, 57)" leading="" trailing=" " raw_val="l.toArray.pop" val="l.toArray.pop"/>
              <AtomNode start="(484, 58)" end="(484, 59)" leading="" trailing=" " val="="/>
              <IdentNode start="(484, 60)" end="(484, 78)" leading="" trailing=" " raw_val="l.dropLast.toArray" val="l.dropLast.toArray"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(484, 79)" end="(486, 7)">
          <AtomNode start="(484, 79)" end="(484, 81)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(484, 82)" end="(486, 7)">
            <AtomNode start="(484, 82)" end="(484, 84)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(485, 3)" end="(486, 7)">
              <TacticTacticseq1IndentedNode start="(485, 3)" end="(486, 7)">
                <NullNode start="(485, 3)" end="(486, 7)">
                  <OtherNode start="(485, 3)" end="(485, 13)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;l : List α&#10;⊢ l.toArray.pop = l.dropLast.toArray" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;⊢ l.toArray.pop.toList = l.dropLast.toArray.toList" tactic="apply ext'">
                    <AtomNode start="(485, 3)" end="(485, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(485, 9)" end="(485, 13)" leading="" trailing="&#10;  " raw_val="ext'" val="ext'" full_name="Array.ext'" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(486, 3)" end="(486, 7)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;⊢ l.toArray.pop.toList = l.dropLast.toArray.toList" state_after="no goals" tactic="simp">
                    <AtomNode start="(486, 3)" end="(486, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(488, 1)" end="(495, 6)" name="takeWhile_go_succ" full_name="List.takeWhile_go_succ">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(488, 1)" end="(495, 6)" name="takeWhile_go_succ" full_name="List.takeWhile_go_succ" _is_private_decl="False">
        <AtomNode start="(488, 1)" end="(488, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(488, 9)" end="(488, 26)">
          <IdentNode start="(488, 9)" end="(488, 26)" leading="" trailing=" " raw_val="takeWhile_go_succ" val="takeWhile_go_succ"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(488, 27)" end="(489, 75)">
          <NullNode start="(488, 27)" end="(488, 72)">
            <TermExplicitbinderNode start="(488, 27)" end="(488, 41)">
              <AtomNode start="(488, 27)" end="(488, 28)" leading="" trailing="" val="("/>
              <NullNode start="(488, 28)" end="(488, 29)">
                <IdentNode start="(488, 28)" end="(488, 29)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(488, 30)" end="(488, 40)">
                <AtomNode start="(488, 30)" end="(488, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(488, 32)" end="(488, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(488, 32)" end="(488, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(488, 34)" end="(488, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(488, 36)" end="(488, 40)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(488, 40)" end="(488, 41)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(488, 42)" end="(488, 49)">
              <AtomNode start="(488, 42)" end="(488, 43)" leading="" trailing="" val="("/>
              <NullNode start="(488, 43)" end="(488, 44)">
                <IdentNode start="(488, 43)" end="(488, 44)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(488, 45)" end="(488, 48)">
                <AtomNode start="(488, 45)" end="(488, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(488, 47)" end="(488, 48)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(488, 48)" end="(488, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(488, 50)" end="(488, 62)">
              <AtomNode start="(488, 50)" end="(488, 51)" leading="" trailing="" val="("/>
              <NullNode start="(488, 51)" end="(488, 52)">
                <IdentNode start="(488, 51)" end="(488, 52)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(488, 53)" end="(488, 61)">
                <AtomNode start="(488, 53)" end="(488, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(488, 55)" end="(488, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(488, 55)" end="(488, 59)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(488, 60)" end="(488, 61)">
                    <IdentNode start="(488, 60)" end="(488, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(488, 61)" end="(488, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(488, 63)" end="(488, 72)">
              <AtomNode start="(488, 63)" end="(488, 64)" leading="" trailing="" val="("/>
              <NullNode start="(488, 64)" end="(488, 65)">
                <IdentNode start="(488, 64)" end="(488, 65)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(488, 66)" end="(488, 71)">
                <AtomNode start="(488, 66)" end="(488, 67)" leading="" trailing=" " val=":"/>
                <IdentNode start="(488, 68)" end="(488, 71)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(488, 71)" end="(488, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(488, 73)" end="(489, 75)">
            <AtomNode start="(488, 73)" end="(488, 74)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(489, 5)" end="(489, 75)" kind="«term_=_»">
              <OtherNode start="(489, 5)" end="(489, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(489, 5)" end="(489, 17)" leading="" trailing=" " raw_val="takeWhile.go" val="takeWhile.go" full_name="Array.takeWhile.go" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(489, 18)" end="(489, 44)">
                  <IdentNode start="(489, 18)" end="(489, 19)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(489, 20)" end="(489, 36)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(489, 20)" end="(489, 28)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(489, 20)" end="(489, 21)" leading="" trailing="" val="("/>
                      <OtherNode start="(489, 21)" end="(489, 27)" kind="«term_::_»">
                        <IdentNode start="(489, 21)" end="(489, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(489, 23)" end="(489, 25)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(489, 26)" end="(489, 27)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(489, 27)" end="(489, 28)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(489, 28)" end="(489, 29)" leading="" trailing="" val="."/>
                    <IdentNode start="(489, 29)" end="(489, 36)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                  <OtherNode start="(489, 37)" end="(489, 42)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(489, 37)" end="(489, 38)" leading="" trailing="" val="("/>
                    <OtherNode start="(489, 38)" end="(489, 41)" kind="«term_+_»">
                      <IdentNode start="(489, 38)" end="(489, 39)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(489, 39)" end="(489, 40)" leading="" trailing="" val="+"/>
                      <OtherNode start="(489, 40)" end="(489, 41)" kind="num">
                        <AtomNode start="(489, 40)" end="(489, 41)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(489, 41)" end="(489, 42)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(489, 43)" end="(489, 44)" leading="" trailing=" " raw_val="r" val="r"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(489, 45)" end="(489, 46)" leading="" trailing=" " val="="/>
              <OtherNode start="(489, 47)" end="(489, 75)" kind="Lean.Parser.Term.app">
                <IdentNode start="(489, 47)" end="(489, 59)" leading="" trailing=" " raw_val="takeWhile.go" val="takeWhile.go" full_name="Array.takeWhile.go" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(489, 60)" end="(489, 75)">
                  <IdentNode start="(489, 60)" end="(489, 61)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(489, 62)" end="(489, 71)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
                  <IdentNode start="(489, 72)" end="(489, 73)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(489, 74)" end="(489, 75)" leading="" trailing=" " raw_val="r" val="r"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(489, 76)" end="(495, 6)">
          <AtomNode start="(489, 76)" end="(489, 78)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(489, 79)" end="(495, 6)">
            <AtomNode start="(489, 79)" end="(489, 81)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(490, 3)" end="(495, 6)">
              <TacticTacticseq1IndentedNode start="(490, 3)" end="(495, 6)">
                <NullNode start="(490, 3)" end="(495, 6)">
                  <OtherNode start="(490, 3)" end="(490, 34)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;r : Array α&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;i : Nat&#10;⊢ takeWhile.go p (a :: l).toArray (i + 1) r = takeWhile.go p l.toArray i r" state_after="α : Type u_1&#10;r : Array α&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;i : Nat&#10;⊢ (if h : i + 1 &amp;lt; (a :: l).toArray.size then&#10;      let a_1 := (a :: l).toArray[i + 1];&#10;      if p a_1 = true then takeWhile.go p (a :: l).toArray (i + 1 + 1) (r.push a_1) else r&#10;    else r) =&#10;    if h : i &amp;lt; l.toArray.size then&#10;      let a := l.toArray[i];&#10;      if p a = true then takeWhile.go p l.toArray (i + 1) (r.push a) else r&#10;    else r" tactic="rw [takeWhile.go, takeWhile.go]">
                    <AtomNode start="(490, 3)" end="(490, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(490, 6)" end="(490, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(490, 6)" end="(490, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(490, 7)" end="(490, 33)">
                        <OtherNode start="(490, 7)" end="(490, 19)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(490, 7)" end="(490, 19)" leading="" trailing="" raw_val="takeWhile.go" val="takeWhile.go" full_name="Array.takeWhile.go" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(490, 19)" end="(490, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(490, 21)" end="(490, 33)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(490, 21)" end="(490, 33)" leading="" trailing="" raw_val="takeWhile.go" val="takeWhile.go" full_name="Array.takeWhile.go" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(490, 33)" end="(490, 34)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(491, 3)" end="(492, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;r : Array α&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;i : Nat&#10;⊢ (if h : i + 1 &amp;lt; (a :: l).toArray.size then&#10;      let a_1 := (a :: l).toArray[i + 1];&#10;      if p a_1 = true then takeWhile.go p (a :: l).toArray (i + 1 + 1) (r.push a_1) else r&#10;    else r) =&#10;    if h : i &amp;lt; l.toArray.size then&#10;      let a := l.toArray[i];&#10;      if p a = true then takeWhile.go p l.toArray (i + 1) (r.push a) else r&#10;    else r" state_after="α : Type u_1&#10;r : Array α&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;i : Nat&#10;⊢ (if h : i &amp;lt; l.length then if p l[i] = true then takeWhile.go p (a :: l).toArray (i + 1 + 1) (r.push l[i]) else r&#10;    else r) =&#10;    if h : i &amp;lt; l.length then if p l[i] = true then takeWhile.go p l.toArray (i + 1) (r.push l[i]) else r else r" tactic="simp only [size_toArray, length_cons, Nat.add_lt_add_iff_right,&#10;  getElem_toArray, getElem_cons_succ]">
                    <AtomNode start="(491, 3)" end="(491, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(491, 8)" end="(491, 12)">
                      <AtomNode start="(491, 8)" end="(491, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(491, 13)" end="(492, 40)">
                      <AtomNode start="(491, 13)" end="(491, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(491, 14)" end="(492, 39)">
                        <OtherNode start="(491, 14)" end="(491, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(491, 14)" end="(491, 26)" leading="" trailing="" raw_val="size_toArray" val="size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(491, 26)" end="(491, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(491, 28)" end="(491, 39)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(491, 28)" end="(491, 39)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(491, 39)" end="(491, 40)" leading="" trailing=" " val=","/>
                        <OtherNode start="(491, 41)" end="(491, 65)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(491, 41)" end="(491, 65)" leading="" trailing="" raw_val="Nat.add_lt_add_iff_right" val="Nat.add_lt_add_iff_right" full_name="Nat.add_lt_add_iff_right" mod_name="Init.Data.Nat.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(491, 65)" end="(491, 66)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(492, 5)" end="(492, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(492, 5)" end="(492, 20)" leading="" trailing="" raw_val="getElem_toArray" val="getElem_toArray" full_name="List.getElem_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(492, 20)" end="(492, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(492, 22)" end="(492, 39)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(492, 22)" end="(492, 39)" leading="" trailing="" raw_val="getElem_cons_succ" val="getElem_cons_succ" full_name="List.getElem_cons_succ" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(492, 39)" end="(492, 40)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(493, 3)" end="(493, 8)" kind="Lean.Parser.Tactic.split" state_before="α : Type u_1&#10;r : Array α&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;i : Nat&#10;⊢ (if h : i &amp;lt; l.length then if p l[i] = true then takeWhile.go p (a :: l).toArray (i + 1 + 1) (r.push l[i]) else r&#10;    else r) =&#10;    if h : i &amp;lt; l.length then if p l[i] = true then takeWhile.go p l.toArray (i + 1) (r.push l[i]) else r else r" state_after="case isTrue&#10;α : Type u_1&#10;r : Array α&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;i : Nat&#10;h✝ : i &amp;lt; l.length&#10;⊢ (if p l[i] = true then takeWhile.go p (a :: l).toArray (i + 1 + 1) (r.push l[i]) else r) =&#10;    if p l[i] = true then takeWhile.go p l.toArray (i + 1) (r.push l[i]) else r&#10;&#10;case isFalse&#10;α : Type u_1&#10;r : Array α&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;i : Nat&#10;h✝ : ¬i &amp;lt; l.length&#10;⊢ r = r" tactic="split">
                    <AtomNode start="(493, 3)" end="(493, 8)" leading="" trailing="&#10;  " val="split"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(494, 3)" end="(494, 25)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue&#10;α : Type u_1&#10;r : Array α&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;i : Nat&#10;h✝ : i &amp;lt; l.length&#10;⊢ (if p l[i] = true then takeWhile.go p (a :: l).toArray (i + 1 + 1) (r.push l[i]) else r) =&#10;    if p l[i] = true then takeWhile.go p l.toArray (i + 1) (r.push l[i]) else r&#10;&#10;case isFalse&#10;α : Type u_1&#10;r : Array α&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;i : Nat&#10;h✝ : ¬i &amp;lt; l.length&#10;⊢ r = r" state_after="case isFalse&#10;α : Type u_1&#10;r : Array α&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;i : Nat&#10;h✝ : ¬i &amp;lt; l.length&#10;⊢ r = r" tactic="rw [takeWhile_go_succ]">
                    <AtomNode start="(494, 3)" end="(494, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(494, 6)" end="(494, 25)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(494, 6)" end="(494, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(494, 7)" end="(494, 24)">
                        <OtherNode start="(494, 7)" end="(494, 24)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(494, 7)" end="(494, 24)" leading="" trailing="" raw_val="takeWhile_go_succ" val="takeWhile_go_succ" full_name="PSigma.Lex.left" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(494, 24)" end="(494, 25)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(495, 3)" end="(495, 6)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case isFalse&#10;α : Type u_1&#10;r : Array α&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;i : Nat&#10;h✝ : ¬i &amp;lt; l.length&#10;⊢ r = r" state_after="no goals" tactic="rfl">
                    <AtomNode start="(495, 3)" end="(495, 6)" leading="" trailing="&#10;&#10;" val="rfl"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(497, 1)" end="(514, 37)" name="takeWhile_go_toArray" full_name="List.takeWhile_go_toArray">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(497, 1)" end="(514, 37)" name="takeWhile_go_toArray" full_name="List.takeWhile_go_toArray" _is_private_decl="False">
        <AtomNode start="(497, 1)" end="(497, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(497, 9)" end="(497, 29)">
          <IdentNode start="(497, 9)" end="(497, 29)" leading="" trailing=" " raw_val="takeWhile_go_toArray" val="takeWhile_go_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(497, 30)" end="(498, 79)">
          <NullNode start="(497, 30)" end="(497, 67)">
            <TermExplicitbinderNode start="(497, 30)" end="(497, 44)">
              <AtomNode start="(497, 30)" end="(497, 31)" leading="" trailing="" val="("/>
              <NullNode start="(497, 31)" end="(497, 32)">
                <IdentNode start="(497, 31)" end="(497, 32)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(497, 33)" end="(497, 43)">
                <AtomNode start="(497, 33)" end="(497, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(497, 35)" end="(497, 43)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(497, 35)" end="(497, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(497, 37)" end="(497, 38)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(497, 39)" end="(497, 43)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(497, 43)" end="(497, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(497, 45)" end="(497, 57)">
              <AtomNode start="(497, 45)" end="(497, 46)" leading="" trailing="" val="("/>
              <NullNode start="(497, 46)" end="(497, 47)">
                <IdentNode start="(497, 46)" end="(497, 47)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(497, 48)" end="(497, 56)">
                <AtomNode start="(497, 48)" end="(497, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(497, 50)" end="(497, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(497, 50)" end="(497, 54)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(497, 55)" end="(497, 56)">
                    <IdentNode start="(497, 55)" end="(497, 56)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(497, 56)" end="(497, 57)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(497, 58)" end="(497, 67)">
              <AtomNode start="(497, 58)" end="(497, 59)" leading="" trailing="" val="("/>
              <NullNode start="(497, 59)" end="(497, 60)">
                <IdentNode start="(497, 59)" end="(497, 60)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(497, 61)" end="(497, 66)">
                <AtomNode start="(497, 61)" end="(497, 62)" leading="" trailing=" " val=":"/>
                <IdentNode start="(497, 63)" end="(497, 66)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(497, 66)" end="(497, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(497, 68)" end="(498, 79)">
            <AtomNode start="(497, 68)" end="(497, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(498, 5)" end="(498, 79)" kind="«term_=_»">
              <OtherNode start="(498, 5)" end="(498, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(498, 5)" end="(498, 23)" leading="" trailing=" " raw_val="Array.takeWhile.go" val="Array.takeWhile.go" full_name="Array.takeWhile.go" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(498, 24)" end="(498, 39)">
                  <IdentNode start="(498, 24)" end="(498, 25)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(498, 26)" end="(498, 35)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
                  <IdentNode start="(498, 36)" end="(498, 37)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(498, 38)" end="(498, 39)" leading="" trailing=" " raw_val="r" val="r"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(498, 40)" end="(498, 41)" leading="" trailing=" " val="="/>
              <OtherNode start="(498, 42)" end="(498, 79)" kind="«term_++_»">
                <IdentNode start="(498, 42)" end="(498, 43)" leading="" trailing=" " raw_val="r" val="r"/>
                <AtomNode start="(498, 44)" end="(498, 46)" leading="" trailing=" " val="++"/>
                <OtherNode start="(498, 47)" end="(498, 79)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(498, 47)" end="(498, 71)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(498, 47)" end="(498, 48)" leading="" trailing="" val="("/>
                    <OtherNode start="(498, 48)" end="(498, 70)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(498, 48)" end="(498, 57)" leading="" trailing=" " raw_val="takeWhile" val="takeWhile" full_name="List.takeWhile" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(498, 58)" end="(498, 70)">
                        <IdentNode start="(498, 58)" end="(498, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                        <OtherNode start="(498, 60)" end="(498, 70)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(498, 60)" end="(498, 61)" leading="" trailing="" val="("/>
                          <OtherNode start="(498, 61)" end="(498, 69)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(498, 61)" end="(498, 67)" leading="" trailing=" " raw_val="l.drop" val="l.drop"/>
                            <NullNode start="(498, 68)" end="(498, 69)">
                              <IdentNode start="(498, 68)" end="(498, 69)" leading="" trailing="" raw_val="i" val="i"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(498, 69)" end="(498, 70)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(498, 70)" end="(498, 71)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(498, 71)" end="(498, 72)" leading="" trailing="" val="."/>
                  <IdentNode start="(498, 72)" end="(498, 79)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(498, 80)" end="(514, 37)">
          <AtomNode start="(498, 80)" end="(498, 82)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(498, 83)" end="(514, 37)">
            <AtomNode start="(498, 83)" end="(498, 85)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(499, 3)" end="(514, 37)">
              <TacticTacticseq1IndentedNode start="(499, 3)" end="(514, 37)">
                <NullNode start="(499, 3)" end="(514, 37)">
                  <OtherNode start="(499, 3)" end="(514, 37)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;r : Array α&#10;p : α → Bool&#10;l : List α&#10;i : Nat&#10;⊢ takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray" state_after="no goals" tactic="induction l generalizing i r with&#10;| nil =&amp;gt; simp [takeWhile.go]&#10;| cons a l ih =&amp;gt;&#10;  rw [takeWhile.go]&#10;  cases i with&#10;  | zero =&amp;gt;&#10;    simp [takeWhile_go_succ, ih, takeWhile_cons]&#10;    split &amp;lt;;&amp;gt; simp&#10;  | succ i =&amp;gt;&#10;    simp only [size_toArray, length_cons, Nat.add_lt_add_iff_right,&#10;      getElem_toArray, getElem_cons_succ, drop_succ_cons]&#10;    split &amp;lt;;&amp;gt; rename_i h₁&#10;    · rw [takeWhile_go_succ, ih]&#10;      rw [← getElem_cons_drop_succ_eq_drop h₁, takeWhile_cons]&#10;      split &amp;lt;;&amp;gt; simp_all&#10;    · simp_all [drop_eq_nil_of_le]">
                    <AtomNode start="(499, 3)" end="(499, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(499, 13)" end="(499, 14)">
                      <OtherNode start="(499, 13)" end="(499, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(499, 13)" end="(499, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(499, 15)" end="(499, 31)">
                      <AtomNode start="(499, 15)" end="(499, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(499, 28)" end="(499, 31)">
                        <IdentNode start="(499, 28)" end="(499, 29)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(499, 30)" end="(499, 31)" leading="" trailing=" " raw_val="r" val="r"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(499, 32)" end="(514, 37)">
                      <OtherNode start="(499, 32)" end="(514, 37)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(499, 32)" end="(499, 36)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(500, 3)" end="(514, 37)">
                          <OtherNode start="(500, 3)" end="(500, 31)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(500, 3)" end="(500, 8)">
                              <OtherNode start="(500, 3)" end="(500, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(500, 3)" end="(500, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(500, 5)" end="(500, 8)">
                                  <NullNode/>
                                  <IdentNode start="(500, 5)" end="(500, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(500, 9)" end="(500, 31)">
                              <AtomNode start="(500, 9)" end="(500, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(500, 12)" end="(500, 31)">
                                <TacticTacticseq1IndentedNode start="(500, 12)" end="(500, 31)">
                                  <NullNode start="(500, 12)" end="(500, 31)">
                                    <OtherNode start="(500, 12)" end="(500, 31)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;r : Array α&#10;i : Nat&#10;⊢ takeWhile.go p #[] i r = r ++ (takeWhile p (drop i [])).toArray" state_after="no goals" tactic="simp [takeWhile.go]">
                                      <AtomNode start="(500, 12)" end="(500, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(500, 17)" end="(500, 31)">
                                        <AtomNode start="(500, 17)" end="(500, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(500, 18)" end="(500, 30)">
                                          <OtherNode start="(500, 18)" end="(500, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(500, 18)" end="(500, 30)" leading="" trailing="" raw_val="takeWhile.go" val="takeWhile.go" full_name="Array.takeWhile.go" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(500, 30)" end="(500, 31)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(501, 3)" end="(514, 37)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(501, 3)" end="(501, 16)">
                              <OtherNode start="(501, 3)" end="(501, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(501, 3)" end="(501, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(501, 5)" end="(501, 9)">
                                  <NullNode/>
                                  <IdentNode start="(501, 5)" end="(501, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(501, 10)" end="(501, 16)">
                                  <IdentNode start="(501, 10)" end="(501, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(501, 12)" end="(501, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(501, 14)" end="(501, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(501, 17)" end="(514, 37)">
                              <AtomNode start="(501, 17)" end="(501, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(502, 5)" end="(514, 37)">
                                <TacticTacticseq1IndentedNode start="(502, 5)" end="(514, 37)">
                                  <NullNode start="(502, 5)" end="(514, 37)">
                                    <OtherNode start="(502, 5)" end="(502, 22)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;⊢ takeWhile.go p (a :: l).toArray i r = r ++ (takeWhile p (drop i (a :: l))).toArray" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;⊢ (if h : i &amp;lt; (a :: l).toArray.size then&#10;      let a_1 := (a :: l).toArray[i];&#10;      if p a_1 = true then takeWhile.go p (a :: l).toArray (i + 1) (r.push a_1) else r&#10;    else r) =&#10;    r ++ (takeWhile p (drop i (a :: l))).toArray" tactic="rw [takeWhile.go]">
                                      <AtomNode start="(502, 5)" end="(502, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(502, 8)" end="(502, 22)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(502, 8)" end="(502, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(502, 9)" end="(502, 21)">
                                          <OtherNode start="(502, 9)" end="(502, 21)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(502, 9)" end="(502, 21)" leading="" trailing="" raw_val="takeWhile.go" val="takeWhile.go" full_name="Array.takeWhile.go" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(502, 21)" end="(502, 22)" leading="" trailing="&#10;    " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(503, 5)" end="(514, 37)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;⊢ (if h : i &amp;lt; (a :: l).toArray.size then&#10;      let a_1 := (a :: l).toArray[i];&#10;      if p a_1 = true then takeWhile.go p (a :: l).toArray (i + 1) (r.push a_1) else r&#10;    else r) =&#10;    r ++ (takeWhile p (drop i (a :: l))).toArray" state_after="no goals" tactic="cases i with&#10;| zero =&amp;gt;&#10;  simp [takeWhile_go_succ, ih, takeWhile_cons]&#10;  split &amp;lt;;&amp;gt; simp&#10;| succ i =&amp;gt;&#10;  simp only [size_toArray, length_cons, Nat.add_lt_add_iff_right,&#10;    getElem_toArray, getElem_cons_succ, drop_succ_cons]&#10;  split &amp;lt;;&amp;gt; rename_i h₁&#10;  · rw [takeWhile_go_succ, ih]&#10;    rw [← getElem_cons_drop_succ_eq_drop h₁, takeWhile_cons]&#10;    split &amp;lt;;&amp;gt; simp_all&#10;  · simp_all [drop_eq_nil_of_le]">
                                      <AtomNode start="(503, 5)" end="(503, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(503, 11)" end="(503, 12)">
                                        <OtherNode start="(503, 11)" end="(503, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(503, 11)" end="(503, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(503, 13)" end="(514, 37)">
                                        <OtherNode start="(503, 13)" end="(514, 37)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(503, 13)" end="(503, 17)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(504, 5)" end="(514, 37)">
                                            <OtherNode start="(504, 5)" end="(506, 21)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(504, 5)" end="(504, 11)">
                                                <OtherNode start="(504, 5)" end="(504, 11)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(504, 5)" end="(504, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(504, 7)" end="(504, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(504, 7)" end="(504, 11)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(504, 12)" end="(506, 21)">
                                                <AtomNode start="(504, 12)" end="(504, 14)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(505, 7)" end="(506, 21)">
                                                  <TacticTacticseq1IndentedNode start="(505, 7)" end="(506, 21)">
                                                    <NullNode start="(505, 7)" end="(506, 21)">
                                                      <OtherNode start="(505, 7)" end="(505, 51)" kind="Lean.Parser.Tactic.simp" state_before="case cons.zero&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;⊢ (if h : 0 &amp;lt; (a :: l).toArray.size then&#10;      let a_1 := (a :: l).toArray[0];&#10;      if p a_1 = true then takeWhile.go p (a :: l).toArray (0 + 1) (r.push a_1) else r&#10;    else r) =&#10;    r ++ (takeWhile p (drop 0 (a :: l))).toArray" state_after="case cons.zero&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;⊢ (if p a = true then r ++ (a :: takeWhile p l).toArray else r) =&#10;    r ++ (if p a = true then a :: takeWhile p l else []).toArray" tactic="simp [takeWhile_go_succ, ih, takeWhile_cons]">
                                                        <AtomNode start="(505, 7)" end="(505, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(505, 12)" end="(505, 51)">
                                                          <AtomNode start="(505, 12)" end="(505, 13)" leading="" trailing="" val="["/>
                                                          <NullNode start="(505, 13)" end="(505, 50)">
                                                            <OtherNode start="(505, 13)" end="(505, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(505, 13)" end="(505, 30)" leading="" trailing="" raw_val="takeWhile_go_succ" val="takeWhile_go_succ" full_name="List.takeWhile_go_succ" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(488, 9)" def_end="(488, 26)"/>
                                                            </OtherNode>
                                                            <AtomNode start="(505, 30)" end="(505, 31)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(505, 32)" end="(505, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(505, 32)" end="(505, 34)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <AtomNode start="(505, 34)" end="(505, 35)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(505, 36)" end="(505, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(505, 36)" end="(505, 50)" leading="" trailing="" raw_val="takeWhile_cons" val="takeWhile_cons" full_name="List.takeWhile_cons" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(505, 50)" end="(505, 51)" leading="" trailing="&#10;      " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(506, 7)" end="(506, 21)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.zero&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;⊢ (if p a = true then r ++ (a :: takeWhile p l).toArray else r) =&#10;    r ++ (if p a = true then a :: takeWhile p l else []).toArray" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                                                        <OtherNode start="(506, 7)" end="(506, 12)" kind="Lean.Parser.Tactic.split">
                                                          <AtomNode start="(506, 7)" end="(506, 12)" leading="" trailing=" " val="split"/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(506, 13)" end="(506, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                        <OtherNode start="(506, 17)" end="(506, 21)" kind="Lean.Parser.Tactic.simp">
                                                          <AtomNode start="(506, 17)" end="(506, 21)" leading="" trailing="&#10;    " val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(507, 5)" end="(514, 37)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(507, 5)" end="(507, 13)">
                                                <OtherNode start="(507, 5)" end="(507, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(507, 5)" end="(507, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(507, 7)" end="(507, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(507, 7)" end="(507, 11)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                  </GroupNode>
                                                  <NullNode start="(507, 12)" end="(507, 13)">
                                                    <IdentNode start="(507, 12)" end="(507, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(507, 14)" end="(514, 37)">
                                                <AtomNode start="(507, 14)" end="(507, 16)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(508, 7)" end="(514, 37)">
                                                  <TacticTacticseq1IndentedNode start="(508, 7)" end="(514, 37)">
                                                    <NullNode start="(508, 7)" end="(514, 37)">
                                                      <OtherNode start="(508, 7)" end="(509, 60)" kind="Lean.Parser.Tactic.simp" state_before="case cons.succ&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;⊢ (if h : i + 1 &amp;lt; (a :: l).toArray.size then&#10;      let a_1 := (a :: l).toArray[i + 1];&#10;      if p a_1 = true then takeWhile.go p (a :: l).toArray (i + 1 + 1) (r.push a_1) else r&#10;    else r) =&#10;    r ++ (takeWhile p (drop (i + 1) (a :: l))).toArray" state_after="case cons.succ&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;⊢ (if h : i &amp;lt; l.length then if p l[i] = true then takeWhile.go p (a :: l).toArray (i + 1 + 1) (r.push l[i]) else r&#10;    else r) =&#10;    r ++ (takeWhile p (drop i l)).toArray" tactic="simp only [size_toArray, length_cons, Nat.add_lt_add_iff_right,&#10;  getElem_toArray, getElem_cons_succ, drop_succ_cons]">
                                                        <AtomNode start="(508, 7)" end="(508, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode start="(508, 12)" end="(508, 16)">
                                                          <AtomNode start="(508, 12)" end="(508, 16)" leading="" trailing=" " val="only"/>
                                                        </NullNode>
                                                        <NullNode start="(508, 17)" end="(509, 60)">
                                                          <AtomNode start="(508, 17)" end="(508, 18)" leading="" trailing="" val="["/>
                                                          <NullNode start="(508, 18)" end="(509, 59)">
                                                            <OtherNode start="(508, 18)" end="(508, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(508, 18)" end="(508, 30)" leading="" trailing="" raw_val="size_toArray" val="size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(508, 30)" end="(508, 31)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(508, 32)" end="(508, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(508, 32)" end="(508, 43)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(508, 43)" end="(508, 44)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(508, 45)" end="(508, 69)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(508, 45)" end="(508, 69)" leading="" trailing="" raw_val="Nat.add_lt_add_iff_right" val="Nat.add_lt_add_iff_right" full_name="Nat.add_lt_add_iff_right" mod_name="Init.Data.Nat.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Lemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(508, 69)" end="(508, 70)" leading="" trailing="&#10;        " val=","/>
                                                            <OtherNode start="(509, 9)" end="(509, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(509, 9)" end="(509, 24)" leading="" trailing="" raw_val="getElem_toArray" val="getElem_toArray" full_name="List.getElem_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(509, 24)" end="(509, 25)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(509, 26)" end="(509, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(509, 26)" end="(509, 43)" leading="" trailing="" raw_val="getElem_cons_succ" val="getElem_cons_succ" full_name="List.getElem_cons_succ" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(509, 43)" end="(509, 44)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(509, 45)" end="(509, 59)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(509, 45)" end="(509, 59)" leading="" trailing="" raw_val="drop_succ_cons" val="drop_succ_cons" full_name="List.drop_succ_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(509, 59)" end="(509, 60)" leading="" trailing="&#10;      " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(510, 7)" end="(510, 28)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.succ&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;⊢ (if h : i &amp;lt; l.length then if p l[i] = true then takeWhile.go p (a :: l).toArray (i + 1 + 1) (r.push l[i]) else r&#10;    else r) =&#10;    r ++ (takeWhile p (drop i l)).toArray" state_after="case cons.succ.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;h₁ : i &amp;lt; l.length&#10;⊢ (if p l[i] = true then takeWhile.go p (a :: l).toArray (i + 1 + 1) (r.push l[i]) else r) =&#10;    r ++ (takeWhile p (drop i l)).toArray&#10;&#10;case cons.succ.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;h₁ : ¬i &amp;lt; l.length&#10;⊢ r = r ++ (takeWhile p (drop i l)).toArray" tactic="split &amp;lt;;&amp;gt; rename_i h₁">
                                                        <OtherNode start="(510, 7)" end="(510, 12)" kind="Lean.Parser.Tactic.split">
                                                          <AtomNode start="(510, 7)" end="(510, 12)" leading="" trailing=" " val="split"/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(510, 13)" end="(510, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                        <OtherNode start="(510, 17)" end="(510, 28)" kind="Lean.Parser.Tactic.renameI">
                                                          <AtomNode start="(510, 17)" end="(510, 25)" leading="" trailing=" " val="rename_i"/>
                                                          <NullNode start="(510, 26)" end="(510, 28)">
                                                            <LeanBinderidentNode start="(510, 26)" end="(510, 28)">
                                                            <IdentNode start="(510, 26)" end="(510, 28)" leading="" trailing="&#10;      " raw_val="h₁" val="h₁"/>
                                                            </LeanBinderidentNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(511, 7)" end="(513, 27)" kind="Lean.cdot" state_before="case cons.succ.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;h₁ : i &amp;lt; l.length&#10;⊢ (if p l[i] = true then takeWhile.go p (a :: l).toArray (i + 1 + 1) (r.push l[i]) else r) =&#10;    r ++ (takeWhile p (drop i l)).toArray&#10;&#10;case cons.succ.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;h₁ : ¬i &amp;lt; l.length&#10;⊢ r = r ++ (takeWhile p (drop i l)).toArray" state_after="case cons.succ.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;h₁ : ¬i &amp;lt; l.length&#10;⊢ r = r ++ (takeWhile p (drop i l)).toArray" tactic="· rw [takeWhile_go_succ, ih]&#10;  rw [← getElem_cons_drop_succ_eq_drop h₁, takeWhile_cons]&#10;  split &amp;lt;;&amp;gt; simp_all">
                                                        <OtherNode start="(511, 7)" end="(511, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(511, 7)" end="(511, 8)" kind="patternIgnore">
                                                            <OtherNode start="(511, 7)" end="(511, 8)" kind="token.«· »">
                                                            <AtomNode start="(511, 7)" end="(511, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(511, 9)" end="(513, 27)">
                                                          <TacticTacticseq1IndentedNode start="(511, 9)" end="(513, 27)">
                                                            <NullNode start="(511, 9)" end="(513, 27)">
                                                            <OtherNode start="(511, 9)" end="(511, 35)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.succ.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;h₁ : i &amp;lt; l.length&#10;⊢ (if p l[i] = true then takeWhile.go p (a :: l).toArray (i + 1 + 1) (r.push l[i]) else r) =&#10;    r ++ (takeWhile p (drop i l)).toArray" state_after="case cons.succ.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;h₁ : i &amp;lt; l.length&#10;⊢ (if p l[i] = true then r.push l[i] ++ (takeWhile p (drop (i + 1) l)).toArray else r) =&#10;    r ++ (takeWhile p (drop i l)).toArray" tactic="rw [takeWhile_go_succ, ih]">
                                                            <AtomNode start="(511, 9)" end="(511, 11)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(511, 12)" end="(511, 35)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(511, 12)" end="(511, 13)" leading="" trailing="" val="["/>
                                                            <NullNode start="(511, 13)" end="(511, 34)">
                                                            <OtherNode start="(511, 13)" end="(511, 30)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(511, 13)" end="(511, 30)" leading="" trailing="" raw_val="takeWhile_go_succ" val="takeWhile_go_succ" full_name="List.takeWhile_go_succ" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(488, 9)" def_end="(488, 26)"/>
                                                            </OtherNode>
                                                            <AtomNode start="(511, 30)" end="(511, 31)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(511, 32)" end="(511, 34)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(511, 32)" end="(511, 34)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(511, 34)" end="(511, 35)" leading="" trailing="&#10;        " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(512, 9)" end="(512, 65)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.succ.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;h₁ : i &amp;lt; l.length&#10;⊢ (if p l[i] = true then r.push l[i] ++ (takeWhile p (drop (i + 1) l)).toArray else r) =&#10;    r ++ (takeWhile p (drop i l)).toArray" state_after="case cons.succ.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;h₁ : i &amp;lt; l.length&#10;⊢ (if p l[i] = true then r.push l[i] ++ (takeWhile p (drop (i + 1) l)).toArray else r) =&#10;    r ++ (if p l[i] = true then l[i] :: takeWhile p (drop (i + 1) l) else []).toArray" tactic="rw [← getElem_cons_drop_succ_eq_drop h₁, takeWhile_cons]">
                                                            <AtomNode start="(512, 9)" end="(512, 11)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(512, 12)" end="(512, 65)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(512, 12)" end="(512, 13)" leading="" trailing="" val="["/>
                                                            <NullNode start="(512, 13)" end="(512, 64)">
                                                            <OtherNode start="(512, 13)" end="(512, 48)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(512, 13)" end="(512, 14)">
                                                            <OtherNode start="(512, 13)" end="(512, 14)" kind="patternIgnore">
                                                            <OtherNode start="(512, 13)" end="(512, 14)" kind="token.«← »">
                                                            <AtomNode start="(512, 13)" end="(512, 14)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <OtherNode start="(512, 15)" end="(512, 48)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(512, 15)" end="(512, 45)" leading="" trailing=" " raw_val="getElem_cons_drop_succ_eq_drop" val="getElem_cons_drop_succ_eq_drop" full_name="List.getElem_cons_drop_succ_eq_drop" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                            <NullNode start="(512, 46)" end="(512, 48)">
                                                            <IdentNode start="(512, 46)" end="(512, 48)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(512, 48)" end="(512, 49)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(512, 50)" end="(512, 64)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(512, 50)" end="(512, 64)" leading="" trailing="" raw_val="takeWhile_cons" val="takeWhile_cons" full_name="List.takeWhile_cons" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(512, 64)" end="(512, 65)" leading="" trailing="&#10;        " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(513, 9)" end="(513, 27)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.succ.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;h₁ : i &amp;lt; l.length&#10;⊢ (if p l[i] = true then r.push l[i] ++ (takeWhile p (drop (i + 1) l)).toArray else r) =&#10;    r ++ (if p l[i] = true then l[i] :: takeWhile p (drop (i + 1) l) else []).toArray" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                                            <OtherNode start="(513, 9)" end="(513, 14)" kind="Lean.Parser.Tactic.split">
                                                            <AtomNode start="(513, 9)" end="(513, 14)" leading="" trailing=" " val="split"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(513, 15)" end="(513, 18)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                            <OtherNode start="(513, 19)" end="(513, 27)" kind="Lean.Parser.Tactic.simpAll">
                                                            <AtomNode start="(513, 19)" end="(513, 27)" leading="" trailing="&#10;      " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(514, 7)" end="(514, 37)" kind="Lean.cdot" state_before="case cons.succ.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;h₁ : ¬i &amp;lt; l.length&#10;⊢ r = r ++ (takeWhile p (drop i l)).toArray" state_after="no goals" tactic="· simp_all [drop_eq_nil_of_le]">
                                                        <OtherNode start="(514, 7)" end="(514, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(514, 7)" end="(514, 8)" kind="patternIgnore">
                                                            <OtherNode start="(514, 7)" end="(514, 8)" kind="token.«· »">
                                                            <AtomNode start="(514, 7)" end="(514, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(514, 9)" end="(514, 37)">
                                                          <TacticTacticseq1IndentedNode start="(514, 9)" end="(514, 37)">
                                                            <NullNode start="(514, 9)" end="(514, 37)">
                                                            <OtherNode start="(514, 9)" end="(514, 37)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.succ.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : ∀ {r : Array α} (i : Nat), takeWhile.go p l.toArray i r = r ++ (takeWhile p (drop i l)).toArray&#10;r : Array α&#10;i : Nat&#10;h₁ : ¬i &amp;lt; l.length&#10;⊢ r = r ++ (takeWhile p (drop i l)).toArray" state_after="no goals" tactic="simp_all [drop_eq_nil_of_le]">
                                                            <AtomNode start="(514, 9)" end="(514, 17)" leading="" trailing=" " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(514, 18)" end="(514, 37)">
                                                            <AtomNode start="(514, 18)" end="(514, 19)" leading="" trailing="" val="["/>
                                                            <NullNode start="(514, 19)" end="(514, 36)">
                                                            <OtherNode start="(514, 19)" end="(514, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(514, 19)" end="(514, 36)" leading="" trailing="" raw_val="drop_eq_nil_of_le" val="drop_eq_nil_of_le" full_name="List.drop_eq_nil_of_le" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(514, 36)" end="(514, 37)" leading="" trailing="&#10;&#10;" val="]"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(516, 1)" end="(518, 47)" name="takeWhile_toArray" full_name="List.takeWhile_toArray">
      <CommandDeclmodifiersNode start="(516, 1)" end="(516, 8)">
        <NullNode/>
        <NullNode start="(516, 1)" end="(516, 8)">
          <OtherNode start="(516, 1)" end="(516, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(516, 1)" end="(516, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(516, 3)" end="(516, 7)">
              <OtherNode start="(516, 3)" end="(516, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(516, 3)" end="(516, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(516, 3)" end="(516, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(516, 7)" end="(516, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(516, 9)" end="(518, 47)" name="takeWhile_toArray" full_name="List.takeWhile_toArray" _is_private_decl="False">
        <AtomNode start="(516, 9)" end="(516, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(516, 17)" end="(516, 34)">
          <IdentNode start="(516, 17)" end="(516, 34)" leading="" trailing=" " raw_val="takeWhile_toArray" val="takeWhile_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(516, 35)" end="(517, 52)">
          <NullNode start="(516, 35)" end="(516, 62)">
            <TermExplicitbinderNode start="(516, 35)" end="(516, 49)">
              <AtomNode start="(516, 35)" end="(516, 36)" leading="" trailing="" val="("/>
              <NullNode start="(516, 36)" end="(516, 37)">
                <IdentNode start="(516, 36)" end="(516, 37)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(516, 38)" end="(516, 48)">
                <AtomNode start="(516, 38)" end="(516, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(516, 40)" end="(516, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(516, 40)" end="(516, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(516, 42)" end="(516, 43)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(516, 44)" end="(516, 48)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(516, 48)" end="(516, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(516, 50)" end="(516, 62)">
              <AtomNode start="(516, 50)" end="(516, 51)" leading="" trailing="" val="("/>
              <NullNode start="(516, 51)" end="(516, 52)">
                <IdentNode start="(516, 51)" end="(516, 52)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(516, 53)" end="(516, 61)">
                <AtomNode start="(516, 53)" end="(516, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(516, 55)" end="(516, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(516, 55)" end="(516, 59)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(516, 60)" end="(516, 61)">
                    <IdentNode start="(516, 60)" end="(516, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(516, 61)" end="(516, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(516, 63)" end="(517, 52)">
            <AtomNode start="(516, 63)" end="(516, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(517, 5)" end="(517, 52)" kind="«term_=_»">
              <OtherNode start="(517, 5)" end="(517, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(517, 5)" end="(517, 24)" leading="" trailing=" " raw_val="l.toArray.takeWhile" val="l.toArray.takeWhile"/>
                <NullNode start="(517, 25)" end="(517, 26)">
                  <IdentNode start="(517, 25)" end="(517, 26)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(517, 27)" end="(517, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(517, 29)" end="(517, 52)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(517, 29)" end="(517, 44)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(517, 29)" end="(517, 30)" leading="" trailing="" val="("/>
                  <OtherNode start="(517, 30)" end="(517, 43)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(517, 30)" end="(517, 41)" leading="" trailing=" " raw_val="l.takeWhile" val="l.takeWhile"/>
                    <NullNode start="(517, 42)" end="(517, 43)">
                      <IdentNode start="(517, 42)" end="(517, 43)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(517, 43)" end="(517, 44)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(517, 44)" end="(517, 45)" leading="" trailing="" val="."/>
                <IdentNode start="(517, 45)" end="(517, 52)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(517, 53)" end="(518, 47)">
          <AtomNode start="(517, 53)" end="(517, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(517, 56)" end="(518, 47)">
            <AtomNode start="(517, 56)" end="(517, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(518, 3)" end="(518, 47)">
              <TacticTacticseq1IndentedNode start="(518, 3)" end="(518, 47)">
                <NullNode start="(518, 3)" end="(518, 47)">
                  <OtherNode start="(518, 3)" end="(518, 47)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ Array.takeWhile p l.toArray = (takeWhile p l).toArray" state_after="no goals" tactic="simp [Array.takeWhile, takeWhile_go_toArray]">
                    <AtomNode start="(518, 3)" end="(518, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(518, 8)" end="(518, 47)">
                      <AtomNode start="(518, 8)" end="(518, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(518, 9)" end="(518, 46)">
                        <OtherNode start="(518, 9)" end="(518, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(518, 9)" end="(518, 24)" leading="" trailing="" raw_val="Array.takeWhile" val="Array.takeWhile" full_name="Array.takeWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(518, 24)" end="(518, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(518, 26)" end="(518, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(518, 26)" end="(518, 46)" leading="" trailing="" raw_val="takeWhile_go_toArray" val="takeWhile_go_toArray" full_name="List.takeWhile_go_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(497, 9)" def_end="(497, 29)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(518, 46)" end="(518, 47)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(520, 1)" end="(529, 11)" name="popWhile_toArray_aux" full_name="List.popWhile_toArray_aux">
      <CommandDeclmodifiersNode start="(520, 1)" end="(520, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(520, 1)" end="(520, 8)">
          <CommandPrivateNode start="(520, 1)" end="(520, 8)">
            <AtomNode start="(520, 1)" end="(520, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(520, 9)" end="(529, 11)" name="popWhile_toArray_aux" full_name="List.popWhile_toArray_aux" _is_private_decl="True">
        <AtomNode start="(520, 9)" end="(520, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(520, 17)" end="(520, 37)">
          <IdentNode start="(520, 17)" end="(520, 37)" leading="" trailing=" " raw_val="popWhile_toArray_aux" val="popWhile_toArray_aux"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(520, 38)" end="(521, 67)">
          <NullNode start="(520, 38)" end="(520, 65)">
            <TermExplicitbinderNode start="(520, 38)" end="(520, 52)">
              <AtomNode start="(520, 38)" end="(520, 39)" leading="" trailing="" val="("/>
              <NullNode start="(520, 39)" end="(520, 40)">
                <IdentNode start="(520, 39)" end="(520, 40)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(520, 41)" end="(520, 51)">
                <AtomNode start="(520, 41)" end="(520, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(520, 43)" end="(520, 51)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(520, 43)" end="(520, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(520, 45)" end="(520, 46)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(520, 47)" end="(520, 51)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(520, 51)" end="(520, 52)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(520, 53)" end="(520, 65)">
              <AtomNode start="(520, 53)" end="(520, 54)" leading="" trailing="" val="("/>
              <NullNode start="(520, 54)" end="(520, 55)">
                <IdentNode start="(520, 54)" end="(520, 55)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(520, 56)" end="(520, 64)">
                <AtomNode start="(520, 56)" end="(520, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(520, 58)" end="(520, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(520, 58)" end="(520, 62)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(520, 63)" end="(520, 64)">
                    <IdentNode start="(520, 63)" end="(520, 64)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(520, 64)" end="(520, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(520, 66)" end="(521, 67)">
            <AtomNode start="(520, 66)" end="(520, 67)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(521, 5)" end="(521, 67)" kind="«term_=_»">
              <OtherNode start="(521, 5)" end="(521, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(521, 5)" end="(521, 31)" leading="" trailing=" " raw_val="l.reverse.toArray.popWhile" val="l.reverse.toArray.popWhile"/>
                <NullNode start="(521, 32)" end="(521, 33)">
                  <IdentNode start="(521, 32)" end="(521, 33)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(521, 34)" end="(521, 35)" leading="" trailing=" " val="="/>
              <OtherNode start="(521, 36)" end="(521, 67)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(521, 36)" end="(521, 51)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(521, 36)" end="(521, 37)" leading="" trailing="" val="("/>
                  <OtherNode start="(521, 37)" end="(521, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(521, 37)" end="(521, 48)" leading="" trailing=" " raw_val="l.dropWhile" val="l.dropWhile"/>
                    <NullNode start="(521, 49)" end="(521, 50)">
                      <IdentNode start="(521, 49)" end="(521, 50)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(521, 50)" end="(521, 51)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(521, 51)" end="(521, 52)" leading="" trailing="" val="."/>
                <IdentNode start="(521, 52)" end="(521, 67)" leading="" trailing=" " raw_val="reverse.toArray" val="reverse.toArray"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(521, 68)" end="(529, 11)">
          <AtomNode start="(521, 68)" end="(521, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(521, 71)" end="(529, 11)">
            <AtomNode start="(521, 71)" end="(521, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(522, 3)" end="(529, 11)">
              <TacticTacticseq1IndentedNode start="(522, 3)" end="(529, 11)">
                <NullNode start="(522, 3)" end="(529, 11)">
                  <OtherNode start="(522, 3)" end="(529, 11)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ popWhile p l.reverse.toArray = (dropWhile p l).reverse.toArray" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt;&#10;  unfold popWhile&#10;  simp [ih, dropWhile_cons]&#10;  split&#10;  · rfl&#10;  · simp">
                    <AtomNode start="(522, 3)" end="(522, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(522, 13)" end="(522, 14)">
                      <OtherNode start="(522, 13)" end="(522, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(522, 13)" end="(522, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(522, 15)" end="(529, 11)">
                      <OtherNode start="(522, 15)" end="(529, 11)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(522, 15)" end="(522, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(523, 3)" end="(529, 11)">
                          <OtherNode start="(523, 3)" end="(523, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(523, 3)" end="(523, 8)">
                              <OtherNode start="(523, 3)" end="(523, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(523, 3)" end="(523, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(523, 5)" end="(523, 8)">
                                  <NullNode/>
                                  <IdentNode start="(523, 5)" end="(523, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(523, 9)" end="(523, 16)">
                              <AtomNode start="(523, 9)" end="(523, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(523, 12)" end="(523, 16)">
                                <TacticTacticseq1IndentedNode start="(523, 12)" end="(523, 16)">
                                  <NullNode start="(523, 12)" end="(523, 16)">
                                    <OtherNode start="(523, 12)" end="(523, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ popWhile p [].reverse.toArray = (dropWhile p []).reverse.toArray" state_after="no goals" tactic="simp">
                                      <AtomNode start="(523, 12)" end="(523, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(524, 3)" end="(529, 11)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(524, 3)" end="(524, 16)">
                              <OtherNode start="(524, 3)" end="(524, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(524, 3)" end="(524, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(524, 5)" end="(524, 9)">
                                  <NullNode/>
                                  <IdentNode start="(524, 5)" end="(524, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(524, 10)" end="(524, 16)">
                                  <IdentNode start="(524, 10)" end="(524, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(524, 12)" end="(524, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(524, 14)" end="(524, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(524, 17)" end="(529, 11)">
                              <AtomNode start="(524, 17)" end="(524, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(525, 5)" end="(529, 11)">
                                <TacticTacticseq1IndentedNode start="(525, 5)" end="(529, 11)">
                                  <NullNode start="(525, 5)" end="(529, 11)">
                                    <OtherNode start="(525, 5)" end="(525, 20)" kind="Lean.Parser.Tactic.unfold" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : popWhile p l.reverse.toArray = (dropWhile p l).reverse.toArray&#10;⊢ popWhile p (a :: l).reverse.toArray = (dropWhile p (a :: l)).reverse.toArray" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : popWhile p l.reverse.toArray = (dropWhile p l).reverse.toArray&#10;⊢ (if h : (a :: l).reverse.toArray.size &amp;gt; 0 then&#10;      if p (a :: l).reverse.toArray[(a :: l).reverse.toArray.size - 1] = true then&#10;        popWhile p (a :: l).reverse.toArray.pop&#10;      else (a :: l).reverse.toArray&#10;    else (a :: l).reverse.toArray) =&#10;    (dropWhile p (a :: l)).reverse.toArray" tactic="unfold popWhile">
                                      <AtomNode start="(525, 5)" end="(525, 11)" leading="" trailing=" " val="unfold"/>
                                      <NullNode start="(525, 12)" end="(525, 20)">
                                        <IdentNode start="(525, 12)" end="(525, 20)" leading="" trailing="&#10;    " raw_val="popWhile" val="popWhile" full_name="Array.popWhile" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(526, 5)" end="(526, 30)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : popWhile p l.reverse.toArray = (dropWhile p l).reverse.toArray&#10;⊢ (if h : (a :: l).reverse.toArray.size &amp;gt; 0 then&#10;      if p (a :: l).reverse.toArray[(a :: l).reverse.toArray.size - 1] = true then&#10;        popWhile p (a :: l).reverse.toArray.pop&#10;      else (a :: l).reverse.toArray&#10;    else (a :: l).reverse.toArray) =&#10;    (dropWhile p (a :: l)).reverse.toArray" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : popWhile p l.reverse.toArray = (dropWhile p l).reverse.toArray&#10;⊢ (if p a = true then (dropWhile p l).reverse.toArray else (l.reverse ++ [a]).toArray) =&#10;    (if p a = true then dropWhile p l else a :: l).reverse.toArray" tactic="simp [ih, dropWhile_cons]">
                                      <AtomNode start="(526, 5)" end="(526, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(526, 10)" end="(526, 30)">
                                        <AtomNode start="(526, 10)" end="(526, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(526, 11)" end="(526, 29)">
                                          <OtherNode start="(526, 11)" end="(526, 13)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(526, 11)" end="(526, 13)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(526, 13)" end="(526, 14)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(526, 15)" end="(526, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(526, 15)" end="(526, 29)" leading="" trailing="" raw_val="dropWhile_cons" val="dropWhile_cons" full_name="List.dropWhile_cons" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(526, 29)" end="(526, 30)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(527, 5)" end="(527, 10)" kind="Lean.Parser.Tactic.split" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : popWhile p l.reverse.toArray = (dropWhile p l).reverse.toArray&#10;⊢ (if p a = true then (dropWhile p l).reverse.toArray else (l.reverse ++ [a]).toArray) =&#10;    (if p a = true then dropWhile p l else a :: l).reverse.toArray" state_after="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : popWhile p l.reverse.toArray = (dropWhile p l).reverse.toArray&#10;h✝ : p a = true&#10;⊢ (dropWhile p l).reverse.toArray = (dropWhile p l).reverse.toArray&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : popWhile p l.reverse.toArray = (dropWhile p l).reverse.toArray&#10;h✝ : ¬p a = true&#10;⊢ (l.reverse ++ [a]).toArray = (a :: l).reverse.toArray" tactic="split">
                                      <AtomNode start="(527, 5)" end="(527, 10)" leading="" trailing="&#10;    " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(528, 5)" end="(528, 10)" kind="Lean.cdot" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : popWhile p l.reverse.toArray = (dropWhile p l).reverse.toArray&#10;h✝ : p a = true&#10;⊢ (dropWhile p l).reverse.toArray = (dropWhile p l).reverse.toArray&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : popWhile p l.reverse.toArray = (dropWhile p l).reverse.toArray&#10;h✝ : ¬p a = true&#10;⊢ (l.reverse ++ [a]).toArray = (a :: l).reverse.toArray" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : popWhile p l.reverse.toArray = (dropWhile p l).reverse.toArray&#10;h✝ : ¬p a = true&#10;⊢ (l.reverse ++ [a]).toArray = (a :: l).reverse.toArray" tactic="· rfl">
                                      <OtherNode start="(528, 5)" end="(528, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(528, 5)" end="(528, 6)" kind="patternIgnore">
                                          <OtherNode start="(528, 5)" end="(528, 6)" kind="token.«· »">
                                            <AtomNode start="(528, 5)" end="(528, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(528, 7)" end="(528, 10)">
                                        <TacticTacticseq1IndentedNode start="(528, 7)" end="(528, 10)">
                                          <NullNode start="(528, 7)" end="(528, 10)">
                                            <OtherNode start="(528, 7)" end="(528, 10)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : popWhile p l.reverse.toArray = (dropWhile p l).reverse.toArray&#10;h✝ : p a = true&#10;⊢ (dropWhile p l).reverse.toArray = (dropWhile p l).reverse.toArray" state_after="no goals" tactic="rfl">
                                              <AtomNode start="(528, 7)" end="(528, 10)" leading="" trailing="&#10;    " val="rfl"/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(529, 5)" end="(529, 11)" kind="Lean.cdot" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : popWhile p l.reverse.toArray = (dropWhile p l).reverse.toArray&#10;h✝ : ¬p a = true&#10;⊢ (l.reverse ++ [a]).toArray = (a :: l).reverse.toArray" state_after="no goals" tactic="· simp">
                                      <OtherNode start="(529, 5)" end="(529, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(529, 5)" end="(529, 6)" kind="patternIgnore">
                                          <OtherNode start="(529, 5)" end="(529, 6)" kind="token.«· »">
                                            <AtomNode start="(529, 5)" end="(529, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(529, 7)" end="(529, 11)">
                                        <TacticTacticseq1IndentedNode start="(529, 7)" end="(529, 11)">
                                          <NullNode start="(529, 7)" end="(529, 11)">
                                            <OtherNode start="(529, 7)" end="(529, 11)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;ih : popWhile p l.reverse.toArray = (dropWhile p l).reverse.toArray&#10;h✝ : ¬p a = true&#10;⊢ (l.reverse ++ [a]).toArray = (a :: l).reverse.toArray" state_after="no goals" tactic="simp">
                                              <AtomNode start="(529, 7)" end="(529, 11)" leading="" trailing="&#10;&#10;" val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(531, 1)" end="(533, 32)" name="popWhile_toArray" full_name="List.popWhile_toArray">
      <CommandDeclmodifiersNode start="(531, 1)" end="(531, 8)">
        <NullNode/>
        <NullNode start="(531, 1)" end="(531, 8)">
          <OtherNode start="(531, 1)" end="(531, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(531, 1)" end="(531, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(531, 3)" end="(531, 7)">
              <OtherNode start="(531, 3)" end="(531, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(531, 3)" end="(531, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(531, 3)" end="(531, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(531, 7)" end="(531, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(531, 9)" end="(533, 32)" name="popWhile_toArray" full_name="List.popWhile_toArray" _is_private_decl="False">
        <AtomNode start="(531, 9)" end="(531, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(531, 17)" end="(531, 33)">
          <IdentNode start="(531, 17)" end="(531, 33)" leading="" trailing=" " raw_val="popWhile_toArray" val="popWhile_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(531, 34)" end="(532, 67)">
          <NullNode start="(531, 34)" end="(531, 61)">
            <TermExplicitbinderNode start="(531, 34)" end="(531, 48)">
              <AtomNode start="(531, 34)" end="(531, 35)" leading="" trailing="" val="("/>
              <NullNode start="(531, 35)" end="(531, 36)">
                <IdentNode start="(531, 35)" end="(531, 36)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(531, 37)" end="(531, 47)">
                <AtomNode start="(531, 37)" end="(531, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(531, 39)" end="(531, 47)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(531, 39)" end="(531, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(531, 41)" end="(531, 42)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(531, 43)" end="(531, 47)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(531, 47)" end="(531, 48)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(531, 49)" end="(531, 61)">
              <AtomNode start="(531, 49)" end="(531, 50)" leading="" trailing="" val="("/>
              <NullNode start="(531, 50)" end="(531, 51)">
                <IdentNode start="(531, 50)" end="(531, 51)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(531, 52)" end="(531, 60)">
                <AtomNode start="(531, 52)" end="(531, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(531, 54)" end="(531, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(531, 54)" end="(531, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(531, 59)" end="(531, 60)">
                    <IdentNode start="(531, 59)" end="(531, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(531, 60)" end="(531, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(531, 62)" end="(532, 67)">
            <AtomNode start="(531, 62)" end="(531, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(532, 5)" end="(532, 67)" kind="«term_=_»">
              <OtherNode start="(532, 5)" end="(532, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(532, 5)" end="(532, 23)" leading="" trailing=" " raw_val="l.toArray.popWhile" val="l.toArray.popWhile"/>
                <NullNode start="(532, 24)" end="(532, 25)">
                  <IdentNode start="(532, 24)" end="(532, 25)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(532, 26)" end="(532, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(532, 28)" end="(532, 67)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(532, 28)" end="(532, 51)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(532, 28)" end="(532, 29)" leading="" trailing="" val="("/>
                  <OtherNode start="(532, 29)" end="(532, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(532, 29)" end="(532, 48)" leading="" trailing=" " raw_val="l.reverse.dropWhile" val="l.reverse.dropWhile"/>
                    <NullNode start="(532, 49)" end="(532, 50)">
                      <IdentNode start="(532, 49)" end="(532, 50)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(532, 50)" end="(532, 51)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(532, 51)" end="(532, 52)" leading="" trailing="" val="."/>
                <IdentNode start="(532, 52)" end="(532, 67)" leading="" trailing=" " raw_val="reverse.toArray" val="reverse.toArray"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(532, 68)" end="(533, 32)">
          <AtomNode start="(532, 68)" end="(532, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(532, 71)" end="(533, 32)">
            <AtomNode start="(532, 71)" end="(532, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(533, 3)" end="(533, 32)">
              <TacticTacticseq1IndentedNode start="(533, 3)" end="(533, 32)">
                <NullNode start="(533, 3)" end="(533, 32)">
                  <OtherNode start="(533, 3)" end="(533, 32)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ popWhile p l.toArray = (dropWhile p l.reverse).reverse.toArray" state_after="no goals" tactic="simp [← popWhile_toArray_aux]">
                    <AtomNode start="(533, 3)" end="(533, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(533, 8)" end="(533, 32)">
                      <AtomNode start="(533, 8)" end="(533, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(533, 9)" end="(533, 31)">
                        <OtherNode start="(533, 9)" end="(533, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(533, 9)" end="(533, 10)">
                            <OtherNode start="(533, 9)" end="(533, 10)" kind="patternIgnore">
                              <OtherNode start="(533, 9)" end="(533, 10)" kind="token.«← »">
                                <AtomNode start="(533, 9)" end="(533, 10)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(533, 11)" end="(533, 31)" leading="" trailing="" raw_val="popWhile_toArray_aux" val="popWhile_toArray_aux" full_name="_private.Init.Data.List.ToArray.0.List.popWhile_toArray_aux" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(520, 17)" def_end="(520, 37)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(533, 31)" end="(533, 32)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(535, 1)" end="(541, 40)" name="setIfInBounds_toArray" full_name="List.setIfInBounds_toArray">
      <CommandDeclmodifiersNode start="(535, 1)" end="(535, 8)">
        <NullNode/>
        <NullNode start="(535, 1)" end="(535, 8)">
          <OtherNode start="(535, 1)" end="(535, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(535, 1)" end="(535, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(535, 3)" end="(535, 7)">
              <OtherNode start="(535, 3)" end="(535, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(535, 3)" end="(535, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(535, 3)" end="(535, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(535, 7)" end="(535, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(535, 9)" end="(541, 40)" name="setIfInBounds_toArray" full_name="List.setIfInBounds_toArray" _is_private_decl="False">
        <AtomNode start="(535, 9)" end="(535, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(535, 17)" end="(535, 38)">
          <IdentNode start="(535, 17)" end="(535, 38)" leading="" trailing=" " raw_val="setIfInBounds_toArray" val="setIfInBounds_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(535, 39)" end="(536, 55)">
          <NullNode start="(535, 39)" end="(535, 69)">
            <TermExplicitbinderNode start="(535, 39)" end="(535, 51)">
              <AtomNode start="(535, 39)" end="(535, 40)" leading="" trailing="" val="("/>
              <NullNode start="(535, 40)" end="(535, 41)">
                <IdentNode start="(535, 40)" end="(535, 41)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(535, 42)" end="(535, 50)">
                <AtomNode start="(535, 42)" end="(535, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(535, 44)" end="(535, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(535, 44)" end="(535, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(535, 49)" end="(535, 50)">
                    <IdentNode start="(535, 49)" end="(535, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(535, 50)" end="(535, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(535, 52)" end="(535, 61)">
              <AtomNode start="(535, 52)" end="(535, 53)" leading="" trailing="" val="("/>
              <NullNode start="(535, 53)" end="(535, 54)">
                <IdentNode start="(535, 53)" end="(535, 54)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(535, 55)" end="(535, 60)">
                <AtomNode start="(535, 55)" end="(535, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(535, 57)" end="(535, 60)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(535, 60)" end="(535, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(535, 62)" end="(535, 69)">
              <AtomNode start="(535, 62)" end="(535, 63)" leading="" trailing="" val="("/>
              <NullNode start="(535, 63)" end="(535, 64)">
                <IdentNode start="(535, 63)" end="(535, 64)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(535, 65)" end="(535, 68)">
                <AtomNode start="(535, 65)" end="(535, 66)" leading="" trailing=" " val=":"/>
                <IdentNode start="(535, 67)" end="(535, 68)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(535, 68)" end="(535, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(535, 70)" end="(536, 55)">
            <AtomNode start="(535, 70)" end="(535, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(536, 5)" end="(536, 55)" kind="«term_=_»">
              <OtherNode start="(536, 5)" end="(536, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(536, 5)" end="(536, 28)" leading="" trailing=" " raw_val="l.toArray.setIfInBounds" val="l.toArray.setIfInBounds"/>
                <NullNode start="(536, 29)" end="(536, 32)">
                  <IdentNode start="(536, 29)" end="(536, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(536, 31)" end="(536, 32)" leading="" trailing="  " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(536, 34)" end="(536, 35)" leading="" trailing=" " val="="/>
              <OtherNode start="(536, 36)" end="(536, 55)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(536, 36)" end="(536, 47)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(536, 36)" end="(536, 37)" leading="" trailing="" val="("/>
                  <OtherNode start="(536, 37)" end="(536, 46)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(536, 37)" end="(536, 42)" leading="" trailing=" " raw_val="l.set" val="l.set"/>
                    <NullNode start="(536, 43)" end="(536, 46)">
                      <IdentNode start="(536, 43)" end="(536, 44)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(536, 45)" end="(536, 46)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(536, 46)" end="(536, 47)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(536, 47)" end="(536, 48)" leading="" trailing="" val="."/>
                <IdentNode start="(536, 48)" end="(536, 55)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(536, 56)" end="(541, 40)">
          <AtomNode start="(536, 56)" end="(536, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(536, 59)" end="(541, 40)">
            <AtomNode start="(536, 59)" end="(536, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(537, 3)" end="(541, 40)">
              <TacticTacticseq1IndentedNode start="(537, 3)" end="(541, 40)">
                <NullNode start="(537, 3)" end="(541, 40)">
                  <OtherNode start="(537, 3)" end="(537, 13)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ l.toArray.setIfInBounds i a = (l.set i a).toArray" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ (l.toArray.setIfInBounds i a).toList = (l.set i a).toArray.toList" tactic="apply ext'">
                    <AtomNode start="(537, 3)" end="(537, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(537, 9)" end="(537, 13)" leading="" trailing="&#10;  " raw_val="ext'" val="ext'" full_name="Array.ext'" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(538, 3)" end="(538, 28)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ (l.toArray.setIfInBounds i a).toList = (l.set i a).toArray.toList" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ (if h : i &amp;lt; l.toArray.size then l.toArray.set i a h else l.toArray).toList = l.set i a" tactic="simp only [setIfInBounds]">
                    <AtomNode start="(538, 3)" end="(538, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(538, 8)" end="(538, 12)">
                      <AtomNode start="(538, 8)" end="(538, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(538, 13)" end="(538, 28)">
                      <AtomNode start="(538, 13)" end="(538, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(538, 14)" end="(538, 27)">
                        <OtherNode start="(538, 14)" end="(538, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(538, 14)" end="(538, 27)" leading="" trailing="" raw_val="setIfInBounds" val="setIfInBounds" full_name="Array.setIfInBounds" mod_name="Init.Data.Array.Set" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Set.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(538, 27)" end="(538, 28)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(539, 3)" end="(539, 8)" kind="Lean.Parser.Tactic.split" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ (if h : i &amp;lt; l.toArray.size then l.toArray.set i a h else l.toArray).toList = l.set i a" state_after="case h.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h✝ : i &amp;lt; l.toArray.size&#10;⊢ (l.toArray.set i a h✝).toList = l.set i a&#10;&#10;case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h✝ : ¬i &amp;lt; l.toArray.size&#10;⊢ l.toArray.toList = l.set i a" tactic="split">
                    <AtomNode start="(539, 3)" end="(539, 8)" leading="" trailing="&#10;  " val="split"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(540, 3)" end="(540, 9)" kind="Lean.cdot" state_before="case h.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h✝ : i &amp;lt; l.toArray.size&#10;⊢ (l.toArray.set i a h✝).toList = l.set i a&#10;&#10;case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h✝ : ¬i &amp;lt; l.toArray.size&#10;⊢ l.toArray.toList = l.set i a" state_after="case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h✝ : ¬i &amp;lt; l.toArray.size&#10;⊢ l.toArray.toList = l.set i a" tactic="· simp">
                    <OtherNode start="(540, 3)" end="(540, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(540, 3)" end="(540, 4)" kind="patternIgnore">
                        <OtherNode start="(540, 3)" end="(540, 4)" kind="token.«· »">
                          <AtomNode start="(540, 3)" end="(540, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(540, 5)" end="(540, 9)">
                      <TacticTacticseq1IndentedNode start="(540, 5)" end="(540, 9)">
                        <NullNode start="(540, 5)" end="(540, 9)">
                          <OtherNode start="(540, 5)" end="(540, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h✝ : i &amp;lt; l.toArray.size&#10;⊢ (l.toArray.set i a h✝).toList = l.set i a" state_after="no goals" tactic="simp">
                            <AtomNode start="(540, 5)" end="(540, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(541, 3)" end="(541, 40)" kind="Lean.cdot" state_before="case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h✝ : ¬i &amp;lt; l.toArray.size&#10;⊢ l.toArray.toList = l.set i a" state_after="no goals" tactic="· simp_all [List.set_eq_of_length_le]">
                    <OtherNode start="(541, 3)" end="(541, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(541, 3)" end="(541, 4)" kind="patternIgnore">
                        <OtherNode start="(541, 3)" end="(541, 4)" kind="token.«· »">
                          <AtomNode start="(541, 3)" end="(541, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(541, 5)" end="(541, 40)">
                      <TacticTacticseq1IndentedNode start="(541, 5)" end="(541, 40)">
                        <NullNode start="(541, 5)" end="(541, 40)">
                          <OtherNode start="(541, 5)" end="(541, 40)" kind="Lean.Parser.Tactic.simpAll" state_before="case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h✝ : ¬i &amp;lt; l.toArray.size&#10;⊢ l.toArray.toList = l.set i a" state_after="no goals" tactic="simp_all [List.set_eq_of_length_le]">
                            <AtomNode start="(541, 5)" end="(541, 13)" leading="" trailing=" " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(541, 14)" end="(541, 40)">
                              <AtomNode start="(541, 14)" end="(541, 15)" leading="" trailing="" val="["/>
                              <NullNode start="(541, 15)" end="(541, 39)">
                                <OtherNode start="(541, 15)" end="(541, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(541, 15)" end="(541, 39)" leading="" trailing="" raw_val="List.set_eq_of_length_le" val="List.set_eq_of_length_le" full_name="List.set_eq_of_length_le" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(541, 39)" end="(541, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(543, 1)" end="(544, 62)" name="toArray_replicate" full_name="List.toArray_replicate">
      <CommandDeclmodifiersNode start="(543, 1)" end="(543, 8)">
        <NullNode/>
        <NullNode start="(543, 1)" end="(543, 8)">
          <OtherNode start="(543, 1)" end="(543, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(543, 1)" end="(543, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(543, 3)" end="(543, 7)">
              <OtherNode start="(543, 3)" end="(543, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(543, 3)" end="(543, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(543, 3)" end="(543, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(543, 7)" end="(543, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(543, 9)" end="(544, 62)" name="toArray_replicate" full_name="List.toArray_replicate" _is_private_decl="False">
        <AtomNode start="(543, 9)" end="(543, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(543, 17)" end="(543, 34)">
          <IdentNode start="(543, 17)" end="(543, 34)" leading="" trailing=" " raw_val="toArray_replicate" val="toArray_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(543, 35)" end="(544, 55)">
          <NullNode start="(543, 35)" end="(543, 52)">
            <TermExplicitbinderNode start="(543, 35)" end="(543, 44)">
              <AtomNode start="(543, 35)" end="(543, 36)" leading="" trailing="" val="("/>
              <NullNode start="(543, 36)" end="(543, 37)">
                <IdentNode start="(543, 36)" end="(543, 37)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(543, 38)" end="(543, 43)">
                <AtomNode start="(543, 38)" end="(543, 39)" leading="" trailing=" " val=":"/>
                <IdentNode start="(543, 40)" end="(543, 43)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(543, 43)" end="(543, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(543, 45)" end="(543, 52)">
              <AtomNode start="(543, 45)" end="(543, 46)" leading="" trailing="" val="("/>
              <NullNode start="(543, 46)" end="(543, 47)">
                <IdentNode start="(543, 46)" end="(543, 47)" leading="" trailing=" " raw_val="v" val="v"/>
              </NullNode>
              <NullNode start="(543, 48)" end="(543, 51)">
                <AtomNode start="(543, 48)" end="(543, 49)" leading="" trailing=" " val=":"/>
                <IdentNode start="(543, 50)" end="(543, 51)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(543, 51)" end="(543, 52)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(543, 53)" end="(544, 55)">
            <AtomNode start="(543, 53)" end="(543, 54)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(544, 5)" end="(544, 55)" kind="«term_=_»">
              <OtherNode start="(544, 5)" end="(544, 33)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(544, 5)" end="(544, 25)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(544, 5)" end="(544, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(544, 6)" end="(544, 24)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(544, 6)" end="(544, 20)" leading="" trailing=" " raw_val="List.replicate" val="List.replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(544, 21)" end="(544, 24)">
                      <IdentNode start="(544, 21)" end="(544, 22)" leading="" trailing=" " raw_val="n" val="n"/>
                      <IdentNode start="(544, 23)" end="(544, 24)" leading="" trailing="" raw_val="v" val="v"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(544, 24)" end="(544, 25)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(544, 25)" end="(544, 26)" leading="" trailing="" val="."/>
                <IdentNode start="(544, 26)" end="(544, 33)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(544, 34)" end="(544, 35)" leading="" trailing=" " val="="/>
              <OtherNode start="(544, 36)" end="(544, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(544, 36)" end="(544, 51)" leading="" trailing=" " raw_val="Array.replicate" val="Array.replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(544, 52)" end="(544, 55)">
                  <IdentNode start="(544, 52)" end="(544, 53)" leading="" trailing=" " raw_val="n" val="n"/>
                  <IdentNode start="(544, 54)" end="(544, 55)" leading="" trailing=" " raw_val="v" val="v"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(544, 56)" end="(544, 62)">
          <AtomNode start="(544, 56)" end="(544, 58)" leading="" trailing=" " val=":="/>
          <IdentNode start="(544, 59)" end="(544, 62)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(546, 1)" end="(548, 7)" name="_root_.Array.replicate_eq_toArray_replicate" full_name="Array.replicate_eq_toArray_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(546, 1)" end="(548, 7)" name="_root_.Array.replicate_eq_toArray_replicate" full_name="Array.replicate_eq_toArray_replicate" _is_private_decl="False">
        <AtomNode start="(546, 1)" end="(546, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(546, 9)" end="(546, 52)">
          <IdentNode start="(546, 9)" end="(546, 52)" leading="" trailing=" " raw_val="_root_.Array.replicate_eq_toArray_replicate" val="_root_.Array.replicate_eq_toArray_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(546, 53)" end="(547, 55)">
          <NullNode/>
          <TermTypespecNode start="(546, 53)" end="(547, 55)">
            <AtomNode start="(546, 53)" end="(546, 54)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(547, 5)" end="(547, 55)" kind="«term_=_»">
              <OtherNode start="(547, 5)" end="(547, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(547, 5)" end="(547, 20)" leading="" trailing=" " raw_val="Array.replicate" val="Array.replicate" full_name="Array.replicate" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(547, 21)" end="(547, 24)">
                  <IdentNode start="(547, 21)" end="(547, 22)" leading="" trailing=" " raw_val="n" val="n"/>
                  <IdentNode start="(547, 23)" end="(547, 24)" leading="" trailing=" " raw_val="v" val="v"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(547, 25)" end="(547, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(547, 27)" end="(547, 55)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(547, 27)" end="(547, 47)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(547, 27)" end="(547, 28)" leading="" trailing="" val="("/>
                  <OtherNode start="(547, 28)" end="(547, 46)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(547, 28)" end="(547, 42)" leading="" trailing=" " raw_val="List.replicate" val="List.replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(547, 43)" end="(547, 46)">
                      <IdentNode start="(547, 43)" end="(547, 44)" leading="" trailing=" " raw_val="n" val="n"/>
                      <IdentNode start="(547, 45)" end="(547, 46)" leading="" trailing="" raw_val="v" val="v"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(547, 46)" end="(547, 47)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(547, 47)" end="(547, 48)" leading="" trailing="" val="."/>
                <IdentNode start="(547, 48)" end="(547, 55)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(547, 56)" end="(548, 7)">
          <AtomNode start="(547, 56)" end="(547, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(547, 59)" end="(548, 7)">
            <AtomNode start="(547, 59)" end="(547, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(548, 3)" end="(548, 7)">
              <TacticTacticseq1IndentedNode start="(548, 3)" end="(548, 7)">
                <NullNode start="(548, 3)" end="(548, 7)">
                  <OtherNode start="(548, 3)" end="(548, 7)" kind="Lean.Parser.Tactic.simp" state_before="n : Nat&#10;α✝ : Type u_1&#10;v : α✝&#10;⊢ Array.replicate n v = (replicate n v).toArray" state_after="no goals" tactic="simp">
                    <AtomNode start="(548, 3)" end="(548, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(550, 1)" end="(551, 97)" name="_root_.Array.mkArray_eq_toArray_replicate" full_name="Array.mkArray_eq_toArray_replicate">
      <CommandDeclmodifiersNode start="(550, 1)" end="(550, 82)">
        <NullNode/>
        <NullNode start="(550, 1)" end="(550, 82)">
          <OtherNode start="(550, 1)" end="(550, 82)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(550, 1)" end="(550, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(550, 3)" end="(550, 81)">
              <OtherNode start="(550, 3)" end="(550, 81)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(550, 3)" end="(550, 81)" kind="Lean.deprecated">
                  <AtomNode start="(550, 3)" end="(550, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(550, 14)" end="(550, 57)">
                    <IdentNode start="(550, 14)" end="(550, 57)" leading="" trailing=" " raw_val="_root_.Array.replicate_eq_toArray_replicate" val="_root_.Array.replicate_eq_toArray_replicate" full_name="Array.replicate_eq_toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(546, 9)" def_end="(546, 52)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(550, 58)" end="(550, 81)">
                    <AtomNode start="(550, 58)" end="(550, 59)" leading="" trailing="" val="("/>
                    <AtomNode start="(550, 59)" end="(550, 64)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(550, 65)" end="(550, 67)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(550, 68)" end="(550, 80)" kind="str">
                      <AtomNode start="(550, 68)" end="(550, 80)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(550, 80)" end="(550, 81)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(550, 81)" end="(550, 82)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(551, 1)" end="(551, 97)" name="_root_.Array.mkArray_eq_toArray_replicate">
        <AtomNode start="(551, 1)" end="(551, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(551, 8)" end="(551, 49)">
          <IdentNode start="(551, 8)" end="(551, 49)" leading="" trailing=" " raw_val="_root_.Array.mkArray_eq_toArray_replicate" val="_root_.Array.mkArray_eq_toArray_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(551, 50)" end="(551, 97)">
          <AtomNode start="(551, 50)" end="(551, 52)" leading="" trailing=" " val=":="/>
          <OtherNode start="(551, 53)" end="(551, 97)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(551, 53)" end="(551, 54)" leading="" trailing="" val="@"/>
            <IdentNode start="(551, 54)" end="(551, 97)" leading="" trailing="&#10;&#10;" raw_val="_root_.Array.replicate_eq_toArray_replicate" val="_root_.Array.replicate_eq_toArray_replicate" full_name="Array.replicate_eq_toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(546, 9)" def_end="(546, 52)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(553, 1)" end="(553, 93)" name="flatMap_empty" full_name="List.flatMap_empty">
      <CommandDeclmodifiersNode start="(553, 1)" end="(553, 8)">
        <NullNode/>
        <NullNode start="(553, 1)" end="(553, 8)">
          <OtherNode start="(553, 1)" end="(553, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(553, 1)" end="(553, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(553, 3)" end="(553, 7)">
              <OtherNode start="(553, 3)" end="(553, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(553, 3)" end="(553, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(553, 3)" end="(553, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(553, 7)" end="(553, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(553, 9)" end="(553, 93)" name="flatMap_empty" full_name="List.flatMap_empty" _is_private_decl="False">
        <AtomNode start="(553, 9)" end="(553, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(553, 17)" end="(553, 30)">
          <IdentNode start="(553, 17)" end="(553, 30)" leading="" trailing=" " raw_val="flatMap_empty" val="flatMap_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(553, 31)" end="(553, 86)">
          <NullNode start="(553, 31)" end="(553, 52)">
            <OtherNode start="(553, 31)" end="(553, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(553, 31)" end="(553, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(553, 32)" end="(553, 33)">
                <IdentNode start="(553, 32)" end="(553, 33)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(553, 33)" end="(553, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(553, 35)" end="(553, 52)">
              <AtomNode start="(553, 35)" end="(553, 36)" leading="" trailing="" val="("/>
              <NullNode start="(553, 36)" end="(553, 37)">
                <IdentNode start="(553, 36)" end="(553, 37)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(553, 38)" end="(553, 51)">
                <AtomNode start="(553, 38)" end="(553, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(553, 40)" end="(553, 51)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(553, 40)" end="(553, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(553, 42)" end="(553, 43)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(553, 44)" end="(553, 51)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(553, 44)" end="(553, 49)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(553, 50)" end="(553, 51)">
                      <IdentNode start="(553, 50)" end="(553, 51)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(553, 51)" end="(553, 52)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(553, 53)" end="(553, 86)">
            <AtomNode start="(553, 53)" end="(553, 54)" leading="" trailing=" " val=":"/>
            <OtherNode start="(553, 55)" end="(553, 86)" kind="«term_=_»">
              <OtherNode start="(553, 55)" end="(553, 80)" kind="Lean.Parser.Term.app">
                <OtherNode start="(553, 55)" end="(553, 78)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(553, 55)" end="(553, 70)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(553, 55)" end="(553, 56)" leading="" trailing="" val="("/>
                    <OtherNode start="(553, 56)" end="(553, 59)" kind="«term#[_,]»">
                      <AtomNode start="(553, 56)" end="(553, 58)" leading="" trailing="" val="#["/>
                      <NullNode/>
                      <AtomNode start="(553, 58)" end="(553, 59)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <AtomNode start="(553, 60)" end="(553, 61)" leading="" trailing=" " val=":"/>
                    <NullNode start="(553, 62)" end="(553, 69)">
                      <OtherNode start="(553, 62)" end="(553, 69)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(553, 62)" end="(553, 67)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(553, 68)" end="(553, 69)">
                          <IdentNode start="(553, 68)" end="(553, 69)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(553, 69)" end="(553, 70)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(553, 70)" end="(553, 71)" leading="" trailing="" val="."/>
                  <IdentNode start="(553, 71)" end="(553, 78)" leading="" trailing=" " raw_val="flatMap" val="flatMap" full_name="Array.flatMap" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(553, 79)" end="(553, 80)">
                  <IdentNode start="(553, 79)" end="(553, 80)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(553, 81)" end="(553, 82)" leading="" trailing=" " val="="/>
              <OtherNode start="(553, 83)" end="(553, 86)" kind="«term#[_,]»">
                <AtomNode start="(553, 83)" end="(553, 85)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(553, 85)" end="(553, 86)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(553, 87)" end="(553, 93)">
          <AtomNode start="(553, 87)" end="(553, 89)" leading="" trailing=" " val=":="/>
          <IdentNode start="(553, 90)" end="(553, 93)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(555, 1)" end="(563, 44)" name="flatMap_toArray_cons" full_name="List.flatMap_toArray_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(555, 1)" end="(563, 44)" name="flatMap_toArray_cons" full_name="List.flatMap_toArray_cons" _is_private_decl="False">
        <AtomNode start="(555, 1)" end="(555, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(555, 9)" end="(555, 29)">
          <IdentNode start="(555, 9)" end="(555, 29)" leading="" trailing=" " raw_val="flatMap_toArray_cons" val="flatMap_toArray_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(555, 30)" end="(556, 62)">
          <NullNode start="(555, 30)" end="(555, 73)">
            <OtherNode start="(555, 30)" end="(555, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(555, 30)" end="(555, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(555, 31)" end="(555, 32)">
                <IdentNode start="(555, 31)" end="(555, 32)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(555, 32)" end="(555, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(555, 34)" end="(555, 51)">
              <AtomNode start="(555, 34)" end="(555, 35)" leading="" trailing="" val="("/>
              <NullNode start="(555, 35)" end="(555, 36)">
                <IdentNode start="(555, 35)" end="(555, 36)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(555, 37)" end="(555, 50)">
                <AtomNode start="(555, 37)" end="(555, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(555, 39)" end="(555, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(555, 39)" end="(555, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(555, 41)" end="(555, 42)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(555, 43)" end="(555, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(555, 43)" end="(555, 48)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(555, 49)" end="(555, 50)">
                      <IdentNode start="(555, 49)" end="(555, 50)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(555, 50)" end="(555, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(555, 52)" end="(555, 59)">
              <AtomNode start="(555, 52)" end="(555, 53)" leading="" trailing="" val="("/>
              <NullNode start="(555, 53)" end="(555, 54)">
                <IdentNode start="(555, 53)" end="(555, 54)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(555, 55)" end="(555, 58)">
                <AtomNode start="(555, 55)" end="(555, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(555, 57)" end="(555, 58)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(555, 58)" end="(555, 59)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(555, 60)" end="(555, 73)">
              <AtomNode start="(555, 60)" end="(555, 61)" leading="" trailing="" val="("/>
              <NullNode start="(555, 61)" end="(555, 63)">
                <IdentNode start="(555, 61)" end="(555, 63)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(555, 64)" end="(555, 72)">
                <AtomNode start="(555, 64)" end="(555, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(555, 66)" end="(555, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(555, 66)" end="(555, 70)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(555, 71)" end="(555, 72)">
                    <IdentNode start="(555, 71)" end="(555, 72)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(555, 72)" end="(555, 73)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(555, 74)" end="(556, 62)">
            <AtomNode start="(555, 74)" end="(555, 75)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(556, 5)" end="(556, 62)" kind="«term_=_»">
              <OtherNode start="(556, 5)" end="(556, 32)" kind="Lean.Parser.Term.app">
                <OtherNode start="(556, 5)" end="(556, 30)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(556, 5)" end="(556, 14)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(556, 5)" end="(556, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(556, 6)" end="(556, 13)" kind="«term_::_»">
                      <IdentNode start="(556, 6)" end="(556, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(556, 8)" end="(556, 10)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(556, 11)" end="(556, 13)" leading="" trailing="" raw_val="as" val="as"/>
                    </OtherNode>
                    <AtomNode start="(556, 13)" end="(556, 14)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(556, 14)" end="(556, 15)" leading="" trailing="" val="."/>
                  <IdentNode start="(556, 15)" end="(556, 30)" leading="" trailing=" " raw_val="toArray.flatMap" val="toArray.flatMap"/>
                </OtherNode>
                <NullNode start="(556, 31)" end="(556, 32)">
                  <IdentNode start="(556, 31)" end="(556, 32)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(556, 33)" end="(556, 34)" leading="" trailing=" " val="="/>
              <OtherNode start="(556, 35)" end="(556, 62)" kind="«term_++_»">
                <OtherNode start="(556, 35)" end="(556, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(556, 35)" end="(556, 36)" leading="" trailing=" " raw_val="f" val="f"/>
                  <NullNode start="(556, 37)" end="(556, 38)">
                    <IdentNode start="(556, 37)" end="(556, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(556, 39)" end="(556, 41)" leading="" trailing=" " val="++"/>
                <OtherNode start="(556, 42)" end="(556, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(556, 42)" end="(556, 60)" leading="" trailing=" " raw_val="as.toArray.flatMap" val="as.toArray.flatMap"/>
                  <NullNode start="(556, 61)" end="(556, 62)">
                    <IdentNode start="(556, 61)" end="(556, 62)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(556, 63)" end="(563, 44)">
          <AtomNode start="(556, 63)" end="(556, 65)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(556, 66)" end="(563, 44)">
            <AtomNode start="(556, 66)" end="(556, 68)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(557, 3)" end="(563, 44)">
              <TacticTacticseq1IndentedNode start="(557, 3)" end="(563, 44)">
                <NullNode start="(557, 3)" end="(563, 44)">
                  <OtherNode start="(557, 3)" end="(557, 23)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;a : α&#10;as : List α&#10;⊢ Array.flatMap f (a :: as).toArray = f a ++ Array.flatMap f as.toArray" state_after="α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;a : α&#10;as : List α&#10;⊢ foldl (fun bs a =&amp;gt; bs ++ f a) (#[] ++ f a) as = f a ++ foldl (fun bs a =&amp;gt; bs ++ f a) #[] as" tactic="simp [Array.flatMap]">
                    <AtomNode start="(557, 3)" end="(557, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(557, 8)" end="(557, 23)">
                      <AtomNode start="(557, 8)" end="(557, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(557, 9)" end="(557, 22)">
                        <OtherNode start="(557, 9)" end="(557, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(557, 9)" end="(557, 22)" leading="" trailing="" raw_val="Array.flatMap" val="Array.flatMap" full_name="Array.flatMap" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(557, 22)" end="(557, 23)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(558, 3)" end="(561, 25)" kind="Lean.Parser.Tactic.tacticSuffices_" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;a : α&#10;as : List α&#10;⊢ foldl (fun bs a =&amp;gt; bs ++ f a) (#[] ++ f a) as = f a ++ foldl (fun bs a =&amp;gt; bs ++ f a) #[] as" state_after="α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;a : α&#10;as : List α&#10;⊢ ∀ (xs : Array β), foldl (fun ys a =&amp;gt; ys ++ f a) (f a ++ xs) as = f a ++ foldl (fun ys a =&amp;gt; ys ++ f a) xs as" tactic="suffices ∀ xs, List.foldl (fun ys a =&amp;gt; ys ++ f a) (f a ++ xs) as =&#10;    f a ++ List.foldl (fun ys a =&amp;gt; ys ++ f a) xs as by&#10;  erw [empty_append] simpa using this #[]">
                    <AtomNode start="(558, 3)" end="(558, 11)" leading="" trailing=" " val="suffices"/>
                    <OtherNode start="(558, 12)" end="(561, 25)" kind="Lean.Parser.Term.sufficesDecl">
                      <OtherNode start="(558, 12)" end="(558, 12)" kind="hygieneInfo">
                        <IdentNode start="(558, 12)" end="(558, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                      </OtherNode>
                      <OtherNode start="(558, 12)" end="(559, 54)" kind="Lean.Parser.Term.forall">
                        <AtomNode start="(558, 12)" end="(558, 13)" leading="" trailing=" " val="∀"/>
                        <NullNode start="(558, 14)" end="(558, 16)">
                          <IdentNode start="(558, 14)" end="(558, 16)" leading="" trailing="" raw_val="xs" val="xs"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(558, 16)" end="(558, 17)" leading="" trailing=" " val=","/>
                        <OtherNode start="(558, 18)" end="(559, 54)" kind="«term_=_»">
                          <OtherNode start="(558, 18)" end="(558, 67)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(558, 18)" end="(558, 28)" leading="" trailing=" " raw_val="List.foldl" val="List.foldl" full_name="List.foldl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(558, 29)" end="(558, 67)">
                              <OtherNode start="(558, 29)" end="(558, 52)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(558, 29)" end="(558, 30)" leading="" trailing="" val="("/>
                                <OtherNode start="(558, 30)" end="(558, 51)" kind="Lean.Parser.Term.fun">
                                  <AtomNode start="(558, 30)" end="(558, 33)" leading="" trailing=" " val="fun"/>
                                  <OtherNode start="(558, 34)" end="(558, 51)" kind="Lean.Parser.Term.basicFun">
                                    <NullNode start="(558, 34)" end="(558, 38)">
                                      <IdentNode start="(558, 34)" end="(558, 36)" leading="" trailing=" " raw_val="ys" val="ys"/>
                                      <IdentNode start="(558, 37)" end="(558, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(558, 39)" end="(558, 41)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <OtherNode start="(558, 42)" end="(558, 51)" kind="«term_++_»">
                                      <IdentNode start="(558, 42)" end="(558, 44)" leading="" trailing=" " raw_val="ys" val="ys"/>
                                      <AtomNode start="(558, 45)" end="(558, 47)" leading="" trailing=" " val="++"/>
                                      <OtherNode start="(558, 48)" end="(558, 51)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(558, 48)" end="(558, 49)" leading="" trailing=" " raw_val="f" val="f"/>
                                        <NullNode start="(558, 50)" end="(558, 51)">
                                          <IdentNode start="(558, 50)" end="(558, 51)" leading="" trailing="" raw_val="a" val="a"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(558, 51)" end="(558, 52)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                              <OtherNode start="(558, 53)" end="(558, 64)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(558, 53)" end="(558, 54)" leading="" trailing="" val="("/>
                                <OtherNode start="(558, 54)" end="(558, 63)" kind="«term_++_»">
                                  <OtherNode start="(558, 54)" end="(558, 57)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(558, 54)" end="(558, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <NullNode start="(558, 56)" end="(558, 57)">
                                      <IdentNode start="(558, 56)" end="(558, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(558, 58)" end="(558, 60)" leading="" trailing=" " val="++"/>
                                  <IdentNode start="(558, 61)" end="(558, 63)" leading="" trailing="" raw_val="xs" val="xs"/>
                                </OtherNode>
                                <AtomNode start="(558, 63)" end="(558, 64)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                              <IdentNode start="(558, 65)" end="(558, 67)" leading="" trailing=" " raw_val="as" val="as"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(558, 68)" end="(558, 69)" leading="" trailing="&#10;      " val="="/>
                          <OtherNode start="(559, 7)" end="(559, 54)" kind="«term_++_»">
                            <OtherNode start="(559, 7)" end="(559, 10)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(559, 7)" end="(559, 8)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(559, 9)" end="(559, 10)">
                                <IdentNode start="(559, 9)" end="(559, 10)" leading="" trailing=" " raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(559, 11)" end="(559, 13)" leading="" trailing=" " val="++"/>
                            <OtherNode start="(559, 14)" end="(559, 54)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(559, 14)" end="(559, 24)" leading="" trailing=" " raw_val="List.foldl" val="List.foldl" full_name="List.foldl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(559, 25)" end="(559, 54)">
                                <OtherNode start="(559, 25)" end="(559, 48)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(559, 25)" end="(559, 26)" leading="" trailing="" val="("/>
                                  <OtherNode start="(559, 26)" end="(559, 47)" kind="Lean.Parser.Term.fun">
                                    <AtomNode start="(559, 26)" end="(559, 29)" leading="" trailing=" " val="fun"/>
                                    <OtherNode start="(559, 30)" end="(559, 47)" kind="Lean.Parser.Term.basicFun">
                                      <NullNode start="(559, 30)" end="(559, 34)">
                                        <IdentNode start="(559, 30)" end="(559, 32)" leading="" trailing=" " raw_val="ys" val="ys"/>
                                        <IdentNode start="(559, 33)" end="(559, 34)" leading="" trailing=" " raw_val="a" val="a"/>
                                      </NullNode>
                                      <NullNode/>
                                      <AtomNode start="(559, 35)" end="(559, 37)" leading="" trailing=" " val="=&amp;gt;"/>
                                      <OtherNode start="(559, 38)" end="(559, 47)" kind="«term_++_»">
                                        <IdentNode start="(559, 38)" end="(559, 40)" leading="" trailing=" " raw_val="ys" val="ys"/>
                                        <AtomNode start="(559, 41)" end="(559, 43)" leading="" trailing=" " val="++"/>
                                        <OtherNode start="(559, 44)" end="(559, 47)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(559, 44)" end="(559, 45)" leading="" trailing=" " raw_val="f" val="f"/>
                                          <NullNode start="(559, 46)" end="(559, 47)">
                                            <IdentNode start="(559, 46)" end="(559, 47)" leading="" trailing="" raw_val="a" val="a"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <AtomNode start="(559, 47)" end="(559, 48)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <IdentNode start="(559, 49)" end="(559, 51)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                <IdentNode start="(559, 52)" end="(559, 54)" leading="" trailing=" " raw_val="as" val="as"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(559, 55)" end="(561, 25)" kind="Lean.Parser.Term.byTactic'">
                        <AtomNode start="(559, 55)" end="(559, 57)" leading="" trailing="&#10;    " val="by"/>
                        <TacticTacticseqNode start="(560, 5)" end="(561, 25)">
                          <TacticTacticseq1IndentedNode start="(560, 5)" end="(561, 25)">
                            <NullNode start="(560, 5)" end="(561, 25)">
                              <OtherNode start="(560, 5)" end="(560, 23)" kind="Lean.Parser.Tactic.tacticErw___" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;a : α&#10;as : List α&#10;this : ∀ (xs : Array β), foldl (fun ys a =&amp;gt; ys ++ f a) (f a ++ xs) as = f a ++ foldl (fun ys a =&amp;gt; ys ++ f a) xs as&#10;⊢ foldl (fun bs a =&amp;gt; bs ++ f a) (#[] ++ f a) as = f a ++ foldl (fun bs a =&amp;gt; bs ++ f a) #[] as" state_after="α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;a : α&#10;as : List α&#10;this : ∀ (xs : Array β), foldl (fun ys a =&amp;gt; ys ++ f a) (f a ++ xs) as = f a ++ foldl (fun ys a =&amp;gt; ys ++ f a) xs as&#10;⊢ foldl (fun bs a =&amp;gt; bs ++ f a) (f a) as = f a ++ foldl (fun bs a =&amp;gt; bs ++ f a) #[] as" tactic="erw [empty_append]">
                                <AtomNode start="(560, 5)" end="(560, 8)" leading="" trailing=" " val="erw"/>
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <OtherNode start="(560, 9)" end="(560, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                  <AtomNode start="(560, 9)" end="(560, 10)" leading="" trailing="" val="["/>
                                  <NullNode start="(560, 10)" end="(560, 22)">
                                    <OtherNode start="(560, 10)" end="(560, 22)" kind="Lean.Parser.Tactic.rwRule">
                                      <NullNode/>
                                      <IdentNode start="(560, 10)" end="(560, 22)" leading="" trailing="" raw_val="empty_append" val="empty_append" full_name="Array.empty_append" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(560, 22)" end="(560, 23)" leading="" trailing=" -- Why doesn't this work via `simp`?&#10;    " val="]"/>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <OtherNode start="(561, 5)" end="(561, 25)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;a : α&#10;as : List α&#10;this : ∀ (xs : Array β), foldl (fun ys a =&amp;gt; ys ++ f a) (f a ++ xs) as = f a ++ foldl (fun ys a =&amp;gt; ys ++ f a) xs as&#10;⊢ foldl (fun bs a =&amp;gt; bs ++ f a) (f a) as = f a ++ foldl (fun bs a =&amp;gt; bs ++ f a) #[] as" state_after="no goals" tactic="simpa using this #[]">
                                <AtomNode start="(561, 5)" end="(561, 10)" leading="" trailing=" " val="simpa"/>
                                <NullNode/>
                                <NullNode/>
                                <OtherNode start="(561, 11)" end="(561, 25)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(561, 11)" end="(561, 25)">
                                    <AtomNode start="(561, 11)" end="(561, 16)" leading="" trailing=" " val="using"/>
                                    <OtherNode start="(561, 17)" end="(561, 25)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(561, 17)" end="(561, 21)" leading="" trailing=" " raw_val="this" val="this"/>
                                      <NullNode start="(561, 22)" end="(561, 25)">
                                        <OtherNode start="(561, 22)" end="(561, 25)" kind="«term#[_,]»">
                                          <AtomNode start="(561, 22)" end="(561, 24)" leading="" trailing="" val="#["/>
                                          <NullNode/>
                                          <AtomNode start="(561, 24)" end="(561, 25)" leading="" trailing="&#10;  " val="]"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </TacticTacticseq1IndentedNode>
                        </TacticTacticseqNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(562, 3)" end="(562, 11)" kind="Lean.Parser.Tactic.intro" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;a : α&#10;as : List α&#10;⊢ ∀ (xs : Array β), foldl (fun ys a =&amp;gt; ys ++ f a) (f a ++ xs) as = f a ++ foldl (fun ys a =&amp;gt; ys ++ f a) xs as" state_after="α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;a : α&#10;as : List α&#10;xs : Array β&#10;⊢ foldl (fun ys a =&amp;gt; ys ++ f a) (f a ++ xs) as = f a ++ foldl (fun ys a =&amp;gt; ys ++ f a) xs as" tactic="intro xs">
                    <AtomNode start="(562, 3)" end="(562, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(562, 9)" end="(562, 11)">
                      <IdentNode start="(562, 9)" end="(562, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(563, 3)" end="(563, 44)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;a : α&#10;as : List α&#10;xs : Array β&#10;⊢ foldl (fun ys a =&amp;gt; ys ++ f a) (f a ++ xs) as = f a ++ foldl (fun ys a =&amp;gt; ys ++ f a) xs as" state_after="no goals" tactic="induction as generalizing xs &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(563, 3)" end="(563, 31)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(563, 3)" end="(563, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(563, 13)" end="(563, 15)">
                        <OtherNode start="(563, 13)" end="(563, 15)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(563, 13)" end="(563, 15)" leading="" trailing=" " raw_val="as" val="as"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode start="(563, 16)" end="(563, 31)">
                        <AtomNode start="(563, 16)" end="(563, 28)" leading="" trailing=" " val="generalizing"/>
                        <NullNode start="(563, 29)" end="(563, 31)">
                          <IdentNode start="(563, 29)" end="(563, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        </NullNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(563, 32)" end="(563, 35)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(563, 36)" end="(563, 44)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(563, 36)" end="(563, 44)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(565, 1)" end="(571, 36)" name="flatMap_toArray" full_name="List.flatMap_toArray">
      <CommandDeclmodifiersNode start="(565, 1)" end="(565, 8)">
        <NullNode/>
        <NullNode start="(565, 1)" end="(565, 8)">
          <OtherNode start="(565, 1)" end="(565, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(565, 1)" end="(565, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(565, 3)" end="(565, 7)">
              <OtherNode start="(565, 3)" end="(565, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(565, 3)" end="(565, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(565, 3)" end="(565, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(565, 7)" end="(565, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(565, 9)" end="(571, 36)" name="flatMap_toArray" full_name="List.flatMap_toArray" _is_private_decl="False">
        <AtomNode start="(565, 9)" end="(565, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(565, 17)" end="(565, 32)">
          <IdentNode start="(565, 17)" end="(565, 32)" leading="" trailing=" " raw_val="flatMap_toArray" val="flatMap_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(565, 33)" end="(566, 72)">
          <NullNode start="(565, 33)" end="(565, 68)">
            <OtherNode start="(565, 33)" end="(565, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(565, 33)" end="(565, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(565, 34)" end="(565, 35)">
                <IdentNode start="(565, 34)" end="(565, 35)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(565, 35)" end="(565, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(565, 37)" end="(565, 54)">
              <AtomNode start="(565, 37)" end="(565, 38)" leading="" trailing="" val="("/>
              <NullNode start="(565, 38)" end="(565, 39)">
                <IdentNode start="(565, 38)" end="(565, 39)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(565, 40)" end="(565, 53)">
                <AtomNode start="(565, 40)" end="(565, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(565, 42)" end="(565, 53)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(565, 42)" end="(565, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(565, 44)" end="(565, 45)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(565, 46)" end="(565, 53)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(565, 46)" end="(565, 51)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(565, 52)" end="(565, 53)">
                      <IdentNode start="(565, 52)" end="(565, 53)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(565, 53)" end="(565, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(565, 55)" end="(565, 68)">
              <AtomNode start="(565, 55)" end="(565, 56)" leading="" trailing="" val="("/>
              <NullNode start="(565, 56)" end="(565, 58)">
                <IdentNode start="(565, 56)" end="(565, 58)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(565, 59)" end="(565, 67)">
                <AtomNode start="(565, 59)" end="(565, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(565, 61)" end="(565, 67)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(565, 61)" end="(565, 65)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(565, 66)" end="(565, 67)">
                    <IdentNode start="(565, 66)" end="(565, 67)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(565, 67)" end="(565, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(565, 69)" end="(566, 72)">
            <AtomNode start="(565, 69)" end="(565, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(566, 5)" end="(566, 72)" kind="«term_=_»">
              <OtherNode start="(566, 5)" end="(566, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(566, 5)" end="(566, 23)" leading="" trailing=" " raw_val="as.toArray.flatMap" val="as.toArray.flatMap"/>
                <NullNode start="(566, 24)" end="(566, 25)">
                  <IdentNode start="(566, 24)" end="(566, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(566, 26)" end="(566, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(566, 28)" end="(566, 72)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(566, 28)" end="(566, 64)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(566, 28)" end="(566, 29)" leading="" trailing="" val="("/>
                  <OtherNode start="(566, 29)" end="(566, 63)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(566, 29)" end="(566, 39)" leading="" trailing=" " raw_val="as.flatMap" val="as.flatMap"/>
                    <NullNode start="(566, 40)" end="(566, 63)">
                      <OtherNode start="(566, 40)" end="(566, 63)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(566, 40)" end="(566, 41)" leading="" trailing="" val="("/>
                        <OtherNode start="(566, 41)" end="(566, 62)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(566, 41)" end="(566, 44)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(566, 45)" end="(566, 62)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(566, 45)" end="(566, 46)">
                              <IdentNode start="(566, 45)" end="(566, 46)" leading="" trailing=" " raw_val="a" val="a"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(566, 47)" end="(566, 49)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(566, 50)" end="(566, 62)" kind="Lean.Parser.Term.proj">
                              <OtherNode start="(566, 50)" end="(566, 55)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(566, 50)" end="(566, 51)" leading="" trailing="" val="("/>
                                <OtherNode start="(566, 51)" end="(566, 54)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(566, 51)" end="(566, 52)" leading="" trailing=" " raw_val="f" val="f"/>
                                  <NullNode start="(566, 53)" end="(566, 54)">
                                    <IdentNode start="(566, 53)" end="(566, 54)" leading="" trailing="" raw_val="a" val="a"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(566, 54)" end="(566, 55)" leading="" trailing="" val=")"/>
                              </OtherNode>
                              <AtomNode start="(566, 55)" end="(566, 56)" leading="" trailing="" val="."/>
                              <IdentNode start="(566, 56)" end="(566, 62)" leading="" trailing="" raw_val="toList" val="toList" full_name="Array.toList" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(566, 62)" end="(566, 63)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(566, 63)" end="(566, 64)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(566, 64)" end="(566, 65)" leading="" trailing="" val="."/>
                <IdentNode start="(566, 65)" end="(566, 72)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(566, 73)" end="(571, 36)">
          <AtomNode start="(566, 73)" end="(566, 75)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(566, 76)" end="(571, 36)">
            <AtomNode start="(566, 76)" end="(566, 78)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(567, 3)" end="(571, 36)">
              <TacticTacticseq1IndentedNode start="(567, 3)" end="(571, 36)">
                <NullNode start="(567, 3)" end="(571, 36)">
                  <OtherNode start="(567, 3)" end="(571, 36)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;as : List α&#10;⊢ Array.flatMap f as.toArray = (flatMap (fun a =&amp;gt; (f a).toList) as).toArray" state_after="no goals" tactic="induction as with&#10;| nil =&amp;gt; simp&#10;| cons a as ih =&amp;gt;&#10;  apply ext'&#10;  simp [ih, flatMap_toArray_cons]">
                    <AtomNode start="(567, 3)" end="(567, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(567, 13)" end="(567, 15)">
                      <OtherNode start="(567, 13)" end="(567, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(567, 13)" end="(567, 15)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(567, 16)" end="(571, 36)">
                      <OtherNode start="(567, 16)" end="(571, 36)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(567, 16)" end="(567, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(568, 3)" end="(571, 36)">
                          <OtherNode start="(568, 3)" end="(568, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(568, 3)" end="(568, 8)">
                              <OtherNode start="(568, 3)" end="(568, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(568, 3)" end="(568, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(568, 5)" end="(568, 8)">
                                  <NullNode/>
                                  <IdentNode start="(568, 5)" end="(568, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(568, 9)" end="(568, 16)">
                              <AtomNode start="(568, 9)" end="(568, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(568, 12)" end="(568, 16)">
                                <TacticTacticseq1IndentedNode start="(568, 12)" end="(568, 16)">
                                  <NullNode start="(568, 12)" end="(568, 16)">
                                    <OtherNode start="(568, 12)" end="(568, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;⊢ Array.flatMap f #[] = (flatMap (fun a =&amp;gt; (f a).toList) []).toArray" state_after="no goals" tactic="simp">
                                      <AtomNode start="(568, 12)" end="(568, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(569, 3)" end="(571, 36)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(569, 3)" end="(569, 17)">
                              <OtherNode start="(569, 3)" end="(569, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(569, 3)" end="(569, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(569, 5)" end="(569, 9)">
                                  <NullNode/>
                                  <IdentNode start="(569, 5)" end="(569, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(569, 10)" end="(569, 17)">
                                  <IdentNode start="(569, 10)" end="(569, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(569, 12)" end="(569, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                                  <IdentNode start="(569, 15)" end="(569, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(569, 18)" end="(571, 36)">
                              <AtomNode start="(569, 18)" end="(569, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(570, 5)" end="(571, 36)">
                                <TacticTacticseq1IndentedNode start="(570, 5)" end="(571, 36)">
                                  <NullNode start="(570, 5)" end="(571, 36)">
                                    <OtherNode start="(570, 5)" end="(570, 15)" kind="Lean.Parser.Tactic.apply" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;a : α&#10;as : List α&#10;ih : Array.flatMap f as.toArray = (flatMap (fun a =&amp;gt; (f a).toList) as).toArray&#10;⊢ Array.flatMap f (a :: as).toArray = (flatMap (fun a =&amp;gt; (f a).toList) (a :: as)).toArray" state_after="case cons.h&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;a : α&#10;as : List α&#10;ih : Array.flatMap f as.toArray = (flatMap (fun a =&amp;gt; (f a).toList) as).toArray&#10;⊢ (Array.flatMap f (a :: as).toArray).toList = (flatMap (fun a =&amp;gt; (f a).toList) (a :: as)).toArray.toList" tactic="apply ext'">
                                      <AtomNode start="(570, 5)" end="(570, 10)" leading="" trailing=" " val="apply"/>
                                      <IdentNode start="(570, 11)" end="(570, 15)" leading="" trailing="&#10;    " raw_val="ext'" val="ext'" full_name="Array.ext'" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(571, 5)" end="(571, 36)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Array β&#10;a : α&#10;as : List α&#10;ih : Array.flatMap f as.toArray = (flatMap (fun a =&amp;gt; (f a).toList) as).toArray&#10;⊢ (Array.flatMap f (a :: as).toArray).toList = (flatMap (fun a =&amp;gt; (f a).toList) (a :: as)).toArray.toList" state_after="no goals" tactic="simp [ih, flatMap_toArray_cons]">
                                      <AtomNode start="(571, 5)" end="(571, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(571, 10)" end="(571, 36)">
                                        <AtomNode start="(571, 10)" end="(571, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(571, 11)" end="(571, 35)">
                                          <OtherNode start="(571, 11)" end="(571, 13)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(571, 11)" end="(571, 13)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(571, 13)" end="(571, 14)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(571, 15)" end="(571, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(571, 15)" end="(571, 35)" leading="" trailing="" raw_val="flatMap_toArray_cons" val="flatMap_toArray_cons" full_name="List.flatMap_toArray_cons" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(555, 9)" def_end="(555, 29)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(571, 35)" end="(571, 36)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(573, 1)" end="(576, 7)" name="swap_toArray" full_name="List.swap_toArray">
      <CommandDeclmodifiersNode start="(573, 1)" end="(573, 8)">
        <NullNode/>
        <NullNode start="(573, 1)" end="(573, 8)">
          <OtherNode start="(573, 1)" end="(573, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(573, 1)" end="(573, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(573, 3)" end="(573, 7)">
              <OtherNode start="(573, 3)" end="(573, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(573, 3)" end="(573, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(573, 3)" end="(573, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(573, 7)" end="(573, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(573, 9)" end="(576, 7)" name="swap_toArray" full_name="List.swap_toArray" _is_private_decl="False">
        <AtomNode start="(573, 9)" end="(573, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(573, 17)" end="(573, 29)">
          <IdentNode start="(573, 17)" end="(573, 29)" leading="" trailing=" " raw_val="swap_toArray" val="swap_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(573, 30)" end="(574, 67)">
          <NullNode start="(573, 30)" end="(573, 62)">
            <TermExplicitbinderNode start="(573, 30)" end="(573, 42)">
              <AtomNode start="(573, 30)" end="(573, 31)" leading="" trailing="" val="("/>
              <NullNode start="(573, 31)" end="(573, 32)">
                <IdentNode start="(573, 31)" end="(573, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(573, 33)" end="(573, 41)">
                <AtomNode start="(573, 33)" end="(573, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(573, 35)" end="(573, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(573, 35)" end="(573, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(573, 40)" end="(573, 41)">
                    <IdentNode start="(573, 40)" end="(573, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(573, 41)" end="(573, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(573, 43)" end="(573, 54)">
              <AtomNode start="(573, 43)" end="(573, 44)" leading="" trailing="" val="("/>
              <NullNode start="(573, 44)" end="(573, 47)">
                <IdentNode start="(573, 44)" end="(573, 45)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(573, 46)" end="(573, 47)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(573, 48)" end="(573, 53)">
                <AtomNode start="(573, 48)" end="(573, 49)" leading="" trailing=" " val=":"/>
                <IdentNode start="(573, 50)" end="(573, 53)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(573, 53)" end="(573, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(573, 55)" end="(573, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(573, 55)" end="(573, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(573, 56)" end="(573, 61)">
                <IdentNode start="(573, 56)" end="(573, 58)" leading="" trailing=" " raw_val="hi" val="hi"/>
                <IdentNode start="(573, 59)" end="(573, 61)" leading="" trailing="" raw_val="hj" val="hj"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(573, 61)" end="(573, 62)" leading="" trailing="" val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(573, 62)" end="(574, 67)">
            <AtomNode start="(573, 62)" end="(573, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(574, 5)" end="(574, 67)" kind="«term_=_»">
              <OtherNode start="(574, 5)" end="(574, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(574, 5)" end="(574, 19)" leading="" trailing=" " raw_val="l.toArray.swap" val="l.toArray.swap"/>
                <NullNode start="(574, 20)" end="(574, 29)">
                  <IdentNode start="(574, 20)" end="(574, 21)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(574, 22)" end="(574, 23)" leading="" trailing=" " raw_val="j" val="j"/>
                  <IdentNode start="(574, 24)" end="(574, 26)" leading="" trailing=" " raw_val="hi" val="hi"/>
                  <IdentNode start="(574, 27)" end="(574, 29)" leading="" trailing=" " raw_val="hj" val="hj"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(574, 30)" end="(574, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(574, 32)" end="(574, 67)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(574, 32)" end="(574, 59)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(574, 32)" end="(574, 33)" leading="" trailing="" val="("/>
                  <OtherNode start="(574, 33)" end="(574, 58)" kind="Lean.Parser.Term.app">
                    <OtherNode start="(574, 33)" end="(574, 51)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(574, 33)" end="(574, 47)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(574, 33)" end="(574, 34)" leading="" trailing="" val="("/>
                        <OtherNode start="(574, 34)" end="(574, 46)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(574, 34)" end="(574, 39)" leading="" trailing=" " raw_val="l.set" val="l.set"/>
                          <NullNode start="(574, 40)" end="(574, 46)">
                            <IdentNode start="(574, 40)" end="(574, 41)" leading="" trailing=" " raw_val="i" val="i"/>
                            <OtherNode start="(574, 42)" end="(574, 46)" kind="«term__[_]»">
                              <IdentNode start="(574, 42)" end="(574, 43)" leading="" trailing="" raw_val="l" val="l"/>
                              <AtomNode start="(574, 43)" end="(574, 44)" leading="" trailing="" val="["/>
                              <IdentNode start="(574, 44)" end="(574, 45)" leading="" trailing="" raw_val="j" val="j"/>
                              <AtomNode start="(574, 45)" end="(574, 46)" leading="" trailing="" val="]"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(574, 46)" end="(574, 47)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(574, 47)" end="(574, 48)" leading="" trailing="" val="."/>
                      <IdentNode start="(574, 48)" end="(574, 51)" leading="" trailing=" " raw_val="set" val="set" full_name="List.set" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <NullNode start="(574, 52)" end="(574, 58)">
                      <IdentNode start="(574, 52)" end="(574, 53)" leading="" trailing=" " raw_val="j" val="j"/>
                      <OtherNode start="(574, 54)" end="(574, 58)" kind="«term__[_]»">
                        <IdentNode start="(574, 54)" end="(574, 55)" leading="" trailing="" raw_val="l" val="l"/>
                        <AtomNode start="(574, 55)" end="(574, 56)" leading="" trailing="" val="["/>
                        <IdentNode start="(574, 56)" end="(574, 57)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(574, 57)" end="(574, 58)" leading="" trailing="" val="]"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(574, 58)" end="(574, 59)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(574, 59)" end="(574, 60)" leading="" trailing="" val="."/>
                <IdentNode start="(574, 60)" end="(574, 67)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(574, 68)" end="(576, 7)">
          <AtomNode start="(574, 68)" end="(574, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(574, 71)" end="(576, 7)">
            <AtomNode start="(574, 71)" end="(574, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(575, 3)" end="(576, 7)">
              <TacticTacticseq1IndentedNode start="(575, 3)" end="(576, 7)">
                <NullNode start="(575, 3)" end="(576, 7)">
                  <OtherNode start="(575, 3)" end="(575, 13)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;hi : i &amp;lt; l.toArray.size&#10;hj : j &amp;lt; l.toArray.size&#10;⊢ l.toArray.swap i j hi hj = ((l.set i l[j]).set j l[i]).toArray" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;hi : i &amp;lt; l.toArray.size&#10;hj : j &amp;lt; l.toArray.size&#10;⊢ (l.toArray.swap i j hi hj).toList = ((l.set i l[j]).set j l[i]).toArray.toList" tactic="apply ext'">
                    <AtomNode start="(575, 3)" end="(575, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(575, 9)" end="(575, 13)" leading="" trailing="&#10;  " raw_val="ext'" val="ext'" full_name="Array.ext'" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(576, 3)" end="(576, 7)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;hi : i &amp;lt; l.toArray.size&#10;hj : j &amp;lt; l.toArray.size&#10;⊢ (l.toArray.swap i j hi hj).toList = ((l.set i l[j]).set j l[i]).toArray.toList" state_after="no goals" tactic="simp">
                    <AtomNode start="(576, 3)" end="(576, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(578, 1)" end="(594, 8)" name="eraseIdx_toArray" full_name="List.eraseIdx_toArray">
      <CommandDeclmodifiersNode start="(578, 1)" end="(578, 8)">
        <NullNode/>
        <NullNode start="(578, 1)" end="(578, 8)">
          <OtherNode start="(578, 1)" end="(578, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(578, 1)" end="(578, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(578, 3)" end="(578, 7)">
              <OtherNode start="(578, 3)" end="(578, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(578, 3)" end="(578, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(578, 3)" end="(578, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(578, 7)" end="(578, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(578, 9)" end="(594, 8)" name="eraseIdx_toArray" full_name="List.eraseIdx_toArray" _is_private_decl="False">
        <AtomNode start="(578, 9)" end="(578, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(578, 17)" end="(578, 33)">
          <IdentNode start="(578, 17)" end="(578, 33)" leading="" trailing=" " raw_val="eraseIdx_toArray" val="eraseIdx_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(578, 34)" end="(579, 52)">
          <NullNode start="(578, 34)" end="(578, 81)">
            <TermExplicitbinderNode start="(578, 34)" end="(578, 46)">
              <AtomNode start="(578, 34)" end="(578, 35)" leading="" trailing="" val="("/>
              <NullNode start="(578, 35)" end="(578, 36)">
                <IdentNode start="(578, 35)" end="(578, 36)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(578, 37)" end="(578, 45)">
                <AtomNode start="(578, 37)" end="(578, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(578, 39)" end="(578, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(578, 39)" end="(578, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(578, 44)" end="(578, 45)">
                    <IdentNode start="(578, 44)" end="(578, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(578, 45)" end="(578, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(578, 47)" end="(578, 56)">
              <AtomNode start="(578, 47)" end="(578, 48)" leading="" trailing="" val="("/>
              <NullNode start="(578, 48)" end="(578, 49)">
                <IdentNode start="(578, 48)" end="(578, 49)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(578, 50)" end="(578, 55)">
                <AtomNode start="(578, 50)" end="(578, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(578, 52)" end="(578, 55)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(578, 55)" end="(578, 56)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(578, 57)" end="(578, 81)">
              <AtomNode start="(578, 57)" end="(578, 58)" leading="" trailing="" val="("/>
              <NullNode start="(578, 58)" end="(578, 59)">
                <IdentNode start="(578, 58)" end="(578, 59)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(578, 60)" end="(578, 80)">
                <AtomNode start="(578, 60)" end="(578, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(578, 62)" end="(578, 80)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(578, 62)" end="(578, 63)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(578, 64)" end="(578, 65)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(578, 66)" end="(578, 80)" leading="" trailing="" raw_val="l.toArray.size" val="l.toArray.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(578, 80)" end="(578, 81)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(578, 82)" end="(579, 52)">
            <AtomNode start="(578, 82)" end="(578, 83)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(579, 5)" end="(579, 52)" kind="«term_=_»">
              <OtherNode start="(579, 5)" end="(579, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(579, 5)" end="(579, 23)" leading="" trailing=" " raw_val="l.toArray.eraseIdx" val="l.toArray.eraseIdx"/>
                <NullNode start="(579, 24)" end="(579, 27)">
                  <IdentNode start="(579, 24)" end="(579, 25)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(579, 26)" end="(579, 27)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(579, 28)" end="(579, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(579, 30)" end="(579, 52)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(579, 30)" end="(579, 44)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(579, 30)" end="(579, 31)" leading="" trailing="" val="("/>
                  <OtherNode start="(579, 31)" end="(579, 43)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(579, 31)" end="(579, 41)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                    <NullNode start="(579, 42)" end="(579, 43)">
                      <IdentNode start="(579, 42)" end="(579, 43)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(579, 43)" end="(579, 44)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(579, 44)" end="(579, 45)" leading="" trailing="" val="."/>
                <IdentNode start="(579, 45)" end="(579, 52)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(579, 53)" end="(594, 8)">
          <AtomNode start="(579, 53)" end="(579, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(579, 56)" end="(588, 13)">
            <AtomNode start="(579, 56)" end="(579, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(580, 3)" end="(588, 13)">
              <TacticTacticseq1IndentedNode start="(580, 3)" end="(588, 13)">
                <NullNode start="(580, 3)" end="(588, 13)">
                  <OtherNode start="(580, 3)" end="(580, 22)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;⊢ l.toArray.eraseIdx i h = (l.eraseIdx i).toArray" state_after="α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;⊢ (if h' : i + 1 &amp;lt; l.toArray.size then&#10;      let xs' := l.toArray.swap (i + 1) i h' h;&#10;      xs'.eraseIdx (i + 1) ⋯&#10;    else l.toArray.pop) =&#10;    (l.eraseIdx i).toArray" tactic="rw [Array.eraseIdx]">
                    <AtomNode start="(580, 3)" end="(580, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(580, 6)" end="(580, 22)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(580, 6)" end="(580, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(580, 7)" end="(580, 21)">
                        <OtherNode start="(580, 7)" end="(580, 21)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(580, 7)" end="(580, 21)" leading="" trailing="" raw_val="Array.eraseIdx" val="Array.eraseIdx" full_name="Array.eraseIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(580, 21)" end="(580, 22)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(581, 3)" end="(581, 24)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;⊢ (if h' : i + 1 &amp;lt; l.toArray.size then&#10;      let xs' := l.toArray.swap (i + 1) i h' h;&#10;      xs'.eraseIdx (i + 1) ⋯&#10;    else l.toArray.pop) =&#10;    (l.eraseIdx i).toArray" state_after="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : i + 1 &amp;lt; l.toArray.size&#10;⊢ (let xs' := l.toArray.swap (i + 1) i h' h;&#10;    xs'.eraseIdx (i + 1) ⋯) =&#10;    (l.eraseIdx i).toArray&#10;&#10;case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : ¬i + 1 &amp;lt; l.toArray.size&#10;⊢ l.toArray.pop = (l.eraseIdx i).toArray" tactic="split &amp;lt;;&amp;gt; rename_i h'">
                    <OtherNode start="(581, 3)" end="(581, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(581, 3)" end="(581, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(581, 9)" end="(581, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(581, 13)" end="(581, 24)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(581, 13)" end="(581, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(581, 22)" end="(581, 24)">
                        <LeanBinderidentNode start="(581, 22)" end="(581, 24)">
                          <IdentNode start="(581, 22)" end="(581, 24)" leading="" trailing="&#10;  " raw_val="h'" val="h'"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(582, 3)" end="(585, 9)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : i + 1 &amp;lt; l.toArray.size&#10;⊢ (let xs' := l.toArray.swap (i + 1) i h' h;&#10;    xs'.eraseIdx (i + 1) ⋯) =&#10;    (l.eraseIdx i).toArray&#10;&#10;case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : ¬i + 1 &amp;lt; l.toArray.size&#10;⊢ l.toArray.pop = (l.eraseIdx i).toArray" state_after="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : ¬i + 1 &amp;lt; l.toArray.size&#10;⊢ l.toArray.pop = (l.eraseIdx i).toArray" tactic="· rw [eraseIdx_toArray]&#10;  simp only [swap_toArray, Fin.getElem_fin, toList_toArray, mk.injEq]&#10;  rw [eraseIdx_set_gt (by simp), eraseIdx_set_eq]&#10;  simp">
                    <OtherNode start="(582, 3)" end="(582, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(582, 3)" end="(582, 4)" kind="patternIgnore">
                        <OtherNode start="(582, 3)" end="(582, 4)" kind="token.«· »">
                          <AtomNode start="(582, 3)" end="(582, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(582, 5)" end="(585, 9)">
                      <TacticTacticseq1IndentedNode start="(582, 5)" end="(585, 9)">
                        <NullNode start="(582, 5)" end="(585, 9)">
                          <OtherNode start="(582, 5)" end="(582, 26)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : i + 1 &amp;lt; l.toArray.size&#10;⊢ (let xs' := l.toArray.swap (i + 1) i h' h;&#10;    xs'.eraseIdx (i + 1) ⋯) =&#10;    (l.eraseIdx i).toArray" state_after="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : i + 1 &amp;lt; l.toArray.size&#10;⊢ ((l.toArray.swap (i + 1) i h' h).toList.eraseIdx (i + 1)).toArray = (l.eraseIdx i).toArray" tactic="rw [eraseIdx_toArray]">
                            <AtomNode start="(582, 5)" end="(582, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(582, 8)" end="(582, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(582, 8)" end="(582, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(582, 9)" end="(582, 25)">
                                <OtherNode start="(582, 9)" end="(582, 25)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(582, 9)" end="(582, 25)" leading="" trailing="" raw_val="eraseIdx_toArray" val="eraseIdx_toArray"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(582, 25)" end="(582, 26)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(583, 5)" end="(583, 72)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : i + 1 &amp;lt; l.toArray.size&#10;⊢ ((l.toArray.swap (i + 1) i h' h).toList.eraseIdx (i + 1)).toArray = (l.eraseIdx i).toArray" state_after="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : i + 1 &amp;lt; l.toArray.size&#10;⊢ ((l.set (i + 1) l[i]).set i l[i + 1]).eraseIdx (i + 1) = l.eraseIdx i" tactic="simp only [swap_toArray, Fin.getElem_fin, toList_toArray, mk.injEq]">
                            <AtomNode start="(583, 5)" end="(583, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(583, 10)" end="(583, 14)">
                              <AtomNode start="(583, 10)" end="(583, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(583, 15)" end="(583, 72)">
                              <AtomNode start="(583, 15)" end="(583, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(583, 16)" end="(583, 71)">
                                <OtherNode start="(583, 16)" end="(583, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(583, 16)" end="(583, 28)" leading="" trailing="" raw_val="swap_toArray" val="swap_toArray" full_name="List.swap_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(573, 17)" def_end="(573, 29)"/>
                                </OtherNode>
                                <AtomNode start="(583, 28)" end="(583, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(583, 30)" end="(583, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(583, 30)" end="(583, 45)" leading="" trailing="" raw_val="Fin.getElem_fin" val="Fin.getElem_fin" full_name="Fin.getElem_fin" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                </OtherNode>
                                <AtomNode start="(583, 45)" end="(583, 46)" leading="" trailing=" " val=","/>
                                <OtherNode start="(583, 47)" end="(583, 61)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(583, 47)" end="(583, 61)" leading="" trailing="" raw_val="toList_toArray" val="toList_toArray" full_name="List.toList_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(583, 61)" end="(583, 62)" leading="" trailing=" " val=","/>
                                <OtherNode start="(583, 63)" end="(583, 71)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(583, 63)" end="(583, 71)" leading="" trailing="" raw_val="mk.injEq" val="mk.injEq" full_name="Array.mk.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(583, 71)" end="(583, 72)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(584, 5)" end="(584, 52)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : i + 1 &amp;lt; l.toArray.size&#10;⊢ ((l.set (i + 1) l[i]).set i l[i + 1]).eraseIdx (i + 1) = l.eraseIdx i" state_after="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : i + 1 &amp;lt; l.toArray.size&#10;⊢ (l.eraseIdx (i + 1)).set i l[i + 1] = l.eraseIdx i" tactic="rw [eraseIdx_set_gt (by simp), eraseIdx_set_eq]">
                            <AtomNode start="(584, 5)" end="(584, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(584, 8)" end="(584, 52)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(584, 8)" end="(584, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(584, 9)" end="(584, 51)">
                                <OtherNode start="(584, 9)" end="(584, 34)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(584, 9)" end="(584, 34)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(584, 9)" end="(584, 24)" leading="" trailing=" " raw_val="eraseIdx_set_gt" val="eraseIdx_set_gt" full_name="List.eraseIdx_set_gt" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean"/>
                                    <NullNode start="(584, 25)" end="(584, 34)">
                                      <OtherNode start="(584, 25)" end="(584, 34)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(584, 25)" end="(584, 26)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(584, 26)" end="(584, 33)">
                                          <AtomNode start="(584, 26)" end="(584, 28)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(584, 29)" end="(584, 33)">
                                            <TacticTacticseq1IndentedNode start="(584, 29)" end="(584, 33)">
                                              <NullNode start="(584, 29)" end="(584, 33)">
                                                <OtherNode start="(584, 29)" end="(584, 33)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : i + 1 &amp;lt; l.toArray.size&#10;⊢ i &amp;lt; i + 1" state_after="no goals" tactic="simp">
                                                  <AtomNode start="(584, 29)" end="(584, 33)" leading="" trailing="" val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(584, 33)" end="(584, 34)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(584, 34)" end="(584, 35)" leading="" trailing=" " val=","/>
                                <OtherNode start="(584, 36)" end="(584, 51)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(584, 36)" end="(584, 51)" leading="" trailing="" raw_val="eraseIdx_set_eq" val="eraseIdx_set_eq" full_name="List.eraseIdx_set_eq" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(584, 51)" end="(584, 52)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(585, 5)" end="(585, 9)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : i + 1 &amp;lt; l.toArray.size&#10;⊢ (l.eraseIdx (i + 1)).set i l[i + 1] = l.eraseIdx i" state_after="no goals" tactic="simp">
                            <AtomNode start="(585, 5)" end="(585, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(586, 3)" end="(588, 13)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : ¬i + 1 &amp;lt; l.toArray.size&#10;⊢ l.toArray.pop = (l.eraseIdx i).toArray" state_after="no goals" tactic="· simp at h h'&#10;  have t : i = l.length - 1 := by omega&#10;  simp [t]">
                    <OtherNode start="(586, 3)" end="(586, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(586, 3)" end="(586, 4)" kind="patternIgnore">
                        <OtherNode start="(586, 3)" end="(586, 4)" kind="token.«· »">
                          <AtomNode start="(586, 3)" end="(586, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(586, 5)" end="(588, 13)">
                      <TacticTacticseq1IndentedNode start="(586, 5)" end="(588, 13)">
                        <NullNode start="(586, 5)" end="(588, 13)">
                          <OtherNode start="(586, 5)" end="(586, 17)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;h' : ¬i + 1 &amp;lt; l.toArray.size&#10;⊢ l.toArray.pop = (l.eraseIdx i).toArray" state_after="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;h' : l.length ≤ i + 1&#10;⊢ l.toArray.pop = (l.eraseIdx i).toArray" tactic="simp at h h'">
                            <AtomNode start="(586, 5)" end="(586, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(586, 10)" end="(586, 17)">
                              <OtherNode start="(586, 10)" end="(586, 17)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(586, 10)" end="(586, 12)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(586, 13)" end="(586, 17)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(586, 13)" end="(586, 17)">
                                    <IdentNode start="(586, 13)" end="(586, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                    <IdentNode start="(586, 15)" end="(586, 17)" leading="" trailing="&#10;    " raw_val="h'" val="h'"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(587, 5)" end="(587, 42)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;h' : l.length ≤ i + 1&#10;⊢ l.toArray.pop = (l.eraseIdx i).toArray" state_after="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;h' : l.length ≤ i + 1&#10;t : i = l.length - 1&#10;⊢ l.toArray.pop = (l.eraseIdx i).toArray" tactic="have t : i = l.length - 1 := by omega">
                            <AtomNode start="(587, 5)" end="(587, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(587, 10)" end="(587, 42)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(587, 10)" end="(587, 42)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(587, 10)" end="(587, 11)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(587, 10)" end="(587, 11)" leading="" trailing=" " raw_val="t" val="t"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(587, 12)" end="(587, 30)">
                                  <TermTypespecNode start="(587, 12)" end="(587, 30)">
                                    <AtomNode start="(587, 12)" end="(587, 13)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(587, 14)" end="(587, 30)" kind="«term_=_»">
                                      <IdentNode start="(587, 14)" end="(587, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                                      <AtomNode start="(587, 16)" end="(587, 17)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(587, 18)" end="(587, 30)" kind="«term_-_»">
                                        <IdentNode start="(587, 18)" end="(587, 26)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                        <AtomNode start="(587, 27)" end="(587, 28)" leading="" trailing=" " val="-"/>
                                        <OtherNode start="(587, 29)" end="(587, 30)" kind="num">
                                          <AtomNode start="(587, 29)" end="(587, 30)" leading="" trailing=" " val="1"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(587, 31)" end="(587, 33)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(587, 34)" end="(587, 42)">
                                  <AtomNode start="(587, 34)" end="(587, 36)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(587, 37)" end="(587, 42)">
                                    <TacticTacticseq1IndentedNode start="(587, 37)" end="(587, 42)">
                                      <NullNode start="(587, 37)" end="(587, 42)">
                                        <OtherNode start="(587, 37)" end="(587, 42)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;h' : l.length ≤ i + 1&#10;⊢ i = l.length - 1" state_after="no goals" tactic="omega">
                                          <AtomNode start="(587, 37)" end="(587, 42)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(588, 5)" end="(588, 13)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;h' : l.length ≤ i + 1&#10;t : i = l.length - 1&#10;⊢ l.toArray.pop = (l.eraseIdx i).toArray" state_after="no goals" tactic="simp [t]">
                            <AtomNode start="(588, 5)" end="(588, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(588, 10)" end="(588, 13)">
                              <AtomNode start="(588, 10)" end="(588, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(588, 11)" end="(588, 12)">
                                <OtherNode start="(588, 11)" end="(588, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(588, 11)" end="(588, 12)" leading="" trailing="" raw_val="t" val="t"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(588, 12)" end="(588, 13)" leading="" trailing="&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode start="(589, 1)" end="(594, 8)" kind="Lean.Parser.Termination.suffix">
            <NullNode start="(589, 1)" end="(589, 28)">
              <OtherNode start="(589, 1)" end="(589, 28)" kind="Lean.Parser.Termination.terminationBy">
                <AtomNode start="(589, 1)" end="(589, 15)" leading="" trailing=" " val="termination_by"/>
                <NullNode/>
                <NullNode/>
                <OtherNode start="(589, 16)" end="(589, 28)" kind="«term_-_»">
                  <IdentNode start="(589, 16)" end="(589, 24)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                  <AtomNode start="(589, 25)" end="(589, 26)" leading="" trailing=" " val="-"/>
                  <IdentNode start="(589, 27)" end="(589, 28)" leading="" trailing="&#10;" raw_val="i" val="i"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <NullNode start="(590, 1)" end="(594, 8)">
              <OtherNode start="(590, 1)" end="(594, 8)" kind="Lean.Parser.Termination.decreasingBy">
                <AtomNode start="(590, 1)" end="(590, 14)" leading="" trailing="&#10;  " val="decreasing_by"/>
                <TacticTacticseqNode start="(591, 3)" end="(594, 8)">
                  <TacticTacticseq1IndentedNode start="(591, 3)" end="(594, 8)">
                    <NullNode start="(591, 3)" end="(594, 8)">
                      <OtherNode start="(591, 3)" end="(591, 13)" kind="Lean.Parser.Tactic.renameI" state_before="α : Type u_1&#10;_x : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size&#10;a✝² :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y _x →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;l : List α&#10;i✝ : (i : Nat) ×' i &amp;lt; l.toArray.size&#10;a✝¹ :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y ⟨l, i✝⟩ →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;i : Nat&#10;h : i &amp;lt; l.toArray.size&#10;a✝ :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y ⟨l, ⟨i, h⟩⟩ →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;h✝ : i + 1 &amp;lt; l.toArray.size&#10;⊢ (l.toArray.swap (i + 1) i h✝ h).toList.length - (i + 1) &amp;lt; l.length - i" state_after="α : Type u_1&#10;_x : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size&#10;a✝² :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y _x →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;l : List α&#10;i✝ : (i : Nat) ×' i &amp;lt; l.toArray.size&#10;a✝¹ :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y ⟨l, i✝⟩ →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;i : Nat&#10;h✝ : i &amp;lt; l.toArray.size&#10;a✝ :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y ⟨l, ⟨i, h✝⟩⟩ →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;h : i + 1 &amp;lt; l.toArray.size&#10;⊢ (l.toArray.swap (i + 1) i h h✝).toList.length - (i + 1) &amp;lt; l.length - i" tactic="rename_i h">
                        <AtomNode start="(591, 3)" end="(591, 11)" leading="" trailing=" " val="rename_i"/>
                        <NullNode start="(591, 12)" end="(591, 13)">
                          <LeanBinderidentNode start="(591, 12)" end="(591, 13)">
                            <IdentNode start="(591, 12)" end="(591, 13)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </LeanBinderidentNode>
                        </NullNode>
                      </OtherNode>
                      <NullNode/>
                      <OtherNode start="(592, 3)" end="(592, 12)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;_x : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size&#10;a✝² :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y _x →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;l : List α&#10;i✝ : (i : Nat) ×' i &amp;lt; l.toArray.size&#10;a✝¹ :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y ⟨l, i✝⟩ →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;i : Nat&#10;h✝ : i &amp;lt; l.toArray.size&#10;a✝ :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y ⟨l, ⟨i, h✝⟩⟩ →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;h : i + 1 &amp;lt; l.toArray.size&#10;⊢ (l.toArray.swap (i + 1) i h h✝).toList.length - (i + 1) &amp;lt; l.length - i" state_after="α : Type u_1&#10;_x : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size&#10;a✝² :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y _x →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;l : List α&#10;i✝ : (i : Nat) ×' i &amp;lt; l.toArray.size&#10;a✝¹ :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y ⟨l, i✝⟩ →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;i : Nat&#10;h✝¹ : i &amp;lt; l.toArray.size&#10;a✝ :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y ⟨l, ⟨i, h✝¹⟩⟩ →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;h✝ : i + 1 &amp;lt; l.toArray.size&#10;h : i + 1 &amp;lt; l.length&#10;⊢ (l.toArray.swap (i + 1) i h✝ h✝¹).toList.length - (i + 1) &amp;lt; l.length - i" tactic="simp at h">
                        <AtomNode start="(592, 3)" end="(592, 7)" leading="" trailing=" " val="simp"/>
                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                          <NullNode/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <NullNode/>
                        <NullNode start="(592, 8)" end="(592, 12)">
                          <OtherNode start="(592, 8)" end="(592, 12)" kind="Lean.Parser.Tactic.location">
                            <AtomNode start="(592, 8)" end="(592, 10)" leading="" trailing=" " val="at"/>
                            <OtherNode start="(592, 11)" end="(592, 12)" kind="Lean.Parser.Tactic.locationHyp">
                              <NullNode start="(592, 11)" end="(592, 12)">
                                <IdentNode start="(592, 11)" end="(592, 12)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <NullNode/>
                      <OtherNode start="(593, 3)" end="(593, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;_x : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size&#10;a✝² :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y _x →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;l : List α&#10;i✝ : (i : Nat) ×' i &amp;lt; l.toArray.size&#10;a✝¹ :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y ⟨l, i✝⟩ →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;i : Nat&#10;h✝¹ : i &amp;lt; l.toArray.size&#10;a✝ :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y ⟨l, ⟨i, h✝¹⟩⟩ →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;h✝ : i + 1 &amp;lt; l.toArray.size&#10;h : i + 1 &amp;lt; l.length&#10;⊢ (l.toArray.swap (i + 1) i h✝ h✝¹).toList.length - (i + 1) &amp;lt; l.length - i" state_after="α : Type u_1&#10;_x : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size&#10;a✝² :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y _x →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;l : List α&#10;i✝ : (i : Nat) ×' i &amp;lt; l.toArray.size&#10;a✝¹ :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y ⟨l, i✝⟩ →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;i : Nat&#10;h✝¹ : i &amp;lt; l.toArray.size&#10;a✝ :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y ⟨l, ⟨i, h✝¹⟩⟩ →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;h✝ : i + 1 &amp;lt; l.toArray.size&#10;h : i + 1 &amp;lt; l.length&#10;⊢ l.length - (i + 1) &amp;lt; l.length - i" tactic="simp">
                        <AtomNode start="(593, 3)" end="(593, 7)" leading="" trailing="&#10;  " val="simp"/>
                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                          <NullNode/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <OtherNode start="(594, 3)" end="(594, 8)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;_x : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size&#10;a✝² :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y _x →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;l : List α&#10;i✝ : (i : Nat) ×' i &amp;lt; l.toArray.size&#10;a✝¹ :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y ⟨l, i✝⟩ →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;i : Nat&#10;h✝¹ : i &amp;lt; l.toArray.size&#10;a✝ :&#10;  ∀ (y : (l : List α) ×' (i : Nat) ×' i &amp;lt; l.toArray.size),&#10;    (invImage (fun x =&amp;gt; PSigma.casesOn x fun l i =&amp;gt; PSigma.casesOn i fun i h =&amp;gt; l.length - i)&#10;            instWellFoundedRelationOfSizeOf).1&#10;        y ⟨l, ⟨i, h✝¹⟩⟩ →&#10;      y.1.toArray.eraseIdx y.2.1 ⋯ = (y.1.eraseIdx y.2.1).toArray&#10;h✝ : i + 1 &amp;lt; l.toArray.size&#10;h : i + 1 &amp;lt; l.length&#10;⊢ l.length - (i + 1) &amp;lt; l.length - i" state_after="no goals" tactic="omega">
                        <AtomNode start="(594, 3)" end="(594, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                          <NullNode/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </TacticTacticseq1IndentedNode>
                </TacticTacticseqNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(596, 1)" end="(601, 34)" name="eraseIdxIfInBounds_toArray" full_name="List.eraseIdxIfInBounds_toArray">
      <CommandDeclmodifiersNode start="(596, 1)" end="(596, 8)">
        <NullNode/>
        <NullNode start="(596, 1)" end="(596, 8)">
          <OtherNode start="(596, 1)" end="(596, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(596, 1)" end="(596, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(596, 3)" end="(596, 7)">
              <OtherNode start="(596, 3)" end="(596, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(596, 3)" end="(596, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(596, 3)" end="(596, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(596, 7)" end="(596, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(596, 9)" end="(601, 34)" name="eraseIdxIfInBounds_toArray" full_name="List.eraseIdxIfInBounds_toArray" _is_private_decl="False">
        <AtomNode start="(596, 9)" end="(596, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(596, 17)" end="(596, 43)">
          <IdentNode start="(596, 17)" end="(596, 43)" leading="" trailing=" " raw_val="eraseIdxIfInBounds_toArray" val="eraseIdxIfInBounds_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(596, 44)" end="(597, 60)">
          <NullNode start="(596, 44)" end="(596, 66)">
            <TermExplicitbinderNode start="(596, 44)" end="(596, 56)">
              <AtomNode start="(596, 44)" end="(596, 45)" leading="" trailing="" val="("/>
              <NullNode start="(596, 45)" end="(596, 46)">
                <IdentNode start="(596, 45)" end="(596, 46)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(596, 47)" end="(596, 55)">
                <AtomNode start="(596, 47)" end="(596, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(596, 49)" end="(596, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(596, 49)" end="(596, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(596, 54)" end="(596, 55)">
                    <IdentNode start="(596, 54)" end="(596, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(596, 55)" end="(596, 56)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(596, 57)" end="(596, 66)">
              <AtomNode start="(596, 57)" end="(596, 58)" leading="" trailing="" val="("/>
              <NullNode start="(596, 58)" end="(596, 59)">
                <IdentNode start="(596, 58)" end="(596, 59)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(596, 60)" end="(596, 65)">
                <AtomNode start="(596, 60)" end="(596, 61)" leading="" trailing=" " val=":"/>
                <IdentNode start="(596, 62)" end="(596, 65)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(596, 65)" end="(596, 66)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(596, 67)" end="(597, 60)">
            <AtomNode start="(596, 67)" end="(596, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(597, 5)" end="(597, 60)" kind="«term_=_»">
              <OtherNode start="(597, 5)" end="(597, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(597, 5)" end="(597, 33)" leading="" trailing=" " raw_val="l.toArray.eraseIdxIfInBounds" val="l.toArray.eraseIdxIfInBounds"/>
                <NullNode start="(597, 34)" end="(597, 35)">
                  <IdentNode start="(597, 34)" end="(597, 35)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(597, 36)" end="(597, 37)" leading="" trailing=" " val="="/>
              <OtherNode start="(597, 38)" end="(597, 60)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(597, 38)" end="(597, 52)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(597, 38)" end="(597, 39)" leading="" trailing="" val="("/>
                  <OtherNode start="(597, 39)" end="(597, 51)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(597, 39)" end="(597, 49)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                    <NullNode start="(597, 50)" end="(597, 51)">
                      <IdentNode start="(597, 50)" end="(597, 51)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(597, 51)" end="(597, 52)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(597, 52)" end="(597, 53)" leading="" trailing="" val="."/>
                <IdentNode start="(597, 53)" end="(597, 60)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(597, 61)" end="(601, 34)">
          <AtomNode start="(597, 61)" end="(597, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(597, 64)" end="(601, 34)">
            <AtomNode start="(597, 64)" end="(597, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(598, 3)" end="(601, 34)">
              <TacticTacticseq1IndentedNode start="(598, 3)" end="(601, 34)">
                <NullNode start="(598, 3)" end="(601, 34)">
                  <OtherNode start="(598, 3)" end="(598, 32)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ l.toArray.eraseIdxIfInBounds i = (l.eraseIdx i).toArray" state_after="α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ (if h : i &amp;lt; l.toArray.size then l.toArray.eraseIdx i h else l.toArray) = (l.eraseIdx i).toArray" tactic="rw [Array.eraseIdxIfInBounds]">
                    <AtomNode start="(598, 3)" end="(598, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(598, 6)" end="(598, 32)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(598, 6)" end="(598, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(598, 7)" end="(598, 31)">
                        <OtherNode start="(598, 7)" end="(598, 31)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(598, 7)" end="(598, 31)" leading="" trailing="" raw_val="Array.eraseIdxIfInBounds" val="Array.eraseIdxIfInBounds" full_name="Array.eraseIdxIfInBounds" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(598, 31)" end="(598, 32)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(599, 3)" end="(599, 8)" kind="Lean.Parser.Tactic.split" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ (if h : i &amp;lt; l.toArray.size then l.toArray.eraseIdx i h else l.toArray) = (l.eraseIdx i).toArray" state_after="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h✝ : i &amp;lt; l.toArray.size&#10;⊢ l.toArray.eraseIdx i h✝ = (l.eraseIdx i).toArray&#10;&#10;case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h✝ : ¬i &amp;lt; l.toArray.size&#10;⊢ l.toArray = (l.eraseIdx i).toArray" tactic="split">
                    <AtomNode start="(599, 3)" end="(599, 8)" leading="" trailing="&#10;  " val="split"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(600, 3)" end="(600, 9)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h✝ : i &amp;lt; l.toArray.size&#10;⊢ l.toArray.eraseIdx i h✝ = (l.eraseIdx i).toArray&#10;&#10;case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h✝ : ¬i &amp;lt; l.toArray.size&#10;⊢ l.toArray = (l.eraseIdx i).toArray" state_after="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h✝ : ¬i &amp;lt; l.toArray.size&#10;⊢ l.toArray = (l.eraseIdx i).toArray" tactic="· simp">
                    <OtherNode start="(600, 3)" end="(600, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(600, 3)" end="(600, 4)" kind="patternIgnore">
                        <OtherNode start="(600, 3)" end="(600, 4)" kind="token.«· »">
                          <AtomNode start="(600, 3)" end="(600, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(600, 5)" end="(600, 9)">
                      <TacticTacticseq1IndentedNode start="(600, 5)" end="(600, 9)">
                        <NullNode start="(600, 5)" end="(600, 9)">
                          <OtherNode start="(600, 5)" end="(600, 9)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h✝ : i &amp;lt; l.toArray.size&#10;⊢ l.toArray.eraseIdx i h✝ = (l.eraseIdx i).toArray" state_after="no goals" tactic="simp">
                            <AtomNode start="(600, 5)" end="(600, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(601, 3)" end="(601, 34)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h✝ : ¬i &amp;lt; l.toArray.size&#10;⊢ l.toArray = (l.eraseIdx i).toArray" state_after="no goals" tactic="· simp_all [eraseIdx_eq_self.2]">
                    <OtherNode start="(601, 3)" end="(601, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(601, 3)" end="(601, 4)" kind="patternIgnore">
                        <OtherNode start="(601, 3)" end="(601, 4)" kind="token.«· »">
                          <AtomNode start="(601, 3)" end="(601, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(601, 5)" end="(601, 34)">
                      <TacticTacticseq1IndentedNode start="(601, 5)" end="(601, 34)">
                        <NullNode start="(601, 5)" end="(601, 34)">
                          <OtherNode start="(601, 5)" end="(601, 34)" kind="Lean.Parser.Tactic.simpAll" state_before="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h✝ : ¬i &amp;lt; l.toArray.size&#10;⊢ l.toArray = (l.eraseIdx i).toArray" state_after="no goals" tactic="simp_all [eraseIdx_eq_self.2]">
                            <AtomNode start="(601, 5)" end="(601, 13)" leading="" trailing=" " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(601, 14)" end="(601, 34)">
                              <AtomNode start="(601, 14)" end="(601, 15)" leading="" trailing="" val="["/>
                              <NullNode start="(601, 15)" end="(601, 33)">
                                <OtherNode start="(601, 15)" end="(601, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(601, 15)" end="(601, 33)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(601, 15)" end="(601, 31)" leading="" trailing="" raw_val="eraseIdx_eq_self" val="eraseIdx_eq_self" full_name="List.eraseIdx_eq_self" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                                    <AtomNode start="(601, 31)" end="(601, 32)" leading="" trailing="" val="."/>
                                    <OtherNode start="(601, 32)" end="(601, 33)" kind="fieldIdx">
                                      <AtomNode start="(601, 32)" end="(601, 33)" leading="" trailing="" val="2"/>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(601, 33)" end="(601, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(603, 1)" end="(606, 54)" name="eraseP_toArray" full_name="List.eraseP_toArray">
      <CommandDeclmodifiersNode start="(603, 1)" end="(603, 8)">
        <NullNode/>
        <NullNode start="(603, 1)" end="(603, 8)">
          <OtherNode start="(603, 1)" end="(603, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(603, 1)" end="(603, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(603, 3)" end="(603, 7)">
              <OtherNode start="(603, 3)" end="(603, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(603, 3)" end="(603, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(603, 3)" end="(603, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(603, 7)" end="(603, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(603, 9)" end="(606, 54)" name="eraseP_toArray" full_name="List.eraseP_toArray" _is_private_decl="False">
        <AtomNode start="(603, 9)" end="(603, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(603, 17)" end="(603, 31)">
          <IdentNode start="(603, 17)" end="(603, 31)" leading="" trailing=" " raw_val="eraseP_toArray" val="eraseP_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(603, 32)" end="(604, 48)">
          <NullNode start="(603, 32)" end="(603, 60)">
            <OtherNode start="(603, 32)" end="(603, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(603, 32)" end="(603, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(603, 33)" end="(603, 35)">
                <IdentNode start="(603, 33)" end="(603, 35)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(603, 36)" end="(603, 44)">
                <AtomNode start="(603, 36)" end="(603, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(603, 38)" end="(603, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(603, 38)" end="(603, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(603, 43)" end="(603, 44)">
                    <IdentNode start="(603, 43)" end="(603, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(603, 44)" end="(603, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(603, 46)" end="(603, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(603, 46)" end="(603, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(603, 47)" end="(603, 48)">
                <IdentNode start="(603, 47)" end="(603, 48)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(603, 49)" end="(603, 59)">
                <AtomNode start="(603, 49)" end="(603, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(603, 51)" end="(603, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(603, 51)" end="(603, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(603, 53)" end="(603, 54)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(603, 55)" end="(603, 59)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(603, 59)" end="(603, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(603, 61)" end="(604, 48)">
            <AtomNode start="(603, 61)" end="(603, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(604, 5)" end="(604, 48)" kind="«term_=_»">
              <OtherNode start="(604, 5)" end="(604, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(604, 5)" end="(604, 22)" leading="" trailing=" " raw_val="as.toArray.eraseP" val="as.toArray.eraseP"/>
                <NullNode start="(604, 23)" end="(604, 24)">
                  <IdentNode start="(604, 23)" end="(604, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(604, 25)" end="(604, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(604, 27)" end="(604, 48)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(604, 27)" end="(604, 40)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(604, 27)" end="(604, 28)" leading="" trailing="" val="("/>
                  <OtherNode start="(604, 28)" end="(604, 39)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(604, 28)" end="(604, 37)" leading="" trailing=" " raw_val="as.eraseP" val="as.eraseP"/>
                    <NullNode start="(604, 38)" end="(604, 39)">
                      <IdentNode start="(604, 38)" end="(604, 39)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(604, 39)" end="(604, 40)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(604, 40)" end="(604, 41)" leading="" trailing="" val="."/>
                <IdentNode start="(604, 41)" end="(604, 48)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(604, 49)" end="(606, 54)">
          <AtomNode start="(604, 49)" end="(604, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(604, 52)" end="(606, 54)">
            <AtomNode start="(604, 52)" end="(604, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(605, 3)" end="(606, 54)">
              <TacticTacticseq1IndentedNode start="(605, 3)" end="(606, 54)">
                <NullNode start="(605, 3)" end="(606, 54)">
                  <OtherNode start="(605, 3)" end="(605, 66)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;as : List α&#10;p : α → Bool&#10;⊢ as.toArray.eraseP p = (eraseP p as).toArray" state_after="α : Type u_1&#10;as : List α&#10;p : α → Bool&#10;⊢ (match findFinIdx? p as with&#10;    | none =&amp;gt; as.toArray&#10;    | some i =&amp;gt; as.toArray.eraseIdx ↑i ⋯) =&#10;    (match findIdx? p as with&#10;      | none =&amp;gt; as&#10;      | some i =&amp;gt; as.eraseIdx i).toArray" tactic="rw [Array.eraseP, List.eraseP_eq_eraseIdx, findFinIdx?_toArray]">
                    <AtomNode start="(605, 3)" end="(605, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(605, 6)" end="(605, 66)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(605, 6)" end="(605, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(605, 7)" end="(605, 65)">
                        <OtherNode start="(605, 7)" end="(605, 19)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(605, 7)" end="(605, 19)" leading="" trailing="" raw_val="Array.eraseP" val="Array.eraseP" full_name="Array.eraseP" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(605, 19)" end="(605, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(605, 21)" end="(605, 44)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(605, 21)" end="(605, 44)" leading="" trailing="" raw_val="List.eraseP_eq_eraseIdx" val="List.eraseP_eq_eraseIdx" full_name="List.eraseP_eq_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(605, 44)" end="(605, 45)" leading="" trailing=" " val=","/>
                        <OtherNode start="(605, 46)" end="(605, 65)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(605, 46)" end="(605, 65)" leading="" trailing="" raw_val="findFinIdx?_toArray" val="findFinIdx?_toArray" full_name="List.findFinIdx?_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(300, 17)" def_end="(300, 36)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(605, 65)" end="(605, 66)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(606, 3)" end="(606, 54)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;as : List α&#10;p : α → Bool&#10;⊢ (match findFinIdx? p as with&#10;    | none =&amp;gt; as.toArray&#10;    | some i =&amp;gt; as.toArray.eraseIdx ↑i ⋯) =&#10;    (match findIdx? p as with&#10;      | none =&amp;gt; as&#10;      | some i =&amp;gt; as.eraseIdx i).toArray" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [*, findIdx?_eq_map_findFinIdx?_val]">
                    <OtherNode start="(606, 3)" end="(606, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(606, 3)" end="(606, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(606, 9)" end="(606, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(606, 13)" end="(606, 54)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(606, 13)" end="(606, 17)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(606, 18)" end="(606, 54)">
                        <AtomNode start="(606, 18)" end="(606, 19)" leading="" trailing="" val="["/>
                        <NullNode start="(606, 19)" end="(606, 53)">
                          <OtherNode start="(606, 19)" end="(606, 20)" kind="Lean.Parser.Tactic.simpStar">
                            <AtomNode start="(606, 19)" end="(606, 20)" leading="" trailing="" val="*"/>
                          </OtherNode>
                          <AtomNode start="(606, 20)" end="(606, 21)" leading="" trailing=" " val=","/>
                          <OtherNode start="(606, 22)" end="(606, 53)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(606, 22)" end="(606, 53)" leading="" trailing="" raw_val="findIdx?_eq_map_findFinIdx?_val" val="findIdx?_eq_map_findFinIdx?_val" full_name="List.findIdx?_eq_map_findFinIdx?_val" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(606, 53)" end="(606, 54)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(608, 1)" end="(612, 21)" name="erase_toArray" full_name="List.erase_toArray">
      <CommandDeclmodifiersNode start="(608, 1)" end="(608, 8)">
        <NullNode/>
        <NullNode start="(608, 1)" end="(608, 8)">
          <OtherNode start="(608, 1)" end="(608, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(608, 1)" end="(608, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(608, 3)" end="(608, 7)">
              <OtherNode start="(608, 3)" end="(608, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(608, 3)" end="(608, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(608, 3)" end="(608, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(608, 7)" end="(608, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(608, 9)" end="(612, 21)" name="erase_toArray" full_name="List.erase_toArray" _is_private_decl="False">
        <AtomNode start="(608, 9)" end="(608, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(608, 17)" end="(608, 30)">
          <IdentNode start="(608, 17)" end="(608, 30)" leading="" trailing=" " raw_val="erase_toArray" val="erase_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(608, 31)" end="(609, 46)">
          <NullNode start="(608, 31)" end="(608, 60)">
            <OtherNode start="(608, 31)" end="(608, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(608, 31)" end="(608, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(608, 32)" end="(608, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(608, 32)" end="(608, 35)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(608, 36)" end="(608, 37)">
                  <IdentNode start="(608, 36)" end="(608, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(608, 37)" end="(608, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(608, 39)" end="(608, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(608, 39)" end="(608, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(608, 40)" end="(608, 42)">
                <IdentNode start="(608, 40)" end="(608, 42)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(608, 43)" end="(608, 51)">
                <AtomNode start="(608, 43)" end="(608, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(608, 45)" end="(608, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(608, 45)" end="(608, 49)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(608, 50)" end="(608, 51)">
                    <IdentNode start="(608, 50)" end="(608, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(608, 51)" end="(608, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(608, 53)" end="(608, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(608, 53)" end="(608, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(608, 54)" end="(608, 55)">
                <IdentNode start="(608, 54)" end="(608, 55)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(608, 56)" end="(608, 59)">
                <AtomNode start="(608, 56)" end="(608, 57)" leading="" trailing=" " val=":"/>
                <IdentNode start="(608, 58)" end="(608, 59)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(608, 59)" end="(608, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(608, 61)" end="(609, 46)">
            <AtomNode start="(608, 61)" end="(608, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(609, 5)" end="(609, 46)" kind="«term_=_»">
              <OtherNode start="(609, 5)" end="(609, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(609, 5)" end="(609, 21)" leading="" trailing=" " raw_val="as.toArray.erase" val="as.toArray.erase"/>
                <NullNode start="(609, 22)" end="(609, 23)">
                  <IdentNode start="(609, 22)" end="(609, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(609, 24)" end="(609, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(609, 26)" end="(609, 46)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(609, 26)" end="(609, 38)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(609, 26)" end="(609, 27)" leading="" trailing="" val="("/>
                  <OtherNode start="(609, 27)" end="(609, 37)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(609, 27)" end="(609, 35)" leading="" trailing=" " raw_val="as.erase" val="as.erase"/>
                    <NullNode start="(609, 36)" end="(609, 37)">
                      <IdentNode start="(609, 36)" end="(609, 37)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(609, 37)" end="(609, 38)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(609, 38)" end="(609, 39)" leading="" trailing="" val="."/>
                <IdentNode start="(609, 39)" end="(609, 46)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(609, 47)" end="(612, 21)">
          <AtomNode start="(609, 47)" end="(609, 49)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(609, 50)" end="(612, 21)">
            <AtomNode start="(609, 50)" end="(609, 52)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(610, 3)" end="(612, 21)">
              <TacticTacticseq1IndentedNode start="(610, 3)" end="(612, 21)">
                <NullNode start="(610, 3)" end="(612, 21)">
                  <OtherNode start="(610, 3)" end="(610, 62)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;as : List α&#10;a : α&#10;⊢ as.toArray.erase a = (as.erase a).toArray" state_after="α : Type u_1&#10;inst✝ : BEq α&#10;as : List α&#10;a : α&#10;⊢ (match finIdxOf? a as with&#10;    | none =&amp;gt; as.toArray&#10;    | some i =&amp;gt; as.toArray.eraseIdx ↑i ⋯) =&#10;    (match idxOf? a as with&#10;      | none =&amp;gt; as&#10;      | some i =&amp;gt; as.eraseIdx i).toArray" tactic="rw [Array.erase, finIdxOf?_toArray, List.erase_eq_eraseIdx]">
                    <AtomNode start="(610, 3)" end="(610, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(610, 6)" end="(610, 62)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(610, 6)" end="(610, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(610, 7)" end="(610, 61)">
                        <OtherNode start="(610, 7)" end="(610, 18)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(610, 7)" end="(610, 18)" leading="" trailing="" raw_val="Array.erase" val="Array.erase" full_name="Array.erase" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(610, 18)" end="(610, 19)" leading="" trailing=" " val=","/>
                        <OtherNode start="(610, 20)" end="(610, 37)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(610, 20)" end="(610, 37)" leading="" trailing="" raw_val="finIdxOf?_toArray" val="finIdxOf?_toArray" full_name="List.finIdxOf?_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(337, 17)" def_end="(337, 34)"/>
                        </OtherNode>
                        <AtomNode start="(610, 37)" end="(610, 38)" leading="" trailing=" " val=","/>
                        <OtherNode start="(610, 39)" end="(610, 61)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(610, 39)" end="(610, 61)" leading="" trailing="" raw_val="List.erase_eq_eraseIdx" val="List.erase_eq_eraseIdx" full_name="List.erase_eq_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(610, 61)" end="(610, 62)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(611, 3)" end="(611, 35)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;as : List α&#10;a : α&#10;⊢ (match finIdxOf? a as with&#10;    | none =&amp;gt; as.toArray&#10;    | some i =&amp;gt; as.toArray.eraseIdx ↑i ⋯) =&#10;    (match idxOf? a as with&#10;      | none =&amp;gt; as&#10;      | some i =&amp;gt; as.eraseIdx i).toArray" state_after="α : Type u_1&#10;inst✝ : BEq α&#10;as : List α&#10;a : α&#10;⊢ (match finIdxOf? a as with&#10;    | none =&amp;gt; as.toArray&#10;    | some i =&amp;gt; as.toArray.eraseIdx ↑i ⋯) =&#10;    (match Option.map (fun x =&amp;gt; ↑x) (finIdxOf? a as) with&#10;      | none =&amp;gt; as&#10;      | some i =&amp;gt; as.eraseIdx i).toArray" tactic="rw [idxOf?_eq_map_finIdxOf?_val]">
                    <AtomNode start="(611, 3)" end="(611, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(611, 6)" end="(611, 35)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(611, 6)" end="(611, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(611, 7)" end="(611, 34)">
                        <OtherNode start="(611, 7)" end="(611, 34)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(611, 7)" end="(611, 34)" leading="" trailing="" raw_val="idxOf?_eq_map_finIdxOf?_val" val="idxOf?_eq_map_finIdxOf?_val" full_name="List.idxOf?_eq_map_finIdxOf?_val" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(611, 34)" end="(611, 35)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(612, 3)" end="(612, 21)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;as : List α&#10;a : α&#10;⊢ (match finIdxOf? a as with&#10;    | none =&amp;gt; as.toArray&#10;    | some i =&amp;gt; as.toArray.eraseIdx ↑i ⋯) =&#10;    (match Option.map (fun x =&amp;gt; ↑x) (finIdxOf? a as) with&#10;      | none =&amp;gt; as&#10;      | some i =&amp;gt; as.eraseIdx i).toArray" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(612, 3)" end="(612, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(612, 3)" end="(612, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(612, 9)" end="(612, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(612, 13)" end="(612, 21)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(612, 13)" end="(612, 21)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(614, 1)" end="(636, 9)" name="insertIdx_loop_toArray" full_name="List.insertIdx_loop_toArray">
      <CommandDeclmodifiersNode start="(614, 1)" end="(614, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(614, 1)" end="(614, 8)">
          <CommandPrivateNode start="(614, 1)" end="(614, 8)">
            <AtomNode start="(614, 1)" end="(614, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(614, 9)" end="(636, 9)" name="insertIdx_loop_toArray" full_name="List.insertIdx_loop_toArray" _is_private_decl="True">
        <AtomNode start="(614, 9)" end="(614, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(614, 17)" end="(614, 39)">
          <IdentNode start="(614, 17)" end="(614, 39)" leading="" trailing=" " raw_val="insertIdx_loop_toArray" val="insertIdx_loop_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(614, 40)" end="(615, 107)">
          <NullNode start="(614, 40)" end="(614, 110)">
            <TermExplicitbinderNode start="(614, 40)" end="(614, 49)">
              <AtomNode start="(614, 40)" end="(614, 41)" leading="" trailing="" val="("/>
              <NullNode start="(614, 41)" end="(614, 42)">
                <IdentNode start="(614, 41)" end="(614, 42)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(614, 43)" end="(614, 48)">
                <AtomNode start="(614, 43)" end="(614, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(614, 45)" end="(614, 48)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(614, 48)" end="(614, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(614, 50)" end="(614, 62)">
              <AtomNode start="(614, 50)" end="(614, 51)" leading="" trailing="" val="("/>
              <NullNode start="(614, 51)" end="(614, 52)">
                <IdentNode start="(614, 51)" end="(614, 52)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(614, 53)" end="(614, 61)">
                <AtomNode start="(614, 53)" end="(614, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(614, 55)" end="(614, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(614, 55)" end="(614, 59)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(614, 60)" end="(614, 61)">
                    <IdentNode start="(614, 60)" end="(614, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(614, 61)" end="(614, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(614, 63)" end="(614, 72)">
              <AtomNode start="(614, 63)" end="(614, 64)" leading="" trailing="" val="("/>
              <NullNode start="(614, 64)" end="(614, 65)">
                <IdentNode start="(614, 64)" end="(614, 65)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(614, 66)" end="(614, 71)">
                <AtomNode start="(614, 66)" end="(614, 67)" leading="" trailing=" " val=":"/>
                <IdentNode start="(614, 68)" end="(614, 71)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(614, 71)" end="(614, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(614, 73)" end="(614, 98)">
              <AtomNode start="(614, 73)" end="(614, 74)" leading="" trailing="" val="("/>
              <NullNode start="(614, 74)" end="(614, 76)">
                <IdentNode start="(614, 74)" end="(614, 76)" leading="" trailing=" " raw_val="hj" val="hj"/>
              </NullNode>
              <NullNode start="(614, 77)" end="(614, 97)">
                <AtomNode start="(614, 77)" end="(614, 78)" leading="" trailing=" " val=":"/>
                <OtherNode start="(614, 79)" end="(614, 97)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(614, 79)" end="(614, 80)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(614, 81)" end="(614, 82)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(614, 83)" end="(614, 97)" leading="" trailing="" raw_val="l.toArray.size" val="l.toArray.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(614, 97)" end="(614, 98)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(614, 99)" end="(614, 110)">
              <AtomNode start="(614, 99)" end="(614, 100)" leading="" trailing="" val="("/>
              <NullNode start="(614, 100)" end="(614, 101)">
                <IdentNode start="(614, 100)" end="(614, 101)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(614, 102)" end="(614, 109)">
                <AtomNode start="(614, 102)" end="(614, 103)" leading="" trailing=" " val=":"/>
                <OtherNode start="(614, 104)" end="(614, 109)" kind="«term_≤_»">
                  <IdentNode start="(614, 104)" end="(614, 105)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(614, 106)" end="(614, 107)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(614, 108)" end="(614, 109)" leading="" trailing="" raw_val="j" val="j"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(614, 109)" end="(614, 110)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(614, 111)" end="(615, 107)">
            <AtomNode start="(614, 111)" end="(614, 112)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(615, 5)" end="(615, 107)" kind="«term_=_»">
              <OtherNode start="(615, 5)" end="(615, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(615, 5)" end="(615, 19)" leading="" trailing=" " raw_val="insertIdx.loop" val="insertIdx.loop" full_name="Array.insertIdx.loop" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(615, 20)" end="(615, 39)">
                  <IdentNode start="(615, 20)" end="(615, 21)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(615, 22)" end="(615, 31)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
                  <OtherNode start="(615, 32)" end="(615, 39)" kind="Lean.Parser.Term.anonymousCtor">
                    <AtomNode start="(615, 32)" end="(615, 33)" leading="" trailing="" val="⟨"/>
                    <NullNode start="(615, 33)" end="(615, 38)">
                      <IdentNode start="(615, 33)" end="(615, 34)" leading="" trailing="" raw_val="j" val="j"/>
                      <AtomNode start="(615, 34)" end="(615, 35)" leading="" trailing=" " val=","/>
                      <IdentNode start="(615, 36)" end="(615, 38)" leading="" trailing="" raw_val="hj" val="hj"/>
                    </NullNode>
                    <AtomNode start="(615, 38)" end="(615, 39)" leading="" trailing=" " val="⟩"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(615, 40)" end="(615, 41)" leading="" trailing=" " val="="/>
              <OtherNode start="(615, 42)" end="(615, 107)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(615, 42)" end="(615, 99)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(615, 42)" end="(615, 43)" leading="" trailing="" val="("/>
                  <OtherNode start="(615, 43)" end="(615, 98)" kind="«term_++_»">
                    <OtherNode start="(615, 43)" end="(615, 80)" kind="«term_++_»">
                      <OtherNode start="(615, 43)" end="(615, 51)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(615, 43)" end="(615, 49)" leading="" trailing=" " raw_val="l.take" val="l.take"/>
                        <NullNode start="(615, 50)" end="(615, 51)">
                          <IdentNode start="(615, 50)" end="(615, 51)" leading="" trailing=" " raw_val="i" val="i"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(615, 52)" end="(615, 54)" leading="" trailing=" " val="++"/>
                      <OtherNode start="(615, 55)" end="(615, 80)" kind="«term_::_»">
                        <OtherNode start="(615, 55)" end="(615, 59)" kind="«term__[_]»">
                          <IdentNode start="(615, 55)" end="(615, 56)" leading="" trailing="" raw_val="l" val="l"/>
                          <AtomNode start="(615, 56)" end="(615, 57)" leading="" trailing="" val="["/>
                          <IdentNode start="(615, 57)" end="(615, 58)" leading="" trailing="" raw_val="j" val="j"/>
                          <AtomNode start="(615, 58)" end="(615, 59)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                        <AtomNode start="(615, 60)" end="(615, 62)" leading="" trailing=" " val="::"/>
                        <OtherNode start="(615, 63)" end="(615, 80)" kind="Lean.Parser.Term.app">
                          <OtherNode start="(615, 63)" end="(615, 78)" kind="Lean.Parser.Term.proj">
                            <OtherNode start="(615, 63)" end="(615, 73)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(615, 63)" end="(615, 64)" leading="" trailing="" val="("/>
                              <OtherNode start="(615, 64)" end="(615, 72)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(615, 64)" end="(615, 70)" leading="" trailing=" " raw_val="l.take" val="l.take"/>
                                <NullNode start="(615, 71)" end="(615, 72)">
                                  <IdentNode start="(615, 71)" end="(615, 72)" leading="" trailing="" raw_val="j" val="j"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(615, 72)" end="(615, 73)" leading="" trailing="" val=")"/>
                            </OtherNode>
                            <AtomNode start="(615, 73)" end="(615, 74)" leading="" trailing="" val="."/>
                            <IdentNode start="(615, 74)" end="(615, 78)" leading="" trailing=" " raw_val="drop" val="drop" full_name="List.drop" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                          </OtherNode>
                          <NullNode start="(615, 79)" end="(615, 80)">
                            <IdentNode start="(615, 79)" end="(615, 80)" leading="" trailing=" " raw_val="i" val="i"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(615, 81)" end="(615, 83)" leading="" trailing=" " val="++"/>
                    <OtherNode start="(615, 84)" end="(615, 98)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(615, 84)" end="(615, 90)" leading="" trailing=" " raw_val="l.drop" val="l.drop"/>
                      <NullNode start="(615, 91)" end="(615, 98)">
                        <OtherNode start="(615, 91)" end="(615, 98)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(615, 91)" end="(615, 92)" leading="" trailing="" val="("/>
                          <OtherNode start="(615, 92)" end="(615, 97)" kind="«term_+_»">
                            <IdentNode start="(615, 92)" end="(615, 93)" leading="" trailing=" " raw_val="j" val="j"/>
                            <AtomNode start="(615, 94)" end="(615, 95)" leading="" trailing=" " val="+"/>
                            <OtherNode start="(615, 96)" end="(615, 97)" kind="num">
                              <AtomNode start="(615, 96)" end="(615, 97)" leading="" trailing="" val="1"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(615, 97)" end="(615, 98)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(615, 98)" end="(615, 99)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(615, 99)" end="(615, 100)" leading="" trailing="" val="."/>
                <IdentNode start="(615, 100)" end="(615, 107)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(615, 108)" end="(636, 9)">
          <AtomNode start="(615, 108)" end="(615, 110)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(615, 111)" end="(636, 9)">
            <AtomNode start="(615, 111)" end="(615, 113)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(616, 3)" end="(636, 9)">
              <TacticTacticseq1IndentedNode start="(616, 3)" end="(636, 9)">
                <NullNode start="(616, 3)" end="(636, 9)">
                  <OtherNode start="(616, 3)" end="(616, 22)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;⊢ insertIdx.loop i l.toArray ⟨j, hj⟩ = (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" state_after="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;⊢ (if i &amp;lt; ↑⟨j, hj⟩ then&#10;      let j' := ⟨↑⟨j, hj⟩ - 1, ⋯⟩;&#10;      let as := l.toArray.swap ↑j' ↑⟨j, hj⟩ ⋯ ⋯;&#10;      insertIdx.loop i as ⟨↑j', ⋯⟩&#10;    else l.toArray) =&#10;    (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" tactic="rw [insertIdx.loop]">
                    <AtomNode start="(616, 3)" end="(616, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(616, 6)" end="(616, 22)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(616, 6)" end="(616, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(616, 7)" end="(616, 21)">
                        <OtherNode start="(616, 7)" end="(616, 21)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(616, 7)" end="(616, 21)" leading="" trailing="" raw_val="insertIdx.loop" val="insertIdx.loop" full_name="Array.insertIdx.loop" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(616, 21)" end="(616, 22)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(617, 3)" end="(617, 33)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;⊢ (if i &amp;lt; ↑⟨j, hj⟩ then&#10;      let j' := ⟨↑⟨j, hj⟩ - 1, ⋯⟩;&#10;      let as := l.toArray.swap ↑j' ↑⟨j, hj⟩ ⋯ ⋯;&#10;      insertIdx.loop i as ⟨↑j', ⋯⟩&#10;    else l.toArray) =&#10;    (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" state_after="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;⊢ (if i &amp;lt; ↑⟨j, hj✝⟩ then&#10;      let j' := ⟨↑⟨j, hj✝⟩ - 1, ⋯⟩;&#10;      let as := l.toArray.swap ↑j' ↑⟨j, hj✝⟩ ⋯ ⋯;&#10;      insertIdx.loop i as ⟨↑j', ⋯⟩&#10;    else l.toArray) =&#10;    (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" tactic="simp only [size_toArray] at hj">
                    <AtomNode start="(617, 3)" end="(617, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(617, 8)" end="(617, 12)">
                      <AtomNode start="(617, 8)" end="(617, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(617, 13)" end="(617, 27)">
                      <AtomNode start="(617, 13)" end="(617, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(617, 14)" end="(617, 26)">
                        <OtherNode start="(617, 14)" end="(617, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(617, 14)" end="(617, 26)" leading="" trailing="" raw_val="size_toArray" val="size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(617, 26)" end="(617, 27)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(617, 28)" end="(617, 33)">
                      <OtherNode start="(617, 28)" end="(617, 33)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(617, 28)" end="(617, 30)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(617, 31)" end="(617, 33)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(617, 31)" end="(617, 33)">
                            <IdentNode start="(617, 31)" end="(617, 33)" leading="" trailing="&#10;  " raw_val="hj" val="hj"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(618, 3)" end="(618, 24)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;⊢ (if i &amp;lt; ↑⟨j, hj✝⟩ then&#10;      let j' := ⟨↑⟨j, hj✝⟩ - 1, ⋯⟩;&#10;      let as := l.toArray.swap ↑j' ↑⟨j, hj✝⟩ ⋯ ⋯;&#10;      insertIdx.loop i as ⟨↑j', ⋯⟩&#10;    else l.toArray) =&#10;    (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" state_after="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; ↑⟨j, hj✝⟩&#10;⊢ (let j' := ⟨↑⟨j, hj✝⟩ - 1, ⋯⟩;&#10;    let as := l.toArray.swap ↑j' ↑⟨j, hj✝⟩ ⋯ ⋯;&#10;    insertIdx.loop i as ⟨↑j', ⋯⟩) =&#10;    (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray&#10;&#10;case isFalse&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : ¬i &amp;lt; ↑⟨j, hj✝⟩&#10;⊢ l.toArray = (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" tactic="split &amp;lt;;&amp;gt; rename_i h'">
                    <OtherNode start="(618, 3)" end="(618, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(618, 3)" end="(618, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(618, 9)" end="(618, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(618, 13)" end="(618, 24)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(618, 13)" end="(618, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(618, 22)" end="(618, 24)">
                        <LeanBinderidentNode start="(618, 22)" end="(618, 24)">
                          <IdentNode start="(618, 22)" end="(618, 24)" leading="" trailing="&#10;  " raw_val="h'" val="h'"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(619, 3)" end="(632, 47)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; ↑⟨j, hj✝⟩&#10;⊢ (let j' := ⟨↑⟨j, hj✝⟩ - 1, ⋯⟩;&#10;    let as := l.toArray.swap ↑j' ↑⟨j, hj✝⟩ ⋯ ⋯;&#10;    insertIdx.loop i as ⟨↑j', ⋯⟩) =&#10;    (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray&#10;&#10;case isFalse&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : ¬i &amp;lt; ↑⟨j, hj✝⟩&#10;⊢ l.toArray = (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" state_after="case isFalse&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : ¬i &amp;lt; ↑⟨j, hj✝⟩&#10;⊢ l.toArray = (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" tactic="· simp only at h'&#10;  have w : j - 1 + 1 = j := by omega&#10;  simp only [append_assoc, cons_append]&#10;  rw [insertIdx_loop_toArray _ _ _ _ (by omega)]&#10;  simp only [swap_toArray, w, append_assoc, cons_append, mk.injEq]&#10;  rw [take_set_of_le (by omega), drop_eq_getElem_cons (i := j) (by simpa), getElem_set_self,&#10;    drop_set_of_lt (by omega), drop_set_of_lt (by omega), getElem_set_ne (by omega),&#10;    getElem_set_self, take_set_of_le (j := j - 1) (by omega),&#10;    take_set_of_le (j := j - 1) (by omega), take_eq_append_getElem_of_pos (by omega) hj,&#10;    drop_append_of_le_length (by simp; omega)]&#10;  simp only [append_assoc, cons_append, nil_append, append_cancel_right_eq]&#10;  cases i with&#10;  | zero =&amp;gt; simp&#10;  | succ i =&amp;gt; rw [take_set_of_le (by omega)]">
                    <OtherNode start="(619, 3)" end="(619, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(619, 3)" end="(619, 4)" kind="patternIgnore">
                        <OtherNode start="(619, 3)" end="(619, 4)" kind="token.«· »">
                          <AtomNode start="(619, 3)" end="(619, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(619, 5)" end="(632, 47)">
                      <TacticTacticseq1IndentedNode start="(619, 5)" end="(632, 47)">
                        <NullNode start="(619, 5)" end="(632, 47)">
                          <OtherNode start="(619, 5)" end="(619, 20)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; ↑⟨j, hj✝⟩&#10;⊢ (let j' := ⟨↑⟨j, hj✝⟩ - 1, ⋯⟩;&#10;    let as := l.toArray.swap ↑j' ↑⟨j, hj✝⟩ ⋯ ⋯;&#10;    insertIdx.loop i as ⟨↑j', ⋯⟩) =&#10;    (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" state_after="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;⊢ (let j' := ⟨↑⟨j, hj✝⟩ - 1, ⋯⟩;&#10;    let as := l.toArray.swap ↑j' ↑⟨j, hj✝⟩ ⋯ ⋯;&#10;    insertIdx.loop i as ⟨↑j', ⋯⟩) =&#10;    (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" tactic="simp only at h'">
                            <AtomNode start="(619, 5)" end="(619, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(619, 10)" end="(619, 14)">
                              <AtomNode start="(619, 10)" end="(619, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(619, 15)" end="(619, 20)">
                              <OtherNode start="(619, 15)" end="(619, 20)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(619, 15)" end="(619, 17)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(619, 18)" end="(619, 20)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(619, 18)" end="(619, 20)">
                                    <IdentNode start="(619, 18)" end="(619, 20)" leading="" trailing="&#10;    " raw_val="h'" val="h'"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(620, 5)" end="(620, 39)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;⊢ (let j' := ⟨↑⟨j, hj✝⟩ - 1, ⋯⟩;&#10;    let as := l.toArray.swap ↑j' ↑⟨j, hj✝⟩ ⋯ ⋯;&#10;    insertIdx.loop i as ⟨↑j', ⋯⟩) =&#10;    (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" state_after="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ (let j' := ⟨↑⟨j, hj✝⟩ - 1, ⋯⟩;&#10;    let as := l.toArray.swap ↑j' ↑⟨j, hj✝⟩ ⋯ ⋯;&#10;    insertIdx.loop i as ⟨↑j', ⋯⟩) =&#10;    (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" tactic="have w : j - 1 + 1 = j := by omega">
                            <AtomNode start="(620, 5)" end="(620, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(620, 10)" end="(620, 39)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(620, 10)" end="(620, 39)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(620, 10)" end="(620, 11)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(620, 10)" end="(620, 11)" leading="" trailing=" " raw_val="w" val="w"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(620, 12)" end="(620, 27)">
                                  <TermTypespecNode start="(620, 12)" end="(620, 27)">
                                    <AtomNode start="(620, 12)" end="(620, 13)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(620, 14)" end="(620, 27)" kind="«term_=_»">
                                      <OtherNode start="(620, 14)" end="(620, 23)" kind="«term_+_»">
                                        <OtherNode start="(620, 14)" end="(620, 19)" kind="«term_-_»">
                                          <IdentNode start="(620, 14)" end="(620, 15)" leading="" trailing=" " raw_val="j" val="j"/>
                                          <AtomNode start="(620, 16)" end="(620, 17)" leading="" trailing=" " val="-"/>
                                          <OtherNode start="(620, 18)" end="(620, 19)" kind="num">
                                            <AtomNode start="(620, 18)" end="(620, 19)" leading="" trailing=" " val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(620, 20)" end="(620, 21)" leading="" trailing=" " val="+"/>
                                        <OtherNode start="(620, 22)" end="(620, 23)" kind="num">
                                          <AtomNode start="(620, 22)" end="(620, 23)" leading="" trailing=" " val="1"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(620, 24)" end="(620, 25)" leading="" trailing=" " val="="/>
                                      <IdentNode start="(620, 26)" end="(620, 27)" leading="" trailing=" " raw_val="j" val="j"/>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(620, 28)" end="(620, 30)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(620, 31)" end="(620, 39)">
                                  <AtomNode start="(620, 31)" end="(620, 33)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(620, 34)" end="(620, 39)">
                                    <TacticTacticseq1IndentedNode start="(620, 34)" end="(620, 39)">
                                      <NullNode start="(620, 34)" end="(620, 39)">
                                        <OtherNode start="(620, 34)" end="(620, 39)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;⊢ j - 1 + 1 = j" state_after="no goals" tactic="omega">
                                          <AtomNode start="(620, 34)" end="(620, 39)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(621, 5)" end="(621, 42)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ (let j' := ⟨↑⟨j, hj✝⟩ - 1, ⋯⟩;&#10;    let as := l.toArray.swap ↑j' ↑⟨j, hj✝⟩ ⋯ ⋯;&#10;    insertIdx.loop i as ⟨↑j', ⋯⟩) =&#10;    (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" state_after="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ insertIdx.loop i (l.toArray.swap (j - 1) j ⋯ ⋯) ⟨j - 1, ⋯⟩ =&#10;    (take i l ++ l[j] :: (drop i (take j l) ++ drop (j + 1) l)).toArray" tactic="simp only [append_assoc, cons_append]">
                            <AtomNode start="(621, 5)" end="(621, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(621, 10)" end="(621, 14)">
                              <AtomNode start="(621, 10)" end="(621, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(621, 15)" end="(621, 42)">
                              <AtomNode start="(621, 15)" end="(621, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(621, 16)" end="(621, 41)">
                                <OtherNode start="(621, 16)" end="(621, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(621, 16)" end="(621, 28)" leading="" trailing="" raw_val="append_assoc" val="append_assoc" full_name="List.append_assoc" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(621, 28)" end="(621, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(621, 30)" end="(621, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(621, 30)" end="(621, 41)" leading="" trailing="" raw_val="cons_append" val="cons_append" full_name="List.cons_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(621, 41)" end="(621, 42)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(622, 5)" end="(622, 51)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ insertIdx.loop i (l.toArray.swap (j - 1) j ⋯ ⋯) ⟨j - 1, ⋯⟩ =&#10;    (take i l ++ l[j] :: (drop i (take j l) ++ drop (j + 1) l)).toArray" state_after="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ (take i (l.toArray.swap (j - 1) j ⋯ ⋯).toList ++&#10;          (l.toArray.swap (j - 1) j ⋯ ⋯).toList[j - 1] :: drop i (take (j - 1) (l.toArray.swap (j - 1) j ⋯ ⋯).toList) ++&#10;        drop (j - 1 + 1) (l.toArray.swap (j - 1) j ⋯ ⋯).toList).toArray =&#10;    (take i l ++ l[j] :: (drop i (take j l) ++ drop (j + 1) l)).toArray" tactic="rw [insertIdx_loop_toArray _ _ _ _ (by omega)]">
                            <AtomNode start="(622, 5)" end="(622, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(622, 8)" end="(622, 51)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(622, 8)" end="(622, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(622, 9)" end="(622, 50)">
                                <OtherNode start="(622, 9)" end="(622, 50)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(622, 9)" end="(622, 50)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(622, 9)" end="(622, 31)" leading="" trailing=" " raw_val="insertIdx_loop_toArray" val="insertIdx_loop_toArray"/>
                                    <NullNode start="(622, 32)" end="(622, 50)">
                                      <TermHoleNode start="(622, 32)" end="(622, 33)">
                                        <AtomNode start="(622, 32)" end="(622, 33)" leading="" trailing=" " val="_"/>
                                      </TermHoleNode>
                                      <TermHoleNode start="(622, 34)" end="(622, 35)">
                                        <AtomNode start="(622, 34)" end="(622, 35)" leading="" trailing=" " val="_"/>
                                      </TermHoleNode>
                                      <TermHoleNode start="(622, 36)" end="(622, 37)">
                                        <AtomNode start="(622, 36)" end="(622, 37)" leading="" trailing=" " val="_"/>
                                      </TermHoleNode>
                                      <TermHoleNode start="(622, 38)" end="(622, 39)">
                                        <AtomNode start="(622, 38)" end="(622, 39)" leading="" trailing=" " val="_"/>
                                      </TermHoleNode>
                                      <OtherNode start="(622, 40)" end="(622, 50)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(622, 40)" end="(622, 41)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(622, 41)" end="(622, 49)">
                                          <AtomNode start="(622, 41)" end="(622, 43)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(622, 44)" end="(622, 49)">
                                            <TacticTacticseq1IndentedNode start="(622, 44)" end="(622, 49)">
                                              <NullNode start="(622, 44)" end="(622, 49)">
                                                <OtherNode start="(622, 44)" end="(622, 49)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ i ≤ j - 1" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(622, 44)" end="(622, 49)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(622, 49)" end="(622, 50)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(622, 50)" end="(622, 51)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(623, 5)" end="(623, 69)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ (take i (l.toArray.swap (j - 1) j ⋯ ⋯).toList ++&#10;          (l.toArray.swap (j - 1) j ⋯ ⋯).toList[j - 1] :: drop i (take (j - 1) (l.toArray.swap (j - 1) j ⋯ ⋯).toList) ++&#10;        drop (j - 1 + 1) (l.toArray.swap (j - 1) j ⋯ ⋯).toList).toArray =&#10;    (take i l ++ l[j] :: (drop i (take j l) ++ drop (j + 1) l)).toArray" state_after="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ take i ((l.set (j - 1) l[j]).set j l[j - 1]) ++&#10;      ((l.set (j - 1) l[j]).set j l[j - 1])[j - 1] ::&#10;        (drop i (take (j - 1) ((l.set (j - 1) l[j]).set j l[j - 1])) ++ drop j ((l.set (j - 1) l[j]).set j l[j - 1])) =&#10;    take i l ++ l[j] :: (drop i (take j l) ++ drop (j + 1) l)" tactic="simp only [swap_toArray, w, append_assoc, cons_append, mk.injEq]">
                            <AtomNode start="(623, 5)" end="(623, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(623, 10)" end="(623, 14)">
                              <AtomNode start="(623, 10)" end="(623, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(623, 15)" end="(623, 69)">
                              <AtomNode start="(623, 15)" end="(623, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(623, 16)" end="(623, 68)">
                                <OtherNode start="(623, 16)" end="(623, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(623, 16)" end="(623, 28)" leading="" trailing="" raw_val="swap_toArray" val="swap_toArray" full_name="List.swap_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(573, 17)" def_end="(573, 29)"/>
                                </OtherNode>
                                <AtomNode start="(623, 28)" end="(623, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(623, 30)" end="(623, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(623, 30)" end="(623, 31)" leading="" trailing="" raw_val="w" val="w"/>
                                </OtherNode>
                                <AtomNode start="(623, 31)" end="(623, 32)" leading="" trailing=" " val=","/>
                                <OtherNode start="(623, 33)" end="(623, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(623, 33)" end="(623, 45)" leading="" trailing="" raw_val="append_assoc" val="append_assoc" full_name="List.append_assoc" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(623, 45)" end="(623, 46)" leading="" trailing=" " val=","/>
                                <OtherNode start="(623, 47)" end="(623, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(623, 47)" end="(623, 58)" leading="" trailing="" raw_val="cons_append" val="cons_append" full_name="List.cons_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(623, 58)" end="(623, 59)" leading="" trailing=" " val=","/>
                                <OtherNode start="(623, 60)" end="(623, 68)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(623, 60)" end="(623, 68)" leading="" trailing="" raw_val="mk.injEq" val="mk.injEq" full_name="Array.mk.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(623, 68)" end="(623, 69)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(624, 5)" end="(628, 49)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ take i ((l.set (j - 1) l[j]).set j l[j - 1]) ++&#10;      ((l.set (j - 1) l[j]).set j l[j - 1])[j - 1] ::&#10;        (drop i (take (j - 1) ((l.set (j - 1) l[j]).set j l[j - 1])) ++ drop j ((l.set (j - 1) l[j]).set j l[j - 1])) =&#10;    take i l ++ l[j] :: (drop i (take j l) ++ drop (j + 1) l)" state_after="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ take i (l.set (j - 1) l[j]) ++ l[j] :: (drop i (take (j - 1) l) ++ l[j - 1] :: drop (j + 1) l) =&#10;    take i l ++ l[j] :: (drop i (take (j - 1) l) ++ [l[j - 1]] ++ drop (j + 1) l)" tactic="rw [take_set_of_le (by omega), drop_eq_getElem_cons (i := j) (by simpa), getElem_set_self,&#10;  drop_set_of_lt (by omega), drop_set_of_lt (by omega), getElem_set_ne (by omega),&#10;  getElem_set_self, take_set_of_le (j := j - 1) (by omega),&#10;  take_set_of_le (j := j - 1) (by omega), take_eq_append_getElem_of_pos (by omega) hj,&#10;  drop_append_of_le_length (by simp; omega)]">
                            <AtomNode start="(624, 5)" end="(624, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(624, 8)" end="(628, 49)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(624, 8)" end="(624, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(624, 9)" end="(628, 48)">
                                <OtherNode start="(624, 9)" end="(624, 34)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(624, 9)" end="(624, 34)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(624, 9)" end="(624, 23)" leading="" trailing=" " raw_val="take_set_of_le" val="take_set_of_le" full_name="List.take_set_of_le" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                    <NullNode start="(624, 24)" end="(624, 34)">
                                      <OtherNode start="(624, 24)" end="(624, 34)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(624, 24)" end="(624, 25)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(624, 25)" end="(624, 33)">
                                          <AtomNode start="(624, 25)" end="(624, 27)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(624, 28)" end="(624, 33)">
                                            <TacticTacticseq1IndentedNode start="(624, 28)" end="(624, 33)">
                                              <NullNode start="(624, 28)" end="(624, 33)">
                                                <OtherNode start="(624, 28)" end="(624, 33)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ i ≤ j" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(624, 28)" end="(624, 33)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(624, 33)" end="(624, 34)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(624, 34)" end="(624, 35)" leading="" trailing=" " val=","/>
                                <OtherNode start="(624, 36)" end="(624, 76)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(624, 36)" end="(624, 76)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(624, 36)" end="(624, 56)" leading="" trailing=" " raw_val="drop_eq_getElem_cons" val="drop_eq_getElem_cons" full_name="List.drop_eq_getElem_cons" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                    <NullNode start="(624, 57)" end="(624, 76)">
                                      <OtherNode start="(624, 57)" end="(624, 65)" kind="Lean.Parser.Term.namedArgument">
                                        <AtomNode start="(624, 57)" end="(624, 58)" leading="" trailing="" val="("/>
                                        <IdentNode start="(624, 58)" end="(624, 59)" leading="" trailing=" " raw_val="i" val="i"/>
                                        <AtomNode start="(624, 60)" end="(624, 62)" leading="" trailing=" " val=":="/>
                                        <IdentNode start="(624, 63)" end="(624, 64)" leading="" trailing="" raw_val="j" val="j"/>
                                        <AtomNode start="(624, 64)" end="(624, 65)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                      <OtherNode start="(624, 66)" end="(624, 76)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(624, 66)" end="(624, 67)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(624, 67)" end="(624, 75)">
                                          <AtomNode start="(624, 67)" end="(624, 69)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(624, 70)" end="(624, 75)">
                                            <TacticTacticseq1IndentedNode start="(624, 70)" end="(624, 75)">
                                              <NullNode start="(624, 70)" end="(624, 75)">
                                                <OtherNode start="(624, 70)" end="(624, 75)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ j &amp;lt; ((l.set (j - 1) l[j]).set j l[j - 1]).length" state_after="no goals" tactic="simpa">
                                                  <AtomNode start="(624, 70)" end="(624, 75)" leading="" trailing="" val="simpa"/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <OtherNode kind="Lean.Parser.Tactic.simpaArgsRest">
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(624, 75)" end="(624, 76)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(624, 76)" end="(624, 77)" leading="" trailing=" " val=","/>
                                <OtherNode start="(624, 78)" end="(624, 94)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(624, 78)" end="(624, 94)" leading="" trailing="" raw_val="getElem_set_self" val="getElem_set_self" full_name="List.getElem_set_self" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(624, 94)" end="(624, 95)" leading="" trailing="&#10;      " val=","/>
                                <OtherNode start="(625, 7)" end="(625, 32)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(625, 7)" end="(625, 32)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(625, 7)" end="(625, 21)" leading="" trailing=" " raw_val="drop_set_of_lt" val="drop_set_of_lt" full_name="List.drop_set_of_lt" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                    <NullNode start="(625, 22)" end="(625, 32)">
                                      <OtherNode start="(625, 22)" end="(625, 32)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(625, 22)" end="(625, 23)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(625, 23)" end="(625, 31)">
                                          <AtomNode start="(625, 23)" end="(625, 25)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(625, 26)" end="(625, 31)">
                                            <TacticTacticseq1IndentedNode start="(625, 26)" end="(625, 31)">
                                              <NullNode start="(625, 26)" end="(625, 31)">
                                                <OtherNode start="(625, 26)" end="(625, 31)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ j &amp;lt; j + 1" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(625, 26)" end="(625, 31)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(625, 31)" end="(625, 32)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(625, 32)" end="(625, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(625, 34)" end="(625, 59)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(625, 34)" end="(625, 59)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(625, 34)" end="(625, 48)" leading="" trailing=" " raw_val="drop_set_of_lt" val="drop_set_of_lt" full_name="List.drop_set_of_lt" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                    <NullNode start="(625, 49)" end="(625, 59)">
                                      <OtherNode start="(625, 49)" end="(625, 59)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(625, 49)" end="(625, 50)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(625, 50)" end="(625, 58)">
                                          <AtomNode start="(625, 50)" end="(625, 52)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(625, 53)" end="(625, 58)">
                                            <TacticTacticseq1IndentedNode start="(625, 53)" end="(625, 58)">
                                              <NullNode start="(625, 53)" end="(625, 58)">
                                                <OtherNode start="(625, 53)" end="(625, 58)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ j - 1 &amp;lt; j + 1" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(625, 53)" end="(625, 58)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(625, 58)" end="(625, 59)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(625, 59)" end="(625, 60)" leading="" trailing=" " val=","/>
                                <OtherNode start="(625, 61)" end="(625, 86)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(625, 61)" end="(625, 86)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(625, 61)" end="(625, 75)" leading="" trailing=" " raw_val="getElem_set_ne" val="getElem_set_ne" full_name="List.getElem_set_ne" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                    <NullNode start="(625, 76)" end="(625, 86)">
                                      <OtherNode start="(625, 76)" end="(625, 86)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(625, 76)" end="(625, 77)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(625, 77)" end="(625, 85)">
                                          <AtomNode start="(625, 77)" end="(625, 79)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(625, 80)" end="(625, 85)">
                                            <TacticTacticseq1IndentedNode start="(625, 80)" end="(625, 85)">
                                              <NullNode start="(625, 80)" end="(625, 85)">
                                                <OtherNode start="(625, 80)" end="(625, 85)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ j ≠ j - 1" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(625, 80)" end="(625, 85)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(625, 85)" end="(625, 86)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(625, 86)" end="(625, 87)" leading="" trailing="&#10;      " val=","/>
                                <OtherNode start="(626, 7)" end="(626, 23)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(626, 7)" end="(626, 23)" leading="" trailing="" raw_val="getElem_set_self" val="getElem_set_self" full_name="List.getElem_set_self" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(626, 23)" end="(626, 24)" leading="" trailing=" " val=","/>
                                <OtherNode start="(626, 25)" end="(626, 63)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(626, 25)" end="(626, 63)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(626, 25)" end="(626, 39)" leading="" trailing=" " raw_val="take_set_of_le" val="take_set_of_le" full_name="List.take_set_of_le" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                    <NullNode start="(626, 40)" end="(626, 63)">
                                      <OtherNode start="(626, 40)" end="(626, 52)" kind="Lean.Parser.Term.namedArgument">
                                        <AtomNode start="(626, 40)" end="(626, 41)" leading="" trailing="" val="("/>
                                        <IdentNode start="(626, 41)" end="(626, 42)" leading="" trailing=" " raw_val="j" val="j"/>
                                        <AtomNode start="(626, 43)" end="(626, 45)" leading="" trailing=" " val=":="/>
                                        <OtherNode start="(626, 46)" end="(626, 51)" kind="«term_-_»">
                                          <IdentNode start="(626, 46)" end="(626, 47)" leading="" trailing=" " raw_val="j" val="j"/>
                                          <AtomNode start="(626, 48)" end="(626, 49)" leading="" trailing=" " val="-"/>
                                          <OtherNode start="(626, 50)" end="(626, 51)" kind="num">
                                            <AtomNode start="(626, 50)" end="(626, 51)" leading="" trailing="" val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(626, 51)" end="(626, 52)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                      <OtherNode start="(626, 53)" end="(626, 63)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(626, 53)" end="(626, 54)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(626, 54)" end="(626, 62)">
                                          <AtomNode start="(626, 54)" end="(626, 56)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(626, 57)" end="(626, 62)">
                                            <TacticTacticseq1IndentedNode start="(626, 57)" end="(626, 62)">
                                              <NullNode start="(626, 57)" end="(626, 62)">
                                                <OtherNode start="(626, 57)" end="(626, 62)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ j - 1 ≤ j" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(626, 57)" end="(626, 62)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(626, 62)" end="(626, 63)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(626, 63)" end="(626, 64)" leading="" trailing="&#10;      " val=","/>
                                <OtherNode start="(627, 7)" end="(627, 45)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(627, 7)" end="(627, 45)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(627, 7)" end="(627, 21)" leading="" trailing=" " raw_val="take_set_of_le" val="take_set_of_le" full_name="List.take_set_of_le" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                    <NullNode start="(627, 22)" end="(627, 45)">
                                      <OtherNode start="(627, 22)" end="(627, 34)" kind="Lean.Parser.Term.namedArgument">
                                        <AtomNode start="(627, 22)" end="(627, 23)" leading="" trailing="" val="("/>
                                        <IdentNode start="(627, 23)" end="(627, 24)" leading="" trailing=" " raw_val="j" val="j"/>
                                        <AtomNode start="(627, 25)" end="(627, 27)" leading="" trailing=" " val=":="/>
                                        <OtherNode start="(627, 28)" end="(627, 33)" kind="«term_-_»">
                                          <IdentNode start="(627, 28)" end="(627, 29)" leading="" trailing=" " raw_val="j" val="j"/>
                                          <AtomNode start="(627, 30)" end="(627, 31)" leading="" trailing=" " val="-"/>
                                          <OtherNode start="(627, 32)" end="(627, 33)" kind="num">
                                            <AtomNode start="(627, 32)" end="(627, 33)" leading="" trailing="" val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(627, 33)" end="(627, 34)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                      <OtherNode start="(627, 35)" end="(627, 45)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(627, 35)" end="(627, 36)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(627, 36)" end="(627, 44)">
                                          <AtomNode start="(627, 36)" end="(627, 38)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(627, 39)" end="(627, 44)">
                                            <TacticTacticseq1IndentedNode start="(627, 39)" end="(627, 44)">
                                              <NullNode start="(627, 39)" end="(627, 44)">
                                                <OtherNode start="(627, 39)" end="(627, 44)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ j - 1 ≤ j - 1" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(627, 39)" end="(627, 44)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(627, 44)" end="(627, 45)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(627, 45)" end="(627, 46)" leading="" trailing=" " val=","/>
                                <OtherNode start="(627, 47)" end="(627, 90)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(627, 47)" end="(627, 90)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(627, 47)" end="(627, 76)" leading="" trailing=" " raw_val="take_eq_append_getElem_of_pos" val="take_eq_append_getElem_of_pos" full_name="List.take_eq_append_getElem_of_pos" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                    <NullNode start="(627, 77)" end="(627, 90)">
                                      <OtherNode start="(627, 77)" end="(627, 87)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(627, 77)" end="(627, 78)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(627, 78)" end="(627, 86)">
                                          <AtomNode start="(627, 78)" end="(627, 80)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(627, 81)" end="(627, 86)">
                                            <TacticTacticseq1IndentedNode start="(627, 81)" end="(627, 86)">
                                              <NullNode start="(627, 81)" end="(627, 86)">
                                                <OtherNode start="(627, 81)" end="(627, 86)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ 0 &amp;lt; j" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(627, 81)" end="(627, 86)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(627, 86)" end="(627, 87)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                      <IdentNode start="(627, 88)" end="(627, 90)" leading="" trailing="" raw_val="hj" val="hj"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(627, 90)" end="(627, 91)" leading="" trailing="&#10;      " val=","/>
                                <OtherNode start="(628, 7)" end="(628, 48)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(628, 7)" end="(628, 48)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(628, 7)" end="(628, 31)" leading="" trailing=" " raw_val="drop_append_of_le_length" val="drop_append_of_le_length" full_name="List.drop_append_of_le_length" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                    <NullNode start="(628, 32)" end="(628, 48)">
                                      <OtherNode start="(628, 32)" end="(628, 48)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(628, 32)" end="(628, 33)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(628, 33)" end="(628, 47)">
                                          <AtomNode start="(628, 33)" end="(628, 35)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(628, 36)" end="(628, 47)">
                                            <TacticTacticseq1IndentedNode start="(628, 36)" end="(628, 47)">
                                              <NullNode start="(628, 36)" end="(628, 47)">
                                                <OtherNode start="(628, 36)" end="(628, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ i ≤ (take (j - 1) l).length" state_after="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ i ≤ min (j - 1) l.length" tactic="simp">
                                                  <AtomNode start="(628, 36)" end="(628, 40)" leading="" trailing="" val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                                <AtomNode start="(628, 40)" end="(628, 41)" leading="" trailing=" " val=";"/>
                                                <OtherNode start="(628, 42)" end="(628, 47)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ i ≤ min (j - 1) l.length" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(628, 42)" end="(628, 47)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(628, 47)" end="(628, 48)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(628, 48)" end="(628, 49)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(629, 5)" end="(629, 78)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ take i (l.set (j - 1) l[j]) ++ l[j] :: (drop i (take (j - 1) l) ++ l[j - 1] :: drop (j + 1) l) =&#10;    take i l ++ l[j] :: (drop i (take (j - 1) l) ++ [l[j - 1]] ++ drop (j + 1) l)" state_after="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ take i (l.set (j - 1) l[j]) = take i l" tactic="simp only [append_assoc, cons_append, nil_append, append_cancel_right_eq]">
                            <AtomNode start="(629, 5)" end="(629, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(629, 10)" end="(629, 14)">
                              <AtomNode start="(629, 10)" end="(629, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(629, 15)" end="(629, 78)">
                              <AtomNode start="(629, 15)" end="(629, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(629, 16)" end="(629, 77)">
                                <OtherNode start="(629, 16)" end="(629, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(629, 16)" end="(629, 28)" leading="" trailing="" raw_val="append_assoc" val="append_assoc" full_name="List.append_assoc" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(629, 28)" end="(629, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(629, 30)" end="(629, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(629, 30)" end="(629, 41)" leading="" trailing="" raw_val="cons_append" val="cons_append" full_name="List.cons_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(629, 41)" end="(629, 42)" leading="" trailing=" " val=","/>
                                <OtherNode start="(629, 43)" end="(629, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(629, 43)" end="(629, 53)" leading="" trailing="" raw_val="nil_append" val="nil_append" full_name="List.nil_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(629, 53)" end="(629, 54)" leading="" trailing=" " val=","/>
                                <OtherNode start="(629, 55)" end="(629, 77)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(629, 55)" end="(629, 77)" leading="" trailing="" raw_val="append_cancel_right_eq" val="append_cancel_right_eq" full_name="List.append_cancel_right_eq" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(629, 77)" end="(629, 78)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(630, 5)" end="(632, 47)" kind="Lean.Parser.Tactic.cases" state_before="case isTrue&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : i &amp;lt; j&#10;w : j - 1 + 1 = j&#10;⊢ take i (l.set (j - 1) l[j]) = take i l" state_after="no goals" tactic="cases i with&#10;| zero =&amp;gt; simp&#10;| succ i =&amp;gt; rw [take_set_of_le (by omega)]">
                            <AtomNode start="(630, 5)" end="(630, 10)" leading="" trailing=" " val="cases"/>
                            <NullNode start="(630, 11)" end="(630, 12)">
                              <OtherNode start="(630, 11)" end="(630, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                <NullNode/>
                                <IdentNode start="(630, 11)" end="(630, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(630, 13)" end="(632, 47)">
                              <OtherNode start="(630, 13)" end="(632, 47)" kind="Lean.Parser.Tactic.inductionAlts">
                                <AtomNode start="(630, 13)" end="(630, 17)" leading="" trailing="&#10;    " val="with"/>
                                <NullNode/>
                                <NullNode start="(631, 5)" end="(632, 47)">
                                  <OtherNode start="(631, 5)" end="(631, 19)" kind="Lean.Parser.Tactic.inductionAlt">
                                    <NullNode start="(631, 5)" end="(631, 11)">
                                      <OtherNode start="(631, 5)" end="(631, 11)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                        <AtomNode start="(631, 5)" end="(631, 6)" leading="" trailing=" " val="|"/>
                                        <GroupNode start="(631, 7)" end="(631, 11)">
                                          <NullNode/>
                                          <IdentNode start="(631, 7)" end="(631, 11)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                        </GroupNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode start="(631, 12)" end="(631, 19)">
                                      <AtomNode start="(631, 12)" end="(631, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                                      <TacticTacticseqNode start="(631, 15)" end="(631, 19)">
                                        <TacticTacticseq1IndentedNode start="(631, 15)" end="(631, 19)">
                                          <NullNode start="(631, 15)" end="(631, 19)">
                                            <OtherNode start="(631, 15)" end="(631, 19)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.zero&#10;α : Type u_1&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;hj : j &amp;lt; l.length&#10;w : j - 1 + 1 = j&#10;h : 0 ≤ j&#10;h' : 0 &amp;lt; j&#10;⊢ take 0 (l.set (j - 1) l[j]) = take 0 l" state_after="no goals" tactic="simp">
                                              <AtomNode start="(631, 15)" end="(631, 19)" leading="" trailing="&#10;    " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </NullNode>
                                  </OtherNode>
                                  <OtherNode start="(632, 5)" end="(632, 47)" kind="Lean.Parser.Tactic.inductionAlt">
                                    <NullNode start="(632, 5)" end="(632, 13)">
                                      <OtherNode start="(632, 5)" end="(632, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                        <AtomNode start="(632, 5)" end="(632, 6)" leading="" trailing=" " val="|"/>
                                        <GroupNode start="(632, 7)" end="(632, 11)">
                                          <NullNode/>
                                          <IdentNode start="(632, 7)" end="(632, 11)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                        </GroupNode>
                                        <NullNode start="(632, 12)" end="(632, 13)">
                                          <IdentNode start="(632, 12)" end="(632, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode start="(632, 14)" end="(632, 47)">
                                      <AtomNode start="(632, 14)" end="(632, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                                      <TacticTacticseqNode start="(632, 17)" end="(632, 47)">
                                        <TacticTacticseq1IndentedNode start="(632, 17)" end="(632, 47)">
                                          <NullNode start="(632, 17)" end="(632, 47)">
                                            <OtherNode start="(632, 17)" end="(632, 47)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue.succ&#10;α : Type u_1&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;hj : j &amp;lt; l.length&#10;w : j - 1 + 1 = j&#10;i : Nat&#10;h : i + 1 ≤ j&#10;h' : i + 1 &amp;lt; j&#10;⊢ take (i + 1) (l.set (j - 1) l[j]) = take (i + 1) l" state_after="no goals" tactic="rw [take_set_of_le (by omega)]">
                                              <AtomNode start="(632, 17)" end="(632, 19)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(632, 20)" end="(632, 47)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(632, 20)" end="(632, 21)" leading="" trailing="" val="["/>
                                                <NullNode start="(632, 21)" end="(632, 46)">
                                                  <OtherNode start="(632, 21)" end="(632, 46)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <OtherNode start="(632, 21)" end="(632, 46)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(632, 21)" end="(632, 35)" leading="" trailing=" " raw_val="take_set_of_le" val="take_set_of_le" full_name="List.take_set_of_le" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                                      <NullNode start="(632, 36)" end="(632, 46)">
                                                        <OtherNode start="(632, 36)" end="(632, 46)" kind="Lean.Parser.Term.paren">
                                                          <AtomNode start="(632, 36)" end="(632, 37)" leading="" trailing="" val="("/>
                                                          <TermBytacticNode start="(632, 37)" end="(632, 45)">
                                                            <AtomNode start="(632, 37)" end="(632, 39)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(632, 40)" end="(632, 45)">
                                                            <TacticTacticseq1IndentedNode start="(632, 40)" end="(632, 45)">
                                                            <NullNode start="(632, 40)" end="(632, 45)">
                                                            <OtherNode start="(632, 40)" end="(632, 45)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;hj : j &amp;lt; l.length&#10;w : j - 1 + 1 = j&#10;i : Nat&#10;h : i + 1 ≤ j&#10;h' : i + 1 &amp;lt; j&#10;⊢ i + 1 ≤ j - 1" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(632, 40)" end="(632, 45)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </TermBytacticNode>
                                                          <AtomNode start="(632, 45)" end="(632, 46)" leading="" trailing="" val=")"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(632, 46)" end="(632, 47)" leading="" trailing="&#10;  " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(633, 3)" end="(636, 9)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : ¬i &amp;lt; ↑⟨j, hj✝⟩&#10;⊢ l.toArray = (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" state_after="no goals" tactic="· simp only [Nat.not_lt] at h'&#10;  have : i = j := by omega&#10;  subst this&#10;  simp">
                    <OtherNode start="(633, 3)" end="(633, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(633, 3)" end="(633, 4)" kind="patternIgnore">
                        <OtherNode start="(633, 3)" end="(633, 4)" kind="token.«· »">
                          <AtomNode start="(633, 3)" end="(633, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(633, 5)" end="(636, 9)">
                      <TacticTacticseq1IndentedNode start="(633, 5)" end="(636, 9)">
                        <NullNode start="(633, 5)" end="(636, 9)">
                          <OtherNode start="(633, 5)" end="(633, 33)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : ¬i &amp;lt; ↑⟨j, hj✝⟩&#10;⊢ l.toArray = (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" state_after="case isFalse&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : j ≤ i&#10;⊢ l.toArray = (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" tactic="simp only [Nat.not_lt] at h'">
                            <AtomNode start="(633, 5)" end="(633, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(633, 10)" end="(633, 14)">
                              <AtomNode start="(633, 10)" end="(633, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(633, 15)" end="(633, 27)">
                              <AtomNode start="(633, 15)" end="(633, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(633, 16)" end="(633, 26)">
                                <OtherNode start="(633, 16)" end="(633, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(633, 16)" end="(633, 26)" leading="" trailing="" raw_val="Nat.not_lt" val="Nat.not_lt" full_name="Nat.not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(633, 26)" end="(633, 27)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(633, 28)" end="(633, 33)">
                              <OtherNode start="(633, 28)" end="(633, 33)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(633, 28)" end="(633, 30)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(633, 31)" end="(633, 33)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(633, 31)" end="(633, 33)">
                                    <IdentNode start="(633, 31)" end="(633, 33)" leading="" trailing="&#10;    " raw_val="h'" val="h'"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(634, 5)" end="(634, 29)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case isFalse&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : j ≤ i&#10;⊢ l.toArray = (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" state_after="case isFalse&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : j ≤ i&#10;this : i = j&#10;⊢ l.toArray = (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" tactic="have : i = j := by omega">
                            <AtomNode start="(634, 5)" end="(634, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(634, 10)" end="(634, 29)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(634, 10)" end="(634, 29)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(634, 10)" end="(634, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(634, 10)" end="(634, 10)" kind="hygieneInfo">
                                    <IdentNode start="(634, 10)" end="(634, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(634, 10)" end="(634, 17)">
                                  <TermTypespecNode start="(634, 10)" end="(634, 17)">
                                    <AtomNode start="(634, 10)" end="(634, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(634, 12)" end="(634, 17)" kind="«term_=_»">
                                      <IdentNode start="(634, 12)" end="(634, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                                      <AtomNode start="(634, 14)" end="(634, 15)" leading="" trailing=" " val="="/>
                                      <IdentNode start="(634, 16)" end="(634, 17)" leading="" trailing=" " raw_val="j" val="j"/>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(634, 18)" end="(634, 20)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(634, 21)" end="(634, 29)">
                                  <AtomNode start="(634, 21)" end="(634, 23)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(634, 24)" end="(634, 29)">
                                    <TacticTacticseq1IndentedNode start="(634, 24)" end="(634, 29)">
                                      <NullNode start="(634, 24)" end="(634, 29)">
                                        <OtherNode start="(634, 24)" end="(634, 29)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : j ≤ i&#10;⊢ i = j" state_after="no goals" tactic="omega">
                                          <AtomNode start="(634, 24)" end="(634, 29)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(635, 5)" end="(635, 15)" kind="Lean.Parser.Tactic.subst" state_before="case isFalse&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;hj✝ : j &amp;lt; l.toArray.size&#10;h : i ≤ j&#10;hj : j &amp;lt; l.length&#10;h' : j ≤ i&#10;this : i = j&#10;⊢ l.toArray = (take i l ++ l[j] :: drop i (take j l) ++ drop (j + 1) l).toArray" state_after="case isFalse&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;hj✝ : i &amp;lt; l.toArray.size&#10;h : i ≤ i&#10;hj : i &amp;lt; l.length&#10;h' : i ≤ i&#10;⊢ l.toArray = (take i l ++ l[i] :: drop i (take i l) ++ drop (i + 1) l).toArray" tactic="subst this">
                            <AtomNode start="(635, 5)" end="(635, 10)" leading="" trailing=" " val="subst"/>
                            <NullNode start="(635, 11)" end="(635, 15)">
                              <IdentNode start="(635, 11)" end="(635, 15)" leading="" trailing="&#10;    " raw_val="this" val="this"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(636, 5)" end="(636, 9)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;hj✝ : i &amp;lt; l.toArray.size&#10;h : i ≤ i&#10;hj : i &amp;lt; l.length&#10;h' : i ≤ i&#10;⊢ l.toArray = (take i l ++ l[i] :: drop i (take i l) ++ drop (i + 1) l).toArray" state_after="no goals" tactic="simp">
                            <AtomNode start="(636, 5)" end="(636, 9)" leading="" trailing="&#10;&#10;" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(638, 1)" end="(659, 14)" name="insertIdx_toArray" full_name="List.insertIdx_toArray">
      <CommandDeclmodifiersNode start="(638, 1)" end="(638, 8)">
        <NullNode/>
        <NullNode start="(638, 1)" end="(638, 8)">
          <OtherNode start="(638, 1)" end="(638, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(638, 1)" end="(638, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(638, 3)" end="(638, 7)">
              <OtherNode start="(638, 3)" end="(638, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(638, 3)" end="(638, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(638, 3)" end="(638, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(638, 7)" end="(638, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(638, 9)" end="(659, 14)" name="insertIdx_toArray" full_name="List.insertIdx_toArray" _is_private_decl="False">
        <AtomNode start="(638, 9)" end="(638, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(638, 17)" end="(638, 34)">
          <IdentNode start="(638, 17)" end="(638, 34)" leading="" trailing=" " raw_val="insertIdx_toArray" val="insertIdx_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(638, 35)" end="(639, 56)">
          <NullNode start="(638, 35)" end="(638, 90)">
            <TermExplicitbinderNode start="(638, 35)" end="(638, 47)">
              <AtomNode start="(638, 35)" end="(638, 36)" leading="" trailing="" val="("/>
              <NullNode start="(638, 36)" end="(638, 37)">
                <IdentNode start="(638, 36)" end="(638, 37)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(638, 38)" end="(638, 46)">
                <AtomNode start="(638, 38)" end="(638, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(638, 40)" end="(638, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(638, 40)" end="(638, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(638, 45)" end="(638, 46)">
                    <IdentNode start="(638, 45)" end="(638, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(638, 46)" end="(638, 47)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(638, 48)" end="(638, 57)">
              <AtomNode start="(638, 48)" end="(638, 49)" leading="" trailing="" val="("/>
              <NullNode start="(638, 49)" end="(638, 50)">
                <IdentNode start="(638, 49)" end="(638, 50)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(638, 51)" end="(638, 56)">
                <AtomNode start="(638, 51)" end="(638, 52)" leading="" trailing=" " val=":"/>
                <IdentNode start="(638, 53)" end="(638, 56)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(638, 56)" end="(638, 57)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(638, 58)" end="(638, 65)">
              <AtomNode start="(638, 58)" end="(638, 59)" leading="" trailing="" val="("/>
              <NullNode start="(638, 59)" end="(638, 60)">
                <IdentNode start="(638, 59)" end="(638, 60)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(638, 61)" end="(638, 64)">
                <AtomNode start="(638, 61)" end="(638, 62)" leading="" trailing=" " val=":"/>
                <IdentNode start="(638, 63)" end="(638, 64)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(638, 64)" end="(638, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(638, 66)" end="(638, 90)">
              <AtomNode start="(638, 66)" end="(638, 67)" leading="" trailing="" val="("/>
              <NullNode start="(638, 67)" end="(638, 68)">
                <IdentNode start="(638, 67)" end="(638, 68)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(638, 69)" end="(638, 89)">
                <AtomNode start="(638, 69)" end="(638, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(638, 71)" end="(638, 89)" kind="«term_≤_»">
                  <IdentNode start="(638, 71)" end="(638, 72)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(638, 73)" end="(638, 74)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(638, 75)" end="(638, 89)" leading="" trailing="" raw_val="l.toArray.size" val="l.toArray.size"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(638, 89)" end="(638, 90)" leading="" trailing="" val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(638, 90)" end="(639, 56)">
            <AtomNode start="(638, 90)" end="(638, 91)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(639, 5)" end="(639, 56)" kind="«term_=_»">
              <OtherNode start="(639, 5)" end="(639, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(639, 5)" end="(639, 24)" leading="" trailing=" " raw_val="l.toArray.insertIdx" val="l.toArray.insertIdx"/>
                <NullNode start="(639, 25)" end="(639, 28)">
                  <IdentNode start="(639, 25)" end="(639, 26)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(639, 27)" end="(639, 28)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(639, 29)" end="(639, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(639, 31)" end="(639, 56)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(639, 31)" end="(639, 48)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(639, 31)" end="(639, 32)" leading="" trailing="" val="("/>
                  <OtherNode start="(639, 32)" end="(639, 47)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(639, 32)" end="(639, 43)" leading="" trailing=" " raw_val="l.insertIdx" val="l.insertIdx"/>
                    <NullNode start="(639, 44)" end="(639, 47)">
                      <IdentNode start="(639, 44)" end="(639, 45)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(639, 46)" end="(639, 47)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(639, 47)" end="(639, 48)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(639, 48)" end="(639, 49)" leading="" trailing="" val="."/>
                <IdentNode start="(639, 49)" end="(639, 56)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(639, 57)" end="(659, 14)">
          <AtomNode start="(639, 57)" end="(639, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(639, 60)" end="(659, 14)">
            <AtomNode start="(639, 60)" end="(639, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(640, 3)" end="(659, 14)">
              <TacticTacticseq1IndentedNode start="(640, 3)" end="(659, 14)">
                <NullNode start="(640, 3)" end="(659, 14)">
                  <OtherNode start="(640, 3)" end="(640, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;⊢ l.toArray.insertIdx i a h = (l.insertIdx i a).toArray" state_after="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;⊢ insertIdx.loop i (l.toArray.push a) ⟨l.toArray.size, ⋯⟩ = (l.insertIdx i a).toArray" tactic="rw [Array.insertIdx]">
                    <AtomNode start="(640, 3)" end="(640, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(640, 6)" end="(640, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(640, 6)" end="(640, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(640, 7)" end="(640, 22)">
                        <OtherNode start="(640, 7)" end="(640, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(640, 7)" end="(640, 22)" leading="" trailing="" raw_val="Array.insertIdx" val="Array.insertIdx" full_name="Array.insertIdx" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(640, 22)" end="(640, 23)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(641, 3)" end="(641, 39)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;⊢ insertIdx.loop i (l.toArray.push a) ⟨l.toArray.size, ⋯⟩ = (l.insertIdx i a).toArray" state_after="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;⊢ (take i (l.toArray.push a).toList ++&#10;          (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;        drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray =&#10;    (l.insertIdx i a).toArray" tactic="rw [insertIdx_loop_toArray (h := h)]">
                    <AtomNode start="(641, 3)" end="(641, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(641, 6)" end="(641, 39)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(641, 6)" end="(641, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(641, 7)" end="(641, 38)">
                        <OtherNode start="(641, 7)" end="(641, 38)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(641, 7)" end="(641, 38)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(641, 7)" end="(641, 29)" leading="" trailing=" " raw_val="insertIdx_loop_toArray" val="insertIdx_loop_toArray" full_name="_private.Init.Data.List.ToArray.0.List.insertIdx_loop_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(614, 17)" def_end="(614, 39)"/>
                            <NullNode start="(641, 30)" end="(641, 38)">
                              <OtherNode start="(641, 30)" end="(641, 38)" kind="Lean.Parser.Term.namedArgument">
                                <AtomNode start="(641, 30)" end="(641, 31)" leading="" trailing="" val="("/>
                                <IdentNode start="(641, 31)" end="(641, 32)" leading="" trailing=" " raw_val="h" val="h"/>
                                <AtomNode start="(641, 33)" end="(641, 35)" leading="" trailing=" " val=":="/>
                                <IdentNode start="(641, 36)" end="(641, 37)" leading="" trailing="" raw_val="h" val="h"/>
                                <AtomNode start="(641, 37)" end="(641, 38)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(641, 38)" end="(641, 39)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(642, 3)" end="(642, 14)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;⊢ (take i (l.toArray.push a).toList ++&#10;          (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;        drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray =&#10;    (l.insertIdx i a).toArray" state_after="case h₁&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;⊢ (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size =&#10;    (l.insertIdx i a).toArray.size&#10;&#10;case h₂&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;⊢ (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray[j] =&#10;    (l.insertIdx i a).toArray[j]" tactic="ext j h₁ h₂">
                    <AtomNode start="(642, 3)" end="(642, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(642, 7)" end="(642, 14)">
                      <OtherNode start="(642, 7)" end="(642, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(642, 7)" end="(642, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(642, 7)" end="(642, 8)" leading="" trailing=" " raw_val="j" val="j"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(642, 9)" end="(642, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(642, 9)" end="(642, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(642, 9)" end="(642, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(642, 12)" end="(642, 14)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(642, 12)" end="(642, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(642, 12)" end="(642, 14)" leading="" trailing="&#10;  " raw_val="h₂" val="h₂"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(643, 3)" end="(645, 10)" kind="Lean.cdot" state_before="case h₁&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;⊢ (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size =&#10;    (l.insertIdx i a).toArray.size&#10;&#10;case h₂&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;⊢ (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray[j] =&#10;    (l.insertIdx i a).toArray[j]" state_after="case h₂&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;⊢ (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray[j] =&#10;    (l.insertIdx i a).toArray[j]" tactic="· simp at h&#10;  simp [length_insertIdx, h]&#10;  omega">
                    <OtherNode start="(643, 3)" end="(643, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(643, 3)" end="(643, 4)" kind="patternIgnore">
                        <OtherNode start="(643, 3)" end="(643, 4)" kind="token.«· »">
                          <AtomNode start="(643, 3)" end="(643, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(643, 5)" end="(645, 10)">
                      <TacticTacticseq1IndentedNode start="(643, 5)" end="(645, 10)">
                        <NullNode start="(643, 5)" end="(645, 10)">
                          <OtherNode start="(643, 5)" end="(643, 14)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;⊢ (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size =&#10;    (l.insertIdx i a).toArray.size" state_after="case h₁&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.length&#10;⊢ (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size =&#10;    (l.insertIdx i a).toArray.size" tactic="simp at h">
                            <AtomNode start="(643, 5)" end="(643, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(643, 10)" end="(643, 14)">
                              <OtherNode start="(643, 10)" end="(643, 14)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(643, 10)" end="(643, 12)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(643, 13)" end="(643, 14)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(643, 13)" end="(643, 14)">
                                    <IdentNode start="(643, 13)" end="(643, 14)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(644, 5)" end="(644, 31)" kind="Lean.Parser.Tactic.simp" state_before="case h₁&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.length&#10;⊢ (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size =&#10;    (l.insertIdx i a).toArray.size" state_after="case h₁&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.length&#10;⊢ min i (l.length + 1) + (l.length - i + 1) = l.length + 1" tactic="simp [length_insertIdx, h]">
                            <AtomNode start="(644, 5)" end="(644, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(644, 10)" end="(644, 31)">
                              <AtomNode start="(644, 10)" end="(644, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(644, 11)" end="(644, 30)">
                                <OtherNode start="(644, 11)" end="(644, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(644, 11)" end="(644, 27)" leading="" trailing="" raw_val="length_insertIdx" val="length_insertIdx" full_name="List.length_insertIdx" mod_name="Init.Data.List.Nat.InsertIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/InsertIdx.lean"/>
                                </OtherNode>
                                <AtomNode start="(644, 27)" end="(644, 28)" leading="" trailing=" " val=","/>
                                <OtherNode start="(644, 29)" end="(644, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(644, 29)" end="(644, 30)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(644, 30)" end="(644, 31)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(645, 5)" end="(645, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h₁&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.length&#10;⊢ min i (l.length + 1) + (l.length - i + 1) = l.length + 1" state_after="no goals" tactic="omega">
                            <AtomNode start="(645, 5)" end="(645, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(646, 3)" end="(659, 14)" kind="Lean.cdot" state_before="case h₂&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;⊢ (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray[j] =&#10;    (l.insertIdx i a).toArray[j]" state_after="no goals" tactic="· simp [length_insertIdx] at h₁ h₂&#10;  simp [getElem_insertIdx]&#10;  split &amp;lt;;&amp;gt; rename_i h₃&#10;  · rw [getElem_append_left (by simp; split at h₂ &amp;lt;;&amp;gt; omega)]&#10;    simp only [getElem_take]&#10;    rw [getElem_append_left]&#10;  · rw [getElem_append_right (by simp; omega)]&#10;    rw [getElem_cons]&#10;    simp&#10;    split &amp;lt;;&amp;gt; rename_i h₄&#10;    · rw [dif_pos (by omega)]&#10;    · rw [dif_neg (by omega)]&#10;      congr&#10;      omega">
                    <OtherNode start="(646, 3)" end="(646, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(646, 3)" end="(646, 4)" kind="patternIgnore">
                        <OtherNode start="(646, 3)" end="(646, 4)" kind="token.«· »">
                          <AtomNode start="(646, 3)" end="(646, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(646, 5)" end="(659, 14)">
                      <TacticTacticseq1IndentedNode start="(646, 5)" end="(659, 14)">
                        <NullNode start="(646, 5)" end="(659, 14)">
                          <OtherNode start="(646, 5)" end="(646, 37)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;⊢ (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray[j] =&#10;    (l.insertIdx i a).toArray[j]" state_after="case h₂&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;⊢ (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray[j] =&#10;    (l.insertIdx i a).toArray[j]" tactic="simp [length_insertIdx] at h₁ h₂">
                            <AtomNode start="(646, 5)" end="(646, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(646, 10)" end="(646, 28)">
                              <AtomNode start="(646, 10)" end="(646, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(646, 11)" end="(646, 27)">
                                <OtherNode start="(646, 11)" end="(646, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(646, 11)" end="(646, 27)" leading="" trailing="" raw_val="length_insertIdx" val="length_insertIdx" full_name="List.length_insertIdx" mod_name="Init.Data.List.Nat.InsertIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/InsertIdx.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(646, 27)" end="(646, 28)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(646, 29)" end="(646, 37)">
                              <OtherNode start="(646, 29)" end="(646, 37)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(646, 29)" end="(646, 31)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(646, 32)" end="(646, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(646, 32)" end="(646, 37)">
                                    <IdentNode start="(646, 32)" end="(646, 34)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(646, 35)" end="(646, 37)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(647, 5)" end="(647, 29)" kind="Lean.Parser.Tactic.simp" state_before="case h₂&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;⊢ (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray[j] =&#10;    (l.insertIdx i a).toArray[j]" state_after="case h₂&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;⊢ (take i (l ++ [a]) ++ a :: drop i l)[j] = if h₁ : j &amp;lt; i then l[j] else if h₂ : j = i then a else l[j - 1]" tactic="simp [getElem_insertIdx]">
                            <AtomNode start="(647, 5)" end="(647, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(647, 10)" end="(647, 29)">
                              <AtomNode start="(647, 10)" end="(647, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(647, 11)" end="(647, 28)">
                                <OtherNode start="(647, 11)" end="(647, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(647, 11)" end="(647, 28)" leading="" trailing="" raw_val="getElem_insertIdx" val="getElem_insertIdx" full_name="List.getElem_insertIdx" mod_name="Init.Data.List.Nat.InsertIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/InsertIdx.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(647, 28)" end="(647, 29)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(648, 5)" end="(648, 26)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h₂&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;⊢ (take i (l ++ [a]) ++ a :: drop i l)[j] = if h₁ : j &amp;lt; i then l[j] else if h₂ : j = i then a else l[j - 1]" state_after="case h₂.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : j &amp;lt; i&#10;⊢ (take i (l ++ [a]) ++ a :: drop i l)[j] = l[j]&#10;&#10;case h₂.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;⊢ (take i (l ++ [a]) ++ a :: drop i l)[j] = if h₂ : j = i then a else l[j - 1]" tactic="split &amp;lt;;&amp;gt; rename_i h₃">
                            <OtherNode start="(648, 5)" end="(648, 10)" kind="Lean.Parser.Tactic.split">
                              <AtomNode start="(648, 5)" end="(648, 10)" leading="" trailing=" " val="split"/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(648, 11)" end="(648, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(648, 15)" end="(648, 26)" kind="Lean.Parser.Tactic.renameI">
                              <AtomNode start="(648, 15)" end="(648, 23)" leading="" trailing=" " val="rename_i"/>
                              <NullNode start="(648, 24)" end="(648, 26)">
                                <LeanBinderidentNode start="(648, 24)" end="(648, 26)">
                                  <IdentNode start="(648, 24)" end="(648, 26)" leading="" trailing="&#10;    " raw_val="h₃" val="h₃"/>
                                </LeanBinderidentNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(649, 5)" end="(651, 31)" kind="Lean.cdot" state_before="case h₂.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : j &amp;lt; i&#10;⊢ (take i (l ++ [a]) ++ a :: drop i l)[j] = l[j]&#10;&#10;case h₂.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;⊢ (take i (l ++ [a]) ++ a :: drop i l)[j] = if h₂ : j = i then a else l[j - 1]" state_after="case h₂.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;⊢ (take i (l ++ [a]) ++ a :: drop i l)[j] = if h₂ : j = i then a else l[j - 1]" tactic="· rw [getElem_append_left (by simp; split at h₂ &amp;lt;;&amp;gt; omega)]&#10;  simp only [getElem_take]&#10;  rw [getElem_append_left]">
                            <OtherNode start="(649, 5)" end="(649, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(649, 5)" end="(649, 6)" kind="patternIgnore">
                                <OtherNode start="(649, 5)" end="(649, 6)" kind="token.«· »">
                                  <AtomNode start="(649, 5)" end="(649, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(649, 7)" end="(651, 31)">
                              <TacticTacticseq1IndentedNode start="(649, 7)" end="(651, 31)">
                                <NullNode start="(649, 7)" end="(651, 31)">
                                  <OtherNode start="(649, 7)" end="(649, 64)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h₂.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : j &amp;lt; i&#10;⊢ (take i (l ++ [a]) ++ a :: drop i l)[j] = l[j]" state_after="case h₂.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : j &amp;lt; i&#10;⊢ (take i (l ++ [a]))[j] = l[j]" tactic="rw [getElem_append_left (by simp; split at h₂ &amp;lt;;&amp;gt; omega)]">
                                    <AtomNode start="(649, 7)" end="(649, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(649, 10)" end="(649, 64)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(649, 10)" end="(649, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(649, 11)" end="(649, 63)">
                                        <OtherNode start="(649, 11)" end="(649, 63)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <OtherNode start="(649, 11)" end="(649, 63)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(649, 11)" end="(649, 30)" leading="" trailing=" " raw_val="getElem_append_left" val="getElem_append_left" full_name="List.getElem_append_left" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                                            <NullNode start="(649, 31)" end="(649, 63)">
                                              <OtherNode start="(649, 31)" end="(649, 63)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(649, 31)" end="(649, 32)" leading="" trailing="" val="("/>
                                                <TermBytacticNode start="(649, 32)" end="(649, 62)">
                                                  <AtomNode start="(649, 32)" end="(649, 34)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(649, 35)" end="(649, 62)">
                                                    <TacticTacticseq1IndentedNode start="(649, 35)" end="(649, 62)">
                                                      <NullNode start="(649, 35)" end="(649, 62)">
                                                        <OtherNode start="(649, 35)" end="(649, 39)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : j &amp;lt; i&#10;⊢ j &amp;lt; (take i (l ++ [a])).length" state_after="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : j &amp;lt; i&#10;⊢ j &amp;lt; min i (l.length + 1)" tactic="simp">
                                                          <AtomNode start="(649, 35)" end="(649, 39)" leading="" trailing="" val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(649, 39)" end="(649, 40)" leading="" trailing=" " val=";"/>
                                                        <OtherNode start="(649, 41)" end="(649, 62)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : j &amp;lt; i&#10;⊢ j &amp;lt; min i (l.length + 1)" state_after="no goals" tactic="split at h₂ &amp;lt;;&amp;gt; omega">
                                                          <OtherNode start="(649, 41)" end="(649, 52)" kind="Lean.Parser.Tactic.split">
                                                            <AtomNode start="(649, 41)" end="(649, 46)" leading="" trailing=" " val="split"/>
                                                            <NullNode/>
                                                            <NullNode start="(649, 47)" end="(649, 52)">
                                                            <OtherNode start="(649, 47)" end="(649, 52)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(649, 47)" end="(649, 49)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(649, 50)" end="(649, 52)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(649, 50)" end="(649, 52)">
                                                            <IdentNode start="(649, 50)" end="(649, 52)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <AtomNode start="(649, 53)" end="(649, 56)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                          <OtherNode start="(649, 57)" end="(649, 62)" kind="Lean.Parser.Tactic.omega">
                                                            <AtomNode start="(649, 57)" end="(649, 62)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                                <AtomNode start="(649, 62)" end="(649, 63)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(649, 63)" end="(649, 64)" leading="" trailing="&#10;      " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(650, 7)" end="(650, 31)" kind="Lean.Parser.Tactic.simp" state_before="case h₂.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : j &amp;lt; i&#10;⊢ (take i (l ++ [a]))[j] = l[j]" state_after="case h₂.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : j &amp;lt; i&#10;⊢ (l ++ [a])[j] = l[j]" tactic="simp only [getElem_take]">
                                    <AtomNode start="(650, 7)" end="(650, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(650, 12)" end="(650, 16)">
                                      <AtomNode start="(650, 12)" end="(650, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(650, 17)" end="(650, 31)">
                                      <AtomNode start="(650, 17)" end="(650, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(650, 18)" end="(650, 30)">
                                        <OtherNode start="(650, 18)" end="(650, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(650, 18)" end="(650, 30)" leading="" trailing="" raw_val="getElem_take" val="getElem_take" full_name="List.getElem_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(650, 30)" end="(650, 31)" leading="" trailing="&#10;      " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(651, 7)" end="(651, 31)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h₂.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : j &amp;lt; i&#10;⊢ (l ++ [a])[j] = l[j]" state_after="no goals" tactic="rw [getElem_append_left]">
                                    <AtomNode start="(651, 7)" end="(651, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(651, 10)" end="(651, 31)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(651, 10)" end="(651, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(651, 11)" end="(651, 30)">
                                        <OtherNode start="(651, 11)" end="(651, 30)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(651, 11)" end="(651, 30)" leading="" trailing="" raw_val="getElem_append_left" val="getElem_append_left" full_name="List.getElem_append_left" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(651, 30)" end="(651, 31)" leading="" trailing="&#10;    " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(652, 5)" end="(659, 14)" kind="Lean.cdot" state_before="case h₂.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;⊢ (take i (l ++ [a]) ++ a :: drop i l)[j] = if h₂ : j = i then a else l[j - 1]" state_after="no goals" tactic="· rw [getElem_append_right (by simp; omega)]&#10;  rw [getElem_cons]&#10;  simp&#10;  split &amp;lt;;&amp;gt; rename_i h₄&#10;  · rw [dif_pos (by omega)]&#10;  · rw [dif_neg (by omega)]&#10;    congr&#10;    omega">
                            <OtherNode start="(652, 5)" end="(652, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(652, 5)" end="(652, 6)" kind="patternIgnore">
                                <OtherNode start="(652, 5)" end="(652, 6)" kind="token.«· »">
                                  <AtomNode start="(652, 5)" end="(652, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(652, 7)" end="(659, 14)">
                              <TacticTacticseq1IndentedNode start="(652, 7)" end="(659, 14)">
                                <NullNode start="(652, 7)" end="(659, 14)">
                                  <OtherNode start="(652, 7)" end="(652, 49)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h₂.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;⊢ (take i (l ++ [a]) ++ a :: drop i l)[j] = if h₂ : j = i then a else l[j - 1]" state_after="case h₂.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;⊢ (a :: drop i l)[j - (take i (l ++ [a])).length] = if h₂ : j = i then a else l[j - 1]" tactic="rw [getElem_append_right (by simp; omega)]">
                                    <AtomNode start="(652, 7)" end="(652, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(652, 10)" end="(652, 49)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(652, 10)" end="(652, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(652, 11)" end="(652, 48)">
                                        <OtherNode start="(652, 11)" end="(652, 48)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <OtherNode start="(652, 11)" end="(652, 48)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(652, 11)" end="(652, 31)" leading="" trailing=" " raw_val="getElem_append_right" val="getElem_append_right" full_name="List.getElem_append_right" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                                            <NullNode start="(652, 32)" end="(652, 48)">
                                              <OtherNode start="(652, 32)" end="(652, 48)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(652, 32)" end="(652, 33)" leading="" trailing="" val="("/>
                                                <TermBytacticNode start="(652, 33)" end="(652, 47)">
                                                  <AtomNode start="(652, 33)" end="(652, 35)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(652, 36)" end="(652, 47)">
                                                    <TacticTacticseq1IndentedNode start="(652, 36)" end="(652, 47)">
                                                      <NullNode start="(652, 36)" end="(652, 47)">
                                                        <OtherNode start="(652, 36)" end="(652, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;⊢ (take i (l ++ [a])).length ≤ j" state_after="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;⊢ min i (l.length + 1) ≤ j" tactic="simp">
                                                          <AtomNode start="(652, 36)" end="(652, 40)" leading="" trailing="" val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(652, 40)" end="(652, 41)" leading="" trailing=" " val=";"/>
                                                        <OtherNode start="(652, 42)" end="(652, 47)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;⊢ min i (l.length + 1) ≤ j" state_after="no goals" tactic="omega">
                                                          <AtomNode start="(652, 42)" end="(652, 47)" leading="" trailing="" val="omega"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                                <AtomNode start="(652, 47)" end="(652, 48)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(652, 48)" end="(652, 49)" leading="" trailing="&#10;      " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(653, 7)" end="(653, 24)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h₂.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;⊢ (a :: drop i l)[j - (take i (l ++ [a])).length] = if h₂ : j = i then a else l[j - 1]" state_after="case h₂.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;⊢ (if h : j - (take i (l ++ [a])).length = 0 then a else (drop i l)[j - (take i (l ++ [a])).length - 1]) =&#10;    if h₂ : j = i then a else l[j - 1]" tactic="rw [getElem_cons]">
                                    <AtomNode start="(653, 7)" end="(653, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(653, 10)" end="(653, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(653, 10)" end="(653, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(653, 11)" end="(653, 23)">
                                        <OtherNode start="(653, 11)" end="(653, 23)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(653, 11)" end="(653, 23)" leading="" trailing="" raw_val="getElem_cons" val="getElem_cons" full_name="List.getElem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(653, 23)" end="(653, 24)" leading="" trailing="&#10;      " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(654, 7)" end="(654, 11)" kind="Lean.Parser.Tactic.simp" state_before="case h₂.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;⊢ (if h : j - (take i (l ++ [a])).length = 0 then a else (drop i l)[j - (take i (l ++ [a])).length - 1]) =&#10;    if h₂ : j = i then a else l[j - 1]" state_after="case h₂.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;⊢ (if h : j - min i (l.length + 1) = 0 then a else l[i + (j - min i (l.length + 1) - 1)]) =&#10;    if h₂ : j = i then a else l[j - 1]" tactic="simp">
                                    <AtomNode start="(654, 7)" end="(654, 11)" leading="" trailing="&#10;      " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(655, 7)" end="(655, 28)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h₂.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;⊢ (if h : j - min i (l.length + 1) = 0 then a else l[i + (j - min i (l.length + 1) - 1)]) =&#10;    if h₂ : j = i then a else l[j - 1]" state_after="case h₂.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;h₄ : j - min i (l.length + 1) = 0&#10;⊢ a = if h₂ : j = i then a else l[j - 1]&#10;&#10;case h₂.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;h₄ : ¬j - min i (l.length + 1) = 0&#10;⊢ l[i + (j - min i (l.length + 1) - 1)] = if h₂ : j = i then a else l[j - 1]" tactic="split &amp;lt;;&amp;gt; rename_i h₄">
                                    <OtherNode start="(655, 7)" end="(655, 12)" kind="Lean.Parser.Tactic.split">
                                      <AtomNode start="(655, 7)" end="(655, 12)" leading="" trailing=" " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(655, 13)" end="(655, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                    <OtherNode start="(655, 17)" end="(655, 28)" kind="Lean.Parser.Tactic.renameI">
                                      <AtomNode start="(655, 17)" end="(655, 25)" leading="" trailing=" " val="rename_i"/>
                                      <NullNode start="(655, 26)" end="(655, 28)">
                                        <LeanBinderidentNode start="(655, 26)" end="(655, 28)">
                                          <IdentNode start="(655, 26)" end="(655, 28)" leading="" trailing="&#10;      " raw_val="h₄" val="h₄"/>
                                        </LeanBinderidentNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(656, 7)" end="(656, 32)" kind="Lean.cdot" state_before="case h₂.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;h₄ : j - min i (l.length + 1) = 0&#10;⊢ a = if h₂ : j = i then a else l[j - 1]&#10;&#10;case h₂.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;h₄ : ¬j - min i (l.length + 1) = 0&#10;⊢ l[i + (j - min i (l.length + 1) - 1)] = if h₂ : j = i then a else l[j - 1]" state_after="case h₂.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;h₄ : ¬j - min i (l.length + 1) = 0&#10;⊢ l[i + (j - min i (l.length + 1) - 1)] = if h₂ : j = i then a else l[j - 1]" tactic="· rw [dif_pos (by omega)]">
                                    <OtherNode start="(656, 7)" end="(656, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(656, 7)" end="(656, 8)" kind="patternIgnore">
                                        <OtherNode start="(656, 7)" end="(656, 8)" kind="token.«· »">
                                          <AtomNode start="(656, 7)" end="(656, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(656, 9)" end="(656, 32)">
                                      <TacticTacticseq1IndentedNode start="(656, 9)" end="(656, 32)">
                                        <NullNode start="(656, 9)" end="(656, 32)">
                                          <OtherNode start="(656, 9)" end="(656, 32)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h₂.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;h₄ : j - min i (l.length + 1) = 0&#10;⊢ a = if h₂ : j = i then a else l[j - 1]" state_after="no goals" tactic="rw [dif_pos (by omega)]">
                                            <AtomNode start="(656, 9)" end="(656, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(656, 12)" end="(656, 32)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(656, 12)" end="(656, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(656, 13)" end="(656, 31)">
                                                <OtherNode start="(656, 13)" end="(656, 31)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(656, 13)" end="(656, 31)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(656, 13)" end="(656, 20)" leading="" trailing=" " raw_val="dif_pos" val="dif_pos" full_name="dif_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                    <NullNode start="(656, 21)" end="(656, 31)">
                                                      <OtherNode start="(656, 21)" end="(656, 31)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(656, 21)" end="(656, 22)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(656, 22)" end="(656, 30)">
                                                          <AtomNode start="(656, 22)" end="(656, 24)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(656, 25)" end="(656, 30)">
                                                            <TacticTacticseq1IndentedNode start="(656, 25)" end="(656, 30)">
                                                            <NullNode start="(656, 25)" end="(656, 30)">
                                                            <OtherNode start="(656, 25)" end="(656, 30)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;h₄ : j - min i (l.length + 1) = 0&#10;⊢ j = i" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(656, 25)" end="(656, 30)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(656, 30)" end="(656, 31)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(656, 31)" end="(656, 32)" leading="" trailing="&#10;      " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(657, 7)" end="(659, 14)" kind="Lean.cdot" state_before="case h₂.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;h₄ : ¬j - min i (l.length + 1) = 0&#10;⊢ l[i + (j - min i (l.length + 1) - 1)] = if h₂ : j = i then a else l[j - 1]" state_after="no goals" tactic="· rw [dif_neg (by omega)]&#10;  congr&#10;  omega">
                                    <OtherNode start="(657, 7)" end="(657, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(657, 7)" end="(657, 8)" kind="patternIgnore">
                                        <OtherNode start="(657, 7)" end="(657, 8)" kind="token.«· »">
                                          <AtomNode start="(657, 7)" end="(657, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(657, 9)" end="(659, 14)">
                                      <TacticTacticseq1IndentedNode start="(657, 9)" end="(659, 14)">
                                        <NullNode start="(657, 9)" end="(659, 14)">
                                          <OtherNode start="(657, 9)" end="(657, 32)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h₂.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;h₄ : ¬j - min i (l.length + 1) = 0&#10;⊢ l[i + (j - min i (l.length + 1) - 1)] = if h₂ : j = i then a else l[j - 1]" state_after="case h₂.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;h₄ : ¬j - min i (l.length + 1) = 0&#10;⊢ l[i + (j - min i (l.length + 1) - 1)] = l[j - 1]" tactic="rw [dif_neg (by omega)]">
                                            <AtomNode start="(657, 9)" end="(657, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(657, 12)" end="(657, 32)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(657, 12)" end="(657, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(657, 13)" end="(657, 31)">
                                                <OtherNode start="(657, 13)" end="(657, 31)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(657, 13)" end="(657, 31)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(657, 13)" end="(657, 20)" leading="" trailing=" " raw_val="dif_neg" val="dif_neg" full_name="dif_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                    <NullNode start="(657, 21)" end="(657, 31)">
                                                      <OtherNode start="(657, 21)" end="(657, 31)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(657, 21)" end="(657, 22)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(657, 22)" end="(657, 30)">
                                                          <AtomNode start="(657, 22)" end="(657, 24)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(657, 25)" end="(657, 30)">
                                                            <TacticTacticseq1IndentedNode start="(657, 25)" end="(657, 30)">
                                                            <NullNode start="(657, 25)" end="(657, 30)">
                                                            <OtherNode start="(657, 25)" end="(657, 30)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;h₄ : ¬j - min i (l.length + 1) = 0&#10;⊢ ¬j = i" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(657, 25)" end="(657, 30)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(657, 30)" end="(657, 31)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(657, 31)" end="(657, 32)" leading="" trailing="&#10;        " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(658, 9)" end="(658, 14)" kind="Lean.Parser.Tactic.congr" state_before="case h₂.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;h₄ : ¬j - min i (l.length + 1) = 0&#10;⊢ l[i + (j - min i (l.length + 1) - 1)] = l[j - 1]" state_after="case h₂.isFalse.isFalse.e_i&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;h₄ : ¬j - min i (l.length + 1) = 0&#10;⊢ i + (j - min i (l.length + 1) - 1) = j - 1" tactic="congr">
                                            <AtomNode start="(658, 9)" end="(658, 14)" leading="" trailing="&#10;        " val="congr"/>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(659, 9)" end="(659, 14)" kind="Lean.Parser.Tactic.omega" state_before="case h₂.isFalse.isFalse.e_i&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i ≤ l.toArray.size&#10;j : Nat&#10;h₁✝ :&#10;  j &amp;lt;&#10;    (take i (l.toArray.push a).toList ++&#10;            (l.toArray.push a).toList[l.toArray.size] :: drop i (take l.toArray.size (l.toArray.push a).toList) ++&#10;          drop (l.toArray.size + 1) (l.toArray.push a).toList).toArray.size&#10;h₂✝ : j &amp;lt; (l.insertIdx i a).toArray.size&#10;h₁ : j &amp;lt; min i (l.length + 1) + (l.length - i + 1)&#10;h₂ : j &amp;lt; if i ≤ l.length then l.length + 1 else l.length&#10;h₃ : ¬j &amp;lt; i&#10;h₄ : ¬j - min i (l.length + 1) = 0&#10;⊢ i + (j - min i (l.length + 1) - 1) = j - 1" state_after="no goals" tactic="omega">
                                            <AtomNode start="(659, 9)" end="(659, 14)" leading="" trailing="&#10;&#10;" val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(661, 1)" end="(667, 47)" name="insertIdxIfInBounds_toArray" full_name="List.insertIdxIfInBounds_toArray">
      <CommandDeclmodifiersNode start="(661, 1)" end="(661, 8)">
        <NullNode/>
        <NullNode start="(661, 1)" end="(661, 8)">
          <OtherNode start="(661, 1)" end="(661, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(661, 1)" end="(661, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(661, 3)" end="(661, 7)">
              <OtherNode start="(661, 3)" end="(661, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(661, 3)" end="(661, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(661, 3)" end="(661, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(661, 7)" end="(661, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(661, 9)" end="(667, 47)" name="insertIdxIfInBounds_toArray" full_name="List.insertIdxIfInBounds_toArray" _is_private_decl="False">
        <AtomNode start="(661, 9)" end="(661, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(661, 17)" end="(661, 44)">
          <IdentNode start="(661, 17)" end="(661, 44)" leading="" trailing=" " raw_val="insertIdxIfInBounds_toArray" val="insertIdxIfInBounds_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(661, 45)" end="(662, 66)">
          <NullNode start="(661, 45)" end="(661, 75)">
            <TermExplicitbinderNode start="(661, 45)" end="(661, 57)">
              <AtomNode start="(661, 45)" end="(661, 46)" leading="" trailing="" val="("/>
              <NullNode start="(661, 46)" end="(661, 47)">
                <IdentNode start="(661, 46)" end="(661, 47)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(661, 48)" end="(661, 56)">
                <AtomNode start="(661, 48)" end="(661, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(661, 50)" end="(661, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(661, 50)" end="(661, 54)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(661, 55)" end="(661, 56)">
                    <IdentNode start="(661, 55)" end="(661, 56)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(661, 56)" end="(661, 57)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(661, 58)" end="(661, 67)">
              <AtomNode start="(661, 58)" end="(661, 59)" leading="" trailing="" val="("/>
              <NullNode start="(661, 59)" end="(661, 60)">
                <IdentNode start="(661, 59)" end="(661, 60)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(661, 61)" end="(661, 66)">
                <AtomNode start="(661, 61)" end="(661, 62)" leading="" trailing=" " val=":"/>
                <IdentNode start="(661, 63)" end="(661, 66)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(661, 66)" end="(661, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(661, 68)" end="(661, 75)">
              <AtomNode start="(661, 68)" end="(661, 69)" leading="" trailing="" val="("/>
              <NullNode start="(661, 69)" end="(661, 70)">
                <IdentNode start="(661, 69)" end="(661, 70)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(661, 71)" end="(661, 74)">
                <AtomNode start="(661, 71)" end="(661, 72)" leading="" trailing=" " val=":"/>
                <IdentNode start="(661, 73)" end="(661, 74)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(661, 74)" end="(661, 75)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(661, 76)" end="(662, 66)">
            <AtomNode start="(661, 76)" end="(661, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(662, 5)" end="(662, 66)" kind="«term_=_»">
              <OtherNode start="(662, 5)" end="(662, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(662, 5)" end="(662, 34)" leading="" trailing=" " raw_val="l.toArray.insertIdxIfInBounds" val="l.toArray.insertIdxIfInBounds"/>
                <NullNode start="(662, 35)" end="(662, 38)">
                  <IdentNode start="(662, 35)" end="(662, 36)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(662, 37)" end="(662, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(662, 39)" end="(662, 40)" leading="" trailing=" " val="="/>
              <OtherNode start="(662, 41)" end="(662, 66)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(662, 41)" end="(662, 58)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(662, 41)" end="(662, 42)" leading="" trailing="" val="("/>
                  <OtherNode start="(662, 42)" end="(662, 57)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(662, 42)" end="(662, 53)" leading="" trailing=" " raw_val="l.insertIdx" val="l.insertIdx"/>
                    <NullNode start="(662, 54)" end="(662, 57)">
                      <IdentNode start="(662, 54)" end="(662, 55)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(662, 56)" end="(662, 57)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(662, 57)" end="(662, 58)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(662, 58)" end="(662, 59)" leading="" trailing="" val="."/>
                <IdentNode start="(662, 59)" end="(662, 66)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(662, 67)" end="(667, 47)">
          <AtomNode start="(662, 67)" end="(662, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(662, 70)" end="(667, 47)">
            <AtomNode start="(662, 70)" end="(662, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(663, 3)" end="(667, 47)">
              <TacticTacticseq1IndentedNode start="(663, 3)" end="(667, 47)">
                <NullNode start="(663, 3)" end="(667, 47)">
                  <OtherNode start="(663, 3)" end="(663, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ l.toArray.insertIdxIfInBounds i a = (l.insertIdx i a).toArray" state_after="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ (if h : i ≤ l.toArray.size then l.toArray.insertIdx i a h else l.toArray) = (l.insertIdx i a).toArray" tactic="rw [Array.insertIdxIfInBounds]">
                    <AtomNode start="(663, 3)" end="(663, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(663, 6)" end="(663, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(663, 6)" end="(663, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(663, 7)" end="(663, 32)">
                        <OtherNode start="(663, 7)" end="(663, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(663, 7)" end="(663, 32)" leading="" trailing="" raw_val="Array.insertIdxIfInBounds" val="Array.insertIdxIfInBounds" full_name="Array.insertIdxIfInBounds" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(663, 32)" end="(663, 33)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(664, 3)" end="(664, 24)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ (if h : i ≤ l.toArray.size then l.toArray.insertIdx i a h else l.toArray) = (l.insertIdx i a).toArray" state_after="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h' : i ≤ l.toArray.size&#10;⊢ l.toArray.insertIdx i a h' = (l.insertIdx i a).toArray&#10;&#10;case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h' : ¬i ≤ l.toArray.size&#10;⊢ l.toArray = (l.insertIdx i a).toArray" tactic="split &amp;lt;;&amp;gt; rename_i h'">
                    <OtherNode start="(664, 3)" end="(664, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(664, 3)" end="(664, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(664, 9)" end="(664, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(664, 13)" end="(664, 24)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(664, 13)" end="(664, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(664, 22)" end="(664, 24)">
                        <LeanBinderidentNode start="(664, 22)" end="(664, 24)">
                          <IdentNode start="(664, 22)" end="(664, 24)" leading="" trailing="&#10;  " raw_val="h'" val="h'"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(665, 3)" end="(665, 9)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h' : i ≤ l.toArray.size&#10;⊢ l.toArray.insertIdx i a h' = (l.insertIdx i a).toArray&#10;&#10;case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h' : ¬i ≤ l.toArray.size&#10;⊢ l.toArray = (l.insertIdx i a).toArray" state_after="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h' : ¬i ≤ l.toArray.size&#10;⊢ l.toArray = (l.insertIdx i a).toArray" tactic="· simp">
                    <OtherNode start="(665, 3)" end="(665, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(665, 3)" end="(665, 4)" kind="patternIgnore">
                        <OtherNode start="(665, 3)" end="(665, 4)" kind="token.«· »">
                          <AtomNode start="(665, 3)" end="(665, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(665, 5)" end="(665, 9)">
                      <TacticTacticseq1IndentedNode start="(665, 5)" end="(665, 9)">
                        <NullNode start="(665, 5)" end="(665, 9)">
                          <OtherNode start="(665, 5)" end="(665, 9)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h' : i ≤ l.toArray.size&#10;⊢ l.toArray.insertIdx i a h' = (l.insertIdx i a).toArray" state_after="no goals" tactic="simp">
                            <AtomNode start="(665, 5)" end="(665, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(666, 3)" end="(667, 47)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h' : ¬i ≤ l.toArray.size&#10;⊢ l.toArray = (l.insertIdx i a).toArray" state_after="no goals" tactic="· simp only [size_toArray, Nat.not_le] at h'&#10;  rw [List.insertIdx_of_length_lt (h := h')]">
                    <OtherNode start="(666, 3)" end="(666, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(666, 3)" end="(666, 4)" kind="patternIgnore">
                        <OtherNode start="(666, 3)" end="(666, 4)" kind="token.«· »">
                          <AtomNode start="(666, 3)" end="(666, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(666, 5)" end="(667, 47)">
                      <TacticTacticseq1IndentedNode start="(666, 5)" end="(667, 47)">
                        <NullNode start="(666, 5)" end="(667, 47)">
                          <OtherNode start="(666, 5)" end="(666, 47)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h' : ¬i ≤ l.toArray.size&#10;⊢ l.toArray = (l.insertIdx i a).toArray" state_after="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h' : l.length &amp;lt; i&#10;⊢ l.toArray = (l.insertIdx i a).toArray" tactic="simp only [size_toArray, Nat.not_le] at h'">
                            <AtomNode start="(666, 5)" end="(666, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(666, 10)" end="(666, 14)">
                              <AtomNode start="(666, 10)" end="(666, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(666, 15)" end="(666, 41)">
                              <AtomNode start="(666, 15)" end="(666, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(666, 16)" end="(666, 40)">
                                <OtherNode start="(666, 16)" end="(666, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(666, 16)" end="(666, 28)" leading="" trailing="" raw_val="size_toArray" val="size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(666, 28)" end="(666, 29)" leading="" trailing=" " val=","/>
                                <OtherNode start="(666, 30)" end="(666, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(666, 30)" end="(666, 40)" leading="" trailing="" raw_val="Nat.not_le" val="Nat.not_le" full_name="Nat.not_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(666, 40)" end="(666, 41)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(666, 42)" end="(666, 47)">
                              <OtherNode start="(666, 42)" end="(666, 47)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(666, 42)" end="(666, 44)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(666, 45)" end="(666, 47)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(666, 45)" end="(666, 47)">
                                    <IdentNode start="(666, 45)" end="(666, 47)" leading="" trailing="&#10;    " raw_val="h'" val="h'"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(667, 5)" end="(667, 47)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;h' : l.length &amp;lt; i&#10;⊢ l.toArray = (l.insertIdx i a).toArray" state_after="no goals" tactic="rw [List.insertIdx_of_length_lt (h := h')]">
                            <AtomNode start="(667, 5)" end="(667, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(667, 8)" end="(667, 47)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(667, 8)" end="(667, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(667, 9)" end="(667, 46)">
                                <OtherNode start="(667, 9)" end="(667, 46)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(667, 9)" end="(667, 46)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(667, 9)" end="(667, 36)" leading="" trailing=" " raw_val="List.insertIdx_of_length_lt" val="List.insertIdx_of_length_lt" full_name="List.insertIdx_of_length_lt" mod_name="Init.Data.List.Nat.InsertIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/InsertIdx.lean"/>
                                    <NullNode start="(667, 37)" end="(667, 46)">
                                      <OtherNode start="(667, 37)" end="(667, 46)" kind="Lean.Parser.Term.namedArgument">
                                        <AtomNode start="(667, 37)" end="(667, 38)" leading="" trailing="" val="("/>
                                        <IdentNode start="(667, 38)" end="(667, 39)" leading="" trailing=" " raw_val="h" val="h"/>
                                        <AtomNode start="(667, 40)" end="(667, 42)" leading="" trailing=" " val=":="/>
                                        <IdentNode start="(667, 43)" end="(667, 45)" leading="" trailing="" raw_val="h'" val="h'"/>
                                        <AtomNode start="(667, 45)" end="(667, 46)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(667, 46)" end="(667, 47)" leading="" trailing="&#10;&#10;" val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(669, 1)" end="(701, 16)" name="replace_toArray" full_name="List.replace_toArray">
      <CommandDeclmodifiersNode start="(669, 1)" end="(669, 8)">
        <NullNode/>
        <NullNode start="(669, 1)" end="(669, 8)">
          <OtherNode start="(669, 1)" end="(669, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(669, 1)" end="(669, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(669, 3)" end="(669, 7)">
              <OtherNode start="(669, 3)" end="(669, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(669, 3)" end="(669, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(669, 3)" end="(669, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(669, 7)" end="(669, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(670, 1)" end="(701, 16)" name="replace_toArray" full_name="List.replace_toArray" _is_private_decl="False">
        <AtomNode start="(670, 1)" end="(670, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(670, 9)" end="(670, 24)">
          <IdentNode start="(670, 9)" end="(670, 24)" leading="" trailing=" " raw_val="replace_toArray" val="replace_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(670, 25)" end="(671, 52)">
          <NullNode start="(670, 25)" end="(670, 69)">
            <OtherNode start="(670, 25)" end="(670, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(670, 25)" end="(670, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(670, 26)" end="(670, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(670, 26)" end="(670, 29)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(670, 30)" end="(670, 31)">
                  <IdentNode start="(670, 30)" end="(670, 31)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(670, 31)" end="(670, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(670, 33)" end="(670, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(670, 33)" end="(670, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(670, 34)" end="(670, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(670, 34)" end="(670, 43)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(670, 44)" end="(670, 45)">
                  <IdentNode start="(670, 44)" end="(670, 45)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(670, 45)" end="(670, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(670, 47)" end="(670, 59)">
              <AtomNode start="(670, 47)" end="(670, 48)" leading="" trailing="" val="("/>
              <NullNode start="(670, 48)" end="(670, 49)">
                <IdentNode start="(670, 48)" end="(670, 49)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(670, 50)" end="(670, 58)">
                <AtomNode start="(670, 50)" end="(670, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(670, 52)" end="(670, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(670, 52)" end="(670, 56)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(670, 57)" end="(670, 58)">
                    <IdentNode start="(670, 57)" end="(670, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(670, 58)" end="(670, 59)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(670, 60)" end="(670, 69)">
              <AtomNode start="(670, 60)" end="(670, 61)" leading="" trailing="" val="("/>
              <NullNode start="(670, 61)" end="(670, 64)">
                <IdentNode start="(670, 61)" end="(670, 62)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(670, 63)" end="(670, 64)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(670, 65)" end="(670, 68)">
                <AtomNode start="(670, 65)" end="(670, 66)" leading="" trailing=" " val=":"/>
                <IdentNode start="(670, 67)" end="(670, 68)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(670, 68)" end="(670, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(670, 70)" end="(671, 52)">
            <AtomNode start="(670, 70)" end="(670, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(671, 5)" end="(671, 52)" kind="«term_=_»">
              <OtherNode start="(671, 5)" end="(671, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(671, 5)" end="(671, 22)" leading="" trailing=" " raw_val="l.toArray.replace" val="l.toArray.replace"/>
                <NullNode start="(671, 23)" end="(671, 26)">
                  <IdentNode start="(671, 23)" end="(671, 24)" leading="" trailing=" " raw_val="a" val="a"/>
                  <IdentNode start="(671, 25)" end="(671, 26)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(671, 27)" end="(671, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(671, 29)" end="(671, 52)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(671, 29)" end="(671, 44)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(671, 29)" end="(671, 30)" leading="" trailing="" val="("/>
                  <OtherNode start="(671, 30)" end="(671, 43)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(671, 30)" end="(671, 39)" leading="" trailing=" " raw_val="l.replace" val="l.replace"/>
                    <NullNode start="(671, 40)" end="(671, 43)">
                      <IdentNode start="(671, 40)" end="(671, 41)" leading="" trailing=" " raw_val="a" val="a"/>
                      <IdentNode start="(671, 42)" end="(671, 43)" leading="" trailing="" raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(671, 43)" end="(671, 44)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(671, 44)" end="(671, 45)" leading="" trailing="" val="."/>
                <IdentNode start="(671, 45)" end="(671, 52)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(671, 53)" end="(701, 16)">
          <AtomNode start="(671, 53)" end="(671, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(671, 56)" end="(701, 16)">
            <AtomNode start="(671, 56)" end="(671, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(672, 3)" end="(701, 16)">
              <TacticTacticseq1IndentedNode start="(672, 3)" end="(701, 16)">
                <NullNode start="(672, 3)" end="(701, 16)">
                  <OtherNode start="(672, 3)" end="(672, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;⊢ l.toArray.replace a b = (l.replace a b).toArray" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;⊢ (match l.toArray.finIdxOf? a with&#10;    | none =&amp;gt; l.toArray&#10;    | some i =&amp;gt; l.toArray.set (↑i) b ⋯) =&#10;    (l.replace a b).toArray" tactic="rw [Array.replace]">
                    <AtomNode start="(672, 3)" end="(672, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(672, 6)" end="(672, 21)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(672, 6)" end="(672, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(672, 7)" end="(672, 20)">
                        <OtherNode start="(672, 7)" end="(672, 20)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(672, 7)" end="(672, 20)" leading="" trailing="" raw_val="Array.replace" val="Array.replace" full_name="Array.replace" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(672, 20)" end="(672, 21)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(673, 3)" end="(673, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;⊢ (match l.toArray.finIdxOf? a with&#10;    | none =&amp;gt; l.toArray&#10;    | some i =&amp;gt; l.toArray.set (↑i) b ⋯) =&#10;    (l.replace a b).toArray" state_after="case h_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;i : Option (Fin l.toArray.size)&#10;h : l.toArray.finIdxOf? a = none&#10;⊢ l.toArray = (l.replace a b).toArray&#10;&#10;case h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l.toArray.finIdxOf? a = some i&#10;⊢ l.toArray.set (↑i) b ⋯ = (l.replace a b).toArray" tactic="split &amp;lt;;&amp;gt; rename_i i h">
                    <OtherNode start="(673, 3)" end="(673, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(673, 3)" end="(673, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(673, 9)" end="(673, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(673, 13)" end="(673, 25)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(673, 13)" end="(673, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(673, 22)" end="(673, 25)">
                        <LeanBinderidentNode start="(673, 22)" end="(673, 23)">
                          <IdentNode start="(673, 22)" end="(673, 23)" leading="" trailing=" " raw_val="i" val="i"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(673, 24)" end="(673, 25)">
                          <IdentNode start="(673, 24)" end="(673, 25)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(674, 3)" end="(676, 10)" kind="Lean.cdot" state_before="case h_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;i : Option (Fin l.toArray.size)&#10;h : l.toArray.finIdxOf? a = none&#10;⊢ l.toArray = (l.replace a b).toArray&#10;&#10;case h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l.toArray.finIdxOf? a = some i&#10;⊢ l.toArray.set (↑i) b ⋯ = (l.replace a b).toArray" state_after="case h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l.toArray.finIdxOf? a = some i&#10;⊢ l.toArray.set (↑i) b ⋯ = (l.replace a b).toArray" tactic="· simp only [finIdxOf?_toArray, finIdxOf?_eq_none_iff] at h&#10;  rw [replace_of_not_mem]&#10;  simpa">
                    <OtherNode start="(674, 3)" end="(674, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(674, 3)" end="(674, 4)" kind="patternIgnore">
                        <OtherNode start="(674, 3)" end="(674, 4)" kind="token.«· »">
                          <AtomNode start="(674, 3)" end="(674, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(674, 5)" end="(676, 10)">
                      <TacticTacticseq1IndentedNode start="(674, 5)" end="(676, 10)">
                        <NullNode start="(674, 5)" end="(676, 10)">
                          <OtherNode start="(674, 5)" end="(674, 62)" kind="Lean.Parser.Tactic.simp" state_before="case h_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;i : Option (Fin l.toArray.size)&#10;h : l.toArray.finIdxOf? a = none&#10;⊢ l.toArray = (l.replace a b).toArray" state_after="case h_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;i : Option (Fin l.toArray.size)&#10;h : ¬a ∈ l&#10;⊢ l.toArray = (l.replace a b).toArray" tactic="simp only [finIdxOf?_toArray, finIdxOf?_eq_none_iff] at h">
                            <AtomNode start="(674, 5)" end="(674, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(674, 10)" end="(674, 14)">
                              <AtomNode start="(674, 10)" end="(674, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(674, 15)" end="(674, 57)">
                              <AtomNode start="(674, 15)" end="(674, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(674, 16)" end="(674, 56)">
                                <OtherNode start="(674, 16)" end="(674, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(674, 16)" end="(674, 33)" leading="" trailing="" raw_val="finIdxOf?_toArray" val="finIdxOf?_toArray" full_name="List.finIdxOf?_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(337, 17)" def_end="(337, 34)"/>
                                </OtherNode>
                                <AtomNode start="(674, 33)" end="(674, 34)" leading="" trailing=" " val=","/>
                                <OtherNode start="(674, 35)" end="(674, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(674, 35)" end="(674, 56)" leading="" trailing="" raw_val="finIdxOf?_eq_none_iff" val="finIdxOf?_eq_none_iff" full_name="List.finIdxOf?_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(674, 56)" end="(674, 57)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(674, 58)" end="(674, 62)">
                              <OtherNode start="(674, 58)" end="(674, 62)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(674, 58)" end="(674, 60)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(674, 61)" end="(674, 62)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(674, 61)" end="(674, 62)">
                                    <IdentNode start="(674, 61)" end="(674, 62)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(675, 5)" end="(675, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;i : Option (Fin l.toArray.size)&#10;h : ¬a ∈ l&#10;⊢ l.toArray = (l.replace a b).toArray" state_after="case h_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;i : Option (Fin l.toArray.size)&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l" tactic="rw [replace_of_not_mem]">
                            <AtomNode start="(675, 5)" end="(675, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(675, 8)" end="(675, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(675, 8)" end="(675, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(675, 9)" end="(675, 27)">
                                <OtherNode start="(675, 9)" end="(675, 27)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(675, 9)" end="(675, 27)" leading="" trailing="" raw_val="replace_of_not_mem" val="replace_of_not_mem" full_name="List.replace_of_not_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(675, 27)" end="(675, 28)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(676, 5)" end="(676, 10)" kind="Lean.Parser.Tactic.simpa" state_before="case h_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;i : Option (Fin l.toArray.size)&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l" state_after="no goals" tactic="simpa">
                            <AtomNode start="(676, 5)" end="(676, 10)" leading="" trailing="&#10;  " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(677, 3)" end="(701, 16)" kind="Lean.cdot" state_before="case h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l.toArray.finIdxOf? a = some i&#10;⊢ l.toArray.set (↑i) b ⋯ = (l.replace a b).toArray" state_after="no goals" tactic="· simp_all only [finIdxOf?_toArray, finIdxOf?_eq_some_iff, Fin.getElem_fin, set_toArray,&#10;    mk.injEq]&#10;  apply List.ext_getElem&#10;  · simp&#10;  · intro j h₁ h₂&#10;    rw [List.getElem_replace, List.getElem_set]&#10;    by_cases h₃ : j &amp;lt; i&#10;    · rw [if_neg (by omega), if_neg]&#10;      simp only [length_set] at h₁ h₃&#10;      simpa using h.2 ⟨j, by omega⟩ h₃&#10;    · by_cases h₃ : j = i&#10;      · rw [if_pos (by omega), if_pos, if_neg]&#10;        · simp only [mem_take_iff_getElem, not_exists]&#10;          intro k hk&#10;          simpa using h.2 ⟨k, by omega⟩ (by show k &amp;lt; i.1; omega)&#10;        · subst h₃&#10;          simpa using h.1&#10;      · rw [if_neg (by omega)]&#10;        split&#10;        · rw [if_pos]&#10;          · simp_all&#10;          · simp only [mem_take_iff_getElem]&#10;            simp only [length_set] at h₁&#10;            exact ⟨i, by omega, h.1⟩&#10;        · rfl">
                    <OtherNode start="(677, 3)" end="(677, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(677, 3)" end="(677, 4)" kind="patternIgnore">
                        <OtherNode start="(677, 3)" end="(677, 4)" kind="token.«· »">
                          <AtomNode start="(677, 3)" end="(677, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(677, 5)" end="(701, 16)">
                      <TacticTacticseq1IndentedNode start="(677, 5)" end="(701, 16)">
                        <NullNode start="(677, 5)" end="(701, 16)">
                          <OtherNode start="(677, 5)" end="(678, 16)" kind="Lean.Parser.Tactic.simpAll" state_before="case h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l.toArray.finIdxOf? a = some i&#10;⊢ l.toArray.set (↑i) b ⋯ = (l.replace a b).toArray" state_after="case h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;⊢ l.set (↑i) b = l.replace a b" tactic="simp_all only [finIdxOf?_toArray, finIdxOf?_eq_some_iff, Fin.getElem_fin, set_toArray,&#10;  mk.injEq]">
                            <AtomNode start="(677, 5)" end="(677, 13)" leading="" trailing=" " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(677, 14)" end="(677, 18)">
                              <AtomNode start="(677, 14)" end="(677, 18)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(677, 19)" end="(678, 16)">
                              <AtomNode start="(677, 19)" end="(677, 20)" leading="" trailing="" val="["/>
                              <NullNode start="(677, 20)" end="(678, 15)">
                                <OtherNode start="(677, 20)" end="(677, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(677, 20)" end="(677, 37)" leading="" trailing="" raw_val="finIdxOf?_toArray" val="finIdxOf?_toArray" full_name="List.finIdxOf?_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(337, 17)" def_end="(337, 34)"/>
                                </OtherNode>
                                <AtomNode start="(677, 37)" end="(677, 38)" leading="" trailing=" " val=","/>
                                <OtherNode start="(677, 39)" end="(677, 60)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(677, 39)" end="(677, 60)" leading="" trailing="" raw_val="finIdxOf?_eq_some_iff" val="finIdxOf?_eq_some_iff" full_name="List.finIdxOf?_eq_some_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                                </OtherNode>
                                <AtomNode start="(677, 60)" end="(677, 61)" leading="" trailing=" " val=","/>
                                <OtherNode start="(677, 62)" end="(677, 77)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(677, 62)" end="(677, 77)" leading="" trailing="" raw_val="Fin.getElem_fin" val="Fin.getElem_fin" full_name="Fin.getElem_fin" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                </OtherNode>
                                <AtomNode start="(677, 77)" end="(677, 78)" leading="" trailing=" " val=","/>
                                <OtherNode start="(677, 79)" end="(677, 90)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(677, 79)" end="(677, 90)" leading="" trailing="" raw_val="set_toArray" val="set_toArray" full_name="List.set_toArray" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(108, 17)" def_end="(108, 28)"/>
                                </OtherNode>
                                <AtomNode start="(677, 90)" end="(677, 91)" leading="" trailing="&#10;      " val=","/>
                                <OtherNode start="(678, 7)" end="(678, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(678, 7)" end="(678, 15)" leading="" trailing="" raw_val="mk.injEq" val="mk.injEq" full_name="Array.mk.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(678, 15)" end="(678, 16)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(679, 5)" end="(679, 27)" kind="Lean.Parser.Tactic.apply" state_before="case h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;⊢ l.set (↑i) b = l.replace a b" state_after="case h_2.hl&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;⊢ (l.set (↑i) b).length = (l.replace a b).length&#10;&#10;case h_2.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; (l.set (↑i) b).length) (h₂ : i_1 &amp;lt; (l.replace a b).length),&#10;    (l.set (↑i) b)[i_1] = (l.replace a b)[i_1]" tactic="apply List.ext_getElem">
                            <AtomNode start="(679, 5)" end="(679, 10)" leading="" trailing=" " val="apply"/>
                            <IdentNode start="(679, 11)" end="(679, 27)" leading="" trailing="&#10;    " raw_val="List.ext_getElem" val="List.ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(680, 5)" end="(680, 11)" kind="Lean.cdot" state_before="case h_2.hl&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;⊢ (l.set (↑i) b).length = (l.replace a b).length&#10;&#10;case h_2.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; (l.set (↑i) b).length) (h₂ : i_1 &amp;lt; (l.replace a b).length),&#10;    (l.set (↑i) b)[i_1] = (l.replace a b)[i_1]" state_after="case h_2.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; (l.set (↑i) b).length) (h₂ : i_1 &amp;lt; (l.replace a b).length),&#10;    (l.set (↑i) b)[i_1] = (l.replace a b)[i_1]" tactic="· simp">
                            <OtherNode start="(680, 5)" end="(680, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(680, 5)" end="(680, 6)" kind="patternIgnore">
                                <OtherNode start="(680, 5)" end="(680, 6)" kind="token.«· »">
                                  <AtomNode start="(680, 5)" end="(680, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(680, 7)" end="(680, 11)">
                              <TacticTacticseq1IndentedNode start="(680, 7)" end="(680, 11)">
                                <NullNode start="(680, 7)" end="(680, 11)">
                                  <OtherNode start="(680, 7)" end="(680, 11)" kind="Lean.Parser.Tactic.simp" state_before="case h_2.hl&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;⊢ (l.set (↑i) b).length = (l.replace a b).length" state_after="no goals" tactic="simp">
                                    <AtomNode start="(680, 7)" end="(680, 11)" leading="" trailing="&#10;    " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(681, 5)" end="(701, 16)" kind="Lean.cdot" state_before="case h_2.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; (l.set (↑i) b).length) (h₂ : i_1 &amp;lt; (l.replace a b).length),&#10;    (l.set (↑i) b)[i_1] = (l.replace a b)[i_1]" state_after="no goals" tactic="· intro j h₁ h₂&#10;  rw [List.getElem_replace, List.getElem_set]&#10;  by_cases h₃ : j &amp;lt; i&#10;  · rw [if_neg (by omega), if_neg]&#10;    simp only [length_set] at h₁ h₃&#10;    simpa using h.2 ⟨j, by omega⟩ h₃&#10;  · by_cases h₃ : j = i&#10;    · rw [if_pos (by omega), if_pos, if_neg]&#10;      · simp only [mem_take_iff_getElem, not_exists]&#10;        intro k hk&#10;        simpa using h.2 ⟨k, by omega⟩ (by show k &amp;lt; i.1; omega)&#10;      · subst h₃&#10;        simpa using h.1&#10;    · rw [if_neg (by omega)]&#10;      split&#10;      · rw [if_pos]&#10;        · simp_all&#10;        · simp only [mem_take_iff_getElem]&#10;          simp only [length_set] at h₁&#10;          exact ⟨i, by omega, h.1⟩&#10;      · rfl">
                            <OtherNode start="(681, 5)" end="(681, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(681, 5)" end="(681, 6)" kind="patternIgnore">
                                <OtherNode start="(681, 5)" end="(681, 6)" kind="token.«· »">
                                  <AtomNode start="(681, 5)" end="(681, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(681, 7)" end="(701, 16)">
                              <TacticTacticseq1IndentedNode start="(681, 7)" end="(701, 16)">
                                <NullNode start="(681, 7)" end="(701, 16)">
                                  <OtherNode start="(681, 7)" end="(681, 20)" kind="Lean.Parser.Tactic.intro" state_before="case h_2.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; (l.set (↑i) b).length) (h₂ : i_1 &amp;lt; (l.replace a b).length),&#10;    (l.set (↑i) b)[i_1] = (l.replace a b)[i_1]" state_after="case h_2.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;⊢ (l.set (↑i) b)[j] = (l.replace a b)[j]" tactic="intro j h₁ h₂">
                                    <AtomNode start="(681, 7)" end="(681, 12)" leading="" trailing=" " val="intro"/>
                                    <NullNode start="(681, 13)" end="(681, 20)">
                                      <IdentNode start="(681, 13)" end="(681, 14)" leading="" trailing=" " raw_val="j" val="j"/>
                                      <IdentNode start="(681, 15)" end="(681, 17)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                      <IdentNode start="(681, 18)" end="(681, 20)" leading="" trailing="&#10;      " raw_val="h₂" val="h₂"/>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(682, 7)" end="(682, 50)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h_2.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;⊢ (l.set (↑i) b)[j] = (l.replace a b)[j]" state_after="case h_2.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]&#10;&#10;case h_2.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;⊢ j &amp;lt; l.length" tactic="rw [List.getElem_replace, List.getElem_set]">
                                    <AtomNode start="(682, 7)" end="(682, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(682, 10)" end="(682, 50)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(682, 10)" end="(682, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(682, 11)" end="(682, 49)">
                                        <OtherNode start="(682, 11)" end="(682, 31)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(682, 11)" end="(682, 31)" leading="" trailing="" raw_val="List.getElem_replace" val="List.getElem_replace" full_name="List.getElem_replace" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(682, 31)" end="(682, 32)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(682, 33)" end="(682, 49)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(682, 33)" end="(682, 49)" leading="" trailing="" raw_val="List.getElem_set" val="List.getElem_set" full_name="List.getElem_set" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(682, 49)" end="(682, 50)" leading="" trailing="&#10;      " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(683, 7)" end="(683, 26)" kind="«tacticBy_cases_:_»" state_before="case h_2.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]&#10;&#10;case h_2.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;⊢ j &amp;lt; l.length" state_after="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃ : j &amp;lt; ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃ : ¬j &amp;lt; ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]&#10;&#10;case h_2.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;⊢ j &amp;lt; l.length" tactic="by_cases h₃ : j &amp;lt; i">
                                    <AtomNode start="(683, 7)" end="(683, 15)" leading="" trailing=" " val="by_cases"/>
                                    <NullNode start="(683, 16)" end="(683, 20)">
                                      <IdentNode start="(683, 16)" end="(683, 18)" leading="" trailing=" " raw_val="h₃" val="h₃"/>
                                      <AtomNode start="(683, 19)" end="(683, 20)" leading="" trailing=" " val=":"/>
                                    </NullNode>
                                    <OtherNode start="(683, 21)" end="(683, 26)" kind="«term_&amp;lt;_»">
                                      <IdentNode start="(683, 21)" end="(683, 22)" leading="" trailing=" " raw_val="j" val="j"/>
                                      <AtomNode start="(683, 23)" end="(683, 24)" leading="" trailing=" " val="&amp;lt;"/>
                                      <IdentNode start="(683, 25)" end="(683, 26)" leading="" trailing="&#10;      " raw_val="i" val="i"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(684, 7)" end="(686, 41)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃ : j &amp;lt; ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃ : ¬j &amp;lt; ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]&#10;&#10;case h_2.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;⊢ j &amp;lt; l.length" state_after="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃ : ¬j &amp;lt; ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]" tactic="· rw [if_neg (by omega), if_neg]&#10;  simp only [length_set] at h₁ h₃&#10;  simpa using h.2 ⟨j, by omega⟩ h₃">
                                    <OtherNode start="(684, 7)" end="(684, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(684, 7)" end="(684, 8)" kind="patternIgnore">
                                        <OtherNode start="(684, 7)" end="(684, 8)" kind="token.«· »">
                                          <AtomNode start="(684, 7)" end="(684, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(684, 9)" end="(686, 41)">
                                      <TacticTacticseq1IndentedNode start="(684, 9)" end="(686, 41)">
                                        <NullNode start="(684, 9)" end="(686, 41)">
                                          <OtherNode start="(684, 9)" end="(684, 39)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃ : j &amp;lt; ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]" state_after="case pos.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃ : j &amp;lt; ↑i&#10;⊢ ¬(l[j] == a) = true" tactic="rw [if_neg (by omega), if_neg]">
                                            <AtomNode start="(684, 9)" end="(684, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(684, 12)" end="(684, 39)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(684, 12)" end="(684, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(684, 13)" end="(684, 38)">
                                                <OtherNode start="(684, 13)" end="(684, 30)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(684, 13)" end="(684, 30)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(684, 13)" end="(684, 19)" leading="" trailing=" " raw_val="if_neg" val="if_neg" full_name="if_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                    <NullNode start="(684, 20)" end="(684, 30)">
                                                      <OtherNode start="(684, 20)" end="(684, 30)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(684, 20)" end="(684, 21)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(684, 21)" end="(684, 29)">
                                                          <AtomNode start="(684, 21)" end="(684, 23)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(684, 24)" end="(684, 29)">
                                                            <TacticTacticseq1IndentedNode start="(684, 24)" end="(684, 29)">
                                                            <NullNode start="(684, 24)" end="(684, 29)">
                                                            <OtherNode start="(684, 24)" end="(684, 29)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃ : j &amp;lt; ↑i&#10;⊢ ¬↑i = j" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(684, 24)" end="(684, 29)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(684, 29)" end="(684, 30)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(684, 30)" end="(684, 31)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(684, 32)" end="(684, 38)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <IdentNode start="(684, 32)" end="(684, 38)" leading="" trailing="" raw_val="if_neg" val="if_neg" full_name="if_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(684, 38)" end="(684, 39)" leading="" trailing="&#10;        " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(685, 9)" end="(685, 40)" kind="Lean.Parser.Tactic.simp" state_before="case pos.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃ : j &amp;lt; ↑i&#10;⊢ ¬(l[j] == a) = true" state_after="case pos.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁✝ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃ : j &amp;lt; ↑i&#10;h₁ : j &amp;lt; l.length&#10;⊢ ¬(l[j] == a) = true" tactic="simp only [length_set] at h₁ h₃">
                                            <AtomNode start="(685, 9)" end="(685, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode start="(685, 14)" end="(685, 18)">
                                              <AtomNode start="(685, 14)" end="(685, 18)" leading="" trailing=" " val="only"/>
                                            </NullNode>
                                            <NullNode start="(685, 19)" end="(685, 31)">
                                              <AtomNode start="(685, 19)" end="(685, 20)" leading="" trailing="" val="["/>
                                              <NullNode start="(685, 20)" end="(685, 30)">
                                                <OtherNode start="(685, 20)" end="(685, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(685, 20)" end="(685, 30)" leading="" trailing="" raw_val="length_set" val="length_set" full_name="List.length_set" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(685, 30)" end="(685, 31)" leading="" trailing=" " val="]"/>
                                            </NullNode>
                                            <NullNode start="(685, 32)" end="(685, 40)">
                                              <OtherNode start="(685, 32)" end="(685, 40)" kind="Lean.Parser.Tactic.location">
                                                <AtomNode start="(685, 32)" end="(685, 34)" leading="" trailing=" " val="at"/>
                                                <OtherNode start="(685, 35)" end="(685, 40)" kind="Lean.Parser.Tactic.locationHyp">
                                                  <NullNode start="(685, 35)" end="(685, 40)">
                                                    <IdentNode start="(685, 35)" end="(685, 37)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                                    <IdentNode start="(685, 38)" end="(685, 40)" leading="" trailing="&#10;        " raw_val="h₃" val="h₃"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(686, 9)" end="(686, 41)" kind="Lean.Parser.Tactic.simpa" state_before="case pos.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁✝ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃ : j &amp;lt; ↑i&#10;h₁ : j &amp;lt; l.length&#10;⊢ ¬(l[j] == a) = true" state_after="no goals" tactic="simpa using h.2 ⟨j, by omega⟩ h₃">
                                            <AtomNode start="(686, 9)" end="(686, 14)" leading="" trailing=" " val="simpa"/>
                                            <NullNode/>
                                            <NullNode/>
                                            <OtherNode start="(686, 15)" end="(686, 41)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(686, 15)" end="(686, 41)">
                                                <AtomNode start="(686, 15)" end="(686, 20)" leading="" trailing=" " val="using"/>
                                                <OtherNode start="(686, 21)" end="(686, 41)" kind="Lean.Parser.Term.app">
                                                  <OtherNode start="(686, 21)" end="(686, 24)" kind="Lean.Parser.Term.proj">
                                                    <IdentNode start="(686, 21)" end="(686, 22)" leading="" trailing="" raw_val="h" val="h"/>
                                                    <AtomNode start="(686, 22)" end="(686, 23)" leading="" trailing="" val="."/>
                                                    <OtherNode start="(686, 23)" end="(686, 24)" kind="fieldIdx">
                                                      <AtomNode start="(686, 23)" end="(686, 24)" leading="" trailing=" " val="2"/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <NullNode start="(686, 25)" end="(686, 41)">
                                                    <OtherNode start="(686, 25)" end="(686, 38)" kind="Lean.Parser.Term.anonymousCtor">
                                                      <AtomNode start="(686, 25)" end="(686, 26)" leading="" trailing="" val="⟨"/>
                                                      <NullNode start="(686, 26)" end="(686, 37)">
                                                        <IdentNode start="(686, 26)" end="(686, 27)" leading="" trailing="" raw_val="j" val="j"/>
                                                        <AtomNode start="(686, 27)" end="(686, 28)" leading="" trailing=" " val=","/>
                                                        <TermBytacticNode start="(686, 29)" end="(686, 37)">
                                                          <AtomNode start="(686, 29)" end="(686, 31)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(686, 32)" end="(686, 37)">
                                                            <TacticTacticseq1IndentedNode start="(686, 32)" end="(686, 37)">
                                                            <NullNode start="(686, 32)" end="(686, 37)">
                                                            <OtherNode start="(686, 32)" end="(686, 37)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁✝ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃ : j &amp;lt; ↑i&#10;h₁ : j &amp;lt; l.length&#10;⊢ j &amp;lt; l.length" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(686, 32)" end="(686, 37)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                      </NullNode>
                                                      <AtomNode start="(686, 37)" end="(686, 38)" leading="" trailing=" " val="⟩"/>
                                                    </OtherNode>
                                                    <IdentNode start="(686, 39)" end="(686, 41)" leading="" trailing="&#10;      " raw_val="h₃" val="h₃"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(687, 7)" end="(701, 16)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃ : ¬j &amp;lt; ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]" state_after="no goals" tactic="· by_cases h₃ : j = i&#10;  · rw [if_pos (by omega), if_pos, if_neg]&#10;    · simp only [mem_take_iff_getElem, not_exists]&#10;      intro k hk&#10;      simpa using h.2 ⟨k, by omega⟩ (by show k &amp;lt; i.1; omega)&#10;    · subst h₃&#10;      simpa using h.1&#10;  · rw [if_neg (by omega)]&#10;    split&#10;    · rw [if_pos]&#10;      · simp_all&#10;      · simp only [mem_take_iff_getElem]&#10;        simp only [length_set] at h₁&#10;        exact ⟨i, by omega, h.1⟩&#10;    · rfl">
                                    <OtherNode start="(687, 7)" end="(687, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(687, 7)" end="(687, 8)" kind="patternIgnore">
                                        <OtherNode start="(687, 7)" end="(687, 8)" kind="token.«· »">
                                          <AtomNode start="(687, 7)" end="(687, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(687, 9)" end="(701, 16)">
                                      <TacticTacticseq1IndentedNode start="(687, 9)" end="(701, 16)">
                                        <NullNode start="(687, 9)" end="(701, 16)">
                                          <OtherNode start="(687, 9)" end="(687, 28)" kind="«tacticBy_cases_:_»" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃ : ¬j &amp;lt; ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]" state_after="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]" tactic="by_cases h₃ : j = i">
                                            <AtomNode start="(687, 9)" end="(687, 17)" leading="" trailing=" " val="by_cases"/>
                                            <NullNode start="(687, 18)" end="(687, 22)">
                                              <IdentNode start="(687, 18)" end="(687, 20)" leading="" trailing=" " raw_val="h₃" val="h₃"/>
                                              <AtomNode start="(687, 21)" end="(687, 22)" leading="" trailing=" " val=":"/>
                                            </NullNode>
                                            <OtherNode start="(687, 23)" end="(687, 28)" kind="«term_=_»">
                                              <IdentNode start="(687, 23)" end="(687, 24)" leading="" trailing=" " raw_val="j" val="j"/>
                                              <AtomNode start="(687, 25)" end="(687, 26)" leading="" trailing=" " val="="/>
                                              <IdentNode start="(687, 27)" end="(687, 28)" leading="" trailing="&#10;        " raw_val="i" val="i"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(688, 9)" end="(693, 28)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]" state_after="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]" tactic="· rw [if_pos (by omega), if_pos, if_neg]&#10;  · simp only [mem_take_iff_getElem, not_exists]&#10;    intro k hk&#10;    simpa using h.2 ⟨k, by omega⟩ (by show k &amp;lt; i.1; omega)&#10;  · subst h₃&#10;    simpa using h.1">
                                            <OtherNode start="(688, 9)" end="(688, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(688, 9)" end="(688, 10)" kind="patternIgnore">
                                                <OtherNode start="(688, 9)" end="(688, 10)" kind="token.«· »">
                                                  <AtomNode start="(688, 9)" end="(688, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(688, 11)" end="(693, 28)">
                                              <TacticTacticseq1IndentedNode start="(688, 11)" end="(693, 28)">
                                                <NullNode start="(688, 11)" end="(693, 28)">
                                                  <OtherNode start="(688, 11)" end="(688, 49)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]" state_after="case pos.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;⊢ ¬a ∈ take j l&#10;&#10;case pos.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;⊢ (l[j] == a) = true" tactic="rw [if_pos (by omega), if_pos, if_neg]">
                                                    <AtomNode start="(688, 11)" end="(688, 13)" leading="" trailing=" " val="rw"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <OtherNode start="(688, 14)" end="(688, 49)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                      <AtomNode start="(688, 14)" end="(688, 15)" leading="" trailing="" val="["/>
                                                      <NullNode start="(688, 15)" end="(688, 48)">
                                                        <OtherNode start="(688, 15)" end="(688, 32)" kind="Lean.Parser.Tactic.rwRule">
                                                          <NullNode/>
                                                          <OtherNode start="(688, 15)" end="(688, 32)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(688, 15)" end="(688, 21)" leading="" trailing=" " raw_val="if_pos" val="if_pos" full_name="if_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            <NullNode start="(688, 22)" end="(688, 32)">
                                                            <OtherNode start="(688, 22)" end="(688, 32)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(688, 22)" end="(688, 23)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(688, 23)" end="(688, 31)">
                                                            <AtomNode start="(688, 23)" end="(688, 25)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(688, 26)" end="(688, 31)">
                                                            <TacticTacticseq1IndentedNode start="(688, 26)" end="(688, 31)">
                                                            <NullNode start="(688, 26)" end="(688, 31)">
                                                            <OtherNode start="(688, 26)" end="(688, 31)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;⊢ ↑i = j" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(688, 26)" end="(688, 31)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(688, 31)" end="(688, 32)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <AtomNode start="(688, 32)" end="(688, 33)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(688, 34)" end="(688, 40)" kind="Lean.Parser.Tactic.rwRule">
                                                          <NullNode/>
                                                          <IdentNode start="(688, 34)" end="(688, 40)" leading="" trailing="" raw_val="if_pos" val="if_pos" full_name="if_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                        </OtherNode>
                                                        <AtomNode start="(688, 40)" end="(688, 41)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(688, 42)" end="(688, 48)" kind="Lean.Parser.Tactic.rwRule">
                                                          <NullNode/>
                                                          <IdentNode start="(688, 42)" end="(688, 48)" leading="" trailing="" raw_val="if_neg" val="if_neg" full_name="if_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(688, 48)" end="(688, 49)" leading="" trailing="&#10;          " val="]"/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(689, 11)" end="(691, 67)" kind="Lean.cdot" state_before="case pos.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;⊢ ¬a ∈ take j l&#10;&#10;case pos.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;⊢ (l[j] == a) = true" state_after="case pos.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;⊢ (l[j] == a) = true" tactic="· simp only [mem_take_iff_getElem, not_exists]&#10;  intro k hk&#10;  simpa using h.2 ⟨k, by omega⟩ (by show k &amp;lt; i.1; omega)">
                                                    <OtherNode start="(689, 11)" end="(689, 12)" kind="Lean.cdotTk">
                                                      <OtherNode start="(689, 11)" end="(689, 12)" kind="patternIgnore">
                                                        <OtherNode start="(689, 11)" end="(689, 12)" kind="token.«· »">
                                                          <AtomNode start="(689, 11)" end="(689, 12)" leading="" trailing=" " val="·"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <TacticTacticseqNode start="(689, 13)" end="(691, 67)">
                                                      <TacticTacticseq1IndentedNode start="(689, 13)" end="(691, 67)">
                                                        <NullNode start="(689, 13)" end="(691, 67)">
                                                          <OtherNode start="(689, 13)" end="(689, 57)" kind="Lean.Parser.Tactic.simp" state_before="case pos.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;⊢ ¬a ∈ take j l" state_after="case pos.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;⊢ ∀ (x : Nat) (x_1 : x &amp;lt; min j l.length), ¬l[x] = a" tactic="simp only [mem_take_iff_getElem, not_exists]">
                                                            <AtomNode start="(689, 13)" end="(689, 17)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(689, 18)" end="(689, 22)">
                                                            <AtomNode start="(689, 18)" end="(689, 22)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(689, 23)" end="(689, 57)">
                                                            <AtomNode start="(689, 23)" end="(689, 24)" leading="" trailing="" val="["/>
                                                            <NullNode start="(689, 24)" end="(689, 56)">
                                                            <OtherNode start="(689, 24)" end="(689, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(689, 24)" end="(689, 44)" leading="" trailing="" raw_val="mem_take_iff_getElem" val="mem_take_iff_getElem" full_name="List.mem_take_iff_getElem" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(689, 44)" end="(689, 45)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(689, 46)" end="(689, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(689, 46)" end="(689, 56)" leading="" trailing="" raw_val="not_exists" val="not_exists" full_name="not_exists" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(689, 56)" end="(689, 57)" leading="" trailing="&#10;            " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <OtherNode start="(690, 13)" end="(690, 23)" kind="Lean.Parser.Tactic.intro" state_before="case pos.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;⊢ ∀ (x : Nat) (x_1 : x &amp;lt; min j l.length), ¬l[x] = a" state_after="case pos.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;k : Nat&#10;hk : k &amp;lt; min j l.length&#10;⊢ ¬l[k] = a" tactic="intro k hk">
                                                            <AtomNode start="(690, 13)" end="(690, 18)" leading="" trailing=" " val="intro"/>
                                                            <NullNode start="(690, 19)" end="(690, 23)">
                                                            <IdentNode start="(690, 19)" end="(690, 20)" leading="" trailing=" " raw_val="k" val="k"/>
                                                            <IdentNode start="(690, 21)" end="(690, 23)" leading="" trailing="&#10;            " raw_val="hk" val="hk"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <OtherNode start="(691, 13)" end="(691, 67)" kind="Lean.Parser.Tactic.simpa" state_before="case pos.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;k : Nat&#10;hk : k &amp;lt; min j l.length&#10;⊢ ¬l[k] = a" state_after="no goals" tactic="simpa using h.2 ⟨k, by omega⟩ (by show k &amp;lt; i.1; omega)">
                                                            <AtomNode start="(691, 13)" end="(691, 18)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(691, 19)" end="(691, 67)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(691, 19)" end="(691, 67)">
                                                            <AtomNode start="(691, 19)" end="(691, 24)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(691, 25)" end="(691, 67)" kind="Lean.Parser.Term.app">
                                                            <OtherNode start="(691, 25)" end="(691, 28)" kind="Lean.Parser.Term.proj">
                                                            <IdentNode start="(691, 25)" end="(691, 26)" leading="" trailing="" raw_val="h" val="h"/>
                                                            <AtomNode start="(691, 26)" end="(691, 27)" leading="" trailing="" val="."/>
                                                            <OtherNode start="(691, 27)" end="(691, 28)" kind="fieldIdx">
                                                            <AtomNode start="(691, 27)" end="(691, 28)" leading="" trailing=" " val="2"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode start="(691, 29)" end="(691, 67)">
                                                            <OtherNode start="(691, 29)" end="(691, 42)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(691, 29)" end="(691, 30)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(691, 30)" end="(691, 41)">
                                                            <IdentNode start="(691, 30)" end="(691, 31)" leading="" trailing="" raw_val="k" val="k"/>
                                                            <AtomNode start="(691, 31)" end="(691, 32)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(691, 33)" end="(691, 41)">
                                                            <AtomNode start="(691, 33)" end="(691, 35)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(691, 36)" end="(691, 41)">
                                                            <TacticTacticseq1IndentedNode start="(691, 36)" end="(691, 41)">
                                                            <NullNode start="(691, 36)" end="(691, 41)">
                                                            <OtherNode start="(691, 36)" end="(691, 41)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;k : Nat&#10;hk : k &amp;lt; min j l.length&#10;⊢ k &amp;lt; l.length" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(691, 36)" end="(691, 41)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            </NullNode>
                                                            <AtomNode start="(691, 41)" end="(691, 42)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            <OtherNode start="(691, 43)" end="(691, 67)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(691, 43)" end="(691, 44)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(691, 44)" end="(691, 66)">
                                                            <AtomNode start="(691, 44)" end="(691, 46)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(691, 47)" end="(691, 66)">
                                                            <TacticTacticseq1IndentedNode start="(691, 47)" end="(691, 66)">
                                                            <NullNode start="(691, 47)" end="(691, 66)">
                                                            <OtherNode start="(691, 47)" end="(691, 59)" kind="Lean.Parser.Tactic.tacticShow_" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;k : Nat&#10;hk : k &amp;lt; min j l.length&#10;⊢ ⟨k, ⋯⟩ &amp;lt; i" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;k : Nat&#10;hk : k &amp;lt; min j l.length&#10;⊢ k &amp;lt; ↑i" tactic="show k &amp;lt; i.1">
                                                            <AtomNode start="(691, 47)" end="(691, 51)" leading="" trailing=" " val="show"/>
                                                            <OtherNode start="(691, 52)" end="(691, 59)" kind="«term_&amp;lt;_»">
                                                            <IdentNode start="(691, 52)" end="(691, 53)" leading="" trailing=" " raw_val="k" val="k"/>
                                                            <AtomNode start="(691, 54)" end="(691, 55)" leading="" trailing=" " val="&amp;lt;"/>
                                                            <OtherNode start="(691, 56)" end="(691, 59)" kind="Lean.Parser.Term.proj">
                                                            <IdentNode start="(691, 56)" end="(691, 57)" leading="" trailing="" raw_val="i" val="i"/>
                                                            <AtomNode start="(691, 57)" end="(691, 58)" leading="" trailing="" val="."/>
                                                            <OtherNode start="(691, 58)" end="(691, 59)" kind="fieldIdx">
                                                            <AtomNode start="(691, 58)" end="(691, 59)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(691, 59)" end="(691, 60)" leading="" trailing=" " val=";"/>
                                                            <OtherNode start="(691, 61)" end="(691, 66)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;k : Nat&#10;hk : k &amp;lt; min j l.length&#10;⊢ k &amp;lt; ↑i" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(691, 61)" end="(691, 66)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(691, 66)" end="(691, 67)" leading="" trailing="&#10;          " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(692, 11)" end="(693, 28)" kind="Lean.cdot" state_before="case pos.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;⊢ (l[j] == a) = true" state_after="no goals" tactic="· subst h₃&#10;  simpa using h.1">
                                                    <OtherNode start="(692, 11)" end="(692, 12)" kind="Lean.cdotTk">
                                                      <OtherNode start="(692, 11)" end="(692, 12)" kind="patternIgnore">
                                                        <OtherNode start="(692, 11)" end="(692, 12)" kind="token.«· »">
                                                          <AtomNode start="(692, 11)" end="(692, 12)" leading="" trailing=" " val="·"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <TacticTacticseqNode start="(692, 13)" end="(693, 28)">
                                                      <TacticTacticseq1IndentedNode start="(692, 13)" end="(693, 28)">
                                                        <NullNode start="(692, 13)" end="(693, 28)">
                                                          <OtherNode start="(692, 13)" end="(692, 21)" kind="Lean.Parser.Tactic.subst" state_before="case pos.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : j = ↑i&#10;⊢ (l[j] == a) = true" state_after="case pos.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;h₁ : ↑i &amp;lt; (l.set (↑i) b).length&#10;h₂ : ↑i &amp;lt; (l.replace a b).length&#10;h₃ : ¬↑i &amp;lt; ↑i&#10;⊢ (l[↑i] == a) = true" tactic="subst h₃">
                                                            <AtomNode start="(692, 13)" end="(692, 18)" leading="" trailing=" " val="subst"/>
                                                            <NullNode start="(692, 19)" end="(692, 21)">
                                                            <IdentNode start="(692, 19)" end="(692, 21)" leading="" trailing="&#10;            " raw_val="h₃" val="h₃"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <OtherNode start="(693, 13)" end="(693, 28)" kind="Lean.Parser.Tactic.simpa" state_before="case pos.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;h₁ : ↑i &amp;lt; (l.set (↑i) b).length&#10;h₂ : ↑i &amp;lt; (l.replace a b).length&#10;h₃ : ¬↑i &amp;lt; ↑i&#10;⊢ (l[↑i] == a) = true" state_after="no goals" tactic="simpa using h.1">
                                                            <AtomNode start="(693, 13)" end="(693, 18)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(693, 19)" end="(693, 28)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(693, 19)" end="(693, 28)">
                                                            <AtomNode start="(693, 19)" end="(693, 24)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(693, 25)" end="(693, 28)" kind="Lean.Parser.Term.proj">
                                                            <IdentNode start="(693, 25)" end="(693, 26)" leading="" trailing="" raw_val="h" val="h"/>
                                                            <AtomNode start="(693, 26)" end="(693, 27)" leading="" trailing="" val="."/>
                                                            <OtherNode start="(693, 27)" end="(693, 28)" kind="fieldIdx">
                                                            <AtomNode start="(693, 27)" end="(693, 28)" leading="" trailing="&#10;        " val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(694, 9)" end="(701, 16)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]" state_after="no goals" tactic="· rw [if_neg (by omega)]&#10;  split&#10;  · rw [if_pos]&#10;    · simp_all&#10;    · simp only [mem_take_iff_getElem]&#10;      simp only [length_set] at h₁&#10;      exact ⟨i, by omega, h.1⟩&#10;  · rfl">
                                            <OtherNode start="(694, 9)" end="(694, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(694, 9)" end="(694, 10)" kind="patternIgnore">
                                                <OtherNode start="(694, 9)" end="(694, 10)" kind="token.«· »">
                                                  <AtomNode start="(694, 9)" end="(694, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(694, 11)" end="(701, 16)">
                                              <TacticTacticseq1IndentedNode start="(694, 11)" end="(701, 16)">
                                                <NullNode start="(694, 11)" end="(701, 16)">
                                                  <OtherNode start="(694, 11)" end="(694, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;⊢ (if ↑i = j then b else l[j]) = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]" state_after="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;⊢ l[j] = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]" tactic="rw [if_neg (by omega)]">
                                                    <AtomNode start="(694, 11)" end="(694, 13)" leading="" trailing=" " val="rw"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <OtherNode start="(694, 14)" end="(694, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                      <AtomNode start="(694, 14)" end="(694, 15)" leading="" trailing="" val="["/>
                                                      <NullNode start="(694, 15)" end="(694, 32)">
                                                        <OtherNode start="(694, 15)" end="(694, 32)" kind="Lean.Parser.Tactic.rwRule">
                                                          <NullNode/>
                                                          <OtherNode start="(694, 15)" end="(694, 32)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(694, 15)" end="(694, 21)" leading="" trailing=" " raw_val="if_neg" val="if_neg" full_name="if_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            <NullNode start="(694, 22)" end="(694, 32)">
                                                            <OtherNode start="(694, 22)" end="(694, 32)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(694, 22)" end="(694, 23)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(694, 23)" end="(694, 31)">
                                                            <AtomNode start="(694, 23)" end="(694, 25)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(694, 26)" end="(694, 31)">
                                                            <TacticTacticseq1IndentedNode start="(694, 26)" end="(694, 31)">
                                                            <NullNode start="(694, 26)" end="(694, 31)">
                                                            <OtherNode start="(694, 26)" end="(694, 31)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;⊢ ¬↑i = j" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(694, 26)" end="(694, 31)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(694, 31)" end="(694, 32)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(694, 32)" end="(694, 33)" leading="" trailing="&#10;          " val="]"/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(695, 11)" end="(695, 16)" kind="Lean.Parser.Tactic.split" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;⊢ l[j] = if (l[j] == a) = true then if a ∈ take j l then a else b else l[j]" state_after="case neg.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;⊢ l[j] = if a ∈ take j l then a else b&#10;&#10;case neg.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : ¬(l[j] == a) = true&#10;⊢ l[j] = l[j]" tactic="split">
                                                    <AtomNode start="(695, 11)" end="(695, 16)" leading="" trailing="&#10;          " val="split"/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(696, 11)" end="(700, 39)" kind="Lean.cdot" state_before="case neg.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;⊢ l[j] = if a ∈ take j l then a else b&#10;&#10;case neg.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : ¬(l[j] == a) = true&#10;⊢ l[j] = l[j]" state_after="case neg.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : ¬(l[j] == a) = true&#10;⊢ l[j] = l[j]" tactic="· rw [if_pos]&#10;  · simp_all&#10;  · simp only [mem_take_iff_getElem]&#10;    simp only [length_set] at h₁&#10;    exact ⟨i, by omega, h.1⟩">
                                                    <OtherNode start="(696, 11)" end="(696, 12)" kind="Lean.cdotTk">
                                                      <OtherNode start="(696, 11)" end="(696, 12)" kind="patternIgnore">
                                                        <OtherNode start="(696, 11)" end="(696, 12)" kind="token.«· »">
                                                          <AtomNode start="(696, 11)" end="(696, 12)" leading="" trailing=" " val="·"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <TacticTacticseqNode start="(696, 13)" end="(700, 39)">
                                                      <TacticTacticseq1IndentedNode start="(696, 13)" end="(700, 39)">
                                                        <NullNode start="(696, 13)" end="(700, 39)">
                                                          <OtherNode start="(696, 13)" end="(696, 24)" kind="Lean.Parser.Tactic.rwSeq" state_before="case neg.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;⊢ l[j] = if a ∈ take j l then a else b" state_after="case neg.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;⊢ l[j] = a&#10;&#10;case neg.isTrue.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;⊢ a ∈ take j l" tactic="rw [if_pos]">
                                                            <AtomNode start="(696, 13)" end="(696, 15)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(696, 16)" end="(696, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(696, 16)" end="(696, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(696, 17)" end="(696, 23)">
                                                            <OtherNode start="(696, 17)" end="(696, 23)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(696, 17)" end="(696, 23)" leading="" trailing="" raw_val="if_pos" val="if_pos" full_name="if_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(696, 23)" end="(696, 24)" leading="" trailing="&#10;            " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <OtherNode start="(697, 13)" end="(697, 23)" kind="Lean.cdot" state_before="case neg.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;⊢ l[j] = a&#10;&#10;case neg.isTrue.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;⊢ a ∈ take j l" state_after="case neg.isTrue.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;⊢ a ∈ take j l" tactic="· simp_all">
                                                            <OtherNode start="(697, 13)" end="(697, 14)" kind="Lean.cdotTk">
                                                            <OtherNode start="(697, 13)" end="(697, 14)" kind="patternIgnore">
                                                            <OtherNode start="(697, 13)" end="(697, 14)" kind="token.«· »">
                                                            <AtomNode start="(697, 13)" end="(697, 14)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(697, 15)" end="(697, 23)">
                                                            <TacticTacticseq1IndentedNode start="(697, 15)" end="(697, 23)">
                                                            <NullNode start="(697, 15)" end="(697, 23)">
                                                            <OtherNode start="(697, 15)" end="(697, 23)" kind="Lean.Parser.Tactic.simpAll" state_before="case neg.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;⊢ l[j] = a" state_after="no goals" tactic="simp_all">
                                                            <AtomNode start="(697, 15)" end="(697, 23)" leading="" trailing="&#10;            " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <OtherNode start="(698, 13)" end="(700, 39)" kind="Lean.cdot" state_before="case neg.isTrue.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;⊢ a ∈ take j l" state_after="no goals" tactic="· simp only [mem_take_iff_getElem]&#10;  simp only [length_set] at h₁&#10;  exact ⟨i, by omega, h.1⟩">
                                                            <OtherNode start="(698, 13)" end="(698, 14)" kind="Lean.cdotTk">
                                                            <OtherNode start="(698, 13)" end="(698, 14)" kind="patternIgnore">
                                                            <OtherNode start="(698, 13)" end="(698, 14)" kind="token.«· »">
                                                            <AtomNode start="(698, 13)" end="(698, 14)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(698, 15)" end="(700, 39)">
                                                            <TacticTacticseq1IndentedNode start="(698, 15)" end="(700, 39)">
                                                            <NullNode start="(698, 15)" end="(700, 39)">
                                                            <OtherNode start="(698, 15)" end="(698, 47)" kind="Lean.Parser.Tactic.simp" state_before="case neg.isTrue.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;⊢ a ∈ take j l" state_after="case neg.isTrue.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;⊢ ∃ j_1 hm, l[j_1] = a" tactic="simp only [mem_take_iff_getElem]">
                                                            <AtomNode start="(698, 15)" end="(698, 19)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(698, 20)" end="(698, 24)">
                                                            <AtomNode start="(698, 20)" end="(698, 24)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(698, 25)" end="(698, 47)">
                                                            <AtomNode start="(698, 25)" end="(698, 26)" leading="" trailing="" val="["/>
                                                            <NullNode start="(698, 26)" end="(698, 46)">
                                                            <OtherNode start="(698, 26)" end="(698, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(698, 26)" end="(698, 46)" leading="" trailing="" raw_val="mem_take_iff_getElem" val="mem_take_iff_getElem" full_name="List.mem_take_iff_getElem" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(698, 46)" end="(698, 47)" leading="" trailing="&#10;              " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(699, 15)" end="(699, 43)" kind="Lean.Parser.Tactic.simp" state_before="case neg.isTrue.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;⊢ ∃ j_1 hm, l[j_1] = a" state_after="case neg.isTrue.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁✝ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;h₁ : j &amp;lt; l.length&#10;⊢ ∃ j_1 hm, l[j_1] = a" tactic="simp only [length_set] at h₁">
                                                            <AtomNode start="(699, 15)" end="(699, 19)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(699, 20)" end="(699, 24)">
                                                            <AtomNode start="(699, 20)" end="(699, 24)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(699, 25)" end="(699, 37)">
                                                            <AtomNode start="(699, 25)" end="(699, 26)" leading="" trailing="" val="["/>
                                                            <NullNode start="(699, 26)" end="(699, 36)">
                                                            <OtherNode start="(699, 26)" end="(699, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(699, 26)" end="(699, 36)" leading="" trailing="" raw_val="length_set" val="length_set" full_name="List.length_set" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(699, 36)" end="(699, 37)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(699, 38)" end="(699, 43)">
                                                            <OtherNode start="(699, 38)" end="(699, 43)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(699, 38)" end="(699, 40)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(699, 41)" end="(699, 43)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(699, 41)" end="(699, 43)">
                                                            <IdentNode start="(699, 41)" end="(699, 43)" leading="" trailing="&#10;              " raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(700, 15)" end="(700, 39)" kind="Lean.Parser.Tactic.exact" state_before="case neg.isTrue.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁✝ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;h₁ : j &amp;lt; l.length&#10;⊢ ∃ j_1 hm, l[j_1] = a" state_after="no goals" tactic="exact ⟨i, by omega, h.1⟩">
                                                            <AtomNode start="(700, 15)" end="(700, 20)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(700, 21)" end="(700, 39)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(700, 21)" end="(700, 22)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(700, 22)" end="(700, 38)">
                                                            <IdentNode start="(700, 22)" end="(700, 23)" leading="" trailing="" raw_val="i" val="i"/>
                                                            <AtomNode start="(700, 23)" end="(700, 24)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(700, 25)" end="(700, 33)">
                                                            <AtomNode start="(700, 25)" end="(700, 27)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(700, 28)" end="(700, 33)">
                                                            <TacticTacticseq1IndentedNode start="(700, 28)" end="(700, 33)">
                                                            <NullNode start="(700, 28)" end="(700, 33)">
                                                            <OtherNode start="(700, 28)" end="(700, 33)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁✝ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : (l[j] == a) = true&#10;h₁ : j &amp;lt; l.length&#10;⊢ ↑i &amp;lt; min j l.length" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(700, 28)" end="(700, 33)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(700, 33)" end="(700, 34)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(700, 35)" end="(700, 38)" kind="Lean.Parser.Term.proj">
                                                            <IdentNode start="(700, 35)" end="(700, 36)" leading="" trailing="" raw_val="h" val="h"/>
                                                            <AtomNode start="(700, 36)" end="(700, 37)" leading="" trailing="" val="."/>
                                                            <OtherNode start="(700, 37)" end="(700, 38)" kind="fieldIdx">
                                                            <AtomNode start="(700, 37)" end="(700, 38)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(700, 38)" end="(700, 39)" leading="" trailing="&#10;          " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(701, 11)" end="(701, 16)" kind="Lean.cdot" state_before="case neg.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : ¬(l[j] == a) = true&#10;⊢ l[j] = l[j]" state_after="no goals" tactic="· rfl">
                                                    <OtherNode start="(701, 11)" end="(701, 12)" kind="Lean.cdotTk">
                                                      <OtherNode start="(701, 11)" end="(701, 12)" kind="patternIgnore">
                                                        <OtherNode start="(701, 11)" end="(701, 12)" kind="token.«· »">
                                                          <AtomNode start="(701, 11)" end="(701, 12)" leading="" trailing=" " val="·"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <TacticTacticseqNode start="(701, 13)" end="(701, 16)">
                                                      <TacticTacticseq1IndentedNode start="(701, 13)" end="(701, 16)">
                                                        <NullNode start="(701, 13)" end="(701, 16)">
                                                          <OtherNode start="(701, 13)" end="(701, 16)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case neg.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a b : α&#10;x✝ : Option (Fin l.toArray.size)&#10;i : Fin l.toArray.size&#10;h : l[↑i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[↑j] = a&#10;j : Nat&#10;h₁ : j &amp;lt; (l.set (↑i) b).length&#10;h₂ : j &amp;lt; (l.replace a b).length&#10;h₃✝ : ¬j &amp;lt; ↑i&#10;h₃ : ¬j = ↑i&#10;h✝ : ¬(l[j] == a) = true&#10;⊢ l[j] = l[j]" state_after="no goals" tactic="rfl">
                                                            <AtomNode start="(701, 13)" end="(701, 16)" leading="" trailing="&#10;&#10;" val="rfl"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(703, 1)" end="(705, 53)" name="leftpad_toArray" full_name="List.leftpad_toArray">
      <CommandDeclmodifiersNode start="(703, 1)" end="(703, 8)">
        <NullNode/>
        <NullNode start="(703, 1)" end="(703, 8)">
          <OtherNode start="(703, 1)" end="(703, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(703, 1)" end="(703, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(703, 3)" end="(703, 7)">
              <OtherNode start="(703, 3)" end="(703, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(703, 3)" end="(703, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(703, 3)" end="(703, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(703, 7)" end="(703, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(703, 9)" end="(705, 53)" name="leftpad_toArray" full_name="List.leftpad_toArray" _is_private_decl="False">
        <AtomNode start="(703, 9)" end="(703, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(703, 17)" end="(703, 32)">
          <IdentNode start="(703, 17)" end="(703, 32)" leading="" trailing=" " raw_val="leftpad_toArray" val="leftpad_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(703, 33)" end="(704, 58)">
          <NullNode start="(703, 33)" end="(703, 63)">
            <TermExplicitbinderNode start="(703, 33)" end="(703, 42)">
              <AtomNode start="(703, 33)" end="(703, 34)" leading="" trailing="" val="("/>
              <NullNode start="(703, 34)" end="(703, 35)">
                <IdentNode start="(703, 34)" end="(703, 35)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(703, 36)" end="(703, 41)">
                <AtomNode start="(703, 36)" end="(703, 37)" leading="" trailing=" " val=":"/>
                <IdentNode start="(703, 38)" end="(703, 41)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(703, 41)" end="(703, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(703, 43)" end="(703, 50)">
              <AtomNode start="(703, 43)" end="(703, 44)" leading="" trailing="" val="("/>
              <NullNode start="(703, 44)" end="(703, 45)">
                <IdentNode start="(703, 44)" end="(703, 45)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(703, 46)" end="(703, 49)">
                <AtomNode start="(703, 46)" end="(703, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(703, 48)" end="(703, 49)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(703, 49)" end="(703, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(703, 51)" end="(703, 63)">
              <AtomNode start="(703, 51)" end="(703, 52)" leading="" trailing="" val="("/>
              <NullNode start="(703, 52)" end="(703, 53)">
                <IdentNode start="(703, 52)" end="(703, 53)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(703, 54)" end="(703, 62)">
                <AtomNode start="(703, 54)" end="(703, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(703, 56)" end="(703, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(703, 56)" end="(703, 60)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(703, 61)" end="(703, 62)">
                    <IdentNode start="(703, 61)" end="(703, 62)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(703, 62)" end="(703, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(703, 64)" end="(704, 58)">
            <AtomNode start="(703, 64)" end="(703, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(704, 5)" end="(704, 58)" kind="«term_=_»">
              <OtherNode start="(704, 5)" end="(704, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(704, 5)" end="(704, 18)" leading="" trailing=" " raw_val="Array.leftpad" val="Array.leftpad" full_name="Array.leftpad" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(704, 19)" end="(704, 32)">
                  <IdentNode start="(704, 19)" end="(704, 20)" leading="" trailing=" " raw_val="n" val="n"/>
                  <IdentNode start="(704, 21)" end="(704, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                  <IdentNode start="(704, 23)" end="(704, 32)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(704, 33)" end="(704, 34)" leading="" trailing=" " val="="/>
              <OtherNode start="(704, 35)" end="(704, 58)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(704, 35)" end="(704, 50)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(704, 35)" end="(704, 36)" leading="" trailing="" val="("/>
                  <OtherNode start="(704, 36)" end="(704, 49)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(704, 36)" end="(704, 43)" leading="" trailing=" " raw_val="leftpad" val="leftpad" full_name="List.leftpad" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(704, 44)" end="(704, 49)">
                      <IdentNode start="(704, 44)" end="(704, 45)" leading="" trailing=" " raw_val="n" val="n"/>
                      <IdentNode start="(704, 46)" end="(704, 47)" leading="" trailing=" " raw_val="a" val="a"/>
                      <IdentNode start="(704, 48)" end="(704, 49)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(704, 49)" end="(704, 50)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(704, 50)" end="(704, 51)" leading="" trailing="" val="."/>
                <IdentNode start="(704, 51)" end="(704, 58)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(704, 59)" end="(705, 53)">
          <AtomNode start="(704, 59)" end="(704, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(704, 62)" end="(705, 53)">
            <AtomNode start="(704, 62)" end="(704, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(705, 3)" end="(705, 53)">
              <TacticTacticseq1IndentedNode start="(705, 3)" end="(705, 53)">
                <NullNode start="(705, 3)" end="(705, 53)">
                  <OtherNode start="(705, 3)" end="(705, 53)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;l : List α&#10;⊢ Array.leftpad n a l.toArray = (leftpad n a l).toArray" state_after="no goals" tactic="simp [leftpad, Array.leftpad, ← toArray_replicate]">
                    <AtomNode start="(705, 3)" end="(705, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(705, 8)" end="(705, 53)">
                      <AtomNode start="(705, 8)" end="(705, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(705, 9)" end="(705, 52)">
                        <OtherNode start="(705, 9)" end="(705, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(705, 9)" end="(705, 16)" leading="" trailing="" raw_val="leftpad" val="leftpad" full_name="List.leftpad" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(705, 16)" end="(705, 17)" leading="" trailing=" " val=","/>
                        <OtherNode start="(705, 18)" end="(705, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(705, 18)" end="(705, 31)" leading="" trailing="" raw_val="Array.leftpad" val="Array.leftpad" full_name="Array.leftpad" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(705, 31)" end="(705, 32)" leading="" trailing=" " val=","/>
                        <OtherNode start="(705, 33)" end="(705, 52)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(705, 33)" end="(705, 34)">
                            <OtherNode start="(705, 33)" end="(705, 34)" kind="patternIgnore">
                              <OtherNode start="(705, 33)" end="(705, 34)" kind="token.«← »">
                                <AtomNode start="(705, 33)" end="(705, 34)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(705, 35)" end="(705, 52)" leading="" trailing="" raw_val="toArray_replicate" val="toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(543, 17)" def_end="(543, 34)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(705, 52)" end="(705, 53)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(707, 1)" end="(709, 55)" name="rightpad_toArray" full_name="List.rightpad_toArray">
      <CommandDeclmodifiersNode start="(707, 1)" end="(707, 8)">
        <NullNode/>
        <NullNode start="(707, 1)" end="(707, 8)">
          <OtherNode start="(707, 1)" end="(707, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(707, 1)" end="(707, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(707, 3)" end="(707, 7)">
              <OtherNode start="(707, 3)" end="(707, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(707, 3)" end="(707, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(707, 3)" end="(707, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(707, 7)" end="(707, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(707, 9)" end="(709, 55)" name="rightpad_toArray" full_name="List.rightpad_toArray" _is_private_decl="False">
        <AtomNode start="(707, 9)" end="(707, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(707, 17)" end="(707, 33)">
          <IdentNode start="(707, 17)" end="(707, 33)" leading="" trailing=" " raw_val="rightpad_toArray" val="rightpad_toArray"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(707, 34)" end="(708, 60)">
          <NullNode start="(707, 34)" end="(707, 64)">
            <TermExplicitbinderNode start="(707, 34)" end="(707, 43)">
              <AtomNode start="(707, 34)" end="(707, 35)" leading="" trailing="" val="("/>
              <NullNode start="(707, 35)" end="(707, 36)">
                <IdentNode start="(707, 35)" end="(707, 36)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(707, 37)" end="(707, 42)">
                <AtomNode start="(707, 37)" end="(707, 38)" leading="" trailing=" " val=":"/>
                <IdentNode start="(707, 39)" end="(707, 42)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(707, 42)" end="(707, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(707, 44)" end="(707, 51)">
              <AtomNode start="(707, 44)" end="(707, 45)" leading="" trailing="" val="("/>
              <NullNode start="(707, 45)" end="(707, 46)">
                <IdentNode start="(707, 45)" end="(707, 46)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(707, 47)" end="(707, 50)">
                <AtomNode start="(707, 47)" end="(707, 48)" leading="" trailing=" " val=":"/>
                <IdentNode start="(707, 49)" end="(707, 50)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(707, 50)" end="(707, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(707, 52)" end="(707, 64)">
              <AtomNode start="(707, 52)" end="(707, 53)" leading="" trailing="" val="("/>
              <NullNode start="(707, 53)" end="(707, 54)">
                <IdentNode start="(707, 53)" end="(707, 54)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(707, 55)" end="(707, 63)">
                <AtomNode start="(707, 55)" end="(707, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(707, 57)" end="(707, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(707, 57)" end="(707, 61)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(707, 62)" end="(707, 63)">
                    <IdentNode start="(707, 62)" end="(707, 63)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(707, 63)" end="(707, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(707, 65)" end="(708, 60)">
            <AtomNode start="(707, 65)" end="(707, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(708, 5)" end="(708, 60)" kind="«term_=_»">
              <OtherNode start="(708, 5)" end="(708, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(708, 5)" end="(708, 19)" leading="" trailing=" " raw_val="Array.rightpad" val="Array.rightpad" full_name="Array.rightpad" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                <NullNode start="(708, 20)" end="(708, 33)">
                  <IdentNode start="(708, 20)" end="(708, 21)" leading="" trailing=" " raw_val="n" val="n"/>
                  <IdentNode start="(708, 22)" end="(708, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                  <IdentNode start="(708, 24)" end="(708, 33)" leading="" trailing=" " raw_val="l.toArray" val="l.toArray"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(708, 34)" end="(708, 35)" leading="" trailing=" " val="="/>
              <OtherNode start="(708, 36)" end="(708, 60)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(708, 36)" end="(708, 52)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(708, 36)" end="(708, 37)" leading="" trailing="" val="("/>
                  <OtherNode start="(708, 37)" end="(708, 51)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(708, 37)" end="(708, 45)" leading="" trailing=" " raw_val="rightpad" val="rightpad" full_name="List.rightpad" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(708, 46)" end="(708, 51)">
                      <IdentNode start="(708, 46)" end="(708, 47)" leading="" trailing=" " raw_val="n" val="n"/>
                      <IdentNode start="(708, 48)" end="(708, 49)" leading="" trailing=" " raw_val="a" val="a"/>
                      <IdentNode start="(708, 50)" end="(708, 51)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(708, 51)" end="(708, 52)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(708, 52)" end="(708, 53)" leading="" trailing="" val="."/>
                <IdentNode start="(708, 53)" end="(708, 60)" leading="" trailing=" " raw_val="toArray" val="toArray" full_name="List.toArray" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(708, 61)" end="(709, 55)">
          <AtomNode start="(708, 61)" end="(708, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(708, 64)" end="(709, 55)">
            <AtomNode start="(708, 64)" end="(708, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(709, 3)" end="(709, 55)">
              <TacticTacticseq1IndentedNode start="(709, 3)" end="(709, 55)">
                <NullNode start="(709, 3)" end="(709, 55)">
                  <OtherNode start="(709, 3)" end="(709, 55)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;l : List α&#10;⊢ Array.rightpad n a l.toArray = (rightpad n a l).toArray" state_after="no goals" tactic="simp [rightpad, Array.rightpad, ← toArray_replicate]">
                    <AtomNode start="(709, 3)" end="(709, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(709, 8)" end="(709, 55)">
                      <AtomNode start="(709, 8)" end="(709, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(709, 9)" end="(709, 54)">
                        <OtherNode start="(709, 9)" end="(709, 17)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(709, 9)" end="(709, 17)" leading="" trailing="" raw_val="rightpad" val="rightpad" full_name="List.rightpad" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(709, 17)" end="(709, 18)" leading="" trailing=" " val=","/>
                        <OtherNode start="(709, 19)" end="(709, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(709, 19)" end="(709, 33)" leading="" trailing="" raw_val="Array.rightpad" val="Array.rightpad" full_name="Array.rightpad" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(709, 33)" end="(709, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(709, 35)" end="(709, 54)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(709, 35)" end="(709, 36)">
                            <OtherNode start="(709, 35)" end="(709, 36)" kind="patternIgnore">
                              <OtherNode start="(709, 35)" end="(709, 36)" kind="token.«← »">
                                <AtomNode start="(709, 35)" end="(709, 36)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(709, 37)" end="(709, 54)" leading="" trailing="" raw_val="toArray_replicate" val="toArray_replicate" full_name="List.toArray_replicate" mod_name="Init.Data.List.ToArray" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/ToArray.lean" def_start="(543, 17)" def_end="(543, 34)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(709, 54)" end="(709, 55)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(711, 1)" end="(711, 9)" name="List">
      <AtomNode start="(711, 1)" end="(711, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(711, 5)" end="(711, 9)">
        <IdentNode start="(711, 5)" end="(711, 9)" leading="" trailing="&#10;" raw_val="List" val="List"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(15, 1)" end="(18, 3)" text="### Lemmas about `List.toArray`.&#10;&#10;We prefer to pull `List.toArray` outwards past `Array` operations.&#10;-/"/>
    <Comment start="(20, 38)" end="(24, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;-- TODO: restore after an update-stage0&#10;-- set_option linter.indexVariables true -- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(54, 1)" end="(56, 1)" text="-- We can't make this a `@[simp]` lemma because `#[] = [].toArray` at reducible transparency,&#10;-- so this would loop with `toList_eq_nil_iff`&#10;"/>
    <Comment start="(64, 1)" end="(65, 1)" text="-- This is not a `@[simp]` lemma because it is pushing `toArray` inwards.&#10;"/>
    <Comment start="(73, 1)" end="(73, 74)" text="Unapplied variant of `push_toArray`, useful for monadic reasoning. -/"/>
    <Comment start="(156, 1)" end="(156, 83)" text="Variant of `foldrM_toArray` with a side condition for the `start` argument. -/"/>
    <Comment start="(164, 1)" end="(164, 82)" text="Variant of `foldlM_toArray` with a side condition for the `stop` argument. -/"/>
    <Comment start="(171, 1)" end="(171, 80)" text="Variant of `forM_toArray` with a side condition for the `stop` argument. -/"/>
    <Comment start="(184, 1)" end="(184, 82)" text="Variant of `foldr_toArray` with a side condition for the `start` argument. -/"/>
    <Comment start="(191, 1)" end="(191, 81)" text="Variant of `foldl_toArray` with a side condition for the `stop` argument. -/"/>
    <Comment start="(239, 1)" end="(240, 1)" text="-- This is not marked as `@[simp]` as later we simplify all occurrences of `findSomeRevM?`.&#10;"/>
    <Comment start="(244, 1)" end="(245, 1)" text="-- This is not marked as `@[simp]` as later we simplify all occurrences of `findRevM?`.&#10;"/>
    <Comment start="(560, 24)" end="(561, 5)" text="-- Why doesn't this work via `simp`?&#10;    "/>
  </Comments>
</TracedFile>
