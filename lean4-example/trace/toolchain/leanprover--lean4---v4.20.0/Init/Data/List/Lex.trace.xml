<TracedFile path="src/lean/Init/Data/List/Lex.lean" md5="396e2ba51e7e35207739882d3ac79e82">
  <FileNode start="(1, 1)" end="(531, 9)">
    <ModuleHeaderNode start="(6, 1)" end="(10, 35)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(10, 35)">
        <ModuleImportNode start="(9, 1)" end="(9, 29)" module="Init.Data.List.Lemmas" path="src/lean/Init/Data/List/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 29)" leading="" trailing="&#10;" raw_val="Init.Data.List.Lemmas" val="Init.Data.List.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 35)" module="Init.Data.List.Nat.TakeDrop" path="src/lean/Init/Data/List/Nat/TakeDrop.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 35)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.List.Nat.TakeDrop" val="Init.Data.List.Nat.TakeDrop"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <OtherNode start="(12, 1)" end="(12, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(12, 1)" end="(12, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(12, 12)" end="(12, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(12, 33)" end="(12, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(13, 1)" end="(13, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(13, 1)" end="(13, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(13, 12)" end="(13, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(13, 34)" end="(13, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(15, 1)" end="(15, 15)" name="List">
      <AtomNode start="(15, 1)" end="(15, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(15, 11)" end="(15, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandModuledocNode start="(17, 1)" end="(17, 34)" comment="### Lexicographic ordering -/">
      <AtomNode start="(17, 1)" end="(17, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(17, 5)" end="(17, 34)" leading="" trailing="&#10;&#10;" val="### Lexicographic ordering -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(19, 1)" end="(19, 88)" name="lex_lt" full_name="List.lex_lt">
      <CommandDeclmodifiersNode start="(19, 1)" end="(19, 8)">
        <NullNode/>
        <NullNode start="(19, 1)" end="(19, 8)">
          <OtherNode start="(19, 1)" end="(19, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(19, 1)" end="(19, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(19, 3)" end="(19, 7)">
              <OtherNode start="(19, 3)" end="(19, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(19, 3)" end="(19, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(19, 3)" end="(19, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(19, 7)" end="(19, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(19, 9)" end="(19, 88)" name="lex_lt" full_name="List.lex_lt" _is_private_decl="False">
        <AtomNode start="(19, 9)" end="(19, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(19, 17)" end="(19, 23)">
          <IdentNode start="(19, 17)" end="(19, 23)" leading="" trailing=" " raw_val="lex_lt" val="lex_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(19, 24)" end="(19, 77)">
          <NullNode start="(19, 24)" end="(19, 47)">
            <OtherNode start="(19, 24)" end="(19, 30)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(19, 24)" end="(19, 25)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(19, 25)" end="(19, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(19, 25)" end="(19, 27)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(19, 28)" end="(19, 29)">
                  <IdentNode start="(19, 28)" end="(19, 29)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(19, 29)" end="(19, 30)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(19, 31)" end="(19, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(19, 31)" end="(19, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(19, 32)" end="(19, 37)">
                <IdentNode start="(19, 32)" end="(19, 34)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(19, 35)" end="(19, 37)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(19, 38)" end="(19, 46)">
                <AtomNode start="(19, 38)" end="(19, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(19, 40)" end="(19, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(19, 40)" end="(19, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(19, 45)" end="(19, 46)">
                    <IdentNode start="(19, 45)" end="(19, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(19, 46)" end="(19, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(19, 48)" end="(19, 77)">
            <AtomNode start="(19, 48)" end="(19, 49)" leading="" trailing=" " val=":"/>
            <OtherNode start="(19, 50)" end="(19, 77)" kind="«term_↔_»">
              <OtherNode start="(19, 50)" end="(19, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(19, 50)" end="(19, 53)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(19, 54)" end="(19, 67)">
                  <OtherNode start="(19, 54)" end="(19, 61)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(19, 54)" end="(19, 55)" leading="" trailing="" val="("/>
                    <OtherNode start="(19, 55)" end="(19, 60)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(19, 55)" end="(19, 56)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(19, 55)" end="(19, 56)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(19, 57)" end="(19, 58)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(19, 59)" end="(19, 60)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(19, 59)" end="(19, 60)" leading="" trailing="" val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(19, 60)" end="(19, 61)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(19, 62)" end="(19, 64)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <IdentNode start="(19, 65)" end="(19, 67)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(19, 68)" end="(19, 69)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(19, 70)" end="(19, 77)" kind="«term_&amp;lt;_»">
                <IdentNode start="(19, 70)" end="(19, 72)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(19, 73)" end="(19, 74)" leading="" trailing=" " val="&amp;lt;"/>
                <IdentNode start="(19, 75)" end="(19, 77)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(19, 78)" end="(19, 88)">
          <AtomNode start="(19, 78)" end="(19, 80)" leading="" trailing=" " val=":="/>
          <IdentNode start="(19, 81)" end="(19, 88)" leading="" trailing="&#10;" raw_val="Iff.rfl" val="Iff.rfl" full_name="Iff.rfl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(20, 1)" end="(20, 94)" name="not_lex_lt" full_name="List.not_lex_lt">
      <CommandDeclmodifiersNode start="(20, 1)" end="(20, 8)">
        <NullNode/>
        <NullNode start="(20, 1)" end="(20, 8)">
          <OtherNode start="(20, 1)" end="(20, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(20, 1)" end="(20, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(20, 3)" end="(20, 7)">
              <OtherNode start="(20, 3)" end="(20, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(20, 3)" end="(20, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(20, 3)" end="(20, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(20, 7)" end="(20, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(20, 9)" end="(20, 94)" name="not_lex_lt" full_name="List.not_lex_lt" _is_private_decl="False">
        <AtomNode start="(20, 9)" end="(20, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(20, 17)" end="(20, 27)">
          <IdentNode start="(20, 17)" end="(20, 27)" leading="" trailing=" " raw_val="not_lex_lt" val="not_lex_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(20, 28)" end="(20, 83)">
          <NullNode start="(20, 28)" end="(20, 51)">
            <OtherNode start="(20, 28)" end="(20, 34)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(20, 28)" end="(20, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(20, 29)" end="(20, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(20, 29)" end="(20, 31)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(20, 32)" end="(20, 33)">
                  <IdentNode start="(20, 32)" end="(20, 33)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(20, 33)" end="(20, 34)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(20, 35)" end="(20, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(20, 35)" end="(20, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(20, 36)" end="(20, 41)">
                <IdentNode start="(20, 36)" end="(20, 38)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(20, 39)" end="(20, 41)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(20, 42)" end="(20, 50)">
                <AtomNode start="(20, 42)" end="(20, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(20, 44)" end="(20, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(20, 44)" end="(20, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(20, 49)" end="(20, 50)">
                    <IdentNode start="(20, 49)" end="(20, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(20, 50)" end="(20, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(20, 52)" end="(20, 83)">
            <AtomNode start="(20, 52)" end="(20, 53)" leading="" trailing=" " val=":"/>
            <OtherNode start="(20, 54)" end="(20, 83)" kind="«term_↔_»">
              <OtherNode start="(20, 54)" end="(20, 73)" kind="«term¬_»">
                <AtomNode start="(20, 54)" end="(20, 55)" leading="" trailing=" " val="¬"/>
                <OtherNode start="(20, 56)" end="(20, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(20, 56)" end="(20, 59)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(20, 60)" end="(20, 73)">
                    <OtherNode start="(20, 60)" end="(20, 67)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(20, 60)" end="(20, 61)" leading="" trailing="" val="("/>
                      <OtherNode start="(20, 61)" end="(20, 66)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(20, 61)" end="(20, 62)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(20, 61)" end="(20, 62)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(20, 63)" end="(20, 64)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(20, 65)" end="(20, 66)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(20, 65)" end="(20, 66)" leading="" trailing="" val="·"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(20, 66)" end="(20, 67)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(20, 68)" end="(20, 70)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(20, 71)" end="(20, 73)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(20, 74)" end="(20, 75)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(20, 76)" end="(20, 83)" kind="«term_≤_»">
                <IdentNode start="(20, 76)" end="(20, 78)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                <AtomNode start="(20, 79)" end="(20, 80)" leading="" trailing=" " val="≤"/>
                <IdentNode start="(20, 81)" end="(20, 83)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(20, 84)" end="(20, 94)">
          <AtomNode start="(20, 84)" end="(20, 86)" leading="" trailing=" " val=":="/>
          <IdentNode start="(20, 87)" end="(20, 94)" leading="" trailing="&#10;&#10;" raw_val="Iff.rfl" val="Iff.rfl" full_name="Iff.rfl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(22, 1)" end="(22, 89)" name="not_lt_iff_ge" full_name="List.not_lt_iff_ge">
      <CommandDeclmodifiersNode start="(22, 1)" end="(22, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(22, 1)" end="(22, 10)">
          <OtherNode start="(22, 1)" end="(22, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(22, 1)" end="(22, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(22, 11)" end="(22, 89)" name="not_lt_iff_ge" full_name="List.not_lt_iff_ge" _is_private_decl="False">
        <AtomNode start="(22, 11)" end="(22, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(22, 19)" end="(22, 32)">
          <IdentNode start="(22, 19)" end="(22, 32)" leading="" trailing=" " raw_val="not_lt_iff_ge" val="not_lt_iff_ge"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(22, 33)" end="(22, 78)">
          <NullNode start="(22, 33)" end="(22, 56)">
            <OtherNode start="(22, 33)" end="(22, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(22, 33)" end="(22, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(22, 34)" end="(22, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(22, 34)" end="(22, 36)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(22, 37)" end="(22, 38)">
                  <IdentNode start="(22, 37)" end="(22, 38)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(22, 38)" end="(22, 39)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(22, 40)" end="(22, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(22, 40)" end="(22, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(22, 41)" end="(22, 46)">
                <IdentNode start="(22, 41)" end="(22, 43)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(22, 44)" end="(22, 46)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(22, 47)" end="(22, 55)">
                <AtomNode start="(22, 47)" end="(22, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(22, 49)" end="(22, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(22, 49)" end="(22, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(22, 54)" end="(22, 55)">
                    <IdentNode start="(22, 54)" end="(22, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(22, 55)" end="(22, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(22, 57)" end="(22, 78)">
            <AtomNode start="(22, 57)" end="(22, 58)" leading="" trailing=" " val=":"/>
            <OtherNode start="(22, 59)" end="(22, 78)" kind="«term_↔_»">
              <OtherNode start="(22, 59)" end="(22, 68)" kind="«term¬_»">
                <AtomNode start="(22, 59)" end="(22, 60)" leading="" trailing=" " val="¬"/>
                <OtherNode start="(22, 61)" end="(22, 68)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(22, 61)" end="(22, 63)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(22, 64)" end="(22, 65)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(22, 66)" end="(22, 68)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(22, 69)" end="(22, 70)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(22, 71)" end="(22, 78)" kind="«term_≤_»">
                <IdentNode start="(22, 71)" end="(22, 73)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                <AtomNode start="(22, 74)" end="(22, 75)" leading="" trailing=" " val="≤"/>
                <IdentNode start="(22, 76)" end="(22, 78)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(22, 79)" end="(22, 89)">
          <AtomNode start="(22, 79)" end="(22, 81)" leading="" trailing=" " val=":="/>
          <IdentNode start="(22, 82)" end="(22, 89)" leading="" trailing="&#10;" raw_val="Iff.rfl" val="Iff.rfl" full_name="Iff.rfl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(23, 1)" end="(25, 20)" name="not_le_iff_gt" full_name="List.not_le_iff_gt">
      <CommandDeclmodifiersNode start="(23, 1)" end="(23, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(23, 1)" end="(23, 10)">
          <OtherNode start="(23, 1)" end="(23, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(23, 1)" end="(23, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(23, 11)" end="(25, 20)" name="not_le_iff_gt" full_name="List.not_le_iff_gt" _is_private_decl="False">
        <AtomNode start="(23, 11)" end="(23, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(23, 19)" end="(23, 32)">
          <IdentNode start="(23, 19)" end="(23, 32)" leading="" trailing=" " raw_val="not_le_iff_gt" val="not_le_iff_gt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(23, 33)" end="(24, 24)">
          <NullNode start="(23, 33)" end="(23, 88)">
            <OtherNode start="(23, 33)" end="(23, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(23, 33)" end="(23, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(23, 34)" end="(23, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(23, 34)" end="(23, 45)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(23, 46)" end="(23, 47)">
                  <IdentNode start="(23, 46)" end="(23, 47)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(23, 47)" end="(23, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(23, 49)" end="(23, 55)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(23, 49)" end="(23, 50)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(23, 50)" end="(23, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(23, 50)" end="(23, 52)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(23, 53)" end="(23, 54)">
                  <IdentNode start="(23, 53)" end="(23, 54)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(23, 54)" end="(23, 55)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(23, 56)" end="(23, 71)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(23, 56)" end="(23, 57)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(23, 57)" end="(23, 70)" kind="Lean.Parser.Term.app">
                <IdentNode start="(23, 57)" end="(23, 68)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(23, 69)" end="(23, 70)">
                  <IdentNode start="(23, 69)" end="(23, 70)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(23, 70)" end="(23, 71)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(23, 72)" end="(23, 88)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(23, 72)" end="(23, 73)" leading="" trailing="" val="{"/>
              <NullNode start="(23, 73)" end="(23, 78)">
                <IdentNode start="(23, 73)" end="(23, 75)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(23, 76)" end="(23, 78)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(23, 79)" end="(23, 87)">
                <AtomNode start="(23, 79)" end="(23, 80)" leading="" trailing=" " val=":"/>
                <OtherNode start="(23, 81)" end="(23, 87)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(23, 81)" end="(23, 85)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(23, 86)" end="(23, 87)">
                    <IdentNode start="(23, 86)" end="(23, 87)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(23, 87)" end="(23, 88)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(23, 89)" end="(24, 24)">
            <AtomNode start="(23, 89)" end="(23, 90)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(24, 5)" end="(24, 24)" kind="«term_↔_»">
              <OtherNode start="(24, 5)" end="(24, 14)" kind="«term¬_»">
                <AtomNode start="(24, 5)" end="(24, 6)" leading="" trailing=" " val="¬"/>
                <OtherNode start="(24, 7)" end="(24, 14)" kind="«term_≤_»">
                  <IdentNode start="(24, 7)" end="(24, 9)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(24, 10)" end="(24, 11)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(24, 12)" end="(24, 14)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(24, 15)" end="(24, 16)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(24, 17)" end="(24, 24)" kind="«term_&amp;lt;_»">
                <IdentNode start="(24, 17)" end="(24, 19)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                <AtomNode start="(24, 20)" end="(24, 21)" leading="" trailing=" " val="&amp;lt;"/>
                <IdentNode start="(24, 22)" end="(24, 24)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(24, 25)" end="(25, 20)">
          <AtomNode start="(24, 25)" end="(24, 27)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(25, 3)" end="(25, 20)" leading="" trailing="&#10;&#10;" raw_val="Decidable.not_not" val="Decidable.not_not" full_name="Decidable.not_not" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(27, 1)" end="(32, 28)" name="lex_irrefl" full_name="List.lex_irrefl">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(27, 1)" end="(32, 28)" name="lex_irrefl" full_name="List.lex_irrefl" _is_private_decl="False">
        <AtomNode start="(27, 1)" end="(27, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(27, 9)" end="(27, 19)">
          <IdentNode start="(27, 9)" end="(27, 19)" leading="" trailing=" " raw_val="lex_irrefl" val="lex_irrefl"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(27, 20)" end="(27, 87)">
          <NullNode start="(27, 20)" end="(27, 74)">
            <OtherNode start="(27, 20)" end="(27, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(27, 20)" end="(27, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(27, 21)" end="(27, 22)">
                <IdentNode start="(27, 21)" end="(27, 22)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(27, 23)" end="(27, 37)">
                <AtomNode start="(27, 23)" end="(27, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(27, 25)" end="(27, 37)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(27, 25)" end="(27, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(27, 27)" end="(27, 28)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(27, 29)" end="(27, 37)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(27, 29)" end="(27, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(27, 31)" end="(27, 32)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(27, 33)" end="(27, 37)" kind="Lean.Parser.Term.prop">
                      <AtomNode start="(27, 33)" end="(27, 37)" leading="" trailing="" val="Prop"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(27, 37)" end="(27, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(27, 39)" end="(27, 61)">
              <AtomNode start="(27, 39)" end="(27, 40)" leading="" trailing="" val="("/>
              <NullNode start="(27, 40)" end="(27, 46)">
                <IdentNode start="(27, 40)" end="(27, 46)" leading="" trailing=" " raw_val="irrefl" val="irrefl"/>
              </NullNode>
              <NullNode start="(27, 47)" end="(27, 60)">
                <AtomNode start="(27, 47)" end="(27, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(27, 49)" end="(27, 60)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(27, 49)" end="(27, 50)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(27, 51)" end="(27, 52)">
                    <IdentNode start="(27, 51)" end="(27, 52)" leading="" trailing="" raw_val="x" val="x"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(27, 52)" end="(27, 53)" leading="" trailing=" " val=","/>
                  <OtherNode start="(27, 54)" end="(27, 60)" kind="«term¬_»">
                    <AtomNode start="(27, 54)" end="(27, 55)" leading="" trailing="" val="¬"/>
                    <OtherNode start="(27, 55)" end="(27, 60)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(27, 55)" end="(27, 56)" leading="" trailing=" " raw_val="r" val="r"/>
                      <NullNode start="(27, 57)" end="(27, 60)">
                        <IdentNode start="(27, 57)" end="(27, 58)" leading="" trailing=" " raw_val="x" val="x"/>
                        <IdentNode start="(27, 59)" end="(27, 60)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(27, 60)" end="(27, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(27, 62)" end="(27, 74)">
              <AtomNode start="(27, 62)" end="(27, 63)" leading="" trailing="" val="("/>
              <NullNode start="(27, 63)" end="(27, 64)">
                <IdentNode start="(27, 63)" end="(27, 64)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(27, 65)" end="(27, 73)">
                <AtomNode start="(27, 65)" end="(27, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(27, 67)" end="(27, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(27, 67)" end="(27, 71)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(27, 72)" end="(27, 73)">
                    <IdentNode start="(27, 72)" end="(27, 73)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(27, 73)" end="(27, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(27, 75)" end="(27, 87)">
            <AtomNode start="(27, 75)" end="(27, 76)" leading="" trailing=" " val=":"/>
            <OtherNode start="(27, 77)" end="(27, 87)" kind="«term¬_»">
              <AtomNode start="(27, 77)" end="(27, 78)" leading="" trailing="" val="¬"/>
              <OtherNode start="(27, 78)" end="(27, 87)" kind="Lean.Parser.Term.app">
                <IdentNode start="(27, 78)" end="(27, 81)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(27, 82)" end="(27, 87)">
                  <IdentNode start="(27, 82)" end="(27, 83)" leading="" trailing=" " raw_val="r" val="r"/>
                  <IdentNode start="(27, 84)" end="(27, 85)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(27, 86)" end="(27, 87)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(27, 88)" end="(32, 28)">
          <AtomNode start="(27, 88)" end="(27, 90)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(27, 91)" end="(32, 28)">
            <AtomNode start="(27, 91)" end="(27, 93)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(28, 3)" end="(32, 28)">
              <TacticTacticseq1IndentedNode start="(28, 3)" end="(32, 28)">
                <NullNode start="(28, 3)" end="(32, 28)">
                  <OtherNode start="(28, 3)" end="(32, 28)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;r : α → α → Prop&#10;irrefl : ∀ (x : α), ¬r x x&#10;l : List α&#10;⊢ ¬Lex r l l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; nofun&#10;| cons a l ih =&amp;gt; intro&#10;  | .rel h =&amp;gt; exact irrefl _ h&#10;  | .cons h =&amp;gt; exact ih h">
                    <AtomNode start="(28, 3)" end="(28, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(28, 13)" end="(28, 14)">
                      <OtherNode start="(28, 13)" end="(28, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(28, 13)" end="(28, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(28, 15)" end="(32, 28)">
                      <OtherNode start="(28, 15)" end="(32, 28)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(28, 15)" end="(28, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(29, 3)" end="(32, 28)">
                          <OtherNode start="(29, 3)" end="(29, 17)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(29, 3)" end="(29, 8)">
                              <OtherNode start="(29, 3)" end="(29, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(29, 3)" end="(29, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(29, 5)" end="(29, 8)">
                                  <NullNode/>
                                  <IdentNode start="(29, 5)" end="(29, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(29, 9)" end="(29, 17)">
                              <AtomNode start="(29, 9)" end="(29, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(29, 12)" end="(29, 17)">
                                <TacticTacticseq1IndentedNode start="(29, 12)" end="(29, 17)">
                                  <NullNode start="(29, 12)" end="(29, 17)">
                                    <OtherNode start="(29, 12)" end="(29, 17)" kind="Lean.Parser.Tactic.tacticNofun" state_before="case nil&#10;α : Type u_1&#10;r : α → α → Prop&#10;irrefl : ∀ (x : α), ¬r x x&#10;⊢ ¬Lex r [] []" state_after="no goals" tactic="nofun">
                                      <AtomNode start="(29, 12)" end="(29, 17)" leading="" trailing="&#10;  " val="nofun"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(30, 3)" end="(32, 28)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(30, 3)" end="(30, 16)">
                              <OtherNode start="(30, 3)" end="(30, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(30, 3)" end="(30, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(30, 5)" end="(30, 9)">
                                  <NullNode/>
                                  <IdentNode start="(30, 5)" end="(30, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(30, 10)" end="(30, 16)">
                                  <IdentNode start="(30, 10)" end="(30, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(30, 12)" end="(30, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(30, 14)" end="(30, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(30, 17)" end="(32, 28)">
                              <AtomNode start="(30, 17)" end="(30, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(30, 20)" end="(32, 28)">
                                <TacticTacticseq1IndentedNode start="(30, 20)" end="(32, 28)">
                                  <NullNode start="(30, 20)" end="(32, 28)">
                                    <OtherNode start="(30, 20)" end="(32, 28)" kind="Lean.Parser.Tactic.introMatch" state_before="case cons&#10;α : Type u_1&#10;r : α → α → Prop&#10;irrefl : ∀ (x : α), ¬r x x&#10;a : α&#10;l : List α&#10;ih : ¬Lex r l l&#10;⊢ ¬Lex r (a :: l) (a :: l)" state_after="no goals" tactic="intro&#10;| .rel h =&amp;gt; exact irrefl _ h&#10;| .cons h =&amp;gt; exact ih h">
                                      <AtomNode start="(30, 20)" end="(30, 25)" leading="" trailing="&#10;    " val="intro"/>
                                      <OtherNode start="(31, 5)" end="(32, 28)" kind="Lean.Parser.Term.matchAlts">
                                        <NullNode start="(31, 5)" end="(32, 28)">
                                          <OtherNode start="(31, 5)" end="(31, 33)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(31, 5)" end="(31, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(31, 7)" end="(31, 13)">
                                              <NullNode start="(31, 7)" end="(31, 13)">
                                                <OtherNode start="(31, 7)" end="(31, 13)" kind="Lean.Parser.Term.app">
                                                  <OtherNode start="(31, 7)" end="(31, 11)" kind="Lean.Parser.Term.dotIdent">
                                                    <AtomNode start="(31, 7)" end="(31, 8)" leading="" trailing="" val="."/>
                                                    <IdentNode start="(31, 8)" end="(31, 11)" leading="" trailing=" " raw_val="rel" val="rel"/>
                                                  </OtherNode>
                                                  <NullNode start="(31, 12)" end="(31, 13)">
                                                    <IdentNode start="(31, 12)" end="(31, 13)" leading="" trailing=" " raw_val="h" val="h"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(31, 14)" end="(31, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(31, 17)" end="(31, 33)">
                                              <TacticTacticseq1IndentedNode start="(31, 17)" end="(31, 33)">
                                                <NullNode start="(31, 17)" end="(31, 33)">
                                                  <OtherNode start="(31, 17)" end="(31, 33)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;r : α → α → Prop&#10;irrefl : ∀ (x : α), ¬r x x&#10;a : α&#10;l : List α&#10;ih : ¬Lex r l l&#10;x✝ : Lex r (a :: l) (a :: l)&#10;h : r a a&#10;⊢ False" state_after="no goals" tactic="exact irrefl _ h">
                                                    <AtomNode start="(31, 17)" end="(31, 22)" leading="" trailing=" " val="exact"/>
                                                    <OtherNode start="(31, 23)" end="(31, 33)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(31, 23)" end="(31, 29)" leading="" trailing=" " raw_val="irrefl" val="irrefl"/>
                                                      <NullNode start="(31, 30)" end="(31, 33)">
                                                        <TermHoleNode start="(31, 30)" end="(31, 31)">
                                                          <AtomNode start="(31, 30)" end="(31, 31)" leading="" trailing=" " val="_"/>
                                                        </TermHoleNode>
                                                        <IdentNode start="(31, 32)" end="(31, 33)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <OtherNode start="(32, 5)" end="(32, 28)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(32, 5)" end="(32, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(32, 7)" end="(32, 14)">
                                              <NullNode start="(32, 7)" end="(32, 14)">
                                                <OtherNode start="(32, 7)" end="(32, 14)" kind="Lean.Parser.Term.app">
                                                  <OtherNode start="(32, 7)" end="(32, 12)" kind="Lean.Parser.Term.dotIdent">
                                                    <AtomNode start="(32, 7)" end="(32, 8)" leading="" trailing="" val="."/>
                                                    <IdentNode start="(32, 8)" end="(32, 12)" leading="" trailing=" " raw_val="cons" val="cons"/>
                                                  </OtherNode>
                                                  <NullNode start="(32, 13)" end="(32, 14)">
                                                    <IdentNode start="(32, 13)" end="(32, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(32, 15)" end="(32, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(32, 18)" end="(32, 28)">
                                              <TacticTacticseq1IndentedNode start="(32, 18)" end="(32, 28)">
                                                <NullNode start="(32, 18)" end="(32, 28)">
                                                  <OtherNode start="(32, 18)" end="(32, 28)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;r : α → α → Prop&#10;irrefl : ∀ (x : α), ¬r x x&#10;a : α&#10;l : List α&#10;ih : ¬Lex r l l&#10;x✝ : Lex r (a :: l) (a :: l)&#10;h : Lex r l l&#10;⊢ False" state_after="no goals" tactic="exact ih h">
                                                    <AtomNode start="(32, 18)" end="(32, 23)" leading="" trailing=" " val="exact"/>
                                                    <OtherNode start="(32, 24)" end="(32, 28)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(32, 24)" end="(32, 26)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                      <NullNode start="(32, 27)" end="(32, 28)">
                                                        <IdentNode start="(32, 27)" end="(32, 28)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(34, 1)" end="(35, 33)" name="lt_irrefl" full_name="List.lt_irrefl">
      <CommandDeclmodifiersNode start="(34, 1)" end="(34, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(34, 1)" end="(34, 10)">
          <OtherNode start="(34, 1)" end="(34, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(34, 1)" end="(34, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(34, 11)" end="(35, 33)" name="lt_irrefl" full_name="List.lt_irrefl" _is_private_decl="False">
        <AtomNode start="(34, 11)" end="(34, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(34, 19)" end="(34, 28)">
          <IdentNode start="(34, 19)" end="(34, 28)" leading="" trailing=" " raw_val="lt_irrefl" val="lt_irrefl"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(34, 29)" end="(34, 94)">
          <NullNode start="(34, 29)" end="(34, 84)">
            <OtherNode start="(34, 29)" end="(34, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(34, 29)" end="(34, 30)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(34, 30)" end="(34, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(34, 30)" end="(34, 32)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(34, 33)" end="(34, 34)">
                  <IdentNode start="(34, 33)" end="(34, 34)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(34, 34)" end="(34, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(34, 36)" end="(34, 71)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(34, 36)" end="(34, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(34, 37)" end="(34, 70)" kind="Lean.Parser.Term.app">
                <IdentNode start="(34, 37)" end="(34, 47)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(34, 48)" end="(34, 70)">
                  <OtherNode start="(34, 48)" end="(34, 70)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(34, 48)" end="(34, 49)" leading="" trailing="" val="("/>
                    <OtherNode start="(34, 49)" end="(34, 54)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(34, 49)" end="(34, 50)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(34, 49)" end="(34, 50)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(34, 51)" end="(34, 52)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(34, 53)" end="(34, 54)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(34, 53)" end="(34, 54)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(34, 55)" end="(34, 56)" leading="" trailing=" " val=":"/>
                    <NullNode start="(34, 57)" end="(34, 69)">
                      <OtherNode start="(34, 57)" end="(34, 69)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(34, 57)" end="(34, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(34, 59)" end="(34, 60)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(34, 61)" end="(34, 69)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(34, 61)" end="(34, 62)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(34, 63)" end="(34, 64)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(34, 65)" end="(34, 69)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(34, 65)" end="(34, 69)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(34, 69)" end="(34, 70)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(34, 70)" end="(34, 71)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(34, 72)" end="(34, 84)">
              <AtomNode start="(34, 72)" end="(34, 73)" leading="" trailing="" val="("/>
              <NullNode start="(34, 73)" end="(34, 74)">
                <IdentNode start="(34, 73)" end="(34, 74)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(34, 75)" end="(34, 83)">
                <AtomNode start="(34, 75)" end="(34, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(34, 77)" end="(34, 83)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(34, 77)" end="(34, 81)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(34, 82)" end="(34, 83)">
                    <IdentNode start="(34, 82)" end="(34, 83)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(34, 83)" end="(34, 84)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(34, 85)" end="(34, 94)">
            <AtomNode start="(34, 85)" end="(34, 86)" leading="" trailing=" " val=":"/>
            <OtherNode start="(34, 87)" end="(34, 94)" kind="«term¬_»">
              <AtomNode start="(34, 87)" end="(34, 88)" leading="" trailing=" " val="¬"/>
              <OtherNode start="(34, 89)" end="(34, 94)" kind="«term_&amp;lt;_»">
                <IdentNode start="(34, 89)" end="(34, 90)" leading="" trailing=" " raw_val="l" val="l"/>
                <AtomNode start="(34, 91)" end="(34, 92)" leading="" trailing=" " val="&amp;lt;"/>
                <IdentNode start="(34, 93)" end="(34, 94)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(34, 95)" end="(35, 33)">
          <AtomNode start="(34, 95)" end="(34, 97)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(35, 3)" end="(35, 33)" kind="Lean.Parser.Term.app">
            <IdentNode start="(35, 3)" end="(35, 13)" leading="" trailing=" " raw_val="lex_irrefl" val="lex_irrefl" full_name="List.lex_irrefl" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(27, 9)" def_end="(27, 19)"/>
            <NullNode start="(35, 14)" end="(35, 33)">
              <IdentNode start="(35, 14)" end="(35, 31)" leading="" trailing=" " raw_val="Std.Irrefl.irrefl" val="Std.Irrefl.irrefl" full_name="Std.Irrefl.irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
              <IdentNode start="(35, 32)" end="(35, 33)" leading="" trailing="&#10;&#10;" raw_val="l" val="l"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(37, 1)" end="(38, 27)" name="ltIrrefl" full_name="List.ltIrrefl">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandInstanceNode start="(37, 1)" end="(38, 27)" name="ltIrrefl">
        <TermAttrkindNode>
          <NullNode/>
        </TermAttrkindNode>
        <AtomNode start="(37, 1)" end="(37, 9)" leading="" trailing=" " val="instance"/>
        <NullNode/>
        <NullNode start="(37, 10)" end="(37, 18)">
          <CommandDeclidNode start="(37, 10)" end="(37, 18)">
            <IdentNode start="(37, 10)" end="(37, 18)" leading="" trailing=" " raw_val="ltIrrefl" val="ltIrrefl"/>
            <NullNode/>
          </CommandDeclidNode>
        </NullNode>
        <CommandDeclsigNode start="(37, 19)" end="(37, 96)">
          <NullNode start="(37, 19)" end="(37, 61)">
            <OtherNode start="(37, 19)" end="(37, 25)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(37, 19)" end="(37, 20)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(37, 20)" end="(37, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(37, 20)" end="(37, 22)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(37, 23)" end="(37, 24)">
                  <IdentNode start="(37, 23)" end="(37, 24)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(37, 24)" end="(37, 25)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(37, 26)" end="(37, 61)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(37, 26)" end="(37, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(37, 27)" end="(37, 60)" kind="Lean.Parser.Term.app">
                <IdentNode start="(37, 27)" end="(37, 37)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(37, 38)" end="(37, 60)">
                  <OtherNode start="(37, 38)" end="(37, 60)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(37, 38)" end="(37, 39)" leading="" trailing="" val="("/>
                    <OtherNode start="(37, 39)" end="(37, 44)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(37, 39)" end="(37, 40)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(37, 39)" end="(37, 40)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(37, 41)" end="(37, 42)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(37, 43)" end="(37, 44)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(37, 43)" end="(37, 44)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(37, 45)" end="(37, 46)" leading="" trailing=" " val=":"/>
                    <NullNode start="(37, 47)" end="(37, 59)">
                      <OtherNode start="(37, 47)" end="(37, 59)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(37, 47)" end="(37, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(37, 49)" end="(37, 50)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(37, 51)" end="(37, 59)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(37, 51)" end="(37, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(37, 53)" end="(37, 54)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(37, 55)" end="(37, 59)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(37, 55)" end="(37, 59)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(37, 59)" end="(37, 60)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(37, 60)" end="(37, 61)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(37, 62)" end="(37, 96)">
            <AtomNode start="(37, 62)" end="(37, 63)" leading="" trailing=" " val=":"/>
            <OtherNode start="(37, 64)" end="(37, 96)" kind="Lean.Parser.Term.app">
              <IdentNode start="(37, 64)" end="(37, 74)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
              <NullNode start="(37, 75)" end="(37, 96)">
                <OtherNode start="(37, 75)" end="(37, 88)" kind="Lean.Parser.Term.namedArgument">
                  <AtomNode start="(37, 75)" end="(37, 76)" leading="" trailing="" val="("/>
                  <IdentNode start="(37, 76)" end="(37, 77)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(37, 78)" end="(37, 80)" leading="" trailing=" " val=":="/>
                  <OtherNode start="(37, 81)" end="(37, 87)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(37, 81)" end="(37, 85)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(37, 86)" end="(37, 87)">
                      <IdentNode start="(37, 86)" end="(37, 87)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(37, 87)" end="(37, 88)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <OtherNode start="(37, 89)" end="(37, 96)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(37, 89)" end="(37, 90)" leading="" trailing="" val="("/>
                  <OtherNode start="(37, 90)" end="(37, 95)" kind="«term_&amp;lt;_»">
                    <OtherNode start="(37, 90)" end="(37, 91)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(37, 90)" end="(37, 91)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                    <AtomNode start="(37, 92)" end="(37, 93)" leading="" trailing=" " val="&amp;lt;"/>
                    <OtherNode start="(37, 94)" end="(37, 95)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(37, 94)" end="(37, 95)" leading="" trailing="" val="·"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(37, 95)" end="(37, 96)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandWherestructinstNode start="(37, 97)" end="(38, 27)">
          <AtomNode start="(37, 97)" end="(37, 102)" leading="" trailing="&#10;  " val="where"/>
          <OtherNode start="(38, 3)" end="(38, 27)" kind="Lean.Parser.Term.structInstFields">
            <NullNode start="(38, 3)" end="(38, 27)">
              <OtherNode start="(38, 3)" end="(38, 27)" kind="Lean.Parser.Term.structInstField">
                <OtherNode start="(38, 3)" end="(38, 9)" kind="Lean.Parser.Term.structInstLVal">
                  <IdentNode start="(38, 3)" end="(38, 9)" leading="" trailing=" " raw_val="irrefl" val="irrefl"/>
                  <NullNode/>
                </OtherNode>
                <NullNode start="(38, 10)" end="(38, 27)">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(38, 10)" end="(38, 27)" kind="Lean.Parser.Term.structInstFieldDef">
                    <AtomNode start="(38, 10)" end="(38, 12)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(38, 13)" end="(38, 27)" leading="" trailing="&#10;&#10;" raw_val="List.lt_irrefl" val="List.lt_irrefl" full_name="List.lt_irrefl" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(34, 19)" def_end="(34, 28)"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <NullNode/>
        </CommandWherestructinstNode>
      </CommandInstanceNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(40, 1)" end="(40, 64)" name="not_lex_nil" full_name="List.not_lex_nil">
      <CommandDeclmodifiersNode start="(40, 1)" end="(40, 8)">
        <NullNode/>
        <NullNode start="(40, 1)" end="(40, 8)">
          <OtherNode start="(40, 1)" end="(40, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(40, 1)" end="(40, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(40, 3)" end="(40, 7)">
              <OtherNode start="(40, 3)" end="(40, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(40, 3)" end="(40, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(40, 3)" end="(40, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(40, 7)" end="(40, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(40, 9)" end="(40, 64)" name="not_lex_nil" full_name="List.not_lex_nil" _is_private_decl="False">
        <AtomNode start="(40, 9)" end="(40, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(40, 17)" end="(40, 28)">
          <IdentNode start="(40, 17)" end="(40, 28)" leading="" trailing=" " raw_val="not_lex_nil" val="not_lex_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(40, 29)" end="(40, 42)">
          <NullNode/>
          <TermTypespecNode start="(40, 29)" end="(40, 42)">
            <AtomNode start="(40, 29)" end="(40, 30)" leading="" trailing=" " val=":"/>
            <OtherNode start="(40, 31)" end="(40, 42)" kind="«term¬_»">
              <AtomNode start="(40, 31)" end="(40, 32)" leading="" trailing="" val="¬"/>
              <OtherNode start="(40, 32)" end="(40, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(40, 32)" end="(40, 35)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(40, 36)" end="(40, 42)">
                  <IdentNode start="(40, 36)" end="(40, 37)" leading="" trailing=" " raw_val="r" val="r"/>
                  <IdentNode start="(40, 38)" end="(40, 39)" leading="" trailing=" " raw_val="l" val="l"/>
                  <OtherNode start="(40, 40)" end="(40, 42)" kind="«term[_]»">
                    <AtomNode start="(40, 40)" end="(40, 41)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(40, 41)" end="(40, 42)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(40, 43)" end="(40, 64)">
          <AtomNode start="(40, 43)" end="(40, 45)" leading="" trailing=" " val=":="/>
          <OtherNode start="(40, 46)" end="(40, 64)" kind="Lean.Parser.Term.fun">
            <AtomNode start="(40, 46)" end="(40, 49)" leading="" trailing=" " val="fun"/>
            <OtherNode start="(40, 50)" end="(40, 64)" kind="Lean.Parser.Term.basicFun">
              <NullNode start="(40, 50)" end="(40, 51)">
                <IdentNode start="(40, 50)" end="(40, 51)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(40, 52)" end="(40, 54)" leading="" trailing=" " val="=&amp;gt;"/>
              <OtherNode start="(40, 55)" end="(40, 64)" kind="Lean.Parser.Term.nomatch">
                <AtomNode start="(40, 55)" end="(40, 62)" leading="" trailing=" " val="nomatch"/>
                <NullNode start="(40, 63)" end="(40, 64)">
                  <IdentNode start="(40, 63)" end="(40, 64)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(42, 1)" end="(42, 80)" name="not_lt_nil" full_name="List.not_lt_nil">
      <CommandDeclmodifiersNode start="(42, 1)" end="(42, 8)">
        <NullNode/>
        <NullNode start="(42, 1)" end="(42, 8)">
          <OtherNode start="(42, 1)" end="(42, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(42, 1)" end="(42, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(42, 3)" end="(42, 7)">
              <OtherNode start="(42, 3)" end="(42, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(42, 3)" end="(42, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(42, 3)" end="(42, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(42, 7)" end="(42, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(42, 9)" end="(42, 80)" name="not_lt_nil" full_name="List.not_lt_nil" _is_private_decl="False">
        <AtomNode start="(42, 9)" end="(42, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(42, 17)" end="(42, 27)">
          <IdentNode start="(42, 17)" end="(42, 27)" leading="" trailing=" " raw_val="not_lt_nil" val="not_lt_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(42, 28)" end="(42, 58)">
          <NullNode start="(42, 28)" end="(42, 47)">
            <OtherNode start="(42, 28)" end="(42, 34)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(42, 28)" end="(42, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(42, 29)" end="(42, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(42, 29)" end="(42, 31)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(42, 32)" end="(42, 33)">
                  <IdentNode start="(42, 32)" end="(42, 33)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(42, 33)" end="(42, 34)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(42, 35)" end="(42, 47)">
              <AtomNode start="(42, 35)" end="(42, 36)" leading="" trailing="" val="("/>
              <NullNode start="(42, 36)" end="(42, 37)">
                <IdentNode start="(42, 36)" end="(42, 37)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(42, 38)" end="(42, 46)">
                <AtomNode start="(42, 38)" end="(42, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(42, 40)" end="(42, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(42, 40)" end="(42, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(42, 45)" end="(42, 46)">
                    <IdentNode start="(42, 45)" end="(42, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(42, 46)" end="(42, 47)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(42, 48)" end="(42, 58)">
            <AtomNode start="(42, 48)" end="(42, 49)" leading="" trailing=" " val=":"/>
            <OtherNode start="(42, 50)" end="(42, 58)" kind="«term¬_»">
              <AtomNode start="(42, 50)" end="(42, 51)" leading="" trailing=" " val="¬"/>
              <OtherNode start="(42, 52)" end="(42, 58)" kind="«term_&amp;lt;_»">
                <IdentNode start="(42, 52)" end="(42, 53)" leading="" trailing=" " raw_val="l" val="l"/>
                <AtomNode start="(42, 54)" end="(42, 55)" leading="" trailing=" " val="&amp;lt;"/>
                <OtherNode start="(42, 56)" end="(42, 58)" kind="«term[_]»">
                  <AtomNode start="(42, 56)" end="(42, 57)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(42, 57)" end="(42, 58)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(42, 59)" end="(42, 80)">
          <AtomNode start="(42, 59)" end="(42, 61)" leading="" trailing=" " val=":="/>
          <OtherNode start="(42, 62)" end="(42, 80)" kind="Lean.Parser.Term.fun">
            <AtomNode start="(42, 62)" end="(42, 65)" leading="" trailing=" " val="fun"/>
            <OtherNode start="(42, 66)" end="(42, 80)" kind="Lean.Parser.Term.basicFun">
              <NullNode start="(42, 66)" end="(42, 67)">
                <IdentNode start="(42, 66)" end="(42, 67)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(42, 68)" end="(42, 70)" leading="" trailing=" " val="=&amp;gt;"/>
              <OtherNode start="(42, 71)" end="(42, 80)" kind="Lean.Parser.Term.nomatch">
                <AtomNode start="(42, 71)" end="(42, 78)" leading="" trailing=" " val="nomatch"/>
                <NullNode start="(42, 79)" end="(42, 80)">
                  <IdentNode start="(42, 79)" end="(42, 80)" leading="" trailing="&#10;" raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(43, 1)" end="(43, 74)" name="nil_le" full_name="List.nil_le">
      <CommandDeclmodifiersNode start="(43, 1)" end="(43, 8)">
        <NullNode/>
        <NullNode start="(43, 1)" end="(43, 8)">
          <OtherNode start="(43, 1)" end="(43, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(43, 1)" end="(43, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(43, 3)" end="(43, 7)">
              <OtherNode start="(43, 3)" end="(43, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(43, 3)" end="(43, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(43, 3)" end="(43, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(43, 7)" end="(43, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(43, 9)" end="(43, 74)" name="nil_le" full_name="List.nil_le" _is_private_decl="False">
        <AtomNode start="(43, 9)" end="(43, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(43, 17)" end="(43, 23)">
          <IdentNode start="(43, 17)" end="(43, 23)" leading="" trailing=" " raw_val="nil_le" val="nil_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(43, 24)" end="(43, 52)">
          <NullNode start="(43, 24)" end="(43, 43)">
            <OtherNode start="(43, 24)" end="(43, 30)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(43, 24)" end="(43, 25)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(43, 25)" end="(43, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(43, 25)" end="(43, 27)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(43, 28)" end="(43, 29)">
                  <IdentNode start="(43, 28)" end="(43, 29)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(43, 29)" end="(43, 30)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(43, 31)" end="(43, 43)">
              <AtomNode start="(43, 31)" end="(43, 32)" leading="" trailing="" val="("/>
              <NullNode start="(43, 32)" end="(43, 33)">
                <IdentNode start="(43, 32)" end="(43, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(43, 34)" end="(43, 42)">
                <AtomNode start="(43, 34)" end="(43, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(43, 36)" end="(43, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(43, 36)" end="(43, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(43, 41)" end="(43, 42)">
                    <IdentNode start="(43, 41)" end="(43, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(43, 42)" end="(43, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(43, 44)" end="(43, 52)">
            <AtomNode start="(43, 44)" end="(43, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(43, 46)" end="(43, 52)" kind="«term_≤_»">
              <OtherNode start="(43, 46)" end="(43, 48)" kind="«term[_]»">
                <AtomNode start="(43, 46)" end="(43, 47)" leading="" trailing="" val="["/>
                <NullNode/>
                <AtomNode start="(43, 47)" end="(43, 48)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(43, 49)" end="(43, 50)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(43, 51)" end="(43, 52)" leading="" trailing=" " raw_val="l" val="l"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(43, 53)" end="(43, 74)">
          <AtomNode start="(43, 53)" end="(43, 55)" leading="" trailing=" " val=":="/>
          <OtherNode start="(43, 56)" end="(43, 74)" kind="Lean.Parser.Term.fun">
            <AtomNode start="(43, 56)" end="(43, 59)" leading="" trailing=" " val="fun"/>
            <OtherNode start="(43, 60)" end="(43, 74)" kind="Lean.Parser.Term.basicFun">
              <NullNode start="(43, 60)" end="(43, 61)">
                <IdentNode start="(43, 60)" end="(43, 61)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(43, 62)" end="(43, 64)" leading="" trailing=" " val="=&amp;gt;"/>
              <OtherNode start="(43, 65)" end="(43, 74)" kind="Lean.Parser.Term.nomatch">
                <AtomNode start="(43, 65)" end="(43, 72)" leading="" trailing=" " val="nomatch"/>
                <NullNode start="(43, 73)" end="(43, 74)">
                  <IdentNode start="(43, 73)" end="(43, 74)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(45, 1)" end="(52, 22)" name="not_nil_lex_iff" full_name="List.not_nil_lex_iff">
      <CommandDeclmodifiersNode start="(45, 1)" end="(45, 8)">
        <NullNode/>
        <NullNode start="(45, 1)" end="(45, 8)">
          <OtherNode start="(45, 1)" end="(45, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(45, 1)" end="(45, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(45, 3)" end="(45, 7)">
              <OtherNode start="(45, 3)" end="(45, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(45, 3)" end="(45, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(45, 3)" end="(45, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(45, 7)" end="(45, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(45, 9)" end="(52, 22)" name="not_nil_lex_iff" full_name="List.not_nil_lex_iff" _is_private_decl="False">
        <AtomNode start="(45, 9)" end="(45, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(45, 17)" end="(45, 32)">
          <IdentNode start="(45, 17)" end="(45, 32)" leading="" trailing=" " raw_val="not_nil_lex_iff" val="not_nil_lex_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(45, 33)" end="(45, 55)">
          <NullNode/>
          <TermTypespecNode start="(45, 33)" end="(45, 55)">
            <AtomNode start="(45, 33)" end="(45, 34)" leading="" trailing=" " val=":"/>
            <OtherNode start="(45, 35)" end="(45, 55)" kind="«term_↔_»">
              <OtherNode start="(45, 35)" end="(45, 46)" kind="«term¬_»">
                <AtomNode start="(45, 35)" end="(45, 36)" leading="" trailing="" val="¬"/>
                <OtherNode start="(45, 36)" end="(45, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(45, 36)" end="(45, 39)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(45, 40)" end="(45, 46)">
                    <IdentNode start="(45, 40)" end="(45, 41)" leading="" trailing=" " raw_val="r" val="r"/>
                    <OtherNode start="(45, 42)" end="(45, 44)" kind="«term[_]»">
                      <AtomNode start="(45, 42)" end="(45, 43)" leading="" trailing="" val="["/>
                      <NullNode/>
                      <AtomNode start="(45, 43)" end="(45, 44)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <IdentNode start="(45, 45)" end="(45, 46)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(45, 47)" end="(45, 48)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(45, 49)" end="(45, 55)" kind="«term_=_»">
                <IdentNode start="(45, 49)" end="(45, 50)" leading="" trailing=" " raw_val="l" val="l"/>
                <AtomNode start="(45, 51)" end="(45, 52)" leading="" trailing=" " val="="/>
                <OtherNode start="(45, 53)" end="(45, 55)" kind="«term[_]»">
                  <AtomNode start="(45, 53)" end="(45, 54)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(45, 54)" end="(45, 55)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(45, 56)" end="(52, 22)">
          <AtomNode start="(45, 56)" end="(45, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(45, 59)" end="(52, 22)">
            <AtomNode start="(45, 59)" end="(45, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(46, 3)" end="(52, 22)">
              <TacticTacticseq1IndentedNode start="(46, 3)" end="(52, 22)">
                <NullNode start="(46, 3)" end="(52, 22)">
                  <OtherNode start="(46, 3)" end="(46, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;l : List α✝&#10;⊢ ¬Lex r [] l ↔ l = []" state_after="case mp&#10;α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;l : List α✝&#10;⊢ ¬Lex r [] l → l = []&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;l : List α✝&#10;⊢ l = [] → ¬Lex r [] l" tactic="constructor">
                    <AtomNode start="(46, 3)" end="(46, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(47, 3)" end="(50, 48)" kind="Lean.cdot" state_before="case mp&#10;α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;l : List α✝&#10;⊢ ¬Lex r [] l → l = []&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;l : List α✝&#10;⊢ l = [] → ¬Lex r [] l" state_after="case mpr&#10;α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;l : List α✝&#10;⊢ l = [] → ¬Lex r [] l" tactic="· rintro h&#10;  match l, h with&#10;  | [], h =&amp;gt; rfl&#10;  | a :: _, h =&amp;gt; exact False.elim (h Lex.nil)">
                    <OtherNode start="(47, 3)" end="(47, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(47, 3)" end="(47, 4)" kind="patternIgnore">
                        <OtherNode start="(47, 3)" end="(47, 4)" kind="token.«· »">
                          <AtomNode start="(47, 3)" end="(47, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(47, 5)" end="(50, 48)">
                      <TacticTacticseq1IndentedNode start="(47, 5)" end="(50, 48)">
                        <NullNode start="(47, 5)" end="(50, 48)">
                          <OtherNode start="(47, 5)" end="(47, 13)" kind="Lean.Parser.Tactic.rintro" state_before="case mp&#10;α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;l : List α✝&#10;⊢ ¬Lex r [] l → l = []" state_after="case mp&#10;α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;l : List α✝&#10;h : ¬Lex r [] l&#10;⊢ l = []" tactic="rintro h">
                            <AtomNode start="(47, 5)" end="(47, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(47, 12)" end="(47, 13)">
                              <OtherNode start="(47, 12)" end="(47, 13)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(47, 12)" end="(47, 13)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(47, 12)" end="(47, 13)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(48, 5)" end="(50, 48)" kind="Lean.Parser.Tactic.match" state_before="case mp&#10;α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;l : List α✝&#10;h : ¬Lex r [] l&#10;⊢ l = []" state_after="no goals" tactic="match l, h with&#10;| [], h =&amp;gt; rfl&#10;| a :: _, h =&amp;gt; exact False.elim (h Lex.nil)">
                            <AtomNode start="(48, 5)" end="(48, 10)" leading="" trailing=" " val="match"/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(48, 11)" end="(48, 15)">
                              <OtherNode start="(48, 11)" end="(48, 12)" kind="Lean.Parser.Term.matchDiscr">
                                <NullNode/>
                                <IdentNode start="(48, 11)" end="(48, 12)" leading="" trailing="" raw_val="l" val="l"/>
                              </OtherNode>
                              <AtomNode start="(48, 12)" end="(48, 13)" leading="" trailing=" " val=","/>
                              <OtherNode start="(48, 14)" end="(48, 15)" kind="Lean.Parser.Term.matchDiscr">
                                <NullNode/>
                                <IdentNode start="(48, 14)" end="(48, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(48, 16)" end="(48, 20)" leading="" trailing="&#10;    " val="with"/>
                            <OtherNode start="(49, 5)" end="(50, 48)" kind="Lean.Parser.Term.matchAlts">
                              <NullNode start="(49, 5)" end="(50, 48)">
                                <OtherNode start="(49, 5)" end="(49, 19)" kind="Lean.Parser.Term.matchAlt">
                                  <AtomNode start="(49, 5)" end="(49, 6)" leading="" trailing=" " val="|"/>
                                  <NullNode start="(49, 7)" end="(49, 12)">
                                    <NullNode start="(49, 7)" end="(49, 12)">
                                      <OtherNode start="(49, 7)" end="(49, 9)" kind="«term[_]»">
                                        <AtomNode start="(49, 7)" end="(49, 8)" leading="" trailing="" val="["/>
                                        <NullNode/>
                                        <AtomNode start="(49, 8)" end="(49, 9)" leading="" trailing="" val="]"/>
                                      </OtherNode>
                                      <AtomNode start="(49, 9)" end="(49, 10)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(49, 11)" end="(49, 12)" leading="" trailing=" " raw_val="h" val="h"/>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(49, 13)" end="(49, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <TacticTacticseqNode start="(49, 16)" end="(49, 19)">
                                    <TacticTacticseq1IndentedNode start="(49, 16)" end="(49, 19)">
                                      <NullNode start="(49, 16)" end="(49, 19)">
                                        <OtherNode start="(49, 16)" end="(49, 19)" kind="Lean.Parser.Tactic.tacticRfl" state_before="α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;l : List α✝&#10;h✝ : ¬Lex r [] l&#10;h : ¬Lex r [] []&#10;⊢ [] = []" state_after="no goals" tactic="rfl">
                                          <AtomNode start="(49, 16)" end="(49, 19)" leading="" trailing="&#10;    " val="rfl"/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                                <OtherNode start="(50, 5)" end="(50, 48)" kind="Lean.Parser.Term.matchAlt">
                                  <AtomNode start="(50, 5)" end="(50, 6)" leading="" trailing=" " val="|"/>
                                  <NullNode start="(50, 7)" end="(50, 16)">
                                    <NullNode start="(50, 7)" end="(50, 16)">
                                      <OtherNode start="(50, 7)" end="(50, 13)" kind="«term_::_»">
                                        <IdentNode start="(50, 7)" end="(50, 8)" leading="" trailing=" " raw_val="a" val="a"/>
                                        <AtomNode start="(50, 9)" end="(50, 11)" leading="" trailing=" " val="::"/>
                                        <TermHoleNode start="(50, 12)" end="(50, 13)">
                                          <AtomNode start="(50, 12)" end="(50, 13)" leading="" trailing="" val="_"/>
                                        </TermHoleNode>
                                      </OtherNode>
                                      <AtomNode start="(50, 13)" end="(50, 14)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(50, 15)" end="(50, 16)" leading="" trailing=" " raw_val="h" val="h"/>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(50, 17)" end="(50, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <TacticTacticseqNode start="(50, 20)" end="(50, 48)">
                                    <TacticTacticseq1IndentedNode start="(50, 20)" end="(50, 48)">
                                      <NullNode start="(50, 20)" end="(50, 48)">
                                        <OtherNode start="(50, 20)" end="(50, 48)" kind="Lean.Parser.Tactic.exact" state_before="α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;l : List α✝&#10;h✝ : ¬Lex r [] l&#10;a : α✝&#10;tail✝ : List α✝&#10;h : ¬Lex r [] (a :: tail✝)&#10;⊢ a :: tail✝ = []" state_after="no goals" tactic="exact False.elim (h Lex.nil)">
                                          <AtomNode start="(50, 20)" end="(50, 25)" leading="" trailing=" " val="exact"/>
                                          <OtherNode start="(50, 26)" end="(50, 48)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(50, 26)" end="(50, 36)" leading="" trailing=" " raw_val="False.elim" val="False.elim" full_name="False.elim" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                            <NullNode start="(50, 37)" end="(50, 48)">
                                              <OtherNode start="(50, 37)" end="(50, 48)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(50, 37)" end="(50, 38)" leading="" trailing="" val="("/>
                                                <OtherNode start="(50, 38)" end="(50, 47)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(50, 38)" end="(50, 39)" leading="" trailing=" " raw_val="h" val="h"/>
                                                  <NullNode start="(50, 40)" end="(50, 47)">
                                                    <IdentNode start="(50, 40)" end="(50, 47)" leading="" trailing="" raw_val="Lex.nil" val="Lex.nil" full_name="List.Lex.nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </NullNode>
                                                </OtherNode>
                                                <AtomNode start="(50, 47)" end="(50, 48)" leading="" trailing="&#10;  " val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(51, 3)" end="(52, 22)" kind="Lean.cdot" state_before="case mpr&#10;α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;l : List α✝&#10;⊢ l = [] → ¬Lex r [] l" state_after="no goals" tactic="· rintro rfl&#10;  exact not_lex_nil">
                    <OtherNode start="(51, 3)" end="(51, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(51, 3)" end="(51, 4)" kind="patternIgnore">
                        <OtherNode start="(51, 3)" end="(51, 4)" kind="token.«· »">
                          <AtomNode start="(51, 3)" end="(51, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(51, 5)" end="(52, 22)">
                      <TacticTacticseq1IndentedNode start="(51, 5)" end="(52, 22)">
                        <NullNode start="(51, 5)" end="(52, 22)">
                          <OtherNode start="(51, 5)" end="(51, 15)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;l : List α✝&#10;⊢ l = [] → ¬Lex r [] l" state_after="case mpr&#10;α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;⊢ ¬Lex r [] []" tactic="rintro rfl">
                            <AtomNode start="(51, 5)" end="(51, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(51, 12)" end="(51, 15)">
                              <OtherNode start="(51, 12)" end="(51, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(51, 12)" end="(51, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(51, 12)" end="(51, 15)" leading="" trailing="&#10;    " raw_val="rfl" val="rfl"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(52, 5)" end="(52, 22)" kind="Lean.Parser.Tactic.exact" state_before="case mpr&#10;α✝ : Type u_1&#10;r : α✝ → α✝ → Prop&#10;⊢ ¬Lex r [] []" state_after="no goals" tactic="exact not_lex_nil">
                            <AtomNode start="(52, 5)" end="(52, 10)" leading="" trailing=" " val="exact"/>
                            <IdentNode start="(52, 11)" end="(52, 22)" leading="" trailing="&#10;&#10;" raw_val="not_lex_nil" val="not_lex_nil" full_name="List.not_lex_nil" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(40, 17)" def_end="(40, 28)"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(54, 1)" end="(54, 80)" name="le_nil" full_name="List.le_nil">
      <CommandDeclmodifiersNode start="(54, 1)" end="(54, 8)">
        <NullNode/>
        <NullNode start="(54, 1)" end="(54, 8)">
          <OtherNode start="(54, 1)" end="(54, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(54, 1)" end="(54, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(54, 3)" end="(54, 7)">
              <OtherNode start="(54, 3)" end="(54, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(54, 3)" end="(54, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(54, 3)" end="(54, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(54, 7)" end="(54, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(54, 9)" end="(54, 80)" name="le_nil" full_name="List.le_nil" _is_private_decl="False">
        <AtomNode start="(54, 9)" end="(54, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(54, 17)" end="(54, 23)">
          <IdentNode start="(54, 17)" end="(54, 23)" leading="" trailing=" " raw_val="le_nil" val="le_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(54, 24)" end="(54, 61)">
          <NullNode start="(54, 24)" end="(54, 43)">
            <OtherNode start="(54, 24)" end="(54, 30)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(54, 24)" end="(54, 25)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(54, 25)" end="(54, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(54, 25)" end="(54, 27)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(54, 28)" end="(54, 29)">
                  <IdentNode start="(54, 28)" end="(54, 29)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(54, 29)" end="(54, 30)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(54, 31)" end="(54, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(54, 31)" end="(54, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(54, 32)" end="(54, 33)">
                <IdentNode start="(54, 32)" end="(54, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(54, 34)" end="(54, 42)">
                <AtomNode start="(54, 34)" end="(54, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(54, 36)" end="(54, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(54, 36)" end="(54, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(54, 41)" end="(54, 42)">
                    <IdentNode start="(54, 41)" end="(54, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(54, 42)" end="(54, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(54, 44)" end="(54, 61)">
            <AtomNode start="(54, 44)" end="(54, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(54, 46)" end="(54, 61)" kind="«term_↔_»">
              <OtherNode start="(54, 46)" end="(54, 52)" kind="«term_≤_»">
                <IdentNode start="(54, 46)" end="(54, 47)" leading="" trailing=" " raw_val="l" val="l"/>
                <AtomNode start="(54, 48)" end="(54, 49)" leading="" trailing=" " val="≤"/>
                <OtherNode start="(54, 50)" end="(54, 52)" kind="«term[_]»">
                  <AtomNode start="(54, 50)" end="(54, 51)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(54, 51)" end="(54, 52)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(54, 53)" end="(54, 54)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(54, 55)" end="(54, 61)" kind="«term_=_»">
                <IdentNode start="(54, 55)" end="(54, 56)" leading="" trailing=" " raw_val="l" val="l"/>
                <AtomNode start="(54, 57)" end="(54, 58)" leading="" trailing=" " val="="/>
                <OtherNode start="(54, 59)" end="(54, 61)" kind="«term[_]»">
                  <AtomNode start="(54, 59)" end="(54, 60)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(54, 60)" end="(54, 61)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(54, 62)" end="(54, 80)">
          <AtomNode start="(54, 62)" end="(54, 64)" leading="" trailing=" " val=":="/>
          <IdentNode start="(54, 65)" end="(54, 80)" leading="" trailing="&#10;&#10;-- This is named with a prime to avoid conflict with `lex [] (b :: bs) lt = true`.&#10;-- Better naming for the `Lex` vs `lex` distinction would be welcome.&#10;" raw_val="not_nil_lex_iff" val="not_nil_lex_iff" full_name="List.not_nil_lex_iff" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(45, 17)" def_end="(45, 32)"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(58, 1)" end="(58, 61)" name="nil_lex_cons'" full_name="List.nil_lex_cons'">
      <CommandDeclmodifiersNode start="(58, 1)" end="(58, 8)">
        <NullNode/>
        <NullNode start="(58, 1)" end="(58, 8)">
          <OtherNode start="(58, 1)" end="(58, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(58, 1)" end="(58, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(58, 3)" end="(58, 7)">
              <OtherNode start="(58, 3)" end="(58, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(58, 3)" end="(58, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(58, 3)" end="(58, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(58, 7)" end="(58, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(58, 9)" end="(58, 61)" name="nil_lex_cons'" full_name="List.nil_lex_cons'" _is_private_decl="False">
        <AtomNode start="(58, 9)" end="(58, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(58, 17)" end="(58, 30)">
          <IdentNode start="(58, 17)" end="(58, 30)" leading="" trailing=" " raw_val="nil_lex_cons'" val="nil_lex_cons'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(58, 31)" end="(58, 50)">
          <NullNode/>
          <TermTypespecNode start="(58, 31)" end="(58, 50)">
            <AtomNode start="(58, 31)" end="(58, 32)" leading="" trailing=" " val=":"/>
            <OtherNode start="(58, 33)" end="(58, 50)" kind="Lean.Parser.Term.app">
              <IdentNode start="(58, 33)" end="(58, 36)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              <NullNode start="(58, 37)" end="(58, 50)">
                <IdentNode start="(58, 37)" end="(58, 38)" leading="" trailing=" " raw_val="r" val="r"/>
                <OtherNode start="(58, 39)" end="(58, 41)" kind="«term[_]»">
                  <AtomNode start="(58, 39)" end="(58, 40)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(58, 40)" end="(58, 41)" leading="" trailing=" " val="]"/>
                </OtherNode>
                <OtherNode start="(58, 42)" end="(58, 50)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(58, 42)" end="(58, 43)" leading="" trailing="" val="("/>
                  <OtherNode start="(58, 43)" end="(58, 49)" kind="«term_::_»">
                    <IdentNode start="(58, 43)" end="(58, 44)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(58, 45)" end="(58, 47)" leading="" trailing=" " val="::"/>
                    <IdentNode start="(58, 48)" end="(58, 49)" leading="" trailing="" raw_val="l" val="l"/>
                  </OtherNode>
                  <AtomNode start="(58, 49)" end="(58, 50)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(58, 51)" end="(58, 61)">
          <AtomNode start="(58, 51)" end="(58, 53)" leading="" trailing=" " val=":="/>
          <IdentNode start="(58, 54)" end="(58, 61)" leading="" trailing="&#10;&#10;" raw_val="Lex.nil" val="Lex.nil" full_name="List.Lex.nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(60, 1)" end="(60, 81)" name="nil_lt_cons" full_name="List.nil_lt_cons">
      <CommandDeclmodifiersNode start="(60, 1)" end="(60, 8)">
        <NullNode/>
        <NullNode start="(60, 1)" end="(60, 8)">
          <OtherNode start="(60, 1)" end="(60, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(60, 1)" end="(60, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(60, 3)" end="(60, 7)">
              <OtherNode start="(60, 3)" end="(60, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(60, 3)" end="(60, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(60, 3)" end="(60, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(60, 7)" end="(60, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(60, 9)" end="(60, 81)" name="nil_lt_cons" full_name="List.nil_lt_cons" _is_private_decl="False">
        <AtomNode start="(60, 9)" end="(60, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(60, 17)" end="(60, 28)">
          <IdentNode start="(60, 17)" end="(60, 28)" leading="" trailing=" " raw_val="nil_lt_cons" val="nil_lt_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(60, 29)" end="(60, 70)">
          <NullNode start="(60, 29)" end="(60, 56)">
            <OtherNode start="(60, 29)" end="(60, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(60, 29)" end="(60, 30)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(60, 30)" end="(60, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(60, 30)" end="(60, 32)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(60, 33)" end="(60, 34)">
                  <IdentNode start="(60, 33)" end="(60, 34)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(60, 34)" end="(60, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(60, 36)" end="(60, 43)">
              <AtomNode start="(60, 36)" end="(60, 37)" leading="" trailing="" val="("/>
              <NullNode start="(60, 37)" end="(60, 38)">
                <IdentNode start="(60, 37)" end="(60, 38)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(60, 39)" end="(60, 42)">
                <AtomNode start="(60, 39)" end="(60, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(60, 41)" end="(60, 42)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(60, 42)" end="(60, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(60, 44)" end="(60, 56)">
              <AtomNode start="(60, 44)" end="(60, 45)" leading="" trailing="" val="("/>
              <NullNode start="(60, 45)" end="(60, 46)">
                <IdentNode start="(60, 45)" end="(60, 46)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(60, 47)" end="(60, 55)">
                <AtomNode start="(60, 47)" end="(60, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(60, 49)" end="(60, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(60, 49)" end="(60, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(60, 54)" end="(60, 55)">
                    <IdentNode start="(60, 54)" end="(60, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(60, 55)" end="(60, 56)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(60, 57)" end="(60, 70)">
            <AtomNode start="(60, 57)" end="(60, 58)" leading="" trailing=" " val=":"/>
            <OtherNode start="(60, 59)" end="(60, 70)" kind="«term_&amp;lt;_»">
              <OtherNode start="(60, 59)" end="(60, 61)" kind="«term[_]»">
                <AtomNode start="(60, 59)" end="(60, 60)" leading="" trailing="" val="["/>
                <NullNode/>
                <AtomNode start="(60, 60)" end="(60, 61)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(60, 62)" end="(60, 63)" leading="" trailing=" " val="&amp;lt;"/>
              <OtherNode start="(60, 64)" end="(60, 70)" kind="«term_::_»">
                <IdentNode start="(60, 64)" end="(60, 65)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(60, 66)" end="(60, 68)" leading="" trailing=" " val="::"/>
                <IdentNode start="(60, 69)" end="(60, 70)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(60, 71)" end="(60, 81)">
          <AtomNode start="(60, 71)" end="(60, 73)" leading="" trailing=" " val=":="/>
          <IdentNode start="(60, 74)" end="(60, 81)" leading="" trailing="&#10;&#10;" raw_val="Lex.nil" val="Lex.nil" full_name="List.Lex.nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(62, 1)" end="(64, 61)" name="cons_lex_cons_iff" full_name="List.cons_lex_cons_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(62, 1)" end="(64, 61)" name="cons_lex_cons_iff" full_name="List.cons_lex_cons_iff" _is_private_decl="False">
        <AtomNode start="(62, 1)" end="(62, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(62, 9)" end="(62, 26)">
          <IdentNode start="(62, 9)" end="(62, 26)" leading="" trailing=" " raw_val="cons_lex_cons_iff" val="cons_lex_cons_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(62, 27)" end="(62, 84)">
          <NullNode/>
          <TermTypespecNode start="(62, 27)" end="(62, 84)">
            <AtomNode start="(62, 27)" end="(62, 28)" leading="" trailing=" " val=":"/>
            <OtherNode start="(62, 29)" end="(62, 84)" kind="«term_↔_»">
              <OtherNode start="(62, 29)" end="(62, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(62, 29)" end="(62, 32)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(62, 33)" end="(62, 54)">
                  <IdentNode start="(62, 33)" end="(62, 34)" leading="" trailing=" " raw_val="r" val="r"/>
                  <OtherNode start="(62, 35)" end="(62, 44)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(62, 35)" end="(62, 36)" leading="" trailing="" val="("/>
                    <OtherNode start="(62, 36)" end="(62, 43)" kind="«term_::_»">
                      <IdentNode start="(62, 36)" end="(62, 37)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(62, 38)" end="(62, 40)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(62, 41)" end="(62, 43)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                    </OtherNode>
                    <AtomNode start="(62, 43)" end="(62, 44)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(62, 45)" end="(62, 54)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(62, 45)" end="(62, 46)" leading="" trailing="" val="("/>
                    <OtherNode start="(62, 46)" end="(62, 53)" kind="«term_::_»">
                      <IdentNode start="(62, 46)" end="(62, 47)" leading="" trailing=" " raw_val="b" val="b"/>
                      <AtomNode start="(62, 48)" end="(62, 50)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(62, 51)" end="(62, 53)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </OtherNode>
                    <AtomNode start="(62, 53)" end="(62, 54)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(62, 55)" end="(62, 56)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(62, 57)" end="(62, 84)" kind="«term_∨_»">
                <OtherNode start="(62, 57)" end="(62, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(62, 57)" end="(62, 58)" leading="" trailing=" " raw_val="r" val="r"/>
                  <NullNode start="(62, 59)" end="(62, 62)">
                    <IdentNode start="(62, 59)" end="(62, 60)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(62, 61)" end="(62, 62)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(62, 63)" end="(62, 64)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(62, 65)" end="(62, 84)" kind="«term_∧_»">
                  <OtherNode start="(62, 65)" end="(62, 70)" kind="«term_=_»">
                    <IdentNode start="(62, 65)" end="(62, 66)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(62, 67)" end="(62, 68)" leading="" trailing=" " val="="/>
                    <IdentNode start="(62, 69)" end="(62, 70)" leading="" trailing=" " raw_val="b" val="b"/>
                  </OtherNode>
                  <AtomNode start="(62, 71)" end="(62, 72)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(62, 73)" end="(62, 84)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(62, 73)" end="(62, 76)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(62, 77)" end="(62, 84)">
                      <IdentNode start="(62, 77)" end="(62, 78)" leading="" trailing=" " raw_val="r" val="r"/>
                      <IdentNode start="(62, 79)" end="(62, 81)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <IdentNode start="(62, 82)" end="(62, 84)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(62, 85)" end="(64, 61)">
          <AtomNode start="(62, 85)" end="(62, 87)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(63, 3)" end="(64, 61)" kind="Lean.Parser.Term.anonymousCtor">
            <AtomNode start="(63, 3)" end="(63, 4)" leading="" trailing="" val="⟨"/>
            <NullNode start="(63, 4)" end="(64, 60)">
              <OtherNode start="(63, 4)" end="(63, 53)" kind="Lean.Parser.Term.fun">
                <AtomNode start="(63, 4)" end="(63, 7)" leading="" trailing=" " val="fun"/>
                <OtherNode start="(63, 8)" end="(63, 53)" kind="Lean.Parser.Term.matchAlts">
                  <NullNode start="(63, 8)" end="(63, 53)">
                    <OtherNode start="(63, 8)" end="(63, 26)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(63, 8)" end="(63, 9)" leading="" trailing=" " val="|"/>
                      <NullNode start="(63, 10)" end="(63, 16)">
                        <NullNode start="(63, 10)" end="(63, 16)">
                          <OtherNode start="(63, 10)" end="(63, 16)" kind="Lean.Parser.Term.app">
                            <OtherNode start="(63, 10)" end="(63, 14)" kind="Lean.Parser.Term.dotIdent">
                              <AtomNode start="(63, 10)" end="(63, 11)" leading="" trailing="" val="."/>
                              <IdentNode start="(63, 11)" end="(63, 14)" leading="" trailing=" " raw_val="rel" val="rel"/>
                            </OtherNode>
                            <NullNode start="(63, 15)" end="(63, 16)">
                              <IdentNode start="(63, 15)" end="(63, 16)" leading="" trailing=" " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(63, 17)" end="(63, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(63, 20)" end="(63, 26)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(63, 20)" end="(63, 24)" kind="Lean.Parser.Term.dotIdent">
                          <AtomNode start="(63, 20)" end="(63, 21)" leading="" trailing="" val="."/>
                          <IdentNode start="(63, 21)" end="(63, 24)" leading="" trailing=" " raw_val="inl" val="inl"/>
                        </OtherNode>
                        <NullNode start="(63, 25)" end="(63, 26)">
                          <IdentNode start="(63, 25)" end="(63, 26)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <OtherNode start="(63, 27)" end="(63, 53)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(63, 27)" end="(63, 28)" leading="" trailing=" " val="|"/>
                      <NullNode start="(63, 29)" end="(63, 36)">
                        <NullNode start="(63, 29)" end="(63, 36)">
                          <OtherNode start="(63, 29)" end="(63, 36)" kind="Lean.Parser.Term.app">
                            <OtherNode start="(63, 29)" end="(63, 34)" kind="Lean.Parser.Term.dotIdent">
                              <AtomNode start="(63, 29)" end="(63, 30)" leading="" trailing="" val="."/>
                              <IdentNode start="(63, 30)" end="(63, 34)" leading="" trailing=" " raw_val="cons" val="cons"/>
                            </OtherNode>
                            <NullNode start="(63, 35)" end="(63, 36)">
                              <IdentNode start="(63, 35)" end="(63, 36)" leading="" trailing=" " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(63, 37)" end="(63, 39)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(63, 40)" end="(63, 53)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(63, 40)" end="(63, 44)" kind="Lean.Parser.Term.dotIdent">
                          <AtomNode start="(63, 40)" end="(63, 41)" leading="" trailing="" val="."/>
                          <IdentNode start="(63, 41)" end="(63, 44)" leading="" trailing=" " raw_val="inr" val="inr"/>
                        </OtherNode>
                        <NullNode start="(63, 45)" end="(63, 53)">
                          <OtherNode start="(63, 45)" end="(63, 53)" kind="Lean.Parser.Term.anonymousCtor">
                            <AtomNode start="(63, 45)" end="(63, 46)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(63, 46)" end="(63, 52)">
                              <IdentNode start="(63, 46)" end="(63, 49)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <AtomNode start="(63, 49)" end="(63, 50)" leading="" trailing=" " val=","/>
                              <IdentNode start="(63, 51)" end="(63, 52)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                            <AtomNode start="(63, 52)" end="(63, 53)" leading="" trailing="" val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(63, 53)" end="(63, 54)" leading="" trailing="&#10;    " val=","/>
              <OtherNode start="(64, 5)" end="(64, 60)" kind="Lean.Parser.Term.fun">
                <AtomNode start="(64, 5)" end="(64, 8)" leading="" trailing=" " val="fun"/>
                <OtherNode start="(64, 9)" end="(64, 60)" kind="Lean.Parser.Term.matchAlts">
                  <NullNode start="(64, 9)" end="(64, 60)">
                    <OtherNode start="(64, 9)" end="(64, 30)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(64, 9)" end="(64, 10)" leading="" trailing=" " val="|"/>
                      <NullNode start="(64, 11)" end="(64, 17)">
                        <NullNode start="(64, 11)" end="(64, 17)">
                          <OtherNode start="(64, 11)" end="(64, 17)" kind="Lean.Parser.Term.app">
                            <OtherNode start="(64, 11)" end="(64, 15)" kind="Lean.Parser.Term.dotIdent">
                              <AtomNode start="(64, 11)" end="(64, 12)" leading="" trailing="" val="."/>
                              <IdentNode start="(64, 12)" end="(64, 15)" leading="" trailing=" " raw_val="inl" val="inl"/>
                            </OtherNode>
                            <NullNode start="(64, 16)" end="(64, 17)">
                              <IdentNode start="(64, 16)" end="(64, 17)" leading="" trailing=" " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(64, 18)" end="(64, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(64, 21)" end="(64, 30)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(64, 21)" end="(64, 28)" leading="" trailing=" " raw_val="Lex.rel" val="Lex.rel" full_name="List.Lex.rel" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        <NullNode start="(64, 29)" end="(64, 30)">
                          <IdentNode start="(64, 29)" end="(64, 30)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <OtherNode start="(64, 31)" end="(64, 60)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(64, 31)" end="(64, 32)" leading="" trailing=" " val="|"/>
                      <NullNode start="(64, 33)" end="(64, 46)">
                        <NullNode start="(64, 33)" end="(64, 46)">
                          <OtherNode start="(64, 33)" end="(64, 46)" kind="Lean.Parser.Term.app">
                            <OtherNode start="(64, 33)" end="(64, 37)" kind="Lean.Parser.Term.dotIdent">
                              <AtomNode start="(64, 33)" end="(64, 34)" leading="" trailing="" val="."/>
                              <IdentNode start="(64, 34)" end="(64, 37)" leading="" trailing=" " raw_val="inr" val="inr"/>
                            </OtherNode>
                            <NullNode start="(64, 38)" end="(64, 46)">
                              <OtherNode start="(64, 38)" end="(64, 46)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(64, 38)" end="(64, 39)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(64, 39)" end="(64, 45)">
                                  <IdentNode start="(64, 39)" end="(64, 42)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <AtomNode start="(64, 42)" end="(64, 43)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(64, 44)" end="(64, 45)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                                <AtomNode start="(64, 45)" end="(64, 46)" leading="" trailing=" " val="⟩"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(64, 47)" end="(64, 49)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(64, 50)" end="(64, 60)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(64, 50)" end="(64, 58)" leading="" trailing=" " raw_val="Lex.cons" val="Lex.cons" full_name="List.Lex.cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        <NullNode start="(64, 59)" end="(64, 60)">
                          <IdentNode start="(64, 59)" end="(64, 60)" leading="" trailing="" raw_val="h" val="h"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(64, 60)" end="(64, 61)" leading="" trailing="&#10;&#10;" val="⟩"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(66, 1)" end="(69, 27)" name="cons_lt_cons_iff" full_name="List.cons_lt_cons_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(66, 1)" end="(69, 27)" name="cons_lt_cons_iff" full_name="List.cons_lt_cons_iff" _is_private_decl="False">
        <AtomNode start="(66, 1)" end="(66, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(66, 9)" end="(66, 25)">
          <IdentNode start="(66, 9)" end="(66, 25)" leading="" trailing=" " raw_val="cons_lt_cons_iff" val="cons_lt_cons_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(66, 26)" end="(67, 52)">
          <NullNode start="(66, 26)" end="(66, 55)">
            <OtherNode start="(66, 26)" end="(66, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(66, 26)" end="(66, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(66, 27)" end="(66, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(66, 27)" end="(66, 29)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(66, 30)" end="(66, 31)">
                  <IdentNode start="(66, 30)" end="(66, 31)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(66, 31)" end="(66, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(66, 33)" end="(66, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(66, 33)" end="(66, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(66, 34)" end="(66, 37)">
                <IdentNode start="(66, 34)" end="(66, 35)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(66, 36)" end="(66, 37)" leading="" trailing="" raw_val="b" val="b"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(66, 37)" end="(66, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(66, 39)" end="(66, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(66, 39)" end="(66, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(66, 40)" end="(66, 45)">
                <IdentNode start="(66, 40)" end="(66, 42)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(66, 43)" end="(66, 45)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(66, 46)" end="(66, 54)">
                <AtomNode start="(66, 46)" end="(66, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(66, 48)" end="(66, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(66, 48)" end="(66, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(66, 53)" end="(66, 54)">
                    <IdentNode start="(66, 53)" end="(66, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(66, 54)" end="(66, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(66, 56)" end="(67, 52)">
            <AtomNode start="(66, 56)" end="(66, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(67, 5)" end="(67, 52)" kind="«term_↔_»">
              <OtherNode start="(67, 5)" end="(67, 26)" kind="«term_&amp;lt;_»">
                <OtherNode start="(67, 5)" end="(67, 14)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(67, 5)" end="(67, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(67, 6)" end="(67, 13)" kind="«term_::_»">
                    <IdentNode start="(67, 6)" end="(67, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(67, 8)" end="(67, 10)" leading="" trailing=" " val="::"/>
                    <IdentNode start="(67, 11)" end="(67, 13)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                  </OtherNode>
                  <AtomNode start="(67, 13)" end="(67, 14)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(67, 15)" end="(67, 16)" leading="" trailing=" " val="&amp;lt;"/>
                <OtherNode start="(67, 17)" end="(67, 26)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(67, 17)" end="(67, 18)" leading="" trailing="" val="("/>
                  <OtherNode start="(67, 18)" end="(67, 25)" kind="«term_::_»">
                    <IdentNode start="(67, 18)" end="(67, 19)" leading="" trailing=" " raw_val="b" val="b"/>
                    <AtomNode start="(67, 20)" end="(67, 22)" leading="" trailing=" " val="::"/>
                    <IdentNode start="(67, 23)" end="(67, 25)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                  </OtherNode>
                  <AtomNode start="(67, 25)" end="(67, 26)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(67, 27)" end="(67, 28)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(67, 29)" end="(67, 52)" kind="«term_∨_»">
                <OtherNode start="(67, 29)" end="(67, 34)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(67, 29)" end="(67, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(67, 31)" end="(67, 32)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(67, 33)" end="(67, 34)" leading="" trailing=" " raw_val="b" val="b"/>
                </OtherNode>
                <AtomNode start="(67, 35)" end="(67, 36)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(67, 37)" end="(67, 52)" kind="«term_∧_»">
                  <OtherNode start="(67, 37)" end="(67, 42)" kind="«term_=_»">
                    <IdentNode start="(67, 37)" end="(67, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(67, 39)" end="(67, 40)" leading="" trailing=" " val="="/>
                    <IdentNode start="(67, 41)" end="(67, 42)" leading="" trailing=" " raw_val="b" val="b"/>
                  </OtherNode>
                  <AtomNode start="(67, 43)" end="(67, 44)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(67, 45)" end="(67, 52)" kind="«term_&amp;lt;_»">
                    <IdentNode start="(67, 45)" end="(67, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <AtomNode start="(67, 48)" end="(67, 49)" leading="" trailing=" " val="&amp;lt;"/>
                    <IdentNode start="(67, 50)" end="(67, 52)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(67, 53)" end="(69, 27)">
          <AtomNode start="(67, 53)" end="(67, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(67, 56)" end="(69, 27)">
            <AtomNode start="(67, 56)" end="(67, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(68, 3)" end="(69, 27)">
              <TacticTacticseq1IndentedNode start="(68, 3)" end="(69, 27)">
                <NullNode start="(68, 3)" end="(69, 27)">
                  <OtherNode start="(68, 3)" end="(68, 31)" kind="Lean.Parser.Tactic.dsimp" state_before="α : Type u_1&#10;inst✝ : LT α&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ a :: l₁ &amp;lt; b :: l₂ ↔ a &amp;lt; b ∨ a = b ∧ l₁ &amp;lt; l₂" state_after="α : Type u_1&#10;inst✝ : LT α&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) (a :: l₁) (b :: l₂) ↔ a &amp;lt; b ∨ a = b ∧ Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₁ l₂" tactic="dsimp only [instLT, List.lt]">
                    <AtomNode start="(68, 3)" end="(68, 8)" leading="" trailing=" " val="dsimp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(68, 9)" end="(68, 13)">
                      <AtomNode start="(68, 9)" end="(68, 13)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(68, 14)" end="(68, 31)">
                      <AtomNode start="(68, 14)" end="(68, 15)" leading="" trailing="" val="["/>
                      <NullNode start="(68, 15)" end="(68, 30)">
                        <OtherNode start="(68, 15)" end="(68, 21)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(68, 15)" end="(68, 21)" leading="" trailing="" raw_val="instLT" val="instLT" full_name="List.instLT" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(68, 21)" end="(68, 22)" leading="" trailing=" " val=","/>
                        <OtherNode start="(68, 23)" end="(68, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(68, 23)" end="(68, 30)" leading="" trailing="" raw_val="List.lt" val="List.lt" full_name="List.lt" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(68, 30)" end="(68, 31)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(69, 3)" end="(69, 27)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : LT α&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) (a :: l₁) (b :: l₂) ↔ a &amp;lt; b ∨ a = b ∧ Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₁ l₂" state_after="no goals" tactic="simp [cons_lex_cons_iff]">
                    <AtomNode start="(69, 3)" end="(69, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(69, 8)" end="(69, 27)">
                      <AtomNode start="(69, 8)" end="(69, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(69, 9)" end="(69, 26)">
                        <OtherNode start="(69, 9)" end="(69, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(69, 9)" end="(69, 26)" leading="" trailing="" raw_val="cons_lex_cons_iff" val="cons_lex_cons_iff" full_name="List.cons_lex_cons_iff" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(62, 9)" def_end="(62, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(69, 26)" end="(69, 27)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(71, 1)" end="(73, 37)" name="cons_lt_cons_self" full_name="List.cons_lt_cons_self">
      <CommandDeclmodifiersNode start="(71, 1)" end="(71, 8)">
        <NullNode/>
        <NullNode start="(71, 1)" end="(71, 8)">
          <OtherNode start="(71, 1)" end="(71, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(71, 1)" end="(71, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(71, 3)" end="(71, 7)">
              <OtherNode start="(71, 3)" end="(71, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(71, 3)" end="(71, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(71, 3)" end="(71, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(71, 7)" end="(71, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(71, 9)" end="(73, 37)" name="cons_lt_cons_self" full_name="List.cons_lt_cons_self" _is_private_decl="False">
        <AtomNode start="(71, 9)" end="(71, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(71, 17)" end="(71, 34)">
          <IdentNode start="(71, 17)" end="(71, 34)" leading="" trailing=" " raw_val="cons_lt_cons_self" val="cons_lt_cons_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(71, 35)" end="(72, 36)">
          <NullNode start="(71, 35)" end="(71, 99)">
            <OtherNode start="(71, 35)" end="(71, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(71, 35)" end="(71, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(71, 36)" end="(71, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(71, 36)" end="(71, 38)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(71, 39)" end="(71, 40)">
                  <IdentNode start="(71, 39)" end="(71, 40)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(71, 40)" end="(71, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(71, 42)" end="(71, 82)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(71, 42)" end="(71, 43)" leading="" trailing="" val="["/>
              <NullNode start="(71, 43)" end="(71, 47)">
                <IdentNode start="(71, 43)" end="(71, 45)" leading="" trailing=" " raw_val="i₀" val="i₀"/>
                <AtomNode start="(71, 46)" end="(71, 47)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(71, 48)" end="(71, 81)" kind="Lean.Parser.Term.app">
                <IdentNode start="(71, 48)" end="(71, 58)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(71, 59)" end="(71, 81)">
                  <OtherNode start="(71, 59)" end="(71, 81)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(71, 59)" end="(71, 60)" leading="" trailing="" val="("/>
                    <OtherNode start="(71, 60)" end="(71, 65)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(71, 60)" end="(71, 61)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(71, 60)" end="(71, 61)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(71, 62)" end="(71, 63)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(71, 64)" end="(71, 65)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(71, 64)" end="(71, 65)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(71, 66)" end="(71, 67)" leading="" trailing=" " val=":"/>
                    <NullNode start="(71, 68)" end="(71, 80)">
                      <OtherNode start="(71, 68)" end="(71, 80)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(71, 68)" end="(71, 69)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(71, 70)" end="(71, 71)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(71, 72)" end="(71, 80)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(71, 72)" end="(71, 73)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(71, 74)" end="(71, 75)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(71, 76)" end="(71, 80)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(71, 76)" end="(71, 80)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(71, 80)" end="(71, 81)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(71, 81)" end="(71, 82)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(71, 83)" end="(71, 99)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(71, 83)" end="(71, 84)" leading="" trailing="" val="{"/>
              <NullNode start="(71, 84)" end="(71, 89)">
                <IdentNode start="(71, 84)" end="(71, 86)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(71, 87)" end="(71, 89)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(71, 90)" end="(71, 98)">
                <AtomNode start="(71, 90)" end="(71, 91)" leading="" trailing=" " val=":"/>
                <OtherNode start="(71, 92)" end="(71, 98)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(71, 92)" end="(71, 96)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(71, 97)" end="(71, 98)">
                    <IdentNode start="(71, 97)" end="(71, 98)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(71, 98)" end="(71, 99)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(71, 100)" end="(72, 36)">
            <AtomNode start="(71, 100)" end="(71, 101)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(72, 5)" end="(72, 36)" kind="«term_↔_»">
              <OtherNode start="(72, 5)" end="(72, 26)" kind="«term_&amp;lt;_»">
                <OtherNode start="(72, 5)" end="(72, 14)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(72, 5)" end="(72, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(72, 6)" end="(72, 13)" kind="«term_::_»">
                    <IdentNode start="(72, 6)" end="(72, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(72, 8)" end="(72, 10)" leading="" trailing=" " val="::"/>
                    <IdentNode start="(72, 11)" end="(72, 13)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                  </OtherNode>
                  <AtomNode start="(72, 13)" end="(72, 14)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(72, 15)" end="(72, 16)" leading="" trailing=" " val="&amp;lt;"/>
                <OtherNode start="(72, 17)" end="(72, 26)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(72, 17)" end="(72, 18)" leading="" trailing="" val="("/>
                  <OtherNode start="(72, 18)" end="(72, 25)" kind="«term_::_»">
                    <IdentNode start="(72, 18)" end="(72, 19)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(72, 20)" end="(72, 22)" leading="" trailing=" " val="::"/>
                    <IdentNode start="(72, 23)" end="(72, 25)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                  </OtherNode>
                  <AtomNode start="(72, 25)" end="(72, 26)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(72, 27)" end="(72, 28)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(72, 29)" end="(72, 36)" kind="«term_&amp;lt;_»">
                <IdentNode start="(72, 29)" end="(72, 31)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(72, 32)" end="(72, 33)" leading="" trailing=" " val="&amp;lt;"/>
                <IdentNode start="(72, 34)" end="(72, 36)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(72, 37)" end="(73, 37)">
          <AtomNode start="(72, 37)" end="(72, 39)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(72, 40)" end="(73, 37)">
            <AtomNode start="(72, 40)" end="(72, 42)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(73, 3)" end="(73, 37)">
              <TacticTacticseq1IndentedNode start="(73, 3)" end="(73, 37)">
                <NullNode start="(73, 3)" end="(73, 37)">
                  <OtherNode start="(73, 3)" end="(73, 37)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;inst✝ : LT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ a :: l₁ &amp;lt; a :: l₂ ↔ l₁ &amp;lt; l₂" state_after="no goals" tactic="simp [cons_lt_cons_iff, i₀.irrefl]">
                    <AtomNode start="(73, 3)" end="(73, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(73, 8)" end="(73, 37)">
                      <AtomNode start="(73, 8)" end="(73, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(73, 9)" end="(73, 36)">
                        <OtherNode start="(73, 9)" end="(73, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(73, 9)" end="(73, 25)" leading="" trailing="" raw_val="cons_lt_cons_iff" val="cons_lt_cons_iff" full_name="List.cons_lt_cons_iff" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(66, 9)" def_end="(66, 25)"/>
                        </OtherNode>
                        <AtomNode start="(73, 25)" end="(73, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(73, 27)" end="(73, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(73, 27)" end="(73, 36)" leading="" trailing="" raw_val="i₀.irrefl" val="i₀.irrefl"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(73, 36)" end="(73, 37)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(75, 1)" end="(77, 76)" name="not_cons_lex_cons_iff" full_name="List.not_cons_lex_cons_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(75, 1)" end="(77, 76)" name="not_cons_lex_cons_iff" full_name="List.not_cons_lex_cons_iff" _is_private_decl="False">
        <AtomNode start="(75, 1)" end="(75, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(75, 9)" end="(75, 30)">
          <IdentNode start="(75, 9)" end="(75, 30)" leading="" trailing=" " raw_val="not_cons_lex_cons_iff" val="not_cons_lex_cons_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(75, 31)" end="(76, 80)">
          <NullNode start="(75, 31)" end="(75, 86)">
            <OtherNode start="(75, 31)" end="(75, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(75, 31)" end="(75, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(75, 32)" end="(75, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(75, 32)" end="(75, 43)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(75, 44)" end="(75, 45)">
                  <IdentNode start="(75, 44)" end="(75, 45)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(75, 45)" end="(75, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(75, 47)" end="(75, 63)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(75, 47)" end="(75, 48)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(75, 48)" end="(75, 62)" kind="Lean.Parser.Term.app">
                <IdentNode start="(75, 48)" end="(75, 60)" leading="" trailing=" " raw_val="DecidableRel" val="DecidableRel" full_name="DecidableRel" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(75, 61)" end="(75, 62)">
                  <IdentNode start="(75, 61)" end="(75, 62)" leading="" trailing="" raw_val="r" val="r"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(75, 62)" end="(75, 63)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(75, 64)" end="(75, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(75, 64)" end="(75, 65)" leading="" trailing="" val="{"/>
              <NullNode start="(75, 65)" end="(75, 68)">
                <IdentNode start="(75, 65)" end="(75, 66)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(75, 67)" end="(75, 68)" leading="" trailing="" raw_val="b" val="b"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(75, 68)" end="(75, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(75, 70)" end="(75, 86)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(75, 70)" end="(75, 71)" leading="" trailing="" val="{"/>
              <NullNode start="(75, 71)" end="(75, 76)">
                <IdentNode start="(75, 71)" end="(75, 73)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(75, 74)" end="(75, 76)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(75, 77)" end="(75, 85)">
                <AtomNode start="(75, 77)" end="(75, 78)" leading="" trailing=" " val=":"/>
                <OtherNode start="(75, 79)" end="(75, 85)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(75, 79)" end="(75, 83)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(75, 84)" end="(75, 85)">
                    <IdentNode start="(75, 84)" end="(75, 85)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(75, 85)" end="(75, 86)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(75, 87)" end="(76, 80)">
            <AtomNode start="(75, 87)" end="(75, 88)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(76, 5)" end="(76, 80)" kind="«term_↔_»">
              <OtherNode start="(76, 5)" end="(76, 32)" kind="«term¬_»">
                <AtomNode start="(76, 5)" end="(76, 6)" leading="" trailing=" " val="¬"/>
                <OtherNode start="(76, 7)" end="(76, 32)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(76, 7)" end="(76, 10)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(76, 11)" end="(76, 32)">
                    <IdentNode start="(76, 11)" end="(76, 12)" leading="" trailing=" " raw_val="r" val="r"/>
                    <OtherNode start="(76, 13)" end="(76, 22)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(76, 13)" end="(76, 14)" leading="" trailing="" val="("/>
                      <OtherNode start="(76, 14)" end="(76, 21)" kind="«term_::_»">
                        <IdentNode start="(76, 14)" end="(76, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(76, 16)" end="(76, 18)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(76, 19)" end="(76, 21)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(76, 21)" end="(76, 22)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(76, 23)" end="(76, 32)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(76, 23)" end="(76, 24)" leading="" trailing="" val="("/>
                      <OtherNode start="(76, 24)" end="(76, 31)" kind="«term_::_»">
                        <IdentNode start="(76, 24)" end="(76, 25)" leading="" trailing=" " raw_val="b" val="b"/>
                        <AtomNode start="(76, 26)" end="(76, 28)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(76, 29)" end="(76, 31)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </OtherNode>
                      <AtomNode start="(76, 31)" end="(76, 32)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(76, 33)" end="(76, 34)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(76, 35)" end="(76, 80)" kind="«term_∨_»">
                <OtherNode start="(76, 35)" end="(76, 52)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(76, 35)" end="(76, 36)" leading="" trailing="" val="("/>
                  <OtherNode start="(76, 36)" end="(76, 51)" kind="«term_∧_»">
                    <OtherNode start="(76, 36)" end="(76, 43)" kind="«term¬_»">
                      <AtomNode start="(76, 36)" end="(76, 37)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(76, 38)" end="(76, 43)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(76, 38)" end="(76, 39)" leading="" trailing=" " raw_val="r" val="r"/>
                        <NullNode start="(76, 40)" end="(76, 43)">
                          <IdentNode start="(76, 40)" end="(76, 41)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(76, 42)" end="(76, 43)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(76, 44)" end="(76, 45)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(76, 46)" end="(76, 51)" kind="«term_≠_»">
                      <IdentNode start="(76, 46)" end="(76, 47)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(76, 48)" end="(76, 49)" leading="" trailing=" " val="≠"/>
                      <IdentNode start="(76, 50)" end="(76, 51)" leading="" trailing="" raw_val="b" val="b"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(76, 51)" end="(76, 52)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(76, 53)" end="(76, 54)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(76, 55)" end="(76, 80)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(76, 55)" end="(76, 56)" leading="" trailing="" val="("/>
                  <OtherNode start="(76, 56)" end="(76, 79)" kind="«term_∧_»">
                    <OtherNode start="(76, 56)" end="(76, 63)" kind="«term¬_»">
                      <AtomNode start="(76, 56)" end="(76, 57)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(76, 58)" end="(76, 63)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(76, 58)" end="(76, 59)" leading="" trailing=" " raw_val="r" val="r"/>
                        <NullNode start="(76, 60)" end="(76, 63)">
                          <IdentNode start="(76, 60)" end="(76, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(76, 62)" end="(76, 63)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(76, 64)" end="(76, 65)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(76, 66)" end="(76, 79)" kind="«term¬_»">
                      <AtomNode start="(76, 66)" end="(76, 67)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(76, 68)" end="(76, 79)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(76, 68)" end="(76, 71)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        <NullNode start="(76, 72)" end="(76, 79)">
                          <IdentNode start="(76, 72)" end="(76, 73)" leading="" trailing=" " raw_val="r" val="r"/>
                          <IdentNode start="(76, 74)" end="(76, 76)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          <IdentNode start="(76, 77)" end="(76, 79)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(76, 79)" end="(76, 80)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(76, 81)" end="(77, 76)">
          <AtomNode start="(76, 81)" end="(76, 83)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(76, 84)" end="(77, 76)">
            <AtomNode start="(76, 84)" end="(76, 86)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(77, 3)" end="(77, 76)">
              <TacticTacticseq1IndentedNode start="(77, 3)" end="(77, 76)">
                <NullNode start="(77, 3)" end="(77, 76)">
                  <OtherNode start="(77, 3)" end="(77, 76)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;r : α → α → Prop&#10;inst✝¹ : DecidableEq α&#10;inst✝ : DecidableRel r&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ ¬Lex r (a :: l₁) (b :: l₂) ↔ ¬r a b ∧ a ≠ b ∨ ¬r a b ∧ ¬Lex r l₁ l₂" state_after="no goals" tactic="rw [cons_lex_cons_iff, not_or, Decidable.not_and_iff_or_not, and_or_left]">
                    <AtomNode start="(77, 3)" end="(77, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(77, 6)" end="(77, 76)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(77, 6)" end="(77, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(77, 7)" end="(77, 75)">
                        <OtherNode start="(77, 7)" end="(77, 24)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(77, 7)" end="(77, 24)" leading="" trailing="" raw_val="cons_lex_cons_iff" val="cons_lex_cons_iff" full_name="List.cons_lex_cons_iff" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(62, 9)" def_end="(62, 26)"/>
                        </OtherNode>
                        <AtomNode start="(77, 24)" end="(77, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(77, 26)" end="(77, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(77, 26)" end="(77, 32)" leading="" trailing="" raw_val="not_or" val="not_or" full_name="not_or" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(77, 32)" end="(77, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(77, 34)" end="(77, 62)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(77, 34)" end="(77, 62)" leading="" trailing="" raw_val="Decidable.not_and_iff_or_not" val="Decidable.not_and_iff_or_not" full_name="Decidable.not_and_iff_or_not" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                        <AtomNode start="(77, 62)" end="(77, 63)" leading="" trailing=" " val=","/>
                        <OtherNode start="(77, 64)" end="(77, 75)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(77, 64)" end="(77, 75)" leading="" trailing="" raw_val="and_or_left" val="and_or_left" full_name="and_or_left" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(77, 75)" end="(77, 76)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(79, 1)" end="(103, 48)" name="cons_le_cons_iff" full_name="List.cons_le_cons_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(79, 1)" end="(103, 48)" name="cons_le_cons_iff" full_name="List.cons_le_cons_iff" _is_private_decl="False">
        <AtomNode start="(79, 1)" end="(79, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(79, 9)" end="(79, 25)">
          <IdentNode start="(79, 9)" end="(79, 25)" leading="" trailing=" " raw_val="cons_le_cons_iff" val="cons_le_cons_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(79, 26)" end="(84, 52)">
          <NullNode start="(79, 26)" end="(83, 27)">
            <OtherNode start="(79, 26)" end="(79, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(79, 26)" end="(79, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(79, 27)" end="(79, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(79, 27)" end="(79, 38)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(79, 39)" end="(79, 40)">
                  <IdentNode start="(79, 39)" end="(79, 40)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(79, 40)" end="(79, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(79, 42)" end="(79, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(79, 42)" end="(79, 43)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(79, 43)" end="(79, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(79, 43)" end="(79, 45)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(79, 46)" end="(79, 47)">
                  <IdentNode start="(79, 46)" end="(79, 47)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(79, 47)" end="(79, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(79, 49)" end="(79, 64)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(79, 49)" end="(79, 50)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(79, 50)" end="(79, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(79, 50)" end="(79, 61)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(79, 62)" end="(79, 63)">
                  <IdentNode start="(79, 62)" end="(79, 63)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(79, 63)" end="(79, 64)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(80, 5)" end="(80, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(80, 5)" end="(80, 6)" leading="" trailing="" val="["/>
              <NullNode start="(80, 6)" end="(80, 10)">
                <IdentNode start="(80, 6)" end="(80, 8)" leading="" trailing=" " raw_val="i₀" val="i₀"/>
                <AtomNode start="(80, 9)" end="(80, 10)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(80, 11)" end="(80, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(80, 11)" end="(80, 21)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(80, 22)" end="(80, 44)">
                  <OtherNode start="(80, 22)" end="(80, 44)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(80, 22)" end="(80, 23)" leading="" trailing="" val="("/>
                    <OtherNode start="(80, 23)" end="(80, 28)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(80, 23)" end="(80, 24)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(80, 23)" end="(80, 24)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(80, 25)" end="(80, 26)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(80, 27)" end="(80, 28)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(80, 27)" end="(80, 28)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(80, 29)" end="(80, 30)" leading="" trailing=" " val=":"/>
                    <NullNode start="(80, 31)" end="(80, 43)">
                      <OtherNode start="(80, 31)" end="(80, 43)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(80, 31)" end="(80, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(80, 33)" end="(80, 34)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(80, 35)" end="(80, 43)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(80, 35)" end="(80, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(80, 37)" end="(80, 38)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(80, 39)" end="(80, 43)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(80, 39)" end="(80, 43)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(80, 43)" end="(80, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(80, 44)" end="(80, 45)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(81, 5)" end="(81, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(81, 5)" end="(81, 6)" leading="" trailing="" val="["/>
              <NullNode start="(81, 6)" end="(81, 10)">
                <IdentNode start="(81, 6)" end="(81, 8)" leading="" trailing=" " raw_val="i₁" val="i₁"/>
                <AtomNode start="(81, 9)" end="(81, 10)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(81, 11)" end="(81, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(81, 11)" end="(81, 20)" leading="" trailing=" " raw_val="Std.Asymm" val="Std.Asymm" full_name="Std.Asymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(81, 21)" end="(81, 43)">
                  <OtherNode start="(81, 21)" end="(81, 43)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(81, 21)" end="(81, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(81, 22)" end="(81, 27)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(81, 22)" end="(81, 23)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(81, 22)" end="(81, 23)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(81, 24)" end="(81, 25)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(81, 26)" end="(81, 27)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(81, 26)" end="(81, 27)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(81, 28)" end="(81, 29)" leading="" trailing=" " val=":"/>
                    <NullNode start="(81, 30)" end="(81, 42)">
                      <OtherNode start="(81, 30)" end="(81, 42)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(81, 30)" end="(81, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(81, 32)" end="(81, 33)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(81, 34)" end="(81, 42)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(81, 34)" end="(81, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(81, 36)" end="(81, 37)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(81, 38)" end="(81, 42)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(81, 38)" end="(81, 42)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(81, 42)" end="(81, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(81, 43)" end="(81, 44)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(82, 5)" end="(82, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(82, 5)" end="(82, 6)" leading="" trailing="" val="["/>
              <NullNode start="(82, 6)" end="(82, 10)">
                <IdentNode start="(82, 6)" end="(82, 8)" leading="" trailing=" " raw_val="i₂" val="i₂"/>
                <AtomNode start="(82, 9)" end="(82, 10)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(82, 11)" end="(82, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(82, 11)" end="(82, 23)" leading="" trailing=" " raw_val="Std.Antisymm" val="Std.Antisymm" full_name="Std.Antisymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(82, 24)" end="(82, 48)">
                  <OtherNode start="(82, 24)" end="(82, 48)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(82, 24)" end="(82, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(82, 25)" end="(82, 32)" kind="«term¬_»">
                      <AtomNode start="(82, 25)" end="(82, 26)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(82, 27)" end="(82, 32)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(82, 27)" end="(82, 28)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(82, 27)" end="(82, 28)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(82, 29)" end="(82, 30)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(82, 31)" end="(82, 32)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(82, 31)" end="(82, 32)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(82, 33)" end="(82, 34)" leading="" trailing=" " val=":"/>
                    <NullNode start="(82, 35)" end="(82, 47)">
                      <OtherNode start="(82, 35)" end="(82, 47)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(82, 35)" end="(82, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(82, 37)" end="(82, 38)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(82, 39)" end="(82, 47)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(82, 39)" end="(82, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(82, 41)" end="(82, 42)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(82, 43)" end="(82, 47)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(82, 43)" end="(82, 47)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(82, 47)" end="(82, 48)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(82, 48)" end="(82, 49)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(83, 5)" end="(83, 10)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(83, 5)" end="(83, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(83, 6)" end="(83, 9)">
                <IdentNode start="(83, 6)" end="(83, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(83, 8)" end="(83, 9)" leading="" trailing="" raw_val="b" val="b"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(83, 9)" end="(83, 10)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(83, 11)" end="(83, 27)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(83, 11)" end="(83, 12)" leading="" trailing="" val="{"/>
              <NullNode start="(83, 12)" end="(83, 17)">
                <IdentNode start="(83, 12)" end="(83, 14)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(83, 15)" end="(83, 17)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(83, 18)" end="(83, 26)">
                <AtomNode start="(83, 18)" end="(83, 19)" leading="" trailing=" " val=":"/>
                <OtherNode start="(83, 20)" end="(83, 26)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(83, 20)" end="(83, 24)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(83, 25)" end="(83, 26)">
                    <IdentNode start="(83, 25)" end="(83, 26)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(83, 26)" end="(83, 27)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(83, 28)" end="(84, 52)">
            <AtomNode start="(83, 28)" end="(83, 29)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(84, 5)" end="(84, 52)" kind="«term_↔_»">
              <OtherNode start="(84, 5)" end="(84, 26)" kind="«term_≤_»">
                <OtherNode start="(84, 5)" end="(84, 14)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(84, 5)" end="(84, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(84, 6)" end="(84, 13)" kind="«term_::_»">
                    <IdentNode start="(84, 6)" end="(84, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(84, 8)" end="(84, 10)" leading="" trailing=" " val="::"/>
                    <IdentNode start="(84, 11)" end="(84, 13)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                  </OtherNode>
                  <AtomNode start="(84, 13)" end="(84, 14)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(84, 15)" end="(84, 16)" leading="" trailing=" " val="≤"/>
                <OtherNode start="(84, 17)" end="(84, 26)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(84, 17)" end="(84, 18)" leading="" trailing="" val="("/>
                  <OtherNode start="(84, 18)" end="(84, 25)" kind="«term_::_»">
                    <IdentNode start="(84, 18)" end="(84, 19)" leading="" trailing=" " raw_val="b" val="b"/>
                    <AtomNode start="(84, 20)" end="(84, 22)" leading="" trailing=" " val="::"/>
                    <IdentNode start="(84, 23)" end="(84, 25)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                  </OtherNode>
                  <AtomNode start="(84, 25)" end="(84, 26)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(84, 27)" end="(84, 28)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(84, 29)" end="(84, 52)" kind="«term_∨_»">
                <OtherNode start="(84, 29)" end="(84, 34)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(84, 29)" end="(84, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(84, 31)" end="(84, 32)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(84, 33)" end="(84, 34)" leading="" trailing=" " raw_val="b" val="b"/>
                </OtherNode>
                <AtomNode start="(84, 35)" end="(84, 36)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(84, 37)" end="(84, 52)" kind="«term_∧_»">
                  <OtherNode start="(84, 37)" end="(84, 42)" kind="«term_=_»">
                    <IdentNode start="(84, 37)" end="(84, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(84, 39)" end="(84, 40)" leading="" trailing=" " val="="/>
                    <IdentNode start="(84, 41)" end="(84, 42)" leading="" trailing=" " raw_val="b" val="b"/>
                  </OtherNode>
                  <AtomNode start="(84, 43)" end="(84, 44)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(84, 45)" end="(84, 52)" kind="«term_≤_»">
                    <IdentNode start="(84, 45)" end="(84, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <AtomNode start="(84, 48)" end="(84, 49)" leading="" trailing=" " val="≤"/>
                    <IdentNode start="(84, 50)" end="(84, 52)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(84, 53)" end="(103, 48)">
          <AtomNode start="(84, 53)" end="(84, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(84, 56)" end="(103, 48)">
            <AtomNode start="(84, 56)" end="(84, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(85, 3)" end="(103, 48)">
              <TacticTacticseq1IndentedNode start="(85, 3)" end="(103, 48)">
                <NullNode start="(85, 3)" end="(103, 48)">
                  <OtherNode start="(85, 3)" end="(85, 48)" kind="Lean.Parser.Tactic.dsimp" state_before="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ a :: l₁ ≤ b :: l₂ ↔ a &amp;lt; b ∨ a = b ∧ l₁ ≤ l₂" state_after="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) (b :: l₂) (a :: l₁) ↔ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" tactic="dsimp only [instLE, instLT, List.le, List.lt]">
                    <AtomNode start="(85, 3)" end="(85, 8)" leading="" trailing=" " val="dsimp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(85, 9)" end="(85, 13)">
                      <AtomNode start="(85, 9)" end="(85, 13)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(85, 14)" end="(85, 48)">
                      <AtomNode start="(85, 14)" end="(85, 15)" leading="" trailing="" val="["/>
                      <NullNode start="(85, 15)" end="(85, 47)">
                        <OtherNode start="(85, 15)" end="(85, 21)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(85, 15)" end="(85, 21)" leading="" trailing="" raw_val="instLE" val="instLE" full_name="List.instLE" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(85, 21)" end="(85, 22)" leading="" trailing=" " val=","/>
                        <OtherNode start="(85, 23)" end="(85, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(85, 23)" end="(85, 29)" leading="" trailing="" raw_val="instLT" val="instLT" full_name="List.instLT" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(85, 29)" end="(85, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(85, 31)" end="(85, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(85, 31)" end="(85, 38)" leading="" trailing="" raw_val="List.le" val="List.le" full_name="List.le" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(85, 38)" end="(85, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(85, 40)" end="(85, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(85, 40)" end="(85, 47)" leading="" trailing="" raw_val="List.lt" val="List.lt" full_name="List.lt" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(85, 47)" end="(85, 48)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(86, 3)" end="(86, 43)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) (b :: l₂) (a :: l₁) ↔ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁ ↔ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" tactic="simp only [not_cons_lex_cons_iff, ne_eq]">
                    <AtomNode start="(86, 3)" end="(86, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(86, 8)" end="(86, 12)">
                      <AtomNode start="(86, 8)" end="(86, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(86, 13)" end="(86, 43)">
                      <AtomNode start="(86, 13)" end="(86, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(86, 14)" end="(86, 42)">
                        <OtherNode start="(86, 14)" end="(86, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(86, 14)" end="(86, 35)" leading="" trailing="" raw_val="not_cons_lex_cons_iff" val="not_cons_lex_cons_iff" full_name="List.not_cons_lex_cons_iff" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(75, 9)" def_end="(75, 30)"/>
                        </OtherNode>
                        <AtomNode start="(86, 35)" end="(86, 36)" leading="" trailing=" " val=","/>
                        <OtherNode start="(86, 37)" end="(86, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(86, 37)" end="(86, 42)" leading="" trailing="" raw_val="ne_eq" val="ne_eq" full_name="ne_eq" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(86, 42)" end="(86, 43)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(87, 3)" end="(87, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁ ↔ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="case mp&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁ → a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;&#10;case mpr&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁ → ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" tactic="constructor">
                    <AtomNode start="(87, 3)" end="(87, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(88, 3)" end="(98, 42)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁ → a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;&#10;case mpr&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁ → ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="case mpr&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁ → ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" tactic="· rintro (⟨h₁, h₂⟩ | ⟨h₁, h₂⟩)&#10;  · left&#10;    apply Decidable.byContradiction&#10;    intro h₃&#10;    apply h₂&#10;    exact i₂.antisymm _ _ h₁ h₃&#10;  · if h₃ : a &amp;lt; b then&#10;      exact .inl h₃&#10;    else&#10;      right&#10;      exact ⟨i₂.antisymm _ _ h₃ h₁, h₂⟩">
                    <OtherNode start="(88, 3)" end="(88, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(88, 3)" end="(88, 4)" kind="patternIgnore">
                        <OtherNode start="(88, 3)" end="(88, 4)" kind="token.«· »">
                          <AtomNode start="(88, 3)" end="(88, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(88, 5)" end="(98, 42)">
                      <TacticTacticseq1IndentedNode start="(88, 5)" end="(98, 42)">
                        <NullNode start="(88, 5)" end="(98, 42)">
                          <OtherNode start="(88, 5)" end="(88, 33)" kind="Lean.Parser.Tactic.rintro" state_before="case mp&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁ → a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="case mp.inl.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬b = a&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;&#10;case mp.inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" tactic="rintro (⟨h₁, h₂⟩ | ⟨h₁, h₂⟩)">
                            <AtomNode start="(88, 5)" end="(88, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(88, 12)" end="(88, 33)">
                              <OtherNode start="(88, 12)" end="(88, 33)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(88, 12)" end="(88, 33)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                  <AtomNode start="(88, 12)" end="(88, 13)" leading="" trailing="" val="("/>
                                  <OtherNode start="(88, 13)" end="(88, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                    <OtherNode start="(88, 13)" end="(88, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                      <NullNode start="(88, 13)" end="(88, 32)">
                                        <OtherNode start="(88, 13)" end="(88, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(88, 13)" end="(88, 14)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(88, 14)" end="(88, 20)">
                                            <OtherNode start="(88, 14)" end="(88, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(88, 14)" end="(88, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(88, 14)" end="(88, 16)">
                                                  <OtherNode start="(88, 14)" end="(88, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(88, 14)" end="(88, 16)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(88, 16)" end="(88, 17)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(88, 18)" end="(88, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(88, 18)" end="(88, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(88, 18)" end="(88, 20)">
                                                  <OtherNode start="(88, 18)" end="(88, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(88, 18)" end="(88, 20)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(88, 20)" end="(88, 21)" leading="" trailing=" " val="⟩"/>
                                        </OtherNode>
                                        <AtomNode start="(88, 22)" end="(88, 23)" leading="" trailing=" " val="|"/>
                                        <OtherNode start="(88, 24)" end="(88, 32)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(88, 24)" end="(88, 25)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(88, 25)" end="(88, 31)">
                                            <OtherNode start="(88, 25)" end="(88, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(88, 25)" end="(88, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(88, 25)" end="(88, 27)">
                                                  <OtherNode start="(88, 25)" end="(88, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(88, 25)" end="(88, 27)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(88, 27)" end="(88, 28)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(88, 29)" end="(88, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(88, 29)" end="(88, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(88, 29)" end="(88, 31)">
                                                  <OtherNode start="(88, 29)" end="(88, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(88, 29)" end="(88, 31)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(88, 31)" end="(88, 32)" leading="" trailing="" val="⟩"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(88, 32)" end="(88, 33)" leading="" trailing="&#10;    " val=")"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(89, 5)" end="(93, 34)" kind="Lean.cdot" state_before="case mp.inl.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬b = a&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;&#10;case mp.inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="case mp.inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" tactic="· left&#10;  apply Decidable.byContradiction&#10;  intro h₃&#10;  apply h₂&#10;  exact i₂.antisymm _ _ h₁ h₃">
                            <OtherNode start="(89, 5)" end="(89, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(89, 5)" end="(89, 6)" kind="patternIgnore">
                                <OtherNode start="(89, 5)" end="(89, 6)" kind="token.«· »">
                                  <AtomNode start="(89, 5)" end="(89, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(89, 7)" end="(93, 34)">
                              <TacticTacticseq1IndentedNode start="(89, 7)" end="(93, 34)">
                                <NullNode start="(89, 7)" end="(93, 34)">
                                  <OtherNode start="(89, 7)" end="(89, 11)" kind="Lean.Parser.Tactic.left" state_before="case mp.inl.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬b = a&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="case mp.inl.intro.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬b = a&#10;⊢ a &amp;lt; b" tactic="left">
                                    <AtomNode start="(89, 7)" end="(89, 11)" leading="" trailing="&#10;      " val="left"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(90, 7)" end="(90, 38)" kind="Lean.Parser.Tactic.apply" state_before="case mp.inl.intro.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬b = a&#10;⊢ a &amp;lt; b" state_after="case mp.inl.intro.h.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬b = a&#10;⊢ ¬a &amp;lt; b → False" tactic="apply Decidable.byContradiction">
                                    <AtomNode start="(90, 7)" end="(90, 12)" leading="" trailing=" " val="apply"/>
                                    <IdentNode start="(90, 13)" end="(90, 38)" leading="" trailing="&#10;      " raw_val="Decidable.byContradiction" val="Decidable.byContradiction" full_name="Decidable.byContradiction" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(91, 7)" end="(91, 15)" kind="Lean.Parser.Tactic.intro" state_before="case mp.inl.intro.h.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬b = a&#10;⊢ ¬a &amp;lt; b → False" state_after="case mp.inl.intro.h.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬b = a&#10;h₃ : ¬a &amp;lt; b&#10;⊢ False" tactic="intro h₃">
                                    <AtomNode start="(91, 7)" end="(91, 12)" leading="" trailing=" " val="intro"/>
                                    <NullNode start="(91, 13)" end="(91, 15)">
                                      <IdentNode start="(91, 13)" end="(91, 15)" leading="" trailing="&#10;      " raw_val="h₃" val="h₃"/>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(92, 7)" end="(92, 15)" kind="Lean.Parser.Tactic.apply" state_before="case mp.inl.intro.h.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬b = a&#10;h₃ : ¬a &amp;lt; b&#10;⊢ False" state_after="case mp.inl.intro.h.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬b = a&#10;h₃ : ¬a &amp;lt; b&#10;⊢ b = a" tactic="apply h₂">
                                    <AtomNode start="(92, 7)" end="(92, 12)" leading="" trailing=" " val="apply"/>
                                    <IdentNode start="(92, 13)" end="(92, 15)" leading="" trailing="&#10;      " raw_val="h₂" val="h₂"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(93, 7)" end="(93, 34)" kind="Lean.Parser.Tactic.exact" state_before="case mp.inl.intro.h.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬b = a&#10;h₃ : ¬a &amp;lt; b&#10;⊢ b = a" state_after="no goals" tactic="exact i₂.antisymm _ _ h₁ h₃">
                                    <AtomNode start="(93, 7)" end="(93, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(93, 13)" end="(93, 34)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(93, 13)" end="(93, 24)" leading="" trailing=" " raw_val="i₂.antisymm" val="i₂.antisymm"/>
                                      <NullNode start="(93, 25)" end="(93, 34)">
                                        <TermHoleNode start="(93, 25)" end="(93, 26)">
                                          <AtomNode start="(93, 25)" end="(93, 26)" leading="" trailing=" " val="_"/>
                                        </TermHoleNode>
                                        <TermHoleNode start="(93, 27)" end="(93, 28)">
                                          <AtomNode start="(93, 27)" end="(93, 28)" leading="" trailing=" " val="_"/>
                                        </TermHoleNode>
                                        <IdentNode start="(93, 29)" end="(93, 31)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                        <IdentNode start="(93, 32)" end="(93, 34)" leading="" trailing="&#10;    " raw_val="h₃" val="h₃"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(94, 5)" end="(98, 42)" kind="Lean.cdot" state_before="case mp.inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="no goals" tactic="· if h₃ : a &amp;lt; b then&#10;    exact .inl h₃&#10;  else&#10;    right&#10;    exact ⟨i₂.antisymm _ _ h₃ h₁, h₂⟩">
                            <OtherNode start="(94, 5)" end="(94, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(94, 5)" end="(94, 6)" kind="patternIgnore">
                                <OtherNode start="(94, 5)" end="(94, 6)" kind="token.«· »">
                                  <AtomNode start="(94, 5)" end="(94, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(94, 7)" end="(98, 42)">
                              <TacticTacticseq1IndentedNode start="(94, 7)" end="(98, 42)">
                                <NullNode start="(94, 7)" end="(98, 42)">
                                  <OtherNode start="(94, 7)" end="(98, 42)" kind="Lean.Parser.Tactic.tacDepIfThenElse" state_before="case mp.inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="no goals" tactic="if h₃ : a &amp;lt; b then&#10;  exact .inl h₃&#10;else&#10;  right&#10;  exact ⟨i₂.antisymm _ _ h₃ h₁, h₂⟩">
                                    <AtomNode start="(94, 7)" end="(94, 9)" leading="" trailing=" " val="if"/>
                                    <LeanBinderidentNode start="(94, 10)" end="(94, 12)">
                                      <IdentNode start="(94, 10)" end="(94, 12)" leading="" trailing=" " raw_val="h₃" val="h₃"/>
                                    </LeanBinderidentNode>
                                    <AtomNode start="(94, 13)" end="(94, 14)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(94, 15)" end="(94, 20)" kind="«term_&amp;lt;_»">
                                      <IdentNode start="(94, 15)" end="(94, 16)" leading="" trailing=" " raw_val="a" val="a"/>
                                      <AtomNode start="(94, 17)" end="(94, 18)" leading="" trailing=" " val="&amp;lt;"/>
                                      <IdentNode start="(94, 19)" end="(94, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                                    </OtherNode>
                                    <AtomNode start="(94, 21)" end="(94, 25)" leading="" trailing="&#10;        " val="then"/>
                                    <TacticTacticseqNode start="(95, 9)" end="(95, 22)">
                                      <TacticTacticseq1IndentedNode start="(95, 9)" end="(95, 22)">
                                        <NullNode start="(95, 9)" end="(95, 22)">
                                          <OtherNode start="(95, 9)" end="(95, 22)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;h₃ : a &amp;lt; b&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="no goals" tactic="exact .inl h₃">
                                            <AtomNode start="(95, 9)" end="(95, 14)" leading="" trailing=" " val="exact"/>
                                            <OtherNode start="(95, 15)" end="(95, 22)" kind="Lean.Parser.Term.app">
                                              <OtherNode start="(95, 15)" end="(95, 19)" kind="Lean.Parser.Term.dotIdent">
                                                <AtomNode start="(95, 15)" end="(95, 16)" leading="" trailing="" val="."/>
                                                <IdentNode start="(95, 16)" end="(95, 19)" leading="" trailing=" " raw_val="inl" val="inl"/>
                                              </OtherNode>
                                              <NullNode start="(95, 20)" end="(95, 22)">
                                                <IdentNode start="(95, 20)" end="(95, 22)" leading="" trailing="&#10;      " raw_val="h₃" val="h₃"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                    <AtomNode start="(96, 7)" end="(96, 11)" leading="" trailing="&#10;        " val="else"/>
                                    <TacticTacticseqNode start="(97, 9)" end="(98, 42)">
                                      <TacticTacticseq1IndentedNode start="(97, 9)" end="(98, 42)">
                                        <NullNode start="(97, 9)" end="(98, 42)">
                                          <OtherNode start="(97, 9)" end="(97, 14)" kind="Lean.Parser.Tactic.right" state_before="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;h₃ : ¬a &amp;lt; b&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="case h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;h₃ : ¬a &amp;lt; b&#10;⊢ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" tactic="right">
                                            <AtomNode start="(97, 9)" end="(97, 14)" leading="" trailing="&#10;        " val="right"/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(98, 9)" end="(98, 42)" kind="Lean.Parser.Tactic.exact" state_before="case h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : ¬b &amp;lt; a&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;h₃ : ¬a &amp;lt; b&#10;⊢ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="no goals" tactic="exact ⟨i₂.antisymm _ _ h₃ h₁, h₂⟩">
                                            <AtomNode start="(98, 9)" end="(98, 14)" leading="" trailing=" " val="exact"/>
                                            <OtherNode start="(98, 15)" end="(98, 42)" kind="Lean.Parser.Term.anonymousCtor">
                                              <AtomNode start="(98, 15)" end="(98, 16)" leading="" trailing="" val="⟨"/>
                                              <NullNode start="(98, 16)" end="(98, 41)">
                                                <OtherNode start="(98, 16)" end="(98, 37)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(98, 16)" end="(98, 27)" leading="" trailing=" " raw_val="i₂.antisymm" val="i₂.antisymm"/>
                                                  <NullNode start="(98, 28)" end="(98, 37)">
                                                    <TermHoleNode start="(98, 28)" end="(98, 29)">
                                                      <AtomNode start="(98, 28)" end="(98, 29)" leading="" trailing=" " val="_"/>
                                                    </TermHoleNode>
                                                    <TermHoleNode start="(98, 30)" end="(98, 31)">
                                                      <AtomNode start="(98, 30)" end="(98, 31)" leading="" trailing=" " val="_"/>
                                                    </TermHoleNode>
                                                    <IdentNode start="(98, 32)" end="(98, 34)" leading="" trailing=" " raw_val="h₃" val="h₃"/>
                                                    <IdentNode start="(98, 35)" end="(98, 37)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                  </NullNode>
                                                </OtherNode>
                                                <AtomNode start="(98, 37)" end="(98, 38)" leading="" trailing=" " val=","/>
                                                <IdentNode start="(98, 39)" end="(98, 41)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                              </NullNode>
                                              <AtomNode start="(98, 41)" end="(98, 42)" leading="" trailing="&#10;  " val="⟩"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(99, 3)" end="(103, 48)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁ → ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="no goals" tactic="· rintro (h | ⟨h₁, h₂⟩)&#10;  · left&#10;    exact ⟨i₁.asymm _ _ h, fun w =&amp;gt; i₀.irrefl _ (w ▸ h)⟩&#10;  · right&#10;    exact ⟨fun w =&amp;gt; i₀.irrefl _ (h₁ ▸ w), h₂⟩">
                    <OtherNode start="(99, 3)" end="(99, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(99, 3)" end="(99, 4)" kind="patternIgnore">
                        <OtherNode start="(99, 3)" end="(99, 4)" kind="token.«· »">
                          <AtomNode start="(99, 3)" end="(99, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(99, 5)" end="(103, 48)">
                      <TacticTacticseq1IndentedNode start="(99, 5)" end="(103, 48)">
                        <NullNode start="(99, 5)" end="(103, 48)">
                          <OtherNode start="(99, 5)" end="(99, 26)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;⊢ a &amp;lt; b ∨ a = b ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁ → ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="case mpr.inl&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; b&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;&#10;case mpr.inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : a = b&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" tactic="rintro (h | ⟨h₁, h₂⟩)">
                            <AtomNode start="(99, 5)" end="(99, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(99, 12)" end="(99, 26)">
                              <OtherNode start="(99, 12)" end="(99, 26)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(99, 12)" end="(99, 26)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                  <AtomNode start="(99, 12)" end="(99, 13)" leading="" trailing="" val="("/>
                                  <OtherNode start="(99, 13)" end="(99, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                    <OtherNode start="(99, 13)" end="(99, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                      <NullNode start="(99, 13)" end="(99, 25)">
                                        <OtherNode start="(99, 13)" end="(99, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(99, 13)" end="(99, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                        </OtherNode>
                                        <AtomNode start="(99, 15)" end="(99, 16)" leading="" trailing=" " val="|"/>
                                        <OtherNode start="(99, 17)" end="(99, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(99, 17)" end="(99, 18)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(99, 18)" end="(99, 24)">
                                            <OtherNode start="(99, 18)" end="(99, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(99, 18)" end="(99, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(99, 18)" end="(99, 20)">
                                                  <OtherNode start="(99, 18)" end="(99, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(99, 18)" end="(99, 20)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(99, 20)" end="(99, 21)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(99, 22)" end="(99, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(99, 22)" end="(99, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(99, 22)" end="(99, 24)">
                                                  <OtherNode start="(99, 22)" end="(99, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(99, 22)" end="(99, 24)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(99, 24)" end="(99, 25)" leading="" trailing="" val="⟩"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(99, 25)" end="(99, 26)" leading="" trailing="&#10;    " val=")"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(100, 5)" end="(101, 59)" kind="Lean.cdot" state_before="case mpr.inl&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; b&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;&#10;case mpr.inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : a = b&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="case mpr.inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : a = b&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" tactic="· left&#10;  exact ⟨i₁.asymm _ _ h, fun w =&amp;gt; i₀.irrefl _ (w ▸ h)⟩">
                            <OtherNode start="(100, 5)" end="(100, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(100, 5)" end="(100, 6)" kind="patternIgnore">
                                <OtherNode start="(100, 5)" end="(100, 6)" kind="token.«· »">
                                  <AtomNode start="(100, 5)" end="(100, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(100, 7)" end="(101, 59)">
                              <TacticTacticseq1IndentedNode start="(100, 7)" end="(101, 59)">
                                <NullNode start="(100, 7)" end="(101, 59)">
                                  <OtherNode start="(100, 7)" end="(100, 11)" kind="Lean.Parser.Tactic.left" state_before="case mpr.inl&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; b&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="case mpr.inl.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; b&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a" tactic="left">
                                    <AtomNode start="(100, 7)" end="(100, 11)" leading="" trailing="&#10;      " val="left"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(101, 7)" end="(101, 59)" kind="Lean.Parser.Tactic.exact" state_before="case mpr.inl.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; b&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a" state_after="no goals" tactic="exact ⟨i₁.asymm _ _ h, fun w =&amp;gt; i₀.irrefl _ (w ▸ h)⟩">
                                    <AtomNode start="(101, 7)" end="(101, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(101, 13)" end="(101, 59)" kind="Lean.Parser.Term.anonymousCtor">
                                      <AtomNode start="(101, 13)" end="(101, 14)" leading="" trailing="" val="⟨"/>
                                      <NullNode start="(101, 14)" end="(101, 58)">
                                        <OtherNode start="(101, 14)" end="(101, 28)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(101, 14)" end="(101, 22)" leading="" trailing=" " raw_val="i₁.asymm" val="i₁.asymm"/>
                                          <NullNode start="(101, 23)" end="(101, 28)">
                                            <TermHoleNode start="(101, 23)" end="(101, 24)">
                                              <AtomNode start="(101, 23)" end="(101, 24)" leading="" trailing=" " val="_"/>
                                            </TermHoleNode>
                                            <TermHoleNode start="(101, 25)" end="(101, 26)">
                                              <AtomNode start="(101, 25)" end="(101, 26)" leading="" trailing=" " val="_"/>
                                            </TermHoleNode>
                                            <IdentNode start="(101, 27)" end="(101, 28)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(101, 28)" end="(101, 29)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(101, 30)" end="(101, 58)" kind="Lean.Parser.Term.fun">
                                          <AtomNode start="(101, 30)" end="(101, 33)" leading="" trailing=" " val="fun"/>
                                          <OtherNode start="(101, 34)" end="(101, 58)" kind="Lean.Parser.Term.basicFun">
                                            <NullNode start="(101, 34)" end="(101, 35)">
                                              <IdentNode start="(101, 34)" end="(101, 35)" leading="" trailing=" " raw_val="w" val="w"/>
                                            </NullNode>
                                            <NullNode/>
                                            <AtomNode start="(101, 36)" end="(101, 38)" leading="" trailing=" " val="=&amp;gt;"/>
                                            <OtherNode start="(101, 39)" end="(101, 58)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(101, 39)" end="(101, 48)" leading="" trailing=" " raw_val="i₀.irrefl" val="i₀.irrefl"/>
                                              <NullNode start="(101, 49)" end="(101, 58)">
                                                <TermHoleNode start="(101, 49)" end="(101, 50)">
                                                  <AtomNode start="(101, 49)" end="(101, 50)" leading="" trailing=" " val="_"/>
                                                </TermHoleNode>
                                                <OtherNode start="(101, 51)" end="(101, 58)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(101, 51)" end="(101, 52)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(101, 52)" end="(101, 57)" kind="Lean.Parser.Term.subst">
                                                    <IdentNode start="(101, 52)" end="(101, 53)" leading="" trailing=" " raw_val="w" val="w"/>
                                                    <AtomNode start="(101, 54)" end="(101, 55)" leading="" trailing=" " val="▸"/>
                                                    <NullNode start="(101, 56)" end="(101, 57)">
                                                      <IdentNode start="(101, 56)" end="(101, 57)" leading="" trailing="" raw_val="h" val="h"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <AtomNode start="(101, 57)" end="(101, 58)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(101, 58)" end="(101, 59)" leading="" trailing="&#10;    " val="⟩"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(102, 5)" end="(103, 48)" kind="Lean.cdot" state_before="case mpr.inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : a = b&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="no goals" tactic="· right&#10;  exact ⟨fun w =&amp;gt; i₀.irrefl _ (h₁ ▸ w), h₂⟩">
                            <OtherNode start="(102, 5)" end="(102, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(102, 5)" end="(102, 6)" kind="patternIgnore">
                                <OtherNode start="(102, 5)" end="(102, 6)" kind="token.«· »">
                                  <AtomNode start="(102, 5)" end="(102, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(102, 7)" end="(103, 48)">
                              <TacticTacticseq1IndentedNode start="(102, 7)" end="(103, 48)">
                                <NullNode start="(102, 7)" end="(103, 48)">
                                  <OtherNode start="(102, 7)" end="(102, 12)" kind="Lean.Parser.Tactic.right" state_before="case mpr.inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : a = b&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;⊢ ¬b &amp;lt; a ∧ ¬b = a ∨ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="case mpr.inr.intro.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : a = b&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;⊢ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" tactic="right">
                                    <AtomNode start="(102, 7)" end="(102, 12)" leading="" trailing="&#10;      " val="right"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(103, 7)" end="(103, 48)" kind="Lean.Parser.Tactic.exact" state_before="case mpr.inr.intro.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h₁ : a = b&#10;h₂ : ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁&#10;⊢ ¬b &amp;lt; a ∧ ¬Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₁" state_after="no goals" tactic="exact ⟨fun w =&amp;gt; i₀.irrefl _ (h₁ ▸ w), h₂⟩">
                                    <AtomNode start="(103, 7)" end="(103, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(103, 13)" end="(103, 48)" kind="Lean.Parser.Term.anonymousCtor">
                                      <AtomNode start="(103, 13)" end="(103, 14)" leading="" trailing="" val="⟨"/>
                                      <NullNode start="(103, 14)" end="(103, 47)">
                                        <OtherNode start="(103, 14)" end="(103, 43)" kind="Lean.Parser.Term.fun">
                                          <AtomNode start="(103, 14)" end="(103, 17)" leading="" trailing=" " val="fun"/>
                                          <OtherNode start="(103, 18)" end="(103, 43)" kind="Lean.Parser.Term.basicFun">
                                            <NullNode start="(103, 18)" end="(103, 19)">
                                              <IdentNode start="(103, 18)" end="(103, 19)" leading="" trailing=" " raw_val="w" val="w"/>
                                            </NullNode>
                                            <NullNode/>
                                            <AtomNode start="(103, 20)" end="(103, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                                            <OtherNode start="(103, 23)" end="(103, 43)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(103, 23)" end="(103, 32)" leading="" trailing=" " raw_val="i₀.irrefl" val="i₀.irrefl"/>
                                              <NullNode start="(103, 33)" end="(103, 43)">
                                                <TermHoleNode start="(103, 33)" end="(103, 34)">
                                                  <AtomNode start="(103, 33)" end="(103, 34)" leading="" trailing=" " val="_"/>
                                                </TermHoleNode>
                                                <OtherNode start="(103, 35)" end="(103, 43)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(103, 35)" end="(103, 36)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(103, 36)" end="(103, 42)" kind="Lean.Parser.Term.subst">
                                                    <IdentNode start="(103, 36)" end="(103, 38)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                                    <AtomNode start="(103, 39)" end="(103, 40)" leading="" trailing=" " val="▸"/>
                                                    <NullNode start="(103, 41)" end="(103, 42)">
                                                      <IdentNode start="(103, 41)" end="(103, 42)" leading="" trailing="" raw_val="w" val="w"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <AtomNode start="(103, 42)" end="(103, 43)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(103, 43)" end="(103, 44)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(103, 45)" end="(103, 47)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                      </NullNode>
                                      <AtomNode start="(103, 47)" end="(103, 48)" leading="" trailing="&#10;&#10;" val="⟩"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(105, 1)" end="(113, 22)" name="not_lt_of_cons_le_cons" full_name="List.not_lt_of_cons_le_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(105, 1)" end="(113, 22)" name="not_lt_of_cons_le_cons" full_name="List.not_lt_of_cons_le_cons" _is_private_decl="False">
        <AtomNode start="(105, 1)" end="(105, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(105, 9)" end="(105, 31)">
          <IdentNode start="(105, 9)" end="(105, 31)" leading="" trailing=" " raw_val="not_lt_of_cons_le_cons" val="not_lt_of_cons_le_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(105, 32)" end="(109, 65)">
          <NullNode start="(105, 32)" end="(109, 55)">
            <OtherNode start="(105, 32)" end="(105, 47)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(105, 32)" end="(105, 33)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(105, 33)" end="(105, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(105, 33)" end="(105, 44)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(105, 45)" end="(105, 46)">
                  <IdentNode start="(105, 45)" end="(105, 46)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(105, 46)" end="(105, 47)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(105, 48)" end="(105, 54)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(105, 48)" end="(105, 49)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(105, 49)" end="(105, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(105, 49)" end="(105, 51)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(105, 52)" end="(105, 53)">
                  <IdentNode start="(105, 52)" end="(105, 53)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(105, 53)" end="(105, 54)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(105, 55)" end="(105, 70)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(105, 55)" end="(105, 56)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(105, 56)" end="(105, 69)" kind="Lean.Parser.Term.app">
                <IdentNode start="(105, 56)" end="(105, 67)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(105, 68)" end="(105, 69)">
                  <IdentNode start="(105, 68)" end="(105, 69)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(105, 69)" end="(105, 70)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(106, 5)" end="(106, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(106, 5)" end="(106, 6)" leading="" trailing="" val="["/>
              <NullNode start="(106, 6)" end="(106, 10)">
                <IdentNode start="(106, 6)" end="(106, 8)" leading="" trailing=" " raw_val="i₀" val="i₀"/>
                <AtomNode start="(106, 9)" end="(106, 10)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(106, 11)" end="(106, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(106, 11)" end="(106, 21)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(106, 22)" end="(106, 44)">
                  <OtherNode start="(106, 22)" end="(106, 44)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(106, 22)" end="(106, 23)" leading="" trailing="" val="("/>
                    <OtherNode start="(106, 23)" end="(106, 28)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(106, 23)" end="(106, 24)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(106, 23)" end="(106, 24)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(106, 25)" end="(106, 26)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(106, 27)" end="(106, 28)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(106, 27)" end="(106, 28)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(106, 29)" end="(106, 30)" leading="" trailing=" " val=":"/>
                    <NullNode start="(106, 31)" end="(106, 43)">
                      <OtherNode start="(106, 31)" end="(106, 43)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(106, 31)" end="(106, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(106, 33)" end="(106, 34)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(106, 35)" end="(106, 43)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(106, 35)" end="(106, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(106, 37)" end="(106, 38)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(106, 39)" end="(106, 43)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(106, 39)" end="(106, 43)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(106, 43)" end="(106, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(106, 44)" end="(106, 45)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(107, 5)" end="(107, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(107, 5)" end="(107, 6)" leading="" trailing="" val="["/>
              <NullNode start="(107, 6)" end="(107, 10)">
                <IdentNode start="(107, 6)" end="(107, 8)" leading="" trailing=" " raw_val="i₁" val="i₁"/>
                <AtomNode start="(107, 9)" end="(107, 10)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(107, 11)" end="(107, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(107, 11)" end="(107, 20)" leading="" trailing=" " raw_val="Std.Asymm" val="Std.Asymm" full_name="Std.Asymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(107, 21)" end="(107, 43)">
                  <OtherNode start="(107, 21)" end="(107, 43)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(107, 21)" end="(107, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(107, 22)" end="(107, 27)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(107, 22)" end="(107, 23)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(107, 22)" end="(107, 23)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(107, 24)" end="(107, 25)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(107, 26)" end="(107, 27)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(107, 26)" end="(107, 27)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(107, 28)" end="(107, 29)" leading="" trailing=" " val=":"/>
                    <NullNode start="(107, 30)" end="(107, 42)">
                      <OtherNode start="(107, 30)" end="(107, 42)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(107, 30)" end="(107, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(107, 32)" end="(107, 33)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(107, 34)" end="(107, 42)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(107, 34)" end="(107, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(107, 36)" end="(107, 37)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(107, 38)" end="(107, 42)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(107, 38)" end="(107, 42)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(107, 42)" end="(107, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(107, 43)" end="(107, 44)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(108, 5)" end="(108, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(108, 5)" end="(108, 6)" leading="" trailing="" val="["/>
              <NullNode start="(108, 6)" end="(108, 10)">
                <IdentNode start="(108, 6)" end="(108, 8)" leading="" trailing=" " raw_val="i₂" val="i₂"/>
                <AtomNode start="(108, 9)" end="(108, 10)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(108, 11)" end="(108, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(108, 11)" end="(108, 23)" leading="" trailing=" " raw_val="Std.Antisymm" val="Std.Antisymm" full_name="Std.Antisymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(108, 24)" end="(108, 48)">
                  <OtherNode start="(108, 24)" end="(108, 48)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(108, 24)" end="(108, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(108, 25)" end="(108, 32)" kind="«term¬_»">
                      <AtomNode start="(108, 25)" end="(108, 26)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(108, 27)" end="(108, 32)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(108, 27)" end="(108, 28)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(108, 27)" end="(108, 28)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(108, 29)" end="(108, 30)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(108, 31)" end="(108, 32)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(108, 31)" end="(108, 32)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(108, 33)" end="(108, 34)" leading="" trailing=" " val=":"/>
                    <NullNode start="(108, 35)" end="(108, 47)">
                      <OtherNode start="(108, 35)" end="(108, 47)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(108, 35)" end="(108, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(108, 37)" end="(108, 38)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(108, 39)" end="(108, 47)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(108, 39)" end="(108, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(108, 41)" end="(108, 42)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(108, 43)" end="(108, 47)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(108, 43)" end="(108, 47)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(108, 47)" end="(108, 48)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(108, 48)" end="(108, 49)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(109, 5)" end="(109, 14)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(109, 5)" end="(109, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(109, 6)" end="(109, 9)">
                <IdentNode start="(109, 6)" end="(109, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(109, 8)" end="(109, 9)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(109, 10)" end="(109, 13)">
                <AtomNode start="(109, 10)" end="(109, 11)" leading="" trailing=" " val=":"/>
                <IdentNode start="(109, 12)" end="(109, 13)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(109, 13)" end="(109, 14)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(109, 15)" end="(109, 31)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(109, 15)" end="(109, 16)" leading="" trailing="" val="{"/>
              <NullNode start="(109, 16)" end="(109, 21)">
                <IdentNode start="(109, 16)" end="(109, 18)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(109, 19)" end="(109, 21)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(109, 22)" end="(109, 30)">
                <AtomNode start="(109, 22)" end="(109, 23)" leading="" trailing=" " val=":"/>
                <OtherNode start="(109, 24)" end="(109, 30)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(109, 24)" end="(109, 28)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(109, 29)" end="(109, 30)">
                    <IdentNode start="(109, 29)" end="(109, 30)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(109, 30)" end="(109, 31)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(109, 32)" end="(109, 55)">
              <AtomNode start="(109, 32)" end="(109, 33)" leading="" trailing="" val="("/>
              <NullNode start="(109, 33)" end="(109, 34)">
                <IdentNode start="(109, 33)" end="(109, 34)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(109, 35)" end="(109, 54)">
                <AtomNode start="(109, 35)" end="(109, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(109, 37)" end="(109, 54)" kind="«term_≤_»">
                  <OtherNode start="(109, 37)" end="(109, 44)" kind="«term_::_»">
                    <IdentNode start="(109, 37)" end="(109, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(109, 39)" end="(109, 41)" leading="" trailing=" " val="::"/>
                    <IdentNode start="(109, 42)" end="(109, 44)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </OtherNode>
                  <AtomNode start="(109, 45)" end="(109, 46)" leading="" trailing=" " val="≤"/>
                  <OtherNode start="(109, 47)" end="(109, 54)" kind="«term_::_»">
                    <IdentNode start="(109, 47)" end="(109, 48)" leading="" trailing=" " raw_val="b" val="b"/>
                    <AtomNode start="(109, 49)" end="(109, 51)" leading="" trailing=" " val="::"/>
                    <IdentNode start="(109, 52)" end="(109, 54)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(109, 54)" end="(109, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(109, 56)" end="(109, 65)">
            <AtomNode start="(109, 56)" end="(109, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(109, 58)" end="(109, 65)" kind="«term¬_»">
              <AtomNode start="(109, 58)" end="(109, 59)" leading="" trailing=" " val="¬"/>
              <OtherNode start="(109, 60)" end="(109, 65)" kind="«term_&amp;lt;_»">
                <IdentNode start="(109, 60)" end="(109, 61)" leading="" trailing=" " raw_val="b" val="b"/>
                <AtomNode start="(109, 62)" end="(109, 63)" leading="" trailing=" " val="&amp;lt;"/>
                <IdentNode start="(109, 64)" end="(109, 65)" leading="" trailing=" " raw_val="a" val="a"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(109, 66)" end="(113, 22)">
          <AtomNode start="(109, 66)" end="(109, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(109, 69)" end="(113, 22)">
            <AtomNode start="(109, 69)" end="(109, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(110, 3)" end="(113, 22)">
              <TacticTacticseq1IndentedNode start="(110, 3)" end="(113, 22)">
                <NullNode start="(110, 3)" end="(113, 22)">
                  <OtherNode start="(110, 3)" end="(110, 29)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h : a :: l₁ ≤ b :: l₂&#10;⊢ ¬b &amp;lt; a" state_after="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; b ∨ a = b ∧ l₁ ≤ l₂&#10;⊢ ¬b &amp;lt; a" tactic="rw [cons_le_cons_iff] at h">
                    <AtomNode start="(110, 3)" end="(110, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(110, 6)" end="(110, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(110, 6)" end="(110, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(110, 7)" end="(110, 23)">
                        <OtherNode start="(110, 7)" end="(110, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(110, 7)" end="(110, 23)" leading="" trailing="" raw_val="cons_le_cons_iff" val="cons_le_cons_iff" full_name="List.cons_le_cons_iff" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(79, 9)" def_end="(79, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(110, 23)" end="(110, 24)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(110, 25)" end="(110, 29)">
                      <OtherNode start="(110, 25)" end="(110, 29)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(110, 25)" end="(110, 27)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(110, 28)" end="(110, 29)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(110, 28)" end="(110, 29)">
                            <IdentNode start="(110, 28)" end="(110, 29)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(111, 3)" end="(111, 29)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; b ∨ a = b ∧ l₁ ≤ l₂&#10;⊢ ¬b &amp;lt; a" state_after="case inl&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; b&#10;⊢ ¬b &amp;lt; a&#10;&#10;case inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;⊢ ¬a &amp;lt; a" tactic="rcases h with h | ⟨rfl, h⟩">
                    <AtomNode start="(111, 3)" end="(111, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(111, 10)" end="(111, 11)">
                      <OtherNode start="(111, 10)" end="(111, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(111, 10)" end="(111, 11)" leading="" trailing=" " raw_val="h" val="h"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(111, 12)" end="(111, 29)">
                      <AtomNode start="(111, 12)" end="(111, 16)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(111, 17)" end="(111, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(111, 17)" end="(111, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(111, 17)" end="(111, 29)">
                            <OtherNode start="(111, 17)" end="(111, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                              <IdentNode start="(111, 17)" end="(111, 18)" leading="" trailing=" " raw_val="h" val="h"/>
                            </OtherNode>
                            <AtomNode start="(111, 19)" end="(111, 20)" leading="" trailing=" " val="|"/>
                            <OtherNode start="(111, 21)" end="(111, 29)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(111, 21)" end="(111, 22)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(111, 22)" end="(111, 28)">
                                <OtherNode start="(111, 22)" end="(111, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(111, 22)" end="(111, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(111, 22)" end="(111, 25)">
                                      <OtherNode start="(111, 22)" end="(111, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(111, 22)" end="(111, 25)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(111, 25)" end="(111, 26)" leading="" trailing=" " val=","/>
                                <OtherNode start="(111, 27)" end="(111, 28)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(111, 27)" end="(111, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(111, 27)" end="(111, 28)">
                                      <OtherNode start="(111, 27)" end="(111, 28)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(111, 27)" end="(111, 28)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(111, 28)" end="(111, 29)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(112, 3)" end="(112, 25)" kind="Lean.cdot" state_before="case inl&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; b&#10;⊢ ¬b &amp;lt; a&#10;&#10;case inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;⊢ ¬a &amp;lt; a" state_after="case inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;⊢ ¬a &amp;lt; a" tactic="· exact i₁.asymm _ _ h">
                    <OtherNode start="(112, 3)" end="(112, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(112, 3)" end="(112, 4)" kind="patternIgnore">
                        <OtherNode start="(112, 3)" end="(112, 4)" kind="token.«· »">
                          <AtomNode start="(112, 3)" end="(112, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(112, 5)" end="(112, 25)">
                      <TacticTacticseq1IndentedNode start="(112, 5)" end="(112, 25)">
                        <NullNode start="(112, 5)" end="(112, 25)">
                          <OtherNode start="(112, 5)" end="(112, 25)" kind="Lean.Parser.Tactic.exact" state_before="case inl&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a b : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; b&#10;⊢ ¬b &amp;lt; a" state_after="no goals" tactic="exact i₁.asymm _ _ h">
                            <AtomNode start="(112, 5)" end="(112, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(112, 11)" end="(112, 25)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(112, 11)" end="(112, 19)" leading="" trailing=" " raw_val="i₁.asymm" val="i₁.asymm"/>
                              <NullNode start="(112, 20)" end="(112, 25)">
                                <TermHoleNode start="(112, 20)" end="(112, 21)">
                                  <AtomNode start="(112, 20)" end="(112, 21)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <TermHoleNode start="(112, 22)" end="(112, 23)">
                                  <AtomNode start="(112, 22)" end="(112, 23)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <IdentNode start="(112, 24)" end="(112, 25)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(113, 3)" end="(113, 22)" kind="Lean.cdot" state_before="case inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;⊢ ¬a &amp;lt; a" state_after="no goals" tactic="· exact i₀.irrefl _">
                    <OtherNode start="(113, 3)" end="(113, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(113, 3)" end="(113, 4)" kind="patternIgnore">
                        <OtherNode start="(113, 3)" end="(113, 4)" kind="token.«· »">
                          <AtomNode start="(113, 3)" end="(113, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(113, 5)" end="(113, 22)">
                      <TacticTacticseq1IndentedNode start="(113, 5)" end="(113, 22)">
                        <NullNode start="(113, 5)" end="(113, 22)">
                          <OtherNode start="(113, 5)" end="(113, 22)" kind="Lean.Parser.Tactic.exact" state_before="case inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;⊢ ¬a &amp;lt; a" state_after="no goals" tactic="exact i₀.irrefl _">
                            <AtomNode start="(113, 5)" end="(113, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(113, 11)" end="(113, 22)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(113, 11)" end="(113, 20)" leading="" trailing=" " raw_val="i₀.irrefl" val="i₀.irrefl"/>
                              <NullNode start="(113, 21)" end="(113, 22)">
                                <TermHoleNode start="(113, 21)" end="(113, 22)">
                                  <AtomNode start="(113, 21)" end="(113, 22)" leading="" trailing="&#10;&#10;" val="_"/>
                                </TermHoleNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(115, 1)" end="(123, 12)" name="le_of_cons_le_cons" full_name="List.le_of_cons_le_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(115, 1)" end="(123, 12)" name="le_of_cons_le_cons" full_name="List.le_of_cons_le_cons" _is_private_decl="False">
        <AtomNode start="(115, 1)" end="(115, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(115, 9)" end="(115, 27)">
          <IdentNode start="(115, 9)" end="(115, 27)" leading="" trailing=" " raw_val="le_of_cons_le_cons" val="le_of_cons_le_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(115, 28)" end="(119, 59)">
          <NullNode start="(115, 28)" end="(119, 49)">
            <OtherNode start="(115, 28)" end="(115, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(115, 28)" end="(115, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(115, 29)" end="(115, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(115, 29)" end="(115, 40)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(115, 41)" end="(115, 42)">
                  <IdentNode start="(115, 41)" end="(115, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(115, 42)" end="(115, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(115, 44)" end="(115, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(115, 44)" end="(115, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(115, 45)" end="(115, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(115, 45)" end="(115, 47)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(115, 48)" end="(115, 49)">
                  <IdentNode start="(115, 48)" end="(115, 49)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(115, 49)" end="(115, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(115, 51)" end="(115, 66)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(115, 51)" end="(115, 52)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(115, 52)" end="(115, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(115, 52)" end="(115, 63)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(115, 64)" end="(115, 65)">
                  <IdentNode start="(115, 64)" end="(115, 65)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(115, 65)" end="(115, 66)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(116, 5)" end="(116, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(116, 5)" end="(116, 6)" leading="" trailing="" val="["/>
              <NullNode start="(116, 6)" end="(116, 10)">
                <IdentNode start="(116, 6)" end="(116, 8)" leading="" trailing=" " raw_val="i₀" val="i₀"/>
                <AtomNode start="(116, 9)" end="(116, 10)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(116, 11)" end="(116, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(116, 11)" end="(116, 21)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(116, 22)" end="(116, 44)">
                  <OtherNode start="(116, 22)" end="(116, 44)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(116, 22)" end="(116, 23)" leading="" trailing="" val="("/>
                    <OtherNode start="(116, 23)" end="(116, 28)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(116, 23)" end="(116, 24)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(116, 23)" end="(116, 24)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(116, 25)" end="(116, 26)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(116, 27)" end="(116, 28)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(116, 27)" end="(116, 28)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(116, 29)" end="(116, 30)" leading="" trailing=" " val=":"/>
                    <NullNode start="(116, 31)" end="(116, 43)">
                      <OtherNode start="(116, 31)" end="(116, 43)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(116, 31)" end="(116, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(116, 33)" end="(116, 34)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(116, 35)" end="(116, 43)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(116, 35)" end="(116, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(116, 37)" end="(116, 38)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(116, 39)" end="(116, 43)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(116, 39)" end="(116, 43)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(116, 43)" end="(116, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(116, 44)" end="(116, 45)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(117, 5)" end="(117, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(117, 5)" end="(117, 6)" leading="" trailing="" val="["/>
              <NullNode start="(117, 6)" end="(117, 10)">
                <IdentNode start="(117, 6)" end="(117, 8)" leading="" trailing=" " raw_val="i₁" val="i₁"/>
                <AtomNode start="(117, 9)" end="(117, 10)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(117, 11)" end="(117, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(117, 11)" end="(117, 20)" leading="" trailing=" " raw_val="Std.Asymm" val="Std.Asymm" full_name="Std.Asymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(117, 21)" end="(117, 43)">
                  <OtherNode start="(117, 21)" end="(117, 43)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(117, 21)" end="(117, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(117, 22)" end="(117, 27)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(117, 22)" end="(117, 23)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(117, 22)" end="(117, 23)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(117, 24)" end="(117, 25)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(117, 26)" end="(117, 27)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(117, 26)" end="(117, 27)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(117, 28)" end="(117, 29)" leading="" trailing=" " val=":"/>
                    <NullNode start="(117, 30)" end="(117, 42)">
                      <OtherNode start="(117, 30)" end="(117, 42)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(117, 30)" end="(117, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(117, 32)" end="(117, 33)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(117, 34)" end="(117, 42)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(117, 34)" end="(117, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(117, 36)" end="(117, 37)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(117, 38)" end="(117, 42)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(117, 38)" end="(117, 42)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(117, 42)" end="(117, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(117, 43)" end="(117, 44)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(118, 5)" end="(118, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(118, 5)" end="(118, 6)" leading="" trailing="" val="["/>
              <NullNode start="(118, 6)" end="(118, 10)">
                <IdentNode start="(118, 6)" end="(118, 8)" leading="" trailing=" " raw_val="i₂" val="i₂"/>
                <AtomNode start="(118, 9)" end="(118, 10)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(118, 11)" end="(118, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(118, 11)" end="(118, 23)" leading="" trailing=" " raw_val="Std.Antisymm" val="Std.Antisymm" full_name="Std.Antisymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(118, 24)" end="(118, 48)">
                  <OtherNode start="(118, 24)" end="(118, 48)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(118, 24)" end="(118, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(118, 25)" end="(118, 32)" kind="«term¬_»">
                      <AtomNode start="(118, 25)" end="(118, 26)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(118, 27)" end="(118, 32)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(118, 27)" end="(118, 28)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(118, 27)" end="(118, 28)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(118, 29)" end="(118, 30)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(118, 31)" end="(118, 32)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(118, 31)" end="(118, 32)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(118, 33)" end="(118, 34)" leading="" trailing=" " val=":"/>
                    <NullNode start="(118, 35)" end="(118, 47)">
                      <OtherNode start="(118, 35)" end="(118, 47)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(118, 35)" end="(118, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(118, 37)" end="(118, 38)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(118, 39)" end="(118, 47)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(118, 39)" end="(118, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(118, 41)" end="(118, 42)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(118, 43)" end="(118, 47)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(118, 43)" end="(118, 47)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(118, 47)" end="(118, 48)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(118, 48)" end="(118, 49)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(119, 5)" end="(119, 8)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(119, 5)" end="(119, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(119, 6)" end="(119, 7)">
                <IdentNode start="(119, 6)" end="(119, 7)" leading="" trailing="" raw_val="a" val="a"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(119, 7)" end="(119, 8)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(119, 9)" end="(119, 25)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(119, 9)" end="(119, 10)" leading="" trailing="" val="{"/>
              <NullNode start="(119, 10)" end="(119, 15)">
                <IdentNode start="(119, 10)" end="(119, 12)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(119, 13)" end="(119, 15)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(119, 16)" end="(119, 24)">
                <AtomNode start="(119, 16)" end="(119, 17)" leading="" trailing=" " val=":"/>
                <OtherNode start="(119, 18)" end="(119, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(119, 18)" end="(119, 22)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(119, 23)" end="(119, 24)">
                    <IdentNode start="(119, 23)" end="(119, 24)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(119, 24)" end="(119, 25)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(119, 26)" end="(119, 49)">
              <AtomNode start="(119, 26)" end="(119, 27)" leading="" trailing="" val="("/>
              <NullNode start="(119, 27)" end="(119, 28)">
                <IdentNode start="(119, 27)" end="(119, 28)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(119, 29)" end="(119, 48)">
                <AtomNode start="(119, 29)" end="(119, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(119, 31)" end="(119, 48)" kind="«term_≤_»">
                  <OtherNode start="(119, 31)" end="(119, 38)" kind="«term_::_»">
                    <IdentNode start="(119, 31)" end="(119, 32)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(119, 33)" end="(119, 35)" leading="" trailing=" " val="::"/>
                    <IdentNode start="(119, 36)" end="(119, 38)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </OtherNode>
                  <AtomNode start="(119, 39)" end="(119, 40)" leading="" trailing=" " val="≤"/>
                  <OtherNode start="(119, 41)" end="(119, 48)" kind="«term_::_»">
                    <IdentNode start="(119, 41)" end="(119, 42)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(119, 43)" end="(119, 45)" leading="" trailing=" " val="::"/>
                    <IdentNode start="(119, 46)" end="(119, 48)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(119, 48)" end="(119, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(119, 50)" end="(119, 59)">
            <AtomNode start="(119, 50)" end="(119, 51)" leading="" trailing=" " val=":"/>
            <OtherNode start="(119, 52)" end="(119, 59)" kind="«term_≤_»">
              <IdentNode start="(119, 52)" end="(119, 54)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              <AtomNode start="(119, 55)" end="(119, 56)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(119, 57)" end="(119, 59)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(119, 60)" end="(123, 12)">
          <AtomNode start="(119, 60)" end="(119, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(119, 63)" end="(123, 12)">
            <AtomNode start="(119, 63)" end="(119, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(120, 3)" end="(123, 12)">
              <TacticTacticseq1IndentedNode start="(120, 3)" end="(123, 12)">
                <NullNode start="(120, 3)" end="(123, 12)">
                  <OtherNode start="(120, 3)" end="(120, 29)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;h : a :: l₁ ≤ a :: l₂&#10;⊢ l₁ ≤ l₂" state_after="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; a ∨ a = a ∧ l₁ ≤ l₂&#10;⊢ l₁ ≤ l₂" tactic="rw [cons_le_cons_iff] at h">
                    <AtomNode start="(120, 3)" end="(120, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(120, 6)" end="(120, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(120, 6)" end="(120, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(120, 7)" end="(120, 23)">
                        <OtherNode start="(120, 7)" end="(120, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(120, 7)" end="(120, 23)" leading="" trailing="" raw_val="cons_le_cons_iff" val="cons_le_cons_iff" full_name="List.cons_le_cons_iff" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(79, 9)" def_end="(79, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(120, 23)" end="(120, 24)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(120, 25)" end="(120, 29)">
                      <OtherNode start="(120, 25)" end="(120, 29)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(120, 25)" end="(120, 27)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(120, 28)" end="(120, 29)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(120, 28)" end="(120, 29)">
                            <IdentNode start="(120, 28)" end="(120, 29)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(121, 3)" end="(121, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; a ∨ a = a ∧ l₁ ≤ l₂&#10;⊢ l₁ ≤ l₂" state_after="case inl&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; a&#10;⊢ l₁ ≤ l₂&#10;&#10;case inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;left✝ : a = a&#10;h : l₁ ≤ l₂&#10;⊢ l₁ ≤ l₂" tactic="rcases h with h | ⟨_, h⟩">
                    <AtomNode start="(121, 3)" end="(121, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(121, 10)" end="(121, 11)">
                      <OtherNode start="(121, 10)" end="(121, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(121, 10)" end="(121, 11)" leading="" trailing=" " raw_val="h" val="h"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(121, 12)" end="(121, 27)">
                      <AtomNode start="(121, 12)" end="(121, 16)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(121, 17)" end="(121, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(121, 17)" end="(121, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(121, 17)" end="(121, 27)">
                            <OtherNode start="(121, 17)" end="(121, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                              <IdentNode start="(121, 17)" end="(121, 18)" leading="" trailing=" " raw_val="h" val="h"/>
                            </OtherNode>
                            <AtomNode start="(121, 19)" end="(121, 20)" leading="" trailing=" " val="|"/>
                            <OtherNode start="(121, 21)" end="(121, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(121, 21)" end="(121, 22)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(121, 22)" end="(121, 26)">
                                <OtherNode start="(121, 22)" end="(121, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(121, 22)" end="(121, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(121, 22)" end="(121, 23)">
                                      <OtherNode start="(121, 22)" end="(121, 23)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                        <AtomNode start="(121, 22)" end="(121, 23)" leading="" trailing="" val="_"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(121, 23)" end="(121, 24)" leading="" trailing=" " val=","/>
                                <OtherNode start="(121, 25)" end="(121, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(121, 25)" end="(121, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(121, 25)" end="(121, 26)">
                                      <OtherNode start="(121, 25)" end="(121, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(121, 25)" end="(121, 26)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(121, 26)" end="(121, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(122, 3)" end="(122, 37)" kind="Lean.cdot" state_before="case inl&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; a&#10;⊢ l₁ ≤ l₂&#10;&#10;case inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;left✝ : a = a&#10;h : l₁ ≤ l₂&#10;⊢ l₁ ≤ l₂" state_after="case inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;left✝ : a = a&#10;h : l₁ ≤ l₂&#10;⊢ l₁ ≤ l₂" tactic="· exact False.elim (i₀.irrefl _ h)">
                    <OtherNode start="(122, 3)" end="(122, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(122, 3)" end="(122, 4)" kind="patternIgnore">
                        <OtherNode start="(122, 3)" end="(122, 4)" kind="token.«· »">
                          <AtomNode start="(122, 3)" end="(122, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(122, 5)" end="(122, 37)">
                      <TacticTacticseq1IndentedNode start="(122, 5)" end="(122, 37)">
                        <NullNode start="(122, 5)" end="(122, 37)">
                          <OtherNode start="(122, 5)" end="(122, 37)" kind="Lean.Parser.Tactic.exact" state_before="case inl&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;h : a &amp;lt; a&#10;⊢ l₁ ≤ l₂" state_after="no goals" tactic="exact False.elim (i₀.irrefl _ h)">
                            <AtomNode start="(122, 5)" end="(122, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(122, 11)" end="(122, 37)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(122, 11)" end="(122, 21)" leading="" trailing=" " raw_val="False.elim" val="False.elim" full_name="False.elim" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(122, 22)" end="(122, 37)">
                                <OtherNode start="(122, 22)" end="(122, 37)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(122, 22)" end="(122, 23)" leading="" trailing="" val="("/>
                                  <OtherNode start="(122, 23)" end="(122, 36)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(122, 23)" end="(122, 32)" leading="" trailing=" " raw_val="i₀.irrefl" val="i₀.irrefl"/>
                                    <NullNode start="(122, 33)" end="(122, 36)">
                                      <TermHoleNode start="(122, 33)" end="(122, 34)">
                                        <AtomNode start="(122, 33)" end="(122, 34)" leading="" trailing=" " val="_"/>
                                      </TermHoleNode>
                                      <IdentNode start="(122, 35)" end="(122, 36)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(122, 36)" end="(122, 37)" leading="" trailing="&#10;  " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(123, 3)" end="(123, 12)" kind="Lean.cdot" state_before="case inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;left✝ : a = a&#10;h : l₁ ≤ l₂&#10;⊢ l₁ ≤ l₂" state_after="no goals" tactic="· exact h">
                    <OtherNode start="(123, 3)" end="(123, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(123, 3)" end="(123, 4)" kind="patternIgnore">
                        <OtherNode start="(123, 3)" end="(123, 4)" kind="token.«· »">
                          <AtomNode start="(123, 3)" end="(123, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(123, 5)" end="(123, 12)">
                      <TacticTacticseq1IndentedNode start="(123, 5)" end="(123, 12)">
                        <NullNode start="(123, 5)" end="(123, 12)">
                          <OtherNode start="(123, 5)" end="(123, 12)" kind="Lean.Parser.Tactic.exact" state_before="case inr.intro&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;a : α&#10;l₁ l₂ : List α&#10;left✝ : a = a&#10;h : l₁ ≤ l₂&#10;⊢ l₁ ≤ l₂" state_after="no goals" tactic="exact h">
                            <AtomNode start="(123, 5)" end="(123, 10)" leading="" trailing=" " val="exact"/>
                            <IdentNode start="(123, 11)" end="(123, 12)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(125, 1)" end="(131, 30)" name="le_refl" full_name="List.le_refl">
      <CommandDeclmodifiersNode start="(125, 1)" end="(125, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(125, 1)" end="(125, 10)">
          <OtherNode start="(125, 1)" end="(125, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(125, 1)" end="(125, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(125, 11)" end="(131, 30)" name="le_refl" full_name="List.le_refl" _is_private_decl="False">
        <AtomNode start="(125, 11)" end="(125, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(125, 19)" end="(125, 26)">
          <IdentNode start="(125, 19)" end="(125, 26)" leading="" trailing=" " raw_val="le_refl" val="le_refl"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(125, 27)" end="(125, 95)">
          <NullNode start="(125, 27)" end="(125, 87)">
            <OtherNode start="(125, 27)" end="(125, 33)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(125, 27)" end="(125, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(125, 28)" end="(125, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(125, 28)" end="(125, 30)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(125, 31)" end="(125, 32)">
                  <IdentNode start="(125, 31)" end="(125, 32)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(125, 32)" end="(125, 33)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(125, 34)" end="(125, 74)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(125, 34)" end="(125, 35)" leading="" trailing="" val="["/>
              <NullNode start="(125, 35)" end="(125, 39)">
                <IdentNode start="(125, 35)" end="(125, 37)" leading="" trailing=" " raw_val="i₀" val="i₀"/>
                <AtomNode start="(125, 38)" end="(125, 39)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(125, 40)" end="(125, 73)" kind="Lean.Parser.Term.app">
                <IdentNode start="(125, 40)" end="(125, 50)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(125, 51)" end="(125, 73)">
                  <OtherNode start="(125, 51)" end="(125, 73)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(125, 51)" end="(125, 52)" leading="" trailing="" val="("/>
                    <OtherNode start="(125, 52)" end="(125, 57)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(125, 52)" end="(125, 53)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(125, 52)" end="(125, 53)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(125, 54)" end="(125, 55)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(125, 56)" end="(125, 57)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(125, 56)" end="(125, 57)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(125, 58)" end="(125, 59)" leading="" trailing=" " val=":"/>
                    <NullNode start="(125, 60)" end="(125, 72)">
                      <OtherNode start="(125, 60)" end="(125, 72)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(125, 60)" end="(125, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(125, 62)" end="(125, 63)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(125, 64)" end="(125, 72)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(125, 64)" end="(125, 65)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(125, 66)" end="(125, 67)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(125, 68)" end="(125, 72)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(125, 68)" end="(125, 72)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(125, 72)" end="(125, 73)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(125, 73)" end="(125, 74)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(125, 75)" end="(125, 87)">
              <AtomNode start="(125, 75)" end="(125, 76)" leading="" trailing="" val="("/>
              <NullNode start="(125, 76)" end="(125, 77)">
                <IdentNode start="(125, 76)" end="(125, 77)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(125, 78)" end="(125, 86)">
                <AtomNode start="(125, 78)" end="(125, 79)" leading="" trailing=" " val=":"/>
                <OtherNode start="(125, 80)" end="(125, 86)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(125, 80)" end="(125, 84)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(125, 85)" end="(125, 86)">
                    <IdentNode start="(125, 85)" end="(125, 86)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(125, 86)" end="(125, 87)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(125, 88)" end="(125, 95)">
            <AtomNode start="(125, 88)" end="(125, 89)" leading="" trailing=" " val=":"/>
            <OtherNode start="(125, 90)" end="(125, 95)" kind="«term_≤_»">
              <IdentNode start="(125, 90)" end="(125, 91)" leading="" trailing=" " raw_val="l" val="l"/>
              <AtomNode start="(125, 92)" end="(125, 93)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(125, 94)" end="(125, 95)" leading="" trailing=" " raw_val="l" val="l"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(125, 96)" end="(131, 30)">
          <AtomNode start="(125, 96)" end="(125, 98)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(125, 99)" end="(131, 30)">
            <AtomNode start="(125, 99)" end="(125, 101)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(126, 3)" end="(131, 30)">
              <TacticTacticseq1IndentedNode start="(126, 3)" end="(131, 30)">
                <NullNode start="(126, 3)" end="(131, 30)">
                  <OtherNode start="(126, 3)" end="(131, 30)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝ : LT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;l : List α&#10;⊢ l ≤ l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt;&#10;  intro&#10;  | .rel h =&amp;gt; exact i₀.irrefl _ h&#10;  | .cons h₃ =&amp;gt; exact ih h₃">
                    <AtomNode start="(126, 3)" end="(126, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(126, 13)" end="(126, 14)">
                      <OtherNode start="(126, 13)" end="(126, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(126, 13)" end="(126, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(126, 15)" end="(131, 30)">
                      <OtherNode start="(126, 15)" end="(131, 30)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(126, 15)" end="(126, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(127, 3)" end="(131, 30)">
                          <OtherNode start="(127, 3)" end="(127, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(127, 3)" end="(127, 8)">
                              <OtherNode start="(127, 3)" end="(127, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(127, 3)" end="(127, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(127, 5)" end="(127, 8)">
                                  <NullNode/>
                                  <IdentNode start="(127, 5)" end="(127, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(127, 9)" end="(127, 16)">
                              <AtomNode start="(127, 9)" end="(127, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(127, 12)" end="(127, 16)">
                                <TacticTacticseq1IndentedNode start="(127, 12)" end="(127, 16)">
                                  <NullNode start="(127, 12)" end="(127, 16)">
                                    <OtherNode start="(127, 12)" end="(127, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;inst✝ : LT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;⊢ [] ≤ []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(127, 12)" end="(127, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(128, 3)" end="(131, 30)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(128, 3)" end="(128, 16)">
                              <OtherNode start="(128, 3)" end="(128, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(128, 3)" end="(128, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(128, 5)" end="(128, 9)">
                                  <NullNode/>
                                  <IdentNode start="(128, 5)" end="(128, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(128, 10)" end="(128, 16)">
                                  <IdentNode start="(128, 10)" end="(128, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(128, 12)" end="(128, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(128, 14)" end="(128, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(128, 17)" end="(131, 30)">
                              <AtomNode start="(128, 17)" end="(128, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(129, 5)" end="(131, 30)">
                                <TacticTacticseq1IndentedNode start="(129, 5)" end="(131, 30)">
                                  <NullNode start="(129, 5)" end="(131, 30)">
                                    <OtherNode start="(129, 5)" end="(131, 30)" kind="Lean.Parser.Tactic.introMatch" state_before="case cons&#10;α : Type u_1&#10;inst✝ : LT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;a : α&#10;l : List α&#10;ih : l ≤ l&#10;⊢ a :: l ≤ a :: l" state_after="no goals" tactic="intro&#10;| .rel h =&amp;gt; exact i₀.irrefl _ h&#10;| .cons h₃ =&amp;gt; exact ih h₃">
                                      <AtomNode start="(129, 5)" end="(129, 10)" leading="" trailing="&#10;    " val="intro"/>
                                      <OtherNode start="(130, 5)" end="(131, 30)" kind="Lean.Parser.Term.matchAlts">
                                        <NullNode start="(130, 5)" end="(131, 30)">
                                          <OtherNode start="(130, 5)" end="(130, 36)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(130, 5)" end="(130, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(130, 7)" end="(130, 13)">
                                              <NullNode start="(130, 7)" end="(130, 13)">
                                                <OtherNode start="(130, 7)" end="(130, 13)" kind="Lean.Parser.Term.app">
                                                  <OtherNode start="(130, 7)" end="(130, 11)" kind="Lean.Parser.Term.dotIdent">
                                                    <AtomNode start="(130, 7)" end="(130, 8)" leading="" trailing="" val="."/>
                                                    <IdentNode start="(130, 8)" end="(130, 11)" leading="" trailing=" " raw_val="rel" val="rel"/>
                                                  </OtherNode>
                                                  <NullNode start="(130, 12)" end="(130, 13)">
                                                    <IdentNode start="(130, 12)" end="(130, 13)" leading="" trailing=" " raw_val="h" val="h"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(130, 14)" end="(130, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(130, 17)" end="(130, 36)">
                                              <TacticTacticseq1IndentedNode start="(130, 17)" end="(130, 36)">
                                                <NullNode start="(130, 17)" end="(130, 36)">
                                                  <OtherNode start="(130, 17)" end="(130, 36)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝ : LT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;a : α&#10;l : List α&#10;ih : l ≤ l&#10;x✝ : a :: l &amp;lt; a :: l&#10;h : a &amp;lt; a&#10;⊢ False" state_after="no goals" tactic="exact i₀.irrefl _ h">
                                                    <AtomNode start="(130, 17)" end="(130, 22)" leading="" trailing=" " val="exact"/>
                                                    <OtherNode start="(130, 23)" end="(130, 36)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(130, 23)" end="(130, 32)" leading="" trailing=" " raw_val="i₀.irrefl" val="i₀.irrefl"/>
                                                      <NullNode start="(130, 33)" end="(130, 36)">
                                                        <TermHoleNode start="(130, 33)" end="(130, 34)">
                                                          <AtomNode start="(130, 33)" end="(130, 34)" leading="" trailing=" " val="_"/>
                                                        </TermHoleNode>
                                                        <IdentNode start="(130, 35)" end="(130, 36)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <OtherNode start="(131, 5)" end="(131, 30)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(131, 5)" end="(131, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(131, 7)" end="(131, 15)">
                                              <NullNode start="(131, 7)" end="(131, 15)">
                                                <OtherNode start="(131, 7)" end="(131, 15)" kind="Lean.Parser.Term.app">
                                                  <OtherNode start="(131, 7)" end="(131, 12)" kind="Lean.Parser.Term.dotIdent">
                                                    <AtomNode start="(131, 7)" end="(131, 8)" leading="" trailing="" val="."/>
                                                    <IdentNode start="(131, 8)" end="(131, 12)" leading="" trailing=" " raw_val="cons" val="cons"/>
                                                  </OtherNode>
                                                  <NullNode start="(131, 13)" end="(131, 15)">
                                                    <IdentNode start="(131, 13)" end="(131, 15)" leading="" trailing=" " raw_val="h₃" val="h₃"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(131, 16)" end="(131, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(131, 19)" end="(131, 30)">
                                              <TacticTacticseq1IndentedNode start="(131, 19)" end="(131, 30)">
                                                <NullNode start="(131, 19)" end="(131, 30)">
                                                  <OtherNode start="(131, 19)" end="(131, 30)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝ : LT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;a : α&#10;l : List α&#10;ih : l ≤ l&#10;x✝ : a :: l &amp;lt; a :: l&#10;h₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l l&#10;⊢ False" state_after="no goals" tactic="exact ih h₃">
                                                    <AtomNode start="(131, 19)" end="(131, 24)" leading="" trailing=" " val="exact"/>
                                                    <OtherNode start="(131, 25)" end="(131, 30)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(131, 25)" end="(131, 27)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                      <NullNode start="(131, 28)" end="(131, 30)">
                                                        <IdentNode start="(131, 28)" end="(131, 30)" leading="" trailing="&#10;&#10;" raw_val="h₃" val="h₃"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(133, 1)" end="(134, 23)">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandInstanceNode start="(133, 1)" end="(134, 23)">
        <TermAttrkindNode>
          <NullNode/>
        </TermAttrkindNode>
        <AtomNode start="(133, 1)" end="(133, 9)" leading="" trailing=" " val="instance"/>
        <NullNode/>
        <NullNode/>
        <CommandDeclsigNode start="(133, 10)" end="(133, 96)">
          <NullNode start="(133, 10)" end="(133, 52)">
            <OtherNode start="(133, 10)" end="(133, 16)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(133, 10)" end="(133, 11)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(133, 11)" end="(133, 15)" kind="Lean.Parser.Term.app">
                <IdentNode start="(133, 11)" end="(133, 13)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(133, 14)" end="(133, 15)">
                  <IdentNode start="(133, 14)" end="(133, 15)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(133, 15)" end="(133, 16)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(133, 17)" end="(133, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(133, 17)" end="(133, 18)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(133, 18)" end="(133, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(133, 18)" end="(133, 28)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(133, 29)" end="(133, 51)">
                  <OtherNode start="(133, 29)" end="(133, 51)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(133, 29)" end="(133, 30)" leading="" trailing="" val="("/>
                    <OtherNode start="(133, 30)" end="(133, 35)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(133, 30)" end="(133, 31)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(133, 30)" end="(133, 31)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(133, 32)" end="(133, 33)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(133, 34)" end="(133, 35)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(133, 34)" end="(133, 35)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(133, 36)" end="(133, 37)" leading="" trailing=" " val=":"/>
                    <NullNode start="(133, 38)" end="(133, 50)">
                      <OtherNode start="(133, 38)" end="(133, 50)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(133, 38)" end="(133, 39)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(133, 40)" end="(133, 41)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(133, 42)" end="(133, 50)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(133, 42)" end="(133, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(133, 44)" end="(133, 45)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(133, 46)" end="(133, 50)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(133, 46)" end="(133, 50)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(133, 50)" end="(133, 51)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(133, 51)" end="(133, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(133, 53)" end="(133, 96)">
            <AtomNode start="(133, 53)" end="(133, 54)" leading="" trailing=" " val=":"/>
            <OtherNode start="(133, 55)" end="(133, 96)" kind="Lean.Parser.Term.app">
              <IdentNode start="(133, 55)" end="(133, 63)" leading="" trailing=" " raw_val="Std.Refl" val="Std.Refl" full_name="Std.Refl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
              <NullNode start="(133, 64)" end="(133, 96)">
                <OtherNode start="(133, 64)" end="(133, 96)" kind="Lean.Parser.Term.typeAscription">
                  <AtomNode start="(133, 64)" end="(133, 65)" leading="" trailing="" val="("/>
                  <OtherNode start="(133, 65)" end="(133, 70)" kind="«term_≤_»">
                    <OtherNode start="(133, 65)" end="(133, 66)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(133, 65)" end="(133, 66)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                    <AtomNode start="(133, 67)" end="(133, 68)" leading="" trailing=" " val="≤"/>
                    <OtherNode start="(133, 69)" end="(133, 70)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(133, 69)" end="(133, 70)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(133, 71)" end="(133, 72)" leading="" trailing=" " val=":"/>
                  <NullNode start="(133, 73)" end="(133, 95)">
                    <OtherNode start="(133, 73)" end="(133, 95)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(133, 73)" end="(133, 79)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(133, 73)" end="(133, 77)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(133, 78)" end="(133, 79)">
                          <IdentNode start="(133, 78)" end="(133, 79)" leading="" trailing=" " raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(133, 80)" end="(133, 81)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(133, 82)" end="(133, 95)" kind="Lean.Parser.Term.arrow">
                        <OtherNode start="(133, 82)" end="(133, 88)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(133, 82)" end="(133, 86)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(133, 87)" end="(133, 88)">
                            <IdentNode start="(133, 87)" end="(133, 88)" leading="" trailing=" " raw_val="α" val="α"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(133, 89)" end="(133, 90)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(133, 91)" end="(133, 95)" kind="Lean.Parser.Term.prop">
                          <AtomNode start="(133, 91)" end="(133, 95)" leading="" trailing="" val="Prop"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(133, 95)" end="(133, 96)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandWherestructinstNode start="(133, 97)" end="(134, 23)">
          <AtomNode start="(133, 97)" end="(133, 102)" leading="" trailing="&#10;  " val="where"/>
          <OtherNode start="(134, 3)" end="(134, 23)" kind="Lean.Parser.Term.structInstFields">
            <NullNode start="(134, 3)" end="(134, 23)">
              <OtherNode start="(134, 3)" end="(134, 23)" kind="Lean.Parser.Term.structInstField">
                <OtherNode start="(134, 3)" end="(134, 7)" kind="Lean.Parser.Term.structInstLVal">
                  <IdentNode start="(134, 3)" end="(134, 7)" leading="" trailing=" " raw_val="refl" val="refl"/>
                  <NullNode/>
                </OtherNode>
                <NullNode start="(134, 8)" end="(134, 23)">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(134, 8)" end="(134, 23)" kind="Lean.Parser.Term.structInstFieldDef">
                    <AtomNode start="(134, 8)" end="(134, 10)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(134, 11)" end="(134, 23)" leading="" trailing="&#10;&#10;" raw_val="List.le_refl" val="List.le_refl" full_name="List.le_refl" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(125, 19)" def_end="(125, 26)"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <NullNode/>
        </CommandWherestructinstNode>
      </CommandInstanceNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(136, 1)" end="(151, 35)" name="lex_trans" full_name="List.lex_trans">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(136, 1)" end="(151, 35)" name="lex_trans" full_name="List.lex_trans" _is_private_decl="False">
        <AtomNode start="(136, 1)" end="(136, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(136, 9)" end="(136, 18)">
          <IdentNode start="(136, 9)" end="(136, 18)" leading="" trailing=" " raw_val="lex_trans" val="lex_trans"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(136, 19)" end="(138, 56)">
          <NullNode start="(136, 19)" end="(138, 42)">
            <OtherNode start="(136, 19)" end="(136, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(136, 19)" end="(136, 20)" leading="" trailing="" val="{"/>
              <NullNode start="(136, 20)" end="(136, 21)">
                <IdentNode start="(136, 20)" end="(136, 21)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(136, 22)" end="(136, 36)">
                <AtomNode start="(136, 22)" end="(136, 23)" leading="" trailing=" " val=":"/>
                <OtherNode start="(136, 24)" end="(136, 36)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(136, 24)" end="(136, 25)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(136, 26)" end="(136, 27)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(136, 28)" end="(136, 36)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(136, 28)" end="(136, 29)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(136, 30)" end="(136, 31)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(136, 32)" end="(136, 36)" kind="Lean.Parser.Term.prop">
                      <AtomNode start="(136, 32)" end="(136, 36)" leading="" trailing="" val="Prop"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(136, 36)" end="(136, 37)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(137, 5)" end="(137, 54)">
              <AtomNode start="(137, 5)" end="(137, 6)" leading="" trailing="" val="("/>
              <NullNode start="(137, 6)" end="(137, 14)">
                <IdentNode start="(137, 6)" end="(137, 14)" leading="" trailing=" " raw_val="lt_trans" val="lt_trans"/>
              </NullNode>
              <NullNode start="(137, 15)" end="(137, 53)">
                <AtomNode start="(137, 15)" end="(137, 16)" leading="" trailing=" " val=":"/>
                <OtherNode start="(137, 17)" end="(137, 53)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(137, 17)" end="(137, 18)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(137, 19)" end="(137, 30)">
                    <OtherNode start="(137, 19)" end="(137, 30)" kind="Lean.Parser.Term.implicitBinder">
                      <AtomNode start="(137, 19)" end="(137, 20)" leading="" trailing="" val="{"/>
                      <NullNode start="(137, 20)" end="(137, 25)">
                        <IdentNode start="(137, 20)" end="(137, 21)" leading="" trailing=" " raw_val="x" val="x"/>
                        <IdentNode start="(137, 22)" end="(137, 23)" leading="" trailing=" " raw_val="y" val="y"/>
                        <IdentNode start="(137, 24)" end="(137, 25)" leading="" trailing=" " raw_val="z" val="z"/>
                      </NullNode>
                      <NullNode start="(137, 26)" end="(137, 29)">
                        <AtomNode start="(137, 26)" end="(137, 27)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(137, 28)" end="(137, 29)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <AtomNode start="(137, 29)" end="(137, 30)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(137, 30)" end="(137, 31)" leading="" trailing=" " val=","/>
                  <OtherNode start="(137, 32)" end="(137, 53)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(137, 32)" end="(137, 37)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(137, 32)" end="(137, 33)" leading="" trailing=" " raw_val="r" val="r"/>
                      <NullNode start="(137, 34)" end="(137, 37)">
                        <IdentNode start="(137, 34)" end="(137, 35)" leading="" trailing=" " raw_val="x" val="x"/>
                        <IdentNode start="(137, 36)" end="(137, 37)" leading="" trailing=" " raw_val="y" val="y"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(137, 38)" end="(137, 39)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(137, 40)" end="(137, 53)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(137, 40)" end="(137, 45)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(137, 40)" end="(137, 41)" leading="" trailing=" " raw_val="r" val="r"/>
                        <NullNode start="(137, 42)" end="(137, 45)">
                          <IdentNode start="(137, 42)" end="(137, 43)" leading="" trailing=" " raw_val="y" val="y"/>
                          <IdentNode start="(137, 44)" end="(137, 45)" leading="" trailing=" " raw_val="z" val="z"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(137, 46)" end="(137, 47)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(137, 48)" end="(137, 53)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(137, 48)" end="(137, 49)" leading="" trailing=" " raw_val="r" val="r"/>
                        <NullNode start="(137, 50)" end="(137, 53)">
                          <IdentNode start="(137, 50)" end="(137, 51)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(137, 52)" end="(137, 53)" leading="" trailing="" raw_val="z" val="z"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(137, 53)" end="(137, 54)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(138, 5)" end="(138, 23)">
              <AtomNode start="(138, 5)" end="(138, 6)" leading="" trailing="" val="("/>
              <NullNode start="(138, 6)" end="(138, 8)">
                <IdentNode start="(138, 6)" end="(138, 8)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
              </NullNode>
              <NullNode start="(138, 9)" end="(138, 22)">
                <AtomNode start="(138, 9)" end="(138, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(138, 11)" end="(138, 22)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(138, 11)" end="(138, 14)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(138, 15)" end="(138, 22)">
                    <IdentNode start="(138, 15)" end="(138, 16)" leading="" trailing=" " raw_val="r" val="r"/>
                    <IdentNode start="(138, 17)" end="(138, 19)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(138, 20)" end="(138, 22)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(138, 22)" end="(138, 23)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(138, 24)" end="(138, 42)">
              <AtomNode start="(138, 24)" end="(138, 25)" leading="" trailing="" val="("/>
              <NullNode start="(138, 25)" end="(138, 27)">
                <IdentNode start="(138, 25)" end="(138, 27)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
              </NullNode>
              <NullNode start="(138, 28)" end="(138, 41)">
                <AtomNode start="(138, 28)" end="(138, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(138, 30)" end="(138, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(138, 30)" end="(138, 33)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(138, 34)" end="(138, 41)">
                    <IdentNode start="(138, 34)" end="(138, 35)" leading="" trailing=" " raw_val="r" val="r"/>
                    <IdentNode start="(138, 36)" end="(138, 38)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    <IdentNode start="(138, 39)" end="(138, 41)" leading="" trailing="" raw_val="l₃" val="l₃"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(138, 41)" end="(138, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(138, 43)" end="(138, 56)">
            <AtomNode start="(138, 43)" end="(138, 44)" leading="" trailing=" " val=":"/>
            <OtherNode start="(138, 45)" end="(138, 56)" kind="Lean.Parser.Term.app">
              <IdentNode start="(138, 45)" end="(138, 48)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              <NullNode start="(138, 49)" end="(138, 56)">
                <IdentNode start="(138, 49)" end="(138, 50)" leading="" trailing=" " raw_val="r" val="r"/>
                <IdentNode start="(138, 51)" end="(138, 53)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(138, 54)" end="(138, 56)" leading="" trailing=" " raw_val="l₃" val="l₃"/>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(138, 57)" end="(151, 35)">
          <AtomNode start="(138, 57)" end="(138, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(138, 60)" end="(151, 35)">
            <AtomNode start="(138, 60)" end="(138, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(139, 3)" end="(151, 35)">
              <TacticTacticseq1IndentedNode start="(139, 3)" end="(151, 35)">
                <NullNode start="(139, 3)" end="(151, 35)">
                  <OtherNode start="(139, 3)" end="(151, 35)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;l₁ l₂ l₃ : List α&#10;r : α → α → Prop&#10;lt_trans : ∀ {x y z : α}, r x y → r y z → r x z&#10;h₁ : Lex r l₁ l₂&#10;h₂ : Lex r l₂ l₃&#10;⊢ Lex r l₁ l₃" state_after="no goals" tactic="induction h₁ generalizing l₃ with&#10;| nil =&amp;gt; let _::_ := l₃; exact List.Lex.nil ..&#10;| @rel a l₁ b l₂ ab =&amp;gt;&#10;  match h₂ with&#10;  | .rel bc =&amp;gt; exact List.Lex.rel (lt_trans ab bc)&#10;  | .cons ih =&amp;gt;&#10;    exact List.Lex.rel ab&#10;| @cons a l₁ l₂ h₁ ih2 =&amp;gt;&#10;  match h₂ with&#10;  | .rel bc =&amp;gt;&#10;    exact List.Lex.rel bc&#10;  | .cons ih =&amp;gt;&#10;    exact List.Lex.cons (ih2 ih)">
                    <AtomNode start="(139, 3)" end="(139, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(139, 13)" end="(139, 15)">
                      <OtherNode start="(139, 13)" end="(139, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(139, 13)" end="(139, 15)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(139, 16)" end="(139, 31)">
                      <AtomNode start="(139, 16)" end="(139, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(139, 29)" end="(139, 31)">
                        <IdentNode start="(139, 29)" end="(139, 31)" leading="" trailing=" " raw_val="l₃" val="l₃"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(139, 32)" end="(151, 35)">
                      <OtherNode start="(139, 32)" end="(151, 35)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(139, 32)" end="(139, 36)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(140, 3)" end="(151, 35)">
                          <OtherNode start="(140, 3)" end="(140, 49)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(140, 3)" end="(140, 8)">
                              <OtherNode start="(140, 3)" end="(140, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(140, 3)" end="(140, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(140, 5)" end="(140, 8)">
                                  <NullNode/>
                                  <IdentNode start="(140, 5)" end="(140, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.Lex.nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(140, 9)" end="(140, 49)">
                              <AtomNode start="(140, 9)" end="(140, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(140, 12)" end="(140, 49)">
                                <TacticTacticseq1IndentedNode start="(140, 12)" end="(140, 49)">
                                  <NullNode start="(140, 12)" end="(140, 49)">
                                    <OtherNode start="(140, 12)" end="(140, 26)" kind="Lean.Parser.Tactic.tacticLet_" state_before="case nil&#10;α : Type u_1&#10;l₁ l₂ : List α&#10;r : α → α → Prop&#10;lt_trans : ∀ {x y z : α}, r x y → r y z → r x z&#10;a✝ : α&#10;l✝ l₃ : List α&#10;h₂ : Lex r (a✝ :: l✝) l₃&#10;⊢ Lex r [] l₃" state_after="case nil&#10;α : Type u_1&#10;l₁ l₂ : List α&#10;r : α → α → Prop&#10;lt_trans : ∀ {x y z : α}, r x y → r y z → r x z&#10;a✝ : α&#10;l✝ l₃ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;h₂ : Lex r (a✝ :: l✝) (head✝ :: tail✝)&#10;⊢ Lex r [] (head✝ :: tail✝)" tactic="let _::_ := l₃">
                                      <AtomNode start="(140, 12)" end="(140, 15)" leading="" trailing=" " val="let"/>
                                      <OtherNode start="(140, 16)" end="(140, 26)" kind="Lean.Parser.Term.letDecl">
                                        <OtherNode start="(140, 16)" end="(140, 26)" kind="Lean.Parser.Term.letPatDecl">
                                          <OtherNode start="(140, 16)" end="(140, 20)" kind="«term_::_»">
                                            <TermHoleNode start="(140, 16)" end="(140, 17)">
                                              <AtomNode start="(140, 16)" end="(140, 17)" leading="" trailing="" val="_"/>
                                            </TermHoleNode>
                                            <AtomNode start="(140, 17)" end="(140, 19)" leading="" trailing="" val="::"/>
                                            <TermHoleNode start="(140, 19)" end="(140, 20)">
                                              <AtomNode start="(140, 19)" end="(140, 20)" leading="" trailing=" " val="_"/>
                                            </TermHoleNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <AtomNode start="(140, 21)" end="(140, 23)" leading="" trailing=" " val=":="/>
                                          <IdentNode start="(140, 24)" end="(140, 26)" leading="" trailing="" raw_val="l₃" val="l₃"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <AtomNode start="(140, 26)" end="(140, 27)" leading="" trailing=" " val=";"/>
                                    <OtherNode start="(140, 28)" end="(140, 49)" kind="Lean.Parser.Tactic.exact" state_before="case nil&#10;α : Type u_1&#10;l₁ l₂ : List α&#10;r : α → α → Prop&#10;lt_trans : ∀ {x y z : α}, r x y → r y z → r x z&#10;a✝ : α&#10;l✝ l₃ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;h₂ : Lex r (a✝ :: l✝) (head✝ :: tail✝)&#10;⊢ Lex r [] (head✝ :: tail✝)" state_after="no goals" tactic="exact List.Lex.nil ..">
                                      <AtomNode start="(140, 28)" end="(140, 33)" leading="" trailing=" " val="exact"/>
                                      <OtherNode start="(140, 34)" end="(140, 49)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(140, 34)" end="(140, 46)" leading="" trailing=" " raw_val="List.Lex.nil" val="List.Lex.nil" full_name="List.Lex.nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                        <NullNode start="(140, 47)" end="(140, 49)">
                                          <OtherNode start="(140, 47)" end="(140, 49)" kind="Lean.Parser.Term.ellipsis">
                                            <AtomNode start="(140, 47)" end="(140, 49)" leading="" trailing="&#10;  " val=".."/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(141, 3)" end="(145, 28)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(141, 3)" end="(141, 22)">
                              <OtherNode start="(141, 3)" end="(141, 22)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(141, 3)" end="(141, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(141, 5)" end="(141, 9)">
                                  <NullNode start="(141, 5)" end="(141, 6)">
                                    <AtomNode start="(141, 5)" end="(141, 6)" leading="" trailing="" val="@"/>
                                  </NullNode>
                                  <IdentNode start="(141, 6)" end="(141, 9)" leading="" trailing=" " raw_val="rel" val="rel" full_name="List.Lex.rel" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </GroupNode>
                                <NullNode start="(141, 10)" end="(141, 22)">
                                  <IdentNode start="(141, 10)" end="(141, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(141, 12)" end="(141, 14)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                  <IdentNode start="(141, 15)" end="(141, 16)" leading="" trailing=" " raw_val="b" val="b"/>
                                  <IdentNode start="(141, 17)" end="(141, 19)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                  <IdentNode start="(141, 20)" end="(141, 22)" leading="" trailing=" " raw_val="ab" val="ab"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(141, 23)" end="(145, 28)">
                              <AtomNode start="(141, 23)" end="(141, 25)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(142, 5)" end="(145, 28)">
                                <TacticTacticseq1IndentedNode start="(142, 5)" end="(145, 28)">
                                  <NullNode start="(142, 5)" end="(145, 28)">
                                    <OtherNode start="(142, 5)" end="(145, 28)" kind="Lean.Parser.Tactic.match" state_before="case rel&#10;α : Type u_1&#10;l₁✝ l₂✝ : List α&#10;r : α → α → Prop&#10;lt_trans : ∀ {x y z : α}, r x y → r y z → r x z&#10;a : α&#10;l₁ : List α&#10;b : α&#10;l₂ : List α&#10;ab : r a b&#10;l₃ : List α&#10;h₂ : Lex r (b :: l₂) l₃&#10;⊢ Lex r (a :: l₁) l₃" state_after="no goals" tactic="match h₂ with&#10;| .rel bc =&amp;gt; exact List.Lex.rel (lt_trans ab bc)&#10;| .cons ih =&amp;gt;&#10;  exact List.Lex.rel ab">
                                      <AtomNode start="(142, 5)" end="(142, 10)" leading="" trailing=" " val="match"/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(142, 11)" end="(142, 13)">
                                        <OtherNode start="(142, 11)" end="(142, 13)" kind="Lean.Parser.Term.matchDiscr">
                                          <NullNode/>
                                          <IdentNode start="(142, 11)" end="(142, 13)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(142, 14)" end="(142, 18)" leading="" trailing="&#10;    " val="with"/>
                                      <OtherNode start="(143, 5)" end="(145, 28)" kind="Lean.Parser.Term.matchAlts">
                                        <NullNode start="(143, 5)" end="(145, 28)">
                                          <OtherNode start="(143, 5)" end="(143, 53)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(143, 5)" end="(143, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(143, 7)" end="(143, 14)">
                                              <NullNode start="(143, 7)" end="(143, 14)">
                                                <OtherNode start="(143, 7)" end="(143, 14)" kind="Lean.Parser.Term.app">
                                                  <OtherNode start="(143, 7)" end="(143, 11)" kind="Lean.Parser.Term.dotIdent">
                                                    <AtomNode start="(143, 7)" end="(143, 8)" leading="" trailing="" val="."/>
                                                    <IdentNode start="(143, 8)" end="(143, 11)" leading="" trailing=" " raw_val="rel" val="rel"/>
                                                  </OtherNode>
                                                  <NullNode start="(143, 12)" end="(143, 14)">
                                                    <IdentNode start="(143, 12)" end="(143, 14)" leading="" trailing=" " raw_val="bc" val="bc"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(143, 15)" end="(143, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(143, 18)" end="(143, 53)">
                                              <TacticTacticseq1IndentedNode start="(143, 18)" end="(143, 53)">
                                                <NullNode start="(143, 18)" end="(143, 53)">
                                                  <OtherNode start="(143, 18)" end="(143, 53)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;l₁✝ l₂✝¹ : List α&#10;r : α → α → Prop&#10;lt_trans : ∀ {x y z : α}, r x y → r y z → r x z&#10;a : α&#10;l₁ : List α&#10;b : α&#10;l₂ : List α&#10;ab : r a b&#10;l₃ : List α&#10;h₂ : Lex r (b :: l₂) l₃&#10;a₂✝ : α&#10;l₂✝ : List α&#10;bc : r b a₂✝&#10;⊢ Lex r (a :: l₁) (a₂✝ :: l₂✝)" state_after="no goals" tactic="exact List.Lex.rel (lt_trans ab bc)">
                                                    <AtomNode start="(143, 18)" end="(143, 23)" leading="" trailing=" " val="exact"/>
                                                    <OtherNode start="(143, 24)" end="(143, 53)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(143, 24)" end="(143, 36)" leading="" trailing=" " raw_val="List.Lex.rel" val="List.Lex.rel" full_name="List.Lex.rel" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                      <NullNode start="(143, 37)" end="(143, 53)">
                                                        <OtherNode start="(143, 37)" end="(143, 53)" kind="Lean.Parser.Term.paren">
                                                          <AtomNode start="(143, 37)" end="(143, 38)" leading="" trailing="" val="("/>
                                                          <OtherNode start="(143, 38)" end="(143, 52)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(143, 38)" end="(143, 46)" leading="" trailing=" " raw_val="lt_trans" val="lt_trans"/>
                                                            <NullNode start="(143, 47)" end="(143, 52)">
                                                            <IdentNode start="(143, 47)" end="(143, 49)" leading="" trailing=" " raw_val="ab" val="ab"/>
                                                            <IdentNode start="(143, 50)" end="(143, 52)" leading="" trailing="" raw_val="bc" val="bc"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <AtomNode start="(143, 52)" end="(143, 53)" leading="" trailing="&#10;    " val=")"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <OtherNode start="(144, 5)" end="(145, 28)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(144, 5)" end="(144, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(144, 7)" end="(144, 15)">
                                              <NullNode start="(144, 7)" end="(144, 15)">
                                                <OtherNode start="(144, 7)" end="(144, 15)" kind="Lean.Parser.Term.app">
                                                  <OtherNode start="(144, 7)" end="(144, 12)" kind="Lean.Parser.Term.dotIdent">
                                                    <AtomNode start="(144, 7)" end="(144, 8)" leading="" trailing="" val="."/>
                                                    <IdentNode start="(144, 8)" end="(144, 12)" leading="" trailing=" " raw_val="cons" val="cons"/>
                                                  </OtherNode>
                                                  <NullNode start="(144, 13)" end="(144, 15)">
                                                    <IdentNode start="(144, 13)" end="(144, 15)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(144, 16)" end="(144, 18)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(145, 7)" end="(145, 28)">
                                              <TacticTacticseq1IndentedNode start="(145, 7)" end="(145, 28)">
                                                <NullNode start="(145, 7)" end="(145, 28)">
                                                  <OtherNode start="(145, 7)" end="(145, 28)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;l₁✝ l₂✝¹ : List α&#10;r : α → α → Prop&#10;lt_trans : ∀ {x y z : α}, r x y → r y z → r x z&#10;a : α&#10;l₁ : List α&#10;b : α&#10;l₂ : List α&#10;ab : r a b&#10;l₃ : List α&#10;h₂ : Lex r (b :: l₂) l₃&#10;l₂✝ : List α&#10;ih : Lex r l₂ l₂✝&#10;⊢ Lex r (a :: l₁) (b :: l₂✝)" state_after="no goals" tactic="exact List.Lex.rel ab">
                                                    <AtomNode start="(145, 7)" end="(145, 12)" leading="" trailing=" " val="exact"/>
                                                    <OtherNode start="(145, 13)" end="(145, 28)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(145, 13)" end="(145, 25)" leading="" trailing=" " raw_val="List.Lex.rel" val="List.Lex.rel" full_name="List.Lex.rel" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                      <NullNode start="(145, 26)" end="(145, 28)">
                                                        <IdentNode start="(145, 26)" end="(145, 28)" leading="" trailing="&#10;  " raw_val="ab" val="ab"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(146, 3)" end="(151, 35)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(146, 3)" end="(146, 25)">
                              <OtherNode start="(146, 3)" end="(146, 25)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(146, 3)" end="(146, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(146, 5)" end="(146, 10)">
                                  <NullNode start="(146, 5)" end="(146, 6)">
                                    <AtomNode start="(146, 5)" end="(146, 6)" leading="" trailing="" val="@"/>
                                  </NullNode>
                                  <IdentNode start="(146, 6)" end="(146, 10)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.Lex.cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </GroupNode>
                                <NullNode start="(146, 11)" end="(146, 25)">
                                  <IdentNode start="(146, 11)" end="(146, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(146, 13)" end="(146, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                  <IdentNode start="(146, 16)" end="(146, 18)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                  <IdentNode start="(146, 19)" end="(146, 21)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                  <IdentNode start="(146, 22)" end="(146, 25)" leading="" trailing=" " raw_val="ih2" val="ih2"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(146, 26)" end="(151, 35)">
                              <AtomNode start="(146, 26)" end="(146, 28)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(147, 5)" end="(151, 35)">
                                <TacticTacticseq1IndentedNode start="(147, 5)" end="(151, 35)">
                                  <NullNode start="(147, 5)" end="(151, 35)">
                                    <OtherNode start="(147, 5)" end="(151, 35)" kind="Lean.Parser.Tactic.match" state_before="case cons&#10;α : Type u_1&#10;l₁✝ l₂✝ : List α&#10;r : α → α → Prop&#10;lt_trans : ∀ {x y z : α}, r x y → r y z → r x z&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : Lex r l₁ l₂&#10;ih2 : ∀ {l₃ : List α}, Lex r l₂ l₃ → Lex r l₁ l₃&#10;l₃ : List α&#10;h₂ : Lex r (a :: l₂) l₃&#10;⊢ Lex r (a :: l₁) l₃" state_after="no goals" tactic="match h₂ with&#10;| .rel bc =&amp;gt;&#10;  exact List.Lex.rel bc&#10;| .cons ih =&amp;gt;&#10;  exact List.Lex.cons (ih2 ih)">
                                      <AtomNode start="(147, 5)" end="(147, 10)" leading="" trailing=" " val="match"/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(147, 11)" end="(147, 13)">
                                        <OtherNode start="(147, 11)" end="(147, 13)" kind="Lean.Parser.Term.matchDiscr">
                                          <NullNode/>
                                          <IdentNode start="(147, 11)" end="(147, 13)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(147, 14)" end="(147, 18)" leading="" trailing="&#10;    " val="with"/>
                                      <OtherNode start="(148, 5)" end="(151, 35)" kind="Lean.Parser.Term.matchAlts">
                                        <NullNode start="(148, 5)" end="(151, 35)">
                                          <OtherNode start="(148, 5)" end="(149, 28)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(148, 5)" end="(148, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(148, 7)" end="(148, 14)">
                                              <NullNode start="(148, 7)" end="(148, 14)">
                                                <OtherNode start="(148, 7)" end="(148, 14)" kind="Lean.Parser.Term.app">
                                                  <OtherNode start="(148, 7)" end="(148, 11)" kind="Lean.Parser.Term.dotIdent">
                                                    <AtomNode start="(148, 7)" end="(148, 8)" leading="" trailing="" val="."/>
                                                    <IdentNode start="(148, 8)" end="(148, 11)" leading="" trailing=" " raw_val="rel" val="rel"/>
                                                  </OtherNode>
                                                  <NullNode start="(148, 12)" end="(148, 14)">
                                                    <IdentNode start="(148, 12)" end="(148, 14)" leading="" trailing=" " raw_val="bc" val="bc"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(148, 15)" end="(148, 17)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(149, 7)" end="(149, 28)">
                                              <TacticTacticseq1IndentedNode start="(149, 7)" end="(149, 28)">
                                                <NullNode start="(149, 7)" end="(149, 28)">
                                                  <OtherNode start="(149, 7)" end="(149, 28)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;l₁✝ l₂✝¹ : List α&#10;r : α → α → Prop&#10;lt_trans : ∀ {x y z : α}, r x y → r y z → r x z&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : Lex r l₁ l₂&#10;ih2 : ∀ {l₃ : List α}, Lex r l₂ l₃ → Lex r l₁ l₃&#10;l₃ : List α&#10;h₂ : Lex r (a :: l₂) l₃&#10;a₂✝ : α&#10;l₂✝ : List α&#10;bc : r a a₂✝&#10;⊢ Lex r (a :: l₁) (a₂✝ :: l₂✝)" state_after="no goals" tactic="exact List.Lex.rel bc">
                                                    <AtomNode start="(149, 7)" end="(149, 12)" leading="" trailing=" " val="exact"/>
                                                    <OtherNode start="(149, 13)" end="(149, 28)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(149, 13)" end="(149, 25)" leading="" trailing=" " raw_val="List.Lex.rel" val="List.Lex.rel" full_name="List.Lex.rel" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                      <NullNode start="(149, 26)" end="(149, 28)">
                                                        <IdentNode start="(149, 26)" end="(149, 28)" leading="" trailing="&#10;    " raw_val="bc" val="bc"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <OtherNode start="(150, 5)" end="(151, 35)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(150, 5)" end="(150, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(150, 7)" end="(150, 15)">
                                              <NullNode start="(150, 7)" end="(150, 15)">
                                                <OtherNode start="(150, 7)" end="(150, 15)" kind="Lean.Parser.Term.app">
                                                  <OtherNode start="(150, 7)" end="(150, 12)" kind="Lean.Parser.Term.dotIdent">
                                                    <AtomNode start="(150, 7)" end="(150, 8)" leading="" trailing="" val="."/>
                                                    <IdentNode start="(150, 8)" end="(150, 12)" leading="" trailing=" " raw_val="cons" val="cons"/>
                                                  </OtherNode>
                                                  <NullNode start="(150, 13)" end="(150, 15)">
                                                    <IdentNode start="(150, 13)" end="(150, 15)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(150, 16)" end="(150, 18)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(151, 7)" end="(151, 35)">
                                              <TacticTacticseq1IndentedNode start="(151, 7)" end="(151, 35)">
                                                <NullNode start="(151, 7)" end="(151, 35)">
                                                  <OtherNode start="(151, 7)" end="(151, 35)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;l₁✝ l₂✝¹ : List α&#10;r : α → α → Prop&#10;lt_trans : ∀ {x y z : α}, r x y → r y z → r x z&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : Lex r l₁ l₂&#10;ih2 : ∀ {l₃ : List α}, Lex r l₂ l₃ → Lex r l₁ l₃&#10;l₃ : List α&#10;h₂ : Lex r (a :: l₂) l₃&#10;l₂✝ : List α&#10;ih : Lex r l₂ l₂✝&#10;⊢ Lex r (a :: l₁) (a :: l₂✝)" state_after="no goals" tactic="exact List.Lex.cons (ih2 ih)">
                                                    <AtomNode start="(151, 7)" end="(151, 12)" leading="" trailing=" " val="exact"/>
                                                    <OtherNode start="(151, 13)" end="(151, 35)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(151, 13)" end="(151, 26)" leading="" trailing=" " raw_val="List.Lex.cons" val="List.Lex.cons" full_name="List.Lex.cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                      <NullNode start="(151, 27)" end="(151, 35)">
                                                        <OtherNode start="(151, 27)" end="(151, 35)" kind="Lean.Parser.Term.paren">
                                                          <AtomNode start="(151, 27)" end="(151, 28)" leading="" trailing="" val="("/>
                                                          <OtherNode start="(151, 28)" end="(151, 34)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(151, 28)" end="(151, 31)" leading="" trailing=" " raw_val="ih2" val="ih2"/>
                                                            <NullNode start="(151, 32)" end="(151, 34)">
                                                            <IdentNode start="(151, 32)" end="(151, 34)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <AtomNode start="(151, 34)" end="(151, 35)" leading="" trailing="&#10;&#10;" val=")"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(153, 1)" end="(157, 54)" name="lt_trans" full_name="List.lt_trans">
      <CommandDeclmodifiersNode start="(153, 1)" end="(153, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(153, 1)" end="(153, 10)">
          <OtherNode start="(153, 1)" end="(153, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(153, 1)" end="(153, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(153, 11)" end="(157, 54)" name="lt_trans" full_name="List.lt_trans" _is_private_decl="False">
        <AtomNode start="(153, 11)" end="(153, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(153, 19)" end="(153, 27)">
          <IdentNode start="(153, 19)" end="(153, 27)" leading="" trailing=" " raw_val="lt_trans" val="lt_trans"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(153, 28)" end="(155, 64)">
          <NullNode start="(153, 28)" end="(155, 54)">
            <OtherNode start="(153, 28)" end="(153, 34)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(153, 28)" end="(153, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(153, 29)" end="(153, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(153, 29)" end="(153, 31)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(153, 32)" end="(153, 33)">
                  <IdentNode start="(153, 32)" end="(153, 33)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(153, 33)" end="(153, 34)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(154, 5)" end="(154, 56)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(154, 5)" end="(154, 6)" leading="" trailing="" val="["/>
              <NullNode start="(154, 6)" end="(154, 10)">
                <IdentNode start="(154, 6)" end="(154, 8)" leading="" trailing=" " raw_val="i₁" val="i₁"/>
                <AtomNode start="(154, 9)" end="(154, 10)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(154, 11)" end="(154, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(154, 11)" end="(154, 16)" leading="" trailing=" " raw_val="Trans" val="Trans" full_name="Trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(154, 17)" end="(154, 55)">
                  <OtherNode start="(154, 17)" end="(154, 39)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(154, 17)" end="(154, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(154, 18)" end="(154, 23)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(154, 18)" end="(154, 19)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(154, 18)" end="(154, 19)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(154, 20)" end="(154, 21)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(154, 22)" end="(154, 23)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(154, 22)" end="(154, 23)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(154, 24)" end="(154, 25)" leading="" trailing=" " val=":"/>
                    <NullNode start="(154, 26)" end="(154, 38)">
                      <OtherNode start="(154, 26)" end="(154, 38)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(154, 26)" end="(154, 27)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(154, 28)" end="(154, 29)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(154, 30)" end="(154, 38)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(154, 30)" end="(154, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(154, 32)" end="(154, 33)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(154, 34)" end="(154, 38)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(154, 34)" end="(154, 38)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(154, 38)" end="(154, 39)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(154, 40)" end="(154, 47)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(154, 40)" end="(154, 41)" leading="" trailing="" val="("/>
                    <OtherNode start="(154, 41)" end="(154, 46)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(154, 41)" end="(154, 42)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(154, 41)" end="(154, 42)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(154, 43)" end="(154, 44)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(154, 45)" end="(154, 46)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(154, 45)" end="(154, 46)" leading="" trailing="" val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(154, 46)" end="(154, 47)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(154, 48)" end="(154, 55)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(154, 48)" end="(154, 49)" leading="" trailing="" val="("/>
                    <OtherNode start="(154, 49)" end="(154, 54)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(154, 49)" end="(154, 50)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(154, 49)" end="(154, 50)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(154, 51)" end="(154, 52)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(154, 53)" end="(154, 54)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(154, 53)" end="(154, 54)" leading="" trailing="" val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(154, 54)" end="(154, 55)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(154, 55)" end="(154, 56)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(155, 5)" end="(155, 24)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(155, 5)" end="(155, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(155, 6)" end="(155, 14)">
                <IdentNode start="(155, 6)" end="(155, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(155, 9)" end="(155, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                <IdentNode start="(155, 12)" end="(155, 14)" leading="" trailing=" " raw_val="l₃" val="l₃"/>
              </NullNode>
              <NullNode start="(155, 15)" end="(155, 23)">
                <AtomNode start="(155, 15)" end="(155, 16)" leading="" trailing=" " val=":"/>
                <OtherNode start="(155, 17)" end="(155, 23)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(155, 17)" end="(155, 21)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(155, 22)" end="(155, 23)">
                    <IdentNode start="(155, 22)" end="(155, 23)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(155, 23)" end="(155, 24)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(155, 25)" end="(155, 39)">
              <AtomNode start="(155, 25)" end="(155, 26)" leading="" trailing="" val="("/>
              <NullNode start="(155, 26)" end="(155, 28)">
                <IdentNode start="(155, 26)" end="(155, 28)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
              </NullNode>
              <NullNode start="(155, 29)" end="(155, 38)">
                <AtomNode start="(155, 29)" end="(155, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(155, 31)" end="(155, 38)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(155, 31)" end="(155, 33)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(155, 34)" end="(155, 35)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(155, 36)" end="(155, 38)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(155, 38)" end="(155, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(155, 40)" end="(155, 54)">
              <AtomNode start="(155, 40)" end="(155, 41)" leading="" trailing="" val="("/>
              <NullNode start="(155, 41)" end="(155, 43)">
                <IdentNode start="(155, 41)" end="(155, 43)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
              </NullNode>
              <NullNode start="(155, 44)" end="(155, 53)">
                <AtomNode start="(155, 44)" end="(155, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(155, 46)" end="(155, 53)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(155, 46)" end="(155, 48)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  <AtomNode start="(155, 49)" end="(155, 50)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(155, 51)" end="(155, 53)" leading="" trailing="" raw_val="l₃" val="l₃"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(155, 53)" end="(155, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(155, 55)" end="(155, 64)">
            <AtomNode start="(155, 55)" end="(155, 56)" leading="" trailing=" " val=":"/>
            <OtherNode start="(155, 57)" end="(155, 64)" kind="«term_&amp;lt;_»">
              <IdentNode start="(155, 57)" end="(155, 59)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              <AtomNode start="(155, 60)" end="(155, 61)" leading="" trailing=" " val="&amp;lt;"/>
              <IdentNode start="(155, 62)" end="(155, 64)" leading="" trailing=" " raw_val="l₃" val="l₃"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(155, 65)" end="(157, 54)">
          <AtomNode start="(155, 65)" end="(155, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(155, 68)" end="(157, 54)">
            <AtomNode start="(155, 68)" end="(155, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(156, 3)" end="(157, 54)">
              <TacticTacticseq1IndentedNode start="(156, 3)" end="(157, 54)">
                <NullNode start="(156, 3)" end="(157, 54)">
                  <OtherNode start="(156, 3)" end="(156, 41)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : LT α&#10;i₁ : Trans (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;l₁ l₂ l₃ : List α&#10;h₁ : l₁ &amp;lt; l₂&#10;h₂ : l₂ &amp;lt; l₃&#10;⊢ l₁ &amp;lt; l₃" state_after="α : Type u_1&#10;inst✝ : LT α&#10;i₁ : Trans (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;l₁ l₂ l₃ : List α&#10;h₁ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₁ l₂&#10;h₂ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₃&#10;⊢ Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₁ l₃" tactic="simp only [instLT, List.lt] at h₁ h₂ ⊢">
                    <AtomNode start="(156, 3)" end="(156, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(156, 8)" end="(156, 12)">
                      <AtomNode start="(156, 8)" end="(156, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(156, 13)" end="(156, 30)">
                      <AtomNode start="(156, 13)" end="(156, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(156, 14)" end="(156, 29)">
                        <OtherNode start="(156, 14)" end="(156, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(156, 14)" end="(156, 20)" leading="" trailing="" raw_val="instLT" val="instLT" full_name="List.instLT" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(156, 20)" end="(156, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(156, 22)" end="(156, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(156, 22)" end="(156, 29)" leading="" trailing="" raw_val="List.lt" val="List.lt" full_name="List.lt" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(156, 29)" end="(156, 30)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(156, 31)" end="(156, 41)">
                      <OtherNode start="(156, 31)" end="(156, 41)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(156, 31)" end="(156, 33)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(156, 34)" end="(156, 41)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(156, 34)" end="(156, 41)">
                            <IdentNode start="(156, 34)" end="(156, 36)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                            <IdentNode start="(156, 37)" end="(156, 39)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                            <OtherNode start="(156, 40)" end="(156, 41)" kind="Lean.Parser.Tactic.locationType">
                              <OtherNode start="(156, 40)" end="(156, 41)" kind="patternIgnore">
                                <OtherNode start="(156, 40)" end="(156, 41)" kind="token.«⊢»">
                                  <AtomNode start="(156, 40)" end="(156, 41)" leading="" trailing="&#10;  " val="⊢"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(157, 3)" end="(157, 54)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝ : LT α&#10;i₁ : Trans (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;l₁ l₂ l₃ : List α&#10;h₁ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₁ l₂&#10;h₂ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₂ l₃&#10;⊢ Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₁ l₃" state_after="no goals" tactic="exact lex_trans (fun h₁ h₂ =&amp;gt; i₁.trans h₁ h₂) h₁ h₂">
                    <AtomNode start="(157, 3)" end="(157, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(157, 9)" end="(157, 54)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(157, 9)" end="(157, 18)" leading="" trailing=" " raw_val="lex_trans" val="lex_trans" full_name="List.lex_trans" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(136, 9)" def_end="(136, 18)"/>
                      <NullNode start="(157, 19)" end="(157, 54)">
                        <OtherNode start="(157, 19)" end="(157, 48)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(157, 19)" end="(157, 20)" leading="" trailing="" val="("/>
                          <OtherNode start="(157, 20)" end="(157, 47)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(157, 20)" end="(157, 23)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(157, 24)" end="(157, 47)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(157, 24)" end="(157, 29)">
                                <IdentNode start="(157, 24)" end="(157, 26)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                <IdentNode start="(157, 27)" end="(157, 29)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(157, 30)" end="(157, 32)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(157, 33)" end="(157, 47)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(157, 33)" end="(157, 41)" leading="" trailing=" " raw_val="i₁.trans" val="i₁.trans"/>
                                <NullNode start="(157, 42)" end="(157, 47)">
                                  <IdentNode start="(157, 42)" end="(157, 44)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                  <IdentNode start="(157, 45)" end="(157, 47)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(157, 47)" end="(157, 48)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <IdentNode start="(157, 49)" end="(157, 51)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        <IdentNode start="(157, 52)" end="(157, 54)" leading="" trailing="&#10;&#10;" raw_val="h₂" val="h₂"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(159, 1)" end="(161, 37)">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandInstanceNode start="(159, 1)" end="(161, 37)">
        <TermAttrkindNode>
          <NullNode/>
        </TermAttrkindNode>
        <AtomNode start="(159, 1)" end="(159, 9)" leading="" trailing=" " val="instance"/>
        <NullNode/>
        <NullNode/>
        <CommandDeclsigNode start="(159, 10)" end="(160, 59)">
          <NullNode start="(159, 10)" end="(159, 63)">
            <OtherNode start="(159, 10)" end="(159, 16)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(159, 10)" end="(159, 11)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(159, 11)" end="(159, 15)" kind="Lean.Parser.Term.app">
                <IdentNode start="(159, 11)" end="(159, 13)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(159, 14)" end="(159, 15)">
                  <IdentNode start="(159, 14)" end="(159, 15)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(159, 15)" end="(159, 16)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(159, 17)" end="(159, 63)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(159, 17)" end="(159, 18)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(159, 18)" end="(159, 62)" kind="Lean.Parser.Term.app">
                <IdentNode start="(159, 18)" end="(159, 23)" leading="" trailing=" " raw_val="Trans" val="Trans" full_name="Trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(159, 24)" end="(159, 62)">
                  <OtherNode start="(159, 24)" end="(159, 46)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(159, 24)" end="(159, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(159, 25)" end="(159, 30)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(159, 25)" end="(159, 26)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(159, 25)" end="(159, 26)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(159, 27)" end="(159, 28)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(159, 29)" end="(159, 30)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(159, 29)" end="(159, 30)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(159, 31)" end="(159, 32)" leading="" trailing=" " val=":"/>
                    <NullNode start="(159, 33)" end="(159, 45)">
                      <OtherNode start="(159, 33)" end="(159, 45)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(159, 33)" end="(159, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(159, 35)" end="(159, 36)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(159, 37)" end="(159, 45)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(159, 37)" end="(159, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(159, 39)" end="(159, 40)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(159, 41)" end="(159, 45)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(159, 41)" end="(159, 45)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(159, 45)" end="(159, 46)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(159, 47)" end="(159, 54)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(159, 47)" end="(159, 48)" leading="" trailing="" val="("/>
                    <OtherNode start="(159, 48)" end="(159, 53)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(159, 48)" end="(159, 49)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(159, 48)" end="(159, 49)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(159, 50)" end="(159, 51)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(159, 52)" end="(159, 53)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(159, 52)" end="(159, 53)" leading="" trailing="" val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(159, 53)" end="(159, 54)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(159, 55)" end="(159, 62)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(159, 55)" end="(159, 56)" leading="" trailing="" val="("/>
                    <OtherNode start="(159, 56)" end="(159, 61)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(159, 56)" end="(159, 57)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(159, 56)" end="(159, 57)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(159, 58)" end="(159, 59)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(159, 60)" end="(159, 61)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(159, 60)" end="(159, 61)" leading="" trailing="" val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(159, 61)" end="(159, 62)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(159, 62)" end="(159, 63)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(159, 64)" end="(160, 59)">
            <AtomNode start="(159, 64)" end="(159, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(160, 5)" end="(160, 59)" kind="Lean.Parser.Term.app">
              <IdentNode start="(160, 5)" end="(160, 10)" leading="" trailing=" " raw_val="Trans" val="Trans" full_name="Trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode start="(160, 11)" end="(160, 59)">
                <OtherNode start="(160, 11)" end="(160, 43)" kind="Lean.Parser.Term.typeAscription">
                  <AtomNode start="(160, 11)" end="(160, 12)" leading="" trailing="" val="("/>
                  <OtherNode start="(160, 12)" end="(160, 17)" kind="«term_&amp;lt;_»">
                    <OtherNode start="(160, 12)" end="(160, 13)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(160, 12)" end="(160, 13)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                    <AtomNode start="(160, 14)" end="(160, 15)" leading="" trailing=" " val="&amp;lt;"/>
                    <OtherNode start="(160, 16)" end="(160, 17)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(160, 16)" end="(160, 17)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(160, 18)" end="(160, 19)" leading="" trailing=" " val=":"/>
                  <NullNode start="(160, 20)" end="(160, 42)">
                    <OtherNode start="(160, 20)" end="(160, 42)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(160, 20)" end="(160, 26)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(160, 20)" end="(160, 24)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(160, 25)" end="(160, 26)">
                          <IdentNode start="(160, 25)" end="(160, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(160, 27)" end="(160, 28)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(160, 29)" end="(160, 42)" kind="Lean.Parser.Term.arrow">
                        <OtherNode start="(160, 29)" end="(160, 35)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(160, 29)" end="(160, 33)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(160, 34)" end="(160, 35)">
                            <IdentNode start="(160, 34)" end="(160, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(160, 36)" end="(160, 37)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(160, 38)" end="(160, 42)" kind="Lean.Parser.Term.prop">
                          <AtomNode start="(160, 38)" end="(160, 42)" leading="" trailing="" val="Prop"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(160, 42)" end="(160, 43)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <OtherNode start="(160, 44)" end="(160, 51)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(160, 44)" end="(160, 45)" leading="" trailing="" val="("/>
                  <OtherNode start="(160, 45)" end="(160, 50)" kind="«term_&amp;lt;_»">
                    <OtherNode start="(160, 45)" end="(160, 46)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(160, 45)" end="(160, 46)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                    <AtomNode start="(160, 47)" end="(160, 48)" leading="" trailing=" " val="&amp;lt;"/>
                    <OtherNode start="(160, 49)" end="(160, 50)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(160, 49)" end="(160, 50)" leading="" trailing="" val="·"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(160, 50)" end="(160, 51)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <OtherNode start="(160, 52)" end="(160, 59)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(160, 52)" end="(160, 53)" leading="" trailing="" val="("/>
                  <OtherNode start="(160, 53)" end="(160, 58)" kind="«term_&amp;lt;_»">
                    <OtherNode start="(160, 53)" end="(160, 54)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(160, 53)" end="(160, 54)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                    <AtomNode start="(160, 55)" end="(160, 56)" leading="" trailing=" " val="&amp;lt;"/>
                    <OtherNode start="(160, 57)" end="(160, 58)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(160, 57)" end="(160, 58)" leading="" trailing="" val="·"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(160, 58)" end="(160, 59)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandWherestructinstNode start="(160, 60)" end="(161, 37)">
          <AtomNode start="(160, 60)" end="(160, 65)" leading="" trailing="&#10;  " val="where"/>
          <OtherNode start="(161, 3)" end="(161, 37)" kind="Lean.Parser.Term.structInstFields">
            <NullNode start="(161, 3)" end="(161, 37)">
              <OtherNode start="(161, 3)" end="(161, 37)" kind="Lean.Parser.Term.structInstField">
                <OtherNode start="(161, 3)" end="(161, 8)" kind="Lean.Parser.Term.structInstLVal">
                  <IdentNode start="(161, 3)" end="(161, 8)" leading="" trailing=" " raw_val="trans" val="trans"/>
                  <NullNode/>
                </OtherNode>
                <NullNode start="(161, 9)" end="(161, 37)">
                  <NullNode start="(161, 9)" end="(161, 14)">
                    <IdentNode start="(161, 9)" end="(161, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                    <IdentNode start="(161, 12)" end="(161, 14)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                  </NullNode>
                  <NullNode/>
                  <OtherNode start="(161, 15)" end="(161, 37)" kind="Lean.Parser.Term.structInstFieldDef">
                    <AtomNode start="(161, 15)" end="(161, 17)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(161, 18)" end="(161, 37)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(161, 18)" end="(161, 31)" leading="" trailing=" " raw_val="List.lt_trans" val="List.lt_trans" full_name="List.lt_trans" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(153, 19)" def_end="(153, 27)"/>
                      <NullNode start="(161, 32)" end="(161, 37)">
                        <IdentNode start="(161, 32)" end="(161, 34)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        <IdentNode start="(161, 35)" end="(161, 37)" leading="" trailing="&#10;&#10;" raw_val="h₂" val="h₂"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <NullNode/>
        </CommandWherestructinstNode>
      </CommandInstanceNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(163, 1)" end="(164, 50)" name="lt_antisymm" full_name="List.lt_antisymm">
      <CommandDeclmodifiersNode start="(163, 1)" end="(164, 10)">
        <NullNode/>
        <NullNode start="(163, 1)" end="(163, 55)">
          <OtherNode start="(163, 1)" end="(163, 55)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(163, 1)" end="(163, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(163, 3)" end="(163, 54)">
              <OtherNode start="(163, 3)" end="(163, 54)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(163, 3)" end="(163, 54)" kind="Lean.deprecated">
                  <AtomNode start="(163, 3)" end="(163, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(163, 14)" end="(163, 30)">
                    <IdentNode start="(163, 14)" end="(163, 30)" leading="" trailing=" " raw_val="List.le_antisymm" val="List.le_antisymm" full_name="List.le_antisymm" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(163, 31)" end="(163, 54)">
                    <AtomNode start="(163, 31)" end="(163, 32)" leading="" trailing="" val="("/>
                    <AtomNode start="(163, 32)" end="(163, 37)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(163, 38)" end="(163, 40)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(163, 41)" end="(163, 53)" kind="str">
                      <AtomNode start="(163, 41)" end="(163, 53)" leading="" trailing="" val="&amp;quot;2024-12-13&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(163, 53)" end="(163, 54)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(163, 54)" end="(163, 55)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode start="(164, 1)" end="(164, 10)">
          <OtherNode start="(164, 1)" end="(164, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(164, 1)" end="(164, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(164, 11)" end="(164, 50)" name="lt_antisymm">
        <AtomNode start="(164, 11)" end="(164, 17)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(164, 18)" end="(164, 29)">
          <IdentNode start="(164, 18)" end="(164, 29)" leading="" trailing=" " raw_val="lt_antisymm" val="lt_antisymm"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(164, 30)" end="(164, 50)">
          <AtomNode start="(164, 30)" end="(164, 32)" leading="" trailing=" " val=":="/>
          <OtherNode start="(164, 33)" end="(164, 50)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(164, 33)" end="(164, 34)" leading="" trailing="" val="@"/>
            <IdentNode start="(164, 34)" end="(164, 50)" leading="" trailing="&#10;&#10;" raw_val="List.le_antisymm" val="List.le_antisymm" full_name="List.le_antisymm" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(166, 1)" end="(194, 87)" name="lt_of_le_of_lt" full_name="List.lt_of_le_of_lt">
      <CommandDeclmodifiersNode start="(166, 1)" end="(166, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(166, 1)" end="(166, 10)">
          <OtherNode start="(166, 1)" end="(166, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(166, 1)" end="(166, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(166, 11)" end="(194, 87)" name="lt_of_le_of_lt" full_name="List.lt_of_le_of_lt" _is_private_decl="False">
        <AtomNode start="(166, 11)" end="(166, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(166, 19)" end="(166, 33)">
          <IdentNode start="(166, 19)" end="(166, 33)" leading="" trailing=" " raw_val="lt_of_le_of_lt" val="lt_of_le_of_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(166, 34)" end="(171, 64)">
          <NullNode start="(166, 34)" end="(171, 54)">
            <OtherNode start="(166, 34)" end="(166, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(166, 34)" end="(166, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(166, 35)" end="(166, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(166, 35)" end="(166, 46)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(166, 47)" end="(166, 48)">
                  <IdentNode start="(166, 47)" end="(166, 48)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(166, 48)" end="(166, 49)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(166, 50)" end="(166, 56)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(166, 50)" end="(166, 51)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(166, 51)" end="(166, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(166, 51)" end="(166, 53)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(166, 54)" end="(166, 55)">
                  <IdentNode start="(166, 54)" end="(166, 55)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(166, 55)" end="(166, 56)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(166, 57)" end="(166, 72)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(166, 57)" end="(166, 58)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(166, 58)" end="(166, 71)" kind="Lean.Parser.Term.app">
                <IdentNode start="(166, 58)" end="(166, 69)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(166, 70)" end="(166, 71)">
                  <IdentNode start="(166, 70)" end="(166, 71)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(166, 71)" end="(166, 72)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(167, 5)" end="(167, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(167, 5)" end="(167, 6)" leading="" trailing="" val="["/>
              <NullNode start="(167, 6)" end="(167, 10)">
                <IdentNode start="(167, 6)" end="(167, 8)" leading="" trailing=" " raw_val="i₀" val="i₀"/>
                <AtomNode start="(167, 9)" end="(167, 10)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(167, 11)" end="(167, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(167, 11)" end="(167, 21)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(167, 22)" end="(167, 44)">
                  <OtherNode start="(167, 22)" end="(167, 44)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(167, 22)" end="(167, 23)" leading="" trailing="" val="("/>
                    <OtherNode start="(167, 23)" end="(167, 28)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(167, 23)" end="(167, 24)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(167, 23)" end="(167, 24)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(167, 25)" end="(167, 26)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(167, 27)" end="(167, 28)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(167, 27)" end="(167, 28)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(167, 29)" end="(167, 30)" leading="" trailing=" " val=":"/>
                    <NullNode start="(167, 31)" end="(167, 43)">
                      <OtherNode start="(167, 31)" end="(167, 43)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(167, 31)" end="(167, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(167, 33)" end="(167, 34)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(167, 35)" end="(167, 43)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(167, 35)" end="(167, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(167, 37)" end="(167, 38)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(167, 39)" end="(167, 43)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(167, 39)" end="(167, 43)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(167, 43)" end="(167, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(167, 44)" end="(167, 45)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(168, 5)" end="(168, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(168, 5)" end="(168, 6)" leading="" trailing="" val="["/>
              <NullNode start="(168, 6)" end="(168, 10)">
                <IdentNode start="(168, 6)" end="(168, 8)" leading="" trailing=" " raw_val="i₁" val="i₁"/>
                <AtomNode start="(168, 9)" end="(168, 10)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(168, 11)" end="(168, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(168, 11)" end="(168, 20)" leading="" trailing=" " raw_val="Std.Asymm" val="Std.Asymm" full_name="Std.Asymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(168, 21)" end="(168, 43)">
                  <OtherNode start="(168, 21)" end="(168, 43)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(168, 21)" end="(168, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(168, 22)" end="(168, 27)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(168, 22)" end="(168, 23)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(168, 22)" end="(168, 23)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(168, 24)" end="(168, 25)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(168, 26)" end="(168, 27)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(168, 26)" end="(168, 27)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(168, 28)" end="(168, 29)" leading="" trailing=" " val=":"/>
                    <NullNode start="(168, 30)" end="(168, 42)">
                      <OtherNode start="(168, 30)" end="(168, 42)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(168, 30)" end="(168, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(168, 32)" end="(168, 33)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(168, 34)" end="(168, 42)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(168, 34)" end="(168, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(168, 36)" end="(168, 37)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(168, 38)" end="(168, 42)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(168, 38)" end="(168, 42)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(168, 42)" end="(168, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(168, 43)" end="(168, 44)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(169, 5)" end="(169, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(169, 5)" end="(169, 6)" leading="" trailing="" val="["/>
              <NullNode start="(169, 6)" end="(169, 10)">
                <IdentNode start="(169, 6)" end="(169, 8)" leading="" trailing=" " raw_val="i₂" val="i₂"/>
                <AtomNode start="(169, 9)" end="(169, 10)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(169, 11)" end="(169, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(169, 11)" end="(169, 23)" leading="" trailing=" " raw_val="Std.Antisymm" val="Std.Antisymm" full_name="Std.Antisymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(169, 24)" end="(169, 48)">
                  <OtherNode start="(169, 24)" end="(169, 48)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(169, 24)" end="(169, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(169, 25)" end="(169, 32)" kind="«term¬_»">
                      <AtomNode start="(169, 25)" end="(169, 26)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(169, 27)" end="(169, 32)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(169, 27)" end="(169, 28)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(169, 27)" end="(169, 28)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(169, 29)" end="(169, 30)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(169, 31)" end="(169, 32)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(169, 31)" end="(169, 32)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(169, 33)" end="(169, 34)" leading="" trailing=" " val=":"/>
                    <NullNode start="(169, 35)" end="(169, 47)">
                      <OtherNode start="(169, 35)" end="(169, 47)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(169, 35)" end="(169, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(169, 37)" end="(169, 38)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(169, 39)" end="(169, 47)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(169, 39)" end="(169, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(169, 41)" end="(169, 42)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(169, 43)" end="(169, 47)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(169, 43)" end="(169, 47)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(169, 47)" end="(169, 48)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(169, 48)" end="(169, 49)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(170, 5)" end="(170, 62)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(170, 5)" end="(170, 6)" leading="" trailing="" val="["/>
              <NullNode start="(170, 6)" end="(170, 10)">
                <IdentNode start="(170, 6)" end="(170, 8)" leading="" trailing=" " raw_val="i₃" val="i₃"/>
                <AtomNode start="(170, 9)" end="(170, 10)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(170, 11)" end="(170, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(170, 11)" end="(170, 16)" leading="" trailing=" " raw_val="Trans" val="Trans" full_name="Trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(170, 17)" end="(170, 61)">
                  <OtherNode start="(170, 17)" end="(170, 41)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(170, 17)" end="(170, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(170, 18)" end="(170, 25)" kind="«term¬_»">
                      <AtomNode start="(170, 18)" end="(170, 19)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(170, 20)" end="(170, 25)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(170, 20)" end="(170, 21)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(170, 20)" end="(170, 21)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(170, 22)" end="(170, 23)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(170, 24)" end="(170, 25)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(170, 24)" end="(170, 25)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(170, 26)" end="(170, 27)" leading="" trailing=" " val=":"/>
                    <NullNode start="(170, 28)" end="(170, 40)">
                      <OtherNode start="(170, 28)" end="(170, 40)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(170, 28)" end="(170, 29)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(170, 30)" end="(170, 31)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(170, 32)" end="(170, 40)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(170, 32)" end="(170, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(170, 34)" end="(170, 35)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(170, 36)" end="(170, 40)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(170, 36)" end="(170, 40)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(170, 40)" end="(170, 41)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(170, 42)" end="(170, 51)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(170, 42)" end="(170, 43)" leading="" trailing="" val="("/>
                    <OtherNode start="(170, 43)" end="(170, 50)" kind="«term¬_»">
                      <AtomNode start="(170, 43)" end="(170, 44)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(170, 45)" end="(170, 50)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(170, 45)" end="(170, 46)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(170, 45)" end="(170, 46)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(170, 47)" end="(170, 48)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(170, 49)" end="(170, 50)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(170, 49)" end="(170, 50)" leading="" trailing="" val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(170, 50)" end="(170, 51)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(170, 52)" end="(170, 61)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(170, 52)" end="(170, 53)" leading="" trailing="" val="("/>
                    <OtherNode start="(170, 53)" end="(170, 60)" kind="«term¬_»">
                      <AtomNode start="(170, 53)" end="(170, 54)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(170, 55)" end="(170, 60)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(170, 55)" end="(170, 56)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(170, 55)" end="(170, 56)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(170, 57)" end="(170, 58)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(170, 59)" end="(170, 60)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(170, 59)" end="(170, 60)" leading="" trailing="" val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(170, 60)" end="(170, 61)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(170, 61)" end="(170, 62)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(171, 5)" end="(171, 24)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(171, 5)" end="(171, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(171, 6)" end="(171, 14)">
                <IdentNode start="(171, 6)" end="(171, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(171, 9)" end="(171, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                <IdentNode start="(171, 12)" end="(171, 14)" leading="" trailing=" " raw_val="l₃" val="l₃"/>
              </NullNode>
              <NullNode start="(171, 15)" end="(171, 23)">
                <AtomNode start="(171, 15)" end="(171, 16)" leading="" trailing=" " val=":"/>
                <OtherNode start="(171, 17)" end="(171, 23)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(171, 17)" end="(171, 21)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(171, 22)" end="(171, 23)">
                    <IdentNode start="(171, 22)" end="(171, 23)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(171, 23)" end="(171, 24)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(171, 25)" end="(171, 39)">
              <AtomNode start="(171, 25)" end="(171, 26)" leading="" trailing="" val="("/>
              <NullNode start="(171, 26)" end="(171, 28)">
                <IdentNode start="(171, 26)" end="(171, 28)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
              </NullNode>
              <NullNode start="(171, 29)" end="(171, 38)">
                <AtomNode start="(171, 29)" end="(171, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(171, 31)" end="(171, 38)" kind="«term_≤_»">
                  <IdentNode start="(171, 31)" end="(171, 33)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(171, 34)" end="(171, 35)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(171, 36)" end="(171, 38)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(171, 38)" end="(171, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(171, 40)" end="(171, 54)">
              <AtomNode start="(171, 40)" end="(171, 41)" leading="" trailing="" val="("/>
              <NullNode start="(171, 41)" end="(171, 43)">
                <IdentNode start="(171, 41)" end="(171, 43)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
              </NullNode>
              <NullNode start="(171, 44)" end="(171, 53)">
                <AtomNode start="(171, 44)" end="(171, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(171, 46)" end="(171, 53)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(171, 46)" end="(171, 48)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  <AtomNode start="(171, 49)" end="(171, 50)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(171, 51)" end="(171, 53)" leading="" trailing="" raw_val="l₃" val="l₃"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(171, 53)" end="(171, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(171, 55)" end="(171, 64)">
            <AtomNode start="(171, 55)" end="(171, 56)" leading="" trailing=" " val=":"/>
            <OtherNode start="(171, 57)" end="(171, 64)" kind="«term_&amp;lt;_»">
              <IdentNode start="(171, 57)" end="(171, 59)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              <AtomNode start="(171, 60)" end="(171, 61)" leading="" trailing=" " val="&amp;lt;"/>
              <IdentNode start="(171, 62)" end="(171, 64)" leading="" trailing=" " raw_val="l₃" val="l₃"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(171, 65)" end="(194, 87)">
          <AtomNode start="(171, 65)" end="(171, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(171, 68)" end="(194, 87)">
            <AtomNode start="(171, 68)" end="(171, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(172, 3)" end="(194, 87)">
              <TacticTacticseq1IndentedNode start="(172, 3)" end="(194, 87)">
                <NullNode start="(172, 3)" end="(194, 87)">
                  <OtherNode start="(172, 3)" end="(194, 87)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ l₃ : List α&#10;h₁ : l₁ ≤ l₂&#10;h₂ : l₂ &amp;lt; l₃&#10;⊢ l₁ &amp;lt; l₃" state_after="no goals" tactic="induction h₂ generalizing l₁ with&#10;| nil =&amp;gt; simp_all&#10;| rel hab =&amp;gt;&#10;  rename_i a xs&#10;  cases l₁ with&#10;  | nil =&amp;gt; simp_all&#10;  | cons c l₁ =&amp;gt;&#10;    apply Lex.rel&#10;    replace h₁ := not_lt_of_cons_le_cons h₁&#10;    apply Decidable.byContradiction&#10;    intro h₂&#10;    have := i₃.trans h₁ h₂&#10;    contradiction&#10;| cons w₃ ih =&amp;gt;&#10;  rename_i a as bs&#10;  cases l₁ with&#10;  | nil =&amp;gt; simp_all&#10;  | cons c l₁ =&amp;gt;&#10;    have w₄ := not_lt_of_cons_le_cons h₁&#10;    by_cases w₅ : a = c&#10;    · subst w₅&#10;      exact Lex.cons (ih (le_of_cons_le_cons h₁))&#10;    · exact Lex.rel (Decidable.byContradiction fun w₆ =&amp;gt; w₅ (i₂.antisymm _ _ w₄ w₆))">
                    <AtomNode start="(172, 3)" end="(172, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(172, 13)" end="(172, 15)">
                      <OtherNode start="(172, 13)" end="(172, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(172, 13)" end="(172, 15)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(172, 16)" end="(172, 31)">
                      <AtomNode start="(172, 16)" end="(172, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(172, 29)" end="(172, 31)">
                        <IdentNode start="(172, 29)" end="(172, 31)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(172, 32)" end="(194, 87)">
                      <OtherNode start="(172, 32)" end="(194, 87)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(172, 32)" end="(172, 36)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(173, 3)" end="(194, 87)">
                          <OtherNode start="(173, 3)" end="(173, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(173, 3)" end="(173, 8)">
                              <OtherNode start="(173, 3)" end="(173, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(173, 3)" end="(173, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(173, 5)" end="(173, 8)">
                                  <NullNode/>
                                  <IdentNode start="(173, 5)" end="(173, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.Lex.nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(173, 9)" end="(173, 20)">
                              <AtomNode start="(173, 9)" end="(173, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(173, 12)" end="(173, 20)">
                                <TacticTacticseq1IndentedNode start="(173, 12)" end="(173, 20)">
                                  <NullNode start="(173, 12)" end="(173, 20)">
                                    <OtherNode start="(173, 12)" end="(173, 20)" kind="Lean.Parser.Tactic.simpAll" state_before="case nil&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a✝ : α&#10;l✝ l₁ : List α&#10;h₁ : l₁ ≤ []&#10;⊢ l₁ &amp;lt; a✝ :: l✝" state_after="no goals" tactic="simp_all">
                                      <AtomNode start="(173, 12)" end="(173, 20)" leading="" trailing="&#10;  " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(174, 3)" end="(184, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(174, 3)" end="(174, 12)">
                              <OtherNode start="(174, 3)" end="(174, 12)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(174, 3)" end="(174, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(174, 5)" end="(174, 8)">
                                  <NullNode/>
                                  <IdentNode start="(174, 5)" end="(174, 8)" leading="" trailing=" " raw_val="rel" val="rel" full_name="List.Lex.rel" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </GroupNode>
                                <NullNode start="(174, 9)" end="(174, 12)">
                                  <IdentNode start="(174, 9)" end="(174, 12)" leading="" trailing=" " raw_val="hab" val="hab"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(174, 13)" end="(184, 20)">
                              <AtomNode start="(174, 13)" end="(174, 15)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(175, 5)" end="(184, 20)">
                                <TacticTacticseq1IndentedNode start="(175, 5)" end="(184, 20)">
                                  <NullNode start="(175, 5)" end="(184, 20)">
                                    <OtherNode start="(175, 5)" end="(175, 18)" kind="Lean.Parser.Tactic.renameI" state_before="case rel&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a₂✝ : α&#10;l₂✝ : List α&#10;hab : a₁✝ &amp;lt; a₂✝&#10;l₁ : List α&#10;h₁ : l₁ ≤ a₁✝ :: l₁✝&#10;⊢ l₁ &amp;lt; a₂✝ :: l₂✝" state_after="case rel&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a : α&#10;xs : List α&#10;hab : a₁✝ &amp;lt; a&#10;l₁ : List α&#10;h₁ : l₁ ≤ a₁✝ :: l₁✝&#10;⊢ l₁ &amp;lt; a :: xs" tactic="rename_i a xs">
                                      <AtomNode start="(175, 5)" end="(175, 13)" leading="" trailing=" " val="rename_i"/>
                                      <NullNode start="(175, 14)" end="(175, 18)">
                                        <LeanBinderidentNode start="(175, 14)" end="(175, 15)">
                                          <IdentNode start="(175, 14)" end="(175, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(175, 16)" end="(175, 18)">
                                          <IdentNode start="(175, 16)" end="(175, 18)" leading="" trailing="&#10;    " raw_val="xs" val="xs"/>
                                        </LeanBinderidentNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(176, 5)" end="(184, 20)" kind="Lean.Parser.Tactic.cases" state_before="case rel&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a : α&#10;xs : List α&#10;hab : a₁✝ &amp;lt; a&#10;l₁ : List α&#10;h₁ : l₁ ≤ a₁✝ :: l₁✝&#10;⊢ l₁ &amp;lt; a :: xs" state_after="no goals" tactic="cases l₁ with&#10;| nil =&amp;gt; simp_all&#10;| cons c l₁ =&amp;gt;&#10;  apply Lex.rel&#10;  replace h₁ := not_lt_of_cons_le_cons h₁&#10;  apply Decidable.byContradiction&#10;  intro h₂&#10;  have := i₃.trans h₁ h₂&#10;  contradiction">
                                      <AtomNode start="(176, 5)" end="(176, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(176, 11)" end="(176, 13)">
                                        <OtherNode start="(176, 11)" end="(176, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(176, 11)" end="(176, 13)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(176, 14)" end="(184, 20)">
                                        <OtherNode start="(176, 14)" end="(184, 20)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(176, 14)" end="(176, 18)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(177, 5)" end="(184, 20)">
                                            <OtherNode start="(177, 5)" end="(177, 22)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(177, 5)" end="(177, 10)">
                                                <OtherNode start="(177, 5)" end="(177, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(177, 5)" end="(177, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(177, 7)" end="(177, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(177, 7)" end="(177, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(177, 11)" end="(177, 22)">
                                                <AtomNode start="(177, 11)" end="(177, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(177, 14)" end="(177, 22)">
                                                  <TacticTacticseq1IndentedNode start="(177, 14)" end="(177, 22)">
                                                    <NullNode start="(177, 14)" end="(177, 22)">
                                                      <OtherNode start="(177, 14)" end="(177, 22)" kind="Lean.Parser.Tactic.simpAll" state_before="case rel.nil&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a : α&#10;xs : List α&#10;hab : a₁✝ &amp;lt; a&#10;h₁ : [] ≤ a₁✝ :: l₁✝&#10;⊢ [] &amp;lt; a :: xs" state_after="no goals" tactic="simp_all">
                                                        <AtomNode start="(177, 14)" end="(177, 22)" leading="" trailing="&#10;    " val="simp_all"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(178, 5)" end="(184, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(178, 5)" end="(178, 16)">
                                                <OtherNode start="(178, 5)" end="(178, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(178, 5)" end="(178, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(178, 7)" end="(178, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(178, 7)" end="(178, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(178, 12)" end="(178, 16)">
                                                    <IdentNode start="(178, 12)" end="(178, 13)" leading="" trailing=" " raw_val="c" val="c"/>
                                                    <IdentNode start="(178, 14)" end="(178, 16)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(178, 17)" end="(184, 20)">
                                                <AtomNode start="(178, 17)" end="(178, 19)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(179, 7)" end="(184, 20)">
                                                  <TacticTacticseq1IndentedNode start="(179, 7)" end="(184, 20)">
                                                    <NullNode start="(179, 7)" end="(184, 20)">
                                                      <OtherNode start="(179, 7)" end="(179, 20)" kind="Lean.Parser.Tactic.apply" state_before="case rel.cons&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a : α&#10;xs : List α&#10;hab : a₁✝ &amp;lt; a&#10;c : α&#10;l₁ : List α&#10;h₁ : c :: l₁ ≤ a₁✝ :: l₁✝&#10;⊢ c :: l₁ &amp;lt; a :: xs" state_after="case rel.cons.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a : α&#10;xs : List α&#10;hab : a₁✝ &amp;lt; a&#10;c : α&#10;l₁ : List α&#10;h₁ : c :: l₁ ≤ a₁✝ :: l₁✝&#10;⊢ c &amp;lt; a" tactic="apply Lex.rel">
                                                        <AtomNode start="(179, 7)" end="(179, 12)" leading="" trailing=" " val="apply"/>
                                                        <IdentNode start="(179, 13)" end="(179, 20)" leading="" trailing="&#10;      " raw_val="Lex.rel" val="Lex.rel" full_name="List.Lex.rel" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(180, 7)" end="(180, 46)" kind="Lean.Parser.Tactic.replace" state_before="case rel.cons.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a : α&#10;xs : List α&#10;hab : a₁✝ &amp;lt; a&#10;c : α&#10;l₁ : List α&#10;h₁ : c :: l₁ ≤ a₁✝ :: l₁✝&#10;⊢ c &amp;lt; a" state_after="case rel.cons.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a : α&#10;xs : List α&#10;hab : a₁✝ &amp;lt; a&#10;c : α&#10;l₁ : List α&#10;h₁ : ¬a₁✝ &amp;lt; c&#10;⊢ c &amp;lt; a" tactic="replace h₁ := not_lt_of_cons_le_cons h₁">
                                                        <AtomNode start="(180, 7)" end="(180, 14)" leading="" trailing=" " val="replace"/>
                                                        <OtherNode start="(180, 15)" end="(180, 46)" kind="Lean.Parser.Term.haveDecl">
                                                          <OtherNode start="(180, 15)" end="(180, 46)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(180, 15)" end="(180, 17)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(180, 15)" end="(180, 17)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(180, 18)" end="(180, 20)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(180, 21)" end="(180, 46)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(180, 21)" end="(180, 43)" leading="" trailing=" " raw_val="not_lt_of_cons_le_cons" val="not_lt_of_cons_le_cons" full_name="List.not_lt_of_cons_le_cons" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(105, 9)" def_end="(105, 31)"/>
                                                            <NullNode start="(180, 44)" end="(180, 46)">
                                                            <IdentNode start="(180, 44)" end="(180, 46)" leading="" trailing="&#10;      " raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(181, 7)" end="(181, 38)" kind="Lean.Parser.Tactic.apply" state_before="case rel.cons.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a : α&#10;xs : List α&#10;hab : a₁✝ &amp;lt; a&#10;c : α&#10;l₁ : List α&#10;h₁ : ¬a₁✝ &amp;lt; c&#10;⊢ c &amp;lt; a" state_after="case rel.cons.h.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a : α&#10;xs : List α&#10;hab : a₁✝ &amp;lt; a&#10;c : α&#10;l₁ : List α&#10;h₁ : ¬a₁✝ &amp;lt; c&#10;⊢ ¬c &amp;lt; a → False" tactic="apply Decidable.byContradiction">
                                                        <AtomNode start="(181, 7)" end="(181, 12)" leading="" trailing=" " val="apply"/>
                                                        <IdentNode start="(181, 13)" end="(181, 38)" leading="" trailing="&#10;      " raw_val="Decidable.byContradiction" val="Decidable.byContradiction" full_name="Decidable.byContradiction" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(182, 7)" end="(182, 15)" kind="Lean.Parser.Tactic.intro" state_before="case rel.cons.h.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a : α&#10;xs : List α&#10;hab : a₁✝ &amp;lt; a&#10;c : α&#10;l₁ : List α&#10;h₁ : ¬a₁✝ &amp;lt; c&#10;⊢ ¬c &amp;lt; a → False" state_after="case rel.cons.h.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a : α&#10;xs : List α&#10;hab : a₁✝ &amp;lt; a&#10;c : α&#10;l₁ : List α&#10;h₁ : ¬a₁✝ &amp;lt; c&#10;h₂ : ¬c &amp;lt; a&#10;⊢ False" tactic="intro h₂">
                                                        <AtomNode start="(182, 7)" end="(182, 12)" leading="" trailing=" " val="intro"/>
                                                        <NullNode start="(182, 13)" end="(182, 15)">
                                                          <IdentNode start="(182, 13)" end="(182, 15)" leading="" trailing="&#10;      " raw_val="h₂" val="h₂"/>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(183, 7)" end="(183, 29)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case rel.cons.h.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a : α&#10;xs : List α&#10;hab : a₁✝ &amp;lt; a&#10;c : α&#10;l₁ : List α&#10;h₁ : ¬a₁✝ &amp;lt; c&#10;h₂ : ¬c &amp;lt; a&#10;⊢ False" state_after="case rel.cons.h.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a : α&#10;xs : List α&#10;hab : a₁✝ &amp;lt; a&#10;c : α&#10;l₁ : List α&#10;h₁ : ¬a₁✝ &amp;lt; c&#10;h₂ : ¬c &amp;lt; a&#10;this : ¬a₁✝ &amp;lt; a&#10;⊢ False" tactic="have := i₃.trans h₁ h₂">
                                                        <AtomNode start="(183, 7)" end="(183, 11)" leading="" trailing=" " val="have"/>
                                                        <OtherNode start="(183, 12)" end="(183, 29)" kind="Lean.Parser.Term.haveDecl">
                                                          <OtherNode start="(183, 12)" end="(183, 29)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(183, 12)" end="(183, 12)" kind="Lean.Parser.Term.haveId">
                                                            <OtherNode start="(183, 12)" end="(183, 12)" kind="hygieneInfo">
                                                            <IdentNode start="(183, 12)" end="(183, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(183, 12)" end="(183, 14)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(183, 15)" end="(183, 29)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(183, 15)" end="(183, 23)" leading="" trailing=" " raw_val="i₃.trans" val="i₃.trans"/>
                                                            <NullNode start="(183, 24)" end="(183, 29)">
                                                            <IdentNode start="(183, 24)" end="(183, 26)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                                            <IdentNode start="(183, 27)" end="(183, 29)" leading="" trailing="&#10;      " raw_val="h₂" val="h₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(184, 7)" end="(184, 20)" kind="Lean.Parser.Tactic.contradiction" state_before="case rel.cons.h.h&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a₁✝ : α&#10;l₁✝ : List α&#10;a : α&#10;xs : List α&#10;hab : a₁✝ &amp;lt; a&#10;c : α&#10;l₁ : List α&#10;h₁ : ¬a₁✝ &amp;lt; c&#10;h₂ : ¬c &amp;lt; a&#10;this : ¬a₁✝ &amp;lt; a&#10;⊢ False" state_after="no goals" tactic="contradiction">
                                                        <AtomNode start="(184, 7)" end="(184, 20)" leading="" trailing="&#10;  " val="contradiction"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(185, 3)" end="(194, 87)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(185, 3)" end="(185, 15)">
                              <OtherNode start="(185, 3)" end="(185, 15)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(185, 3)" end="(185, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(185, 5)" end="(185, 9)">
                                  <NullNode/>
                                  <IdentNode start="(185, 5)" end="(185, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.Lex.cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </GroupNode>
                                <NullNode start="(185, 10)" end="(185, 15)">
                                  <IdentNode start="(185, 10)" end="(185, 12)" leading="" trailing=" " raw_val="w₃" val="w₃"/>
                                  <IdentNode start="(185, 13)" end="(185, 15)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(185, 16)" end="(194, 87)">
                              <AtomNode start="(185, 16)" end="(185, 18)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(186, 5)" end="(194, 87)">
                                <TacticTacticseq1IndentedNode start="(186, 5)" end="(194, 87)">
                                  <NullNode start="(186, 5)" end="(194, 87)">
                                    <OtherNode start="(186, 5)" end="(186, 21)" kind="Lean.Parser.Tactic.renameI" state_before="case cons&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a✝ : α&#10;l₁✝ l₂✝ : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₁✝ l₂✝&#10;ih : ∀ {l₁ : List α}, l₁ ≤ l₁✝ → l₁ &amp;lt; l₂✝&#10;l₁ : List α&#10;h₁ : l₁ ≤ a✝ :: l₁✝&#10;⊢ l₁ &amp;lt; a✝ :: l₂✝" state_after="case cons&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;l₁ : List α&#10;h₁ : l₁ ≤ a :: as&#10;⊢ l₁ &amp;lt; a :: bs" tactic="rename_i a as bs">
                                      <AtomNode start="(186, 5)" end="(186, 13)" leading="" trailing=" " val="rename_i"/>
                                      <NullNode start="(186, 14)" end="(186, 21)">
                                        <LeanBinderidentNode start="(186, 14)" end="(186, 15)">
                                          <IdentNode start="(186, 14)" end="(186, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(186, 16)" end="(186, 18)">
                                          <IdentNode start="(186, 16)" end="(186, 18)" leading="" trailing=" " raw_val="as" val="as"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(186, 19)" end="(186, 21)">
                                          <IdentNode start="(186, 19)" end="(186, 21)" leading="" trailing="&#10;    " raw_val="bs" val="bs"/>
                                        </LeanBinderidentNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(187, 5)" end="(194, 87)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;l₁ : List α&#10;h₁ : l₁ ≤ a :: as&#10;⊢ l₁ &amp;lt; a :: bs" state_after="no goals" tactic="cases l₁ with&#10;| nil =&amp;gt; simp_all&#10;| cons c l₁ =&amp;gt;&#10;  have w₄ := not_lt_of_cons_le_cons h₁&#10;  by_cases w₅ : a = c&#10;  · subst w₅&#10;    exact Lex.cons (ih (le_of_cons_le_cons h₁))&#10;  · exact Lex.rel (Decidable.byContradiction fun w₆ =&amp;gt; w₅ (i₂.antisymm _ _ w₄ w₆))">
                                      <AtomNode start="(187, 5)" end="(187, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(187, 11)" end="(187, 13)">
                                        <OtherNode start="(187, 11)" end="(187, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(187, 11)" end="(187, 13)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(187, 14)" end="(194, 87)">
                                        <OtherNode start="(187, 14)" end="(194, 87)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(187, 14)" end="(187, 18)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(188, 5)" end="(194, 87)">
                                            <OtherNode start="(188, 5)" end="(188, 22)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(188, 5)" end="(188, 10)">
                                                <OtherNode start="(188, 5)" end="(188, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(188, 5)" end="(188, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(188, 7)" end="(188, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(188, 7)" end="(188, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(188, 11)" end="(188, 22)">
                                                <AtomNode start="(188, 11)" end="(188, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(188, 14)" end="(188, 22)">
                                                  <TacticTacticseq1IndentedNode start="(188, 14)" end="(188, 22)">
                                                    <NullNode start="(188, 14)" end="(188, 22)">
                                                      <OtherNode start="(188, 14)" end="(188, 22)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.nil&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;h₁ : [] ≤ a :: as&#10;⊢ [] &amp;lt; a :: bs" state_after="no goals" tactic="simp_all">
                                                        <AtomNode start="(188, 14)" end="(188, 22)" leading="" trailing="&#10;    " val="simp_all"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(189, 5)" end="(194, 87)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(189, 5)" end="(189, 16)">
                                                <OtherNode start="(189, 5)" end="(189, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(189, 5)" end="(189, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(189, 7)" end="(189, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(189, 7)" end="(189, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(189, 12)" end="(189, 16)">
                                                    <IdentNode start="(189, 12)" end="(189, 13)" leading="" trailing=" " raw_val="c" val="c"/>
                                                    <IdentNode start="(189, 14)" end="(189, 16)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(189, 17)" end="(194, 87)">
                                                <AtomNode start="(189, 17)" end="(189, 19)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(190, 7)" end="(194, 87)">
                                                  <TacticTacticseq1IndentedNode start="(190, 7)" end="(194, 87)">
                                                    <NullNode start="(190, 7)" end="(194, 87)">
                                                      <OtherNode start="(190, 7)" end="(190, 43)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case cons.cons&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;c : α&#10;l₁ : List α&#10;h₁ : c :: l₁ ≤ a :: as&#10;⊢ c :: l₁ &amp;lt; a :: bs" state_after="case cons.cons&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;c : α&#10;l₁ : List α&#10;h₁ : c :: l₁ ≤ a :: as&#10;w₄ : ¬a &amp;lt; c&#10;⊢ c :: l₁ &amp;lt; a :: bs" tactic="have w₄ := not_lt_of_cons_le_cons h₁">
                                                        <AtomNode start="(190, 7)" end="(190, 11)" leading="" trailing=" " val="have"/>
                                                        <OtherNode start="(190, 12)" end="(190, 43)" kind="Lean.Parser.Term.haveDecl">
                                                          <OtherNode start="(190, 12)" end="(190, 43)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(190, 12)" end="(190, 14)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(190, 12)" end="(190, 14)" leading="" trailing=" " raw_val="w₄" val="w₄"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(190, 15)" end="(190, 17)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(190, 18)" end="(190, 43)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(190, 18)" end="(190, 40)" leading="" trailing=" " raw_val="not_lt_of_cons_le_cons" val="not_lt_of_cons_le_cons" full_name="List.not_lt_of_cons_le_cons" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(105, 9)" def_end="(105, 31)"/>
                                                            <NullNode start="(190, 41)" end="(190, 43)">
                                                            <IdentNode start="(190, 41)" end="(190, 43)" leading="" trailing="&#10;      " raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(191, 7)" end="(191, 26)" kind="«tacticBy_cases_:_»" state_before="case cons.cons&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;c : α&#10;l₁ : List α&#10;h₁ : c :: l₁ ≤ a :: as&#10;w₄ : ¬a &amp;lt; c&#10;⊢ c :: l₁ &amp;lt; a :: bs" state_after="case pos&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;c : α&#10;l₁ : List α&#10;h₁ : c :: l₁ ≤ a :: as&#10;w₄ : ¬a &amp;lt; c&#10;w₅ : a = c&#10;⊢ c :: l₁ &amp;lt; a :: bs&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;c : α&#10;l₁ : List α&#10;h₁ : c :: l₁ ≤ a :: as&#10;w₄ : ¬a &amp;lt; c&#10;w₅ : ¬a = c&#10;⊢ c :: l₁ &amp;lt; a :: bs" tactic="by_cases w₅ : a = c">
                                                        <AtomNode start="(191, 7)" end="(191, 15)" leading="" trailing=" " val="by_cases"/>
                                                        <NullNode start="(191, 16)" end="(191, 20)">
                                                          <IdentNode start="(191, 16)" end="(191, 18)" leading="" trailing=" " raw_val="w₅" val="w₅"/>
                                                          <AtomNode start="(191, 19)" end="(191, 20)" leading="" trailing=" " val=":"/>
                                                        </NullNode>
                                                        <OtherNode start="(191, 21)" end="(191, 26)" kind="«term_=_»">
                                                          <IdentNode start="(191, 21)" end="(191, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                                                          <AtomNode start="(191, 23)" end="(191, 24)" leading="" trailing=" " val="="/>
                                                          <IdentNode start="(191, 25)" end="(191, 26)" leading="" trailing="&#10;      " raw_val="c" val="c"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(192, 7)" end="(193, 52)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;c : α&#10;l₁ : List α&#10;h₁ : c :: l₁ ≤ a :: as&#10;w₄ : ¬a &amp;lt; c&#10;w₅ : a = c&#10;⊢ c :: l₁ &amp;lt; a :: bs&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;c : α&#10;l₁ : List α&#10;h₁ : c :: l₁ ≤ a :: as&#10;w₄ : ¬a &amp;lt; c&#10;w₅ : ¬a = c&#10;⊢ c :: l₁ &amp;lt; a :: bs" state_after="case neg&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;c : α&#10;l₁ : List α&#10;h₁ : c :: l₁ ≤ a :: as&#10;w₄ : ¬a &amp;lt; c&#10;w₅ : ¬a = c&#10;⊢ c :: l₁ &amp;lt; a :: bs" tactic="· subst w₅&#10;  exact Lex.cons (ih (le_of_cons_le_cons h₁))">
                                                        <OtherNode start="(192, 7)" end="(192, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(192, 7)" end="(192, 8)" kind="patternIgnore">
                                                            <OtherNode start="(192, 7)" end="(192, 8)" kind="token.«· »">
                                                            <AtomNode start="(192, 7)" end="(192, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(192, 9)" end="(193, 52)">
                                                          <TacticTacticseq1IndentedNode start="(192, 9)" end="(193, 52)">
                                                            <NullNode start="(192, 9)" end="(193, 52)">
                                                            <OtherNode start="(192, 9)" end="(192, 17)" kind="Lean.Parser.Tactic.subst" state_before="case pos&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;c : α&#10;l₁ : List α&#10;h₁ : c :: l₁ ≤ a :: as&#10;w₄ : ¬a &amp;lt; c&#10;w₅ : a = c&#10;⊢ c :: l₁ &amp;lt; a :: bs" state_after="case pos&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;l₁ : List α&#10;h₁ : a :: l₁ ≤ a :: as&#10;w₄ : ¬a &amp;lt; a&#10;⊢ a :: l₁ &amp;lt; a :: bs" tactic="subst w₅">
                                                            <AtomNode start="(192, 9)" end="(192, 14)" leading="" trailing=" " val="subst"/>
                                                            <NullNode start="(192, 15)" end="(192, 17)">
                                                            <IdentNode start="(192, 15)" end="(192, 17)" leading="" trailing="&#10;        " raw_val="w₅" val="w₅"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(193, 9)" end="(193, 52)" kind="Lean.Parser.Tactic.exact" state_before="case pos&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;l₁ : List α&#10;h₁ : a :: l₁ ≤ a :: as&#10;w₄ : ¬a &amp;lt; a&#10;⊢ a :: l₁ &amp;lt; a :: bs" state_after="no goals" tactic="exact Lex.cons (ih (le_of_cons_le_cons h₁))">
                                                            <AtomNode start="(193, 9)" end="(193, 14)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(193, 15)" end="(193, 52)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(193, 15)" end="(193, 23)" leading="" trailing=" " raw_val="Lex.cons" val="Lex.cons" full_name="List.Lex.cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            <NullNode start="(193, 24)" end="(193, 52)">
                                                            <OtherNode start="(193, 24)" end="(193, 52)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(193, 24)" end="(193, 25)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(193, 25)" end="(193, 51)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(193, 25)" end="(193, 27)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(193, 28)" end="(193, 51)">
                                                            <OtherNode start="(193, 28)" end="(193, 51)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(193, 28)" end="(193, 29)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(193, 29)" end="(193, 50)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(193, 29)" end="(193, 47)" leading="" trailing=" " raw_val="le_of_cons_le_cons" val="le_of_cons_le_cons" full_name="List.le_of_cons_le_cons" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(115, 9)" def_end="(115, 27)"/>
                                                            <NullNode start="(193, 48)" end="(193, 50)">
                                                            <IdentNode start="(193, 48)" end="(193, 50)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(193, 50)" end="(193, 51)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(193, 51)" end="(193, 52)" leading="" trailing="&#10;      " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(194, 7)" end="(194, 87)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;c : α&#10;l₁ : List α&#10;h₁ : c :: l₁ ≤ a :: as&#10;w₄ : ¬a &amp;lt; c&#10;w₅ : ¬a = c&#10;⊢ c :: l₁ &amp;lt; a :: bs" state_after="no goals" tactic="· exact Lex.rel (Decidable.byContradiction fun w₆ =&amp;gt; w₅ (i₂.antisymm _ _ w₄ w₆))">
                                                        <OtherNode start="(194, 7)" end="(194, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(194, 7)" end="(194, 8)" kind="patternIgnore">
                                                            <OtherNode start="(194, 7)" end="(194, 8)" kind="token.«· »">
                                                            <AtomNode start="(194, 7)" end="(194, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(194, 9)" end="(194, 87)">
                                                          <TacticTacticseq1IndentedNode start="(194, 9)" end="(194, 87)">
                                                            <NullNode start="(194, 9)" end="(194, 87)">
                                                            <OtherNode start="(194, 9)" end="(194, 87)" kind="Lean.Parser.Tactic.exact" state_before="case neg&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i₀ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₁ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;i₂ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;i₃ : Trans (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) (fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2) fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;a : α&#10;as bs : List α&#10;w₃ : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) as bs&#10;ih : ∀ {l₁ : List α}, l₁ ≤ as → l₁ &amp;lt; bs&#10;c : α&#10;l₁ : List α&#10;h₁ : c :: l₁ ≤ a :: as&#10;w₄ : ¬a &amp;lt; c&#10;w₅ : ¬a = c&#10;⊢ c :: l₁ &amp;lt; a :: bs" state_after="no goals" tactic="exact Lex.rel (Decidable.byContradiction fun w₆ =&amp;gt; w₅ (i₂.antisymm _ _ w₄ w₆))">
                                                            <AtomNode start="(194, 9)" end="(194, 14)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(194, 15)" end="(194, 87)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(194, 15)" end="(194, 22)" leading="" trailing=" " raw_val="Lex.rel" val="Lex.rel" full_name="List.Lex.rel" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            <NullNode start="(194, 23)" end="(194, 87)">
                                                            <OtherNode start="(194, 23)" end="(194, 87)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(194, 23)" end="(194, 24)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(194, 24)" end="(194, 86)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(194, 24)" end="(194, 49)" leading="" trailing=" " raw_val="Decidable.byContradiction" val="Decidable.byContradiction" full_name="Decidable.byContradiction" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            <NullNode start="(194, 50)" end="(194, 86)">
                                                            <OtherNode start="(194, 50)" end="(194, 86)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(194, 50)" end="(194, 53)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(194, 54)" end="(194, 86)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(194, 54)" end="(194, 56)">
                                                            <IdentNode start="(194, 54)" end="(194, 56)" leading="" trailing=" " raw_val="w₆" val="w₆"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(194, 57)" end="(194, 59)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(194, 60)" end="(194, 86)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(194, 60)" end="(194, 62)" leading="" trailing=" " raw_val="w₅" val="w₅"/>
                                                            <NullNode start="(194, 63)" end="(194, 86)">
                                                            <OtherNode start="(194, 63)" end="(194, 86)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(194, 63)" end="(194, 64)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(194, 64)" end="(194, 85)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(194, 64)" end="(194, 75)" leading="" trailing=" " raw_val="i₂.antisymm" val="i₂.antisymm"/>
                                                            <NullNode start="(194, 76)" end="(194, 85)">
                                                            <TermHoleNode start="(194, 76)" end="(194, 77)">
                                                            <AtomNode start="(194, 76)" end="(194, 77)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(194, 78)" end="(194, 79)">
                                                            <AtomNode start="(194, 78)" end="(194, 79)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(194, 80)" end="(194, 82)" leading="" trailing=" " raw_val="w₄" val="w₄"/>
                                                            <IdentNode start="(194, 83)" end="(194, 85)" leading="" trailing="" raw_val="w₆" val="w₆"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(194, 85)" end="(194, 86)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(194, 86)" end="(194, 87)" leading="" trailing="&#10;&#10;" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(196, 1)" end="(202, 43)" name="le_trans" full_name="List.le_trans">
      <CommandDeclmodifiersNode start="(196, 1)" end="(196, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(196, 1)" end="(196, 10)">
          <OtherNode start="(196, 1)" end="(196, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(196, 1)" end="(196, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(196, 11)" end="(202, 43)" name="le_trans" full_name="List.le_trans" _is_private_decl="False">
        <AtomNode start="(196, 11)" end="(196, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(196, 19)" end="(196, 27)">
          <IdentNode start="(196, 19)" end="(196, 27)" leading="" trailing=" " raw_val="le_trans" val="le_trans"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(196, 28)" end="(201, 64)">
          <NullNode start="(196, 28)" end="(201, 54)">
            <OtherNode start="(196, 28)" end="(196, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(196, 28)" end="(196, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(196, 29)" end="(196, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(196, 29)" end="(196, 40)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(196, 41)" end="(196, 42)">
                  <IdentNode start="(196, 41)" end="(196, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(196, 42)" end="(196, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(196, 44)" end="(196, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(196, 44)" end="(196, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(196, 45)" end="(196, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(196, 45)" end="(196, 47)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(196, 48)" end="(196, 49)">
                  <IdentNode start="(196, 48)" end="(196, 49)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(196, 49)" end="(196, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(196, 51)" end="(196, 66)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(196, 51)" end="(196, 52)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(196, 52)" end="(196, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(196, 52)" end="(196, 63)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(196, 64)" end="(196, 65)">
                  <IdentNode start="(196, 64)" end="(196, 65)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(196, 65)" end="(196, 66)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(197, 5)" end="(197, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(197, 5)" end="(197, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(197, 6)" end="(197, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(197, 6)" end="(197, 16)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(197, 17)" end="(197, 39)">
                  <OtherNode start="(197, 17)" end="(197, 39)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(197, 17)" end="(197, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(197, 18)" end="(197, 23)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(197, 18)" end="(197, 19)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(197, 18)" end="(197, 19)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(197, 20)" end="(197, 21)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(197, 22)" end="(197, 23)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(197, 22)" end="(197, 23)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(197, 24)" end="(197, 25)" leading="" trailing=" " val=":"/>
                    <NullNode start="(197, 26)" end="(197, 38)">
                      <OtherNode start="(197, 26)" end="(197, 38)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(197, 26)" end="(197, 27)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(197, 28)" end="(197, 29)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(197, 30)" end="(197, 38)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(197, 30)" end="(197, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(197, 32)" end="(197, 33)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(197, 34)" end="(197, 38)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(197, 34)" end="(197, 38)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(197, 38)" end="(197, 39)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(197, 39)" end="(197, 40)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(198, 5)" end="(198, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(198, 5)" end="(198, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(198, 6)" end="(198, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(198, 6)" end="(198, 15)" leading="" trailing=" " raw_val="Std.Asymm" val="Std.Asymm" full_name="Std.Asymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(198, 16)" end="(198, 38)">
                  <OtherNode start="(198, 16)" end="(198, 38)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(198, 16)" end="(198, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(198, 17)" end="(198, 22)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(198, 17)" end="(198, 18)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(198, 17)" end="(198, 18)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(198, 19)" end="(198, 20)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(198, 21)" end="(198, 22)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(198, 21)" end="(198, 22)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(198, 23)" end="(198, 24)" leading="" trailing=" " val=":"/>
                    <NullNode start="(198, 25)" end="(198, 37)">
                      <OtherNode start="(198, 25)" end="(198, 37)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(198, 25)" end="(198, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(198, 27)" end="(198, 28)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(198, 29)" end="(198, 37)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(198, 29)" end="(198, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(198, 31)" end="(198, 32)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(198, 33)" end="(198, 37)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(198, 33)" end="(198, 37)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(198, 37)" end="(198, 38)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(198, 38)" end="(198, 39)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(199, 5)" end="(199, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(199, 5)" end="(199, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(199, 6)" end="(199, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(199, 6)" end="(199, 18)" leading="" trailing=" " raw_val="Std.Antisymm" val="Std.Antisymm" full_name="Std.Antisymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(199, 19)" end="(199, 43)">
                  <OtherNode start="(199, 19)" end="(199, 43)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(199, 19)" end="(199, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(199, 20)" end="(199, 27)" kind="«term¬_»">
                      <AtomNode start="(199, 20)" end="(199, 21)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(199, 22)" end="(199, 27)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(199, 22)" end="(199, 23)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(199, 22)" end="(199, 23)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(199, 24)" end="(199, 25)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(199, 26)" end="(199, 27)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(199, 26)" end="(199, 27)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(199, 28)" end="(199, 29)" leading="" trailing=" " val=":"/>
                    <NullNode start="(199, 30)" end="(199, 42)">
                      <OtherNode start="(199, 30)" end="(199, 42)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(199, 30)" end="(199, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(199, 32)" end="(199, 33)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(199, 34)" end="(199, 42)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(199, 34)" end="(199, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(199, 36)" end="(199, 37)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(199, 38)" end="(199, 42)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(199, 38)" end="(199, 42)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(199, 42)" end="(199, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(199, 43)" end="(199, 44)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(200, 5)" end="(200, 57)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(200, 5)" end="(200, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(200, 6)" end="(200, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(200, 6)" end="(200, 11)" leading="" trailing=" " raw_val="Trans" val="Trans" full_name="Trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(200, 12)" end="(200, 56)">
                  <OtherNode start="(200, 12)" end="(200, 36)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(200, 12)" end="(200, 13)" leading="" trailing="" val="("/>
                    <OtherNode start="(200, 13)" end="(200, 20)" kind="«term¬_»">
                      <AtomNode start="(200, 13)" end="(200, 14)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(200, 15)" end="(200, 20)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(200, 15)" end="(200, 16)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(200, 15)" end="(200, 16)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(200, 17)" end="(200, 18)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(200, 19)" end="(200, 20)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(200, 19)" end="(200, 20)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(200, 21)" end="(200, 22)" leading="" trailing=" " val=":"/>
                    <NullNode start="(200, 23)" end="(200, 35)">
                      <OtherNode start="(200, 23)" end="(200, 35)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(200, 23)" end="(200, 24)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(200, 25)" end="(200, 26)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(200, 27)" end="(200, 35)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(200, 27)" end="(200, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(200, 29)" end="(200, 30)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(200, 31)" end="(200, 35)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(200, 31)" end="(200, 35)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(200, 35)" end="(200, 36)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(200, 37)" end="(200, 46)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(200, 37)" end="(200, 38)" leading="" trailing="" val="("/>
                    <OtherNode start="(200, 38)" end="(200, 45)" kind="«term¬_»">
                      <AtomNode start="(200, 38)" end="(200, 39)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(200, 40)" end="(200, 45)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(200, 40)" end="(200, 41)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(200, 40)" end="(200, 41)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(200, 42)" end="(200, 43)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(200, 44)" end="(200, 45)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(200, 44)" end="(200, 45)" leading="" trailing="" val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(200, 45)" end="(200, 46)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(200, 47)" end="(200, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(200, 47)" end="(200, 48)" leading="" trailing="" val="("/>
                    <OtherNode start="(200, 48)" end="(200, 55)" kind="«term¬_»">
                      <AtomNode start="(200, 48)" end="(200, 49)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(200, 50)" end="(200, 55)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(200, 50)" end="(200, 51)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(200, 50)" end="(200, 51)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(200, 52)" end="(200, 53)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(200, 54)" end="(200, 55)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(200, 54)" end="(200, 55)" leading="" trailing="" val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(200, 55)" end="(200, 56)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(200, 56)" end="(200, 57)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(201, 5)" end="(201, 24)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(201, 5)" end="(201, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(201, 6)" end="(201, 14)">
                <IdentNode start="(201, 6)" end="(201, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(201, 9)" end="(201, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                <IdentNode start="(201, 12)" end="(201, 14)" leading="" trailing=" " raw_val="l₃" val="l₃"/>
              </NullNode>
              <NullNode start="(201, 15)" end="(201, 23)">
                <AtomNode start="(201, 15)" end="(201, 16)" leading="" trailing=" " val=":"/>
                <OtherNode start="(201, 17)" end="(201, 23)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(201, 17)" end="(201, 21)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(201, 22)" end="(201, 23)">
                    <IdentNode start="(201, 22)" end="(201, 23)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(201, 23)" end="(201, 24)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(201, 25)" end="(201, 39)">
              <AtomNode start="(201, 25)" end="(201, 26)" leading="" trailing="" val="("/>
              <NullNode start="(201, 26)" end="(201, 28)">
                <IdentNode start="(201, 26)" end="(201, 28)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
              </NullNode>
              <NullNode start="(201, 29)" end="(201, 38)">
                <AtomNode start="(201, 29)" end="(201, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(201, 31)" end="(201, 38)" kind="«term_≤_»">
                  <IdentNode start="(201, 31)" end="(201, 33)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(201, 34)" end="(201, 35)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(201, 36)" end="(201, 38)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(201, 38)" end="(201, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(201, 40)" end="(201, 54)">
              <AtomNode start="(201, 40)" end="(201, 41)" leading="" trailing="" val="("/>
              <NullNode start="(201, 41)" end="(201, 43)">
                <IdentNode start="(201, 41)" end="(201, 43)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
              </NullNode>
              <NullNode start="(201, 44)" end="(201, 53)">
                <AtomNode start="(201, 44)" end="(201, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(201, 46)" end="(201, 53)" kind="«term_≤_»">
                  <IdentNode start="(201, 46)" end="(201, 48)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  <AtomNode start="(201, 49)" end="(201, 50)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(201, 51)" end="(201, 53)" leading="" trailing="" raw_val="l₃" val="l₃"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(201, 53)" end="(201, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(201, 55)" end="(201, 64)">
            <AtomNode start="(201, 55)" end="(201, 56)" leading="" trailing=" " val=":"/>
            <OtherNode start="(201, 57)" end="(201, 64)" kind="«term_≤_»">
              <IdentNode start="(201, 57)" end="(201, 59)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              <AtomNode start="(201, 60)" end="(201, 61)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(201, 62)" end="(201, 64)" leading="" trailing=" " raw_val="l₃" val="l₃"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(201, 65)" end="(202, 43)">
          <AtomNode start="(201, 65)" end="(201, 67)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(202, 3)" end="(202, 43)" kind="Lean.Parser.Term.fun">
            <AtomNode start="(202, 3)" end="(202, 6)" leading="" trailing=" " val="fun"/>
            <OtherNode start="(202, 7)" end="(202, 43)" kind="Lean.Parser.Term.basicFun">
              <NullNode start="(202, 7)" end="(202, 9)">
                <IdentNode start="(202, 7)" end="(202, 9)" leading="" trailing=" " raw_val="h₃" val="h₃"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(202, 10)" end="(202, 12)" leading="" trailing=" " val="=&amp;gt;"/>
              <OtherNode start="(202, 13)" end="(202, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(202, 13)" end="(202, 15)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                <NullNode start="(202, 16)" end="(202, 43)">
                  <OtherNode start="(202, 16)" end="(202, 43)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(202, 16)" end="(202, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(202, 17)" end="(202, 42)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(202, 17)" end="(202, 36)" leading="" trailing=" " raw_val="List.lt_of_le_of_lt" val="List.lt_of_le_of_lt" full_name="List.lt_of_le_of_lt" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(166, 19)" def_end="(166, 33)"/>
                      <NullNode start="(202, 37)" end="(202, 42)">
                        <IdentNode start="(202, 37)" end="(202, 39)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                        <IdentNode start="(202, 40)" end="(202, 42)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(202, 42)" end="(202, 43)" leading="" trailing="&#10;&#10;" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(204, 1)" end="(210, 37)">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandInstanceNode start="(204, 1)" end="(210, 37)">
        <TermAttrkindNode>
          <NullNode/>
        </TermAttrkindNode>
        <AtomNode start="(204, 1)" end="(204, 9)" leading="" trailing=" " val="instance"/>
        <NullNode/>
        <NullNode/>
        <CommandDeclsigNode start="(204, 10)" end="(209, 59)">
          <NullNode start="(204, 10)" end="(208, 57)">
            <OtherNode start="(204, 10)" end="(204, 25)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(204, 10)" end="(204, 11)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(204, 11)" end="(204, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(204, 11)" end="(204, 22)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(204, 23)" end="(204, 24)">
                  <IdentNode start="(204, 23)" end="(204, 24)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(204, 24)" end="(204, 25)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(204, 26)" end="(204, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(204, 26)" end="(204, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(204, 27)" end="(204, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(204, 27)" end="(204, 29)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(204, 30)" end="(204, 31)">
                  <IdentNode start="(204, 30)" end="(204, 31)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(204, 31)" end="(204, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(204, 33)" end="(204, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(204, 33)" end="(204, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(204, 34)" end="(204, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(204, 34)" end="(204, 45)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(204, 46)" end="(204, 47)">
                  <IdentNode start="(204, 46)" end="(204, 47)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(204, 47)" end="(204, 48)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(205, 5)" end="(205, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(205, 5)" end="(205, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(205, 6)" end="(205, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(205, 6)" end="(205, 16)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(205, 17)" end="(205, 39)">
                  <OtherNode start="(205, 17)" end="(205, 39)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(205, 17)" end="(205, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(205, 18)" end="(205, 23)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(205, 18)" end="(205, 19)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(205, 18)" end="(205, 19)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(205, 20)" end="(205, 21)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(205, 22)" end="(205, 23)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(205, 22)" end="(205, 23)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(205, 24)" end="(205, 25)" leading="" trailing=" " val=":"/>
                    <NullNode start="(205, 26)" end="(205, 38)">
                      <OtherNode start="(205, 26)" end="(205, 38)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(205, 26)" end="(205, 27)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(205, 28)" end="(205, 29)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(205, 30)" end="(205, 38)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(205, 30)" end="(205, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(205, 32)" end="(205, 33)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(205, 34)" end="(205, 38)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(205, 34)" end="(205, 38)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(205, 38)" end="(205, 39)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(205, 39)" end="(205, 40)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(206, 5)" end="(206, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(206, 5)" end="(206, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(206, 6)" end="(206, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(206, 6)" end="(206, 15)" leading="" trailing=" " raw_val="Std.Asymm" val="Std.Asymm" full_name="Std.Asymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(206, 16)" end="(206, 38)">
                  <OtherNode start="(206, 16)" end="(206, 38)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(206, 16)" end="(206, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(206, 17)" end="(206, 22)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(206, 17)" end="(206, 18)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(206, 17)" end="(206, 18)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(206, 19)" end="(206, 20)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(206, 21)" end="(206, 22)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(206, 21)" end="(206, 22)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(206, 23)" end="(206, 24)" leading="" trailing=" " val=":"/>
                    <NullNode start="(206, 25)" end="(206, 37)">
                      <OtherNode start="(206, 25)" end="(206, 37)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(206, 25)" end="(206, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(206, 27)" end="(206, 28)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(206, 29)" end="(206, 37)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(206, 29)" end="(206, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(206, 31)" end="(206, 32)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(206, 33)" end="(206, 37)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(206, 33)" end="(206, 37)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(206, 37)" end="(206, 38)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(206, 38)" end="(206, 39)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(207, 5)" end="(207, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(207, 5)" end="(207, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(207, 6)" end="(207, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(207, 6)" end="(207, 18)" leading="" trailing=" " raw_val="Std.Antisymm" val="Std.Antisymm" full_name="Std.Antisymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(207, 19)" end="(207, 43)">
                  <OtherNode start="(207, 19)" end="(207, 43)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(207, 19)" end="(207, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(207, 20)" end="(207, 27)" kind="«term¬_»">
                      <AtomNode start="(207, 20)" end="(207, 21)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(207, 22)" end="(207, 27)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(207, 22)" end="(207, 23)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(207, 22)" end="(207, 23)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(207, 24)" end="(207, 25)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(207, 26)" end="(207, 27)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(207, 26)" end="(207, 27)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(207, 28)" end="(207, 29)" leading="" trailing=" " val=":"/>
                    <NullNode start="(207, 30)" end="(207, 42)">
                      <OtherNode start="(207, 30)" end="(207, 42)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(207, 30)" end="(207, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(207, 32)" end="(207, 33)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(207, 34)" end="(207, 42)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(207, 34)" end="(207, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(207, 36)" end="(207, 37)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(207, 38)" end="(207, 42)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(207, 38)" end="(207, 42)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(207, 42)" end="(207, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(207, 43)" end="(207, 44)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(208, 5)" end="(208, 57)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(208, 5)" end="(208, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(208, 6)" end="(208, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(208, 6)" end="(208, 11)" leading="" trailing=" " raw_val="Trans" val="Trans" full_name="Trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(208, 12)" end="(208, 56)">
                  <OtherNode start="(208, 12)" end="(208, 36)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(208, 12)" end="(208, 13)" leading="" trailing="" val="("/>
                    <OtherNode start="(208, 13)" end="(208, 20)" kind="«term¬_»">
                      <AtomNode start="(208, 13)" end="(208, 14)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(208, 15)" end="(208, 20)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(208, 15)" end="(208, 16)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(208, 15)" end="(208, 16)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(208, 17)" end="(208, 18)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(208, 19)" end="(208, 20)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(208, 19)" end="(208, 20)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(208, 21)" end="(208, 22)" leading="" trailing=" " val=":"/>
                    <NullNode start="(208, 23)" end="(208, 35)">
                      <OtherNode start="(208, 23)" end="(208, 35)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(208, 23)" end="(208, 24)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(208, 25)" end="(208, 26)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(208, 27)" end="(208, 35)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(208, 27)" end="(208, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(208, 29)" end="(208, 30)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(208, 31)" end="(208, 35)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(208, 31)" end="(208, 35)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(208, 35)" end="(208, 36)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(208, 37)" end="(208, 46)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(208, 37)" end="(208, 38)" leading="" trailing="" val="("/>
                    <OtherNode start="(208, 38)" end="(208, 45)" kind="«term¬_»">
                      <AtomNode start="(208, 38)" end="(208, 39)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(208, 40)" end="(208, 45)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(208, 40)" end="(208, 41)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(208, 40)" end="(208, 41)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(208, 42)" end="(208, 43)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(208, 44)" end="(208, 45)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(208, 44)" end="(208, 45)" leading="" trailing="" val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(208, 45)" end="(208, 46)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(208, 47)" end="(208, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(208, 47)" end="(208, 48)" leading="" trailing="" val="("/>
                    <OtherNode start="(208, 48)" end="(208, 55)" kind="«term¬_»">
                      <AtomNode start="(208, 48)" end="(208, 49)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(208, 50)" end="(208, 55)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(208, 50)" end="(208, 51)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(208, 50)" end="(208, 51)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(208, 52)" end="(208, 53)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(208, 54)" end="(208, 55)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(208, 54)" end="(208, 55)" leading="" trailing="" val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(208, 55)" end="(208, 56)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(208, 56)" end="(208, 57)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(208, 58)" end="(209, 59)">
            <AtomNode start="(208, 58)" end="(208, 59)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(209, 5)" end="(209, 59)" kind="Lean.Parser.Term.app">
              <IdentNode start="(209, 5)" end="(209, 10)" leading="" trailing=" " raw_val="Trans" val="Trans" full_name="Trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode start="(209, 11)" end="(209, 59)">
                <OtherNode start="(209, 11)" end="(209, 43)" kind="Lean.Parser.Term.typeAscription">
                  <AtomNode start="(209, 11)" end="(209, 12)" leading="" trailing="" val="("/>
                  <OtherNode start="(209, 12)" end="(209, 17)" kind="«term_≤_»">
                    <OtherNode start="(209, 12)" end="(209, 13)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(209, 12)" end="(209, 13)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                    <AtomNode start="(209, 14)" end="(209, 15)" leading="" trailing=" " val="≤"/>
                    <OtherNode start="(209, 16)" end="(209, 17)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(209, 16)" end="(209, 17)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(209, 18)" end="(209, 19)" leading="" trailing=" " val=":"/>
                  <NullNode start="(209, 20)" end="(209, 42)">
                    <OtherNode start="(209, 20)" end="(209, 42)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(209, 20)" end="(209, 26)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(209, 20)" end="(209, 24)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(209, 25)" end="(209, 26)">
                          <IdentNode start="(209, 25)" end="(209, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(209, 27)" end="(209, 28)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(209, 29)" end="(209, 42)" kind="Lean.Parser.Term.arrow">
                        <OtherNode start="(209, 29)" end="(209, 35)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(209, 29)" end="(209, 33)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(209, 34)" end="(209, 35)">
                            <IdentNode start="(209, 34)" end="(209, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(209, 36)" end="(209, 37)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(209, 38)" end="(209, 42)" kind="Lean.Parser.Term.prop">
                          <AtomNode start="(209, 38)" end="(209, 42)" leading="" trailing="" val="Prop"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(209, 42)" end="(209, 43)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <OtherNode start="(209, 44)" end="(209, 51)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(209, 44)" end="(209, 45)" leading="" trailing="" val="("/>
                  <OtherNode start="(209, 45)" end="(209, 50)" kind="«term_≤_»">
                    <OtherNode start="(209, 45)" end="(209, 46)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(209, 45)" end="(209, 46)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                    <AtomNode start="(209, 47)" end="(209, 48)" leading="" trailing=" " val="≤"/>
                    <OtherNode start="(209, 49)" end="(209, 50)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(209, 49)" end="(209, 50)" leading="" trailing="" val="·"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(209, 50)" end="(209, 51)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <OtherNode start="(209, 52)" end="(209, 59)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(209, 52)" end="(209, 53)" leading="" trailing="" val="("/>
                  <OtherNode start="(209, 53)" end="(209, 58)" kind="«term_≤_»">
                    <OtherNode start="(209, 53)" end="(209, 54)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(209, 53)" end="(209, 54)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                    <AtomNode start="(209, 55)" end="(209, 56)" leading="" trailing=" " val="≤"/>
                    <OtherNode start="(209, 57)" end="(209, 58)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(209, 57)" end="(209, 58)" leading="" trailing="" val="·"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(209, 58)" end="(209, 59)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandWherestructinstNode start="(209, 60)" end="(210, 37)">
          <AtomNode start="(209, 60)" end="(209, 65)" leading="" trailing="&#10;  " val="where"/>
          <OtherNode start="(210, 3)" end="(210, 37)" kind="Lean.Parser.Term.structInstFields">
            <NullNode start="(210, 3)" end="(210, 37)">
              <OtherNode start="(210, 3)" end="(210, 37)" kind="Lean.Parser.Term.structInstField">
                <OtherNode start="(210, 3)" end="(210, 8)" kind="Lean.Parser.Term.structInstLVal">
                  <IdentNode start="(210, 3)" end="(210, 8)" leading="" trailing=" " raw_val="trans" val="trans"/>
                  <NullNode/>
                </OtherNode>
                <NullNode start="(210, 9)" end="(210, 37)">
                  <NullNode start="(210, 9)" end="(210, 14)">
                    <IdentNode start="(210, 9)" end="(210, 11)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                    <IdentNode start="(210, 12)" end="(210, 14)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                  </NullNode>
                  <NullNode/>
                  <OtherNode start="(210, 15)" end="(210, 37)" kind="Lean.Parser.Term.structInstFieldDef">
                    <AtomNode start="(210, 15)" end="(210, 17)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(210, 18)" end="(210, 37)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(210, 18)" end="(210, 31)" leading="" trailing=" " raw_val="List.le_trans" val="List.le_trans" full_name="List.le_trans" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(196, 19)" def_end="(196, 27)"/>
                      <NullNode start="(210, 32)" end="(210, 37)">
                        <IdentNode start="(210, 32)" end="(210, 34)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        <IdentNode start="(210, 35)" end="(210, 37)" leading="" trailing="&#10;&#10;" raw_val="h₂" val="h₂"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <NullNode/>
        </CommandWherestructinstNode>
      </CommandInstanceNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(212, 1)" end="(222, 36)" name="lex_asymm" full_name="List.lex_asymm">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(212, 1)" end="(222, 36)" name="lex_asymm" full_name="List.lex_asymm" _is_private_decl="False">
        <AtomNode start="(212, 1)" end="(212, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(212, 9)" end="(212, 18)">
          <IdentNode start="(212, 9)" end="(212, 18)" leading="" trailing=" " raw_val="lex_asymm" val="lex_asymm"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(212, 19)" end="(213, 89)">
          <NullNode start="(212, 19)" end="(213, 39)">
            <OtherNode start="(212, 19)" end="(212, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(212, 19)" end="(212, 20)" leading="" trailing="" val="{"/>
              <NullNode start="(212, 20)" end="(212, 21)">
                <IdentNode start="(212, 20)" end="(212, 21)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(212, 22)" end="(212, 36)">
                <AtomNode start="(212, 22)" end="(212, 23)" leading="" trailing=" " val=":"/>
                <OtherNode start="(212, 24)" end="(212, 36)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(212, 24)" end="(212, 25)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(212, 26)" end="(212, 27)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(212, 28)" end="(212, 36)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(212, 28)" end="(212, 29)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(212, 30)" end="(212, 31)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(212, 32)" end="(212, 36)" kind="Lean.Parser.Term.prop">
                      <AtomNode start="(212, 32)" end="(212, 36)" leading="" trailing="" val="Prop"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(212, 36)" end="(212, 37)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(213, 5)" end="(213, 39)">
              <AtomNode start="(213, 5)" end="(213, 6)" leading="" trailing="" val="("/>
              <NullNode start="(213, 6)" end="(213, 7)">
                <IdentNode start="(213, 6)" end="(213, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(213, 8)" end="(213, 38)">
                <AtomNode start="(213, 8)" end="(213, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(213, 10)" end="(213, 38)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(213, 10)" end="(213, 11)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(213, 12)" end="(213, 21)">
                    <OtherNode start="(213, 12)" end="(213, 21)" kind="Lean.Parser.Term.implicitBinder">
                      <AtomNode start="(213, 12)" end="(213, 13)" leading="" trailing="" val="{"/>
                      <NullNode start="(213, 13)" end="(213, 16)">
                        <IdentNode start="(213, 13)" end="(213, 14)" leading="" trailing=" " raw_val="x" val="x"/>
                        <IdentNode start="(213, 15)" end="(213, 16)" leading="" trailing=" " raw_val="y" val="y"/>
                      </NullNode>
                      <NullNode start="(213, 17)" end="(213, 20)">
                        <AtomNode start="(213, 17)" end="(213, 18)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(213, 19)" end="(213, 20)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <AtomNode start="(213, 20)" end="(213, 21)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(213, 21)" end="(213, 22)" leading="" trailing=" " val=","/>
                  <OtherNode start="(213, 23)" end="(213, 38)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(213, 23)" end="(213, 28)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(213, 23)" end="(213, 24)" leading="" trailing=" " raw_val="r" val="r"/>
                      <NullNode start="(213, 25)" end="(213, 28)">
                        <IdentNode start="(213, 25)" end="(213, 26)" leading="" trailing=" " raw_val="x" val="x"/>
                        <IdentNode start="(213, 27)" end="(213, 28)" leading="" trailing=" " raw_val="y" val="y"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(213, 29)" end="(213, 30)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(213, 31)" end="(213, 38)" kind="«term¬_»">
                      <AtomNode start="(213, 31)" end="(213, 32)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(213, 33)" end="(213, 38)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(213, 33)" end="(213, 34)" leading="" trailing=" " raw_val="r" val="r"/>
                        <NullNode start="(213, 35)" end="(213, 38)">
                          <IdentNode start="(213, 35)" end="(213, 36)" leading="" trailing=" " raw_val="y" val="y"/>
                          <IdentNode start="(213, 37)" end="(213, 38)" leading="" trailing="" raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(213, 38)" end="(213, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(213, 40)" end="(213, 89)">
            <AtomNode start="(213, 40)" end="(213, 41)" leading="" trailing=" " val=":"/>
            <OtherNode start="(213, 42)" end="(213, 89)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(213, 42)" end="(213, 43)" leading="" trailing=" " val="∀"/>
              <NullNode start="(213, 44)" end="(213, 60)">
                <OtherNode start="(213, 44)" end="(213, 60)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(213, 44)" end="(213, 45)" leading="" trailing="" val="{"/>
                  <NullNode start="(213, 45)" end="(213, 50)">
                    <IdentNode start="(213, 45)" end="(213, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(213, 48)" end="(213, 50)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                  <NullNode start="(213, 51)" end="(213, 59)">
                    <AtomNode start="(213, 51)" end="(213, 52)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(213, 53)" end="(213, 59)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(213, 53)" end="(213, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(213, 58)" end="(213, 59)">
                        <IdentNode start="(213, 58)" end="(213, 59)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(213, 59)" end="(213, 60)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(213, 60)" end="(213, 61)" leading="" trailing=" " val=","/>
              <OtherNode start="(213, 62)" end="(213, 89)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(213, 62)" end="(213, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(213, 62)" end="(213, 65)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(213, 66)" end="(213, 73)">
                    <IdentNode start="(213, 66)" end="(213, 67)" leading="" trailing=" " raw_val="r" val="r"/>
                    <IdentNode start="(213, 68)" end="(213, 70)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(213, 71)" end="(213, 73)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(213, 74)" end="(213, 75)" leading="" trailing=" " val="→"/>
                <OtherNode start="(213, 76)" end="(213, 89)" kind="«term¬_»">
                  <AtomNode start="(213, 76)" end="(213, 77)" leading="" trailing=" " val="¬"/>
                  <OtherNode start="(213, 78)" end="(213, 89)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(213, 78)" end="(213, 81)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(213, 82)" end="(213, 89)">
                      <IdentNode start="(213, 82)" end="(213, 83)" leading="" trailing=" " raw_val="r" val="r"/>
                      <IdentNode start="(213, 84)" end="(213, 86)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      <IdentNode start="(213, 87)" end="(213, 89)" leading="" trailing="&#10;  " raw_val="l₁" val="l₁"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(214, 3)" end="(222, 36)">
          <OtherNode start="(214, 3)" end="(222, 36)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(214, 3)" end="(222, 36)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(214, 3)" end="(222, 36)">
                <OtherNode start="(214, 3)" end="(214, 28)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(214, 3)" end="(214, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(214, 5)" end="(214, 17)">
                    <NullNode start="(214, 5)" end="(214, 17)">
                      <IdentNode start="(214, 5)" end="(214, 8)" leading="" trailing="" raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(214, 8)" end="(214, 9)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(214, 10)" end="(214, 11)">
                        <AtomNode start="(214, 10)" end="(214, 11)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(214, 11)" end="(214, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(214, 13)" end="(214, 17)" kind="Lean.Parser.Term.dotIdent">
                        <AtomNode start="(214, 13)" end="(214, 14)" leading="" trailing="" val="."/>
                        <IdentNode start="(214, 14)" end="(214, 17)" leading="" trailing=" " raw_val="nil" val="nil"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(214, 18)" end="(214, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(214, 21)" end="(214, 28)">
                    <AtomNode start="(214, 21)" end="(214, 23)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(214, 24)" end="(214, 28)">
                      <TacticTacticseq1IndentedNode start="(214, 24)" end="(214, 28)">
                        <NullNode start="(214, 24)" end="(214, 28)">
                          <OtherNode start="(214, 24)" end="(214, 28)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;r : α → α → Prop&#10;h : ∀ {x y : α}, r x y → ¬r y x&#10;a✝ : α&#10;l✝ : List α&#10;⊢ ¬Lex r (a✝ :: l✝) []" state_after="no goals" tactic="simp">
                            <AtomNode start="(214, 24)" end="(214, 28)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(215, 3)" end="(218, 26)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(215, 3)" end="(215, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(215, 5)" end="(215, 30)">
                    <NullNode start="(215, 5)" end="(215, 30)">
                      <OtherNode start="(215, 5)" end="(215, 12)" kind="«term_::_»">
                        <IdentNode start="(215, 5)" end="(215, 6)" leading="" trailing=" " raw_val="x" val="x"/>
                        <AtomNode start="(215, 7)" end="(215, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(215, 10)" end="(215, 12)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(215, 12)" end="(215, 13)" leading="" trailing=" " val=","/>
                      <OtherNode start="(215, 14)" end="(215, 21)" kind="«term_::_»">
                        <IdentNode start="(215, 14)" end="(215, 15)" leading="" trailing=" " raw_val="y" val="y"/>
                        <AtomNode start="(215, 16)" end="(215, 18)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(215, 19)" end="(215, 21)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </OtherNode>
                      <AtomNode start="(215, 21)" end="(215, 22)" leading="" trailing=" " val=","/>
                      <OtherNode start="(215, 23)" end="(215, 30)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(215, 23)" end="(215, 27)" kind="Lean.Parser.Term.dotIdent">
                          <AtomNode start="(215, 23)" end="(215, 24)" leading="" trailing="" val="."/>
                          <IdentNode start="(215, 24)" end="(215, 27)" leading="" trailing=" " raw_val="rel" val="rel"/>
                        </OtherNode>
                        <NullNode start="(215, 28)" end="(215, 30)">
                          <IdentNode start="(215, 28)" end="(215, 30)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(215, 31)" end="(215, 33)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                  <OtherNode start="(216, 5)" end="(218, 26)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(216, 5)" end="(216, 8)" leading="" trailing="&#10;    " val="fun"/>
                    <OtherNode start="(217, 5)" end="(218, 26)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(217, 5)" end="(218, 26)">
                        <OtherNode start="(217, 5)" end="(217, 25)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(217, 5)" end="(217, 6)" leading="" trailing=" " val="|"/>
                          <NullNode start="(217, 7)" end="(217, 14)">
                            <NullNode start="(217, 7)" end="(217, 14)">
                              <OtherNode start="(217, 7)" end="(217, 14)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(217, 7)" end="(217, 11)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(217, 7)" end="(217, 8)" leading="" trailing="" val="."/>
                                  <IdentNode start="(217, 8)" end="(217, 11)" leading="" trailing=" " raw_val="rel" val="rel"/>
                                </OtherNode>
                                <NullNode start="(217, 12)" end="(217, 14)">
                                  <IdentNode start="(217, 12)" end="(217, 14)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(217, 15)" end="(217, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(217, 18)" end="(217, 25)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(217, 18)" end="(217, 19)" leading="" trailing=" " raw_val="h" val="h"/>
                            <NullNode start="(217, 20)" end="(217, 25)">
                              <IdentNode start="(217, 20)" end="(217, 22)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                              <IdentNode start="(217, 23)" end="(217, 25)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <OtherNode start="(218, 5)" end="(218, 26)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(218, 5)" end="(218, 6)" leading="" trailing=" " val="|"/>
                          <NullNode start="(218, 7)" end="(218, 15)">
                            <NullNode start="(218, 7)" end="(218, 15)">
                              <OtherNode start="(218, 7)" end="(218, 15)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(218, 7)" end="(218, 12)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(218, 7)" end="(218, 8)" leading="" trailing="" val="."/>
                                  <IdentNode start="(218, 8)" end="(218, 12)" leading="" trailing=" " raw_val="cons" val="cons"/>
                                </OtherNode>
                                <NullNode start="(218, 13)" end="(218, 15)">
                                  <IdentNode start="(218, 13)" end="(218, 15)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(218, 16)" end="(218, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(218, 19)" end="(218, 26)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(218, 19)" end="(218, 20)" leading="" trailing=" " raw_val="h" val="h"/>
                            <NullNode start="(218, 21)" end="(218, 26)">
                              <IdentNode start="(218, 21)" end="(218, 23)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                              <IdentNode start="(218, 24)" end="(218, 26)" leading="" trailing="&#10;  " raw_val="h₁" val="h₁"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(219, 3)" end="(222, 36)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(219, 3)" end="(219, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(219, 5)" end="(219, 31)">
                    <NullNode start="(219, 5)" end="(219, 31)">
                      <OtherNode start="(219, 5)" end="(219, 12)" kind="«term_::_»">
                        <IdentNode start="(219, 5)" end="(219, 6)" leading="" trailing=" " raw_val="x" val="x"/>
                        <AtomNode start="(219, 7)" end="(219, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(219, 10)" end="(219, 12)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(219, 12)" end="(219, 13)" leading="" trailing=" " val=","/>
                      <OtherNode start="(219, 14)" end="(219, 21)" kind="«term_::_»">
                        <TermHoleNode start="(219, 14)" end="(219, 15)">
                          <AtomNode start="(219, 14)" end="(219, 15)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(219, 16)" end="(219, 18)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(219, 19)" end="(219, 21)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </OtherNode>
                      <AtomNode start="(219, 21)" end="(219, 22)" leading="" trailing=" " val=","/>
                      <OtherNode start="(219, 23)" end="(219, 31)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(219, 23)" end="(219, 28)" kind="Lean.Parser.Term.dotIdent">
                          <AtomNode start="(219, 23)" end="(219, 24)" leading="" trailing="" val="."/>
                          <IdentNode start="(219, 24)" end="(219, 28)" leading="" trailing=" " raw_val="cons" val="cons"/>
                        </OtherNode>
                        <NullNode start="(219, 29)" end="(219, 31)">
                          <IdentNode start="(219, 29)" end="(219, 31)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(219, 32)" end="(219, 34)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                  <OtherNode start="(220, 5)" end="(222, 36)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(220, 5)" end="(220, 8)" leading="" trailing="&#10;    " val="fun"/>
                    <OtherNode start="(221, 5)" end="(222, 36)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(221, 5)" end="(222, 36)">
                        <OtherNode start="(221, 5)" end="(221, 25)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(221, 5)" end="(221, 6)" leading="" trailing=" " val="|"/>
                          <NullNode start="(221, 7)" end="(221, 14)">
                            <NullNode start="(221, 7)" end="(221, 14)">
                              <OtherNode start="(221, 7)" end="(221, 14)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(221, 7)" end="(221, 11)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(221, 7)" end="(221, 8)" leading="" trailing="" val="."/>
                                  <IdentNode start="(221, 8)" end="(221, 11)" leading="" trailing=" " raw_val="rel" val="rel"/>
                                </OtherNode>
                                <NullNode start="(221, 12)" end="(221, 14)">
                                  <IdentNode start="(221, 12)" end="(221, 14)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(221, 15)" end="(221, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(221, 18)" end="(221, 25)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(221, 18)" end="(221, 19)" leading="" trailing=" " raw_val="h" val="h"/>
                            <NullNode start="(221, 20)" end="(221, 25)">
                              <IdentNode start="(221, 20)" end="(221, 22)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                              <IdentNode start="(221, 23)" end="(221, 25)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <OtherNode start="(222, 5)" end="(222, 36)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(222, 5)" end="(222, 6)" leading="" trailing=" " val="|"/>
                          <NullNode start="(222, 7)" end="(222, 15)">
                            <NullNode start="(222, 7)" end="(222, 15)">
                              <OtherNode start="(222, 7)" end="(222, 15)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(222, 7)" end="(222, 12)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(222, 7)" end="(222, 8)" leading="" trailing="" val="."/>
                                  <IdentNode start="(222, 8)" end="(222, 12)" leading="" trailing=" " raw_val="cons" val="cons"/>
                                </OtherNode>
                                <NullNode start="(222, 13)" end="(222, 15)">
                                  <IdentNode start="(222, 13)" end="(222, 15)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(222, 16)" end="(222, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(222, 19)" end="(222, 36)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(222, 19)" end="(222, 28)" leading="" trailing=" " raw_val="lex_asymm" val="lex_asymm"/>
                            <NullNode start="(222, 29)" end="(222, 36)">
                              <IdentNode start="(222, 29)" end="(222, 30)" leading="" trailing=" " raw_val="h" val="h"/>
                              <IdentNode start="(222, 31)" end="(222, 33)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                              <IdentNode start="(222, 34)" end="(222, 36)" leading="" trailing="&#10;&#10;" raw_val="h₂" val="h₂"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(224, 1)" end="(226, 76)" name="lt_asymm" full_name="List.lt_asymm">
      <CommandDeclmodifiersNode start="(224, 1)" end="(224, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(224, 1)" end="(224, 10)">
          <OtherNode start="(224, 1)" end="(224, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(224, 1)" end="(224, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(224, 11)" end="(226, 76)" name="lt_asymm" full_name="List.lt_asymm" _is_private_decl="False">
        <AtomNode start="(224, 11)" end="(224, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(224, 19)" end="(224, 27)">
          <IdentNode start="(224, 19)" end="(224, 27)" leading="" trailing=" " raw_val="lt_asymm" val="lt_asymm"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(224, 28)" end="(226, 47)">
          <NullNode start="(224, 28)" end="(226, 35)">
            <OtherNode start="(224, 28)" end="(224, 34)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(224, 28)" end="(224, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(224, 29)" end="(224, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(224, 29)" end="(224, 31)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(224, 32)" end="(224, 33)">
                  <IdentNode start="(224, 32)" end="(224, 33)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(224, 33)" end="(224, 34)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(225, 5)" end="(225, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(225, 5)" end="(225, 6)" leading="" trailing="" val="["/>
              <NullNode start="(225, 6)" end="(225, 9)">
                <IdentNode start="(225, 6)" end="(225, 7)" leading="" trailing=" " raw_val="i" val="i"/>
                <AtomNode start="(225, 8)" end="(225, 9)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(225, 10)" end="(225, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(225, 10)" end="(225, 19)" leading="" trailing=" " raw_val="Std.Asymm" val="Std.Asymm" full_name="Std.Asymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(225, 20)" end="(225, 42)">
                  <OtherNode start="(225, 20)" end="(225, 42)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(225, 20)" end="(225, 21)" leading="" trailing="" val="("/>
                    <OtherNode start="(225, 21)" end="(225, 26)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(225, 21)" end="(225, 22)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(225, 21)" end="(225, 22)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(225, 23)" end="(225, 24)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(225, 25)" end="(225, 26)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(225, 25)" end="(225, 26)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(225, 27)" end="(225, 28)" leading="" trailing=" " val=":"/>
                    <NullNode start="(225, 29)" end="(225, 41)">
                      <OtherNode start="(225, 29)" end="(225, 41)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(225, 29)" end="(225, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(225, 31)" end="(225, 32)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(225, 33)" end="(225, 41)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(225, 33)" end="(225, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(225, 35)" end="(225, 36)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(225, 37)" end="(225, 41)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(225, 37)" end="(225, 41)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(225, 41)" end="(225, 42)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(225, 42)" end="(225, 43)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(226, 5)" end="(226, 21)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(226, 5)" end="(226, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(226, 6)" end="(226, 11)">
                <IdentNode start="(226, 6)" end="(226, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(226, 9)" end="(226, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(226, 12)" end="(226, 20)">
                <AtomNode start="(226, 12)" end="(226, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(226, 14)" end="(226, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(226, 14)" end="(226, 18)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(226, 19)" end="(226, 20)">
                    <IdentNode start="(226, 19)" end="(226, 20)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(226, 20)" end="(226, 21)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(226, 22)" end="(226, 35)">
              <AtomNode start="(226, 22)" end="(226, 23)" leading="" trailing="" val="("/>
              <NullNode start="(226, 23)" end="(226, 24)">
                <IdentNode start="(226, 23)" end="(226, 24)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(226, 25)" end="(226, 34)">
                <AtomNode start="(226, 25)" end="(226, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(226, 27)" end="(226, 34)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(226, 27)" end="(226, 29)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(226, 30)" end="(226, 31)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(226, 32)" end="(226, 34)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(226, 34)" end="(226, 35)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(226, 36)" end="(226, 47)">
            <AtomNode start="(226, 36)" end="(226, 37)" leading="" trailing=" " val=":"/>
            <OtherNode start="(226, 38)" end="(226, 47)" kind="«term¬_»">
              <AtomNode start="(226, 38)" end="(226, 39)" leading="" trailing=" " val="¬"/>
              <OtherNode start="(226, 40)" end="(226, 47)" kind="«term_&amp;lt;_»">
                <IdentNode start="(226, 40)" end="(226, 42)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                <AtomNode start="(226, 43)" end="(226, 44)" leading="" trailing=" " val="&amp;lt;"/>
                <IdentNode start="(226, 45)" end="(226, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(226, 48)" end="(226, 76)">
          <AtomNode start="(226, 48)" end="(226, 50)" leading="" trailing=" " val=":="/>
          <OtherNode start="(226, 51)" end="(226, 76)" kind="Lean.Parser.Term.app">
            <IdentNode start="(226, 51)" end="(226, 60)" leading="" trailing=" " raw_val="lex_asymm" val="lex_asymm" full_name="List.lex_asymm" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(212, 9)" def_end="(212, 18)"/>
            <NullNode start="(226, 61)" end="(226, 76)">
              <OtherNode start="(226, 61)" end="(226, 74)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(226, 61)" end="(226, 62)" leading="" trailing="" val="("/>
                <OtherNode start="(226, 62)" end="(226, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(226, 62)" end="(226, 69)" leading="" trailing=" " raw_val="i.asymm" val="i.asymm"/>
                  <NullNode start="(226, 70)" end="(226, 73)">
                    <TermHoleNode start="(226, 70)" end="(226, 71)">
                      <AtomNode start="(226, 70)" end="(226, 71)" leading="" trailing=" " val="_"/>
                    </TermHoleNode>
                    <TermHoleNode start="(226, 72)" end="(226, 73)">
                      <AtomNode start="(226, 72)" end="(226, 73)" leading="" trailing="" val="_"/>
                    </TermHoleNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(226, 73)" end="(226, 74)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <IdentNode start="(226, 75)" end="(226, 76)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(228, 1)" end="(230, 29)">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandInstanceNode start="(228, 1)" end="(230, 29)">
        <TermAttrkindNode>
          <NullNode/>
        </TermAttrkindNode>
        <AtomNode start="(228, 1)" end="(228, 9)" leading="" trailing=" " val="instance"/>
        <NullNode/>
        <NullNode/>
        <CommandDeclsigNode start="(228, 10)" end="(229, 47)">
          <NullNode start="(228, 10)" end="(228, 51)">
            <OtherNode start="(228, 10)" end="(228, 16)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(228, 10)" end="(228, 11)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(228, 11)" end="(228, 15)" kind="Lean.Parser.Term.app">
                <IdentNode start="(228, 11)" end="(228, 13)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(228, 14)" end="(228, 15)">
                  <IdentNode start="(228, 14)" end="(228, 15)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(228, 15)" end="(228, 16)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(228, 17)" end="(228, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(228, 17)" end="(228, 18)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(228, 18)" end="(228, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(228, 18)" end="(228, 27)" leading="" trailing=" " raw_val="Std.Asymm" val="Std.Asymm" full_name="Std.Asymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(228, 28)" end="(228, 50)">
                  <OtherNode start="(228, 28)" end="(228, 50)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(228, 28)" end="(228, 29)" leading="" trailing="" val="("/>
                    <OtherNode start="(228, 29)" end="(228, 34)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(228, 29)" end="(228, 30)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(228, 29)" end="(228, 30)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(228, 31)" end="(228, 32)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(228, 33)" end="(228, 34)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(228, 33)" end="(228, 34)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(228, 35)" end="(228, 36)" leading="" trailing=" " val=":"/>
                    <NullNode start="(228, 37)" end="(228, 49)">
                      <OtherNode start="(228, 37)" end="(228, 49)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(228, 37)" end="(228, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(228, 39)" end="(228, 40)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(228, 41)" end="(228, 49)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(228, 41)" end="(228, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(228, 43)" end="(228, 44)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(228, 45)" end="(228, 49)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(228, 45)" end="(228, 49)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(228, 49)" end="(228, 50)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(228, 50)" end="(228, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(228, 52)" end="(229, 47)">
            <AtomNode start="(228, 52)" end="(228, 53)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(229, 5)" end="(229, 47)" kind="Lean.Parser.Term.app">
              <IdentNode start="(229, 5)" end="(229, 14)" leading="" trailing=" " raw_val="Std.Asymm" val="Std.Asymm" full_name="Std.Asymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
              <NullNode start="(229, 15)" end="(229, 47)">
                <OtherNode start="(229, 15)" end="(229, 47)" kind="Lean.Parser.Term.typeAscription">
                  <AtomNode start="(229, 15)" end="(229, 16)" leading="" trailing="" val="("/>
                  <OtherNode start="(229, 16)" end="(229, 21)" kind="«term_&amp;lt;_»">
                    <OtherNode start="(229, 16)" end="(229, 17)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(229, 16)" end="(229, 17)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                    <AtomNode start="(229, 18)" end="(229, 19)" leading="" trailing=" " val="&amp;lt;"/>
                    <OtherNode start="(229, 20)" end="(229, 21)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(229, 20)" end="(229, 21)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(229, 22)" end="(229, 23)" leading="" trailing=" " val=":"/>
                  <NullNode start="(229, 24)" end="(229, 46)">
                    <OtherNode start="(229, 24)" end="(229, 46)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(229, 24)" end="(229, 30)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(229, 24)" end="(229, 28)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(229, 29)" end="(229, 30)">
                          <IdentNode start="(229, 29)" end="(229, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(229, 31)" end="(229, 32)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(229, 33)" end="(229, 46)" kind="Lean.Parser.Term.arrow">
                        <OtherNode start="(229, 33)" end="(229, 39)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(229, 33)" end="(229, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(229, 38)" end="(229, 39)">
                            <IdentNode start="(229, 38)" end="(229, 39)" leading="" trailing=" " raw_val="α" val="α"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(229, 40)" end="(229, 41)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(229, 42)" end="(229, 46)" kind="Lean.Parser.Term.prop">
                          <AtomNode start="(229, 42)" end="(229, 46)" leading="" trailing="" val="Prop"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(229, 46)" end="(229, 47)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandWherestructinstNode start="(229, 48)" end="(230, 29)">
          <AtomNode start="(229, 48)" end="(229, 53)" leading="" trailing="&#10;  " val="where"/>
          <OtherNode start="(230, 3)" end="(230, 29)" kind="Lean.Parser.Term.structInstFields">
            <NullNode start="(230, 3)" end="(230, 29)">
              <OtherNode start="(230, 3)" end="(230, 29)" kind="Lean.Parser.Term.structInstField">
                <OtherNode start="(230, 3)" end="(230, 8)" kind="Lean.Parser.Term.structInstLVal">
                  <IdentNode start="(230, 3)" end="(230, 8)" leading="" trailing=" " raw_val="asymm" val="asymm"/>
                  <NullNode/>
                </OtherNode>
                <NullNode start="(230, 9)" end="(230, 29)">
                  <NullNode start="(230, 9)" end="(230, 12)">
                    <TermHoleNode start="(230, 9)" end="(230, 10)">
                      <AtomNode start="(230, 9)" end="(230, 10)" leading="" trailing=" " val="_"/>
                    </TermHoleNode>
                    <TermHoleNode start="(230, 11)" end="(230, 12)">
                      <AtomNode start="(230, 11)" end="(230, 12)" leading="" trailing=" " val="_"/>
                    </TermHoleNode>
                  </NullNode>
                  <NullNode/>
                  <OtherNode start="(230, 13)" end="(230, 29)" kind="Lean.Parser.Term.structInstFieldDef">
                    <AtomNode start="(230, 13)" end="(230, 15)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(230, 16)" end="(230, 29)" leading="" trailing="&#10;&#10;" raw_val="List.lt_asymm" val="List.lt_asymm" full_name="List.lt_asymm" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(224, 19)" def_end="(224, 27)"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <NullNode/>
        </CommandWherestructinstNode>
      </CommandInstanceNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(232, 1)" end="(245, 62)" name="not_lex_total" full_name="List.not_lex_total">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(232, 1)" end="(245, 62)" name="not_lex_total" full_name="List.not_lex_total" _is_private_decl="False">
        <AtomNode start="(232, 1)" end="(232, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(232, 9)" end="(232, 22)">
          <IdentNode start="(232, 9)" end="(232, 22)" leading="" trailing=" " raw_val="not_lex_total" val="not_lex_total"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(232, 23)" end="(233, 88)">
          <NullNode start="(232, 23)" end="(233, 56)">
            <OtherNode start="(232, 23)" end="(232, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(232, 23)" end="(232, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(232, 24)" end="(232, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(232, 24)" end="(232, 35)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(232, 36)" end="(232, 37)">
                  <IdentNode start="(232, 36)" end="(232, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(232, 37)" end="(232, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(232, 39)" end="(232, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(232, 39)" end="(232, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(232, 40)" end="(232, 41)">
                <IdentNode start="(232, 40)" end="(232, 41)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(232, 42)" end="(232, 56)">
                <AtomNode start="(232, 42)" end="(232, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(232, 44)" end="(232, 56)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(232, 44)" end="(232, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(232, 46)" end="(232, 47)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(232, 48)" end="(232, 56)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(232, 48)" end="(232, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(232, 50)" end="(232, 51)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(232, 52)" end="(232, 56)" kind="Lean.Parser.Term.prop">
                      <AtomNode start="(232, 52)" end="(232, 56)" leading="" trailing="" val="Prop"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(232, 56)" end="(232, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(232, 58)" end="(232, 74)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(232, 58)" end="(232, 59)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(232, 59)" end="(232, 73)" kind="Lean.Parser.Term.app">
                <IdentNode start="(232, 59)" end="(232, 71)" leading="" trailing=" " raw_val="DecidableRel" val="DecidableRel" full_name="DecidableRel" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(232, 72)" end="(232, 73)">
                  <IdentNode start="(232, 72)" end="(232, 73)" leading="" trailing="" raw_val="r" val="r"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(232, 73)" end="(232, 74)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(233, 5)" end="(233, 39)">
              <AtomNode start="(233, 5)" end="(233, 6)" leading="" trailing="" val="("/>
              <NullNode start="(233, 6)" end="(233, 7)">
                <IdentNode start="(233, 6)" end="(233, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(233, 8)" end="(233, 38)">
                <AtomNode start="(233, 8)" end="(233, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(233, 10)" end="(233, 38)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(233, 10)" end="(233, 11)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(233, 12)" end="(233, 15)">
                    <IdentNode start="(233, 12)" end="(233, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(233, 14)" end="(233, 15)" leading="" trailing=" " raw_val="y" val="y"/>
                  </NullNode>
                  <NullNode start="(233, 16)" end="(233, 19)">
                    <TermTypespecNode start="(233, 16)" end="(233, 19)">
                      <AtomNode start="(233, 16)" end="(233, 17)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(233, 18)" end="(233, 19)" leading="" trailing="" raw_val="α" val="α"/>
                    </TermTypespecNode>
                  </NullNode>
                  <AtomNode start="(233, 19)" end="(233, 20)" leading="" trailing=" " val=","/>
                  <OtherNode start="(233, 21)" end="(233, 38)" kind="«term_∨_»">
                    <OtherNode start="(233, 21)" end="(233, 28)" kind="«term¬_»">
                      <AtomNode start="(233, 21)" end="(233, 22)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(233, 23)" end="(233, 28)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(233, 23)" end="(233, 24)" leading="" trailing=" " raw_val="r" val="r"/>
                        <NullNode start="(233, 25)" end="(233, 28)">
                          <IdentNode start="(233, 25)" end="(233, 26)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(233, 27)" end="(233, 28)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(233, 29)" end="(233, 30)" leading="" trailing=" " val="∨"/>
                    <OtherNode start="(233, 31)" end="(233, 38)" kind="«term¬_»">
                      <AtomNode start="(233, 31)" end="(233, 32)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(233, 33)" end="(233, 38)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(233, 33)" end="(233, 34)" leading="" trailing=" " raw_val="r" val="r"/>
                        <NullNode start="(233, 35)" end="(233, 38)">
                          <IdentNode start="(233, 35)" end="(233, 36)" leading="" trailing=" " raw_val="y" val="y"/>
                          <IdentNode start="(233, 37)" end="(233, 38)" leading="" trailing="" raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(233, 38)" end="(233, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(233, 40)" end="(233, 56)">
              <AtomNode start="(233, 40)" end="(233, 41)" leading="" trailing="" val="("/>
              <NullNode start="(233, 41)" end="(233, 46)">
                <IdentNode start="(233, 41)" end="(233, 43)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(233, 44)" end="(233, 46)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(233, 47)" end="(233, 55)">
                <AtomNode start="(233, 47)" end="(233, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(233, 49)" end="(233, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(233, 49)" end="(233, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(233, 54)" end="(233, 55)">
                    <IdentNode start="(233, 54)" end="(233, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(233, 55)" end="(233, 56)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(233, 57)" end="(233, 88)">
            <AtomNode start="(233, 57)" end="(233, 58)" leading="" trailing=" " val=":"/>
            <OtherNode start="(233, 59)" end="(233, 88)" kind="«term_∨_»">
              <OtherNode start="(233, 59)" end="(233, 72)" kind="«term¬_»">
                <AtomNode start="(233, 59)" end="(233, 60)" leading="" trailing=" " val="¬"/>
                <OtherNode start="(233, 61)" end="(233, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(233, 61)" end="(233, 64)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(233, 65)" end="(233, 72)">
                    <IdentNode start="(233, 65)" end="(233, 66)" leading="" trailing=" " raw_val="r" val="r"/>
                    <IdentNode start="(233, 67)" end="(233, 69)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(233, 70)" end="(233, 72)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(233, 73)" end="(233, 74)" leading="" trailing=" " val="∨"/>
              <OtherNode start="(233, 75)" end="(233, 88)" kind="«term¬_»">
                <AtomNode start="(233, 75)" end="(233, 76)" leading="" trailing=" " val="¬"/>
                <OtherNode start="(233, 77)" end="(233, 88)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(233, 77)" end="(233, 80)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(233, 81)" end="(233, 88)">
                    <IdentNode start="(233, 81)" end="(233, 82)" leading="" trailing=" " raw_val="r" val="r"/>
                    <IdentNode start="(233, 83)" end="(233, 85)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    <IdentNode start="(233, 86)" end="(233, 88)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(233, 89)" end="(245, 62)">
          <AtomNode start="(233, 89)" end="(233, 91)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(233, 92)" end="(245, 62)">
            <AtomNode start="(233, 92)" end="(233, 94)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(234, 3)" end="(245, 62)">
              <TacticTacticseq1IndentedNode start="(234, 3)" end="(245, 62)">
                <NullNode start="(234, 3)" end="(245, 62)">
                  <OtherNode start="(234, 3)" end="(234, 56)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : DecidableEq α&#10;r : α → α → Prop&#10;inst✝ : DecidableRel r&#10;h : ∀ (x y : α), ¬r x y ∨ ¬r y x&#10;l₁ l₂ : List α&#10;⊢ ¬Lex r l₁ l₂ ∨ ¬Lex r l₂ l₁" state_after="α : Type u_1&#10;inst✝¹ : DecidableEq α&#10;r : α → α → Prop&#10;inst✝ : DecidableRel r&#10;h : ∀ (x y : α), ¬r x y ∨ ¬r y x&#10;l₁ l₂ : List α&#10;⊢ Lex r l₁ l₂ → ¬Lex r l₂ l₁" tactic="rw [Decidable.or_iff_not_imp_left, Decidable.not_not]">
                    <AtomNode start="(234, 3)" end="(234, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(234, 6)" end="(234, 56)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(234, 6)" end="(234, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(234, 7)" end="(234, 55)">
                        <OtherNode start="(234, 7)" end="(234, 36)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(234, 7)" end="(234, 36)" leading="" trailing="" raw_val="Decidable.or_iff_not_imp_left" val="Decidable.or_iff_not_imp_left" full_name="Decidable.or_iff_not_imp_left" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(234, 36)" end="(234, 37)" leading="" trailing=" " val=","/>
                        <OtherNode start="(234, 38)" end="(234, 55)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(234, 38)" end="(234, 55)" leading="" trailing="" raw_val="Decidable.not_not" val="Decidable.not_not" full_name="Decidable.not_not" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(234, 55)" end="(234, 56)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(235, 3)" end="(235, 14)" kind="Lean.Parser.Tactic.intro" state_before="α : Type u_1&#10;inst✝¹ : DecidableEq α&#10;r : α → α → Prop&#10;inst✝ : DecidableRel r&#10;h : ∀ (x y : α), ¬r x y ∨ ¬r y x&#10;l₁ l₂ : List α&#10;⊢ Lex r l₁ l₂ → ¬Lex r l₂ l₁" state_after="α : Type u_1&#10;inst✝¹ : DecidableEq α&#10;r : α → α → Prop&#10;inst✝ : DecidableRel r&#10;h : ∀ (x y : α), ¬r x y ∨ ¬r y x&#10;l₁ l₂ : List α&#10;w₁ : Lex r l₁ l₂&#10;w₂ : Lex r l₂ l₁&#10;⊢ False" tactic="intro w₁ w₂">
                    <AtomNode start="(235, 3)" end="(235, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(235, 9)" end="(235, 14)">
                      <IdentNode start="(235, 9)" end="(235, 11)" leading="" trailing=" " raw_val="w₁" val="w₁"/>
                      <IdentNode start="(235, 12)" end="(235, 14)" leading="" trailing="&#10;  " raw_val="w₂" val="w₂"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(236, 3)" end="(245, 62)" kind="Lean.Parser.Tactic.match" state_before="α : Type u_1&#10;inst✝¹ : DecidableEq α&#10;r : α → α → Prop&#10;inst✝ : DecidableRel r&#10;h : ∀ (x y : α), ¬r x y ∨ ¬r y x&#10;l₁ l₂ : List α&#10;w₁ : Lex r l₁ l₂&#10;w₂ : Lex r l₂ l₁&#10;⊢ False" state_after="no goals" tactic="match l₁, l₂, w₁, w₂ with&#10;| nil, _ :: _, .nil, w₂ =&amp;gt; simp at w₂&#10;| x :: _, y :: _, .rel _, .rel _ =&amp;gt;&#10;  obtain (_ | _) := h x y &amp;lt;;&amp;gt; contradiction&#10;| x :: _, _ :: _, .rel _, .cons _ =&amp;gt;&#10;  obtain (_ | _) := h x x &amp;lt;;&amp;gt; contradiction&#10;| x :: _, _ :: _, .cons  _, .rel _ =&amp;gt;&#10;  obtain (_ | _) := h x x &amp;lt;;&amp;gt; contradiction&#10;| _ :: l₁, _ :: l₂, .cons _, .cons _ =&amp;gt;&#10;  obtain (_ | _) := not_lex_total h l₁ l₂ &amp;lt;;&amp;gt; contradiction">
                    <AtomNode start="(236, 3)" end="(236, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(236, 9)" end="(236, 23)">
                      <OtherNode start="(236, 9)" end="(236, 11)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(236, 9)" end="(236, 11)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(236, 11)" end="(236, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(236, 13)" end="(236, 15)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(236, 13)" end="(236, 15)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </OtherNode>
                      <AtomNode start="(236, 15)" end="(236, 16)" leading="" trailing=" " val=","/>
                      <OtherNode start="(236, 17)" end="(236, 19)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(236, 17)" end="(236, 19)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                      </OtherNode>
                      <AtomNode start="(236, 19)" end="(236, 20)" leading="" trailing=" " val=","/>
                      <OtherNode start="(236, 21)" end="(236, 23)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(236, 21)" end="(236, 23)" leading="" trailing=" " raw_val="w₂" val="w₂"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(236, 24)" end="(236, 28)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(237, 3)" end="(245, 62)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(237, 3)" end="(245, 62)">
                        <OtherNode start="(237, 3)" end="(237, 40)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(237, 3)" end="(237, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(237, 5)" end="(237, 26)">
                            <NullNode start="(237, 5)" end="(237, 26)">
                              <IdentNode start="(237, 5)" end="(237, 8)" leading="" trailing="" raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <AtomNode start="(237, 8)" end="(237, 9)" leading="" trailing=" " val=","/>
                              <OtherNode start="(237, 10)" end="(237, 16)" kind="«term_::_»">
                                <TermHoleNode start="(237, 10)" end="(237, 11)">
                                  <AtomNode start="(237, 10)" end="(237, 11)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(237, 12)" end="(237, 14)" leading="" trailing=" " val="::"/>
                                <TermHoleNode start="(237, 15)" end="(237, 16)">
                                  <AtomNode start="(237, 15)" end="(237, 16)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                              </OtherNode>
                              <AtomNode start="(237, 16)" end="(237, 17)" leading="" trailing=" " val=","/>
                              <OtherNode start="(237, 18)" end="(237, 22)" kind="Lean.Parser.Term.dotIdent">
                                <AtomNode start="(237, 18)" end="(237, 19)" leading="" trailing="" val="."/>
                                <IdentNode start="(237, 19)" end="(237, 22)" leading="" trailing="" raw_val="nil" val="nil"/>
                              </OtherNode>
                              <AtomNode start="(237, 22)" end="(237, 23)" leading="" trailing=" " val=","/>
                              <IdentNode start="(237, 24)" end="(237, 26)" leading="" trailing=" " raw_val="w₂" val="w₂"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(237, 27)" end="(237, 29)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(237, 30)" end="(237, 40)">
                            <TacticTacticseq1IndentedNode start="(237, 30)" end="(237, 40)">
                              <NullNode start="(237, 30)" end="(237, 40)">
                                <OtherNode start="(237, 30)" end="(237, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : DecidableEq α&#10;r : α → α → Prop&#10;inst✝ : DecidableRel r&#10;h : ∀ (x y : α), ¬r x y ∨ ¬r y x&#10;l₁ l₂ : List α&#10;w₁ : Lex r l₁ l₂&#10;w₂✝ : Lex r l₂ l₁&#10;head✝ : α&#10;tail✝ : List α&#10;w₂ : Lex r (head✝ :: tail✝) []&#10;⊢ False" state_after="no goals" tactic="simp at w₂">
                                  <AtomNode start="(237, 30)" end="(237, 34)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(237, 35)" end="(237, 40)">
                                    <OtherNode start="(237, 35)" end="(237, 40)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(237, 35)" end="(237, 37)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(237, 38)" end="(237, 40)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(237, 38)" end="(237, 40)">
                                          <IdentNode start="(237, 38)" end="(237, 40)" leading="" trailing="&#10;  " raw_val="w₂" val="w₂"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(238, 3)" end="(239, 46)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(238, 3)" end="(238, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(238, 5)" end="(238, 35)">
                            <NullNode start="(238, 5)" end="(238, 35)">
                              <OtherNode start="(238, 5)" end="(238, 11)" kind="«term_::_»">
                                <IdentNode start="(238, 5)" end="(238, 6)" leading="" trailing=" " raw_val="x" val="x"/>
                                <AtomNode start="(238, 7)" end="(238, 9)" leading="" trailing=" " val="::"/>
                                <TermHoleNode start="(238, 10)" end="(238, 11)">
                                  <AtomNode start="(238, 10)" end="(238, 11)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                              </OtherNode>
                              <AtomNode start="(238, 11)" end="(238, 12)" leading="" trailing=" " val=","/>
                              <OtherNode start="(238, 13)" end="(238, 19)" kind="«term_::_»">
                                <IdentNode start="(238, 13)" end="(238, 14)" leading="" trailing=" " raw_val="y" val="y"/>
                                <AtomNode start="(238, 15)" end="(238, 17)" leading="" trailing=" " val="::"/>
                                <TermHoleNode start="(238, 18)" end="(238, 19)">
                                  <AtomNode start="(238, 18)" end="(238, 19)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                              </OtherNode>
                              <AtomNode start="(238, 19)" end="(238, 20)" leading="" trailing=" " val=","/>
                              <OtherNode start="(238, 21)" end="(238, 27)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(238, 21)" end="(238, 25)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(238, 21)" end="(238, 22)" leading="" trailing="" val="."/>
                                  <IdentNode start="(238, 22)" end="(238, 25)" leading="" trailing=" " raw_val="rel" val="rel"/>
                                </OtherNode>
                                <NullNode start="(238, 26)" end="(238, 27)">
                                  <TermHoleNode start="(238, 26)" end="(238, 27)">
                                    <AtomNode start="(238, 26)" end="(238, 27)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(238, 27)" end="(238, 28)" leading="" trailing=" " val=","/>
                              <OtherNode start="(238, 29)" end="(238, 35)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(238, 29)" end="(238, 33)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(238, 29)" end="(238, 30)" leading="" trailing="" val="."/>
                                  <IdentNode start="(238, 30)" end="(238, 33)" leading="" trailing=" " raw_val="rel" val="rel"/>
                                </OtherNode>
                                <NullNode start="(238, 34)" end="(238, 35)">
                                  <TermHoleNode start="(238, 34)" end="(238, 35)">
                                    <AtomNode start="(238, 34)" end="(238, 35)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(238, 36)" end="(238, 38)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(239, 5)" end="(239, 46)">
                            <TacticTacticseq1IndentedNode start="(239, 5)" end="(239, 46)">
                              <NullNode start="(239, 5)" end="(239, 46)">
                                <OtherNode start="(239, 5)" end="(239, 46)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝¹ : DecidableEq α&#10;r : α → α → Prop&#10;inst✝ : DecidableRel r&#10;h : ∀ (x y : α), ¬r x y ∨ ¬r y x&#10;l₁ l₂ : List α&#10;w₁ : Lex r l₁ l₂&#10;w₂ : Lex r l₂ l₁&#10;x : α&#10;tail✝¹ : List α&#10;y : α&#10;tail✝ : List α&#10;h✝¹ : r x y&#10;h✝ : r y x&#10;⊢ False" state_after="no goals" tactic="obtain (_ | _) := h x y &amp;lt;;&amp;gt; contradiction">
                                  <OtherNode start="(239, 5)" end="(239, 28)" kind="Lean.Parser.Tactic.obtain">
                                    <AtomNode start="(239, 5)" end="(239, 11)" leading="" trailing=" " val="obtain"/>
                                    <NullNode start="(239, 12)" end="(239, 19)">
                                      <OtherNode start="(239, 12)" end="(239, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(239, 12)" end="(239, 19)">
                                          <OtherNode start="(239, 12)" end="(239, 19)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                            <AtomNode start="(239, 12)" end="(239, 13)" leading="" trailing="" val="("/>
                                            <OtherNode start="(239, 13)" end="(239, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(239, 13)" end="(239, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(239, 13)" end="(239, 18)">
                                                  <OtherNode start="(239, 13)" end="(239, 14)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                    <AtomNode start="(239, 13)" end="(239, 14)" leading="" trailing=" " val="_"/>
                                                  </OtherNode>
                                                  <AtomNode start="(239, 15)" end="(239, 16)" leading="" trailing=" " val="|"/>
                                                  <OtherNode start="(239, 17)" end="(239, 18)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                    <AtomNode start="(239, 17)" end="(239, 18)" leading="" trailing="" val="_"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(239, 18)" end="(239, 19)" leading="" trailing=" " val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode/>
                                    <NullNode start="(239, 20)" end="(239, 28)">
                                      <AtomNode start="(239, 20)" end="(239, 22)" leading="" trailing=" " val=":="/>
                                      <NullNode start="(239, 23)" end="(239, 28)">
                                        <OtherNode start="(239, 23)" end="(239, 28)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(239, 23)" end="(239, 24)" leading="" trailing=" " raw_val="h" val="h"/>
                                          <NullNode start="(239, 25)" end="(239, 28)">
                                            <IdentNode start="(239, 25)" end="(239, 26)" leading="" trailing=" " raw_val="x" val="x"/>
                                            <IdentNode start="(239, 27)" end="(239, 28)" leading="" trailing=" " raw_val="y" val="y"/>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(239, 29)" end="(239, 32)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                  <OtherNode start="(239, 33)" end="(239, 46)" kind="Lean.Parser.Tactic.contradiction">
                                    <AtomNode start="(239, 33)" end="(239, 46)" leading="" trailing="&#10;  " val="contradiction"/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(240, 3)" end="(241, 46)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(240, 3)" end="(240, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(240, 5)" end="(240, 36)">
                            <NullNode start="(240, 5)" end="(240, 36)">
                              <OtherNode start="(240, 5)" end="(240, 11)" kind="«term_::_»">
                                <IdentNode start="(240, 5)" end="(240, 6)" leading="" trailing=" " raw_val="x" val="x"/>
                                <AtomNode start="(240, 7)" end="(240, 9)" leading="" trailing=" " val="::"/>
                                <TermHoleNode start="(240, 10)" end="(240, 11)">
                                  <AtomNode start="(240, 10)" end="(240, 11)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                              </OtherNode>
                              <AtomNode start="(240, 11)" end="(240, 12)" leading="" trailing=" " val=","/>
                              <OtherNode start="(240, 13)" end="(240, 19)" kind="«term_::_»">
                                <TermHoleNode start="(240, 13)" end="(240, 14)">
                                  <AtomNode start="(240, 13)" end="(240, 14)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(240, 15)" end="(240, 17)" leading="" trailing=" " val="::"/>
                                <TermHoleNode start="(240, 18)" end="(240, 19)">
                                  <AtomNode start="(240, 18)" end="(240, 19)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                              </OtherNode>
                              <AtomNode start="(240, 19)" end="(240, 20)" leading="" trailing=" " val=","/>
                              <OtherNode start="(240, 21)" end="(240, 27)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(240, 21)" end="(240, 25)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(240, 21)" end="(240, 22)" leading="" trailing="" val="."/>
                                  <IdentNode start="(240, 22)" end="(240, 25)" leading="" trailing=" " raw_val="rel" val="rel"/>
                                </OtherNode>
                                <NullNode start="(240, 26)" end="(240, 27)">
                                  <TermHoleNode start="(240, 26)" end="(240, 27)">
                                    <AtomNode start="(240, 26)" end="(240, 27)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(240, 27)" end="(240, 28)" leading="" trailing=" " val=","/>
                              <OtherNode start="(240, 29)" end="(240, 36)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(240, 29)" end="(240, 34)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(240, 29)" end="(240, 30)" leading="" trailing="" val="."/>
                                  <IdentNode start="(240, 30)" end="(240, 34)" leading="" trailing=" " raw_val="cons" val="cons"/>
                                </OtherNode>
                                <NullNode start="(240, 35)" end="(240, 36)">
                                  <TermHoleNode start="(240, 35)" end="(240, 36)">
                                    <AtomNode start="(240, 35)" end="(240, 36)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(240, 37)" end="(240, 39)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(241, 5)" end="(241, 46)">
                            <TacticTacticseq1IndentedNode start="(241, 5)" end="(241, 46)">
                              <NullNode start="(241, 5)" end="(241, 46)">
                                <OtherNode start="(241, 5)" end="(241, 46)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝¹ : DecidableEq α&#10;r : α → α → Prop&#10;inst✝ : DecidableRel r&#10;h : ∀ (x y : α), ¬r x y ∨ ¬r y x&#10;l₁ l₂ : List α&#10;w₁ : Lex r l₁ l₂&#10;w₂ : Lex r l₂ l₁&#10;x : α&#10;tail✝¹ tail✝ : List α&#10;h✝¹ : r x x&#10;h✝ : Lex r tail✝ tail✝¹&#10;⊢ False" state_after="no goals" tactic="obtain (_ | _) := h x x &amp;lt;;&amp;gt; contradiction">
                                  <OtherNode start="(241, 5)" end="(241, 28)" kind="Lean.Parser.Tactic.obtain">
                                    <AtomNode start="(241, 5)" end="(241, 11)" leading="" trailing=" " val="obtain"/>
                                    <NullNode start="(241, 12)" end="(241, 19)">
                                      <OtherNode start="(241, 12)" end="(241, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(241, 12)" end="(241, 19)">
                                          <OtherNode start="(241, 12)" end="(241, 19)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                            <AtomNode start="(241, 12)" end="(241, 13)" leading="" trailing="" val="("/>
                                            <OtherNode start="(241, 13)" end="(241, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(241, 13)" end="(241, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(241, 13)" end="(241, 18)">
                                                  <OtherNode start="(241, 13)" end="(241, 14)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                    <AtomNode start="(241, 13)" end="(241, 14)" leading="" trailing=" " val="_"/>
                                                  </OtherNode>
                                                  <AtomNode start="(241, 15)" end="(241, 16)" leading="" trailing=" " val="|"/>
                                                  <OtherNode start="(241, 17)" end="(241, 18)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                    <AtomNode start="(241, 17)" end="(241, 18)" leading="" trailing="" val="_"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(241, 18)" end="(241, 19)" leading="" trailing=" " val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode/>
                                    <NullNode start="(241, 20)" end="(241, 28)">
                                      <AtomNode start="(241, 20)" end="(241, 22)" leading="" trailing=" " val=":="/>
                                      <NullNode start="(241, 23)" end="(241, 28)">
                                        <OtherNode start="(241, 23)" end="(241, 28)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(241, 23)" end="(241, 24)" leading="" trailing=" " raw_val="h" val="h"/>
                                          <NullNode start="(241, 25)" end="(241, 28)">
                                            <IdentNode start="(241, 25)" end="(241, 26)" leading="" trailing=" " raw_val="x" val="x"/>
                                            <IdentNode start="(241, 27)" end="(241, 28)" leading="" trailing=" " raw_val="x" val="x"/>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(241, 29)" end="(241, 32)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                  <OtherNode start="(241, 33)" end="(241, 46)" kind="Lean.Parser.Tactic.contradiction">
                                    <AtomNode start="(241, 33)" end="(241, 46)" leading="" trailing="&#10;  " val="contradiction"/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(242, 3)" end="(243, 46)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(242, 3)" end="(242, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(242, 5)" end="(242, 37)">
                            <NullNode start="(242, 5)" end="(242, 37)">
                              <OtherNode start="(242, 5)" end="(242, 11)" kind="«term_::_»">
                                <IdentNode start="(242, 5)" end="(242, 6)" leading="" trailing=" " raw_val="x" val="x"/>
                                <AtomNode start="(242, 7)" end="(242, 9)" leading="" trailing=" " val="::"/>
                                <TermHoleNode start="(242, 10)" end="(242, 11)">
                                  <AtomNode start="(242, 10)" end="(242, 11)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                              </OtherNode>
                              <AtomNode start="(242, 11)" end="(242, 12)" leading="" trailing=" " val=","/>
                              <OtherNode start="(242, 13)" end="(242, 19)" kind="«term_::_»">
                                <TermHoleNode start="(242, 13)" end="(242, 14)">
                                  <AtomNode start="(242, 13)" end="(242, 14)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(242, 15)" end="(242, 17)" leading="" trailing=" " val="::"/>
                                <TermHoleNode start="(242, 18)" end="(242, 19)">
                                  <AtomNode start="(242, 18)" end="(242, 19)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                              </OtherNode>
                              <AtomNode start="(242, 19)" end="(242, 20)" leading="" trailing=" " val=","/>
                              <OtherNode start="(242, 21)" end="(242, 29)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(242, 21)" end="(242, 26)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(242, 21)" end="(242, 22)" leading="" trailing="" val="."/>
                                  <IdentNode start="(242, 22)" end="(242, 26)" leading="" trailing="  " raw_val="cons" val="cons"/>
                                </OtherNode>
                                <NullNode start="(242, 28)" end="(242, 29)">
                                  <TermHoleNode start="(242, 28)" end="(242, 29)">
                                    <AtomNode start="(242, 28)" end="(242, 29)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(242, 29)" end="(242, 30)" leading="" trailing=" " val=","/>
                              <OtherNode start="(242, 31)" end="(242, 37)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(242, 31)" end="(242, 35)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(242, 31)" end="(242, 32)" leading="" trailing="" val="."/>
                                  <IdentNode start="(242, 32)" end="(242, 35)" leading="" trailing=" " raw_val="rel" val="rel"/>
                                </OtherNode>
                                <NullNode start="(242, 36)" end="(242, 37)">
                                  <TermHoleNode start="(242, 36)" end="(242, 37)">
                                    <AtomNode start="(242, 36)" end="(242, 37)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(242, 38)" end="(242, 40)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(243, 5)" end="(243, 46)">
                            <TacticTacticseq1IndentedNode start="(243, 5)" end="(243, 46)">
                              <NullNode start="(243, 5)" end="(243, 46)">
                                <OtherNode start="(243, 5)" end="(243, 46)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝¹ : DecidableEq α&#10;r : α → α → Prop&#10;inst✝ : DecidableRel r&#10;h : ∀ (x y : α), ¬r x y ∨ ¬r y x&#10;l₁ l₂ : List α&#10;w₁ : Lex r l₁ l₂&#10;w₂ : Lex r l₂ l₁&#10;x : α&#10;tail✝¹ tail✝ : List α&#10;h✝¹ : Lex r tail✝¹ tail✝&#10;h✝ : r x x&#10;⊢ False" state_after="no goals" tactic="obtain (_ | _) := h x x &amp;lt;;&amp;gt; contradiction">
                                  <OtherNode start="(243, 5)" end="(243, 28)" kind="Lean.Parser.Tactic.obtain">
                                    <AtomNode start="(243, 5)" end="(243, 11)" leading="" trailing=" " val="obtain"/>
                                    <NullNode start="(243, 12)" end="(243, 19)">
                                      <OtherNode start="(243, 12)" end="(243, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(243, 12)" end="(243, 19)">
                                          <OtherNode start="(243, 12)" end="(243, 19)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                            <AtomNode start="(243, 12)" end="(243, 13)" leading="" trailing="" val="("/>
                                            <OtherNode start="(243, 13)" end="(243, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(243, 13)" end="(243, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(243, 13)" end="(243, 18)">
                                                  <OtherNode start="(243, 13)" end="(243, 14)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                    <AtomNode start="(243, 13)" end="(243, 14)" leading="" trailing=" " val="_"/>
                                                  </OtherNode>
                                                  <AtomNode start="(243, 15)" end="(243, 16)" leading="" trailing=" " val="|"/>
                                                  <OtherNode start="(243, 17)" end="(243, 18)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                    <AtomNode start="(243, 17)" end="(243, 18)" leading="" trailing="" val="_"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(243, 18)" end="(243, 19)" leading="" trailing=" " val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode/>
                                    <NullNode start="(243, 20)" end="(243, 28)">
                                      <AtomNode start="(243, 20)" end="(243, 22)" leading="" trailing=" " val=":="/>
                                      <NullNode start="(243, 23)" end="(243, 28)">
                                        <OtherNode start="(243, 23)" end="(243, 28)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(243, 23)" end="(243, 24)" leading="" trailing=" " raw_val="h" val="h"/>
                                          <NullNode start="(243, 25)" end="(243, 28)">
                                            <IdentNode start="(243, 25)" end="(243, 26)" leading="" trailing=" " raw_val="x" val="x"/>
                                            <IdentNode start="(243, 27)" end="(243, 28)" leading="" trailing=" " raw_val="x" val="x"/>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(243, 29)" end="(243, 32)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                  <OtherNode start="(243, 33)" end="(243, 46)" kind="Lean.Parser.Tactic.contradiction">
                                    <AtomNode start="(243, 33)" end="(243, 46)" leading="" trailing="&#10;  " val="contradiction"/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(244, 3)" end="(245, 62)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(244, 3)" end="(244, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(244, 5)" end="(244, 39)">
                            <NullNode start="(244, 5)" end="(244, 39)">
                              <OtherNode start="(244, 5)" end="(244, 12)" kind="«term_::_»">
                                <TermHoleNode start="(244, 5)" end="(244, 6)">
                                  <AtomNode start="(244, 5)" end="(244, 6)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(244, 7)" end="(244, 9)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(244, 10)" end="(244, 12)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                              </OtherNode>
                              <AtomNode start="(244, 12)" end="(244, 13)" leading="" trailing=" " val=","/>
                              <OtherNode start="(244, 14)" end="(244, 21)" kind="«term_::_»">
                                <TermHoleNode start="(244, 14)" end="(244, 15)">
                                  <AtomNode start="(244, 14)" end="(244, 15)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(244, 16)" end="(244, 18)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(244, 19)" end="(244, 21)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                              </OtherNode>
                              <AtomNode start="(244, 21)" end="(244, 22)" leading="" trailing=" " val=","/>
                              <OtherNode start="(244, 23)" end="(244, 30)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(244, 23)" end="(244, 28)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(244, 23)" end="(244, 24)" leading="" trailing="" val="."/>
                                  <IdentNode start="(244, 24)" end="(244, 28)" leading="" trailing=" " raw_val="cons" val="cons"/>
                                </OtherNode>
                                <NullNode start="(244, 29)" end="(244, 30)">
                                  <TermHoleNode start="(244, 29)" end="(244, 30)">
                                    <AtomNode start="(244, 29)" end="(244, 30)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(244, 30)" end="(244, 31)" leading="" trailing=" " val=","/>
                              <OtherNode start="(244, 32)" end="(244, 39)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(244, 32)" end="(244, 37)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(244, 32)" end="(244, 33)" leading="" trailing="" val="."/>
                                  <IdentNode start="(244, 33)" end="(244, 37)" leading="" trailing=" " raw_val="cons" val="cons"/>
                                </OtherNode>
                                <NullNode start="(244, 38)" end="(244, 39)">
                                  <TermHoleNode start="(244, 38)" end="(244, 39)">
                                    <AtomNode start="(244, 38)" end="(244, 39)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(244, 40)" end="(244, 42)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(245, 5)" end="(245, 62)">
                            <TacticTacticseq1IndentedNode start="(245, 5)" end="(245, 62)">
                              <NullNode start="(245, 5)" end="(245, 62)">
                                <OtherNode start="(245, 5)" end="(245, 62)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝¹ : DecidableEq α&#10;r : α → α → Prop&#10;inst✝ : DecidableRel r&#10;h : ∀ (x y : α), ¬r x y ∨ ¬r y x&#10;l₁✝ l₂✝ : List α&#10;w₁ : Lex r l₁✝ l₂✝&#10;w₂ : Lex r l₂✝ l₁✝&#10;head✝ : α&#10;l₁ l₂ : List α&#10;h✝¹ : Lex r l₁ l₂&#10;h✝ : Lex r l₂ l₁&#10;⊢ False" state_after="no goals" tactic="obtain (_ | _) := not_lex_total h l₁ l₂ &amp;lt;;&amp;gt; contradiction">
                                  <OtherNode start="(245, 5)" end="(245, 44)" kind="Lean.Parser.Tactic.obtain">
                                    <AtomNode start="(245, 5)" end="(245, 11)" leading="" trailing=" " val="obtain"/>
                                    <NullNode start="(245, 12)" end="(245, 19)">
                                      <OtherNode start="(245, 12)" end="(245, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(245, 12)" end="(245, 19)">
                                          <OtherNode start="(245, 12)" end="(245, 19)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                            <AtomNode start="(245, 12)" end="(245, 13)" leading="" trailing="" val="("/>
                                            <OtherNode start="(245, 13)" end="(245, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(245, 13)" end="(245, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(245, 13)" end="(245, 18)">
                                                  <OtherNode start="(245, 13)" end="(245, 14)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                    <AtomNode start="(245, 13)" end="(245, 14)" leading="" trailing=" " val="_"/>
                                                  </OtherNode>
                                                  <AtomNode start="(245, 15)" end="(245, 16)" leading="" trailing=" " val="|"/>
                                                  <OtherNode start="(245, 17)" end="(245, 18)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                    <AtomNode start="(245, 17)" end="(245, 18)" leading="" trailing="" val="_"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(245, 18)" end="(245, 19)" leading="" trailing=" " val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode/>
                                    <NullNode start="(245, 20)" end="(245, 44)">
                                      <AtomNode start="(245, 20)" end="(245, 22)" leading="" trailing=" " val=":="/>
                                      <NullNode start="(245, 23)" end="(245, 44)">
                                        <OtherNode start="(245, 23)" end="(245, 44)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(245, 23)" end="(245, 36)" leading="" trailing=" " raw_val="not_lex_total" val="not_lex_total"/>
                                          <NullNode start="(245, 37)" end="(245, 44)">
                                            <IdentNode start="(245, 37)" end="(245, 38)" leading="" trailing=" " raw_val="h" val="h"/>
                                            <IdentNode start="(245, 39)" end="(245, 41)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                            <IdentNode start="(245, 42)" end="(245, 44)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(245, 45)" end="(245, 48)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                  <OtherNode start="(245, 49)" end="(245, 62)" kind="Lean.Parser.Tactic.contradiction">
                                    <AtomNode start="(245, 49)" end="(245, 62)" leading="" trailing="&#10;&#10;" val="contradiction"/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(247, 1)" end="(249, 30)" name="le_total" full_name="List.le_total">
      <CommandDeclmodifiersNode start="(247, 1)" end="(247, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(247, 1)" end="(247, 10)">
          <OtherNode start="(247, 1)" end="(247, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(247, 1)" end="(247, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(247, 11)" end="(249, 30)" name="le_total" full_name="List.le_total" _is_private_decl="False">
        <AtomNode start="(247, 11)" end="(247, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(247, 19)" end="(247, 27)">
          <IdentNode start="(247, 19)" end="(247, 27)" leading="" trailing=" " raw_val="le_total" val="le_total"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(247, 28)" end="(248, 82)">
          <NullNode start="(247, 28)" end="(248, 62)">
            <OtherNode start="(247, 28)" end="(247, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(247, 28)" end="(247, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(247, 29)" end="(247, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(247, 29)" end="(247, 40)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(247, 41)" end="(247, 42)">
                  <IdentNode start="(247, 41)" end="(247, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(247, 42)" end="(247, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(247, 44)" end="(247, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(247, 44)" end="(247, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(247, 45)" end="(247, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(247, 45)" end="(247, 47)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(247, 48)" end="(247, 49)">
                  <IdentNode start="(247, 48)" end="(247, 49)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(247, 49)" end="(247, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(247, 51)" end="(247, 66)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(247, 51)" end="(247, 52)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(247, 52)" end="(247, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(247, 52)" end="(247, 63)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(247, 64)" end="(247, 65)">
                  <IdentNode start="(247, 64)" end="(247, 65)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(247, 65)" end="(247, 66)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(248, 5)" end="(248, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(248, 5)" end="(248, 6)" leading="" trailing="" val="["/>
              <NullNode start="(248, 6)" end="(248, 9)">
                <IdentNode start="(248, 6)" end="(248, 7)" leading="" trailing=" " raw_val="i" val="i"/>
                <AtomNode start="(248, 8)" end="(248, 9)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(248, 10)" end="(248, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(248, 10)" end="(248, 19)" leading="" trailing=" " raw_val="Std.Total" val="Std.Total" full_name="Std.Total" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(248, 20)" end="(248, 44)">
                  <OtherNode start="(248, 20)" end="(248, 44)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(248, 20)" end="(248, 21)" leading="" trailing="" val="("/>
                    <OtherNode start="(248, 21)" end="(248, 28)" kind="«term¬_»">
                      <AtomNode start="(248, 21)" end="(248, 22)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(248, 23)" end="(248, 28)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(248, 23)" end="(248, 24)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(248, 23)" end="(248, 24)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(248, 25)" end="(248, 26)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(248, 27)" end="(248, 28)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(248, 27)" end="(248, 28)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(248, 29)" end="(248, 30)" leading="" trailing=" " val=":"/>
                    <NullNode start="(248, 31)" end="(248, 43)">
                      <OtherNode start="(248, 31)" end="(248, 43)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(248, 31)" end="(248, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(248, 33)" end="(248, 34)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(248, 35)" end="(248, 43)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(248, 35)" end="(248, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(248, 37)" end="(248, 38)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(248, 39)" end="(248, 43)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(248, 39)" end="(248, 43)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(248, 43)" end="(248, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(248, 44)" end="(248, 45)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(248, 46)" end="(248, 62)">
              <AtomNode start="(248, 46)" end="(248, 47)" leading="" trailing="" val="("/>
              <NullNode start="(248, 47)" end="(248, 52)">
                <IdentNode start="(248, 47)" end="(248, 49)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(248, 50)" end="(248, 52)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(248, 53)" end="(248, 61)">
                <AtomNode start="(248, 53)" end="(248, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(248, 55)" end="(248, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(248, 55)" end="(248, 59)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(248, 60)" end="(248, 61)">
                    <IdentNode start="(248, 60)" end="(248, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(248, 61)" end="(248, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(248, 63)" end="(248, 82)">
            <AtomNode start="(248, 63)" end="(248, 64)" leading="" trailing=" " val=":"/>
            <OtherNode start="(248, 65)" end="(248, 82)" kind="«term_∨_»">
              <OtherNode start="(248, 65)" end="(248, 72)" kind="«term_≤_»">
                <IdentNode start="(248, 65)" end="(248, 67)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(248, 68)" end="(248, 69)" leading="" trailing=" " val="≤"/>
                <IdentNode start="(248, 70)" end="(248, 72)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
              <AtomNode start="(248, 73)" end="(248, 74)" leading="" trailing=" " val="∨"/>
              <OtherNode start="(248, 75)" end="(248, 82)" kind="«term_≤_»">
                <IdentNode start="(248, 75)" end="(248, 77)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                <AtomNode start="(248, 78)" end="(248, 79)" leading="" trailing=" " val="≤"/>
                <IdentNode start="(248, 80)" end="(248, 82)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(248, 83)" end="(249, 30)">
          <AtomNode start="(248, 83)" end="(248, 85)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(249, 3)" end="(249, 30)" kind="Lean.Parser.Term.app">
            <IdentNode start="(249, 3)" end="(249, 16)" leading="" trailing=" " raw_val="not_lex_total" val="not_lex_total" full_name="List.not_lex_total" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(232, 9)" def_end="(232, 22)"/>
            <NullNode start="(249, 17)" end="(249, 30)">
              <IdentNode start="(249, 17)" end="(249, 24)" leading="" trailing=" " raw_val="i.total" val="i.total"/>
              <IdentNode start="(249, 25)" end="(249, 27)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              <IdentNode start="(249, 28)" end="(249, 30)" leading="" trailing="&#10;&#10;" raw_val="l₁" val="l₁"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(251, 1)" end="(254, 25)">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandInstanceNode start="(251, 1)" end="(254, 25)">
        <TermAttrkindNode>
          <NullNode/>
        </TermAttrkindNode>
        <AtomNode start="(251, 1)" end="(251, 9)" leading="" trailing=" " val="instance"/>
        <NullNode/>
        <NullNode/>
        <CommandDeclsigNode start="(251, 10)" end="(253, 47)">
          <NullNode start="(251, 10)" end="(252, 41)">
            <OtherNode start="(251, 10)" end="(251, 25)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(251, 10)" end="(251, 11)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(251, 11)" end="(251, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(251, 11)" end="(251, 22)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(251, 23)" end="(251, 24)">
                  <IdentNode start="(251, 23)" end="(251, 24)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(251, 24)" end="(251, 25)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(251, 26)" end="(251, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(251, 26)" end="(251, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(251, 27)" end="(251, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(251, 27)" end="(251, 29)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(251, 30)" end="(251, 31)">
                  <IdentNode start="(251, 30)" end="(251, 31)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(251, 31)" end="(251, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(251, 33)" end="(251, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(251, 33)" end="(251, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(251, 34)" end="(251, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(251, 34)" end="(251, 45)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(251, 46)" end="(251, 47)">
                  <IdentNode start="(251, 46)" end="(251, 47)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(251, 47)" end="(251, 48)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(252, 5)" end="(252, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(252, 5)" end="(252, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(252, 6)" end="(252, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(252, 6)" end="(252, 15)" leading="" trailing=" " raw_val="Std.Total" val="Std.Total" full_name="Std.Total" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(252, 16)" end="(252, 40)">
                  <OtherNode start="(252, 16)" end="(252, 40)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(252, 16)" end="(252, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(252, 17)" end="(252, 24)" kind="«term¬_»">
                      <AtomNode start="(252, 17)" end="(252, 18)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(252, 19)" end="(252, 24)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(252, 19)" end="(252, 20)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(252, 19)" end="(252, 20)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(252, 21)" end="(252, 22)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(252, 23)" end="(252, 24)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(252, 23)" end="(252, 24)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(252, 25)" end="(252, 26)" leading="" trailing=" " val=":"/>
                    <NullNode start="(252, 27)" end="(252, 39)">
                      <OtherNode start="(252, 27)" end="(252, 39)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(252, 27)" end="(252, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(252, 29)" end="(252, 30)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(252, 31)" end="(252, 39)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(252, 31)" end="(252, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(252, 33)" end="(252, 34)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(252, 35)" end="(252, 39)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(252, 35)" end="(252, 39)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(252, 39)" end="(252, 40)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(252, 40)" end="(252, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(252, 42)" end="(253, 47)">
            <AtomNode start="(252, 42)" end="(252, 43)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(253, 5)" end="(253, 47)" kind="Lean.Parser.Term.app">
              <IdentNode start="(253, 5)" end="(253, 14)" leading="" trailing=" " raw_val="Std.Total" val="Std.Total" full_name="Std.Total" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
              <NullNode start="(253, 15)" end="(253, 47)">
                <OtherNode start="(253, 15)" end="(253, 47)" kind="Lean.Parser.Term.typeAscription">
                  <AtomNode start="(253, 15)" end="(253, 16)" leading="" trailing="" val="("/>
                  <OtherNode start="(253, 16)" end="(253, 21)" kind="«term_≤_»">
                    <OtherNode start="(253, 16)" end="(253, 17)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(253, 16)" end="(253, 17)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                    <AtomNode start="(253, 18)" end="(253, 19)" leading="" trailing=" " val="≤"/>
                    <OtherNode start="(253, 20)" end="(253, 21)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(253, 20)" end="(253, 21)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(253, 22)" end="(253, 23)" leading="" trailing=" " val=":"/>
                  <NullNode start="(253, 24)" end="(253, 46)">
                    <OtherNode start="(253, 24)" end="(253, 46)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(253, 24)" end="(253, 30)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(253, 24)" end="(253, 28)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(253, 29)" end="(253, 30)">
                          <IdentNode start="(253, 29)" end="(253, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(253, 31)" end="(253, 32)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(253, 33)" end="(253, 46)" kind="Lean.Parser.Term.arrow">
                        <OtherNode start="(253, 33)" end="(253, 39)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(253, 33)" end="(253, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(253, 38)" end="(253, 39)">
                            <IdentNode start="(253, 38)" end="(253, 39)" leading="" trailing=" " raw_val="α" val="α"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(253, 40)" end="(253, 41)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(253, 42)" end="(253, 46)" kind="Lean.Parser.Term.prop">
                          <AtomNode start="(253, 42)" end="(253, 46)" leading="" trailing="" val="Prop"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(253, 46)" end="(253, 47)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandWherestructinstNode start="(253, 48)" end="(254, 25)">
          <AtomNode start="(253, 48)" end="(253, 53)" leading="" trailing="&#10;  " val="where"/>
          <OtherNode start="(254, 3)" end="(254, 25)" kind="Lean.Parser.Term.structInstFields">
            <NullNode start="(254, 3)" end="(254, 25)">
              <OtherNode start="(254, 3)" end="(254, 25)" kind="Lean.Parser.Term.structInstField">
                <OtherNode start="(254, 3)" end="(254, 8)" kind="Lean.Parser.Term.structInstLVal">
                  <IdentNode start="(254, 3)" end="(254, 8)" leading="" trailing=" " raw_val="total" val="total"/>
                  <NullNode/>
                </OtherNode>
                <NullNode start="(254, 9)" end="(254, 25)">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(254, 9)" end="(254, 25)" kind="Lean.Parser.Term.structInstFieldDef">
                    <AtomNode start="(254, 9)" end="(254, 11)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(254, 12)" end="(254, 25)" leading="" trailing="&#10;&#10;" raw_val="List.le_total" val="List.le_total" full_name="List.le_total" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(247, 19)" def_end="(247, 27)"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <NullNode/>
        </CommandWherestructinstNode>
      </CommandInstanceNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(256, 1)" end="(257, 54)" name="not_lt" full_name="List.not_lt">
      <CommandDeclmodifiersNode start="(256, 1)" end="(256, 18)">
        <NullNode/>
        <NullNode start="(256, 1)" end="(256, 8)">
          <OtherNode start="(256, 1)" end="(256, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(256, 1)" end="(256, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(256, 3)" end="(256, 7)">
              <OtherNode start="(256, 3)" end="(256, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(256, 3)" end="(256, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(256, 3)" end="(256, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(256, 7)" end="(256, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode start="(256, 9)" end="(256, 18)">
          <OtherNode start="(256, 9)" end="(256, 18)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(256, 9)" end="(256, 18)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(256, 19)" end="(257, 54)" name="not_lt" full_name="List.not_lt" _is_private_decl="False">
        <AtomNode start="(256, 19)" end="(256, 26)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(256, 27)" end="(256, 33)">
          <IdentNode start="(256, 27)" end="(256, 33)" leading="" trailing=" " raw_val="not_lt" val="not_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(256, 34)" end="(257, 43)">
          <NullNode start="(256, 34)" end="(257, 21)">
            <OtherNode start="(256, 34)" end="(256, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(256, 34)" end="(256, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(256, 35)" end="(256, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(256, 35)" end="(256, 37)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(256, 38)" end="(256, 39)">
                  <IdentNode start="(256, 38)" end="(256, 39)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(256, 39)" end="(256, 40)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(257, 5)" end="(257, 21)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(257, 5)" end="(257, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(257, 6)" end="(257, 11)">
                <IdentNode start="(257, 6)" end="(257, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(257, 9)" end="(257, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(257, 12)" end="(257, 20)">
                <AtomNode start="(257, 12)" end="(257, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(257, 14)" end="(257, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(257, 14)" end="(257, 18)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(257, 19)" end="(257, 20)">
                    <IdentNode start="(257, 19)" end="(257, 20)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(257, 20)" end="(257, 21)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(257, 22)" end="(257, 43)">
            <AtomNode start="(257, 22)" end="(257, 23)" leading="" trailing=" " val=":"/>
            <OtherNode start="(257, 24)" end="(257, 43)" kind="«term_↔_»">
              <OtherNode start="(257, 24)" end="(257, 33)" kind="«term¬_»">
                <AtomNode start="(257, 24)" end="(257, 25)" leading="" trailing=" " val="¬"/>
                <OtherNode start="(257, 26)" end="(257, 33)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(257, 26)" end="(257, 28)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(257, 29)" end="(257, 30)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(257, 31)" end="(257, 33)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(257, 34)" end="(257, 35)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(257, 36)" end="(257, 43)" kind="«term_≤_»">
                <IdentNode start="(257, 36)" end="(257, 38)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                <AtomNode start="(257, 39)" end="(257, 40)" leading="" trailing=" " val="≤"/>
                <IdentNode start="(257, 41)" end="(257, 43)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(257, 44)" end="(257, 54)">
          <AtomNode start="(257, 44)" end="(257, 46)" leading="" trailing=" " val=":="/>
          <IdentNode start="(257, 47)" end="(257, 54)" leading="" trailing="&#10;&#10;" raw_val="Iff.rfl" val="Iff.rfl" full_name="Iff.rfl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(259, 1)" end="(260, 64)" name="not_le" full_name="List.not_le">
      <CommandDeclmodifiersNode start="(259, 1)" end="(259, 18)">
        <NullNode/>
        <NullNode start="(259, 1)" end="(259, 8)">
          <OtherNode start="(259, 1)" end="(259, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(259, 1)" end="(259, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(259, 3)" end="(259, 7)">
              <OtherNode start="(259, 3)" end="(259, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(259, 3)" end="(259, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(259, 3)" end="(259, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(259, 7)" end="(259, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode start="(259, 9)" end="(259, 18)">
          <OtherNode start="(259, 9)" end="(259, 18)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(259, 9)" end="(259, 18)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(259, 19)" end="(260, 64)" name="not_le" full_name="List.not_le" _is_private_decl="False">
        <AtomNode start="(259, 19)" end="(259, 26)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(259, 27)" end="(259, 33)">
          <IdentNode start="(259, 27)" end="(259, 33)" leading="" trailing=" " raw_val="not_le" val="not_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(259, 34)" end="(260, 43)">
          <NullNode start="(259, 34)" end="(260, 21)">
            <OtherNode start="(259, 34)" end="(259, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(259, 34)" end="(259, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(259, 35)" end="(259, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(259, 35)" end="(259, 46)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(259, 47)" end="(259, 48)">
                  <IdentNode start="(259, 47)" end="(259, 48)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(259, 48)" end="(259, 49)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(259, 50)" end="(259, 56)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(259, 50)" end="(259, 51)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(259, 51)" end="(259, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(259, 51)" end="(259, 53)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(259, 54)" end="(259, 55)">
                  <IdentNode start="(259, 54)" end="(259, 55)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(259, 55)" end="(259, 56)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(259, 57)" end="(259, 72)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(259, 57)" end="(259, 58)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(259, 58)" end="(259, 71)" kind="Lean.Parser.Term.app">
                <IdentNode start="(259, 58)" end="(259, 69)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(259, 70)" end="(259, 71)">
                  <IdentNode start="(259, 70)" end="(259, 71)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(259, 71)" end="(259, 72)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(260, 5)" end="(260, 21)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(260, 5)" end="(260, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(260, 6)" end="(260, 11)">
                <IdentNode start="(260, 6)" end="(260, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(260, 9)" end="(260, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(260, 12)" end="(260, 20)">
                <AtomNode start="(260, 12)" end="(260, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(260, 14)" end="(260, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(260, 14)" end="(260, 18)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(260, 19)" end="(260, 20)">
                    <IdentNode start="(260, 19)" end="(260, 20)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(260, 20)" end="(260, 21)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(260, 22)" end="(260, 43)">
            <AtomNode start="(260, 22)" end="(260, 23)" leading="" trailing=" " val=":"/>
            <OtherNode start="(260, 24)" end="(260, 43)" kind="«term_↔_»">
              <OtherNode start="(260, 24)" end="(260, 33)" kind="«term¬_»">
                <AtomNode start="(260, 24)" end="(260, 25)" leading="" trailing=" " val="¬"/>
                <OtherNode start="(260, 26)" end="(260, 33)" kind="«term_≤_»">
                  <IdentNode start="(260, 26)" end="(260, 28)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  <AtomNode start="(260, 29)" end="(260, 30)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(260, 31)" end="(260, 33)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(260, 34)" end="(260, 35)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(260, 36)" end="(260, 43)" kind="«term_&amp;lt;_»">
                <IdentNode start="(260, 36)" end="(260, 38)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(260, 39)" end="(260, 40)" leading="" trailing=" " val="&amp;lt;"/>
                <IdentNode start="(260, 41)" end="(260, 43)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(260, 44)" end="(260, 64)">
          <AtomNode start="(260, 44)" end="(260, 46)" leading="" trailing=" " val=":="/>
          <IdentNode start="(260, 47)" end="(260, 64)" leading="" trailing="&#10;&#10;" raw_val="Decidable.not_not" val="Decidable.not_not" full_name="Decidable.not_not" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(262, 1)" end="(268, 15)" name="le_of_lt" full_name="List.le_of_lt">
      <CommandDeclmodifiersNode start="(262, 1)" end="(262, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(262, 1)" end="(262, 10)">
          <OtherNode start="(262, 1)" end="(262, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(262, 1)" end="(262, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(262, 11)" end="(268, 15)" name="le_of_lt" full_name="List.le_of_lt" _is_private_decl="False">
        <AtomNode start="(262, 11)" end="(262, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(262, 19)" end="(262, 27)">
          <IdentNode start="(262, 19)" end="(262, 27)" leading="" trailing=" " raw_val="le_of_lt" val="le_of_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(262, 28)" end="(264, 45)">
          <NullNode start="(262, 28)" end="(264, 35)">
            <OtherNode start="(262, 28)" end="(262, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(262, 28)" end="(262, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(262, 29)" end="(262, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(262, 29)" end="(262, 40)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(262, 41)" end="(262, 42)">
                  <IdentNode start="(262, 41)" end="(262, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(262, 42)" end="(262, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(262, 44)" end="(262, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(262, 44)" end="(262, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(262, 45)" end="(262, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(262, 45)" end="(262, 47)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(262, 48)" end="(262, 49)">
                  <IdentNode start="(262, 48)" end="(262, 49)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(262, 49)" end="(262, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(262, 51)" end="(262, 66)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(262, 51)" end="(262, 52)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(262, 52)" end="(262, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(262, 52)" end="(262, 63)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(262, 64)" end="(262, 65)">
                  <IdentNode start="(262, 64)" end="(262, 65)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(262, 65)" end="(262, 66)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(263, 5)" end="(263, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(263, 5)" end="(263, 6)" leading="" trailing="" val="["/>
              <NullNode start="(263, 6)" end="(263, 9)">
                <IdentNode start="(263, 6)" end="(263, 7)" leading="" trailing=" " raw_val="i" val="i"/>
                <AtomNode start="(263, 8)" end="(263, 9)" leading="" trailing=" " val=":"/>
              </NullNode>
              <OtherNode start="(263, 10)" end="(263, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(263, 10)" end="(263, 19)" leading="" trailing=" " raw_val="Std.Total" val="Std.Total" full_name="Std.Total" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(263, 20)" end="(263, 44)">
                  <OtherNode start="(263, 20)" end="(263, 44)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(263, 20)" end="(263, 21)" leading="" trailing="" val="("/>
                    <OtherNode start="(263, 21)" end="(263, 28)" kind="«term¬_»">
                      <AtomNode start="(263, 21)" end="(263, 22)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(263, 23)" end="(263, 28)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(263, 23)" end="(263, 24)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(263, 23)" end="(263, 24)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(263, 25)" end="(263, 26)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(263, 27)" end="(263, 28)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(263, 27)" end="(263, 28)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(263, 29)" end="(263, 30)" leading="" trailing=" " val=":"/>
                    <NullNode start="(263, 31)" end="(263, 43)">
                      <OtherNode start="(263, 31)" end="(263, 43)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(263, 31)" end="(263, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(263, 33)" end="(263, 34)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(263, 35)" end="(263, 43)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(263, 35)" end="(263, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(263, 37)" end="(263, 38)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(263, 39)" end="(263, 43)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(263, 39)" end="(263, 43)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(263, 43)" end="(263, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(263, 44)" end="(263, 45)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(264, 5)" end="(264, 21)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(264, 5)" end="(264, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(264, 6)" end="(264, 11)">
                <IdentNode start="(264, 6)" end="(264, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(264, 9)" end="(264, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(264, 12)" end="(264, 20)">
                <AtomNode start="(264, 12)" end="(264, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(264, 14)" end="(264, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(264, 14)" end="(264, 18)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(264, 19)" end="(264, 20)">
                    <IdentNode start="(264, 19)" end="(264, 20)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(264, 20)" end="(264, 21)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(264, 22)" end="(264, 35)">
              <AtomNode start="(264, 22)" end="(264, 23)" leading="" trailing="" val="("/>
              <NullNode start="(264, 23)" end="(264, 24)">
                <IdentNode start="(264, 23)" end="(264, 24)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(264, 25)" end="(264, 34)">
                <AtomNode start="(264, 25)" end="(264, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(264, 27)" end="(264, 34)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(264, 27)" end="(264, 29)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(264, 30)" end="(264, 31)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(264, 32)" end="(264, 34)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(264, 34)" end="(264, 35)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(264, 36)" end="(264, 45)">
            <AtomNode start="(264, 36)" end="(264, 37)" leading="" trailing=" " val=":"/>
            <OtherNode start="(264, 38)" end="(264, 45)" kind="«term_≤_»">
              <IdentNode start="(264, 38)" end="(264, 40)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              <AtomNode start="(264, 41)" end="(264, 42)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(264, 43)" end="(264, 45)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(264, 46)" end="(268, 15)">
          <AtomNode start="(264, 46)" end="(264, 48)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(264, 49)" end="(268, 15)">
            <AtomNode start="(264, 49)" end="(264, 51)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(265, 3)" end="(268, 15)">
              <TacticTacticseq1IndentedNode start="(265, 3)" end="(268, 15)">
                <NullNode start="(265, 3)" end="(268, 15)">
                  <OtherNode start="(265, 3)" end="(265, 42)" kind="Lean.Parser.Tactic.obtain" state_before="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt; l₂&#10;⊢ l₁ ≤ l₂" state_after="case inl&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt; l₂&#10;h' : l₁ ≤ l₂&#10;⊢ l₁ ≤ l₂&#10;&#10;case inr&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt; l₂&#10;h' : l₂ ≤ l₁&#10;⊢ l₁ ≤ l₂" tactic="obtain (h' | h') := List.le_total l₁ l₂">
                    <AtomNode start="(265, 3)" end="(265, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(265, 10)" end="(265, 19)">
                      <OtherNode start="(265, 10)" end="(265, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(265, 10)" end="(265, 19)">
                          <OtherNode start="(265, 10)" end="(265, 19)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                            <AtomNode start="(265, 10)" end="(265, 11)" leading="" trailing="" val="("/>
                            <OtherNode start="(265, 11)" end="(265, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                              <OtherNode start="(265, 11)" end="(265, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(265, 11)" end="(265, 18)">
                                  <OtherNode start="(265, 11)" end="(265, 13)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                    <IdentNode start="(265, 11)" end="(265, 13)" leading="" trailing=" " raw_val="h'" val="h'"/>
                                  </OtherNode>
                                  <AtomNode start="(265, 14)" end="(265, 15)" leading="" trailing=" " val="|"/>
                                  <OtherNode start="(265, 16)" end="(265, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                    <IdentNode start="(265, 16)" end="(265, 18)" leading="" trailing="" raw_val="h'" val="h'"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(265, 18)" end="(265, 19)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(265, 20)" end="(265, 42)">
                      <AtomNode start="(265, 20)" end="(265, 22)" leading="" trailing=" " val=":="/>
                      <NullNode start="(265, 23)" end="(265, 42)">
                        <OtherNode start="(265, 23)" end="(265, 42)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(265, 23)" end="(265, 36)" leading="" trailing=" " raw_val="List.le_total" val="List.le_total" full_name="List.le_total" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(247, 19)" def_end="(247, 27)"/>
                          <NullNode start="(265, 37)" end="(265, 42)">
                            <IdentNode start="(265, 37)" end="(265, 39)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                            <IdentNode start="(265, 40)" end="(265, 42)" leading="" trailing="&#10;  " raw_val="l₂" val="l₂"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(266, 3)" end="(266, 13)" kind="Lean.cdot" state_before="case inl&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt; l₂&#10;h' : l₁ ≤ l₂&#10;⊢ l₁ ≤ l₂&#10;&#10;case inr&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt; l₂&#10;h' : l₂ ≤ l₁&#10;⊢ l₁ ≤ l₂" state_after="case inr&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt; l₂&#10;h' : l₂ ≤ l₁&#10;⊢ l₁ ≤ l₂" tactic="· exact h'">
                    <OtherNode start="(266, 3)" end="(266, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(266, 3)" end="(266, 4)" kind="patternIgnore">
                        <OtherNode start="(266, 3)" end="(266, 4)" kind="token.«· »">
                          <AtomNode start="(266, 3)" end="(266, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(266, 5)" end="(266, 13)">
                      <TacticTacticseq1IndentedNode start="(266, 5)" end="(266, 13)">
                        <NullNode start="(266, 5)" end="(266, 13)">
                          <OtherNode start="(266, 5)" end="(266, 13)" kind="Lean.Parser.Tactic.exact" state_before="case inl&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt; l₂&#10;h' : l₁ ≤ l₂&#10;⊢ l₁ ≤ l₂" state_after="no goals" tactic="exact h'">
                            <AtomNode start="(266, 5)" end="(266, 10)" leading="" trailing=" " val="exact"/>
                            <IdentNode start="(266, 11)" end="(266, 13)" leading="" trailing="&#10;  " raw_val="h'" val="h'"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(267, 3)" end="(268, 15)" kind="Lean.cdot" state_before="case inr&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt; l₂&#10;h' : l₂ ≤ l₁&#10;⊢ l₁ ≤ l₂" state_after="no goals" tactic="· exfalso&#10;  exact h' h">
                    <OtherNode start="(267, 3)" end="(267, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(267, 3)" end="(267, 4)" kind="patternIgnore">
                        <OtherNode start="(267, 3)" end="(267, 4)" kind="token.«· »">
                          <AtomNode start="(267, 3)" end="(267, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(267, 5)" end="(268, 15)">
                      <TacticTacticseq1IndentedNode start="(267, 5)" end="(268, 15)">
                        <NullNode start="(267, 5)" end="(268, 15)">
                          <OtherNode start="(267, 5)" end="(267, 12)" kind="Lean.Parser.Tactic.tacticExfalso" state_before="case inr&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt; l₂&#10;h' : l₂ ≤ l₁&#10;⊢ l₁ ≤ l₂" state_after="case inr&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt; l₂&#10;h' : l₂ ≤ l₁&#10;⊢ False" tactic="exfalso">
                            <AtomNode start="(267, 5)" end="(267, 12)" leading="" trailing="&#10;    " val="exfalso"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(268, 5)" end="(268, 15)" kind="Lean.Parser.Tactic.exact" state_before="case inr&#10;α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;i : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt; l₂&#10;h' : l₂ ≤ l₁&#10;⊢ False" state_after="no goals" tactic="exact h' h">
                            <AtomNode start="(268, 5)" end="(268, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(268, 11)" end="(268, 15)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(268, 11)" end="(268, 13)" leading="" trailing=" " raw_val="h'" val="h'"/>
                              <NullNode start="(268, 14)" end="(268, 15)">
                                <IdentNode start="(268, 14)" end="(268, 15)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(270, 1)" end="(284, 28)" name="le_iff_lt_or_eq" full_name="List.le_iff_lt_or_eq">
      <CommandDeclmodifiersNode start="(270, 1)" end="(270, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(270, 1)" end="(270, 10)">
          <OtherNode start="(270, 1)" end="(270, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(270, 1)" end="(270, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(270, 11)" end="(284, 28)" name="le_iff_lt_or_eq" full_name="List.le_iff_lt_or_eq" _is_private_decl="False">
        <AtomNode start="(270, 11)" end="(270, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(270, 19)" end="(270, 34)">
          <IdentNode start="(270, 19)" end="(270, 34)" leading="" trailing=" " raw_val="le_iff_lt_or_eq" val="le_iff_lt_or_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(270, 35)" end="(274, 51)">
          <NullNode start="(270, 35)" end="(274, 21)">
            <OtherNode start="(270, 35)" end="(270, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(270, 35)" end="(270, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(270, 36)" end="(270, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(270, 36)" end="(270, 47)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(270, 48)" end="(270, 49)">
                  <IdentNode start="(270, 48)" end="(270, 49)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(270, 49)" end="(270, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(270, 51)" end="(270, 57)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(270, 51)" end="(270, 52)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(270, 52)" end="(270, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(270, 52)" end="(270, 54)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(270, 55)" end="(270, 56)">
                  <IdentNode start="(270, 55)" end="(270, 56)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(270, 56)" end="(270, 57)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(270, 58)" end="(270, 73)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(270, 58)" end="(270, 59)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(270, 59)" end="(270, 72)" kind="Lean.Parser.Term.app">
                <IdentNode start="(270, 59)" end="(270, 70)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(270, 71)" end="(270, 72)">
                  <IdentNode start="(270, 71)" end="(270, 72)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(270, 72)" end="(270, 73)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(271, 5)" end="(271, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(271, 5)" end="(271, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(271, 6)" end="(271, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(271, 6)" end="(271, 16)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(271, 17)" end="(271, 39)">
                  <OtherNode start="(271, 17)" end="(271, 39)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(271, 17)" end="(271, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(271, 18)" end="(271, 23)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(271, 18)" end="(271, 19)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(271, 18)" end="(271, 19)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(271, 20)" end="(271, 21)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(271, 22)" end="(271, 23)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(271, 22)" end="(271, 23)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(271, 24)" end="(271, 25)" leading="" trailing=" " val=":"/>
                    <NullNode start="(271, 26)" end="(271, 38)">
                      <OtherNode start="(271, 26)" end="(271, 38)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(271, 26)" end="(271, 27)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(271, 28)" end="(271, 29)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(271, 30)" end="(271, 38)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(271, 30)" end="(271, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(271, 32)" end="(271, 33)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(271, 34)" end="(271, 38)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(271, 34)" end="(271, 38)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(271, 38)" end="(271, 39)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(271, 39)" end="(271, 40)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(272, 5)" end="(272, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(272, 5)" end="(272, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(272, 6)" end="(272, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(272, 6)" end="(272, 18)" leading="" trailing=" " raw_val="Std.Antisymm" val="Std.Antisymm" full_name="Std.Antisymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(272, 19)" end="(272, 43)">
                  <OtherNode start="(272, 19)" end="(272, 43)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(272, 19)" end="(272, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(272, 20)" end="(272, 27)" kind="«term¬_»">
                      <AtomNode start="(272, 20)" end="(272, 21)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(272, 22)" end="(272, 27)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(272, 22)" end="(272, 23)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(272, 22)" end="(272, 23)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(272, 24)" end="(272, 25)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(272, 26)" end="(272, 27)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(272, 26)" end="(272, 27)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(272, 28)" end="(272, 29)" leading="" trailing=" " val=":"/>
                    <NullNode start="(272, 30)" end="(272, 42)">
                      <OtherNode start="(272, 30)" end="(272, 42)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(272, 30)" end="(272, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(272, 32)" end="(272, 33)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(272, 34)" end="(272, 42)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(272, 34)" end="(272, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(272, 36)" end="(272, 37)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(272, 38)" end="(272, 42)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(272, 38)" end="(272, 42)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(272, 42)" end="(272, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(272, 43)" end="(272, 44)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(273, 5)" end="(273, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(273, 5)" end="(273, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(273, 6)" end="(273, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(273, 6)" end="(273, 15)" leading="" trailing=" " raw_val="Std.Total" val="Std.Total" full_name="Std.Total" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(273, 16)" end="(273, 40)">
                  <OtherNode start="(273, 16)" end="(273, 40)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(273, 16)" end="(273, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(273, 17)" end="(273, 24)" kind="«term¬_»">
                      <AtomNode start="(273, 17)" end="(273, 18)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(273, 19)" end="(273, 24)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(273, 19)" end="(273, 20)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(273, 19)" end="(273, 20)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(273, 21)" end="(273, 22)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(273, 23)" end="(273, 24)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(273, 23)" end="(273, 24)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(273, 25)" end="(273, 26)" leading="" trailing=" " val=":"/>
                    <NullNode start="(273, 27)" end="(273, 39)">
                      <OtherNode start="(273, 27)" end="(273, 39)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(273, 27)" end="(273, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(273, 29)" end="(273, 30)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(273, 31)" end="(273, 39)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(273, 31)" end="(273, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(273, 33)" end="(273, 34)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(273, 35)" end="(273, 39)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(273, 35)" end="(273, 39)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(273, 39)" end="(273, 40)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(273, 40)" end="(273, 41)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(274, 5)" end="(274, 21)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(274, 5)" end="(274, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(274, 6)" end="(274, 11)">
                <IdentNode start="(274, 6)" end="(274, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(274, 9)" end="(274, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(274, 12)" end="(274, 20)">
                <AtomNode start="(274, 12)" end="(274, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(274, 14)" end="(274, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(274, 14)" end="(274, 18)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(274, 19)" end="(274, 20)">
                    <IdentNode start="(274, 19)" end="(274, 20)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(274, 20)" end="(274, 21)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(274, 22)" end="(274, 51)">
            <AtomNode start="(274, 22)" end="(274, 23)" leading="" trailing=" " val=":"/>
            <OtherNode start="(274, 24)" end="(274, 51)" kind="«term_↔_»">
              <OtherNode start="(274, 24)" end="(274, 31)" kind="«term_≤_»">
                <IdentNode start="(274, 24)" end="(274, 26)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(274, 27)" end="(274, 28)" leading="" trailing=" " val="≤"/>
                <IdentNode start="(274, 29)" end="(274, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
              <AtomNode start="(274, 32)" end="(274, 33)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(274, 34)" end="(274, 51)" kind="«term_∨_»">
                <OtherNode start="(274, 34)" end="(274, 41)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(274, 34)" end="(274, 36)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(274, 37)" end="(274, 38)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(274, 39)" end="(274, 41)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </OtherNode>
                <AtomNode start="(274, 42)" end="(274, 43)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(274, 44)" end="(274, 51)" kind="«term_=_»">
                  <IdentNode start="(274, 44)" end="(274, 46)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(274, 47)" end="(274, 48)" leading="" trailing=" " val="="/>
                  <IdentNode start="(274, 49)" end="(274, 51)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(274, 52)" end="(284, 28)">
          <AtomNode start="(274, 52)" end="(274, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(274, 55)" end="(284, 28)">
            <AtomNode start="(274, 55)" end="(274, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(275, 3)" end="(284, 28)">
              <TacticTacticseq1IndentedNode start="(275, 3)" end="(284, 28)">
                <NullNode start="(275, 3)" end="(284, 28)">
                  <OtherNode start="(275, 3)" end="(275, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ l₁ ≤ l₂ ↔ l₁ &amp;lt; l₂ ∨ l₁ = l₂" state_after="case mp&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ l₁ ≤ l₂ → l₁ &amp;lt; l₂ ∨ l₁ = l₂&#10;&#10;case mpr&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂ → l₁ ≤ l₂" tactic="constructor">
                    <AtomNode start="(275, 3)" end="(275, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(276, 3)" end="(281, 36)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ l₁ ≤ l₂ → l₁ &amp;lt; l₂ ∨ l₁ = l₂&#10;&#10;case mpr&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂ → l₁ ≤ l₂" state_after="case mpr&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂ → l₁ ≤ l₂" tactic="· intro h&#10;  by_cases h' : l₂ ≤ l₁&#10;  · right&#10;    apply List.le_antisymm h h'&#10;  · left&#10;    exact Decidable.not_not.mp h'">
                    <OtherNode start="(276, 3)" end="(276, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(276, 3)" end="(276, 4)" kind="patternIgnore">
                        <OtherNode start="(276, 3)" end="(276, 4)" kind="token.«· »">
                          <AtomNode start="(276, 3)" end="(276, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(276, 5)" end="(281, 36)">
                      <TacticTacticseq1IndentedNode start="(276, 5)" end="(281, 36)">
                        <NullNode start="(276, 5)" end="(281, 36)">
                          <OtherNode start="(276, 5)" end="(276, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ l₁ ≤ l₂ → l₁ &amp;lt; l₂ ∨ l₁ = l₂" state_after="case mp&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂" tactic="intro h">
                            <AtomNode start="(276, 5)" end="(276, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(276, 11)" end="(276, 12)">
                              <IdentNode start="(276, 11)" end="(276, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(277, 5)" end="(277, 26)" kind="«tacticBy_cases_:_»" state_before="case mp&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂" state_after="case pos&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;h' : l₂ ≤ l₁&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;h' : ¬l₂ ≤ l₁&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂" tactic="by_cases h' : l₂ ≤ l₁">
                            <AtomNode start="(277, 5)" end="(277, 13)" leading="" trailing=" " val="by_cases"/>
                            <NullNode start="(277, 14)" end="(277, 18)">
                              <IdentNode start="(277, 14)" end="(277, 16)" leading="" trailing=" " raw_val="h'" val="h'"/>
                              <AtomNode start="(277, 17)" end="(277, 18)" leading="" trailing=" " val=":"/>
                            </NullNode>
                            <OtherNode start="(277, 19)" end="(277, 26)" kind="«term_≤_»">
                              <IdentNode start="(277, 19)" end="(277, 21)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                              <AtomNode start="(277, 22)" end="(277, 23)" leading="" trailing=" " val="≤"/>
                              <IdentNode start="(277, 24)" end="(277, 26)" leading="" trailing="&#10;    " raw_val="l₁" val="l₁"/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(278, 5)" end="(279, 34)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;h' : l₂ ≤ l₁&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;h' : ¬l₂ ≤ l₁&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂" state_after="case neg&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;h' : ¬l₂ ≤ l₁&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂" tactic="· right&#10;  apply List.le_antisymm h h'">
                            <OtherNode start="(278, 5)" end="(278, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(278, 5)" end="(278, 6)" kind="patternIgnore">
                                <OtherNode start="(278, 5)" end="(278, 6)" kind="token.«· »">
                                  <AtomNode start="(278, 5)" end="(278, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(278, 7)" end="(279, 34)">
                              <TacticTacticseq1IndentedNode start="(278, 7)" end="(279, 34)">
                                <NullNode start="(278, 7)" end="(279, 34)">
                                  <OtherNode start="(278, 7)" end="(278, 12)" kind="Lean.Parser.Tactic.right" state_before="case pos&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;h' : l₂ ≤ l₁&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂" state_after="case pos.h&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;h' : l₂ ≤ l₁&#10;⊢ l₁ = l₂" tactic="right">
                                    <AtomNode start="(278, 7)" end="(278, 12)" leading="" trailing="&#10;      " val="right"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(279, 7)" end="(279, 34)" kind="Lean.Parser.Tactic.apply" state_before="case pos.h&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;h' : l₂ ≤ l₁&#10;⊢ l₁ = l₂" state_after="no goals" tactic="apply List.le_antisymm h h'">
                                    <AtomNode start="(279, 7)" end="(279, 12)" leading="" trailing=" " val="apply"/>
                                    <OtherNode start="(279, 13)" end="(279, 34)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(279, 13)" end="(279, 29)" leading="" trailing=" " raw_val="List.le_antisymm" val="List.le_antisymm" full_name="List.le_antisymm" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                                      <NullNode start="(279, 30)" end="(279, 34)">
                                        <IdentNode start="(279, 30)" end="(279, 31)" leading="" trailing=" " raw_val="h" val="h"/>
                                        <IdentNode start="(279, 32)" end="(279, 34)" leading="" trailing="&#10;    " raw_val="h'" val="h'"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(280, 5)" end="(281, 36)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;h' : ¬l₂ ≤ l₁&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂" state_after="no goals" tactic="· left&#10;  exact Decidable.not_not.mp h'">
                            <OtherNode start="(280, 5)" end="(280, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(280, 5)" end="(280, 6)" kind="patternIgnore">
                                <OtherNode start="(280, 5)" end="(280, 6)" kind="token.«· »">
                                  <AtomNode start="(280, 5)" end="(280, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(280, 7)" end="(281, 36)">
                              <TacticTacticseq1IndentedNode start="(280, 7)" end="(281, 36)">
                                <NullNode start="(280, 7)" end="(281, 36)">
                                  <OtherNode start="(280, 7)" end="(280, 11)" kind="Lean.Parser.Tactic.left" state_before="case neg&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;h' : ¬l₂ ≤ l₁&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂" state_after="case neg.h&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;h' : ¬l₂ ≤ l₁&#10;⊢ l₁ &amp;lt; l₂" tactic="left">
                                    <AtomNode start="(280, 7)" end="(280, 11)" leading="" trailing="&#10;      " val="left"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(281, 7)" end="(281, 36)" kind="Lean.Parser.Tactic.exact" state_before="case neg.h&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ≤ l₂&#10;h' : ¬l₂ ≤ l₁&#10;⊢ l₁ &amp;lt; l₂" state_after="no goals" tactic="exact Decidable.not_not.mp h'">
                                    <AtomNode start="(281, 7)" end="(281, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(281, 13)" end="(281, 36)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(281, 13)" end="(281, 33)" leading="" trailing=" " raw_val="Decidable.not_not.mp" val="Decidable.not_not.mp"/>
                                      <NullNode start="(281, 34)" end="(281, 36)">
                                        <IdentNode start="(281, 34)" end="(281, 36)" leading="" trailing="&#10;  " raw_val="h'" val="h'"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(282, 3)" end="(284, 28)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂ → l₁ ≤ l₂" state_after="no goals" tactic="· rintro (h | rfl)&#10;  · exact List.le_of_lt h&#10;  · exact List.le_refl l₁">
                    <OtherNode start="(282, 3)" end="(282, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(282, 3)" end="(282, 4)" kind="patternIgnore">
                        <OtherNode start="(282, 3)" end="(282, 4)" kind="token.«· »">
                          <AtomNode start="(282, 3)" end="(282, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(282, 5)" end="(284, 28)">
                      <TacticTacticseq1IndentedNode start="(282, 5)" end="(284, 28)">
                        <NullNode start="(282, 5)" end="(284, 28)">
                          <OtherNode start="(282, 5)" end="(282, 21)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ l₁ &amp;lt; l₂ ∨ l₁ = l₂ → l₁ ≤ l₂" state_after="case mpr.inl&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt; l₂&#10;⊢ l₁ ≤ l₂&#10;&#10;case mpr.inr&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ : List α&#10;⊢ l₁ ≤ l₁" tactic="rintro (h | rfl)">
                            <AtomNode start="(282, 5)" end="(282, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(282, 12)" end="(282, 21)">
                              <OtherNode start="(282, 12)" end="(282, 21)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(282, 12)" end="(282, 21)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                  <AtomNode start="(282, 12)" end="(282, 13)" leading="" trailing="" val="("/>
                                  <OtherNode start="(282, 13)" end="(282, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                    <OtherNode start="(282, 13)" end="(282, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                      <NullNode start="(282, 13)" end="(282, 20)">
                                        <OtherNode start="(282, 13)" end="(282, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(282, 13)" end="(282, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                        </OtherNode>
                                        <AtomNode start="(282, 15)" end="(282, 16)" leading="" trailing=" " val="|"/>
                                        <OtherNode start="(282, 17)" end="(282, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(282, 17)" end="(282, 20)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(282, 20)" end="(282, 21)" leading="" trailing="&#10;    " val=")"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(283, 5)" end="(283, 28)" kind="Lean.cdot" state_before="case mpr.inl&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt; l₂&#10;⊢ l₁ ≤ l₂&#10;&#10;case mpr.inr&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ : List α&#10;⊢ l₁ ≤ l₁" state_after="case mpr.inr&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ : List α&#10;⊢ l₁ ≤ l₁" tactic="· exact List.le_of_lt h">
                            <OtherNode start="(283, 5)" end="(283, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(283, 5)" end="(283, 6)" kind="patternIgnore">
                                <OtherNode start="(283, 5)" end="(283, 6)" kind="token.«· »">
                                  <AtomNode start="(283, 5)" end="(283, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(283, 7)" end="(283, 28)">
                              <TacticTacticseq1IndentedNode start="(283, 7)" end="(283, 28)">
                                <NullNode start="(283, 7)" end="(283, 28)">
                                  <OtherNode start="(283, 7)" end="(283, 28)" kind="Lean.Parser.Tactic.exact" state_before="case mpr.inl&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt; l₂&#10;⊢ l₁ ≤ l₂" state_after="no goals" tactic="exact List.le_of_lt h">
                                    <AtomNode start="(283, 7)" end="(283, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(283, 13)" end="(283, 28)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(283, 13)" end="(283, 26)" leading="" trailing=" " raw_val="List.le_of_lt" val="List.le_of_lt" full_name="List.le_of_lt" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(262, 19)" def_end="(262, 27)"/>
                                      <NullNode start="(283, 27)" end="(283, 28)">
                                        <IdentNode start="(283, 27)" end="(283, 28)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(284, 5)" end="(284, 28)" kind="Lean.cdot" state_before="case mpr.inr&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ : List α&#10;⊢ l₁ ≤ l₁" state_after="no goals" tactic="· exact List.le_refl l₁">
                            <OtherNode start="(284, 5)" end="(284, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(284, 5)" end="(284, 6)" kind="patternIgnore">
                                <OtherNode start="(284, 5)" end="(284, 6)" kind="token.«· »">
                                  <AtomNode start="(284, 5)" end="(284, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(284, 7)" end="(284, 28)">
                              <TacticTacticseq1IndentedNode start="(284, 7)" end="(284, 28)">
                                <NullNode start="(284, 7)" end="(284, 28)">
                                  <OtherNode start="(284, 7)" end="(284, 28)" kind="Lean.Parser.Tactic.exact" state_before="case mpr.inr&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝ : Std.Total fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ : List α&#10;⊢ l₁ ≤ l₁" state_after="no goals" tactic="exact List.le_refl l₁">
                                    <AtomNode start="(284, 7)" end="(284, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(284, 13)" end="(284, 28)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(284, 13)" end="(284, 25)" leading="" trailing=" " raw_val="List.le_refl" val="List.le_refl" full_name="List.le_refl" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(125, 19)" def_end="(125, 26)"/>
                                      <NullNode start="(284, 26)" end="(284, 28)">
                                        <IdentNode start="(284, 26)" end="(284, 28)" leading="" trailing="&#10;&#10;" raw_val="l₁" val="l₁"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(286, 1)" end="(297, 63)" name="lex_eq_decide_lex" full_name="List.lex_eq_decide_lex">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(286, 1)" end="(297, 63)" name="lex_eq_decide_lex" full_name="List.lex_eq_decide_lex" _is_private_decl="False">
        <AtomNode start="(286, 1)" end="(286, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(286, 9)" end="(286, 26)">
          <IdentNode start="(286, 9)" end="(286, 26)" leading="" trailing=" " raw_val="lex_eq_decide_lex" val="lex_eq_decide_lex"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(286, 27)" end="(287, 58)">
          <NullNode start="(286, 27)" end="(286, 84)">
            <OtherNode start="(286, 27)" end="(286, 34)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(286, 27)" end="(286, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(286, 28)" end="(286, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(286, 28)" end="(286, 31)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(286, 32)" end="(286, 33)">
                  <IdentNode start="(286, 32)" end="(286, 33)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(286, 33)" end="(286, 34)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(286, 35)" end="(286, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(286, 35)" end="(286, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(286, 36)" end="(286, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(286, 36)" end="(286, 45)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(286, 46)" end="(286, 47)">
                  <IdentNode start="(286, 46)" end="(286, 47)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(286, 47)" end="(286, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(286, 49)" end="(286, 64)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(286, 49)" end="(286, 50)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(286, 50)" end="(286, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(286, 50)" end="(286, 61)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(286, 62)" end="(286, 63)">
                  <IdentNode start="(286, 62)" end="(286, 63)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(286, 63)" end="(286, 64)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(286, 65)" end="(286, 84)">
              <AtomNode start="(286, 65)" end="(286, 66)" leading="" trailing="" val="("/>
              <NullNode start="(286, 66)" end="(286, 68)">
                <IdentNode start="(286, 66)" end="(286, 68)" leading="" trailing=" " raw_val="lt" val="lt"/>
              </NullNode>
              <NullNode start="(286, 69)" end="(286, 83)">
                <AtomNode start="(286, 69)" end="(286, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(286, 71)" end="(286, 83)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(286, 71)" end="(286, 72)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(286, 73)" end="(286, 74)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(286, 75)" end="(286, 83)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(286, 75)" end="(286, 76)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(286, 77)" end="(286, 78)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(286, 79)" end="(286, 83)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(286, 83)" end="(286, 84)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(286, 85)" end="(287, 58)">
            <AtomNode start="(286, 85)" end="(286, 86)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(287, 5)" end="(287, 58)" kind="«term_=_»">
              <OtherNode start="(287, 5)" end="(287, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(287, 5)" end="(287, 8)" leading="" trailing=" " raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(287, 9)" end="(287, 17)">
                  <IdentNode start="(287, 9)" end="(287, 11)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <IdentNode start="(287, 12)" end="(287, 14)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  <IdentNode start="(287, 15)" end="(287, 17)" leading="" trailing=" " raw_val="lt" val="lt"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(287, 18)" end="(287, 19)" leading="" trailing=" " val="="/>
              <OtherNode start="(287, 20)" end="(287, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(287, 20)" end="(287, 26)" leading="" trailing=" " raw_val="decide" val="decide" full_name="Decidable.decide" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(287, 27)" end="(287, 58)">
                  <OtherNode start="(287, 27)" end="(287, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(287, 27)" end="(287, 28)" leading="" trailing="" val="("/>
                    <OtherNode start="(287, 28)" end="(287, 57)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(287, 28)" end="(287, 31)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(287, 32)" end="(287, 57)">
                        <OtherNode start="(287, 32)" end="(287, 51)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(287, 32)" end="(287, 33)" leading="" trailing="" val="("/>
                          <OtherNode start="(287, 33)" end="(287, 50)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(287, 33)" end="(287, 36)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(287, 37)" end="(287, 50)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(287, 37)" end="(287, 40)">
                                <IdentNode start="(287, 37)" end="(287, 38)" leading="" trailing=" " raw_val="x" val="x"/>
                                <IdentNode start="(287, 39)" end="(287, 40)" leading="" trailing=" " raw_val="y" val="y"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(287, 41)" end="(287, 43)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(287, 44)" end="(287, 50)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(287, 44)" end="(287, 46)" leading="" trailing=" " raw_val="lt" val="lt"/>
                                <NullNode start="(287, 47)" end="(287, 50)">
                                  <IdentNode start="(287, 47)" end="(287, 48)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(287, 49)" end="(287, 50)" leading="" trailing="" raw_val="y" val="y"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(287, 50)" end="(287, 51)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <IdentNode start="(287, 52)" end="(287, 54)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        <IdentNode start="(287, 55)" end="(287, 57)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(287, 57)" end="(287, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(287, 59)" end="(297, 63)">
          <AtomNode start="(287, 59)" end="(287, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(287, 62)" end="(297, 63)">
            <AtomNode start="(287, 62)" end="(287, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(288, 3)" end="(297, 63)">
              <TacticTacticseq1IndentedNode start="(288, 3)" end="(297, 63)">
                <NullNode start="(288, 3)" end="(297, 63)">
                  <OtherNode start="(288, 3)" end="(297, 63)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;l₁ l₂ : List α&#10;inst✝² : BEq α&#10;inst✝¹ : LawfulBEq α&#10;inst✝ : DecidableEq α&#10;lt : α → α → Bool&#10;⊢ l₁.lex l₂ lt = decide (Lex (fun x y =&amp;gt; lt x y = true) l₁ l₂)" state_after="no goals" tactic="induction l₁ generalizing l₂ with&#10;| nil =&amp;gt;&#10;  cases l₂ with&#10;  | nil =&amp;gt; simp [lex]&#10;  | cons b bs =&amp;gt; simp [lex]&#10;| cons a l₁ ih =&amp;gt;&#10;  cases l₂ with&#10;  | nil =&amp;gt; simp [lex]&#10;  | cons b bs =&amp;gt;&#10;    simp [lex, ih, cons_lex_cons_iff, Bool.beq_eq_decide_eq]">
                    <AtomNode start="(288, 3)" end="(288, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(288, 13)" end="(288, 15)">
                      <OtherNode start="(288, 13)" end="(288, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(288, 13)" end="(288, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(288, 16)" end="(288, 31)">
                      <AtomNode start="(288, 16)" end="(288, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(288, 29)" end="(288, 31)">
                        <IdentNode start="(288, 29)" end="(288, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(288, 32)" end="(297, 63)">
                      <OtherNode start="(288, 32)" end="(297, 63)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(288, 32)" end="(288, 36)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(289, 3)" end="(297, 63)">
                          <OtherNode start="(289, 3)" end="(292, 30)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(289, 3)" end="(289, 8)">
                              <OtherNode start="(289, 3)" end="(289, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(289, 3)" end="(289, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(289, 5)" end="(289, 8)">
                                  <NullNode/>
                                  <IdentNode start="(289, 5)" end="(289, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(289, 9)" end="(292, 30)">
                              <AtomNode start="(289, 9)" end="(289, 11)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(290, 5)" end="(292, 30)">
                                <TacticTacticseq1IndentedNode start="(290, 5)" end="(292, 30)">
                                  <NullNode start="(290, 5)" end="(292, 30)">
                                    <OtherNode start="(290, 5)" end="(292, 30)" kind="Lean.Parser.Tactic.cases" state_before="case nil&#10;α : Type u_1&#10;inst✝² : BEq α&#10;inst✝¹ : LawfulBEq α&#10;inst✝ : DecidableEq α&#10;lt : α → α → Bool&#10;l₂ : List α&#10;⊢ [].lex l₂ lt = decide (Lex (fun x y =&amp;gt; lt x y = true) [] l₂)" state_after="no goals" tactic="cases l₂ with&#10;| nil =&amp;gt; simp [lex]&#10;| cons b bs =&amp;gt; simp [lex]">
                                      <AtomNode start="(290, 5)" end="(290, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(290, 11)" end="(290, 13)">
                                        <OtherNode start="(290, 11)" end="(290, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(290, 11)" end="(290, 13)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(290, 14)" end="(292, 30)">
                                        <OtherNode start="(290, 14)" end="(292, 30)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(290, 14)" end="(290, 18)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(291, 5)" end="(292, 30)">
                                            <OtherNode start="(291, 5)" end="(291, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(291, 5)" end="(291, 10)">
                                                <OtherNode start="(291, 5)" end="(291, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(291, 5)" end="(291, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(291, 7)" end="(291, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(291, 7)" end="(291, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(291, 11)" end="(291, 24)">
                                                <AtomNode start="(291, 11)" end="(291, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(291, 14)" end="(291, 24)">
                                                  <TacticTacticseq1IndentedNode start="(291, 14)" end="(291, 24)">
                                                    <NullNode start="(291, 14)" end="(291, 24)">
                                                      <OtherNode start="(291, 14)" end="(291, 24)" kind="Lean.Parser.Tactic.simp" state_before="case nil.nil&#10;α : Type u_1&#10;inst✝² : BEq α&#10;inst✝¹ : LawfulBEq α&#10;inst✝ : DecidableEq α&#10;lt : α → α → Bool&#10;⊢ [].lex [] lt = decide (Lex (fun x y =&amp;gt; lt x y = true) [] [])" state_after="no goals" tactic="simp [lex]">
                                                        <AtomNode start="(291, 14)" end="(291, 18)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(291, 19)" end="(291, 24)">
                                                          <AtomNode start="(291, 19)" end="(291, 20)" leading="" trailing="" val="["/>
                                                          <NullNode start="(291, 20)" end="(291, 23)">
                                                            <OtherNode start="(291, 20)" end="(291, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(291, 20)" end="(291, 23)" leading="" trailing="" raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(291, 23)" end="(291, 24)" leading="" trailing="&#10;    " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(292, 5)" end="(292, 30)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(292, 5)" end="(292, 16)">
                                                <OtherNode start="(292, 5)" end="(292, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(292, 5)" end="(292, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(292, 7)" end="(292, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(292, 7)" end="(292, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(292, 12)" end="(292, 16)">
                                                    <IdentNode start="(292, 12)" end="(292, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                                    <IdentNode start="(292, 14)" end="(292, 16)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(292, 17)" end="(292, 30)">
                                                <AtomNode start="(292, 17)" end="(292, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(292, 20)" end="(292, 30)">
                                                  <TacticTacticseq1IndentedNode start="(292, 20)" end="(292, 30)">
                                                    <NullNode start="(292, 20)" end="(292, 30)">
                                                      <OtherNode start="(292, 20)" end="(292, 30)" kind="Lean.Parser.Tactic.simp" state_before="case nil.cons&#10;α : Type u_1&#10;inst✝² : BEq α&#10;inst✝¹ : LawfulBEq α&#10;inst✝ : DecidableEq α&#10;lt : α → α → Bool&#10;b : α&#10;bs : List α&#10;⊢ [].lex (b :: bs) lt = decide (Lex (fun x y =&amp;gt; lt x y = true) [] (b :: bs))" state_after="no goals" tactic="simp [lex]">
                                                        <AtomNode start="(292, 20)" end="(292, 24)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(292, 25)" end="(292, 30)">
                                                          <AtomNode start="(292, 25)" end="(292, 26)" leading="" trailing="" val="["/>
                                                          <NullNode start="(292, 26)" end="(292, 29)">
                                                            <OtherNode start="(292, 26)" end="(292, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(292, 26)" end="(292, 29)" leading="" trailing="" raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(292, 29)" end="(292, 30)" leading="" trailing="&#10;  " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(293, 3)" end="(297, 63)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(293, 3)" end="(293, 17)">
                              <OtherNode start="(293, 3)" end="(293, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(293, 3)" end="(293, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(293, 5)" end="(293, 9)">
                                  <NullNode/>
                                  <IdentNode start="(293, 5)" end="(293, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(293, 10)" end="(293, 17)">
                                  <IdentNode start="(293, 10)" end="(293, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(293, 12)" end="(293, 14)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                  <IdentNode start="(293, 15)" end="(293, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(293, 18)" end="(297, 63)">
                              <AtomNode start="(293, 18)" end="(293, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(294, 5)" end="(297, 63)">
                                <TacticTacticseq1IndentedNode start="(294, 5)" end="(297, 63)">
                                  <NullNode start="(294, 5)" end="(297, 63)">
                                    <OtherNode start="(294, 5)" end="(297, 63)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;inst✝² : BEq α&#10;inst✝¹ : LawfulBEq α&#10;inst✝ : DecidableEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih : ∀ {l₂ : List α}, l₁.lex l₂ lt = decide (Lex (fun x y =&amp;gt; lt x y = true) l₁ l₂)&#10;l₂ : List α&#10;⊢ (a :: l₁).lex l₂ lt = decide (Lex (fun x y =&amp;gt; lt x y = true) (a :: l₁) l₂)" state_after="no goals" tactic="cases l₂ with&#10;| nil =&amp;gt; simp [lex]&#10;| cons b bs =&amp;gt;&#10;  simp [lex, ih, cons_lex_cons_iff, Bool.beq_eq_decide_eq]">
                                      <AtomNode start="(294, 5)" end="(294, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(294, 11)" end="(294, 13)">
                                        <OtherNode start="(294, 11)" end="(294, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(294, 11)" end="(294, 13)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(294, 14)" end="(297, 63)">
                                        <OtherNode start="(294, 14)" end="(297, 63)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(294, 14)" end="(294, 18)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(295, 5)" end="(297, 63)">
                                            <OtherNode start="(295, 5)" end="(295, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(295, 5)" end="(295, 10)">
                                                <OtherNode start="(295, 5)" end="(295, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(295, 5)" end="(295, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(295, 7)" end="(295, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(295, 7)" end="(295, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(295, 11)" end="(295, 24)">
                                                <AtomNode start="(295, 11)" end="(295, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(295, 14)" end="(295, 24)">
                                                  <TacticTacticseq1IndentedNode start="(295, 14)" end="(295, 24)">
                                                    <NullNode start="(295, 14)" end="(295, 24)">
                                                      <OtherNode start="(295, 14)" end="(295, 24)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;α : Type u_1&#10;inst✝² : BEq α&#10;inst✝¹ : LawfulBEq α&#10;inst✝ : DecidableEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih : ∀ {l₂ : List α}, l₁.lex l₂ lt = decide (Lex (fun x y =&amp;gt; lt x y = true) l₁ l₂)&#10;⊢ (a :: l₁).lex [] lt = decide (Lex (fun x y =&amp;gt; lt x y = true) (a :: l₁) [])" state_after="no goals" tactic="simp [lex]">
                                                        <AtomNode start="(295, 14)" end="(295, 18)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(295, 19)" end="(295, 24)">
                                                          <AtomNode start="(295, 19)" end="(295, 20)" leading="" trailing="" val="["/>
                                                          <NullNode start="(295, 20)" end="(295, 23)">
                                                            <OtherNode start="(295, 20)" end="(295, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(295, 20)" end="(295, 23)" leading="" trailing="" raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(295, 23)" end="(295, 24)" leading="" trailing="&#10;    " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(296, 5)" end="(297, 63)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(296, 5)" end="(296, 16)">
                                                <OtherNode start="(296, 5)" end="(296, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(296, 5)" end="(296, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(296, 7)" end="(296, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(296, 7)" end="(296, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(296, 12)" end="(296, 16)">
                                                    <IdentNode start="(296, 12)" end="(296, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                                    <IdentNode start="(296, 14)" end="(296, 16)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(296, 17)" end="(297, 63)">
                                                <AtomNode start="(296, 17)" end="(296, 19)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(297, 7)" end="(297, 63)">
                                                  <TacticTacticseq1IndentedNode start="(297, 7)" end="(297, 63)">
                                                    <NullNode start="(297, 7)" end="(297, 63)">
                                                      <OtherNode start="(297, 7)" end="(297, 63)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons&#10;α : Type u_1&#10;inst✝² : BEq α&#10;inst✝¹ : LawfulBEq α&#10;inst✝ : DecidableEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih : ∀ {l₂ : List α}, l₁.lex l₂ lt = decide (Lex (fun x y =&amp;gt; lt x y = true) l₁ l₂)&#10;b : α&#10;bs : List α&#10;⊢ (a :: l₁).lex (b :: bs) lt = decide (Lex (fun x y =&amp;gt; lt x y = true) (a :: l₁) (b :: bs))" state_after="no goals" tactic="simp [lex, ih, cons_lex_cons_iff, Bool.beq_eq_decide_eq]">
                                                        <AtomNode start="(297, 7)" end="(297, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(297, 12)" end="(297, 63)">
                                                          <AtomNode start="(297, 12)" end="(297, 13)" leading="" trailing="" val="["/>
                                                          <NullNode start="(297, 13)" end="(297, 62)">
                                                            <OtherNode start="(297, 13)" end="(297, 16)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(297, 13)" end="(297, 16)" leading="" trailing="" raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(297, 16)" end="(297, 17)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(297, 18)" end="(297, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(297, 18)" end="(297, 20)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <AtomNode start="(297, 20)" end="(297, 21)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(297, 22)" end="(297, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(297, 22)" end="(297, 39)" leading="" trailing="" raw_val="cons_lex_cons_iff" val="cons_lex_cons_iff" full_name="List.cons_lex_cons_iff" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(62, 9)" def_end="(62, 26)"/>
                                                            </OtherNode>
                                                            <AtomNode start="(297, 39)" end="(297, 40)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(297, 41)" end="(297, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(297, 41)" end="(297, 62)" leading="" trailing="" raw_val="Bool.beq_eq_decide_eq" val="Bool.beq_eq_decide_eq" full_name="Bool.beq_eq_decide_eq" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(297, 62)" end="(297, 63)" leading="" trailing="&#10;&#10;" val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(299, 1)" end="(303, 27)" name="lex_eq_true_iff_lex" full_name="List.lex_eq_true_iff_lex">
      <CommandDeclmodifiersNode start="(299, 1)" end="(300, 8)">
        <NullNode start="(299, 1)" end="(299, 67)">
          <CommandDoccommentNode start="(299, 1)" end="(299, 67)" comment="Variant of `lex_eq_true_iff` using an arbitrary comparator. -/">
            <AtomNode start="(299, 1)" end="(299, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(299, 5)" end="(299, 67)" leading="" trailing="&#10;" val="Variant of `lex_eq_true_iff` using an arbitrary comparator. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(300, 1)" end="(300, 8)">
          <OtherNode start="(300, 1)" end="(300, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(300, 1)" end="(300, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(300, 3)" end="(300, 7)">
              <OtherNode start="(300, 3)" end="(300, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(300, 3)" end="(300, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(300, 3)" end="(300, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(300, 7)" end="(300, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(300, 9)" end="(303, 27)" name="lex_eq_true_iff_lex" full_name="List.lex_eq_true_iff_lex" _is_private_decl="False">
        <AtomNode start="(300, 9)" end="(300, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(300, 17)" end="(300, 36)">
          <IdentNode start="(300, 17)" end="(300, 36)" leading="" trailing=" " raw_val="lex_eq_true_iff_lex" val="lex_eq_true_iff_lex"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(300, 37)" end="(301, 56)">
          <NullNode start="(300, 37)" end="(300, 78)">
            <OtherNode start="(300, 37)" end="(300, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(300, 37)" end="(300, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(300, 38)" end="(300, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(300, 38)" end="(300, 41)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(300, 42)" end="(300, 43)">
                  <IdentNode start="(300, 42)" end="(300, 43)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(300, 43)" end="(300, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(300, 45)" end="(300, 58)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(300, 45)" end="(300, 46)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(300, 46)" end="(300, 57)" kind="Lean.Parser.Term.app">
                <IdentNode start="(300, 46)" end="(300, 55)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(300, 56)" end="(300, 57)">
                  <IdentNode start="(300, 56)" end="(300, 57)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(300, 57)" end="(300, 58)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(300, 59)" end="(300, 78)">
              <AtomNode start="(300, 59)" end="(300, 60)" leading="" trailing="" val="("/>
              <NullNode start="(300, 60)" end="(300, 62)">
                <IdentNode start="(300, 60)" end="(300, 62)" leading="" trailing=" " raw_val="lt" val="lt"/>
              </NullNode>
              <NullNode start="(300, 63)" end="(300, 77)">
                <AtomNode start="(300, 63)" end="(300, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(300, 65)" end="(300, 77)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(300, 65)" end="(300, 66)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(300, 67)" end="(300, 68)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(300, 69)" end="(300, 77)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(300, 69)" end="(300, 70)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(300, 71)" end="(300, 72)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(300, 73)" end="(300, 77)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(300, 77)" end="(300, 78)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(300, 79)" end="(301, 56)">
            <AtomNode start="(300, 79)" end="(300, 80)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(301, 5)" end="(301, 56)" kind="«term_↔_»">
              <OtherNode start="(301, 5)" end="(301, 24)" kind="«term_=_»">
                <OtherNode start="(301, 5)" end="(301, 17)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(301, 5)" end="(301, 8)" leading="" trailing=" " raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(301, 9)" end="(301, 17)">
                    <IdentNode start="(301, 9)" end="(301, 11)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(301, 12)" end="(301, 14)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    <IdentNode start="(301, 15)" end="(301, 17)" leading="" trailing=" " raw_val="lt" val="lt"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(301, 18)" end="(301, 19)" leading="" trailing=" " val="="/>
                <IdentNode start="(301, 20)" end="(301, 24)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(301, 25)" end="(301, 26)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(301, 27)" end="(301, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(301, 27)" end="(301, 30)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(301, 31)" end="(301, 56)">
                  <OtherNode start="(301, 31)" end="(301, 50)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(301, 31)" end="(301, 32)" leading="" trailing="" val="("/>
                    <OtherNode start="(301, 32)" end="(301, 49)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(301, 32)" end="(301, 35)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(301, 36)" end="(301, 49)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(301, 36)" end="(301, 39)">
                          <IdentNode start="(301, 36)" end="(301, 37)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(301, 38)" end="(301, 39)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(301, 40)" end="(301, 42)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(301, 43)" end="(301, 49)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(301, 43)" end="(301, 45)" leading="" trailing=" " raw_val="lt" val="lt"/>
                          <NullNode start="(301, 46)" end="(301, 49)">
                            <IdentNode start="(301, 46)" end="(301, 47)" leading="" trailing=" " raw_val="x" val="x"/>
                            <IdentNode start="(301, 48)" end="(301, 49)" leading="" trailing="" raw_val="y" val="y"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(301, 49)" end="(301, 50)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(301, 51)" end="(301, 53)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <IdentNode start="(301, 54)" end="(301, 56)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(301, 57)" end="(303, 27)">
          <AtomNode start="(301, 57)" end="(301, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(301, 60)" end="(303, 27)">
            <AtomNode start="(301, 60)" end="(301, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(302, 3)" end="(303, 27)">
              <TacticTacticseq1IndentedNode start="(302, 3)" end="(303, 27)">
                <NullNode start="(302, 3)" end="(303, 27)">
                  <OtherNode start="(302, 3)" end="(302, 53)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;l₁ l₂ : List α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;lt : α → α → Bool&#10;⊢ l₁.lex l₂ lt = true ↔ Lex (fun x y =&amp;gt; lt x y = true) l₁ l₂" state_after="α : Type u_1&#10;l₁ l₂ : List α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;lt : α → α → Bool&#10;this : DecidableEq α&#10;⊢ l₁.lex l₂ lt = true ↔ Lex (fun x y =&amp;gt; lt x y = true) l₁ l₂" tactic="have : DecidableEq α := instDecidableEqOfLawfulBEq">
                    <AtomNode start="(302, 3)" end="(302, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(302, 8)" end="(302, 53)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(302, 8)" end="(302, 53)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(302, 8)" end="(302, 8)" kind="Lean.Parser.Term.haveId">
                          <OtherNode start="(302, 8)" end="(302, 8)" kind="hygieneInfo">
                            <IdentNode start="(302, 8)" end="(302, 8)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                          </OtherNode>
                        </OtherNode>
                        <NullNode/>
                        <NullNode start="(302, 8)" end="(302, 23)">
                          <TermTypespecNode start="(302, 8)" end="(302, 23)">
                            <AtomNode start="(302, 8)" end="(302, 9)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(302, 10)" end="(302, 23)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(302, 10)" end="(302, 21)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(302, 22)" end="(302, 23)">
                                <IdentNode start="(302, 22)" end="(302, 23)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                          </TermTypespecNode>
                        </NullNode>
                        <AtomNode start="(302, 24)" end="(302, 26)" leading="" trailing=" " val=":="/>
                        <IdentNode start="(302, 27)" end="(302, 53)" leading="" trailing="&#10;  " raw_val="instDecidableEqOfLawfulBEq" val="instDecidableEqOfLawfulBEq" full_name="instDecidableEqOfLawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(303, 3)" end="(303, 27)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l₁ l₂ : List α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;lt : α → α → Bool&#10;this : DecidableEq α&#10;⊢ l₁.lex l₂ lt = true ↔ Lex (fun x y =&amp;gt; lt x y = true) l₁ l₂" state_after="no goals" tactic="simp [lex_eq_decide_lex]">
                    <AtomNode start="(303, 3)" end="(303, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(303, 8)" end="(303, 27)">
                      <AtomNode start="(303, 8)" end="(303, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(303, 9)" end="(303, 26)">
                        <OtherNode start="(303, 9)" end="(303, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(303, 9)" end="(303, 26)" leading="" trailing="" raw_val="lex_eq_decide_lex" val="lex_eq_decide_lex" full_name="List.lex_eq_decide_lex" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(286, 9)" def_end="(286, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(303, 26)" end="(303, 27)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(305, 1)" end="(308, 48)" name="lex_eq_false_iff_not_lex" full_name="List.lex_eq_false_iff_not_lex">
      <CommandDeclmodifiersNode start="(305, 1)" end="(306, 8)">
        <NullNode start="(305, 1)" end="(305, 68)">
          <CommandDoccommentNode start="(305, 1)" end="(305, 68)" comment="Variant of `lex_eq_false_iff` using an arbitrary comparator. -/">
            <AtomNode start="(305, 1)" end="(305, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(305, 5)" end="(305, 68)" leading="" trailing="&#10;" val="Variant of `lex_eq_false_iff` using an arbitrary comparator. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(306, 1)" end="(306, 8)">
          <OtherNode start="(306, 1)" end="(306, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(306, 1)" end="(306, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(306, 3)" end="(306, 7)">
              <OtherNode start="(306, 3)" end="(306, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(306, 3)" end="(306, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(306, 3)" end="(306, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(306, 7)" end="(306, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(306, 9)" end="(308, 48)" name="lex_eq_false_iff_not_lex" full_name="List.lex_eq_false_iff_not_lex" _is_private_decl="False">
        <AtomNode start="(306, 9)" end="(306, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(306, 17)" end="(306, 41)">
          <IdentNode start="(306, 17)" end="(306, 41)" leading="" trailing=" " raw_val="lex_eq_false_iff_not_lex" val="lex_eq_false_iff_not_lex"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(306, 42)" end="(307, 59)">
          <NullNode start="(306, 42)" end="(306, 83)">
            <OtherNode start="(306, 42)" end="(306, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(306, 42)" end="(306, 43)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(306, 43)" end="(306, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(306, 43)" end="(306, 46)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(306, 47)" end="(306, 48)">
                  <IdentNode start="(306, 47)" end="(306, 48)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(306, 48)" end="(306, 49)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(306, 50)" end="(306, 63)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(306, 50)" end="(306, 51)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(306, 51)" end="(306, 62)" kind="Lean.Parser.Term.app">
                <IdentNode start="(306, 51)" end="(306, 60)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(306, 61)" end="(306, 62)">
                  <IdentNode start="(306, 61)" end="(306, 62)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(306, 62)" end="(306, 63)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(306, 64)" end="(306, 83)">
              <AtomNode start="(306, 64)" end="(306, 65)" leading="" trailing="" val="("/>
              <NullNode start="(306, 65)" end="(306, 67)">
                <IdentNode start="(306, 65)" end="(306, 67)" leading="" trailing=" " raw_val="lt" val="lt"/>
              </NullNode>
              <NullNode start="(306, 68)" end="(306, 82)">
                <AtomNode start="(306, 68)" end="(306, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(306, 70)" end="(306, 82)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(306, 70)" end="(306, 71)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(306, 72)" end="(306, 73)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(306, 74)" end="(306, 82)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(306, 74)" end="(306, 75)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(306, 76)" end="(306, 77)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(306, 78)" end="(306, 82)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(306, 82)" end="(306, 83)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(306, 84)" end="(307, 59)">
            <AtomNode start="(306, 84)" end="(306, 85)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(307, 5)" end="(307, 59)" kind="«term_↔_»">
              <OtherNode start="(307, 5)" end="(307, 25)" kind="«term_=_»">
                <OtherNode start="(307, 5)" end="(307, 17)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(307, 5)" end="(307, 8)" leading="" trailing=" " raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(307, 9)" end="(307, 17)">
                    <IdentNode start="(307, 9)" end="(307, 11)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(307, 12)" end="(307, 14)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    <IdentNode start="(307, 15)" end="(307, 17)" leading="" trailing=" " raw_val="lt" val="lt"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(307, 18)" end="(307, 19)" leading="" trailing=" " val="="/>
                <IdentNode start="(307, 20)" end="(307, 25)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(307, 26)" end="(307, 27)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(307, 28)" end="(307, 59)" kind="«term¬_»">
                <AtomNode start="(307, 28)" end="(307, 29)" leading="" trailing=" " val="¬"/>
                <OtherNode start="(307, 30)" end="(307, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(307, 30)" end="(307, 33)" leading="" trailing=" " raw_val="Lex" val="Lex" full_name="List.Lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(307, 34)" end="(307, 59)">
                    <OtherNode start="(307, 34)" end="(307, 53)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(307, 34)" end="(307, 35)" leading="" trailing="" val="("/>
                      <OtherNode start="(307, 35)" end="(307, 52)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(307, 35)" end="(307, 38)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(307, 39)" end="(307, 52)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(307, 39)" end="(307, 42)">
                            <IdentNode start="(307, 39)" end="(307, 40)" leading="" trailing=" " raw_val="x" val="x"/>
                            <IdentNode start="(307, 41)" end="(307, 42)" leading="" trailing=" " raw_val="y" val="y"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(307, 43)" end="(307, 45)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(307, 46)" end="(307, 52)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(307, 46)" end="(307, 48)" leading="" trailing=" " raw_val="lt" val="lt"/>
                            <NullNode start="(307, 49)" end="(307, 52)">
                              <IdentNode start="(307, 49)" end="(307, 50)" leading="" trailing=" " raw_val="x" val="x"/>
                              <IdentNode start="(307, 51)" end="(307, 52)" leading="" trailing="" raw_val="y" val="y"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(307, 52)" end="(307, 53)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(307, 54)" end="(307, 56)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(307, 57)" end="(307, 59)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(307, 60)" end="(308, 48)">
          <AtomNode start="(307, 60)" end="(307, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(307, 63)" end="(308, 48)">
            <AtomNode start="(307, 63)" end="(307, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(308, 3)" end="(308, 48)">
              <TacticTacticseq1IndentedNode start="(308, 3)" end="(308, 48)">
                <NullNode start="(308, 3)" end="(308, 48)">
                  <OtherNode start="(308, 3)" end="(308, 48)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l₁ l₂ : List α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;lt : α → α → Bool&#10;⊢ l₁.lex l₂ lt = false ↔ ¬Lex (fun x y =&amp;gt; lt x y = true) l₁ l₂" state_after="no goals" tactic="simp [Bool.eq_false_iff, lex_eq_true_iff_lex]">
                    <AtomNode start="(308, 3)" end="(308, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(308, 8)" end="(308, 48)">
                      <AtomNode start="(308, 8)" end="(308, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(308, 9)" end="(308, 47)">
                        <OtherNode start="(308, 9)" end="(308, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(308, 9)" end="(308, 26)" leading="" trailing="" raw_val="Bool.eq_false_iff" val="Bool.eq_false_iff" full_name="Bool.eq_false_iff" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                        </OtherNode>
                        <AtomNode start="(308, 26)" end="(308, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(308, 28)" end="(308, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(308, 28)" end="(308, 47)" leading="" trailing="" raw_val="lex_eq_true_iff_lex" val="lex_eq_true_iff_lex" full_name="List.lex_eq_true_iff_lex" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(300, 17)" def_end="(300, 36)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(308, 47)" end="(308, 48)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(310, 1)" end="(313, 16)" name="lex_eq_true_iff_lt" full_name="List.lex_eq_true_iff_lt">
      <CommandDeclmodifiersNode start="(310, 1)" end="(310, 8)">
        <NullNode/>
        <NullNode start="(310, 1)" end="(310, 8)">
          <OtherNode start="(310, 1)" end="(310, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(310, 1)" end="(310, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(310, 3)" end="(310, 7)">
              <OtherNode start="(310, 3)" end="(310, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(310, 3)" end="(310, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(310, 3)" end="(310, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(310, 7)" end="(310, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(310, 9)" end="(313, 16)" name="lex_eq_true_iff_lt" full_name="List.lex_eq_true_iff_lt" _is_private_decl="False">
        <AtomNode start="(310, 9)" end="(310, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(310, 17)" end="(310, 35)">
          <IdentNode start="(310, 17)" end="(310, 35)" leading="" trailing=" " raw_val="lex_eq_true_iff_lt" val="lex_eq_true_iff_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(310, 36)" end="(311, 50)">
          <NullNode start="(310, 36)" end="(311, 21)">
            <OtherNode start="(310, 36)" end="(310, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(310, 36)" end="(310, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(310, 37)" end="(310, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(310, 37)" end="(310, 40)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(310, 41)" end="(310, 42)">
                  <IdentNode start="(310, 41)" end="(310, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(310, 42)" end="(310, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(310, 44)" end="(310, 57)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(310, 44)" end="(310, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(310, 45)" end="(310, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(310, 45)" end="(310, 54)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(310, 55)" end="(310, 56)">
                  <IdentNode start="(310, 55)" end="(310, 56)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(310, 56)" end="(310, 57)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(310, 58)" end="(310, 64)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(310, 58)" end="(310, 59)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(310, 59)" end="(310, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(310, 59)" end="(310, 61)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(310, 62)" end="(310, 63)">
                  <IdentNode start="(310, 62)" end="(310, 63)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(310, 63)" end="(310, 64)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(310, 65)" end="(310, 80)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(310, 65)" end="(310, 66)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(310, 66)" end="(310, 79)" kind="Lean.Parser.Term.app">
                <IdentNode start="(310, 66)" end="(310, 77)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(310, 78)" end="(310, 79)">
                  <IdentNode start="(310, 78)" end="(310, 79)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(310, 79)" end="(310, 80)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(311, 5)" end="(311, 21)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(311, 5)" end="(311, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(311, 6)" end="(311, 11)">
                <IdentNode start="(311, 6)" end="(311, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(311, 9)" end="(311, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(311, 12)" end="(311, 20)">
                <AtomNode start="(311, 12)" end="(311, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(311, 14)" end="(311, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(311, 14)" end="(311, 18)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(311, 19)" end="(311, 20)">
                    <IdentNode start="(311, 19)" end="(311, 20)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(311, 20)" end="(311, 21)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(311, 22)" end="(311, 50)">
            <AtomNode start="(311, 22)" end="(311, 23)" leading="" trailing=" " val=":"/>
            <OtherNode start="(311, 24)" end="(311, 50)" kind="«term_↔_»">
              <OtherNode start="(311, 24)" end="(311, 40)" kind="«term_=_»">
                <OtherNode start="(311, 24)" end="(311, 33)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(311, 24)" end="(311, 27)" leading="" trailing=" " raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(311, 28)" end="(311, 33)">
                    <IdentNode start="(311, 28)" end="(311, 30)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(311, 31)" end="(311, 33)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(311, 34)" end="(311, 35)" leading="" trailing=" " val="="/>
                <IdentNode start="(311, 36)" end="(311, 40)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(311, 41)" end="(311, 42)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(311, 43)" end="(311, 50)" kind="«term_&amp;lt;_»">
                <IdentNode start="(311, 43)" end="(311, 45)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(311, 46)" end="(311, 47)" leading="" trailing=" " val="&amp;lt;"/>
                <IdentNode start="(311, 48)" end="(311, 50)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(311, 51)" end="(313, 16)">
          <AtomNode start="(311, 51)" end="(311, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(311, 54)" end="(313, 16)">
            <AtomNode start="(311, 54)" end="(311, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(312, 3)" end="(313, 16)">
              <TacticTacticseq1IndentedNode start="(312, 3)" end="(313, 16)">
                <NullNode start="(312, 3)" end="(313, 16)">
                  <OtherNode start="(312, 3)" end="(312, 53)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝³ : BEq α&#10;inst✝² : LawfulBEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;l₁ l₂ : List α&#10;⊢ (l₁.lex l₂ fun x1 x2 =&amp;gt; decide (x1 &amp;lt; x2)) = true ↔ l₁ &amp;lt; l₂" state_after="α : Type u_1&#10;inst✝³ : BEq α&#10;inst✝² : LawfulBEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;l₁ l₂ : List α&#10;⊢ Lex (fun x y =&amp;gt; x &amp;lt; y) l₁ l₂ ↔ l₁ &amp;lt; l₂" tactic="simp only [lex_eq_true_iff_lex, decide_eq_true_eq]">
                    <AtomNode start="(312, 3)" end="(312, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(312, 8)" end="(312, 12)">
                      <AtomNode start="(312, 8)" end="(312, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(312, 13)" end="(312, 53)">
                      <AtomNode start="(312, 13)" end="(312, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(312, 14)" end="(312, 52)">
                        <OtherNode start="(312, 14)" end="(312, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(312, 14)" end="(312, 33)" leading="" trailing="" raw_val="lex_eq_true_iff_lex" val="lex_eq_true_iff_lex" full_name="List.lex_eq_true_iff_lex" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(300, 17)" def_end="(300, 36)"/>
                        </OtherNode>
                        <AtomNode start="(312, 33)" end="(312, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(312, 35)" end="(312, 52)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(312, 35)" end="(312, 52)" leading="" trailing="" raw_val="decide_eq_true_eq" val="decide_eq_true_eq" full_name="decide_eq_true_eq" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(312, 52)" end="(312, 53)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(313, 3)" end="(313, 16)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝³ : BEq α&#10;inst✝² : LawfulBEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;l₁ l₂ : List α&#10;⊢ Lex (fun x y =&amp;gt; x &amp;lt; y) l₁ l₂ ↔ l₁ &amp;lt; l₂" state_after="no goals" tactic="exact Iff.rfl">
                    <AtomNode start="(313, 3)" end="(313, 8)" leading="" trailing=" " val="exact"/>
                    <IdentNode start="(313, 9)" end="(313, 16)" leading="" trailing="&#10;&#10;" raw_val="Iff.rfl" val="Iff.rfl" full_name="Iff.rfl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(315, 1)" end="(318, 16)" name="lex_eq_false_iff_ge" full_name="List.lex_eq_false_iff_ge">
      <CommandDeclmodifiersNode start="(315, 1)" end="(315, 8)">
        <NullNode/>
        <NullNode start="(315, 1)" end="(315, 8)">
          <OtherNode start="(315, 1)" end="(315, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(315, 1)" end="(315, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(315, 3)" end="(315, 7)">
              <OtherNode start="(315, 3)" end="(315, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(315, 3)" end="(315, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(315, 3)" end="(315, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(315, 7)" end="(315, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(315, 9)" end="(318, 16)" name="lex_eq_false_iff_ge" full_name="List.lex_eq_false_iff_ge" _is_private_decl="False">
        <AtomNode start="(315, 9)" end="(315, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(315, 17)" end="(315, 36)">
          <IdentNode start="(315, 17)" end="(315, 36)" leading="" trailing=" " raw_val="lex_eq_false_iff_ge" val="lex_eq_false_iff_ge"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(315, 37)" end="(316, 51)">
          <NullNode start="(315, 37)" end="(316, 21)">
            <OtherNode start="(315, 37)" end="(315, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(315, 37)" end="(315, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(315, 38)" end="(315, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(315, 38)" end="(315, 41)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(315, 42)" end="(315, 43)">
                  <IdentNode start="(315, 42)" end="(315, 43)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(315, 43)" end="(315, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(315, 45)" end="(315, 58)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(315, 45)" end="(315, 46)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(315, 46)" end="(315, 57)" kind="Lean.Parser.Term.app">
                <IdentNode start="(315, 46)" end="(315, 55)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(315, 56)" end="(315, 57)">
                  <IdentNode start="(315, 56)" end="(315, 57)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(315, 57)" end="(315, 58)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(315, 59)" end="(315, 65)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(315, 59)" end="(315, 60)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(315, 60)" end="(315, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(315, 60)" end="(315, 62)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(315, 63)" end="(315, 64)">
                  <IdentNode start="(315, 63)" end="(315, 64)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(315, 64)" end="(315, 65)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(315, 66)" end="(315, 81)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(315, 66)" end="(315, 67)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(315, 67)" end="(315, 80)" kind="Lean.Parser.Term.app">
                <IdentNode start="(315, 67)" end="(315, 78)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(315, 79)" end="(315, 80)">
                  <IdentNode start="(315, 79)" end="(315, 80)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(315, 80)" end="(315, 81)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(316, 5)" end="(316, 21)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(316, 5)" end="(316, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(316, 6)" end="(316, 11)">
                <IdentNode start="(316, 6)" end="(316, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(316, 9)" end="(316, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(316, 12)" end="(316, 20)">
                <AtomNode start="(316, 12)" end="(316, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(316, 14)" end="(316, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(316, 14)" end="(316, 18)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(316, 19)" end="(316, 20)">
                    <IdentNode start="(316, 19)" end="(316, 20)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(316, 20)" end="(316, 21)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(316, 22)" end="(316, 51)">
            <AtomNode start="(316, 22)" end="(316, 23)" leading="" trailing=" " val=":"/>
            <OtherNode start="(316, 24)" end="(316, 51)" kind="«term_↔_»">
              <OtherNode start="(316, 24)" end="(316, 41)" kind="«term_=_»">
                <OtherNode start="(316, 24)" end="(316, 33)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(316, 24)" end="(316, 27)" leading="" trailing=" " raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(316, 28)" end="(316, 33)">
                    <IdentNode start="(316, 28)" end="(316, 30)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(316, 31)" end="(316, 33)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(316, 34)" end="(316, 35)" leading="" trailing=" " val="="/>
                <IdentNode start="(316, 36)" end="(316, 41)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(316, 42)" end="(316, 43)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(316, 44)" end="(316, 51)" kind="«term_≤_»">
                <IdentNode start="(316, 44)" end="(316, 46)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                <AtomNode start="(316, 47)" end="(316, 48)" leading="" trailing=" " val="≤"/>
                <IdentNode start="(316, 49)" end="(316, 51)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(316, 52)" end="(318, 16)">
          <AtomNode start="(316, 52)" end="(316, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(316, 55)" end="(318, 16)">
            <AtomNode start="(316, 55)" end="(316, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(317, 3)" end="(318, 16)">
              <TacticTacticseq1IndentedNode start="(317, 3)" end="(318, 16)">
                <NullNode start="(317, 3)" end="(318, 16)">
                  <OtherNode start="(317, 3)" end="(317, 58)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝³ : BEq α&#10;inst✝² : LawfulBEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;l₁ l₂ : List α&#10;⊢ (l₁.lex l₂ fun x1 x2 =&amp;gt; decide (x1 &amp;lt; x2)) = false ↔ l₂ ≤ l₁" state_after="α : Type u_1&#10;inst✝³ : BEq α&#10;inst✝² : LawfulBEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;l₁ l₂ : List α&#10;⊢ ¬Lex (fun x y =&amp;gt; x &amp;lt; y) l₁ l₂ ↔ l₂ ≤ l₁" tactic="simp only [lex_eq_false_iff_not_lex, decide_eq_true_eq]">
                    <AtomNode start="(317, 3)" end="(317, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(317, 8)" end="(317, 12)">
                      <AtomNode start="(317, 8)" end="(317, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(317, 13)" end="(317, 58)">
                      <AtomNode start="(317, 13)" end="(317, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(317, 14)" end="(317, 57)">
                        <OtherNode start="(317, 14)" end="(317, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(317, 14)" end="(317, 38)" leading="" trailing="" raw_val="lex_eq_false_iff_not_lex" val="lex_eq_false_iff_not_lex" full_name="List.lex_eq_false_iff_not_lex" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(306, 17)" def_end="(306, 41)"/>
                        </OtherNode>
                        <AtomNode start="(317, 38)" end="(317, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(317, 40)" end="(317, 57)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(317, 40)" end="(317, 57)" leading="" trailing="" raw_val="decide_eq_true_eq" val="decide_eq_true_eq" full_name="decide_eq_true_eq" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(317, 57)" end="(317, 58)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(318, 3)" end="(318, 16)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝³ : BEq α&#10;inst✝² : LawfulBEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;l₁ l₂ : List α&#10;⊢ ¬Lex (fun x y =&amp;gt; x &amp;lt; y) l₁ l₂ ↔ l₂ ≤ l₁" state_after="no goals" tactic="exact Iff.rfl">
                    <AtomNode start="(318, 3)" end="(318, 8)" leading="" trailing=" " val="exact"/>
                    <IdentNode start="(318, 9)" end="(318, 16)" leading="" trailing="&#10;&#10;" raw_val="Iff.rfl" val="Iff.rfl" full_name="Iff.rfl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(320, 1)" end="(372, 29)" kind="Lean.Parser.Command.in">
      <OtherNode start="(320, 1)" end="(320, 50)" kind="Lean.Parser.Command.attribute">
        <AtomNode start="(320, 1)" end="(320, 10)" leading="" trailing=" " val="attribute"/>
        <AtomNode start="(320, 11)" end="(320, 12)" leading="" trailing="" val="["/>
        <NullNode start="(320, 12)" end="(320, 22)">
          <OtherNode start="(320, 12)" end="(320, 22)" kind="Lean.Parser.Term.attrInstance">
            <TermAttrkindNode start="(320, 12)" end="(320, 17)">
              <NullNode start="(320, 12)" end="(320, 17)">
                <OtherNode start="(320, 12)" end="(320, 17)" kind="Lean.Parser.Term.local">
                  <AtomNode start="(320, 12)" end="(320, 17)" leading="" trailing=" " val="local"/>
                </OtherNode>
              </NullNode>
            </TermAttrkindNode>
            <OtherNode start="(320, 18)" end="(320, 22)" kind="Lean.Parser.Attr.simp">
              <AtomNode start="(320, 18)" end="(320, 22)" leading="" trailing="" val="simp"/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
            </OtherNode>
          </OtherNode>
        </NullNode>
        <AtomNode start="(320, 22)" end="(320, 23)" leading="" trailing=" " val="]"/>
        <NullNode start="(320, 24)" end="(320, 50)">
          <IdentNode start="(320, 24)" end="(320, 50)" leading="" trailing=" " raw_val="Nat.add_one_lt_add_one_iff" val="Nat.add_one_lt_add_one_iff" full_name="Nat.add_one_lt_add_one_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
        </NullNode>
      </OtherNode>
      <AtomNode start="(320, 51)" end="(320, 53)" leading="" trailing="&#10;" val="in"/>
      <CommandDeclarationNode start="(321, 1)" end="(372, 29)" name="lex_eq_true_iff_exists" full_name="List.lex_eq_true_iff_exists">
        <CommandDeclmodifiersNode start="(321, 1)" end="(328, 3)">
          <NullNode start="(321, 1)" end="(328, 3)">
            <CommandDoccommentNode start="(321, 1)" end="(328, 3)" comment="`l₁` is lexicographically less than `l₂` if either&#10;- `l₁` is pairwise equivalent under `· == ·` to `l₂.take l₁.length`,&#10;  and `l₁` is shorter than `l₂` or&#10;- there exists an index `i` such that&#10;  - for all `j &amp;lt; i`, `l₁[j] == l₂[j]` and&#10;  - `l₁[i] &amp;lt; l₂[i]`&#10;-/">
              <AtomNode start="(321, 1)" end="(321, 4)" leading="" trailing="&#10;" val="/--"/>
              <AtomNode start="(322, 1)" end="(328, 3)" leading="" trailing="&#10;" val="`l₁` is lexicographically less than `l₂` if either&#10;- `l₁` is pairwise equivalent under `· == ·` to `l₂.take l₁.length`,&#10;  and `l₁` is shorter than `l₂` or&#10;- there exists an index `i` such that&#10;  - for all `j &amp;lt; i`, `l₁[j] == l₂[j]` and&#10;  - `l₁[i] &amp;lt; l₂[i]`&#10;-/"/>
            </CommandDoccommentNode>
          </NullNode>
          <NullNode/>
          <NullNode/>
          <NullNode/>
          <NullNode/>
          <NullNode/>
        </CommandDeclmodifiersNode>
        <CommandTheoremNode start="(329, 1)" end="(372, 29)" name="lex_eq_true_iff_exists" full_name="List.lex_eq_true_iff_exists" _is_private_decl="False">
          <AtomNode start="(329, 1)" end="(329, 8)" leading="" trailing=" " val="theorem"/>
          <CommandDeclidNode start="(329, 9)" end="(329, 31)">
            <IdentNode start="(329, 9)" end="(329, 31)" leading="" trailing=" " raw_val="lex_eq_true_iff_exists" val="lex_eq_true_iff_exists"/>
            <NullNode/>
          </CommandDeclidNode>
          <CommandDeclsigNode start="(329, 32)" end="(334, 88)">
            <NullNode start="(329, 32)" end="(329, 59)">
              <OtherNode start="(329, 32)" end="(329, 39)" kind="Lean.Parser.Term.instBinder">
                <AtomNode start="(329, 32)" end="(329, 33)" leading="" trailing="" val="["/>
                <NullNode/>
                <OtherNode start="(329, 33)" end="(329, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(329, 33)" end="(329, 36)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(329, 37)" end="(329, 38)">
                    <IdentNode start="(329, 37)" end="(329, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(329, 38)" end="(329, 39)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <TermExplicitbinderNode start="(329, 40)" end="(329, 59)">
                <AtomNode start="(329, 40)" end="(329, 41)" leading="" trailing="" val="("/>
                <NullNode start="(329, 41)" end="(329, 43)">
                  <IdentNode start="(329, 41)" end="(329, 43)" leading="" trailing=" " raw_val="lt" val="lt"/>
                </NullNode>
                <NullNode start="(329, 44)" end="(329, 58)">
                  <AtomNode start="(329, 44)" end="(329, 45)" leading="" trailing=" " val=":"/>
                  <OtherNode start="(329, 46)" end="(329, 58)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(329, 46)" end="(329, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(329, 48)" end="(329, 49)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(329, 50)" end="(329, 58)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(329, 50)" end="(329, 51)" leading="" trailing=" " raw_val="α" val="α"/>
                      <AtomNode start="(329, 52)" end="(329, 53)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(329, 54)" end="(329, 58)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <NullNode/>
                <AtomNode start="(329, 58)" end="(329, 59)" leading="" trailing=" " val=")"/>
              </TermExplicitbinderNode>
            </NullNode>
            <TermTypespecNode start="(329, 60)" end="(334, 88)">
              <AtomNode start="(329, 60)" end="(329, 61)" leading="" trailing="&#10;    " val=":"/>
              <OtherNode start="(330, 5)" end="(334, 88)" kind="«term_↔_»">
                <OtherNode start="(330, 5)" end="(330, 24)" kind="«term_=_»">
                  <OtherNode start="(330, 5)" end="(330, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(330, 5)" end="(330, 8)" leading="" trailing=" " raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(330, 9)" end="(330, 17)">
                      <IdentNode start="(330, 9)" end="(330, 11)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <IdentNode start="(330, 12)" end="(330, 14)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      <IdentNode start="(330, 15)" end="(330, 17)" leading="" trailing=" " raw_val="lt" val="lt"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(330, 18)" end="(330, 19)" leading="" trailing=" " val="="/>
                  <IdentNode start="(330, 20)" end="(330, 24)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <AtomNode start="(330, 25)" end="(330, 26)" leading="" trailing="&#10;      " val="↔"/>
                <OtherNode start="(331, 7)" end="(334, 88)" kind="«term_∨_»">
                  <OtherNode start="(331, 7)" end="(331, 70)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(331, 7)" end="(331, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(331, 8)" end="(331, 69)" kind="«term_∧_»">
                      <OtherNode start="(331, 8)" end="(331, 45)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(331, 8)" end="(331, 16)" leading="" trailing=" " raw_val="l₁.isEqv" val="l₁.isEqv"/>
                        <NullNode start="(331, 17)" end="(331, 45)">
                          <OtherNode start="(331, 17)" end="(331, 36)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(331, 17)" end="(331, 18)" leading="" trailing="" val="("/>
                            <OtherNode start="(331, 18)" end="(331, 35)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(331, 18)" end="(331, 25)" leading="" trailing=" " raw_val="l₂.take" val="l₂.take"/>
                              <NullNode start="(331, 26)" end="(331, 35)">
                                <IdentNode start="(331, 26)" end="(331, 35)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(331, 35)" end="(331, 36)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <OtherNode start="(331, 37)" end="(331, 45)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(331, 37)" end="(331, 38)" leading="" trailing="" val="("/>
                            <OtherNode start="(331, 38)" end="(331, 44)" kind="«term_==_»">
                              <OtherNode start="(331, 38)" end="(331, 39)" kind="Lean.Parser.Term.cdot">
                                <AtomNode start="(331, 38)" end="(331, 39)" leading="" trailing=" " val="·"/>
                              </OtherNode>
                              <AtomNode start="(331, 40)" end="(331, 42)" leading="" trailing=" " val="=="/>
                              <OtherNode start="(331, 43)" end="(331, 44)" kind="Lean.Parser.Term.cdot">
                                <AtomNode start="(331, 43)" end="(331, 44)" leading="" trailing="" val="·"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(331, 44)" end="(331, 45)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(331, 46)" end="(331, 47)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(331, 48)" end="(331, 69)" kind="«term_&amp;lt;_»">
                        <IdentNode start="(331, 48)" end="(331, 57)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                        <AtomNode start="(331, 58)" end="(331, 59)" leading="" trailing=" " val="&amp;lt;"/>
                        <IdentNode start="(331, 60)" end="(331, 69)" leading="" trailing="" raw_val="l₂.length" val="l₂.length"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(331, 69)" end="(331, 70)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <AtomNode start="(331, 71)" end="(331, 72)" leading="" trailing="&#10;        " val="∨"/>
                  <OtherNode start="(332, 9)" end="(334, 88)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(332, 9)" end="(332, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(332, 10)" end="(334, 87)" kind="«term∃_,_»">
                      <AtomNode start="(332, 10)" end="(332, 11)" leading="" trailing=" " val="∃"/>
                      <OtherNode start="(332, 12)" end="(332, 63)" kind="Lean.explicitBinders">
                        <NullNode start="(332, 12)" end="(332, 63)">
                          <OtherNode start="(332, 12)" end="(332, 21)" kind="Lean.bracketedExplicitBinders">
                            <AtomNode start="(332, 12)" end="(332, 13)" leading="" trailing="" val="("/>
                            <NullNode start="(332, 13)" end="(332, 14)">
                              <LeanBinderidentNode start="(332, 13)" end="(332, 14)">
                                <IdentNode start="(332, 13)" end="(332, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                              </LeanBinderidentNode>
                            </NullNode>
                            <AtomNode start="(332, 15)" end="(332, 16)" leading="" trailing=" " val=":"/>
                            <IdentNode start="(332, 17)" end="(332, 20)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <AtomNode start="(332, 20)" end="(332, 21)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <OtherNode start="(332, 22)" end="(332, 42)" kind="Lean.bracketedExplicitBinders">
                            <AtomNode start="(332, 22)" end="(332, 23)" leading="" trailing="" val="("/>
                            <NullNode start="(332, 23)" end="(332, 25)">
                              <LeanBinderidentNode start="(332, 23)" end="(332, 25)">
                                <IdentNode start="(332, 23)" end="(332, 25)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                              </LeanBinderidentNode>
                            </NullNode>
                            <AtomNode start="(332, 26)" end="(332, 27)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(332, 28)" end="(332, 41)" kind="«term_&amp;lt;_»">
                              <IdentNode start="(332, 28)" end="(332, 29)" leading="" trailing=" " raw_val="i" val="i"/>
                              <AtomNode start="(332, 30)" end="(332, 31)" leading="" trailing=" " val="&amp;lt;"/>
                              <IdentNode start="(332, 32)" end="(332, 41)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                            </OtherNode>
                            <AtomNode start="(332, 41)" end="(332, 42)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <OtherNode start="(332, 43)" end="(332, 63)" kind="Lean.bracketedExplicitBinders">
                            <AtomNode start="(332, 43)" end="(332, 44)" leading="" trailing="" val="("/>
                            <NullNode start="(332, 44)" end="(332, 46)">
                              <LeanBinderidentNode start="(332, 44)" end="(332, 46)">
                                <IdentNode start="(332, 44)" end="(332, 46)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                              </LeanBinderidentNode>
                            </NullNode>
                            <AtomNode start="(332, 47)" end="(332, 48)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(332, 49)" end="(332, 62)" kind="«term_&amp;lt;_»">
                              <IdentNode start="(332, 49)" end="(332, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                              <AtomNode start="(332, 51)" end="(332, 52)" leading="" trailing=" " val="&amp;lt;"/>
                              <IdentNode start="(332, 53)" end="(332, 62)" leading="" trailing="" raw_val="l₂.length" val="l₂.length"/>
                            </OtherNode>
                            <AtomNode start="(332, 62)" end="(332, 63)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(332, 63)" end="(332, 64)" leading="" trailing="&#10;          " val=","/>
                      <OtherNode start="(333, 11)" end="(334, 87)" kind="«term_∧_»">
                        <OtherNode start="(333, 11)" end="(334, 70)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(333, 11)" end="(333, 12)" leading="" trailing="" val="("/>
                          <OtherNode start="(333, 12)" end="(334, 69)" kind="Lean.Parser.Term.forall">
                            <AtomNode start="(333, 12)" end="(333, 13)" leading="" trailing=" " val="∀"/>
                            <NullNode start="(333, 14)" end="(333, 15)">
                              <IdentNode start="(333, 14)" end="(333, 15)" leading="" trailing="" raw_val="j" val="j"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(333, 15)" end="(333, 16)" leading="" trailing=" " val=","/>
                            <OtherNode start="(333, 17)" end="(334, 69)" kind="Lean.Parser.Term.depArrow">
                              <TermExplicitbinderNode start="(333, 17)" end="(333, 29)">
                                <AtomNode start="(333, 17)" end="(333, 18)" leading="" trailing="" val="("/>
                                <NullNode start="(333, 18)" end="(333, 20)">
                                  <IdentNode start="(333, 18)" end="(333, 20)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                </NullNode>
                                <NullNode start="(333, 21)" end="(333, 28)">
                                  <AtomNode start="(333, 21)" end="(333, 22)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(333, 23)" end="(333, 28)" kind="«term_&amp;lt;_»">
                                    <IdentNode start="(333, 23)" end="(333, 24)" leading="" trailing=" " raw_val="j" val="j"/>
                                    <AtomNode start="(333, 25)" end="(333, 26)" leading="" trailing=" " val="&amp;lt;"/>
                                    <IdentNode start="(333, 27)" end="(333, 28)" leading="" trailing="" raw_val="i" val="i"/>
                                  </OtherNode>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(333, 28)" end="(333, 29)" leading="" trailing=" " val=")"/>
                              </TermExplicitbinderNode>
                              <AtomNode start="(333, 30)" end="(333, 31)" leading="" trailing="&#10;            " val="→"/>
                              <OtherNode start="(334, 13)" end="(334, 69)" kind="«term_==_»">
                                <OtherNode start="(334, 13)" end="(334, 39)" kind="«term__[_]'_»">
                                  <IdentNode start="(334, 13)" end="(334, 15)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                  <AtomNode start="(334, 15)" end="(334, 16)" leading="" trailing="" val="["/>
                                  <IdentNode start="(334, 16)" end="(334, 17)" leading="" trailing="" raw_val="j" val="j"/>
                                  <AtomNode start="(334, 17)" end="(334, 19)" leading="" trailing="" val="]'"/>
                                  <OtherNode start="(334, 19)" end="(334, 39)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(334, 19)" end="(334, 20)" leading="" trailing="" val="("/>
                                    <OtherNode start="(334, 20)" end="(334, 38)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(334, 20)" end="(334, 32)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(334, 33)" end="(334, 38)">
                                        <IdentNode start="(334, 33)" end="(334, 35)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                        <IdentNode start="(334, 36)" end="(334, 38)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(334, 38)" end="(334, 39)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(334, 40)" end="(334, 42)" leading="" trailing=" " val="=="/>
                                <OtherNode start="(334, 43)" end="(334, 69)" kind="«term__[_]'_»">
                                  <IdentNode start="(334, 43)" end="(334, 45)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                  <AtomNode start="(334, 45)" end="(334, 46)" leading="" trailing="" val="["/>
                                  <IdentNode start="(334, 46)" end="(334, 47)" leading="" trailing="" raw_val="j" val="j"/>
                                  <AtomNode start="(334, 47)" end="(334, 49)" leading="" trailing="" val="]'"/>
                                  <OtherNode start="(334, 49)" end="(334, 69)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(334, 49)" end="(334, 50)" leading="" trailing="" val="("/>
                                    <OtherNode start="(334, 50)" end="(334, 68)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(334, 50)" end="(334, 62)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(334, 63)" end="(334, 68)">
                                        <IdentNode start="(334, 63)" end="(334, 65)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                        <IdentNode start="(334, 66)" end="(334, 68)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(334, 68)" end="(334, 69)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(334, 69)" end="(334, 70)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(334, 71)" end="(334, 72)" leading="" trailing=" " val="∧"/>
                        <OtherNode start="(334, 73)" end="(334, 87)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(334, 73)" end="(334, 75)" leading="" trailing=" " raw_val="lt" val="lt"/>
                          <NullNode start="(334, 76)" end="(334, 87)">
                            <OtherNode start="(334, 76)" end="(334, 81)" kind="«term__[_]»">
                              <IdentNode start="(334, 76)" end="(334, 78)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                              <AtomNode start="(334, 78)" end="(334, 79)" leading="" trailing="" val="["/>
                              <IdentNode start="(334, 79)" end="(334, 80)" leading="" trailing="" raw_val="i" val="i"/>
                              <AtomNode start="(334, 80)" end="(334, 81)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <OtherNode start="(334, 82)" end="(334, 87)" kind="«term__[_]»">
                              <IdentNode start="(334, 82)" end="(334, 84)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                              <AtomNode start="(334, 84)" end="(334, 85)" leading="" trailing="" val="["/>
                              <IdentNode start="(334, 85)" end="(334, 86)" leading="" trailing="" raw_val="i" val="i"/>
                              <AtomNode start="(334, 86)" end="(334, 87)" leading="" trailing="" val="]"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(334, 87)" end="(334, 88)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </TermTypespecNode>
          </CommandDeclsigNode>
          <CommandDeclvalsimpleNode start="(334, 89)" end="(372, 29)">
            <AtomNode start="(334, 89)" end="(334, 91)" leading="" trailing=" " val=":="/>
            <TermBytacticNode start="(334, 92)" end="(372, 29)">
              <AtomNode start="(334, 92)" end="(334, 94)" leading="" trailing="&#10;  " val="by"/>
              <TacticTacticseqNode start="(335, 3)" end="(372, 29)">
                <TacticTacticseq1IndentedNode start="(335, 3)" end="(372, 29)">
                  <NullNode start="(335, 3)" end="(372, 29)">
                    <OtherNode start="(335, 3)" end="(372, 29)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;l₁ l₂ : List α&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;⊢ l₁.lex l₂ lt = true ↔&#10;    (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true" state_after="no goals" tactic="induction l₁ generalizing l₂ with&#10;| nil =&amp;gt;&#10;  cases l₂ with&#10;  | nil =&amp;gt; simp [lex]&#10;  | cons b bs =&amp;gt; simp [lex]&#10;| cons a l₁ ih =&amp;gt;&#10;  cases l₂ with&#10;  | nil =&amp;gt; simp [lex]&#10;  | cons b l₂ =&amp;gt;&#10;    simp [cons_lex_cons, Bool.or_eq_true, Bool.and_eq_true, ih, isEqv, length_cons]&#10;    constructor&#10;    · rintro (hab | ⟨hab, ⟨h₁, h₂⟩ | ⟨i, h₁, h₂, w₁, w₂⟩⟩)&#10;      · exact .inr ⟨0, by simp [hab]⟩&#10;      · exact .inl ⟨⟨hab, h₁⟩, by simpa using h₂⟩&#10;      · refine .inr ⟨i + 1, by simp [h₁],&#10;          by simp [h₂], ?_, ?_⟩&#10;        · intro j hj&#10;          cases j with&#10;          | zero =&amp;gt; simp [hab]&#10;          | succ j =&amp;gt;&#10;            simp only [getElem_cons_succ]&#10;            rw [w₁]&#10;            simpa using hj&#10;        · simpa using w₂&#10;    · rintro (⟨⟨h₁, h₂⟩, h₃⟩ | ⟨i, h₁, h₂, w₁, w₂⟩)&#10;      · exact .inr ⟨h₁, .inl ⟨h₂, by simpa using h₃⟩⟩&#10;      · cases i with&#10;        | zero =&amp;gt;&#10;          left&#10;          simpa using w₂&#10;        | succ i =&amp;gt;&#10;          right&#10;          refine ⟨by simpa using w₁ 0 (by simp), ?_⟩&#10;          right&#10;          refine ⟨i, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;          · intro j hj&#10;            simpa using w₁ (j + 1) (by simpa)&#10;          · simpa using w₂">
                      <AtomNode start="(335, 3)" end="(335, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(335, 13)" end="(335, 15)">
                        <OtherNode start="(335, 13)" end="(335, 15)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(335, 13)" end="(335, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode start="(335, 16)" end="(335, 31)">
                        <AtomNode start="(335, 16)" end="(335, 28)" leading="" trailing=" " val="generalizing"/>
                        <NullNode start="(335, 29)" end="(335, 31)">
                          <IdentNode start="(335, 29)" end="(335, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                        </NullNode>
                      </NullNode>
                      <NullNode start="(335, 32)" end="(372, 29)">
                        <OtherNode start="(335, 32)" end="(372, 29)" kind="Lean.Parser.Tactic.inductionAlts">
                          <AtomNode start="(335, 32)" end="(335, 36)" leading="" trailing="&#10;  " val="with"/>
                          <NullNode/>
                          <NullNode start="(336, 3)" end="(372, 29)">
                            <OtherNode start="(336, 3)" end="(339, 30)" kind="Lean.Parser.Tactic.inductionAlt">
                              <NullNode start="(336, 3)" end="(336, 8)">
                                <OtherNode start="(336, 3)" end="(336, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                  <AtomNode start="(336, 3)" end="(336, 4)" leading="" trailing=" " val="|"/>
                                  <GroupNode start="(336, 5)" end="(336, 8)">
                                    <NullNode/>
                                    <IdentNode start="(336, 5)" end="(336, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </GroupNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <NullNode start="(336, 9)" end="(339, 30)">
                                <AtomNode start="(336, 9)" end="(336, 11)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                                <TacticTacticseqNode start="(337, 5)" end="(339, 30)">
                                  <TacticTacticseq1IndentedNode start="(337, 5)" end="(339, 30)">
                                    <NullNode start="(337, 5)" end="(339, 30)">
                                      <OtherNode start="(337, 5)" end="(339, 30)" kind="Lean.Parser.Tactic.cases" state_before="case nil&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;l₂ : List α&#10;⊢ [].lex l₂ lt = true ↔&#10;    ([].isEqv (take [].length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ [].length &amp;lt; l₂.length ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ([][j] == l₂[j]) = true) ∧ lt [][i] l₂[i] = true" state_after="no goals" tactic="cases l₂ with&#10;| nil =&amp;gt; simp [lex]&#10;| cons b bs =&amp;gt; simp [lex]">
                                        <AtomNode start="(337, 5)" end="(337, 10)" leading="" trailing=" " val="cases"/>
                                        <NullNode start="(337, 11)" end="(337, 13)">
                                          <OtherNode start="(337, 11)" end="(337, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                            <NullNode/>
                                            <IdentNode start="(337, 11)" end="(337, 13)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode/>
                                        <NullNode start="(337, 14)" end="(339, 30)">
                                          <OtherNode start="(337, 14)" end="(339, 30)" kind="Lean.Parser.Tactic.inductionAlts">
                                            <AtomNode start="(337, 14)" end="(337, 18)" leading="" trailing="&#10;    " val="with"/>
                                            <NullNode/>
                                            <NullNode start="(338, 5)" end="(339, 30)">
                                              <OtherNode start="(338, 5)" end="(338, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                                                <NullNode start="(338, 5)" end="(338, 10)">
                                                  <OtherNode start="(338, 5)" end="(338, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                    <AtomNode start="(338, 5)" end="(338, 6)" leading="" trailing=" " val="|"/>
                                                    <GroupNode start="(338, 7)" end="(338, 10)">
                                                      <NullNode/>
                                                      <IdentNode start="(338, 7)" end="(338, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                    </GroupNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </NullNode>
                                                <NullNode start="(338, 11)" end="(338, 24)">
                                                  <AtomNode start="(338, 11)" end="(338, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                  <TacticTacticseqNode start="(338, 14)" end="(338, 24)">
                                                    <TacticTacticseq1IndentedNode start="(338, 14)" end="(338, 24)">
                                                      <NullNode start="(338, 14)" end="(338, 24)">
                                                        <OtherNode start="(338, 14)" end="(338, 24)" kind="Lean.Parser.Tactic.simp" state_before="case nil.nil&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;⊢ [].lex [] lt = true ↔&#10;    ([].isEqv (take [].length []) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ [].length &amp;lt; [].length ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ([][j] == [][j]) = true) ∧ lt [][i] [][i] = true" state_after="no goals" tactic="simp [lex]">
                                                          <AtomNode start="(338, 14)" end="(338, 18)" leading="" trailing=" " val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(338, 19)" end="(338, 24)">
                                                            <AtomNode start="(338, 19)" end="(338, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(338, 20)" end="(338, 23)">
                                                            <OtherNode start="(338, 20)" end="(338, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(338, 20)" end="(338, 23)" leading="" trailing="" raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(338, 23)" end="(338, 24)" leading="" trailing="&#10;    " val="]"/>
                                                          </NullNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </NullNode>
                                              </OtherNode>
                                              <OtherNode start="(339, 5)" end="(339, 30)" kind="Lean.Parser.Tactic.inductionAlt">
                                                <NullNode start="(339, 5)" end="(339, 16)">
                                                  <OtherNode start="(339, 5)" end="(339, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                    <AtomNode start="(339, 5)" end="(339, 6)" leading="" trailing=" " val="|"/>
                                                    <GroupNode start="(339, 7)" end="(339, 11)">
                                                      <NullNode/>
                                                      <IdentNode start="(339, 7)" end="(339, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                    </GroupNode>
                                                    <NullNode start="(339, 12)" end="(339, 16)">
                                                      <IdentNode start="(339, 12)" end="(339, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                                      <IdentNode start="(339, 14)" end="(339, 16)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <NullNode start="(339, 17)" end="(339, 30)">
                                                  <AtomNode start="(339, 17)" end="(339, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                                                  <TacticTacticseqNode start="(339, 20)" end="(339, 30)">
                                                    <TacticTacticseq1IndentedNode start="(339, 20)" end="(339, 30)">
                                                      <NullNode start="(339, 20)" end="(339, 30)">
                                                        <OtherNode start="(339, 20)" end="(339, 30)" kind="Lean.Parser.Tactic.simp" state_before="case nil.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;b : α&#10;bs : List α&#10;⊢ [].lex (b :: bs) lt = true ↔&#10;    ([].isEqv (take [].length (b :: bs)) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ [].length &amp;lt; (b :: bs).length ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ([][j] == (b :: bs)[j]) = true) ∧ lt [][i] (b :: bs)[i] = true" state_after="no goals" tactic="simp [lex]">
                                                          <AtomNode start="(339, 20)" end="(339, 24)" leading="" trailing=" " val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(339, 25)" end="(339, 30)">
                                                            <AtomNode start="(339, 25)" end="(339, 26)" leading="" trailing="" val="["/>
                                                            <NullNode start="(339, 26)" end="(339, 29)">
                                                            <OtherNode start="(339, 26)" end="(339, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(339, 26)" end="(339, 29)" leading="" trailing="" raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(339, 29)" end="(339, 30)" leading="" trailing="&#10;  " val="]"/>
                                                          </NullNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </NullNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </NullNode>
                            </OtherNode>
                            <OtherNode start="(340, 3)" end="(372, 29)" kind="Lean.Parser.Tactic.inductionAlt">
                              <NullNode start="(340, 3)" end="(340, 17)">
                                <OtherNode start="(340, 3)" end="(340, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                  <AtomNode start="(340, 3)" end="(340, 4)" leading="" trailing=" " val="|"/>
                                  <GroupNode start="(340, 5)" end="(340, 9)">
                                    <NullNode/>
                                    <IdentNode start="(340, 5)" end="(340, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </GroupNode>
                                  <NullNode start="(340, 10)" end="(340, 17)">
                                    <IdentNode start="(340, 10)" end="(340, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                    <IdentNode start="(340, 12)" end="(340, 14)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                    <IdentNode start="(340, 15)" end="(340, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                              <NullNode start="(340, 18)" end="(372, 29)">
                                <AtomNode start="(340, 18)" end="(340, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                                <TacticTacticseqNode start="(341, 5)" end="(372, 29)">
                                  <TacticTacticseq1IndentedNode start="(341, 5)" end="(372, 29)">
                                    <NullNode start="(341, 5)" end="(372, 29)">
                                      <OtherNode start="(341, 5)" end="(372, 29)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;l₂ : List α&#10;⊢ (a :: l₁).lex l₂ lt = true ↔&#10;    ((a :: l₁).isEqv (take (a :: l₁).length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ (a :: l₁).length &amp;lt; l₂.length ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == l₂[j]) = true) ∧ lt (a :: l₁)[i] l₂[i] = true" state_after="no goals" tactic="cases l₂ with&#10;| nil =&amp;gt; simp [lex]&#10;| cons b l₂ =&amp;gt;&#10;  simp [cons_lex_cons, Bool.or_eq_true, Bool.and_eq_true, ih, isEqv, length_cons]&#10;  constructor&#10;  · rintro (hab | ⟨hab, ⟨h₁, h₂⟩ | ⟨i, h₁, h₂, w₁, w₂⟩⟩)&#10;    · exact .inr ⟨0, by simp [hab]⟩&#10;    · exact .inl ⟨⟨hab, h₁⟩, by simpa using h₂⟩&#10;    · refine .inr ⟨i + 1, by simp [h₁],&#10;        by simp [h₂], ?_, ?_⟩&#10;      · intro j hj&#10;        cases j with&#10;        | zero =&amp;gt; simp [hab]&#10;        | succ j =&amp;gt;&#10;          simp only [getElem_cons_succ]&#10;          rw [w₁]&#10;          simpa using hj&#10;      · simpa using w₂&#10;  · rintro (⟨⟨h₁, h₂⟩, h₃⟩ | ⟨i, h₁, h₂, w₁, w₂⟩)&#10;    · exact .inr ⟨h₁, .inl ⟨h₂, by simpa using h₃⟩⟩&#10;    · cases i with&#10;      | zero =&amp;gt;&#10;        left&#10;        simpa using w₂&#10;      | succ i =&amp;gt;&#10;        right&#10;        refine ⟨by simpa using w₁ 0 (by simp), ?_⟩&#10;        right&#10;        refine ⟨i, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;        · intro j hj&#10;          simpa using w₁ (j + 1) (by simpa)&#10;        · simpa using w₂">
                                        <AtomNode start="(341, 5)" end="(341, 10)" leading="" trailing=" " val="cases"/>
                                        <NullNode start="(341, 11)" end="(341, 13)">
                                          <OtherNode start="(341, 11)" end="(341, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                            <NullNode/>
                                            <IdentNode start="(341, 11)" end="(341, 13)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode/>
                                        <NullNode start="(341, 14)" end="(372, 29)">
                                          <OtherNode start="(341, 14)" end="(372, 29)" kind="Lean.Parser.Tactic.inductionAlts">
                                            <AtomNode start="(341, 14)" end="(341, 18)" leading="" trailing="&#10;    " val="with"/>
                                            <NullNode/>
                                            <NullNode start="(342, 5)" end="(372, 29)">
                                              <OtherNode start="(342, 5)" end="(342, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                                                <NullNode start="(342, 5)" end="(342, 10)">
                                                  <OtherNode start="(342, 5)" end="(342, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                    <AtomNode start="(342, 5)" end="(342, 6)" leading="" trailing=" " val="|"/>
                                                    <GroupNode start="(342, 7)" end="(342, 10)">
                                                      <NullNode/>
                                                      <IdentNode start="(342, 7)" end="(342, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                    </GroupNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </NullNode>
                                                <NullNode start="(342, 11)" end="(342, 24)">
                                                  <AtomNode start="(342, 11)" end="(342, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                  <TacticTacticseqNode start="(342, 14)" end="(342, 24)">
                                                    <TacticTacticseq1IndentedNode start="(342, 14)" end="(342, 24)">
                                                      <NullNode start="(342, 14)" end="(342, 24)">
                                                        <OtherNode start="(342, 14)" end="(342, 24)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;⊢ (a :: l₁).lex [] lt = true ↔&#10;    ((a :: l₁).isEqv (take (a :: l₁).length []) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ (a :: l₁).length &amp;lt; [].length ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == [][j]) = true) ∧ lt (a :: l₁)[i] [][i] = true" state_after="no goals" tactic="simp [lex]">
                                                          <AtomNode start="(342, 14)" end="(342, 18)" leading="" trailing=" " val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(342, 19)" end="(342, 24)">
                                                            <AtomNode start="(342, 19)" end="(342, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(342, 20)" end="(342, 23)">
                                                            <OtherNode start="(342, 20)" end="(342, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(342, 20)" end="(342, 23)" leading="" trailing="" raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(342, 23)" end="(342, 24)" leading="" trailing="&#10;    " val="]"/>
                                                          </NullNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </NullNode>
                                              </OtherNode>
                                              <OtherNode start="(343, 5)" end="(372, 29)" kind="Lean.Parser.Tactic.inductionAlt">
                                                <NullNode start="(343, 5)" end="(343, 16)">
                                                  <OtherNode start="(343, 5)" end="(343, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                    <AtomNode start="(343, 5)" end="(343, 6)" leading="" trailing=" " val="|"/>
                                                    <GroupNode start="(343, 7)" end="(343, 11)">
                                                      <NullNode/>
                                                      <IdentNode start="(343, 7)" end="(343, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                    </GroupNode>
                                                    <NullNode start="(343, 12)" end="(343, 16)">
                                                      <IdentNode start="(343, 12)" end="(343, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                                      <IdentNode start="(343, 14)" end="(343, 16)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <NullNode start="(343, 17)" end="(372, 29)">
                                                  <AtomNode start="(343, 17)" end="(343, 19)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                  <TacticTacticseqNode start="(344, 7)" end="(372, 29)">
                                                    <TacticTacticseq1IndentedNode start="(344, 7)" end="(372, 29)">
                                                      <NullNode start="(344, 7)" end="(372, 29)">
                                                        <OtherNode start="(344, 7)" end="(344, 86)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ (a :: l₁).lex (b :: l₂) lt = true ↔&#10;    ((a :: l₁).isEqv (take (a :: l₁).length (b :: l₂)) fun x1 x2 =&amp;gt; x1 == x2) = true ∧&#10;        (a :: l₁).length &amp;lt; (b :: l₂).length ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true" state_after="case cons.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ lt a b = true ∨&#10;      (a == b) = true ∧&#10;        ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true) ↔&#10;    ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true" tactic="simp [cons_lex_cons, Bool.or_eq_true, Bool.and_eq_true, ih, isEqv, length_cons]">
                                                          <AtomNode start="(344, 7)" end="(344, 11)" leading="" trailing=" " val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(344, 12)" end="(344, 86)">
                                                            <AtomNode start="(344, 12)" end="(344, 13)" leading="" trailing="" val="["/>
                                                            <NullNode start="(344, 13)" end="(344, 85)">
                                                            <OtherNode start="(344, 13)" end="(344, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(344, 13)" end="(344, 26)" leading="" trailing="" raw_val="cons_lex_cons" val="cons_lex_cons" full_name="List.cons_lex_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(344, 26)" end="(344, 27)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(344, 28)" end="(344, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(344, 28)" end="(344, 43)" leading="" trailing="" raw_val="Bool.or_eq_true" val="Bool.or_eq_true" full_name="Bool.or_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(344, 43)" end="(344, 44)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(344, 45)" end="(344, 61)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(344, 45)" end="(344, 61)" leading="" trailing="" raw_val="Bool.and_eq_true" val="Bool.and_eq_true" full_name="Bool.and_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(344, 61)" end="(344, 62)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(344, 63)" end="(344, 65)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(344, 63)" end="(344, 65)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <AtomNode start="(344, 65)" end="(344, 66)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(344, 67)" end="(344, 72)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(344, 67)" end="(344, 72)" leading="" trailing="" raw_val="isEqv" val="isEqv" full_name="List.isEqv" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(344, 72)" end="(344, 73)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(344, 74)" end="(344, 85)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(344, 74)" end="(344, 85)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(344, 85)" end="(344, 86)" leading="" trailing="&#10;      " val="]"/>
                                                          </NullNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <OtherNode start="(345, 7)" end="(345, 18)" kind="Lean.Parser.Tactic.constructor" state_before="case cons.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ lt a b = true ∨&#10;      (a == b) = true ∧&#10;        ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true) ↔&#10;    ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true" state_after="case cons.cons.mp&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ lt a b = true ∨&#10;      (a == b) = true ∧&#10;        ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true) →&#10;    ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true&#10;&#10;case cons.cons.mpr&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ (((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h h₂,&#10;        (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true) →&#10;    lt a b = true ∨&#10;      (a == b) = true ∧&#10;        ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" tactic="constructor">
                                                          <AtomNode start="(345, 7)" end="(345, 18)" leading="" trailing="&#10;      " val="constructor"/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <OtherNode start="(346, 7)" end="(358, 27)" kind="Lean.cdot" state_before="case cons.cons.mp&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ lt a b = true ∨&#10;      (a == b) = true ∧&#10;        ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true) →&#10;    ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true&#10;&#10;case cons.cons.mpr&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ (((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h h₂,&#10;        (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true) →&#10;    lt a b = true ∨&#10;      (a == b) = true ∧&#10;        ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" state_after="case cons.cons.mpr&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ (((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h h₂,&#10;        (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true) →&#10;    lt a b = true ∨&#10;      (a == b) = true ∧&#10;        ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" tactic="· rintro (hab | ⟨hab, ⟨h₁, h₂⟩ | ⟨i, h₁, h₂, w₁, w₂⟩⟩)&#10;  · exact .inr ⟨0, by simp [hab]⟩&#10;  · exact .inl ⟨⟨hab, h₁⟩, by simpa using h₂⟩&#10;  · refine .inr ⟨i + 1, by simp [h₁],&#10;      by simp [h₂], ?_, ?_⟩&#10;    · intro j hj&#10;      cases j with&#10;      | zero =&amp;gt; simp [hab]&#10;      | succ j =&amp;gt;&#10;        simp only [getElem_cons_succ]&#10;        rw [w₁]&#10;        simpa using hj&#10;    · simpa using w₂">
                                                          <OtherNode start="(346, 7)" end="(346, 8)" kind="Lean.cdotTk">
                                                            <OtherNode start="(346, 7)" end="(346, 8)" kind="patternIgnore">
                                                            <OtherNode start="(346, 7)" end="(346, 8)" kind="token.«· »">
                                                            <AtomNode start="(346, 7)" end="(346, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                          <TacticTacticseqNode start="(346, 9)" end="(358, 27)">
                                                            <TacticTacticseq1IndentedNode start="(346, 9)" end="(358, 27)">
                                                            <NullNode start="(346, 9)" end="(358, 27)">
                                                            <OtherNode start="(346, 9)" end="(346, 61)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.cons.mp&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ lt a b = true ∨&#10;      (a == b) = true ∧&#10;        ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true) →&#10;    ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true" state_after="case cons.cons.mp.inl&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = true&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true&#10;&#10;case cons.cons.mp.inr.intro.inl.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;h₁ : (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;h₂ : l₁.length &amp;lt; l₂.length&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true&#10;&#10;case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true" tactic="rintro (hab | ⟨hab, ⟨h₁, h₂⟩ | ⟨i, h₁, h₂, w₁, w₂⟩⟩)">
                                                            <AtomNode start="(346, 9)" end="(346, 15)" leading="" trailing=" " val="rintro"/>
                                                            <NullNode start="(346, 16)" end="(346, 61)">
                                                            <OtherNode start="(346, 16)" end="(346, 61)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                            <OtherNode start="(346, 16)" end="(346, 61)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                            <AtomNode start="(346, 16)" end="(346, 17)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(346, 17)" end="(346, 60)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(346, 17)" end="(346, 60)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(346, 17)" end="(346, 60)">
                                                            <OtherNode start="(346, 17)" end="(346, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(346, 17)" end="(346, 20)" leading="" trailing=" " raw_val="hab" val="hab"/>
                                                            </OtherNode>
                                                            <AtomNode start="(346, 21)" end="(346, 22)" leading="" trailing=" " val="|"/>
                                                            <OtherNode start="(346, 23)" end="(346, 60)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(346, 23)" end="(346, 24)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(346, 24)" end="(346, 59)">
                                                            <OtherNode start="(346, 24)" end="(346, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(346, 24)" end="(346, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(346, 24)" end="(346, 27)">
                                                            <OtherNode start="(346, 24)" end="(346, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(346, 24)" end="(346, 27)" leading="" trailing="" raw_val="hab" val="hab"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(346, 27)" end="(346, 28)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(346, 29)" end="(346, 59)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(346, 29)" end="(346, 59)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(346, 29)" end="(346, 59)">
                                                            <OtherNode start="(346, 29)" end="(346, 37)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(346, 29)" end="(346, 30)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(346, 30)" end="(346, 36)">
                                                            <OtherNode start="(346, 30)" end="(346, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(346, 30)" end="(346, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(346, 30)" end="(346, 32)">
                                                            <OtherNode start="(346, 30)" end="(346, 32)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(346, 30)" end="(346, 32)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(346, 32)" end="(346, 33)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(346, 34)" end="(346, 36)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(346, 34)" end="(346, 36)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(346, 34)" end="(346, 36)">
                                                            <OtherNode start="(346, 34)" end="(346, 36)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(346, 34)" end="(346, 36)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(346, 36)" end="(346, 37)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            <AtomNode start="(346, 38)" end="(346, 39)" leading="" trailing=" " val="|"/>
                                                            <OtherNode start="(346, 40)" end="(346, 59)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(346, 40)" end="(346, 41)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(346, 41)" end="(346, 58)">
                                                            <OtherNode start="(346, 41)" end="(346, 42)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(346, 41)" end="(346, 42)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(346, 41)" end="(346, 42)">
                                                            <OtherNode start="(346, 41)" end="(346, 42)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(346, 41)" end="(346, 42)" leading="" trailing="" raw_val="i" val="i"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(346, 42)" end="(346, 43)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(346, 44)" end="(346, 46)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(346, 44)" end="(346, 46)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(346, 44)" end="(346, 46)">
                                                            <OtherNode start="(346, 44)" end="(346, 46)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(346, 44)" end="(346, 46)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(346, 46)" end="(346, 47)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(346, 48)" end="(346, 50)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(346, 48)" end="(346, 50)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(346, 48)" end="(346, 50)">
                                                            <OtherNode start="(346, 48)" end="(346, 50)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(346, 48)" end="(346, 50)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(346, 50)" end="(346, 51)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(346, 52)" end="(346, 54)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(346, 52)" end="(346, 54)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(346, 52)" end="(346, 54)">
                                                            <OtherNode start="(346, 52)" end="(346, 54)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(346, 52)" end="(346, 54)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(346, 54)" end="(346, 55)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(346, 56)" end="(346, 58)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(346, 56)" end="(346, 58)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(346, 56)" end="(346, 58)">
                                                            <OtherNode start="(346, 56)" end="(346, 58)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(346, 56)" end="(346, 58)" leading="" trailing="" raw_val="w₂" val="w₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(346, 58)" end="(346, 59)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(346, 59)" end="(346, 60)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(346, 60)" end="(346, 61)" leading="" trailing="&#10;        " val=")"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(347, 9)" end="(347, 40)" kind="Lean.cdot" state_before="case cons.cons.mp.inl&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = true&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true&#10;&#10;case cons.cons.mp.inr.intro.inl.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;h₁ : (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;h₂ : l₁.length &amp;lt; l₂.length&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true&#10;&#10;case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true" state_after="case cons.cons.mp.inr.intro.inl.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;h₁ : (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;h₂ : l₁.length &amp;lt; l₂.length&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true&#10;&#10;case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true" tactic="· exact .inr ⟨0, by simp [hab]⟩">
                                                            <OtherNode start="(347, 9)" end="(347, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(347, 9)" end="(347, 10)" kind="patternIgnore">
                                                            <OtherNode start="(347, 9)" end="(347, 10)" kind="token.«· »">
                                                            <AtomNode start="(347, 9)" end="(347, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(347, 11)" end="(347, 40)">
                                                            <TacticTacticseq1IndentedNode start="(347, 11)" end="(347, 40)">
                                                            <NullNode start="(347, 11)" end="(347, 40)">
                                                            <OtherNode start="(347, 11)" end="(347, 40)" kind="Lean.Parser.Tactic.exact" state_before="case cons.cons.mp.inl&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = true&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true" state_after="no goals" tactic="exact .inr ⟨0, by simp [hab]⟩">
                                                            <AtomNode start="(347, 11)" end="(347, 16)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(347, 17)" end="(347, 40)" kind="Lean.Parser.Term.app">
                                                            <OtherNode start="(347, 17)" end="(347, 21)" kind="Lean.Parser.Term.dotIdent">
                                                            <AtomNode start="(347, 17)" end="(347, 18)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(347, 18)" end="(347, 21)" leading="" trailing=" " raw_val="inr" val="inr"/>
                                                            </OtherNode>
                                                            <NullNode start="(347, 22)" end="(347, 40)">
                                                            <OtherNode start="(347, 22)" end="(347, 40)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(347, 22)" end="(347, 23)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(347, 23)" end="(347, 39)">
                                                            <OtherNode start="(347, 23)" end="(347, 24)" kind="num">
                                                            <AtomNode start="(347, 23)" end="(347, 24)" leading="" trailing="" val="0"/>
                                                            </OtherNode>
                                                            <AtomNode start="(347, 24)" end="(347, 25)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(347, 26)" end="(347, 39)">
                                                            <AtomNode start="(347, 26)" end="(347, 28)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(347, 29)" end="(347, 39)">
                                                            <TacticTacticseq1IndentedNode start="(347, 29)" end="(347, 39)">
                                                            <NullNode start="(347, 29)" end="(347, 39)">
                                                            <OtherNode start="(347, 29)" end="(347, 39)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = true&#10;⊢ ∃ h h₂, (∀ (j : Nat) (hj : j &amp;lt; 0), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[0] (b :: l₂)[0] = true" state_after="no goals" tactic="simp [hab]">
                                                            <AtomNode start="(347, 29)" end="(347, 33)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(347, 34)" end="(347, 39)">
                                                            <AtomNode start="(347, 34)" end="(347, 35)" leading="" trailing="" val="["/>
                                                            <NullNode start="(347, 35)" end="(347, 38)">
                                                            <OtherNode start="(347, 35)" end="(347, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(347, 35)" end="(347, 38)" leading="" trailing="" raw_val="hab" val="hab"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(347, 38)" end="(347, 39)" leading="" trailing="" val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            </NullNode>
                                                            <AtomNode start="(347, 39)" end="(347, 40)" leading="" trailing="&#10;        " val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(348, 9)" end="(348, 52)" kind="Lean.cdot" state_before="case cons.cons.mp.inr.intro.inl.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;h₁ : (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;h₂ : l₁.length &amp;lt; l₂.length&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true&#10;&#10;case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true" state_after="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true" tactic="· exact .inl ⟨⟨hab, h₁⟩, by simpa using h₂⟩">
                                                            <OtherNode start="(348, 9)" end="(348, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(348, 9)" end="(348, 10)" kind="patternIgnore">
                                                            <OtherNode start="(348, 9)" end="(348, 10)" kind="token.«· »">
                                                            <AtomNode start="(348, 9)" end="(348, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(348, 11)" end="(348, 52)">
                                                            <TacticTacticseq1IndentedNode start="(348, 11)" end="(348, 52)">
                                                            <NullNode start="(348, 11)" end="(348, 52)">
                                                            <OtherNode start="(348, 11)" end="(348, 52)" kind="Lean.Parser.Tactic.exact" state_before="case cons.cons.mp.inr.intro.inl.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;h₁ : (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;h₂ : l₁.length &amp;lt; l₂.length&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true" state_after="no goals" tactic="exact .inl ⟨⟨hab, h₁⟩, by simpa using h₂⟩">
                                                            <AtomNode start="(348, 11)" end="(348, 16)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(348, 17)" end="(348, 52)" kind="Lean.Parser.Term.app">
                                                            <OtherNode start="(348, 17)" end="(348, 21)" kind="Lean.Parser.Term.dotIdent">
                                                            <AtomNode start="(348, 17)" end="(348, 18)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(348, 18)" end="(348, 21)" leading="" trailing=" " raw_val="inl" val="inl"/>
                                                            </OtherNode>
                                                            <NullNode start="(348, 22)" end="(348, 52)">
                                                            <OtherNode start="(348, 22)" end="(348, 52)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(348, 22)" end="(348, 23)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(348, 23)" end="(348, 51)">
                                                            <OtherNode start="(348, 23)" end="(348, 32)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(348, 23)" end="(348, 24)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(348, 24)" end="(348, 31)">
                                                            <IdentNode start="(348, 24)" end="(348, 27)" leading="" trailing="" raw_val="hab" val="hab"/>
                                                            <AtomNode start="(348, 27)" end="(348, 28)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(348, 29)" end="(348, 31)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            <AtomNode start="(348, 31)" end="(348, 32)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            <AtomNode start="(348, 32)" end="(348, 33)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(348, 34)" end="(348, 51)">
                                                            <AtomNode start="(348, 34)" end="(348, 36)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(348, 37)" end="(348, 51)">
                                                            <TacticTacticseq1IndentedNode start="(348, 37)" end="(348, 51)">
                                                            <NullNode start="(348, 37)" end="(348, 51)">
                                                            <OtherNode start="(348, 37)" end="(348, 51)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;h₁ : (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;h₂ : l₁.length &amp;lt; l₂.length&#10;⊢ l₁.length &amp;lt; l₂.length" state_after="no goals" tactic="simpa using h₂">
                                                            <AtomNode start="(348, 37)" end="(348, 42)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(348, 43)" end="(348, 51)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(348, 43)" end="(348, 51)">
                                                            <AtomNode start="(348, 43)" end="(348, 48)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(348, 49)" end="(348, 51)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            </NullNode>
                                                            <AtomNode start="(348, 51)" end="(348, 52)" leading="" trailing="&#10;        " val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(349, 9)" end="(358, 27)" kind="Lean.cdot" state_before="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true" state_after="no goals" tactic="· refine .inr ⟨i + 1, by simp [h₁],&#10;    by simp [h₂], ?_, ?_⟩&#10;  · intro j hj&#10;    cases j with&#10;    | zero =&amp;gt; simp [hab]&#10;    | succ j =&amp;gt;&#10;      simp only [getElem_cons_succ]&#10;      rw [w₁]&#10;      simpa using hj&#10;  · simpa using w₂">
                                                            <OtherNode start="(349, 9)" end="(349, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(349, 9)" end="(349, 10)" kind="patternIgnore">
                                                            <OtherNode start="(349, 9)" end="(349, 10)" kind="token.«· »">
                                                            <AtomNode start="(349, 9)" end="(349, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(349, 11)" end="(358, 27)">
                                                            <TacticTacticseq1IndentedNode start="(349, 11)" end="(358, 27)">
                                                            <NullNode start="(349, 11)" end="(358, 27)">
                                                            <OtherNode start="(349, 11)" end="(350, 34)" kind="Lean.Parser.Tactic.refine" state_before="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ ((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true" state_after="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_1&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;&#10;case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true" tactic="refine .inr ⟨i + 1, by simp [h₁],&#10;  by simp [h₂], ?_, ?_⟩">
                                                            <AtomNode start="(349, 11)" end="(349, 17)" leading="" trailing=" " val="refine"/>
                                                            <OtherNode start="(349, 18)" end="(350, 34)" kind="Lean.Parser.Term.app">
                                                            <OtherNode start="(349, 18)" end="(349, 22)" kind="Lean.Parser.Term.dotIdent">
                                                            <AtomNode start="(349, 18)" end="(349, 19)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(349, 19)" end="(349, 22)" leading="" trailing=" " raw_val="inr" val="inr"/>
                                                            </OtherNode>
                                                            <NullNode start="(349, 23)" end="(350, 34)">
                                                            <OtherNode start="(349, 23)" end="(350, 34)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(349, 23)" end="(349, 24)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(349, 24)" end="(350, 33)">
                                                            <OtherNode start="(349, 24)" end="(349, 29)" kind="«term_+_»">
                                                            <IdentNode start="(349, 24)" end="(349, 25)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            <AtomNode start="(349, 26)" end="(349, 27)" leading="" trailing=" " val="+"/>
                                                            <OtherNode start="(349, 28)" end="(349, 29)" kind="num">
                                                            <AtomNode start="(349, 28)" end="(349, 29)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(349, 29)" end="(349, 30)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(349, 31)" end="(349, 43)">
                                                            <AtomNode start="(349, 31)" end="(349, 33)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(349, 34)" end="(349, 43)">
                                                            <TacticTacticseq1IndentedNode start="(349, 34)" end="(349, 43)">
                                                            <NullNode start="(349, 34)" end="(349, 43)">
                                                            <OtherNode start="(349, 34)" end="(349, 43)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ i + 1 &amp;lt; l₁.length + 1" state_after="no goals" tactic="simp [h₁]">
                                                            <AtomNode start="(349, 34)" end="(349, 38)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(349, 39)" end="(349, 43)">
                                                            <AtomNode start="(349, 39)" end="(349, 40)" leading="" trailing="" val="["/>
                                                            <NullNode start="(349, 40)" end="(349, 42)">
                                                            <OtherNode start="(349, 40)" end="(349, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(349, 40)" end="(349, 42)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(349, 42)" end="(349, 43)" leading="" trailing="" val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(349, 43)" end="(349, 44)" leading="" trailing="&#10;            " val=","/>
                                                            <TermBytacticNode start="(350, 13)" end="(350, 25)">
                                                            <AtomNode start="(350, 13)" end="(350, 15)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(350, 16)" end="(350, 25)">
                                                            <TacticTacticseq1IndentedNode start="(350, 16)" end="(350, 25)">
                                                            <NullNode start="(350, 16)" end="(350, 25)">
                                                            <OtherNode start="(350, 16)" end="(350, 25)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ i + 1 &amp;lt; l₂.length + 1" state_after="no goals" tactic="simp [h₂]">
                                                            <AtomNode start="(350, 16)" end="(350, 20)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(350, 21)" end="(350, 25)">
                                                            <AtomNode start="(350, 21)" end="(350, 22)" leading="" trailing="" val="["/>
                                                            <NullNode start="(350, 22)" end="(350, 24)">
                                                            <OtherNode start="(350, 22)" end="(350, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(350, 22)" end="(350, 24)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(350, 24)" end="(350, 25)" leading="" trailing="" val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(350, 25)" end="(350, 26)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(350, 27)" end="(350, 29)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(350, 27)" end="(350, 28)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(350, 28)" end="(350, 29)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            <AtomNode start="(350, 29)" end="(350, 30)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(350, 31)" end="(350, 33)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(350, 31)" end="(350, 32)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(350, 32)" end="(350, 33)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(350, 33)" end="(350, 34)" leading="" trailing="&#10;          " val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(351, 11)" end="(357, 29)" kind="Lean.cdot" state_before="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_1&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;&#10;case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true" state_after="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true" tactic="· intro j hj&#10;  cases j with&#10;  | zero =&amp;gt; simp [hab]&#10;  | succ j =&amp;gt;&#10;    simp only [getElem_cons_succ]&#10;    rw [w₁]&#10;    simpa using hj">
                                                            <OtherNode start="(351, 11)" end="(351, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(351, 11)" end="(351, 12)" kind="patternIgnore">
                                                            <OtherNode start="(351, 11)" end="(351, 12)" kind="token.«· »">
                                                            <AtomNode start="(351, 11)" end="(351, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(351, 13)" end="(357, 29)">
                                                            <TacticTacticseq1IndentedNode start="(351, 13)" end="(357, 29)">
                                                            <NullNode start="(351, 13)" end="(357, 29)">
                                                            <OtherNode start="(351, 13)" end="(351, 23)" kind="Lean.Parser.Tactic.intro" state_before="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_1&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true" state_after="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_1&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;j : Nat&#10;hj : j &amp;lt; i + 1&#10;⊢ ((a :: l₁)[j] == (b :: l₂)[j]) = true" tactic="intro j hj">
                                                            <AtomNode start="(351, 13)" end="(351, 18)" leading="" trailing=" " val="intro"/>
                                                            <NullNode start="(351, 19)" end="(351, 23)">
                                                            <IdentNode start="(351, 19)" end="(351, 20)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            <IdentNode start="(351, 21)" end="(351, 23)" leading="" trailing="&#10;            " raw_val="hj" val="hj"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(352, 13)" end="(357, 29)" kind="Lean.Parser.Tactic.cases" state_before="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_1&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;j : Nat&#10;hj : j &amp;lt; i + 1&#10;⊢ ((a :: l₁)[j] == (b :: l₂)[j]) = true" state_after="no goals" tactic="cases j with&#10;| zero =&amp;gt; simp [hab]&#10;| succ j =&amp;gt;&#10;  simp only [getElem_cons_succ]&#10;  rw [w₁]&#10;  simpa using hj">
                                                            <AtomNode start="(352, 13)" end="(352, 18)" leading="" trailing=" " val="cases"/>
                                                            <NullNode start="(352, 19)" end="(352, 20)">
                                                            <OtherNode start="(352, 19)" end="(352, 20)" kind="Lean.Parser.Tactic.elimTarget">
                                                            <NullNode/>
                                                            <IdentNode start="(352, 19)" end="(352, 20)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode start="(352, 21)" end="(357, 29)">
                                                            <OtherNode start="(352, 21)" end="(357, 29)" kind="Lean.Parser.Tactic.inductionAlts">
                                                            <AtomNode start="(352, 21)" end="(352, 25)" leading="" trailing="&#10;            " val="with"/>
                                                            <NullNode/>
                                                            <NullNode start="(353, 13)" end="(357, 29)">
                                                            <OtherNode start="(353, 13)" end="(353, 33)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(353, 13)" end="(353, 19)">
                                                            <OtherNode start="(353, 13)" end="(353, 19)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(353, 13)" end="(353, 14)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(353, 15)" end="(353, 19)">
                                                            <NullNode/>
                                                            <IdentNode start="(353, 15)" end="(353, 19)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                            </GroupNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(353, 20)" end="(353, 33)">
                                                            <AtomNode start="(353, 20)" end="(353, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(353, 23)" end="(353, 33)">
                                                            <TacticTacticseq1IndentedNode start="(353, 23)" end="(353, 33)">
                                                            <NullNode start="(353, 23)" end="(353, 33)">
                                                            <OtherNode start="(353, 23)" end="(353, 33)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_1.zero&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;hj : 0 &amp;lt; i + 1&#10;⊢ ((a :: l₁)[0] == (b :: l₂)[0]) = true" state_after="no goals" tactic="simp [hab]">
                                                            <AtomNode start="(353, 23)" end="(353, 27)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(353, 28)" end="(353, 33)">
                                                            <AtomNode start="(353, 28)" end="(353, 29)" leading="" trailing="" val="["/>
                                                            <NullNode start="(353, 29)" end="(353, 32)">
                                                            <OtherNode start="(353, 29)" end="(353, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(353, 29)" end="(353, 32)" leading="" trailing="" raw_val="hab" val="hab"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(353, 32)" end="(353, 33)" leading="" trailing="&#10;            " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <OtherNode start="(354, 13)" end="(357, 29)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(354, 13)" end="(354, 21)">
                                                            <OtherNode start="(354, 13)" end="(354, 21)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(354, 13)" end="(354, 14)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(354, 15)" end="(354, 19)">
                                                            <NullNode/>
                                                            <IdentNode start="(354, 15)" end="(354, 19)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                            </GroupNode>
                                                            <NullNode start="(354, 20)" end="(354, 21)">
                                                            <IdentNode start="(354, 20)" end="(354, 21)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(354, 22)" end="(357, 29)">
                                                            <AtomNode start="(354, 22)" end="(354, 24)" leading="" trailing="&#10;              " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(355, 15)" end="(357, 29)">
                                                            <TacticTacticseq1IndentedNode start="(355, 15)" end="(357, 29)">
                                                            <NullNode start="(355, 15)" end="(357, 29)">
                                                            <OtherNode start="(355, 15)" end="(355, 44)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_1.succ&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;j : Nat&#10;hj : j + 1 &amp;lt; i + 1&#10;⊢ ((a :: l₁)[j + 1] == (b :: l₂)[j + 1]) = true" state_after="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_1.succ&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;j : Nat&#10;hj : j + 1 &amp;lt; i + 1&#10;⊢ (l₁[j] == l₂[j]) = true" tactic="simp only [getElem_cons_succ]">
                                                            <AtomNode start="(355, 15)" end="(355, 19)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(355, 20)" end="(355, 24)">
                                                            <AtomNode start="(355, 20)" end="(355, 24)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(355, 25)" end="(355, 44)">
                                                            <AtomNode start="(355, 25)" end="(355, 26)" leading="" trailing="" val="["/>
                                                            <NullNode start="(355, 26)" end="(355, 43)">
                                                            <OtherNode start="(355, 26)" end="(355, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(355, 26)" end="(355, 43)" leading="" trailing="" raw_val="getElem_cons_succ" val="getElem_cons_succ" full_name="List.getElem_cons_succ" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(355, 43)" end="(355, 44)" leading="" trailing="&#10;              " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(356, 15)" end="(356, 22)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_1.succ&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;j : Nat&#10;hj : j + 1 &amp;lt; i + 1&#10;⊢ (l₁[j] == l₂[j]) = true" state_after="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_1.succ.hj&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;j : Nat&#10;hj : j + 1 &amp;lt; i + 1&#10;⊢ j &amp;lt; i" tactic="rw [w₁]">
                                                            <AtomNode start="(356, 15)" end="(356, 17)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(356, 18)" end="(356, 22)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(356, 18)" end="(356, 19)" leading="" trailing="" val="["/>
                                                            <NullNode start="(356, 19)" end="(356, 21)">
                                                            <OtherNode start="(356, 19)" end="(356, 21)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(356, 19)" end="(356, 21)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(356, 21)" end="(356, 22)" leading="" trailing="&#10;              " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(357, 15)" end="(357, 29)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_1.succ.hj&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;j : Nat&#10;hj : j + 1 &amp;lt; i + 1&#10;⊢ j &amp;lt; i" state_after="no goals" tactic="simpa using hj">
                                                            <AtomNode start="(357, 15)" end="(357, 20)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(357, 21)" end="(357, 29)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(357, 21)" end="(357, 29)">
                                                            <AtomNode start="(357, 21)" end="(357, 26)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(357, 27)" end="(357, 29)" leading="" trailing="&#10;          " raw_val="hj" val="hj"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(358, 11)" end="(358, 27)" kind="Lean.cdot" state_before="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true" state_after="no goals" tactic="· simpa using w₂">
                                                            <OtherNode start="(358, 11)" end="(358, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(358, 11)" end="(358, 12)" kind="patternIgnore">
                                                            <OtherNode start="(358, 11)" end="(358, 12)" kind="token.«· »">
                                                            <AtomNode start="(358, 11)" end="(358, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(358, 13)" end="(358, 27)">
                                                            <TacticTacticseq1IndentedNode start="(358, 13)" end="(358, 27)">
                                                            <NullNode start="(358, 13)" end="(358, 27)">
                                                            <OtherNode start="(358, 13)" end="(358, 27)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.cons.mp.inr.intro.inr.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : (a == b) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₁[i] l₂[i] = true&#10;⊢ lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true" state_after="no goals" tactic="simpa using w₂">
                                                            <AtomNode start="(358, 13)" end="(358, 18)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(358, 19)" end="(358, 27)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(358, 19)" end="(358, 27)">
                                                            <AtomNode start="(358, 19)" end="(358, 24)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(358, 25)" end="(358, 27)" leading="" trailing="&#10;      " raw_val="w₂" val="w₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <OtherNode start="(359, 7)" end="(372, 29)" kind="Lean.cdot" state_before="case cons.cons.mpr&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ (((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h h₂,&#10;        (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true) →&#10;    lt a b = true ∨&#10;      (a == b) = true ∧&#10;        ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" state_after="no goals" tactic="· rintro (⟨⟨h₁, h₂⟩, h₃⟩ | ⟨i, h₁, h₂, w₁, w₂⟩)&#10;  · exact .inr ⟨h₁, .inl ⟨h₂, by simpa using h₃⟩⟩&#10;  · cases i with&#10;    | zero =&amp;gt;&#10;      left&#10;      simpa using w₂&#10;    | succ i =&amp;gt;&#10;      right&#10;      refine ⟨by simpa using w₁ 0 (by simp), ?_⟩&#10;      right&#10;      refine ⟨i, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;      · intro j hj&#10;        simpa using w₁ (j + 1) (by simpa)&#10;      · simpa using w₂">
                                                          <OtherNode start="(359, 7)" end="(359, 8)" kind="Lean.cdotTk">
                                                            <OtherNode start="(359, 7)" end="(359, 8)" kind="patternIgnore">
                                                            <OtherNode start="(359, 7)" end="(359, 8)" kind="token.«· »">
                                                            <AtomNode start="(359, 7)" end="(359, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                          <TacticTacticseqNode start="(359, 9)" end="(372, 29)">
                                                            <TacticTacticseq1IndentedNode start="(359, 9)" end="(372, 29)">
                                                            <NullNode start="(359, 9)" end="(372, 29)">
                                                            <OtherNode start="(359, 9)" end="(359, 54)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.cons.mpr&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ (((a == b) = true ∧ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true) ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h h₂,&#10;        (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (a :: l₁)[i] (b :: l₂)[i] = true) →&#10;    lt a b = true ∨&#10;      (a == b) = true ∧&#10;        ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" state_after="case cons.cons.mpr.inl.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;h₃ : l₁.length &amp;lt; l₂.length&#10;h₁ : (a == b) = true&#10;h₂ : (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;⊢ lt a b = true ∨&#10;    (a == b) = true ∧&#10;      ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)&#10;&#10;case cons.cons.mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length + 1&#10;h₂ : i &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i] (b :: l₂)[i] = true&#10;⊢ lt a b = true ∨&#10;    (a == b) = true ∧&#10;      ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" tactic="rintro (⟨⟨h₁, h₂⟩, h₃⟩ | ⟨i, h₁, h₂, w₁, w₂⟩)">
                                                            <AtomNode start="(359, 9)" end="(359, 15)" leading="" trailing=" " val="rintro"/>
                                                            <NullNode start="(359, 16)" end="(359, 54)">
                                                            <OtherNode start="(359, 16)" end="(359, 54)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                            <OtherNode start="(359, 16)" end="(359, 54)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                            <AtomNode start="(359, 16)" end="(359, 17)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(359, 17)" end="(359, 53)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(359, 17)" end="(359, 53)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(359, 17)" end="(359, 53)">
                                                            <OtherNode start="(359, 17)" end="(359, 31)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(359, 17)" end="(359, 18)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(359, 18)" end="(359, 30)">
                                                            <OtherNode start="(359, 18)" end="(359, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(359, 18)" end="(359, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(359, 18)" end="(359, 26)">
                                                            <OtherNode start="(359, 18)" end="(359, 26)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(359, 18)" end="(359, 19)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(359, 19)" end="(359, 25)">
                                                            <OtherNode start="(359, 19)" end="(359, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(359, 19)" end="(359, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(359, 19)" end="(359, 21)">
                                                            <OtherNode start="(359, 19)" end="(359, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(359, 19)" end="(359, 21)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(359, 21)" end="(359, 22)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(359, 23)" end="(359, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(359, 23)" end="(359, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(359, 23)" end="(359, 25)">
                                                            <OtherNode start="(359, 23)" end="(359, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(359, 23)" end="(359, 25)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(359, 25)" end="(359, 26)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(359, 26)" end="(359, 27)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(359, 28)" end="(359, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(359, 28)" end="(359, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(359, 28)" end="(359, 30)">
                                                            <OtherNode start="(359, 28)" end="(359, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(359, 28)" end="(359, 30)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(359, 30)" end="(359, 31)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            <AtomNode start="(359, 32)" end="(359, 33)" leading="" trailing=" " val="|"/>
                                                            <OtherNode start="(359, 34)" end="(359, 53)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(359, 34)" end="(359, 35)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(359, 35)" end="(359, 52)">
                                                            <OtherNode start="(359, 35)" end="(359, 36)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(359, 35)" end="(359, 36)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(359, 35)" end="(359, 36)">
                                                            <OtherNode start="(359, 35)" end="(359, 36)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(359, 35)" end="(359, 36)" leading="" trailing="" raw_val="i" val="i"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(359, 36)" end="(359, 37)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(359, 38)" end="(359, 40)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(359, 38)" end="(359, 40)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(359, 38)" end="(359, 40)">
                                                            <OtherNode start="(359, 38)" end="(359, 40)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(359, 38)" end="(359, 40)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(359, 40)" end="(359, 41)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(359, 42)" end="(359, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(359, 42)" end="(359, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(359, 42)" end="(359, 44)">
                                                            <OtherNode start="(359, 42)" end="(359, 44)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(359, 42)" end="(359, 44)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(359, 44)" end="(359, 45)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(359, 46)" end="(359, 48)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(359, 46)" end="(359, 48)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(359, 46)" end="(359, 48)">
                                                            <OtherNode start="(359, 46)" end="(359, 48)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(359, 46)" end="(359, 48)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(359, 48)" end="(359, 49)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(359, 50)" end="(359, 52)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(359, 50)" end="(359, 52)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(359, 50)" end="(359, 52)">
                                                            <OtherNode start="(359, 50)" end="(359, 52)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(359, 50)" end="(359, 52)" leading="" trailing="" raw_val="w₂" val="w₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(359, 52)" end="(359, 53)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(359, 53)" end="(359, 54)" leading="" trailing="&#10;        " val=")"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(360, 9)" end="(360, 56)" kind="Lean.cdot" state_before="case cons.cons.mpr.inl.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;h₃ : l₁.length &amp;lt; l₂.length&#10;h₁ : (a == b) = true&#10;h₂ : (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;⊢ lt a b = true ∨&#10;    (a == b) = true ∧&#10;      ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)&#10;&#10;case cons.cons.mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length + 1&#10;h₂ : i &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i] (b :: l₂)[i] = true&#10;⊢ lt a b = true ∨&#10;    (a == b) = true ∧&#10;      ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length + 1&#10;h₂ : i &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i] (b :: l₂)[i] = true&#10;⊢ lt a b = true ∨&#10;    (a == b) = true ∧&#10;      ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" tactic="· exact .inr ⟨h₁, .inl ⟨h₂, by simpa using h₃⟩⟩">
                                                            <OtherNode start="(360, 9)" end="(360, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(360, 9)" end="(360, 10)" kind="patternIgnore">
                                                            <OtherNode start="(360, 9)" end="(360, 10)" kind="token.«· »">
                                                            <AtomNode start="(360, 9)" end="(360, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(360, 11)" end="(360, 56)">
                                                            <TacticTacticseq1IndentedNode start="(360, 11)" end="(360, 56)">
                                                            <NullNode start="(360, 11)" end="(360, 56)">
                                                            <OtherNode start="(360, 11)" end="(360, 56)" kind="Lean.Parser.Tactic.exact" state_before="case cons.cons.mpr.inl.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;h₃ : l₁.length &amp;lt; l₂.length&#10;h₁ : (a == b) = true&#10;h₂ : (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;⊢ lt a b = true ∨&#10;    (a == b) = true ∧&#10;      ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" state_after="no goals" tactic="exact .inr ⟨h₁, .inl ⟨h₂, by simpa using h₃⟩⟩">
                                                            <AtomNode start="(360, 11)" end="(360, 16)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(360, 17)" end="(360, 56)" kind="Lean.Parser.Term.app">
                                                            <OtherNode start="(360, 17)" end="(360, 21)" kind="Lean.Parser.Term.dotIdent">
                                                            <AtomNode start="(360, 17)" end="(360, 18)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(360, 18)" end="(360, 21)" leading="" trailing=" " raw_val="inr" val="inr"/>
                                                            </OtherNode>
                                                            <NullNode start="(360, 22)" end="(360, 56)">
                                                            <OtherNode start="(360, 22)" end="(360, 56)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(360, 22)" end="(360, 23)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(360, 23)" end="(360, 55)">
                                                            <IdentNode start="(360, 23)" end="(360, 25)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            <AtomNode start="(360, 25)" end="(360, 26)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(360, 27)" end="(360, 55)" kind="Lean.Parser.Term.app">
                                                            <OtherNode start="(360, 27)" end="(360, 31)" kind="Lean.Parser.Term.dotIdent">
                                                            <AtomNode start="(360, 27)" end="(360, 28)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(360, 28)" end="(360, 31)" leading="" trailing=" " raw_val="inl" val="inl"/>
                                                            </OtherNode>
                                                            <NullNode start="(360, 32)" end="(360, 55)">
                                                            <OtherNode start="(360, 32)" end="(360, 55)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(360, 32)" end="(360, 33)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(360, 33)" end="(360, 54)">
                                                            <IdentNode start="(360, 33)" end="(360, 35)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            <AtomNode start="(360, 35)" end="(360, 36)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(360, 37)" end="(360, 54)">
                                                            <AtomNode start="(360, 37)" end="(360, 39)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(360, 40)" end="(360, 54)">
                                                            <TacticTacticseq1IndentedNode start="(360, 40)" end="(360, 54)">
                                                            <NullNode start="(360, 40)" end="(360, 54)">
                                                            <OtherNode start="(360, 40)" end="(360, 54)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;h₃ : l₁.length &amp;lt; l₂.length&#10;h₁ : (a == b) = true&#10;h₂ : (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;⊢ l₁.length &amp;lt; l₂.length" state_after="no goals" tactic="simpa using h₃">
                                                            <AtomNode start="(360, 40)" end="(360, 45)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(360, 46)" end="(360, 54)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(360, 46)" end="(360, 54)">
                                                            <AtomNode start="(360, 46)" end="(360, 51)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(360, 52)" end="(360, 54)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            </NullNode>
                                                            <AtomNode start="(360, 54)" end="(360, 55)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(360, 55)" end="(360, 56)" leading="" trailing="&#10;        " val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(361, 9)" end="(372, 29)" kind="Lean.cdot" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length + 1&#10;h₂ : i &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i] (b :: l₂)[i] = true&#10;⊢ lt a b = true ∨&#10;    (a == b) = true ∧&#10;      ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" state_after="no goals" tactic="· cases i with&#10;  | zero =&amp;gt;&#10;    left&#10;    simpa using w₂&#10;  | succ i =&amp;gt;&#10;    right&#10;    refine ⟨by simpa using w₁ 0 (by simp), ?_⟩&#10;    right&#10;    refine ⟨i, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;    · intro j hj&#10;      simpa using w₁ (j + 1) (by simpa)&#10;    · simpa using w₂">
                                                            <OtherNode start="(361, 9)" end="(361, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(361, 9)" end="(361, 10)" kind="patternIgnore">
                                                            <OtherNode start="(361, 9)" end="(361, 10)" kind="token.«· »">
                                                            <AtomNode start="(361, 9)" end="(361, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(361, 11)" end="(372, 29)">
                                                            <TacticTacticseq1IndentedNode start="(361, 11)" end="(372, 29)">
                                                            <NullNode start="(361, 11)" end="(372, 29)">
                                                            <OtherNode start="(361, 11)" end="(372, 29)" kind="Lean.Parser.Tactic.cases" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length + 1&#10;h₂ : i &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i] (b :: l₂)[i] = true&#10;⊢ lt a b = true ∨&#10;    (a == b) = true ∧&#10;      ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" state_after="no goals" tactic="cases i with&#10;| zero =&amp;gt;&#10;  left&#10;  simpa using w₂&#10;| succ i =&amp;gt;&#10;  right&#10;  refine ⟨by simpa using w₁ 0 (by simp), ?_⟩&#10;  right&#10;  refine ⟨i, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;  · intro j hj&#10;    simpa using w₁ (j + 1) (by simpa)&#10;  · simpa using w₂">
                                                            <AtomNode start="(361, 11)" end="(361, 16)" leading="" trailing=" " val="cases"/>
                                                            <NullNode start="(361, 17)" end="(361, 18)">
                                                            <OtherNode start="(361, 17)" end="(361, 18)" kind="Lean.Parser.Tactic.elimTarget">
                                                            <NullNode/>
                                                            <IdentNode start="(361, 17)" end="(361, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode start="(361, 19)" end="(372, 29)">
                                                            <OtherNode start="(361, 19)" end="(372, 29)" kind="Lean.Parser.Tactic.inductionAlts">
                                                            <AtomNode start="(361, 19)" end="(361, 23)" leading="" trailing="&#10;          " val="with"/>
                                                            <NullNode/>
                                                            <NullNode start="(362, 11)" end="(372, 29)">
                                                            <OtherNode start="(362, 11)" end="(364, 27)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(362, 11)" end="(362, 17)">
                                                            <OtherNode start="(362, 11)" end="(362, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(362, 11)" end="(362, 12)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(362, 13)" end="(362, 17)">
                                                            <NullNode/>
                                                            <IdentNode start="(362, 13)" end="(362, 17)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                            </GroupNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(362, 18)" end="(364, 27)">
                                                            <AtomNode start="(362, 18)" end="(362, 20)" leading="" trailing="&#10;            " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(363, 13)" end="(364, 27)">
                                                            <TacticTacticseq1IndentedNode start="(363, 13)" end="(364, 27)">
                                                            <NullNode start="(363, 13)" end="(364, 27)">
                                                            <OtherNode start="(363, 13)" end="(363, 17)" kind="Lean.Parser.Tactic.left" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.zero&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;h₁ : 0 &amp;lt; l₁.length + 1&#10;h₂ : 0 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; 0), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[0] (b :: l₂)[0] = true&#10;⊢ lt a b = true ∨&#10;    (a == b) = true ∧&#10;      ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.zero.h&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;h₁ : 0 &amp;lt; l₁.length + 1&#10;h₂ : 0 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; 0), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[0] (b :: l₂)[0] = true&#10;⊢ lt a b = true" tactic="left">
                                                            <AtomNode start="(363, 13)" end="(363, 17)" leading="" trailing="&#10;            " val="left"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(364, 13)" end="(364, 27)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.zero.h&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;h₁ : 0 &amp;lt; l₁.length + 1&#10;h₂ : 0 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; 0), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[0] (b :: l₂)[0] = true&#10;⊢ lt a b = true" state_after="no goals" tactic="simpa using w₂">
                                                            <AtomNode start="(364, 13)" end="(364, 18)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(364, 19)" end="(364, 27)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(364, 19)" end="(364, 27)">
                                                            <AtomNode start="(364, 19)" end="(364, 24)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(364, 25)" end="(364, 27)" leading="" trailing="&#10;          " raw_val="w₂" val="w₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <OtherNode start="(365, 11)" end="(372, 29)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(365, 11)" end="(365, 19)">
                                                            <OtherNode start="(365, 11)" end="(365, 19)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(365, 11)" end="(365, 12)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(365, 13)" end="(365, 17)">
                                                            <NullNode/>
                                                            <IdentNode start="(365, 13)" end="(365, 17)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                            </GroupNode>
                                                            <NullNode start="(365, 18)" end="(365, 19)">
                                                            <IdentNode start="(365, 18)" end="(365, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(365, 20)" end="(372, 29)">
                                                            <AtomNode start="(365, 20)" end="(365, 22)" leading="" trailing="&#10;            " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(366, 13)" end="(372, 29)">
                                                            <TacticTacticseq1IndentedNode start="(366, 13)" end="(372, 29)">
                                                            <NullNode start="(366, 13)" end="(372, 29)">
                                                            <OtherNode start="(366, 13)" end="(366, 18)" kind="Lean.Parser.Tactic.right" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ lt a b = true ∨&#10;    (a == b) = true ∧&#10;      ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ (a == b) = true ∧&#10;    ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" tactic="right">
                                                            <AtomNode start="(366, 13)" end="(366, 18)" leading="" trailing="&#10;            " val="right"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(367, 13)" end="(367, 55)" kind="Lean.Parser.Tactic.refine" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ (a == b) = true ∧&#10;    ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true)" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true" tactic="refine ⟨by simpa using w₁ 0 (by simp), ?_⟩">
                                                            <AtomNode start="(367, 13)" end="(367, 19)" leading="" trailing=" " val="refine"/>
                                                            <OtherNode start="(367, 20)" end="(367, 55)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(367, 20)" end="(367, 21)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(367, 21)" end="(367, 54)">
                                                            <TermBytacticNode start="(367, 21)" end="(367, 50)">
                                                            <AtomNode start="(367, 21)" end="(367, 23)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(367, 24)" end="(367, 50)">
                                                            <TacticTacticseq1IndentedNode start="(367, 24)" end="(367, 50)">
                                                            <NullNode start="(367, 24)" end="(367, 50)">
                                                            <OtherNode start="(367, 24)" end="(367, 50)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ (a == b) = true" state_after="no goals" tactic="simpa using w₁ 0 (by simp)">
                                                            <AtomNode start="(367, 24)" end="(367, 29)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(367, 30)" end="(367, 50)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(367, 30)" end="(367, 50)">
                                                            <AtomNode start="(367, 30)" end="(367, 35)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(367, 36)" end="(367, 50)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(367, 36)" end="(367, 38)" leading="" trailing=" " raw_val="w₁" val="w₁"/>
                                                            <NullNode start="(367, 39)" end="(367, 50)">
                                                            <OtherNode start="(367, 39)" end="(367, 40)" kind="num">
                                                            <AtomNode start="(367, 39)" end="(367, 40)" leading="" trailing=" " val="0"/>
                                                            </OtherNode>
                                                            <OtherNode start="(367, 41)" end="(367, 50)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(367, 41)" end="(367, 42)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(367, 42)" end="(367, 49)">
                                                            <AtomNode start="(367, 42)" end="(367, 44)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(367, 45)" end="(367, 49)">
                                                            <TacticTacticseq1IndentedNode start="(367, 45)" end="(367, 49)">
                                                            <NullNode start="(367, 45)" end="(367, 49)">
                                                            <OtherNode start="(367, 45)" end="(367, 49)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ 0 &amp;lt; i + 1" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(367, 45)" end="(367, 49)" leading="" trailing="" val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(367, 49)" end="(367, 50)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(367, 50)" end="(367, 51)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(367, 52)" end="(367, 54)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(367, 52)" end="(367, 53)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(367, 53)" end="(367, 54)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(367, 54)" end="(367, 55)" leading="" trailing="&#10;            " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(368, 13)" end="(368, 18)" kind="Lean.Parser.Tactic.right" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h.h&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true" tactic="right">
                                                            <AtomNode start="(368, 13)" end="(368, 18)" leading="" trailing="&#10;            " val="right"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(369, 13)" end="(369, 69)" kind="Lean.Parser.Tactic.refine" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h.h&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h.h.refine_1&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;&#10;case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h.h.refine_2&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ lt l₁[i] l₂[i] = true" tactic="refine ⟨i, by simpa using h₁, by simpa using h₂, ?_, ?_⟩">
                                                            <AtomNode start="(369, 13)" end="(369, 19)" leading="" trailing=" " val="refine"/>
                                                            <OtherNode start="(369, 20)" end="(369, 69)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(369, 20)" end="(369, 21)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(369, 21)" end="(369, 68)">
                                                            <IdentNode start="(369, 21)" end="(369, 22)" leading="" trailing="" raw_val="i" val="i"/>
                                                            <AtomNode start="(369, 22)" end="(369, 23)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(369, 24)" end="(369, 41)">
                                                            <AtomNode start="(369, 24)" end="(369, 26)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(369, 27)" end="(369, 41)">
                                                            <TacticTacticseq1IndentedNode start="(369, 27)" end="(369, 41)">
                                                            <NullNode start="(369, 27)" end="(369, 41)">
                                                            <OtherNode start="(369, 27)" end="(369, 41)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ i &amp;lt; l₁.length" state_after="no goals" tactic="simpa using h₁">
                                                            <AtomNode start="(369, 27)" end="(369, 32)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(369, 33)" end="(369, 41)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(369, 33)" end="(369, 41)">
                                                            <AtomNode start="(369, 33)" end="(369, 38)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(369, 39)" end="(369, 41)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(369, 41)" end="(369, 42)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(369, 43)" end="(369, 60)">
                                                            <AtomNode start="(369, 43)" end="(369, 45)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(369, 46)" end="(369, 60)">
                                                            <TacticTacticseq1IndentedNode start="(369, 46)" end="(369, 60)">
                                                            <NullNode start="(369, 46)" end="(369, 60)">
                                                            <OtherNode start="(369, 46)" end="(369, 60)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ i &amp;lt; l₂.length" state_after="no goals" tactic="simpa using h₂">
                                                            <AtomNode start="(369, 46)" end="(369, 51)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(369, 52)" end="(369, 60)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(369, 52)" end="(369, 60)">
                                                            <AtomNode start="(369, 52)" end="(369, 57)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(369, 58)" end="(369, 60)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(369, 60)" end="(369, 61)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(369, 62)" end="(369, 64)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(369, 62)" end="(369, 63)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(369, 63)" end="(369, 64)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            <AtomNode start="(369, 64)" end="(369, 65)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(369, 66)" end="(369, 68)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(369, 66)" end="(369, 67)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(369, 67)" end="(369, 68)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(369, 68)" end="(369, 69)" leading="" trailing="&#10;            " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(370, 13)" end="(371, 48)" kind="Lean.cdot" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h.h.refine_1&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;&#10;case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h.h.refine_2&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ lt l₁[i] l₂[i] = true" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h.h.refine_2&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ lt l₁[i] l₂[i] = true" tactic="· intro j hj&#10;  simpa using w₁ (j + 1) (by simpa)">
                                                            <OtherNode start="(370, 13)" end="(370, 14)" kind="Lean.cdotTk">
                                                            <OtherNode start="(370, 13)" end="(370, 14)" kind="patternIgnore">
                                                            <OtherNode start="(370, 13)" end="(370, 14)" kind="token.«· »">
                                                            <AtomNode start="(370, 13)" end="(370, 14)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(370, 15)" end="(371, 48)">
                                                            <TacticTacticseq1IndentedNode start="(370, 15)" end="(371, 48)">
                                                            <NullNode start="(370, 15)" end="(371, 48)">
                                                            <OtherNode start="(370, 15)" end="(370, 25)" kind="Lean.Parser.Tactic.intro" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h.h.refine_1&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h.h.refine_1&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;j : Nat&#10;hj : j &amp;lt; i&#10;⊢ (l₁[j] == l₂[j]) = true" tactic="intro j hj">
                                                            <AtomNode start="(370, 15)" end="(370, 20)" leading="" trailing=" " val="intro"/>
                                                            <NullNode start="(370, 21)" end="(370, 25)">
                                                            <IdentNode start="(370, 21)" end="(370, 22)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            <IdentNode start="(370, 23)" end="(370, 25)" leading="" trailing="&#10;              " raw_val="hj" val="hj"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(371, 15)" end="(371, 48)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h.h.refine_1&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;j : Nat&#10;hj : j &amp;lt; i&#10;⊢ (l₁[j] == l₂[j]) = true" state_after="no goals" tactic="simpa using w₁ (j + 1) (by simpa)">
                                                            <AtomNode start="(371, 15)" end="(371, 20)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(371, 21)" end="(371, 48)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(371, 21)" end="(371, 48)">
                                                            <AtomNode start="(371, 21)" end="(371, 26)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(371, 27)" end="(371, 48)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(371, 27)" end="(371, 29)" leading="" trailing=" " raw_val="w₁" val="w₁"/>
                                                            <NullNode start="(371, 30)" end="(371, 48)">
                                                            <OtherNode start="(371, 30)" end="(371, 37)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(371, 30)" end="(371, 31)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(371, 31)" end="(371, 36)" kind="«term_+_»">
                                                            <IdentNode start="(371, 31)" end="(371, 32)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            <AtomNode start="(371, 33)" end="(371, 34)" leading="" trailing=" " val="+"/>
                                                            <OtherNode start="(371, 35)" end="(371, 36)" kind="num">
                                                            <AtomNode start="(371, 35)" end="(371, 36)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(371, 36)" end="(371, 37)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <OtherNode start="(371, 38)" end="(371, 48)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(371, 38)" end="(371, 39)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(371, 39)" end="(371, 47)">
                                                            <AtomNode start="(371, 39)" end="(371, 41)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(371, 42)" end="(371, 47)">
                                                            <TacticTacticseq1IndentedNode start="(371, 42)" end="(371, 47)">
                                                            <NullNode start="(371, 42)" end="(371, 47)">
                                                            <OtherNode start="(371, 42)" end="(371, 47)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;j : Nat&#10;hj : j &amp;lt; i&#10;⊢ j + 1 &amp;lt; i + 1" state_after="no goals" tactic="simpa">
                                                            <AtomNode start="(371, 42)" end="(371, 47)" leading="" trailing="" val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(371, 47)" end="(371, 48)" leading="" trailing="&#10;            " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(372, 13)" end="(372, 29)" kind="Lean.cdot" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h.h.refine_2&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ lt l₁[i] l₂[i] = true" state_after="no goals" tactic="· simpa using w₂">
                                                            <OtherNode start="(372, 13)" end="(372, 14)" kind="Lean.cdotTk">
                                                            <OtherNode start="(372, 13)" end="(372, 14)" kind="patternIgnore">
                                                            <OtherNode start="(372, 13)" end="(372, 14)" kind="token.«· »">
                                                            <AtomNode start="(372, 13)" end="(372, 14)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(372, 15)" end="(372, 29)">
                                                            <TacticTacticseq1IndentedNode start="(372, 15)" end="(372, 29)">
                                                            <NullNode start="(372, 15)" end="(372, 29)">
                                                            <OtherNode start="(372, 15)" end="(372, 29)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.h.h.refine_2&#10;α : Type u_1&#10;inst✝ : BEq α&#10;lt : α → α → Bool&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = true ↔&#10;      (l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₁[i] l₂[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (a :: l₁)[i + 1] (b :: l₂)[i + 1] = true&#10;⊢ lt l₁[i] l₂[i] = true" state_after="no goals" tactic="simpa using w₂">
                                                            <AtomNode start="(372, 15)" end="(372, 20)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(372, 21)" end="(372, 29)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(372, 21)" end="(372, 29)">
                                                            <AtomNode start="(372, 21)" end="(372, 26)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(372, 27)" end="(372, 29)" leading="" trailing="&#10;&#10;" raw_val="w₂" val="w₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </NullNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </NullNode>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                </TacticTacticseq1IndentedNode>
              </TacticTacticseqNode>
            </TermBytacticNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </CommandDeclvalsimpleNode>
        </CommandTheoremNode>
      </CommandDeclarationNode>
    </OtherNode>
    <OtherNode start="(374, 1)" end="(444, 29)" kind="Lean.Parser.Command.in">
      <OtherNode start="(374, 1)" end="(374, 50)" kind="Lean.Parser.Command.attribute">
        <AtomNode start="(374, 1)" end="(374, 10)" leading="" trailing=" " val="attribute"/>
        <AtomNode start="(374, 11)" end="(374, 12)" leading="" trailing="" val="["/>
        <NullNode start="(374, 12)" end="(374, 22)">
          <OtherNode start="(374, 12)" end="(374, 22)" kind="Lean.Parser.Term.attrInstance">
            <TermAttrkindNode start="(374, 12)" end="(374, 17)">
              <NullNode start="(374, 12)" end="(374, 17)">
                <OtherNode start="(374, 12)" end="(374, 17)" kind="Lean.Parser.Term.local">
                  <AtomNode start="(374, 12)" end="(374, 17)" leading="" trailing=" " val="local"/>
                </OtherNode>
              </NullNode>
            </TermAttrkindNode>
            <OtherNode start="(374, 18)" end="(374, 22)" kind="Lean.Parser.Attr.simp">
              <AtomNode start="(374, 18)" end="(374, 22)" leading="" trailing="" val="simp"/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
            </OtherNode>
          </OtherNode>
        </NullNode>
        <AtomNode start="(374, 22)" end="(374, 23)" leading="" trailing=" " val="]"/>
        <NullNode start="(374, 24)" end="(374, 50)">
          <IdentNode start="(374, 24)" end="(374, 50)" leading="" trailing=" " raw_val="Nat.add_one_lt_add_one_iff" val="Nat.add_one_lt_add_one_iff" full_name="Nat.add_one_lt_add_one_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
        </NullNode>
      </OtherNode>
      <AtomNode start="(374, 51)" end="(374, 53)" leading="" trailing="&#10;" val="in"/>
      <CommandDeclarationNode start="(375, 1)" end="(444, 29)" name="lex_eq_false_iff_exists" full_name="List.lex_eq_false_iff_exists">
        <CommandDeclmodifiersNode start="(375, 1)" end="(389, 3)">
          <NullNode start="(375, 1)" end="(389, 3)">
            <CommandDoccommentNode start="(375, 1)" end="(389, 3)" comment="`l₁` is *not* lexicographically less than `l₂`&#10;(which you might think of as &amp;quot;`l₂` is lexicographically greater than or equal to `l₁`&amp;quot;&amp;quot;) if either&#10;- `l₁` is pairwise equivalent under `· == ·` to `l₂.take l₁.length` or&#10;- there exists an index `i` such that&#10;  - for all `j &amp;lt; i`, `l₁[j] == l₂[j]` and&#10;  - `l₂[i] &amp;lt; l₁[i]`&#10;&#10;This formulation requires that `==` and `lt` are compatible in the following senses:&#10;- `==` is symmetric&#10;  (we unnecessarily further assume it is transitive, to make use of the existing typeclasses)&#10;- `lt` is irreflexive with respect to `==` (i.e. if `x == y` then `lt x y = false`&#10;- `lt` is asymmetric  (i.e. `lt x y = true → lt y x = false`)&#10;- `lt` is antisymmetric with respect to `==` (i.e. `lt x y = false → lt y x = false → x == y`)&#10;-/">
              <AtomNode start="(375, 1)" end="(375, 4)" leading="" trailing="&#10;" val="/--"/>
              <AtomNode start="(376, 1)" end="(389, 3)" leading="" trailing="&#10;" val="`l₁` is *not* lexicographically less than `l₂`&#10;(which you might think of as &amp;quot;`l₂` is lexicographically greater than or equal to `l₁`&amp;quot;&amp;quot;) if either&#10;- `l₁` is pairwise equivalent under `· == ·` to `l₂.take l₁.length` or&#10;- there exists an index `i` such that&#10;  - for all `j &amp;lt; i`, `l₁[j] == l₂[j]` and&#10;  - `l₂[i] &amp;lt; l₁[i]`&#10;&#10;This formulation requires that `==` and `lt` are compatible in the following senses:&#10;- `==` is symmetric&#10;  (we unnecessarily further assume it is transitive, to make use of the existing typeclasses)&#10;- `lt` is irreflexive with respect to `==` (i.e. if `x == y` then `lt x y = false`&#10;- `lt` is asymmetric  (i.e. `lt x y = true → lt y x = false`)&#10;- `lt` is antisymmetric with respect to `==` (i.e. `lt x y = false → lt y x = false → x == y`)&#10;-/"/>
            </CommandDoccommentNode>
          </NullNode>
          <NullNode/>
          <NullNode/>
          <NullNode/>
          <NullNode/>
          <NullNode/>
        </CommandDeclmodifiersNode>
        <CommandTheoremNode start="(390, 1)" end="(444, 29)" name="lex_eq_false_iff_exists" full_name="List.lex_eq_false_iff_exists" _is_private_decl="False">
          <AtomNode start="(390, 1)" end="(390, 8)" leading="" trailing=" " val="theorem"/>
          <CommandDeclidNode start="(390, 9)" end="(390, 32)">
            <IdentNode start="(390, 9)" end="(390, 32)" leading="" trailing=" " raw_val="lex_eq_false_iff_exists" val="lex_eq_false_iff_exists"/>
            <NullNode/>
          </CommandDeclidNode>
          <CommandDeclsigNode start="(390, 33)" end="(398, 88)">
            <NullNode start="(390, 33)" end="(393, 68)">
              <OtherNode start="(390, 33)" end="(390, 40)" kind="Lean.Parser.Term.instBinder">
                <AtomNode start="(390, 33)" end="(390, 34)" leading="" trailing="" val="["/>
                <NullNode/>
                <OtherNode start="(390, 34)" end="(390, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(390, 34)" end="(390, 37)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(390, 38)" end="(390, 39)">
                    <IdentNode start="(390, 38)" end="(390, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(390, 39)" end="(390, 40)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <OtherNode start="(390, 41)" end="(390, 60)" kind="Lean.Parser.Term.instBinder">
                <AtomNode start="(390, 41)" end="(390, 42)" leading="" trailing="" val="["/>
                <NullNode/>
                <OtherNode start="(390, 42)" end="(390, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(390, 42)" end="(390, 57)" leading="" trailing=" " raw_val="PartialEquivBEq" val="PartialEquivBEq" full_name="PartialEquivBEq" mod_name="Init.Data.BEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BEq.lean"/>
                  <NullNode start="(390, 58)" end="(390, 59)">
                    <IdentNode start="(390, 58)" end="(390, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(390, 59)" end="(390, 60)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <TermExplicitbinderNode start="(390, 61)" end="(390, 80)">
                <AtomNode start="(390, 61)" end="(390, 62)" leading="" trailing="" val="("/>
                <NullNode start="(390, 62)" end="(390, 64)">
                  <IdentNode start="(390, 62)" end="(390, 64)" leading="" trailing=" " raw_val="lt" val="lt"/>
                </NullNode>
                <NullNode start="(390, 65)" end="(390, 79)">
                  <AtomNode start="(390, 65)" end="(390, 66)" leading="" trailing=" " val=":"/>
                  <OtherNode start="(390, 67)" end="(390, 79)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(390, 67)" end="(390, 68)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(390, 69)" end="(390, 70)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(390, 71)" end="(390, 79)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(390, 71)" end="(390, 72)" leading="" trailing=" " raw_val="α" val="α"/>
                      <AtomNode start="(390, 73)" end="(390, 74)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(390, 75)" end="(390, 79)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <NullNode/>
                <AtomNode start="(390, 79)" end="(390, 80)" leading="" trailing="&#10;    " val=")"/>
              </TermExplicitbinderNode>
              <TermExplicitbinderNode start="(391, 5)" end="(391, 49)">
                <AtomNode start="(391, 5)" end="(391, 6)" leading="" trailing="" val="("/>
                <NullNode start="(391, 6)" end="(391, 15)">
                  <IdentNode start="(391, 6)" end="(391, 15)" leading="" trailing=" " raw_val="lt_irrefl" val="lt_irrefl"/>
                </NullNode>
                <NullNode start="(391, 16)" end="(391, 48)">
                  <AtomNode start="(391, 16)" end="(391, 17)" leading="" trailing=" " val=":"/>
                  <OtherNode start="(391, 18)" end="(391, 48)" kind="Lean.Parser.Term.forall">
                    <AtomNode start="(391, 18)" end="(391, 19)" leading="" trailing=" " val="∀"/>
                    <NullNode start="(391, 20)" end="(391, 23)">
                      <IdentNode start="(391, 20)" end="(391, 21)" leading="" trailing=" " raw_val="x" val="x"/>
                      <IdentNode start="(391, 22)" end="(391, 23)" leading="" trailing="" raw_val="y" val="y"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(391, 23)" end="(391, 24)" leading="" trailing=" " val=","/>
                    <OtherNode start="(391, 25)" end="(391, 48)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(391, 25)" end="(391, 31)" kind="«term_==_»">
                        <IdentNode start="(391, 25)" end="(391, 26)" leading="" trailing=" " raw_val="x" val="x"/>
                        <AtomNode start="(391, 27)" end="(391, 29)" leading="" trailing=" " val="=="/>
                        <IdentNode start="(391, 30)" end="(391, 31)" leading="" trailing=" " raw_val="y" val="y"/>
                      </OtherNode>
                      <AtomNode start="(391, 32)" end="(391, 33)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(391, 34)" end="(391, 48)" kind="«term_=_»">
                        <OtherNode start="(391, 34)" end="(391, 40)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(391, 34)" end="(391, 36)" leading="" trailing=" " raw_val="lt" val="lt"/>
                          <NullNode start="(391, 37)" end="(391, 40)">
                            <IdentNode start="(391, 37)" end="(391, 38)" leading="" trailing=" " raw_val="x" val="x"/>
                            <IdentNode start="(391, 39)" end="(391, 40)" leading="" trailing=" " raw_val="y" val="y"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(391, 41)" end="(391, 42)" leading="" trailing=" " val="="/>
                        <IdentNode start="(391, 43)" end="(391, 48)" leading="" trailing="" raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <NullNode/>
                <AtomNode start="(391, 48)" end="(391, 49)" leading="" trailing="&#10;    " val=")"/>
              </TermExplicitbinderNode>
              <TermExplicitbinderNode start="(392, 5)" end="(392, 55)">
                <AtomNode start="(392, 5)" end="(392, 6)" leading="" trailing="" val="("/>
                <NullNode start="(392, 6)" end="(392, 14)">
                  <IdentNode start="(392, 6)" end="(392, 14)" leading="" trailing=" " raw_val="lt_asymm" val="lt_asymm"/>
                </NullNode>
                <NullNode start="(392, 15)" end="(392, 54)">
                  <AtomNode start="(392, 15)" end="(392, 16)" leading="" trailing=" " val=":"/>
                  <OtherNode start="(392, 17)" end="(392, 54)" kind="Lean.Parser.Term.forall">
                    <AtomNode start="(392, 17)" end="(392, 18)" leading="" trailing=" " val="∀"/>
                    <NullNode start="(392, 19)" end="(392, 22)">
                      <IdentNode start="(392, 19)" end="(392, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      <IdentNode start="(392, 21)" end="(392, 22)" leading="" trailing="" raw_val="y" val="y"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(392, 22)" end="(392, 23)" leading="" trailing=" " val=","/>
                    <OtherNode start="(392, 24)" end="(392, 54)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(392, 24)" end="(392, 37)" kind="«term_=_»">
                        <OtherNode start="(392, 24)" end="(392, 30)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(392, 24)" end="(392, 26)" leading="" trailing=" " raw_val="lt" val="lt"/>
                          <NullNode start="(392, 27)" end="(392, 30)">
                            <IdentNode start="(392, 27)" end="(392, 28)" leading="" trailing=" " raw_val="x" val="x"/>
                            <IdentNode start="(392, 29)" end="(392, 30)" leading="" trailing=" " raw_val="y" val="y"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(392, 31)" end="(392, 32)" leading="" trailing=" " val="="/>
                        <IdentNode start="(392, 33)" end="(392, 37)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                      <AtomNode start="(392, 38)" end="(392, 39)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(392, 40)" end="(392, 54)" kind="«term_=_»">
                        <OtherNode start="(392, 40)" end="(392, 46)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(392, 40)" end="(392, 42)" leading="" trailing=" " raw_val="lt" val="lt"/>
                          <NullNode start="(392, 43)" end="(392, 46)">
                            <IdentNode start="(392, 43)" end="(392, 44)" leading="" trailing=" " raw_val="y" val="y"/>
                            <IdentNode start="(392, 45)" end="(392, 46)" leading="" trailing=" " raw_val="x" val="x"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(392, 47)" end="(392, 48)" leading="" trailing=" " val="="/>
                        <IdentNode start="(392, 49)" end="(392, 54)" leading="" trailing="" raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <NullNode/>
                <AtomNode start="(392, 54)" end="(392, 55)" leading="" trailing="&#10;    " val=")"/>
              </TermExplicitbinderNode>
              <TermExplicitbinderNode start="(393, 5)" end="(393, 68)">
                <AtomNode start="(393, 5)" end="(393, 6)" leading="" trailing="" val="("/>
                <NullNode start="(393, 6)" end="(393, 17)">
                  <IdentNode start="(393, 6)" end="(393, 17)" leading="" trailing=" " raw_val="lt_antisymm" val="lt_antisymm"/>
                </NullNode>
                <NullNode start="(393, 18)" end="(393, 67)">
                  <AtomNode start="(393, 18)" end="(393, 19)" leading="" trailing=" " val=":"/>
                  <OtherNode start="(393, 20)" end="(393, 67)" kind="Lean.Parser.Term.forall">
                    <AtomNode start="(393, 20)" end="(393, 21)" leading="" trailing=" " val="∀"/>
                    <NullNode start="(393, 22)" end="(393, 25)">
                      <IdentNode start="(393, 22)" end="(393, 23)" leading="" trailing=" " raw_val="x" val="x"/>
                      <IdentNode start="(393, 24)" end="(393, 25)" leading="" trailing="" raw_val="y" val="y"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(393, 25)" end="(393, 26)" leading="" trailing=" " val=","/>
                    <OtherNode start="(393, 27)" end="(393, 67)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(393, 27)" end="(393, 41)" kind="«term_=_»">
                        <OtherNode start="(393, 27)" end="(393, 33)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(393, 27)" end="(393, 29)" leading="" trailing=" " raw_val="lt" val="lt"/>
                          <NullNode start="(393, 30)" end="(393, 33)">
                            <IdentNode start="(393, 30)" end="(393, 31)" leading="" trailing=" " raw_val="x" val="x"/>
                            <IdentNode start="(393, 32)" end="(393, 33)" leading="" trailing=" " raw_val="y" val="y"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(393, 34)" end="(393, 35)" leading="" trailing=" " val="="/>
                        <IdentNode start="(393, 36)" end="(393, 41)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                      <AtomNode start="(393, 42)" end="(393, 43)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(393, 44)" end="(393, 67)" kind="Lean.Parser.Term.arrow">
                        <OtherNode start="(393, 44)" end="(393, 58)" kind="«term_=_»">
                          <OtherNode start="(393, 44)" end="(393, 50)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(393, 44)" end="(393, 46)" leading="" trailing=" " raw_val="lt" val="lt"/>
                            <NullNode start="(393, 47)" end="(393, 50)">
                              <IdentNode start="(393, 47)" end="(393, 48)" leading="" trailing=" " raw_val="y" val="y"/>
                              <IdentNode start="(393, 49)" end="(393, 50)" leading="" trailing=" " raw_val="x" val="x"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(393, 51)" end="(393, 52)" leading="" trailing=" " val="="/>
                          <IdentNode start="(393, 53)" end="(393, 58)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                        <AtomNode start="(393, 59)" end="(393, 60)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(393, 61)" end="(393, 67)" kind="«term_==_»">
                          <IdentNode start="(393, 61)" end="(393, 62)" leading="" trailing=" " raw_val="x" val="x"/>
                          <AtomNode start="(393, 63)" end="(393, 65)" leading="" trailing=" " val="=="/>
                          <IdentNode start="(393, 66)" end="(393, 67)" leading="" trailing="" raw_val="y" val="y"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <NullNode/>
                <AtomNode start="(393, 67)" end="(393, 68)" leading="" trailing=" " val=")"/>
              </TermExplicitbinderNode>
            </NullNode>
            <TermTypespecNode start="(393, 69)" end="(398, 88)">
              <AtomNode start="(393, 69)" end="(393, 70)" leading="" trailing="&#10;    " val=":"/>
              <OtherNode start="(394, 5)" end="(398, 88)" kind="«term_↔_»">
                <OtherNode start="(394, 5)" end="(394, 25)" kind="«term_=_»">
                  <OtherNode start="(394, 5)" end="(394, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(394, 5)" end="(394, 8)" leading="" trailing=" " raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(394, 9)" end="(394, 17)">
                      <IdentNode start="(394, 9)" end="(394, 11)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <IdentNode start="(394, 12)" end="(394, 14)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      <IdentNode start="(394, 15)" end="(394, 17)" leading="" trailing=" " raw_val="lt" val="lt"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(394, 18)" end="(394, 19)" leading="" trailing=" " val="="/>
                  <IdentNode start="(394, 20)" end="(394, 25)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <AtomNode start="(394, 26)" end="(394, 27)" leading="" trailing="&#10;      " val="↔"/>
                <OtherNode start="(395, 7)" end="(398, 88)" kind="«term_∨_»">
                  <OtherNode start="(395, 7)" end="(395, 46)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(395, 7)" end="(395, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(395, 8)" end="(395, 45)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(395, 8)" end="(395, 16)" leading="" trailing=" " raw_val="l₂.isEqv" val="l₂.isEqv"/>
                      <NullNode start="(395, 17)" end="(395, 45)">
                        <OtherNode start="(395, 17)" end="(395, 36)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(395, 17)" end="(395, 18)" leading="" trailing="" val="("/>
                          <OtherNode start="(395, 18)" end="(395, 35)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(395, 18)" end="(395, 25)" leading="" trailing=" " raw_val="l₁.take" val="l₁.take"/>
                            <NullNode start="(395, 26)" end="(395, 35)">
                              <IdentNode start="(395, 26)" end="(395, 35)" leading="" trailing="" raw_val="l₂.length" val="l₂.length"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(395, 35)" end="(395, 36)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <OtherNode start="(395, 37)" end="(395, 45)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(395, 37)" end="(395, 38)" leading="" trailing="" val="("/>
                          <OtherNode start="(395, 38)" end="(395, 44)" kind="«term_==_»">
                            <OtherNode start="(395, 38)" end="(395, 39)" kind="Lean.Parser.Term.cdot">
                              <AtomNode start="(395, 38)" end="(395, 39)" leading="" trailing=" " val="·"/>
                            </OtherNode>
                            <AtomNode start="(395, 40)" end="(395, 42)" leading="" trailing=" " val="=="/>
                            <OtherNode start="(395, 43)" end="(395, 44)" kind="Lean.Parser.Term.cdot">
                              <AtomNode start="(395, 43)" end="(395, 44)" leading="" trailing="" val="·"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(395, 44)" end="(395, 45)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(395, 45)" end="(395, 46)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <AtomNode start="(395, 47)" end="(395, 48)" leading="" trailing="&#10;        " val="∨"/>
                  <OtherNode start="(396, 9)" end="(398, 88)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(396, 9)" end="(396, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(396, 10)" end="(398, 87)" kind="«term∃_,_»">
                      <AtomNode start="(396, 10)" end="(396, 11)" leading="" trailing=" " val="∃"/>
                      <OtherNode start="(396, 12)" end="(396, 63)" kind="Lean.explicitBinders">
                        <NullNode start="(396, 12)" end="(396, 63)">
                          <OtherNode start="(396, 12)" end="(396, 21)" kind="Lean.bracketedExplicitBinders">
                            <AtomNode start="(396, 12)" end="(396, 13)" leading="" trailing="" val="("/>
                            <NullNode start="(396, 13)" end="(396, 14)">
                              <LeanBinderidentNode start="(396, 13)" end="(396, 14)">
                                <IdentNode start="(396, 13)" end="(396, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                              </LeanBinderidentNode>
                            </NullNode>
                            <AtomNode start="(396, 15)" end="(396, 16)" leading="" trailing=" " val=":"/>
                            <IdentNode start="(396, 17)" end="(396, 20)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <AtomNode start="(396, 20)" end="(396, 21)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <OtherNode start="(396, 22)" end="(396, 42)" kind="Lean.bracketedExplicitBinders">
                            <AtomNode start="(396, 22)" end="(396, 23)" leading="" trailing="" val="("/>
                            <NullNode start="(396, 23)" end="(396, 25)">
                              <LeanBinderidentNode start="(396, 23)" end="(396, 25)">
                                <IdentNode start="(396, 23)" end="(396, 25)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                              </LeanBinderidentNode>
                            </NullNode>
                            <AtomNode start="(396, 26)" end="(396, 27)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(396, 28)" end="(396, 41)" kind="«term_&amp;lt;_»">
                              <IdentNode start="(396, 28)" end="(396, 29)" leading="" trailing=" " raw_val="i" val="i"/>
                              <AtomNode start="(396, 30)" end="(396, 31)" leading="" trailing=" " val="&amp;lt;"/>
                              <IdentNode start="(396, 32)" end="(396, 41)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                            </OtherNode>
                            <AtomNode start="(396, 41)" end="(396, 42)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <OtherNode start="(396, 43)" end="(396, 63)" kind="Lean.bracketedExplicitBinders">
                            <AtomNode start="(396, 43)" end="(396, 44)" leading="" trailing="" val="("/>
                            <NullNode start="(396, 44)" end="(396, 46)">
                              <LeanBinderidentNode start="(396, 44)" end="(396, 46)">
                                <IdentNode start="(396, 44)" end="(396, 46)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                              </LeanBinderidentNode>
                            </NullNode>
                            <AtomNode start="(396, 47)" end="(396, 48)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(396, 49)" end="(396, 62)" kind="«term_&amp;lt;_»">
                              <IdentNode start="(396, 49)" end="(396, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                              <AtomNode start="(396, 51)" end="(396, 52)" leading="" trailing=" " val="&amp;lt;"/>
                              <IdentNode start="(396, 53)" end="(396, 62)" leading="" trailing="" raw_val="l₂.length" val="l₂.length"/>
                            </OtherNode>
                            <AtomNode start="(396, 62)" end="(396, 63)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(396, 63)" end="(396, 64)" leading="" trailing="&#10;          " val=","/>
                      <OtherNode start="(397, 11)" end="(398, 87)" kind="«term_∧_»">
                        <OtherNode start="(397, 11)" end="(398, 70)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(397, 11)" end="(397, 12)" leading="" trailing="" val="("/>
                          <OtherNode start="(397, 12)" end="(398, 69)" kind="Lean.Parser.Term.forall">
                            <AtomNode start="(397, 12)" end="(397, 13)" leading="" trailing=" " val="∀"/>
                            <NullNode start="(397, 14)" end="(397, 15)">
                              <IdentNode start="(397, 14)" end="(397, 15)" leading="" trailing="" raw_val="j" val="j"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(397, 15)" end="(397, 16)" leading="" trailing=" " val=","/>
                            <OtherNode start="(397, 17)" end="(398, 69)" kind="Lean.Parser.Term.depArrow">
                              <TermExplicitbinderNode start="(397, 17)" end="(397, 29)">
                                <AtomNode start="(397, 17)" end="(397, 18)" leading="" trailing="" val="("/>
                                <NullNode start="(397, 18)" end="(397, 20)">
                                  <IdentNode start="(397, 18)" end="(397, 20)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                </NullNode>
                                <NullNode start="(397, 21)" end="(397, 28)">
                                  <AtomNode start="(397, 21)" end="(397, 22)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(397, 23)" end="(397, 28)" kind="«term_&amp;lt;_»">
                                    <IdentNode start="(397, 23)" end="(397, 24)" leading="" trailing=" " raw_val="j" val="j"/>
                                    <AtomNode start="(397, 25)" end="(397, 26)" leading="" trailing=" " val="&amp;lt;"/>
                                    <IdentNode start="(397, 27)" end="(397, 28)" leading="" trailing="" raw_val="i" val="i"/>
                                  </OtherNode>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(397, 28)" end="(397, 29)" leading="" trailing=" " val=")"/>
                              </TermExplicitbinderNode>
                              <AtomNode start="(397, 30)" end="(397, 31)" leading="" trailing="&#10;            " val="→"/>
                              <OtherNode start="(398, 13)" end="(398, 69)" kind="«term_==_»">
                                <OtherNode start="(398, 13)" end="(398, 39)" kind="«term__[_]'_»">
                                  <IdentNode start="(398, 13)" end="(398, 15)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                  <AtomNode start="(398, 15)" end="(398, 16)" leading="" trailing="" val="["/>
                                  <IdentNode start="(398, 16)" end="(398, 17)" leading="" trailing="" raw_val="j" val="j"/>
                                  <AtomNode start="(398, 17)" end="(398, 19)" leading="" trailing="" val="]'"/>
                                  <OtherNode start="(398, 19)" end="(398, 39)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(398, 19)" end="(398, 20)" leading="" trailing="" val="("/>
                                    <OtherNode start="(398, 20)" end="(398, 38)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(398, 20)" end="(398, 32)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(398, 33)" end="(398, 38)">
                                        <IdentNode start="(398, 33)" end="(398, 35)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                        <IdentNode start="(398, 36)" end="(398, 38)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(398, 38)" end="(398, 39)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(398, 40)" end="(398, 42)" leading="" trailing=" " val="=="/>
                                <OtherNode start="(398, 43)" end="(398, 69)" kind="«term__[_]'_»">
                                  <IdentNode start="(398, 43)" end="(398, 45)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                  <AtomNode start="(398, 45)" end="(398, 46)" leading="" trailing="" val="["/>
                                  <IdentNode start="(398, 46)" end="(398, 47)" leading="" trailing="" raw_val="j" val="j"/>
                                  <AtomNode start="(398, 47)" end="(398, 49)" leading="" trailing="" val="]'"/>
                                  <OtherNode start="(398, 49)" end="(398, 69)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(398, 49)" end="(398, 50)" leading="" trailing="" val="("/>
                                    <OtherNode start="(398, 50)" end="(398, 68)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(398, 50)" end="(398, 62)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(398, 63)" end="(398, 68)">
                                        <IdentNode start="(398, 63)" end="(398, 65)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                        <IdentNode start="(398, 66)" end="(398, 68)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(398, 68)" end="(398, 69)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(398, 69)" end="(398, 70)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(398, 71)" end="(398, 72)" leading="" trailing=" " val="∧"/>
                        <OtherNode start="(398, 73)" end="(398, 87)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(398, 73)" end="(398, 75)" leading="" trailing=" " raw_val="lt" val="lt"/>
                          <NullNode start="(398, 76)" end="(398, 87)">
                            <OtherNode start="(398, 76)" end="(398, 81)" kind="«term__[_]»">
                              <IdentNode start="(398, 76)" end="(398, 78)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                              <AtomNode start="(398, 78)" end="(398, 79)" leading="" trailing="" val="["/>
                              <IdentNode start="(398, 79)" end="(398, 80)" leading="" trailing="" raw_val="i" val="i"/>
                              <AtomNode start="(398, 80)" end="(398, 81)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <OtherNode start="(398, 82)" end="(398, 87)" kind="«term__[_]»">
                              <IdentNode start="(398, 82)" end="(398, 84)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                              <AtomNode start="(398, 84)" end="(398, 85)" leading="" trailing="" val="["/>
                              <IdentNode start="(398, 85)" end="(398, 86)" leading="" trailing="" raw_val="i" val="i"/>
                              <AtomNode start="(398, 86)" end="(398, 87)" leading="" trailing="" val="]"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(398, 87)" end="(398, 88)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </TermTypespecNode>
          </CommandDeclsigNode>
          <CommandDeclvalsimpleNode start="(398, 89)" end="(444, 29)">
            <AtomNode start="(398, 89)" end="(398, 91)" leading="" trailing=" " val=":="/>
            <TermBytacticNode start="(398, 92)" end="(444, 29)">
              <AtomNode start="(398, 92)" end="(398, 94)" leading="" trailing="&#10;  " val="by"/>
              <TacticTacticseqNode start="(399, 3)" end="(444, 29)">
                <TacticTacticseq1IndentedNode start="(399, 3)" end="(444, 29)">
                  <NullNode start="(399, 3)" end="(444, 29)">
                    <OtherNode start="(399, 3)" end="(444, 29)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;l₁ l₂ : List α&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;⊢ l₁.lex l₂ lt = false ↔&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true" state_after="no goals" tactic="induction l₁ generalizing l₂ with&#10;| nil =&amp;gt;&#10;  cases l₂ with&#10;  | nil =&amp;gt; simp [lex]&#10;  | cons b bs =&amp;gt; simp [lex]&#10;| cons a l₁ ih =&amp;gt;&#10;  cases l₂ with&#10;  | nil =&amp;gt; simp [lex]&#10;  | cons b l₂ =&amp;gt;&#10;    simp [cons_lex_cons, Bool.or_eq_false_iff, Bool.and_eq_false_imp, ih, isEqv,&#10;      Bool.and_eq_true, length_cons]&#10;    constructor&#10;    · rintro ⟨hab, h⟩&#10;      if eq : b == a then&#10;        specialize h (BEq.symm eq)&#10;        obtain (h | ⟨i, h₁, h₂, w₁, w₂⟩) := h&#10;        · exact .inl ⟨eq, h⟩&#10;        · refine .inr ⟨i + 1, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;          · intro j hj&#10;            cases j with&#10;            | zero =&amp;gt; simpa using BEq.symm eq&#10;            | succ j =&amp;gt;&#10;              simp only [getElem_cons_succ]&#10;              rw [w₁]&#10;              simpa using hj&#10;          · simpa using w₂&#10;      else&#10;        right&#10;        have hba : lt b a :=&#10;          Decidable.byContradiction fun hba =&amp;gt; eq (lt_antisymm _ _ (by simpa using hba) hab)&#10;        exact ⟨0, by simp, by simp, by simpa⟩&#10;    · rintro (⟨eq, h⟩ | ⟨i, h₁, h₂, w₁, w₂⟩)&#10;      · exact ⟨lt_irrefl _ _ (BEq.symm eq), fun _ =&amp;gt; .inl h⟩&#10;      · cases i with&#10;        | zero =&amp;gt;&#10;          simp at w₂&#10;          refine ⟨lt_asymm _ _ w₂, ?_⟩&#10;          intro eq&#10;          exfalso&#10;          simp [lt_irrefl _ _ (BEq.symm eq)] at w₂&#10;        | succ i =&amp;gt;&#10;          refine ⟨lt_irrefl _ _ (by simpa using w₁ 0 (by simp)), ?_⟩&#10;          refine fun _ =&amp;gt; .inr ⟨i, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;          · intro j hj&#10;            simpa using w₁ (j + 1) (by simpa)&#10;          · simpa using w₂">
                      <AtomNode start="(399, 3)" end="(399, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(399, 13)" end="(399, 15)">
                        <OtherNode start="(399, 13)" end="(399, 15)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(399, 13)" end="(399, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode start="(399, 16)" end="(399, 31)">
                        <AtomNode start="(399, 16)" end="(399, 28)" leading="" trailing=" " val="generalizing"/>
                        <NullNode start="(399, 29)" end="(399, 31)">
                          <IdentNode start="(399, 29)" end="(399, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                        </NullNode>
                      </NullNode>
                      <NullNode start="(399, 32)" end="(444, 29)">
                        <OtherNode start="(399, 32)" end="(444, 29)" kind="Lean.Parser.Tactic.inductionAlts">
                          <AtomNode start="(399, 32)" end="(399, 36)" leading="" trailing="&#10;  " val="with"/>
                          <NullNode/>
                          <NullNode start="(400, 3)" end="(444, 29)">
                            <OtherNode start="(400, 3)" end="(403, 30)" kind="Lean.Parser.Tactic.inductionAlt">
                              <NullNode start="(400, 3)" end="(400, 8)">
                                <OtherNode start="(400, 3)" end="(400, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                  <AtomNode start="(400, 3)" end="(400, 4)" leading="" trailing=" " val="|"/>
                                  <GroupNode start="(400, 5)" end="(400, 8)">
                                    <NullNode/>
                                    <IdentNode start="(400, 5)" end="(400, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </GroupNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <NullNode start="(400, 9)" end="(403, 30)">
                                <AtomNode start="(400, 9)" end="(400, 11)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                                <TacticTacticseqNode start="(401, 5)" end="(403, 30)">
                                  <TacticTacticseq1IndentedNode start="(401, 5)" end="(403, 30)">
                                    <NullNode start="(401, 5)" end="(403, 30)">
                                      <OtherNode start="(401, 5)" end="(403, 30)" kind="Lean.Parser.Tactic.cases" state_before="case nil&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;l₂ : List α&#10;⊢ [].lex l₂ lt = false ↔&#10;    (l₂.isEqv (take l₂.length []) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ([][j] == l₂[j]) = true) ∧ lt l₂[i] [][i] = true" state_after="no goals" tactic="cases l₂ with&#10;| nil =&amp;gt; simp [lex]&#10;| cons b bs =&amp;gt; simp [lex]">
                                        <AtomNode start="(401, 5)" end="(401, 10)" leading="" trailing=" " val="cases"/>
                                        <NullNode start="(401, 11)" end="(401, 13)">
                                          <OtherNode start="(401, 11)" end="(401, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                            <NullNode/>
                                            <IdentNode start="(401, 11)" end="(401, 13)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode/>
                                        <NullNode start="(401, 14)" end="(403, 30)">
                                          <OtherNode start="(401, 14)" end="(403, 30)" kind="Lean.Parser.Tactic.inductionAlts">
                                            <AtomNode start="(401, 14)" end="(401, 18)" leading="" trailing="&#10;    " val="with"/>
                                            <NullNode/>
                                            <NullNode start="(402, 5)" end="(403, 30)">
                                              <OtherNode start="(402, 5)" end="(402, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                                                <NullNode start="(402, 5)" end="(402, 10)">
                                                  <OtherNode start="(402, 5)" end="(402, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                    <AtomNode start="(402, 5)" end="(402, 6)" leading="" trailing=" " val="|"/>
                                                    <GroupNode start="(402, 7)" end="(402, 10)">
                                                      <NullNode/>
                                                      <IdentNode start="(402, 7)" end="(402, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                    </GroupNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </NullNode>
                                                <NullNode start="(402, 11)" end="(402, 24)">
                                                  <AtomNode start="(402, 11)" end="(402, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                  <TacticTacticseqNode start="(402, 14)" end="(402, 24)">
                                                    <TacticTacticseq1IndentedNode start="(402, 14)" end="(402, 24)">
                                                      <NullNode start="(402, 14)" end="(402, 24)">
                                                        <OtherNode start="(402, 14)" end="(402, 24)" kind="Lean.Parser.Tactic.simp" state_before="case nil.nil&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;⊢ [].lex [] lt = false ↔&#10;    ([].isEqv (take [].length []) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ([][j] == [][j]) = true) ∧ lt [][i] [][i] = true" state_after="no goals" tactic="simp [lex]">
                                                          <AtomNode start="(402, 14)" end="(402, 18)" leading="" trailing=" " val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(402, 19)" end="(402, 24)">
                                                            <AtomNode start="(402, 19)" end="(402, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(402, 20)" end="(402, 23)">
                                                            <OtherNode start="(402, 20)" end="(402, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(402, 20)" end="(402, 23)" leading="" trailing="" raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(402, 23)" end="(402, 24)" leading="" trailing="&#10;    " val="]"/>
                                                          </NullNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </NullNode>
                                              </OtherNode>
                                              <OtherNode start="(403, 5)" end="(403, 30)" kind="Lean.Parser.Tactic.inductionAlt">
                                                <NullNode start="(403, 5)" end="(403, 16)">
                                                  <OtherNode start="(403, 5)" end="(403, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                    <AtomNode start="(403, 5)" end="(403, 6)" leading="" trailing=" " val="|"/>
                                                    <GroupNode start="(403, 7)" end="(403, 11)">
                                                      <NullNode/>
                                                      <IdentNode start="(403, 7)" end="(403, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                    </GroupNode>
                                                    <NullNode start="(403, 12)" end="(403, 16)">
                                                      <IdentNode start="(403, 12)" end="(403, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                                      <IdentNode start="(403, 14)" end="(403, 16)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <NullNode start="(403, 17)" end="(403, 30)">
                                                  <AtomNode start="(403, 17)" end="(403, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                                                  <TacticTacticseqNode start="(403, 20)" end="(403, 30)">
                                                    <TacticTacticseq1IndentedNode start="(403, 20)" end="(403, 30)">
                                                      <NullNode start="(403, 20)" end="(403, 30)">
                                                        <OtherNode start="(403, 20)" end="(403, 30)" kind="Lean.Parser.Tactic.simp" state_before="case nil.cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;b : α&#10;bs : List α&#10;⊢ [].lex (b :: bs) lt = false ↔&#10;    ((b :: bs).isEqv (take (b :: bs).length []) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ([][j] == (b :: bs)[j]) = true) ∧ lt (b :: bs)[i] [][i] = true" state_after="no goals" tactic="simp [lex]">
                                                          <AtomNode start="(403, 20)" end="(403, 24)" leading="" trailing=" " val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(403, 25)" end="(403, 30)">
                                                            <AtomNode start="(403, 25)" end="(403, 26)" leading="" trailing="" val="["/>
                                                            <NullNode start="(403, 26)" end="(403, 29)">
                                                            <OtherNode start="(403, 26)" end="(403, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(403, 26)" end="(403, 29)" leading="" trailing="" raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(403, 29)" end="(403, 30)" leading="" trailing="&#10;  " val="]"/>
                                                          </NullNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </NullNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </NullNode>
                            </OtherNode>
                            <OtherNode start="(404, 3)" end="(444, 29)" kind="Lean.Parser.Tactic.inductionAlt">
                              <NullNode start="(404, 3)" end="(404, 17)">
                                <OtherNode start="(404, 3)" end="(404, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                  <AtomNode start="(404, 3)" end="(404, 4)" leading="" trailing=" " val="|"/>
                                  <GroupNode start="(404, 5)" end="(404, 9)">
                                    <NullNode/>
                                    <IdentNode start="(404, 5)" end="(404, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </GroupNode>
                                  <NullNode start="(404, 10)" end="(404, 17)">
                                    <IdentNode start="(404, 10)" end="(404, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                    <IdentNode start="(404, 12)" end="(404, 14)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                    <IdentNode start="(404, 15)" end="(404, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                              <NullNode start="(404, 18)" end="(444, 29)">
                                <AtomNode start="(404, 18)" end="(404, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                                <TacticTacticseqNode start="(405, 5)" end="(444, 29)">
                                  <TacticTacticseq1IndentedNode start="(405, 5)" end="(444, 29)">
                                    <NullNode start="(405, 5)" end="(444, 29)">
                                      <OtherNode start="(405, 5)" end="(444, 29)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;l₂ : List α&#10;⊢ (a :: l₁).lex l₂ lt = false ↔&#10;    (l₂.isEqv (take l₂.length (a :: l₁)) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == l₂[j]) = true) ∧ lt l₂[i] (a :: l₁)[i] = true" state_after="no goals" tactic="cases l₂ with&#10;| nil =&amp;gt; simp [lex]&#10;| cons b l₂ =&amp;gt;&#10;  simp [cons_lex_cons, Bool.or_eq_false_iff, Bool.and_eq_false_imp, ih, isEqv,&#10;    Bool.and_eq_true, length_cons]&#10;  constructor&#10;  · rintro ⟨hab, h⟩&#10;    if eq : b == a then&#10;      specialize h (BEq.symm eq)&#10;      obtain (h | ⟨i, h₁, h₂, w₁, w₂⟩) := h&#10;      · exact .inl ⟨eq, h⟩&#10;      · refine .inr ⟨i + 1, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;        · intro j hj&#10;          cases j with&#10;          | zero =&amp;gt; simpa using BEq.symm eq&#10;          | succ j =&amp;gt;&#10;            simp only [getElem_cons_succ]&#10;            rw [w₁]&#10;            simpa using hj&#10;        · simpa using w₂&#10;    else&#10;      right&#10;      have hba : lt b a :=&#10;        Decidable.byContradiction fun hba =&amp;gt; eq (lt_antisymm _ _ (by simpa using hba) hab)&#10;      exact ⟨0, by simp, by simp, by simpa⟩&#10;  · rintro (⟨eq, h⟩ | ⟨i, h₁, h₂, w₁, w₂⟩)&#10;    · exact ⟨lt_irrefl _ _ (BEq.symm eq), fun _ =&amp;gt; .inl h⟩&#10;    · cases i with&#10;      | zero =&amp;gt;&#10;        simp at w₂&#10;        refine ⟨lt_asymm _ _ w₂, ?_⟩&#10;        intro eq&#10;        exfalso&#10;        simp [lt_irrefl _ _ (BEq.symm eq)] at w₂&#10;      | succ i =&amp;gt;&#10;        refine ⟨lt_irrefl _ _ (by simpa using w₁ 0 (by simp)), ?_⟩&#10;        refine fun _ =&amp;gt; .inr ⟨i, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;        · intro j hj&#10;          simpa using w₁ (j + 1) (by simpa)&#10;        · simpa using w₂">
                                        <AtomNode start="(405, 5)" end="(405, 10)" leading="" trailing=" " val="cases"/>
                                        <NullNode start="(405, 11)" end="(405, 13)">
                                          <OtherNode start="(405, 11)" end="(405, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                            <NullNode/>
                                            <IdentNode start="(405, 11)" end="(405, 13)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode/>
                                        <NullNode start="(405, 14)" end="(444, 29)">
                                          <OtherNode start="(405, 14)" end="(444, 29)" kind="Lean.Parser.Tactic.inductionAlts">
                                            <AtomNode start="(405, 14)" end="(405, 18)" leading="" trailing="&#10;    " val="with"/>
                                            <NullNode/>
                                            <NullNode start="(406, 5)" end="(444, 29)">
                                              <OtherNode start="(406, 5)" end="(406, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                                                <NullNode start="(406, 5)" end="(406, 10)">
                                                  <OtherNode start="(406, 5)" end="(406, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                    <AtomNode start="(406, 5)" end="(406, 6)" leading="" trailing=" " val="|"/>
                                                    <GroupNode start="(406, 7)" end="(406, 10)">
                                                      <NullNode/>
                                                      <IdentNode start="(406, 7)" end="(406, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                    </GroupNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </NullNode>
                                                <NullNode start="(406, 11)" end="(406, 24)">
                                                  <AtomNode start="(406, 11)" end="(406, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                  <TacticTacticseqNode start="(406, 14)" end="(406, 24)">
                                                    <TacticTacticseq1IndentedNode start="(406, 14)" end="(406, 24)">
                                                      <NullNode start="(406, 14)" end="(406, 24)">
                                                        <OtherNode start="(406, 14)" end="(406, 24)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;⊢ (a :: l₁).lex [] lt = false ↔&#10;    ([].isEqv (take [].length (a :: l₁)) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == [][j]) = true) ∧ lt [][i] (a :: l₁)[i] = true" state_after="no goals" tactic="simp [lex]">
                                                          <AtomNode start="(406, 14)" end="(406, 18)" leading="" trailing=" " val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(406, 19)" end="(406, 24)">
                                                            <AtomNode start="(406, 19)" end="(406, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(406, 20)" end="(406, 23)">
                                                            <OtherNode start="(406, 20)" end="(406, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(406, 20)" end="(406, 23)" leading="" trailing="" raw_val="lex" val="lex" full_name="List.lex" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(406, 23)" end="(406, 24)" leading="" trailing="&#10;    " val="]"/>
                                                          </NullNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </NullNode>
                                              </OtherNode>
                                              <OtherNode start="(407, 5)" end="(444, 29)" kind="Lean.Parser.Tactic.inductionAlt">
                                                <NullNode start="(407, 5)" end="(407, 16)">
                                                  <OtherNode start="(407, 5)" end="(407, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                    <AtomNode start="(407, 5)" end="(407, 6)" leading="" trailing=" " val="|"/>
                                                    <GroupNode start="(407, 7)" end="(407, 11)">
                                                      <NullNode/>
                                                      <IdentNode start="(407, 7)" end="(407, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                    </GroupNode>
                                                    <NullNode start="(407, 12)" end="(407, 16)">
                                                      <IdentNode start="(407, 12)" end="(407, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                                      <IdentNode start="(407, 14)" end="(407, 16)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <NullNode start="(407, 17)" end="(444, 29)">
                                                  <AtomNode start="(407, 17)" end="(407, 19)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                  <TacticTacticseqNode start="(408, 7)" end="(444, 29)">
                                                    <TacticTacticseq1IndentedNode start="(408, 7)" end="(444, 29)">
                                                      <NullNode start="(408, 7)" end="(444, 29)">
                                                        <OtherNode start="(408, 7)" end="(409, 39)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ (a :: l₁).lex (b :: l₂) lt = false ↔&#10;    ((b :: l₂).isEqv (take (b :: l₂).length (a :: l₁)) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" state_after="case cons.cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ lt a b = false ∧&#10;      ((a == b) = true →&#10;        (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true) ↔&#10;    (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" tactic="simp [cons_lex_cons, Bool.or_eq_false_iff, Bool.and_eq_false_imp, ih, isEqv,&#10;  Bool.and_eq_true, length_cons]">
                                                          <AtomNode start="(408, 7)" end="(408, 11)" leading="" trailing=" " val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(408, 12)" end="(409, 39)">
                                                            <AtomNode start="(408, 12)" end="(408, 13)" leading="" trailing="" val="["/>
                                                            <NullNode start="(408, 13)" end="(409, 38)">
                                                            <OtherNode start="(408, 13)" end="(408, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(408, 13)" end="(408, 26)" leading="" trailing="" raw_val="cons_lex_cons" val="cons_lex_cons" full_name="List.cons_lex_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(408, 26)" end="(408, 27)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(408, 28)" end="(408, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(408, 28)" end="(408, 48)" leading="" trailing="" raw_val="Bool.or_eq_false_iff" val="Bool.or_eq_false_iff" full_name="Bool.or_eq_false_iff" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(408, 48)" end="(408, 49)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(408, 50)" end="(408, 71)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(408, 50)" end="(408, 71)" leading="" trailing="" raw_val="Bool.and_eq_false_imp" val="Bool.and_eq_false_imp" full_name="Bool.and_eq_false_imp" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(408, 71)" end="(408, 72)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(408, 73)" end="(408, 75)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(408, 73)" end="(408, 75)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <AtomNode start="(408, 75)" end="(408, 76)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(408, 77)" end="(408, 82)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(408, 77)" end="(408, 82)" leading="" trailing="" raw_val="isEqv" val="isEqv" full_name="List.isEqv" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(408, 82)" end="(408, 83)" leading="" trailing="&#10;        " val=","/>
                                                            <OtherNode start="(409, 9)" end="(409, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(409, 9)" end="(409, 25)" leading="" trailing="" raw_val="Bool.and_eq_true" val="Bool.and_eq_true" full_name="Bool.and_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(409, 25)" end="(409, 26)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(409, 27)" end="(409, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(409, 27)" end="(409, 38)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(409, 38)" end="(409, 39)" leading="" trailing="&#10;      " val="]"/>
                                                          </NullNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <OtherNode start="(410, 7)" end="(410, 18)" kind="Lean.Parser.Tactic.constructor" state_before="case cons.cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ lt a b = false ∧&#10;      ((a == b) = true →&#10;        (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true) ↔&#10;    (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" state_after="case cons.cons.mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ lt a b = false ∧&#10;      ((a == b) = true →&#10;        (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true) →&#10;    (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true&#10;&#10;case cons.cons.mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ ((b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h h₂,&#10;        (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true) →&#10;    lt a b = false ∧&#10;      ((a == b) = true →&#10;        (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" tactic="constructor">
                                                          <AtomNode start="(410, 7)" end="(410, 18)" leading="" trailing="&#10;      " val="constructor"/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <OtherNode start="(411, 7)" end="(429, 48)" kind="Lean.cdot" state_before="case cons.cons.mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ lt a b = false ∧&#10;      ((a == b) = true →&#10;        (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true) →&#10;    (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true&#10;&#10;case cons.cons.mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ ((b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h h₂,&#10;        (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true) →&#10;    lt a b = false ∧&#10;      ((a == b) = true →&#10;        (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" state_after="case cons.cons.mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ ((b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h h₂,&#10;        (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true) →&#10;    lt a b = false ∧&#10;      ((a == b) = true →&#10;        (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" tactic="· rintro ⟨hab, h⟩&#10;  if eq : b == a then&#10;    specialize h (BEq.symm eq)&#10;    obtain (h | ⟨i, h₁, h₂, w₁, w₂⟩) := h&#10;    · exact .inl ⟨eq, h⟩&#10;    · refine .inr ⟨i + 1, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;      · intro j hj&#10;        cases j with&#10;        | zero =&amp;gt; simpa using BEq.symm eq&#10;        | succ j =&amp;gt;&#10;          simp only [getElem_cons_succ]&#10;          rw [w₁]&#10;          simpa using hj&#10;      · simpa using w₂&#10;  else&#10;    right&#10;    have hba : lt b a :=&#10;      Decidable.byContradiction fun hba =&amp;gt; eq (lt_antisymm _ _ (by simpa using hba) hab)&#10;    exact ⟨0, by simp, by simp, by simpa⟩">
                                                          <OtherNode start="(411, 7)" end="(411, 8)" kind="Lean.cdotTk">
                                                            <OtherNode start="(411, 7)" end="(411, 8)" kind="patternIgnore">
                                                            <OtherNode start="(411, 7)" end="(411, 8)" kind="token.«· »">
                                                            <AtomNode start="(411, 7)" end="(411, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                          <TacticTacticseqNode start="(411, 9)" end="(429, 48)">
                                                            <TacticTacticseq1IndentedNode start="(411, 9)" end="(429, 48)">
                                                            <NullNode start="(411, 9)" end="(429, 48)">
                                                            <OtherNode start="(411, 9)" end="(411, 24)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.cons.mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ lt a b = false ∧&#10;      ((a == b) = true →&#10;        (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true) →&#10;    (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" state_after="case cons.cons.mp.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;h :&#10;  (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;⊢ (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" tactic="rintro ⟨hab, h⟩">
                                                            <AtomNode start="(411, 9)" end="(411, 15)" leading="" trailing=" " val="rintro"/>
                                                            <NullNode start="(411, 16)" end="(411, 24)">
                                                            <OtherNode start="(411, 16)" end="(411, 24)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                            <OtherNode start="(411, 16)" end="(411, 24)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(411, 16)" end="(411, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(411, 17)" end="(411, 23)">
                                                            <OtherNode start="(411, 17)" end="(411, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(411, 17)" end="(411, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(411, 17)" end="(411, 20)">
                                                            <OtherNode start="(411, 17)" end="(411, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(411, 17)" end="(411, 20)" leading="" trailing="" raw_val="hab" val="hab"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(411, 20)" end="(411, 21)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(411, 22)" end="(411, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(411, 22)" end="(411, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(411, 22)" end="(411, 23)">
                                                            <OtherNode start="(411, 22)" end="(411, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(411, 22)" end="(411, 23)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(411, 23)" end="(411, 24)" leading="" trailing="&#10;        " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(412, 9)" end="(429, 48)" kind="Lean.Parser.Tactic.tacDepIfThenElse" state_before="case cons.cons.mp.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;h :&#10;  (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;⊢ (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" state_after="no goals" tactic="if eq : b == a then&#10;  specialize h (BEq.symm eq)&#10;  obtain (h | ⟨i, h₁, h₂, w₁, w₂⟩) := h&#10;  · exact .inl ⟨eq, h⟩&#10;  · refine .inr ⟨i + 1, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;    · intro j hj&#10;      cases j with&#10;      | zero =&amp;gt; simpa using BEq.symm eq&#10;      | succ j =&amp;gt;&#10;        simp only [getElem_cons_succ]&#10;        rw [w₁]&#10;        simpa using hj&#10;    · simpa using w₂&#10;else&#10;  right&#10;  have hba : lt b a :=&#10;    Decidable.byContradiction fun hba =&amp;gt; eq (lt_antisymm _ _ (by simpa using hba) hab)&#10;  exact ⟨0, by simp, by simp, by simpa⟩">
                                                            <AtomNode start="(412, 9)" end="(412, 11)" leading="" trailing=" " val="if"/>
                                                            <LeanBinderidentNode start="(412, 12)" end="(412, 14)">
                                                            <IdentNode start="(412, 12)" end="(412, 14)" leading="" trailing=" " raw_val="eq" val="eq"/>
                                                            </LeanBinderidentNode>
                                                            <AtomNode start="(412, 15)" end="(412, 16)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(412, 17)" end="(412, 23)" kind="«term_==_»">
                                                            <IdentNode start="(412, 17)" end="(412, 18)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            <AtomNode start="(412, 19)" end="(412, 21)" leading="" trailing=" " val="=="/>
                                                            <IdentNode start="(412, 22)" end="(412, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            </OtherNode>
                                                            <AtomNode start="(412, 24)" end="(412, 28)" leading="" trailing="&#10;          " val="then"/>
                                                            <TacticTacticseqNode start="(413, 11)" end="(424, 29)">
                                                            <TacticTacticseq1IndentedNode start="(413, 11)" end="(424, 29)">
                                                            <NullNode start="(413, 11)" end="(424, 29)">
                                                            <OtherNode start="(413, 11)" end="(413, 37)" kind="Lean.Parser.Tactic.specialize" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;h :&#10;  (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;eq : (b == a) = true&#10;⊢ (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;h :&#10;  (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;⊢ (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" tactic="specialize h (BEq.symm eq)">
                                                            <AtomNode start="(413, 11)" end="(413, 21)" leading="" trailing=" " val="specialize"/>
                                                            <OtherNode start="(413, 22)" end="(413, 37)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(413, 22)" end="(413, 23)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <NullNode start="(413, 24)" end="(413, 37)">
                                                            <OtherNode start="(413, 24)" end="(413, 37)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(413, 24)" end="(413, 25)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(413, 25)" end="(413, 36)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(413, 25)" end="(413, 33)" leading="" trailing=" " raw_val="BEq.symm" val="BEq.symm" full_name="BEq.symm" mod_name="Init.Data.BEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BEq.lean"/>
                                                            <NullNode start="(413, 34)" end="(413, 36)">
                                                            <IdentNode start="(413, 34)" end="(413, 36)" leading="" trailing="" raw_val="eq" val="eq"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(413, 36)" end="(413, 37)" leading="" trailing="&#10;          " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(414, 11)" end="(414, 48)" kind="Lean.Parser.Tactic.obtain" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;h :&#10;  (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;⊢ (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" state_after="case inl&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;h : (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;⊢ (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true&#10;&#10;case inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" tactic="obtain (h | ⟨i, h₁, h₂, w₁, w₂⟩) := h">
                                                            <AtomNode start="(414, 11)" end="(414, 17)" leading="" trailing=" " val="obtain"/>
                                                            <NullNode start="(414, 18)" end="(414, 43)">
                                                            <OtherNode start="(414, 18)" end="(414, 43)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(414, 18)" end="(414, 43)">
                                                            <OtherNode start="(414, 18)" end="(414, 43)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                            <AtomNode start="(414, 18)" end="(414, 19)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(414, 19)" end="(414, 42)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(414, 19)" end="(414, 42)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(414, 19)" end="(414, 42)">
                                                            <OtherNode start="(414, 19)" end="(414, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(414, 19)" end="(414, 20)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            <AtomNode start="(414, 21)" end="(414, 22)" leading="" trailing=" " val="|"/>
                                                            <OtherNode start="(414, 23)" end="(414, 42)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(414, 23)" end="(414, 24)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(414, 24)" end="(414, 41)">
                                                            <OtherNode start="(414, 24)" end="(414, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(414, 24)" end="(414, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(414, 24)" end="(414, 25)">
                                                            <OtherNode start="(414, 24)" end="(414, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(414, 24)" end="(414, 25)" leading="" trailing="" raw_val="i" val="i"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(414, 25)" end="(414, 26)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(414, 27)" end="(414, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(414, 27)" end="(414, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(414, 27)" end="(414, 29)">
                                                            <OtherNode start="(414, 27)" end="(414, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(414, 27)" end="(414, 29)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(414, 29)" end="(414, 30)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(414, 31)" end="(414, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(414, 31)" end="(414, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(414, 31)" end="(414, 33)">
                                                            <OtherNode start="(414, 31)" end="(414, 33)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(414, 31)" end="(414, 33)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(414, 33)" end="(414, 34)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(414, 35)" end="(414, 37)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(414, 35)" end="(414, 37)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(414, 35)" end="(414, 37)">
                                                            <OtherNode start="(414, 35)" end="(414, 37)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(414, 35)" end="(414, 37)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(414, 37)" end="(414, 38)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(414, 39)" end="(414, 41)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(414, 39)" end="(414, 41)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(414, 39)" end="(414, 41)">
                                                            <OtherNode start="(414, 39)" end="(414, 41)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(414, 39)" end="(414, 41)" leading="" trailing="" raw_val="w₂" val="w₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(414, 41)" end="(414, 42)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(414, 42)" end="(414, 43)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode start="(414, 44)" end="(414, 48)">
                                                            <AtomNode start="(414, 44)" end="(414, 46)" leading="" trailing=" " val=":="/>
                                                            <NullNode start="(414, 47)" end="(414, 48)">
                                                            <IdentNode start="(414, 47)" end="(414, 48)" leading="" trailing="&#10;          " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(415, 11)" end="(415, 31)" kind="Lean.cdot" state_before="case inl&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;h : (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;⊢ (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true&#10;&#10;case inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" state_after="case inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" tactic="· exact .inl ⟨eq, h⟩">
                                                            <OtherNode start="(415, 11)" end="(415, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(415, 11)" end="(415, 12)" kind="patternIgnore">
                                                            <OtherNode start="(415, 11)" end="(415, 12)" kind="token.«· »">
                                                            <AtomNode start="(415, 11)" end="(415, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(415, 13)" end="(415, 31)">
                                                            <TacticTacticseq1IndentedNode start="(415, 13)" end="(415, 31)">
                                                            <NullNode start="(415, 13)" end="(415, 31)">
                                                            <OtherNode start="(415, 13)" end="(415, 31)" kind="Lean.Parser.Tactic.exact" state_before="case inl&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;h : (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;⊢ (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" state_after="no goals" tactic="exact .inl ⟨eq, h⟩">
                                                            <AtomNode start="(415, 13)" end="(415, 18)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(415, 19)" end="(415, 31)" kind="Lean.Parser.Term.app">
                                                            <OtherNode start="(415, 19)" end="(415, 23)" kind="Lean.Parser.Term.dotIdent">
                                                            <AtomNode start="(415, 19)" end="(415, 20)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(415, 20)" end="(415, 23)" leading="" trailing=" " raw_val="inl" val="inl"/>
                                                            </OtherNode>
                                                            <NullNode start="(415, 24)" end="(415, 31)">
                                                            <OtherNode start="(415, 24)" end="(415, 31)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(415, 24)" end="(415, 25)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(415, 25)" end="(415, 30)">
                                                            <IdentNode start="(415, 25)" end="(415, 27)" leading="" trailing="" raw_val="eq" val="eq"/>
                                                            <AtomNode start="(415, 27)" end="(415, 28)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(415, 29)" end="(415, 30)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </NullNode>
                                                            <AtomNode start="(415, 30)" end="(415, 31)" leading="" trailing="&#10;          " val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(416, 11)" end="(424, 29)" kind="Lean.cdot" state_before="case inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" state_after="no goals" tactic="· refine .inr ⟨i + 1, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;  · intro j hj&#10;    cases j with&#10;    | zero =&amp;gt; simpa using BEq.symm eq&#10;    | succ j =&amp;gt;&#10;      simp only [getElem_cons_succ]&#10;      rw [w₁]&#10;      simpa using hj&#10;  · simpa using w₂">
                                                            <OtherNode start="(416, 11)" end="(416, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(416, 11)" end="(416, 12)" kind="patternIgnore">
                                                            <OtherNode start="(416, 11)" end="(416, 12)" kind="token.«· »">
                                                            <AtomNode start="(416, 11)" end="(416, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(416, 13)" end="(424, 29)">
                                                            <TacticTacticseq1IndentedNode start="(416, 13)" end="(424, 29)">
                                                            <NullNode start="(416, 13)" end="(424, 29)">
                                                            <OtherNode start="(416, 13)" end="(416, 78)" kind="Lean.Parser.Tactic.refine" state_before="case inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" state_after="case inr.intro.intro.intro.intro.refine_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;&#10;case inr.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true" tactic="refine .inr ⟨i + 1, by simpa using h₁, by simpa using h₂, ?_, ?_⟩">
                                                            <AtomNode start="(416, 13)" end="(416, 19)" leading="" trailing=" " val="refine"/>
                                                            <OtherNode start="(416, 20)" end="(416, 78)" kind="Lean.Parser.Term.app">
                                                            <OtherNode start="(416, 20)" end="(416, 24)" kind="Lean.Parser.Term.dotIdent">
                                                            <AtomNode start="(416, 20)" end="(416, 21)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(416, 21)" end="(416, 24)" leading="" trailing=" " raw_val="inr" val="inr"/>
                                                            </OtherNode>
                                                            <NullNode start="(416, 25)" end="(416, 78)">
                                                            <OtherNode start="(416, 25)" end="(416, 78)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(416, 25)" end="(416, 26)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(416, 26)" end="(416, 77)">
                                                            <OtherNode start="(416, 26)" end="(416, 31)" kind="«term_+_»">
                                                            <IdentNode start="(416, 26)" end="(416, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            <AtomNode start="(416, 28)" end="(416, 29)" leading="" trailing=" " val="+"/>
                                                            <OtherNode start="(416, 30)" end="(416, 31)" kind="num">
                                                            <AtomNode start="(416, 30)" end="(416, 31)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(416, 31)" end="(416, 32)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(416, 33)" end="(416, 50)">
                                                            <AtomNode start="(416, 33)" end="(416, 35)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(416, 36)" end="(416, 50)">
                                                            <TacticTacticseq1IndentedNode start="(416, 36)" end="(416, 50)">
                                                            <NullNode start="(416, 36)" end="(416, 50)">
                                                            <OtherNode start="(416, 36)" end="(416, 50)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ i + 1 &amp;lt; l₁.length + 1" state_after="no goals" tactic="simpa using h₁">
                                                            <AtomNode start="(416, 36)" end="(416, 41)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(416, 42)" end="(416, 50)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(416, 42)" end="(416, 50)">
                                                            <AtomNode start="(416, 42)" end="(416, 47)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(416, 48)" end="(416, 50)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(416, 50)" end="(416, 51)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(416, 52)" end="(416, 69)">
                                                            <AtomNode start="(416, 52)" end="(416, 54)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(416, 55)" end="(416, 69)">
                                                            <TacticTacticseq1IndentedNode start="(416, 55)" end="(416, 69)">
                                                            <NullNode start="(416, 55)" end="(416, 69)">
                                                            <OtherNode start="(416, 55)" end="(416, 69)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ i + 1 &amp;lt; l₂.length + 1" state_after="no goals" tactic="simpa using h₂">
                                                            <AtomNode start="(416, 55)" end="(416, 60)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(416, 61)" end="(416, 69)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(416, 61)" end="(416, 69)">
                                                            <AtomNode start="(416, 61)" end="(416, 66)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(416, 67)" end="(416, 69)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(416, 69)" end="(416, 70)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(416, 71)" end="(416, 73)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(416, 71)" end="(416, 72)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(416, 72)" end="(416, 73)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            <AtomNode start="(416, 73)" end="(416, 74)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(416, 75)" end="(416, 77)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(416, 75)" end="(416, 76)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(416, 76)" end="(416, 77)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(416, 77)" end="(416, 78)" leading="" trailing="&#10;            " val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(417, 13)" end="(423, 31)" kind="Lean.cdot" state_before="case inr.intro.intro.intro.intro.refine_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;&#10;case inr.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true" state_after="case inr.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true" tactic="· intro j hj&#10;  cases j with&#10;  | zero =&amp;gt; simpa using BEq.symm eq&#10;  | succ j =&amp;gt;&#10;    simp only [getElem_cons_succ]&#10;    rw [w₁]&#10;    simpa using hj">
                                                            <OtherNode start="(417, 13)" end="(417, 14)" kind="Lean.cdotTk">
                                                            <OtherNode start="(417, 13)" end="(417, 14)" kind="patternIgnore">
                                                            <OtherNode start="(417, 13)" end="(417, 14)" kind="token.«· »">
                                                            <AtomNode start="(417, 13)" end="(417, 14)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(417, 15)" end="(423, 31)">
                                                            <TacticTacticseq1IndentedNode start="(417, 15)" end="(423, 31)">
                                                            <NullNode start="(417, 15)" end="(423, 31)">
                                                            <OtherNode start="(417, 15)" end="(417, 25)" kind="Lean.Parser.Tactic.intro" state_before="case inr.intro.intro.intro.intro.refine_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true" state_after="case inr.intro.intro.intro.intro.refine_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;j : Nat&#10;hj : j &amp;lt; i + 1&#10;⊢ ((a :: l₁)[j] == (b :: l₂)[j]) = true" tactic="intro j hj">
                                                            <AtomNode start="(417, 15)" end="(417, 20)" leading="" trailing=" " val="intro"/>
                                                            <NullNode start="(417, 21)" end="(417, 25)">
                                                            <IdentNode start="(417, 21)" end="(417, 22)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            <IdentNode start="(417, 23)" end="(417, 25)" leading="" trailing="&#10;              " raw_val="hj" val="hj"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(418, 15)" end="(423, 31)" kind="Lean.Parser.Tactic.cases" state_before="case inr.intro.intro.intro.intro.refine_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;j : Nat&#10;hj : j &amp;lt; i + 1&#10;⊢ ((a :: l₁)[j] == (b :: l₂)[j]) = true" state_after="no goals" tactic="cases j with&#10;| zero =&amp;gt; simpa using BEq.symm eq&#10;| succ j =&amp;gt;&#10;  simp only [getElem_cons_succ]&#10;  rw [w₁]&#10;  simpa using hj">
                                                            <AtomNode start="(418, 15)" end="(418, 20)" leading="" trailing=" " val="cases"/>
                                                            <NullNode start="(418, 21)" end="(418, 22)">
                                                            <OtherNode start="(418, 21)" end="(418, 22)" kind="Lean.Parser.Tactic.elimTarget">
                                                            <NullNode/>
                                                            <IdentNode start="(418, 21)" end="(418, 22)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode start="(418, 23)" end="(423, 31)">
                                                            <OtherNode start="(418, 23)" end="(423, 31)" kind="Lean.Parser.Tactic.inductionAlts">
                                                            <AtomNode start="(418, 23)" end="(418, 27)" leading="" trailing="&#10;              " val="with"/>
                                                            <NullNode/>
                                                            <NullNode start="(419, 15)" end="(423, 31)">
                                                            <OtherNode start="(419, 15)" end="(419, 48)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(419, 15)" end="(419, 21)">
                                                            <OtherNode start="(419, 15)" end="(419, 21)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(419, 15)" end="(419, 16)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(419, 17)" end="(419, 21)">
                                                            <NullNode/>
                                                            <IdentNode start="(419, 17)" end="(419, 21)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                            </GroupNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(419, 22)" end="(419, 48)">
                                                            <AtomNode start="(419, 22)" end="(419, 24)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(419, 25)" end="(419, 48)">
                                                            <TacticTacticseq1IndentedNode start="(419, 25)" end="(419, 48)">
                                                            <NullNode start="(419, 25)" end="(419, 48)">
                                                            <OtherNode start="(419, 25)" end="(419, 48)" kind="Lean.Parser.Tactic.simpa" state_before="case inr.intro.intro.intro.intro.refine_1.zero&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;hj : 0 &amp;lt; i + 1&#10;⊢ ((a :: l₁)[0] == (b :: l₂)[0]) = true" state_after="no goals" tactic="simpa using BEq.symm eq">
                                                            <AtomNode start="(419, 25)" end="(419, 30)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(419, 31)" end="(419, 48)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(419, 31)" end="(419, 48)">
                                                            <AtomNode start="(419, 31)" end="(419, 36)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(419, 37)" end="(419, 48)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(419, 37)" end="(419, 45)" leading="" trailing=" " raw_val="BEq.symm" val="BEq.symm" full_name="BEq.symm" mod_name="Init.Data.BEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BEq.lean"/>
                                                            <NullNode start="(419, 46)" end="(419, 48)">
                                                            <IdentNode start="(419, 46)" end="(419, 48)" leading="" trailing="&#10;              " raw_val="eq" val="eq"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <OtherNode start="(420, 15)" end="(423, 31)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(420, 15)" end="(420, 23)">
                                                            <OtherNode start="(420, 15)" end="(420, 23)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(420, 15)" end="(420, 16)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(420, 17)" end="(420, 21)">
                                                            <NullNode/>
                                                            <IdentNode start="(420, 17)" end="(420, 21)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                            </GroupNode>
                                                            <NullNode start="(420, 22)" end="(420, 23)">
                                                            <IdentNode start="(420, 22)" end="(420, 23)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(420, 24)" end="(423, 31)">
                                                            <AtomNode start="(420, 24)" end="(420, 26)" leading="" trailing="&#10;                " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(421, 17)" end="(423, 31)">
                                                            <TacticTacticseq1IndentedNode start="(421, 17)" end="(423, 31)">
                                                            <NullNode start="(421, 17)" end="(423, 31)">
                                                            <OtherNode start="(421, 17)" end="(421, 46)" kind="Lean.Parser.Tactic.simp" state_before="case inr.intro.intro.intro.intro.refine_1.succ&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;j : Nat&#10;hj : j + 1 &amp;lt; i + 1&#10;⊢ ((a :: l₁)[j + 1] == (b :: l₂)[j + 1]) = true" state_after="case inr.intro.intro.intro.intro.refine_1.succ&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;j : Nat&#10;hj : j + 1 &amp;lt; i + 1&#10;⊢ (l₁[j] == l₂[j]) = true" tactic="simp only [getElem_cons_succ]">
                                                            <AtomNode start="(421, 17)" end="(421, 21)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(421, 22)" end="(421, 26)">
                                                            <AtomNode start="(421, 22)" end="(421, 26)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(421, 27)" end="(421, 46)">
                                                            <AtomNode start="(421, 27)" end="(421, 28)" leading="" trailing="" val="["/>
                                                            <NullNode start="(421, 28)" end="(421, 45)">
                                                            <OtherNode start="(421, 28)" end="(421, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(421, 28)" end="(421, 45)" leading="" trailing="" raw_val="getElem_cons_succ" val="getElem_cons_succ" full_name="List.getElem_cons_succ" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(421, 45)" end="(421, 46)" leading="" trailing="&#10;                " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(422, 17)" end="(422, 24)" kind="Lean.Parser.Tactic.rwSeq" state_before="case inr.intro.intro.intro.intro.refine_1.succ&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;j : Nat&#10;hj : j + 1 &amp;lt; i + 1&#10;⊢ (l₁[j] == l₂[j]) = true" state_after="case inr.intro.intro.intro.intro.refine_1.succ.hj&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;j : Nat&#10;hj : j + 1 &amp;lt; i + 1&#10;⊢ j &amp;lt; i" tactic="rw [w₁]">
                                                            <AtomNode start="(422, 17)" end="(422, 19)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(422, 20)" end="(422, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(422, 20)" end="(422, 21)" leading="" trailing="" val="["/>
                                                            <NullNode start="(422, 21)" end="(422, 23)">
                                                            <OtherNode start="(422, 21)" end="(422, 23)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(422, 21)" end="(422, 23)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(422, 23)" end="(422, 24)" leading="" trailing="&#10;                " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(423, 17)" end="(423, 31)" kind="Lean.Parser.Tactic.simpa" state_before="case inr.intro.intro.intro.intro.refine_1.succ.hj&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;j : Nat&#10;hj : j + 1 &amp;lt; i + 1&#10;⊢ j &amp;lt; i" state_after="no goals" tactic="simpa using hj">
                                                            <AtomNode start="(423, 17)" end="(423, 22)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(423, 23)" end="(423, 31)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(423, 23)" end="(423, 31)">
                                                            <AtomNode start="(423, 23)" end="(423, 28)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(423, 29)" end="(423, 31)" leading="" trailing="&#10;            " raw_val="hj" val="hj"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(424, 13)" end="(424, 29)" kind="Lean.cdot" state_before="case inr.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true" state_after="no goals" tactic="· simpa using w₂">
                                                            <OtherNode start="(424, 13)" end="(424, 14)" kind="Lean.cdotTk">
                                                            <OtherNode start="(424, 13)" end="(424, 14)" kind="patternIgnore">
                                                            <OtherNode start="(424, 13)" end="(424, 14)" kind="token.«· »">
                                                            <AtomNode start="(424, 13)" end="(424, 14)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(424, 15)" end="(424, 29)">
                                                            <TacticTacticseq1IndentedNode start="(424, 15)" end="(424, 29)">
                                                            <NullNode start="(424, 15)" end="(424, 29)">
                                                            <OtherNode start="(424, 15)" end="(424, 29)" kind="Lean.Parser.Tactic.simpa" state_before="case inr.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;eq : (b == a) = true&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;w₂ : lt l₂[i] l₁[i] = true&#10;⊢ lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true" state_after="no goals" tactic="simpa using w₂">
                                                            <AtomNode start="(424, 15)" end="(424, 20)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(424, 21)" end="(424, 29)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(424, 21)" end="(424, 29)">
                                                            <AtomNode start="(424, 21)" end="(424, 26)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(424, 27)" end="(424, 29)" leading="" trailing="&#10;        " raw_val="w₂" val="w₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            <AtomNode start="(425, 9)" end="(425, 13)" leading="" trailing="&#10;          " val="else"/>
                                                            <TacticTacticseqNode start="(426, 11)" end="(429, 48)">
                                                            <TacticTacticseq1IndentedNode start="(426, 11)" end="(429, 48)">
                                                            <NullNode start="(426, 11)" end="(429, 48)">
                                                            <OtherNode start="(426, 11)" end="(426, 16)" kind="Lean.Parser.Tactic.right" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;h :&#10;  (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;eq : ¬(b == a) = true&#10;⊢ (b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" state_after="case h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;h :&#10;  (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;eq : ¬(b == a) = true&#10;⊢ ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" tactic="right">
                                                            <AtomNode start="(426, 11)" end="(426, 16)" leading="" trailing="&#10;          " val="right"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(427, 11)" end="(428, 95)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;h :&#10;  (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;eq : ¬(b == a) = true&#10;⊢ ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" state_after="case h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;h :&#10;  (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;eq : ¬(b == a) = true&#10;hba : lt b a = true&#10;⊢ ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" tactic="have hba : lt b a :=&#10;  Decidable.byContradiction fun hba =&amp;gt; eq (lt_antisymm _ _ (by simpa using hba) hab)">
                                                            <AtomNode start="(427, 11)" end="(427, 15)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(427, 16)" end="(428, 95)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(427, 16)" end="(428, 95)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(427, 16)" end="(427, 19)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(427, 16)" end="(427, 19)" leading="" trailing=" " raw_val="hba" val="hba"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(427, 20)" end="(427, 28)">
                                                            <TermTypespecNode start="(427, 20)" end="(427, 28)">
                                                            <AtomNode start="(427, 20)" end="(427, 21)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(427, 22)" end="(427, 28)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(427, 22)" end="(427, 24)" leading="" trailing=" " raw_val="lt" val="lt"/>
                                                            <NullNode start="(427, 25)" end="(427, 28)">
                                                            <IdentNode start="(427, 25)" end="(427, 26)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            <IdentNode start="(427, 27)" end="(427, 28)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(427, 29)" end="(427, 31)" leading="" trailing="&#10;            " val=":="/>
                                                            <OtherNode start="(428, 13)" end="(428, 95)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(428, 13)" end="(428, 38)" leading="" trailing=" " raw_val="Decidable.byContradiction" val="Decidable.byContradiction" full_name="Decidable.byContradiction" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            <NullNode start="(428, 39)" end="(428, 95)">
                                                            <OtherNode start="(428, 39)" end="(428, 95)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(428, 39)" end="(428, 42)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(428, 43)" end="(428, 95)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(428, 43)" end="(428, 46)">
                                                            <IdentNode start="(428, 43)" end="(428, 46)" leading="" trailing=" " raw_val="hba" val="hba"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(428, 47)" end="(428, 49)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(428, 50)" end="(428, 95)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(428, 50)" end="(428, 52)" leading="" trailing=" " raw_val="eq" val="eq"/>
                                                            <NullNode start="(428, 53)" end="(428, 95)">
                                                            <OtherNode start="(428, 53)" end="(428, 95)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(428, 53)" end="(428, 54)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(428, 54)" end="(428, 94)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(428, 54)" end="(428, 65)" leading="" trailing=" " raw_val="lt_antisymm" val="lt_antisymm"/>
                                                            <NullNode start="(428, 66)" end="(428, 94)">
                                                            <TermHoleNode start="(428, 66)" end="(428, 67)">
                                                            <AtomNode start="(428, 66)" end="(428, 67)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(428, 68)" end="(428, 69)">
                                                            <AtomNode start="(428, 68)" end="(428, 69)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(428, 70)" end="(428, 90)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(428, 70)" end="(428, 71)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(428, 71)" end="(428, 89)">
                                                            <AtomNode start="(428, 71)" end="(428, 73)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(428, 74)" end="(428, 89)">
                                                            <TacticTacticseq1IndentedNode start="(428, 74)" end="(428, 89)">
                                                            <NullNode start="(428, 74)" end="(428, 89)">
                                                            <OtherNode start="(428, 74)" end="(428, 89)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;h :&#10;  (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;eq : ¬(b == a) = true&#10;hba : ¬lt b a = true&#10;⊢ lt b a = false" state_after="no goals" tactic="simpa using hba">
                                                            <AtomNode start="(428, 74)" end="(428, 79)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(428, 80)" end="(428, 89)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(428, 80)" end="(428, 89)">
                                                            <AtomNode start="(428, 80)" end="(428, 85)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(428, 86)" end="(428, 89)" leading="" trailing="" raw_val="hba" val="hba"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(428, 89)" end="(428, 90)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <IdentNode start="(428, 91)" end="(428, 94)" leading="" trailing="" raw_val="hab" val="hab"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(428, 94)" end="(428, 95)" leading="" trailing="&#10;          " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(429, 11)" end="(429, 48)" kind="Lean.Parser.Tactic.exact" state_before="case h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;h :&#10;  (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;eq : ¬(b == a) = true&#10;hba : lt b a = true&#10;⊢ ∃ i h h₂, (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true" state_after="no goals" tactic="exact ⟨0, by simp, by simp, by simpa⟩">
                                                            <AtomNode start="(429, 11)" end="(429, 16)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(429, 17)" end="(429, 48)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(429, 17)" end="(429, 18)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(429, 18)" end="(429, 47)">
                                                            <OtherNode start="(429, 18)" end="(429, 19)" kind="num">
                                                            <AtomNode start="(429, 18)" end="(429, 19)" leading="" trailing="" val="0"/>
                                                            </OtherNode>
                                                            <AtomNode start="(429, 19)" end="(429, 20)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(429, 21)" end="(429, 28)">
                                                            <AtomNode start="(429, 21)" end="(429, 23)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(429, 24)" end="(429, 28)">
                                                            <TacticTacticseq1IndentedNode start="(429, 24)" end="(429, 28)">
                                                            <NullNode start="(429, 24)" end="(429, 28)">
                                                            <OtherNode start="(429, 24)" end="(429, 28)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;h :&#10;  (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;eq : ¬(b == a) = true&#10;hba : lt b a = true&#10;⊢ 0 &amp;lt; l₁.length + 1" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(429, 24)" end="(429, 28)" leading="" trailing="" val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(429, 28)" end="(429, 29)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(429, 30)" end="(429, 37)">
                                                            <AtomNode start="(429, 30)" end="(429, 32)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(429, 33)" end="(429, 37)">
                                                            <TacticTacticseq1IndentedNode start="(429, 33)" end="(429, 37)">
                                                            <NullNode start="(429, 33)" end="(429, 37)">
                                                            <OtherNode start="(429, 33)" end="(429, 37)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;h :&#10;  (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;eq : ¬(b == a) = true&#10;hba : lt b a = true&#10;⊢ 0 &amp;lt; l₂.length + 1" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(429, 33)" end="(429, 37)" leading="" trailing="" val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(429, 37)" end="(429, 38)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(429, 39)" end="(429, 47)">
                                                            <AtomNode start="(429, 39)" end="(429, 41)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(429, 42)" end="(429, 47)">
                                                            <TacticTacticseq1IndentedNode start="(429, 42)" end="(429, 47)">
                                                            <NullNode start="(429, 42)" end="(429, 47)">
                                                            <OtherNode start="(429, 42)" end="(429, 47)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;hab : lt a b = false&#10;h :&#10;  (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;eq : ¬(b == a) = true&#10;hba : lt b a = true&#10;⊢ (∀ (j : Nat) (hj : j &amp;lt; 0), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[0] (a :: l₁)[0] = true" state_after="no goals" tactic="simpa">
                                                            <AtomNode start="(429, 42)" end="(429, 47)" leading="" trailing="" val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            </NullNode>
                                                            <AtomNode start="(429, 47)" end="(429, 48)" leading="" trailing="&#10;      " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <OtherNode start="(430, 7)" end="(444, 29)" kind="Lean.cdot" state_before="case cons.cons.mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ ((b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h h₂,&#10;        (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true) →&#10;    lt a b = false ∧&#10;      ((a == b) = true →&#10;        (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" state_after="no goals" tactic="· rintro (⟨eq, h⟩ | ⟨i, h₁, h₂, w₁, w₂⟩)&#10;  · exact ⟨lt_irrefl _ _ (BEq.symm eq), fun _ =&amp;gt; .inl h⟩&#10;  · cases i with&#10;    | zero =&amp;gt;&#10;      simp at w₂&#10;      refine ⟨lt_asymm _ _ w₂, ?_⟩&#10;      intro eq&#10;      exfalso&#10;      simp [lt_irrefl _ _ (BEq.symm eq)] at w₂&#10;    | succ i =&amp;gt;&#10;      refine ⟨lt_irrefl _ _ (by simpa using w₁ 0 (by simp)), ?_⟩&#10;      refine fun _ =&amp;gt; .inr ⟨i, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;      · intro j hj&#10;        simpa using w₁ (j + 1) (by simpa)&#10;      · simpa using w₂">
                                                          <OtherNode start="(430, 7)" end="(430, 8)" kind="Lean.cdotTk">
                                                            <OtherNode start="(430, 7)" end="(430, 8)" kind="patternIgnore">
                                                            <OtherNode start="(430, 7)" end="(430, 8)" kind="token.«· »">
                                                            <AtomNode start="(430, 7)" end="(430, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                          <TacticTacticseqNode start="(430, 9)" end="(444, 29)">
                                                            <TacticTacticseq1IndentedNode start="(430, 9)" end="(444, 29)">
                                                            <NullNode start="(430, 9)" end="(444, 29)">
                                                            <OtherNode start="(430, 9)" end="(430, 47)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.cons.mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;⊢ ((b == a) = true ∧ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h h₂,&#10;        (∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true) ∧ lt (b :: l₂)[i] (a :: l₁)[i] = true) →&#10;    lt a b = false ∧&#10;      ((a == b) = true →&#10;        (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;          ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" state_after="case cons.cons.mpr.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;eq : (b == a) = true&#10;h : (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;⊢ lt a b = false ∧&#10;    ((a == b) = true →&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)&#10;&#10;case cons.cons.mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length + 1&#10;h₂ : i &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i] (a :: l₁)[i] = true&#10;⊢ lt a b = false ∧&#10;    ((a == b) = true →&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" tactic="rintro (⟨eq, h⟩ | ⟨i, h₁, h₂, w₁, w₂⟩)">
                                                            <AtomNode start="(430, 9)" end="(430, 15)" leading="" trailing=" " val="rintro"/>
                                                            <NullNode start="(430, 16)" end="(430, 47)">
                                                            <OtherNode start="(430, 16)" end="(430, 47)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                            <OtherNode start="(430, 16)" end="(430, 47)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                            <AtomNode start="(430, 16)" end="(430, 17)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(430, 17)" end="(430, 46)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(430, 17)" end="(430, 46)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(430, 17)" end="(430, 46)">
                                                            <OtherNode start="(430, 17)" end="(430, 24)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(430, 17)" end="(430, 18)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(430, 18)" end="(430, 23)">
                                                            <OtherNode start="(430, 18)" end="(430, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(430, 18)" end="(430, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(430, 18)" end="(430, 20)">
                                                            <OtherNode start="(430, 18)" end="(430, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(430, 18)" end="(430, 20)" leading="" trailing="" raw_val="eq" val="eq"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(430, 20)" end="(430, 21)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(430, 22)" end="(430, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(430, 22)" end="(430, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(430, 22)" end="(430, 23)">
                                                            <OtherNode start="(430, 22)" end="(430, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(430, 22)" end="(430, 23)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(430, 23)" end="(430, 24)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            <AtomNode start="(430, 25)" end="(430, 26)" leading="" trailing=" " val="|"/>
                                                            <OtherNode start="(430, 27)" end="(430, 46)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(430, 27)" end="(430, 28)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(430, 28)" end="(430, 45)">
                                                            <OtherNode start="(430, 28)" end="(430, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(430, 28)" end="(430, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(430, 28)" end="(430, 29)">
                                                            <OtherNode start="(430, 28)" end="(430, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(430, 28)" end="(430, 29)" leading="" trailing="" raw_val="i" val="i"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(430, 29)" end="(430, 30)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(430, 31)" end="(430, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(430, 31)" end="(430, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(430, 31)" end="(430, 33)">
                                                            <OtherNode start="(430, 31)" end="(430, 33)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(430, 31)" end="(430, 33)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(430, 33)" end="(430, 34)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(430, 35)" end="(430, 37)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(430, 35)" end="(430, 37)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(430, 35)" end="(430, 37)">
                                                            <OtherNode start="(430, 35)" end="(430, 37)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(430, 35)" end="(430, 37)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(430, 37)" end="(430, 38)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(430, 39)" end="(430, 41)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(430, 39)" end="(430, 41)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(430, 39)" end="(430, 41)">
                                                            <OtherNode start="(430, 39)" end="(430, 41)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(430, 39)" end="(430, 41)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(430, 41)" end="(430, 42)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(430, 43)" end="(430, 45)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(430, 43)" end="(430, 45)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(430, 43)" end="(430, 45)">
                                                            <OtherNode start="(430, 43)" end="(430, 45)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(430, 43)" end="(430, 45)" leading="" trailing="" raw_val="w₂" val="w₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(430, 45)" end="(430, 46)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(430, 46)" end="(430, 47)" leading="" trailing="&#10;        " val=")"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(431, 9)" end="(431, 63)" kind="Lean.cdot" state_before="case cons.cons.mpr.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;eq : (b == a) = true&#10;h : (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;⊢ lt a b = false ∧&#10;    ((a == b) = true →&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)&#10;&#10;case cons.cons.mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length + 1&#10;h₂ : i &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i] (a :: l₁)[i] = true&#10;⊢ lt a b = false ∧&#10;    ((a == b) = true →&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length + 1&#10;h₂ : i &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i] (a :: l₁)[i] = true&#10;⊢ lt a b = false ∧&#10;    ((a == b) = true →&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" tactic="· exact ⟨lt_irrefl _ _ (BEq.symm eq), fun _ =&amp;gt; .inl h⟩">
                                                            <OtherNode start="(431, 9)" end="(431, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(431, 9)" end="(431, 10)" kind="patternIgnore">
                                                            <OtherNode start="(431, 9)" end="(431, 10)" kind="token.«· »">
                                                            <AtomNode start="(431, 9)" end="(431, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(431, 11)" end="(431, 63)">
                                                            <TacticTacticseq1IndentedNode start="(431, 11)" end="(431, 63)">
                                                            <NullNode start="(431, 11)" end="(431, 63)">
                                                            <OtherNode start="(431, 11)" end="(431, 63)" kind="Lean.Parser.Tactic.exact" state_before="case cons.cons.mpr.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;eq : (b == a) = true&#10;h : (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true&#10;⊢ lt a b = false ∧&#10;    ((a == b) = true →&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" state_after="no goals" tactic="exact ⟨lt_irrefl _ _ (BEq.symm eq), fun _ =&amp;gt; .inl h⟩">
                                                            <AtomNode start="(431, 11)" end="(431, 16)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(431, 17)" end="(431, 63)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(431, 17)" end="(431, 18)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(431, 18)" end="(431, 62)">
                                                            <OtherNode start="(431, 18)" end="(431, 45)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(431, 18)" end="(431, 27)" leading="" trailing=" " raw_val="lt_irrefl" val="lt_irrefl"/>
                                                            <NullNode start="(431, 28)" end="(431, 45)">
                                                            <TermHoleNode start="(431, 28)" end="(431, 29)">
                                                            <AtomNode start="(431, 28)" end="(431, 29)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(431, 30)" end="(431, 31)">
                                                            <AtomNode start="(431, 30)" end="(431, 31)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(431, 32)" end="(431, 45)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(431, 32)" end="(431, 33)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(431, 33)" end="(431, 44)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(431, 33)" end="(431, 41)" leading="" trailing=" " raw_val="BEq.symm" val="BEq.symm" full_name="BEq.symm" mod_name="Init.Data.BEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BEq.lean"/>
                                                            <NullNode start="(431, 42)" end="(431, 44)">
                                                            <IdentNode start="(431, 42)" end="(431, 44)" leading="" trailing="" raw_val="eq" val="eq"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(431, 44)" end="(431, 45)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(431, 45)" end="(431, 46)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(431, 47)" end="(431, 62)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(431, 47)" end="(431, 50)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(431, 51)" end="(431, 62)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(431, 51)" end="(431, 52)">
                                                            <TermHoleNode start="(431, 51)" end="(431, 52)">
                                                            <AtomNode start="(431, 51)" end="(431, 52)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(431, 53)" end="(431, 55)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(431, 56)" end="(431, 62)" kind="Lean.Parser.Term.app">
                                                            <OtherNode start="(431, 56)" end="(431, 60)" kind="Lean.Parser.Term.dotIdent">
                                                            <AtomNode start="(431, 56)" end="(431, 57)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(431, 57)" end="(431, 60)" leading="" trailing=" " raw_val="inl" val="inl"/>
                                                            </OtherNode>
                                                            <NullNode start="(431, 61)" end="(431, 62)">
                                                            <IdentNode start="(431, 61)" end="(431, 62)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(431, 62)" end="(431, 63)" leading="" trailing="&#10;        " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(432, 9)" end="(444, 29)" kind="Lean.cdot" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length + 1&#10;h₂ : i &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i] (a :: l₁)[i] = true&#10;⊢ lt a b = false ∧&#10;    ((a == b) = true →&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" state_after="no goals" tactic="· cases i with&#10;  | zero =&amp;gt;&#10;    simp at w₂&#10;    refine ⟨lt_asymm _ _ w₂, ?_⟩&#10;    intro eq&#10;    exfalso&#10;    simp [lt_irrefl _ _ (BEq.symm eq)] at w₂&#10;  | succ i =&amp;gt;&#10;    refine ⟨lt_irrefl _ _ (by simpa using w₁ 0 (by simp)), ?_⟩&#10;    refine fun _ =&amp;gt; .inr ⟨i, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;    · intro j hj&#10;      simpa using w₁ (j + 1) (by simpa)&#10;    · simpa using w₂">
                                                            <OtherNode start="(432, 9)" end="(432, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(432, 9)" end="(432, 10)" kind="patternIgnore">
                                                            <OtherNode start="(432, 9)" end="(432, 10)" kind="token.«· »">
                                                            <AtomNode start="(432, 9)" end="(432, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(432, 11)" end="(444, 29)">
                                                            <TacticTacticseq1IndentedNode start="(432, 11)" end="(444, 29)">
                                                            <NullNode start="(432, 11)" end="(444, 29)">
                                                            <OtherNode start="(432, 11)" end="(444, 29)" kind="Lean.Parser.Tactic.cases" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length + 1&#10;h₂ : i &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i] (a :: l₁)[i] = true&#10;⊢ lt a b = false ∧&#10;    ((a == b) = true →&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" state_after="no goals" tactic="cases i with&#10;| zero =&amp;gt;&#10;  simp at w₂&#10;  refine ⟨lt_asymm _ _ w₂, ?_⟩&#10;  intro eq&#10;  exfalso&#10;  simp [lt_irrefl _ _ (BEq.symm eq)] at w₂&#10;| succ i =&amp;gt;&#10;  refine ⟨lt_irrefl _ _ (by simpa using w₁ 0 (by simp)), ?_⟩&#10;  refine fun _ =&amp;gt; .inr ⟨i, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;  · intro j hj&#10;    simpa using w₁ (j + 1) (by simpa)&#10;  · simpa using w₂">
                                                            <AtomNode start="(432, 11)" end="(432, 16)" leading="" trailing=" " val="cases"/>
                                                            <NullNode start="(432, 17)" end="(432, 18)">
                                                            <OtherNode start="(432, 17)" end="(432, 18)" kind="Lean.Parser.Tactic.elimTarget">
                                                            <NullNode/>
                                                            <IdentNode start="(432, 17)" end="(432, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode start="(432, 19)" end="(444, 29)">
                                                            <OtherNode start="(432, 19)" end="(444, 29)" kind="Lean.Parser.Tactic.inductionAlts">
                                                            <AtomNode start="(432, 19)" end="(432, 23)" leading="" trailing="&#10;          " val="with"/>
                                                            <NullNode/>
                                                            <NullNode start="(433, 11)" end="(444, 29)">
                                                            <OtherNode start="(433, 11)" end="(438, 53)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(433, 11)" end="(433, 17)">
                                                            <OtherNode start="(433, 11)" end="(433, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(433, 11)" end="(433, 12)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(433, 13)" end="(433, 17)">
                                                            <NullNode/>
                                                            <IdentNode start="(433, 13)" end="(433, 17)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                            </GroupNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(433, 18)" end="(438, 53)">
                                                            <AtomNode start="(433, 18)" end="(433, 20)" leading="" trailing="&#10;            " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(434, 13)" end="(438, 53)">
                                                            <TacticTacticseq1IndentedNode start="(434, 13)" end="(438, 53)">
                                                            <NullNode start="(434, 13)" end="(438, 53)">
                                                            <OtherNode start="(434, 13)" end="(434, 23)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.zero&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;h₁ : 0 &amp;lt; l₁.length + 1&#10;h₂ : 0 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; 0), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[0] (a :: l₁)[0] = true&#10;⊢ lt a b = false ∧&#10;    ((a == b) = true →&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.zero&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;h₁ : 0 &amp;lt; l₁.length + 1&#10;h₂ : 0 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; 0), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt b a = true&#10;⊢ lt a b = false ∧&#10;    ((a == b) = true →&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" tactic="simp at w₂">
                                                            <AtomNode start="(434, 13)" end="(434, 17)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(434, 18)" end="(434, 23)">
                                                            <OtherNode start="(434, 18)" end="(434, 23)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(434, 18)" end="(434, 20)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(434, 21)" end="(434, 23)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(434, 21)" end="(434, 23)">
                                                            <IdentNode start="(434, 21)" end="(434, 23)" leading="" trailing="&#10;            " raw_val="w₂" val="w₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(435, 13)" end="(435, 41)" kind="Lean.Parser.Tactic.refine" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.zero&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;h₁ : 0 &amp;lt; l₁.length + 1&#10;h₂ : 0 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; 0), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt b a = true&#10;⊢ lt a b = false ∧&#10;    ((a == b) = true →&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.zero&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;h₁ : 0 &amp;lt; l₁.length + 1&#10;h₂ : 0 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; 0), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt b a = true&#10;⊢ (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true" tactic="refine ⟨lt_asymm _ _ w₂, ?_⟩">
                                                            <AtomNode start="(435, 13)" end="(435, 19)" leading="" trailing=" " val="refine"/>
                                                            <OtherNode start="(435, 20)" end="(435, 41)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(435, 20)" end="(435, 21)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(435, 21)" end="(435, 40)">
                                                            <OtherNode start="(435, 21)" end="(435, 36)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(435, 21)" end="(435, 29)" leading="" trailing=" " raw_val="lt_asymm" val="lt_asymm"/>
                                                            <NullNode start="(435, 30)" end="(435, 36)">
                                                            <TermHoleNode start="(435, 30)" end="(435, 31)">
                                                            <AtomNode start="(435, 30)" end="(435, 31)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(435, 32)" end="(435, 33)">
                                                            <AtomNode start="(435, 32)" end="(435, 33)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(435, 34)" end="(435, 36)" leading="" trailing="" raw_val="w₂" val="w₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(435, 36)" end="(435, 37)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(435, 38)" end="(435, 40)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(435, 38)" end="(435, 39)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(435, 39)" end="(435, 40)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(435, 40)" end="(435, 41)" leading="" trailing="&#10;            " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(436, 13)" end="(436, 21)" kind="Lean.Parser.Tactic.intro" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.zero&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;h₁ : 0 &amp;lt; l₁.length + 1&#10;h₂ : 0 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; 0), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt b a = true&#10;⊢ (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.zero&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;h₁ : 0 &amp;lt; l₁.length + 1&#10;h₂ : 0 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; 0), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt b a = true&#10;eq : (a == b) = true&#10;⊢ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true" tactic="intro eq">
                                                            <AtomNode start="(436, 13)" end="(436, 18)" leading="" trailing=" " val="intro"/>
                                                            <NullNode start="(436, 19)" end="(436, 21)">
                                                            <IdentNode start="(436, 19)" end="(436, 21)" leading="" trailing="&#10;            " raw_val="eq" val="eq"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(437, 13)" end="(437, 20)" kind="Lean.Parser.Tactic.tacticExfalso" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.zero&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;h₁ : 0 &amp;lt; l₁.length + 1&#10;h₂ : 0 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; 0), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt b a = true&#10;eq : (a == b) = true&#10;⊢ (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.zero&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;h₁ : 0 &amp;lt; l₁.length + 1&#10;h₂ : 0 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; 0), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt b a = true&#10;eq : (a == b) = true&#10;⊢ False" tactic="exfalso">
                                                            <AtomNode start="(437, 13)" end="(437, 20)" leading="" trailing="&#10;            " val="exfalso"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(438, 13)" end="(438, 53)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.zero&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;h₁ : 0 &amp;lt; l₁.length + 1&#10;h₂ : 0 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; 0), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt b a = true&#10;eq : (a == b) = true&#10;⊢ False" state_after="no goals" tactic="simp [lt_irrefl _ _ (BEq.symm eq)] at w₂">
                                                            <AtomNode start="(438, 13)" end="(438, 17)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(438, 18)" end="(438, 47)">
                                                            <AtomNode start="(438, 18)" end="(438, 19)" leading="" trailing="" val="["/>
                                                            <NullNode start="(438, 19)" end="(438, 46)">
                                                            <OtherNode start="(438, 19)" end="(438, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(438, 19)" end="(438, 46)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(438, 19)" end="(438, 28)" leading="" trailing=" " raw_val="lt_irrefl" val="lt_irrefl"/>
                                                            <NullNode start="(438, 29)" end="(438, 46)">
                                                            <TermHoleNode start="(438, 29)" end="(438, 30)">
                                                            <AtomNode start="(438, 29)" end="(438, 30)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(438, 31)" end="(438, 32)">
                                                            <AtomNode start="(438, 31)" end="(438, 32)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(438, 33)" end="(438, 46)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(438, 33)" end="(438, 34)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(438, 34)" end="(438, 45)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(438, 34)" end="(438, 42)" leading="" trailing=" " raw_val="BEq.symm" val="BEq.symm" full_name="BEq.symm" mod_name="Init.Data.BEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BEq.lean"/>
                                                            <NullNode start="(438, 43)" end="(438, 45)">
                                                            <IdentNode start="(438, 43)" end="(438, 45)" leading="" trailing="" raw_val="eq" val="eq"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(438, 45)" end="(438, 46)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(438, 46)" end="(438, 47)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(438, 48)" end="(438, 53)">
                                                            <OtherNode start="(438, 48)" end="(438, 53)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(438, 48)" end="(438, 50)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(438, 51)" end="(438, 53)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(438, 51)" end="(438, 53)">
                                                            <IdentNode start="(438, 51)" end="(438, 53)" leading="" trailing="&#10;          " raw_val="w₂" val="w₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <OtherNode start="(439, 11)" end="(444, 29)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(439, 11)" end="(439, 19)">
                                                            <OtherNode start="(439, 11)" end="(439, 19)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(439, 11)" end="(439, 12)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(439, 13)" end="(439, 17)">
                                                            <NullNode/>
                                                            <IdentNode start="(439, 13)" end="(439, 17)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                            </GroupNode>
                                                            <NullNode start="(439, 18)" end="(439, 19)">
                                                            <IdentNode start="(439, 18)" end="(439, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(439, 20)" end="(444, 29)">
                                                            <AtomNode start="(439, 20)" end="(439, 22)" leading="" trailing="&#10;            " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(440, 13)" end="(444, 29)">
                                                            <TacticTacticseq1IndentedNode start="(440, 13)" end="(444, 29)">
                                                            <NullNode start="(440, 13)" end="(444, 29)">
                                                            <OtherNode start="(440, 13)" end="(440, 71)" kind="Lean.Parser.Tactic.refine" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;⊢ lt a b = false ∧&#10;    ((a == b) = true →&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true)" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.succ&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;⊢ (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true" tactic="refine ⟨lt_irrefl _ _ (by simpa using w₁ 0 (by simp)), ?_⟩">
                                                            <AtomNode start="(440, 13)" end="(440, 19)" leading="" trailing=" " val="refine"/>
                                                            <OtherNode start="(440, 20)" end="(440, 71)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(440, 20)" end="(440, 21)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(440, 21)" end="(440, 70)">
                                                            <OtherNode start="(440, 21)" end="(440, 66)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(440, 21)" end="(440, 30)" leading="" trailing=" " raw_val="lt_irrefl" val="lt_irrefl"/>
                                                            <NullNode start="(440, 31)" end="(440, 66)">
                                                            <TermHoleNode start="(440, 31)" end="(440, 32)">
                                                            <AtomNode start="(440, 31)" end="(440, 32)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(440, 33)" end="(440, 34)">
                                                            <AtomNode start="(440, 33)" end="(440, 34)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(440, 35)" end="(440, 66)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(440, 35)" end="(440, 36)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(440, 36)" end="(440, 65)">
                                                            <AtomNode start="(440, 36)" end="(440, 38)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(440, 39)" end="(440, 65)">
                                                            <TacticTacticseq1IndentedNode start="(440, 39)" end="(440, 65)">
                                                            <NullNode start="(440, 39)" end="(440, 65)">
                                                            <OtherNode start="(440, 39)" end="(440, 65)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;⊢ (a == b) = true" state_after="no goals" tactic="simpa using w₁ 0 (by simp)">
                                                            <AtomNode start="(440, 39)" end="(440, 44)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(440, 45)" end="(440, 65)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(440, 45)" end="(440, 65)">
                                                            <AtomNode start="(440, 45)" end="(440, 50)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(440, 51)" end="(440, 65)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(440, 51)" end="(440, 53)" leading="" trailing=" " raw_val="w₁" val="w₁"/>
                                                            <NullNode start="(440, 54)" end="(440, 65)">
                                                            <OtherNode start="(440, 54)" end="(440, 55)" kind="num">
                                                            <AtomNode start="(440, 54)" end="(440, 55)" leading="" trailing=" " val="0"/>
                                                            </OtherNode>
                                                            <OtherNode start="(440, 56)" end="(440, 65)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(440, 56)" end="(440, 57)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(440, 57)" end="(440, 64)">
                                                            <AtomNode start="(440, 57)" end="(440, 59)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(440, 60)" end="(440, 64)">
                                                            <TacticTacticseq1IndentedNode start="(440, 60)" end="(440, 64)">
                                                            <NullNode start="(440, 60)" end="(440, 64)">
                                                            <OtherNode start="(440, 60)" end="(440, 64)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;⊢ 0 &amp;lt; i + 1" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(440, 60)" end="(440, 64)" leading="" trailing="" val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(440, 64)" end="(440, 65)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(440, 65)" end="(440, 66)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(440, 66)" end="(440, 67)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(440, 68)" end="(440, 70)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(440, 68)" end="(440, 69)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(440, 69)" end="(440, 70)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(440, 70)" end="(440, 71)" leading="" trailing="&#10;            " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(441, 13)" end="(441, 83)" kind="Lean.Parser.Tactic.refine" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;⊢ (a == b) = true →&#10;    (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.refine_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;x✝ : (a == b) = true&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;&#10;case cons.cons.mpr.inr.intro.intro.intro.intro.succ.refine_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;x✝ : (a == b) = true&#10;⊢ lt l₂[i] l₁[i] = true" tactic="refine fun _ =&amp;gt; .inr ⟨i, by simpa using h₁, by simpa using h₂, ?_, ?_⟩">
                                                            <AtomNode start="(441, 13)" end="(441, 19)" leading="" trailing=" " val="refine"/>
                                                            <OtherNode start="(441, 20)" end="(441, 83)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(441, 20)" end="(441, 23)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(441, 24)" end="(441, 83)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(441, 24)" end="(441, 25)">
                                                            <TermHoleNode start="(441, 24)" end="(441, 25)">
                                                            <AtomNode start="(441, 24)" end="(441, 25)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(441, 26)" end="(441, 28)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(441, 29)" end="(441, 83)" kind="Lean.Parser.Term.app">
                                                            <OtherNode start="(441, 29)" end="(441, 33)" kind="Lean.Parser.Term.dotIdent">
                                                            <AtomNode start="(441, 29)" end="(441, 30)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(441, 30)" end="(441, 33)" leading="" trailing=" " raw_val="inr" val="inr"/>
                                                            </OtherNode>
                                                            <NullNode start="(441, 34)" end="(441, 83)">
                                                            <OtherNode start="(441, 34)" end="(441, 83)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(441, 34)" end="(441, 35)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(441, 35)" end="(441, 82)">
                                                            <IdentNode start="(441, 35)" end="(441, 36)" leading="" trailing="" raw_val="i" val="i"/>
                                                            <AtomNode start="(441, 36)" end="(441, 37)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(441, 38)" end="(441, 55)">
                                                            <AtomNode start="(441, 38)" end="(441, 40)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(441, 41)" end="(441, 55)">
                                                            <TacticTacticseq1IndentedNode start="(441, 41)" end="(441, 55)">
                                                            <NullNode start="(441, 41)" end="(441, 55)">
                                                            <OtherNode start="(441, 41)" end="(441, 55)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;x✝ : (a == b) = true&#10;⊢ i &amp;lt; l₁.length" state_after="no goals" tactic="simpa using h₁">
                                                            <AtomNode start="(441, 41)" end="(441, 46)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(441, 47)" end="(441, 55)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(441, 47)" end="(441, 55)">
                                                            <AtomNode start="(441, 47)" end="(441, 52)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(441, 53)" end="(441, 55)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(441, 55)" end="(441, 56)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(441, 57)" end="(441, 74)">
                                                            <AtomNode start="(441, 57)" end="(441, 59)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(441, 60)" end="(441, 74)">
                                                            <TacticTacticseq1IndentedNode start="(441, 60)" end="(441, 74)">
                                                            <NullNode start="(441, 60)" end="(441, 74)">
                                                            <OtherNode start="(441, 60)" end="(441, 74)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;x✝ : (a == b) = true&#10;⊢ i &amp;lt; l₂.length" state_after="no goals" tactic="simpa using h₂">
                                                            <AtomNode start="(441, 60)" end="(441, 65)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(441, 66)" end="(441, 74)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(441, 66)" end="(441, 74)">
                                                            <AtomNode start="(441, 66)" end="(441, 71)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(441, 72)" end="(441, 74)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(441, 74)" end="(441, 75)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(441, 76)" end="(441, 78)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(441, 76)" end="(441, 77)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(441, 77)" end="(441, 78)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            <AtomNode start="(441, 78)" end="(441, 79)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(441, 80)" end="(441, 82)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(441, 80)" end="(441, 81)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(441, 81)" end="(441, 82)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(441, 82)" end="(441, 83)" leading="" trailing="&#10;            " val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(442, 13)" end="(443, 48)" kind="Lean.cdot" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.refine_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;x✝ : (a == b) = true&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true&#10;&#10;case cons.cons.mpr.inr.intro.intro.intro.intro.succ.refine_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;x✝ : (a == b) = true&#10;⊢ lt l₂[i] l₁[i] = true" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.refine_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;x✝ : (a == b) = true&#10;⊢ lt l₂[i] l₁[i] = true" tactic="· intro j hj&#10;  simpa using w₁ (j + 1) (by simpa)">
                                                            <OtherNode start="(442, 13)" end="(442, 14)" kind="Lean.cdotTk">
                                                            <OtherNode start="(442, 13)" end="(442, 14)" kind="patternIgnore">
                                                            <OtherNode start="(442, 13)" end="(442, 14)" kind="token.«· »">
                                                            <AtomNode start="(442, 13)" end="(442, 14)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(442, 15)" end="(443, 48)">
                                                            <TacticTacticseq1IndentedNode start="(442, 15)" end="(443, 48)">
                                                            <NullNode start="(442, 15)" end="(443, 48)">
                                                            <OtherNode start="(442, 15)" end="(442, 25)" kind="Lean.Parser.Tactic.intro" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.refine_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;x✝ : (a == b) = true&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true" state_after="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.refine_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;x✝ : (a == b) = true&#10;j : Nat&#10;hj : j &amp;lt; i&#10;⊢ (l₁[j] == l₂[j]) = true" tactic="intro j hj">
                                                            <AtomNode start="(442, 15)" end="(442, 20)" leading="" trailing=" " val="intro"/>
                                                            <NullNode start="(442, 21)" end="(442, 25)">
                                                            <IdentNode start="(442, 21)" end="(442, 22)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            <IdentNode start="(442, 23)" end="(442, 25)" leading="" trailing="&#10;              " raw_val="hj" val="hj"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(443, 15)" end="(443, 48)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.refine_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;x✝ : (a == b) = true&#10;j : Nat&#10;hj : j &amp;lt; i&#10;⊢ (l₁[j] == l₂[j]) = true" state_after="no goals" tactic="simpa using w₁ (j + 1) (by simpa)">
                                                            <AtomNode start="(443, 15)" end="(443, 20)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(443, 21)" end="(443, 48)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(443, 21)" end="(443, 48)">
                                                            <AtomNode start="(443, 21)" end="(443, 26)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(443, 27)" end="(443, 48)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(443, 27)" end="(443, 29)" leading="" trailing=" " raw_val="w₁" val="w₁"/>
                                                            <NullNode start="(443, 30)" end="(443, 48)">
                                                            <OtherNode start="(443, 30)" end="(443, 37)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(443, 30)" end="(443, 31)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(443, 31)" end="(443, 36)" kind="«term_+_»">
                                                            <IdentNode start="(443, 31)" end="(443, 32)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            <AtomNode start="(443, 33)" end="(443, 34)" leading="" trailing=" " val="+"/>
                                                            <OtherNode start="(443, 35)" end="(443, 36)" kind="num">
                                                            <AtomNode start="(443, 35)" end="(443, 36)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(443, 36)" end="(443, 37)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <OtherNode start="(443, 38)" end="(443, 48)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(443, 38)" end="(443, 39)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(443, 39)" end="(443, 47)">
                                                            <AtomNode start="(443, 39)" end="(443, 41)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(443, 42)" end="(443, 47)">
                                                            <TacticTacticseq1IndentedNode start="(443, 42)" end="(443, 47)">
                                                            <NullNode start="(443, 42)" end="(443, 47)">
                                                            <OtherNode start="(443, 42)" end="(443, 47)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;x✝ : (a == b) = true&#10;j : Nat&#10;hj : j &amp;lt; i&#10;⊢ j + 1 &amp;lt; i + 1" state_after="no goals" tactic="simpa">
                                                            <AtomNode start="(443, 42)" end="(443, 47)" leading="" trailing="" val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(443, 47)" end="(443, 48)" leading="" trailing="&#10;            " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(444, 13)" end="(444, 29)" kind="Lean.cdot" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.refine_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;x✝ : (a == b) = true&#10;⊢ lt l₂[i] l₁[i] = true" state_after="no goals" tactic="· simpa using w₂">
                                                            <OtherNode start="(444, 13)" end="(444, 14)" kind="Lean.cdotTk">
                                                            <OtherNode start="(444, 13)" end="(444, 14)" kind="patternIgnore">
                                                            <OtherNode start="(444, 13)" end="(444, 14)" kind="token.«· »">
                                                            <AtomNode start="(444, 13)" end="(444, 14)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(444, 15)" end="(444, 29)">
                                                            <TacticTacticseq1IndentedNode start="(444, 15)" end="(444, 29)">
                                                            <NullNode start="(444, 15)" end="(444, 29)">
                                                            <OtherNode start="(444, 15)" end="(444, 29)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.cons.mpr.inr.intro.intro.intro.intro.succ.refine_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : PartialEquivBEq α&#10;lt : α → α → Bool&#10;lt_irrefl : ∀ (x y : α), (x == y) = true → lt x y = false&#10;lt_asymm : ∀ (x y : α), lt x y = true → lt y x = false&#10;lt_antisymm : ∀ (x y : α), lt x y = false → lt y x = false → (x == y) = true&#10;a : α&#10;l₁ : List α&#10;ih :&#10;  ∀ {l₂ : List α},&#10;    l₁.lex l₂ lt = false ↔&#10;      (l₂.isEqv (take l₂.length l₁) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;        ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ lt l₂[i] l₁[i] = true&#10;b : α&#10;l₂ : List α&#10;i : Nat&#10;h₁ : i + 1 &amp;lt; l₁.length + 1&#10;h₂ : i + 1 &amp;lt; l₂.length + 1&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i + 1), ((a :: l₁)[j] == (b :: l₂)[j]) = true&#10;w₂ : lt (b :: l₂)[i + 1] (a :: l₁)[i + 1] = true&#10;x✝ : (a == b) = true&#10;⊢ lt l₂[i] l₁[i] = true" state_after="no goals" tactic="simpa using w₂">
                                                            <AtomNode start="(444, 15)" end="(444, 20)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(444, 21)" end="(444, 29)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(444, 21)" end="(444, 29)">
                                                            <AtomNode start="(444, 21)" end="(444, 26)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(444, 27)" end="(444, 29)" leading="" trailing="&#10;&#10;" raw_val="w₂" val="w₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </NullNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </NullNode>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                </TacticTacticseq1IndentedNode>
              </TacticTacticseqNode>
            </TermBytacticNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </CommandDeclvalsimpleNode>
        </CommandTheoremNode>
      </CommandDeclarationNode>
    </OtherNode>
    <CommandDeclarationNode start="(446, 1)" end="(453, 7)" name="lt_iff_exists" full_name="List.lt_iff_exists">
      <CommandDeclmodifiersNode start="(446, 1)" end="(446, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(446, 1)" end="(446, 10)">
          <OtherNode start="(446, 1)" end="(446, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(446, 1)" end="(446, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(446, 11)" end="(453, 7)" name="lt_iff_exists" full_name="List.lt_iff_exists" _is_private_decl="False">
        <AtomNode start="(446, 11)" end="(446, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(446, 19)" end="(446, 32)">
          <IdentNode start="(446, 19)" end="(446, 32)" leading="" trailing=" " raw_val="lt_iff_exists" val="lt_iff_exists"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(446, 33)" end="(451, 86)">
          <NullNode start="(446, 33)" end="(446, 88)">
            <OtherNode start="(446, 33)" end="(446, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(446, 33)" end="(446, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(446, 34)" end="(446, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(446, 34)" end="(446, 45)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(446, 46)" end="(446, 47)">
                  <IdentNode start="(446, 46)" end="(446, 47)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(446, 47)" end="(446, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(446, 49)" end="(446, 55)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(446, 49)" end="(446, 50)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(446, 50)" end="(446, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(446, 50)" end="(446, 52)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(446, 53)" end="(446, 54)">
                  <IdentNode start="(446, 53)" end="(446, 54)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(446, 54)" end="(446, 55)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(446, 56)" end="(446, 71)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(446, 56)" end="(446, 57)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(446, 57)" end="(446, 70)" kind="Lean.Parser.Term.app">
                <IdentNode start="(446, 57)" end="(446, 68)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(446, 69)" end="(446, 70)">
                  <IdentNode start="(446, 69)" end="(446, 70)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(446, 70)" end="(446, 71)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(446, 72)" end="(446, 88)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(446, 72)" end="(446, 73)" leading="" trailing="" val="{"/>
              <NullNode start="(446, 73)" end="(446, 78)">
                <IdentNode start="(446, 73)" end="(446, 75)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(446, 76)" end="(446, 78)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(446, 79)" end="(446, 87)">
                <AtomNode start="(446, 79)" end="(446, 80)" leading="" trailing=" " val=":"/>
                <OtherNode start="(446, 81)" end="(446, 87)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(446, 81)" end="(446, 85)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(446, 86)" end="(446, 87)">
                    <IdentNode start="(446, 86)" end="(446, 87)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(446, 87)" end="(446, 88)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(446, 89)" end="(451, 86)">
            <AtomNode start="(446, 89)" end="(446, 90)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(447, 5)" end="(451, 86)" kind="«term_↔_»">
              <OtherNode start="(447, 5)" end="(447, 12)" kind="«term_&amp;lt;_»">
                <IdentNode start="(447, 5)" end="(447, 7)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(447, 8)" end="(447, 9)" leading="" trailing=" " val="&amp;lt;"/>
                <IdentNode start="(447, 10)" end="(447, 12)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
              <AtomNode start="(447, 13)" end="(447, 14)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(448, 7)" end="(451, 86)" kind="«term_∨_»">
                <OtherNode start="(448, 7)" end="(448, 55)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(448, 7)" end="(448, 8)" leading="" trailing="" val="("/>
                  <OtherNode start="(448, 8)" end="(448, 54)" kind="«term_∧_»">
                    <OtherNode start="(448, 8)" end="(448, 30)" kind="«term_=_»">
                      <IdentNode start="(448, 8)" end="(448, 10)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(448, 11)" end="(448, 12)" leading="" trailing=" " val="="/>
                      <OtherNode start="(448, 13)" end="(448, 30)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(448, 13)" end="(448, 20)" leading="" trailing=" " raw_val="l₂.take" val="l₂.take"/>
                        <NullNode start="(448, 21)" end="(448, 30)">
                          <IdentNode start="(448, 21)" end="(448, 30)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(448, 31)" end="(448, 32)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(448, 33)" end="(448, 54)" kind="«term_&amp;lt;_»">
                      <IdentNode start="(448, 33)" end="(448, 42)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                      <AtomNode start="(448, 43)" end="(448, 44)" leading="" trailing=" " val="&amp;lt;"/>
                      <IdentNode start="(448, 45)" end="(448, 54)" leading="" trailing="" raw_val="l₂.length" val="l₂.length"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(448, 54)" end="(448, 55)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(448, 56)" end="(448, 57)" leading="" trailing="&#10;        " val="∨"/>
                <OtherNode start="(449, 9)" end="(451, 86)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(449, 9)" end="(449, 10)" leading="" trailing="" val="("/>
                  <OtherNode start="(449, 10)" end="(451, 85)" kind="«term∃_,_»">
                    <AtomNode start="(449, 10)" end="(449, 11)" leading="" trailing=" " val="∃"/>
                    <OtherNode start="(449, 12)" end="(449, 63)" kind="Lean.explicitBinders">
                      <NullNode start="(449, 12)" end="(449, 63)">
                        <OtherNode start="(449, 12)" end="(449, 21)" kind="Lean.bracketedExplicitBinders">
                          <AtomNode start="(449, 12)" end="(449, 13)" leading="" trailing="" val="("/>
                          <NullNode start="(449, 13)" end="(449, 14)">
                            <LeanBinderidentNode start="(449, 13)" end="(449, 14)">
                              <IdentNode start="(449, 13)" end="(449, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                            </LeanBinderidentNode>
                          </NullNode>
                          <AtomNode start="(449, 15)" end="(449, 16)" leading="" trailing=" " val=":"/>
                          <IdentNode start="(449, 17)" end="(449, 20)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <AtomNode start="(449, 20)" end="(449, 21)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <OtherNode start="(449, 22)" end="(449, 42)" kind="Lean.bracketedExplicitBinders">
                          <AtomNode start="(449, 22)" end="(449, 23)" leading="" trailing="" val="("/>
                          <NullNode start="(449, 23)" end="(449, 25)">
                            <LeanBinderidentNode start="(449, 23)" end="(449, 25)">
                              <IdentNode start="(449, 23)" end="(449, 25)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                            </LeanBinderidentNode>
                          </NullNode>
                          <AtomNode start="(449, 26)" end="(449, 27)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(449, 28)" end="(449, 41)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(449, 28)" end="(449, 29)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(449, 30)" end="(449, 31)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(449, 32)" end="(449, 41)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                          </OtherNode>
                          <AtomNode start="(449, 41)" end="(449, 42)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <OtherNode start="(449, 43)" end="(449, 63)" kind="Lean.bracketedExplicitBinders">
                          <AtomNode start="(449, 43)" end="(449, 44)" leading="" trailing="" val="("/>
                          <NullNode start="(449, 44)" end="(449, 46)">
                            <LeanBinderidentNode start="(449, 44)" end="(449, 46)">
                              <IdentNode start="(449, 44)" end="(449, 46)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                            </LeanBinderidentNode>
                          </NullNode>
                          <AtomNode start="(449, 47)" end="(449, 48)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(449, 49)" end="(449, 62)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(449, 49)" end="(449, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(449, 51)" end="(449, 52)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(449, 53)" end="(449, 62)" leading="" trailing="" raw_val="l₂.length" val="l₂.length"/>
                          </OtherNode>
                          <AtomNode start="(449, 62)" end="(449, 63)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(449, 63)" end="(449, 64)" leading="" trailing="&#10;          " val=","/>
                    <OtherNode start="(450, 11)" end="(451, 85)" kind="«term_∧_»">
                      <OtherNode start="(450, 11)" end="(451, 69)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(450, 11)" end="(450, 12)" leading="" trailing="" val="("/>
                        <OtherNode start="(450, 12)" end="(451, 68)" kind="Lean.Parser.Term.forall">
                          <AtomNode start="(450, 12)" end="(450, 13)" leading="" trailing=" " val="∀"/>
                          <NullNode start="(450, 14)" end="(450, 15)">
                            <IdentNode start="(450, 14)" end="(450, 15)" leading="" trailing="" raw_val="j" val="j"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(450, 15)" end="(450, 16)" leading="" trailing=" " val=","/>
                          <OtherNode start="(450, 17)" end="(451, 68)" kind="Lean.Parser.Term.depArrow">
                            <TermExplicitbinderNode start="(450, 17)" end="(450, 29)">
                              <AtomNode start="(450, 17)" end="(450, 18)" leading="" trailing="" val="("/>
                              <NullNode start="(450, 18)" end="(450, 20)">
                                <IdentNode start="(450, 18)" end="(450, 20)" leading="" trailing=" " raw_val="hj" val="hj"/>
                              </NullNode>
                              <NullNode start="(450, 21)" end="(450, 28)">
                                <AtomNode start="(450, 21)" end="(450, 22)" leading="" trailing=" " val=":"/>
                                <OtherNode start="(450, 23)" end="(450, 28)" kind="«term_&amp;lt;_»">
                                  <IdentNode start="(450, 23)" end="(450, 24)" leading="" trailing=" " raw_val="j" val="j"/>
                                  <AtomNode start="(450, 25)" end="(450, 26)" leading="" trailing=" " val="&amp;lt;"/>
                                  <IdentNode start="(450, 27)" end="(450, 28)" leading="" trailing="" raw_val="i" val="i"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(450, 28)" end="(450, 29)" leading="" trailing=" " val=")"/>
                            </TermExplicitbinderNode>
                            <AtomNode start="(450, 30)" end="(450, 31)" leading="" trailing="&#10;            " val="→"/>
                            <OtherNode start="(451, 13)" end="(451, 68)" kind="«term_=_»">
                              <OtherNode start="(451, 13)" end="(451, 39)" kind="«term__[_]'_»">
                                <IdentNode start="(451, 13)" end="(451, 15)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                <AtomNode start="(451, 15)" end="(451, 16)" leading="" trailing="" val="["/>
                                <IdentNode start="(451, 16)" end="(451, 17)" leading="" trailing="" raw_val="j" val="j"/>
                                <AtomNode start="(451, 17)" end="(451, 19)" leading="" trailing="" val="]'"/>
                                <OtherNode start="(451, 19)" end="(451, 39)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(451, 19)" end="(451, 20)" leading="" trailing="" val="("/>
                                  <OtherNode start="(451, 20)" end="(451, 38)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(451, 20)" end="(451, 32)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(451, 33)" end="(451, 38)">
                                      <IdentNode start="(451, 33)" end="(451, 35)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                      <IdentNode start="(451, 36)" end="(451, 38)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(451, 38)" end="(451, 39)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(451, 40)" end="(451, 41)" leading="" trailing=" " val="="/>
                              <OtherNode start="(451, 42)" end="(451, 68)" kind="«term__[_]'_»">
                                <IdentNode start="(451, 42)" end="(451, 44)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                <AtomNode start="(451, 44)" end="(451, 45)" leading="" trailing="" val="["/>
                                <IdentNode start="(451, 45)" end="(451, 46)" leading="" trailing="" raw_val="j" val="j"/>
                                <AtomNode start="(451, 46)" end="(451, 48)" leading="" trailing="" val="]'"/>
                                <OtherNode start="(451, 48)" end="(451, 68)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(451, 48)" end="(451, 49)" leading="" trailing="" val="("/>
                                  <OtherNode start="(451, 49)" end="(451, 67)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(451, 49)" end="(451, 61)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(451, 62)" end="(451, 67)">
                                      <IdentNode start="(451, 62)" end="(451, 64)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                      <IdentNode start="(451, 65)" end="(451, 67)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(451, 67)" end="(451, 68)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(451, 68)" end="(451, 69)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <AtomNode start="(451, 70)" end="(451, 71)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(451, 72)" end="(451, 85)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(451, 72)" end="(451, 77)" kind="«term__[_]»">
                          <IdentNode start="(451, 72)" end="(451, 74)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                          <AtomNode start="(451, 74)" end="(451, 75)" leading="" trailing="" val="["/>
                          <IdentNode start="(451, 75)" end="(451, 76)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(451, 76)" end="(451, 77)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                        <AtomNode start="(451, 78)" end="(451, 79)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(451, 80)" end="(451, 85)" kind="«term__[_]»">
                          <IdentNode start="(451, 80)" end="(451, 82)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                          <AtomNode start="(451, 82)" end="(451, 83)" leading="" trailing="" val="["/>
                          <IdentNode start="(451, 83)" end="(451, 84)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(451, 84)" end="(451, 85)" leading="" trailing="" val="]"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(451, 85)" end="(451, 86)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(451, 87)" end="(453, 7)">
          <AtomNode start="(451, 87)" end="(451, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(451, 90)" end="(453, 7)">
            <AtomNode start="(451, 90)" end="(451, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(452, 3)" end="(453, 7)">
              <TacticTacticseq1IndentedNode start="(452, 3)" end="(453, 7)">
                <NullNode start="(452, 3)" end="(453, 7)">
                  <OtherNode start="(452, 3)" end="(452, 52)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;l₁ l₂ : List α&#10;⊢ l₁ &amp;lt; l₂ ↔&#10;    l₁ = take l₁.length l₂ ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]" state_after="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;l₁ l₂ : List α&#10;⊢ ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ decide (l₁[i] &amp;lt; l₂[i]) = true) ↔&#10;    l₁ = take l₁.length l₂ ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]" tactic="rw [← lex_eq_true_iff_lt, lex_eq_true_iff_exists]">
                    <AtomNode start="(452, 3)" end="(452, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(452, 6)" end="(452, 52)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(452, 6)" end="(452, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(452, 7)" end="(452, 51)">
                        <OtherNode start="(452, 7)" end="(452, 27)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(452, 7)" end="(452, 8)">
                            <OtherNode start="(452, 7)" end="(452, 8)" kind="patternIgnore">
                              <OtherNode start="(452, 7)" end="(452, 8)" kind="token.«← »">
                                <AtomNode start="(452, 7)" end="(452, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(452, 9)" end="(452, 27)" leading="" trailing="" raw_val="lex_eq_true_iff_lt" val="lex_eq_true_iff_lt" full_name="List.lex_eq_true_iff_lt" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(310, 17)" def_end="(310, 35)"/>
                        </OtherNode>
                        <AtomNode start="(452, 27)" end="(452, 28)" leading="" trailing=" " val=","/>
                        <OtherNode start="(452, 29)" end="(452, 51)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(452, 29)" end="(452, 51)" leading="" trailing="" raw_val="lex_eq_true_iff_exists" val="lex_eq_true_iff_exists" full_name="List.lex_eq_true_iff_exists" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(329, 9)" def_end="(329, 31)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(452, 51)" end="(452, 52)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(453, 3)" end="(453, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝² : DecidableEq α&#10;inst✝¹ : LT α&#10;inst✝ : DecidableLT α&#10;l₁ l₂ : List α&#10;⊢ ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₁[j] == l₂[j]) = true) ∧ decide (l₁[i] &amp;lt; l₂[i]) = true) ↔&#10;    l₁ = take l₁.length l₂ ∧ l₁.length &amp;lt; l₂.length ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]" state_after="no goals" tactic="simp">
                    <AtomNode start="(453, 3)" end="(453, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(455, 1)" end="(470, 38)" name="le_iff_exists" full_name="List.le_iff_exists">
      <CommandDeclmodifiersNode start="(455, 1)" end="(455, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(455, 1)" end="(455, 10)">
          <OtherNode start="(455, 1)" end="(455, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(455, 1)" end="(455, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(455, 11)" end="(470, 38)" name="le_iff_exists" full_name="List.le_iff_exists" _is_private_decl="False">
        <AtomNode start="(455, 11)" end="(455, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(455, 19)" end="(455, 32)">
          <IdentNode start="(455, 19)" end="(455, 32)" leading="" trailing=" " raw_val="le_iff_exists" val="le_iff_exists"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(455, 33)" end="(463, 86)">
          <NullNode start="(455, 33)" end="(458, 61)">
            <OtherNode start="(455, 33)" end="(455, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(455, 33)" end="(455, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(455, 34)" end="(455, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(455, 34)" end="(455, 45)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(455, 46)" end="(455, 47)">
                  <IdentNode start="(455, 46)" end="(455, 47)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(455, 47)" end="(455, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(455, 49)" end="(455, 55)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(455, 49)" end="(455, 50)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(455, 50)" end="(455, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(455, 50)" end="(455, 52)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(455, 53)" end="(455, 54)">
                  <IdentNode start="(455, 53)" end="(455, 54)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(455, 54)" end="(455, 55)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(455, 56)" end="(455, 71)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(455, 56)" end="(455, 57)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(455, 57)" end="(455, 70)" kind="Lean.Parser.Term.app">
                <IdentNode start="(455, 57)" end="(455, 68)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(455, 69)" end="(455, 70)">
                  <IdentNode start="(455, 69)" end="(455, 70)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(455, 70)" end="(455, 71)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(456, 5)" end="(456, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(456, 5)" end="(456, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(456, 6)" end="(456, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(456, 6)" end="(456, 16)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(456, 17)" end="(456, 39)">
                  <OtherNode start="(456, 17)" end="(456, 39)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(456, 17)" end="(456, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(456, 18)" end="(456, 23)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(456, 18)" end="(456, 19)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(456, 18)" end="(456, 19)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(456, 20)" end="(456, 21)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(456, 22)" end="(456, 23)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(456, 22)" end="(456, 23)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(456, 24)" end="(456, 25)" leading="" trailing=" " val=":"/>
                    <NullNode start="(456, 26)" end="(456, 38)">
                      <OtherNode start="(456, 26)" end="(456, 38)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(456, 26)" end="(456, 27)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(456, 28)" end="(456, 29)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(456, 30)" end="(456, 38)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(456, 30)" end="(456, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(456, 32)" end="(456, 33)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(456, 34)" end="(456, 38)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(456, 34)" end="(456, 38)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(456, 38)" end="(456, 39)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(456, 39)" end="(456, 40)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(457, 5)" end="(457, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(457, 5)" end="(457, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(457, 6)" end="(457, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(457, 6)" end="(457, 15)" leading="" trailing=" " raw_val="Std.Asymm" val="Std.Asymm" full_name="Std.Asymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(457, 16)" end="(457, 38)">
                  <OtherNode start="(457, 16)" end="(457, 38)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(457, 16)" end="(457, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(457, 17)" end="(457, 22)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(457, 17)" end="(457, 18)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(457, 17)" end="(457, 18)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(457, 19)" end="(457, 20)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(457, 21)" end="(457, 22)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(457, 21)" end="(457, 22)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(457, 23)" end="(457, 24)" leading="" trailing=" " val=":"/>
                    <NullNode start="(457, 25)" end="(457, 37)">
                      <OtherNode start="(457, 25)" end="(457, 37)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(457, 25)" end="(457, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(457, 27)" end="(457, 28)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(457, 29)" end="(457, 37)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(457, 29)" end="(457, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(457, 31)" end="(457, 32)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(457, 33)" end="(457, 37)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(457, 33)" end="(457, 37)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(457, 37)" end="(457, 38)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(457, 38)" end="(457, 39)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(458, 5)" end="(458, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(458, 5)" end="(458, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(458, 6)" end="(458, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(458, 6)" end="(458, 18)" leading="" trailing=" " raw_val="Std.Antisymm" val="Std.Antisymm" full_name="Std.Antisymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(458, 19)" end="(458, 43)">
                  <OtherNode start="(458, 19)" end="(458, 43)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(458, 19)" end="(458, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(458, 20)" end="(458, 27)" kind="«term¬_»">
                      <AtomNode start="(458, 20)" end="(458, 21)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(458, 22)" end="(458, 27)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(458, 22)" end="(458, 23)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(458, 22)" end="(458, 23)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(458, 24)" end="(458, 25)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(458, 26)" end="(458, 27)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(458, 26)" end="(458, 27)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(458, 28)" end="(458, 29)" leading="" trailing=" " val=":"/>
                    <NullNode start="(458, 30)" end="(458, 42)">
                      <OtherNode start="(458, 30)" end="(458, 42)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(458, 30)" end="(458, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(458, 32)" end="(458, 33)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(458, 34)" end="(458, 42)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(458, 34)" end="(458, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(458, 36)" end="(458, 37)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(458, 38)" end="(458, 42)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(458, 38)" end="(458, 42)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(458, 42)" end="(458, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(458, 43)" end="(458, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(458, 45)" end="(458, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(458, 45)" end="(458, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(458, 46)" end="(458, 51)">
                <IdentNode start="(458, 46)" end="(458, 48)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(458, 49)" end="(458, 51)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(458, 52)" end="(458, 60)">
                <AtomNode start="(458, 52)" end="(458, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(458, 54)" end="(458, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(458, 54)" end="(458, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(458, 59)" end="(458, 60)">
                    <IdentNode start="(458, 59)" end="(458, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(458, 60)" end="(458, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(458, 62)" end="(463, 86)">
            <AtomNode start="(458, 62)" end="(458, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(459, 5)" end="(463, 86)" kind="«term_↔_»">
              <OtherNode start="(459, 5)" end="(459, 12)" kind="«term_≤_»">
                <IdentNode start="(459, 5)" end="(459, 7)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(459, 8)" end="(459, 9)" leading="" trailing=" " val="≤"/>
                <IdentNode start="(459, 10)" end="(459, 12)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
              <AtomNode start="(459, 13)" end="(459, 14)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(460, 7)" end="(463, 86)" kind="«term_∨_»">
                <OtherNode start="(460, 7)" end="(460, 31)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(460, 7)" end="(460, 8)" leading="" trailing="" val="("/>
                  <OtherNode start="(460, 8)" end="(460, 30)" kind="«term_=_»">
                    <IdentNode start="(460, 8)" end="(460, 10)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <AtomNode start="(460, 11)" end="(460, 12)" leading="" trailing=" " val="="/>
                    <OtherNode start="(460, 13)" end="(460, 30)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(460, 13)" end="(460, 20)" leading="" trailing=" " raw_val="l₂.take" val="l₂.take"/>
                      <NullNode start="(460, 21)" end="(460, 30)">
                        <IdentNode start="(460, 21)" end="(460, 30)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(460, 30)" end="(460, 31)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(460, 32)" end="(460, 33)" leading="" trailing="&#10;        " val="∨"/>
                <OtherNode start="(461, 9)" end="(463, 86)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(461, 9)" end="(461, 10)" leading="" trailing="" val="("/>
                  <OtherNode start="(461, 10)" end="(463, 85)" kind="«term∃_,_»">
                    <AtomNode start="(461, 10)" end="(461, 11)" leading="" trailing=" " val="∃"/>
                    <OtherNode start="(461, 12)" end="(461, 63)" kind="Lean.explicitBinders">
                      <NullNode start="(461, 12)" end="(461, 63)">
                        <OtherNode start="(461, 12)" end="(461, 21)" kind="Lean.bracketedExplicitBinders">
                          <AtomNode start="(461, 12)" end="(461, 13)" leading="" trailing="" val="("/>
                          <NullNode start="(461, 13)" end="(461, 14)">
                            <LeanBinderidentNode start="(461, 13)" end="(461, 14)">
                              <IdentNode start="(461, 13)" end="(461, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                            </LeanBinderidentNode>
                          </NullNode>
                          <AtomNode start="(461, 15)" end="(461, 16)" leading="" trailing=" " val=":"/>
                          <IdentNode start="(461, 17)" end="(461, 20)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <AtomNode start="(461, 20)" end="(461, 21)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <OtherNode start="(461, 22)" end="(461, 42)" kind="Lean.bracketedExplicitBinders">
                          <AtomNode start="(461, 22)" end="(461, 23)" leading="" trailing="" val="("/>
                          <NullNode start="(461, 23)" end="(461, 25)">
                            <LeanBinderidentNode start="(461, 23)" end="(461, 25)">
                              <IdentNode start="(461, 23)" end="(461, 25)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                            </LeanBinderidentNode>
                          </NullNode>
                          <AtomNode start="(461, 26)" end="(461, 27)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(461, 28)" end="(461, 41)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(461, 28)" end="(461, 29)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(461, 30)" end="(461, 31)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(461, 32)" end="(461, 41)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                          </OtherNode>
                          <AtomNode start="(461, 41)" end="(461, 42)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <OtherNode start="(461, 43)" end="(461, 63)" kind="Lean.bracketedExplicitBinders">
                          <AtomNode start="(461, 43)" end="(461, 44)" leading="" trailing="" val="("/>
                          <NullNode start="(461, 44)" end="(461, 46)">
                            <LeanBinderidentNode start="(461, 44)" end="(461, 46)">
                              <IdentNode start="(461, 44)" end="(461, 46)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                            </LeanBinderidentNode>
                          </NullNode>
                          <AtomNode start="(461, 47)" end="(461, 48)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(461, 49)" end="(461, 62)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(461, 49)" end="(461, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(461, 51)" end="(461, 52)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(461, 53)" end="(461, 62)" leading="" trailing="" raw_val="l₂.length" val="l₂.length"/>
                          </OtherNode>
                          <AtomNode start="(461, 62)" end="(461, 63)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(461, 63)" end="(461, 64)" leading="" trailing="&#10;          " val=","/>
                    <OtherNode start="(462, 11)" end="(463, 85)" kind="«term_∧_»">
                      <OtherNode start="(462, 11)" end="(463, 69)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(462, 11)" end="(462, 12)" leading="" trailing="" val="("/>
                        <OtherNode start="(462, 12)" end="(463, 68)" kind="Lean.Parser.Term.forall">
                          <AtomNode start="(462, 12)" end="(462, 13)" leading="" trailing=" " val="∀"/>
                          <NullNode start="(462, 14)" end="(462, 15)">
                            <IdentNode start="(462, 14)" end="(462, 15)" leading="" trailing="" raw_val="j" val="j"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(462, 15)" end="(462, 16)" leading="" trailing=" " val=","/>
                          <OtherNode start="(462, 17)" end="(463, 68)" kind="Lean.Parser.Term.depArrow">
                            <TermExplicitbinderNode start="(462, 17)" end="(462, 29)">
                              <AtomNode start="(462, 17)" end="(462, 18)" leading="" trailing="" val="("/>
                              <NullNode start="(462, 18)" end="(462, 20)">
                                <IdentNode start="(462, 18)" end="(462, 20)" leading="" trailing=" " raw_val="hj" val="hj"/>
                              </NullNode>
                              <NullNode start="(462, 21)" end="(462, 28)">
                                <AtomNode start="(462, 21)" end="(462, 22)" leading="" trailing=" " val=":"/>
                                <OtherNode start="(462, 23)" end="(462, 28)" kind="«term_&amp;lt;_»">
                                  <IdentNode start="(462, 23)" end="(462, 24)" leading="" trailing=" " raw_val="j" val="j"/>
                                  <AtomNode start="(462, 25)" end="(462, 26)" leading="" trailing=" " val="&amp;lt;"/>
                                  <IdentNode start="(462, 27)" end="(462, 28)" leading="" trailing="" raw_val="i" val="i"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(462, 28)" end="(462, 29)" leading="" trailing=" " val=")"/>
                            </TermExplicitbinderNode>
                            <AtomNode start="(462, 30)" end="(462, 31)" leading="" trailing="&#10;            " val="→"/>
                            <OtherNode start="(463, 13)" end="(463, 68)" kind="«term_=_»">
                              <OtherNode start="(463, 13)" end="(463, 39)" kind="«term__[_]'_»">
                                <IdentNode start="(463, 13)" end="(463, 15)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                <AtomNode start="(463, 15)" end="(463, 16)" leading="" trailing="" val="["/>
                                <IdentNode start="(463, 16)" end="(463, 17)" leading="" trailing="" raw_val="j" val="j"/>
                                <AtomNode start="(463, 17)" end="(463, 19)" leading="" trailing="" val="]'"/>
                                <OtherNode start="(463, 19)" end="(463, 39)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(463, 19)" end="(463, 20)" leading="" trailing="" val="("/>
                                  <OtherNode start="(463, 20)" end="(463, 38)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(463, 20)" end="(463, 32)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(463, 33)" end="(463, 38)">
                                      <IdentNode start="(463, 33)" end="(463, 35)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                      <IdentNode start="(463, 36)" end="(463, 38)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(463, 38)" end="(463, 39)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(463, 40)" end="(463, 41)" leading="" trailing=" " val="="/>
                              <OtherNode start="(463, 42)" end="(463, 68)" kind="«term__[_]'_»">
                                <IdentNode start="(463, 42)" end="(463, 44)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                <AtomNode start="(463, 44)" end="(463, 45)" leading="" trailing="" val="["/>
                                <IdentNode start="(463, 45)" end="(463, 46)" leading="" trailing="" raw_val="j" val="j"/>
                                <AtomNode start="(463, 46)" end="(463, 48)" leading="" trailing="" val="]'"/>
                                <OtherNode start="(463, 48)" end="(463, 68)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(463, 48)" end="(463, 49)" leading="" trailing="" val="("/>
                                  <OtherNode start="(463, 49)" end="(463, 67)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(463, 49)" end="(463, 61)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(463, 62)" end="(463, 67)">
                                      <IdentNode start="(463, 62)" end="(463, 64)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                      <IdentNode start="(463, 65)" end="(463, 67)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(463, 67)" end="(463, 68)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(463, 68)" end="(463, 69)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <AtomNode start="(463, 70)" end="(463, 71)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(463, 72)" end="(463, 85)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(463, 72)" end="(463, 77)" kind="«term__[_]»">
                          <IdentNode start="(463, 72)" end="(463, 74)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                          <AtomNode start="(463, 74)" end="(463, 75)" leading="" trailing="" val="["/>
                          <IdentNode start="(463, 75)" end="(463, 76)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(463, 76)" end="(463, 77)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                        <AtomNode start="(463, 78)" end="(463, 79)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(463, 80)" end="(463, 85)" kind="«term__[_]»">
                          <IdentNode start="(463, 80)" end="(463, 82)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                          <AtomNode start="(463, 82)" end="(463, 83)" leading="" trailing="" val="["/>
                          <IdentNode start="(463, 83)" end="(463, 84)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(463, 84)" end="(463, 85)" leading="" trailing="" val="]"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(463, 85)" end="(463, 86)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(463, 87)" end="(470, 38)">
          <AtomNode start="(463, 87)" end="(463, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(463, 90)" end="(470, 38)">
            <AtomNode start="(463, 90)" end="(463, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(464, 3)" end="(470, 38)">
              <TacticTacticseq1IndentedNode start="(464, 3)" end="(470, 38)">
                <NullNode start="(464, 3)" end="(470, 38)">
                  <OtherNode start="(464, 3)" end="(464, 54)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ l₁ ≤ l₂ ↔ l₁ = take l₁.length l₂ ∨ ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]" state_after="α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₂[j] == l₁[j]) = true) ∧ decide (l₁[i] &amp;lt; l₂[i]) = true) ↔&#10;    l₁ = take l₁.length l₂ ∨ ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]&#10;&#10;case lt_irrefl&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), (x == y) = true → decide (x &amp;lt; y) = false&#10;&#10;case lt_asymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = true → decide (y &amp;lt; x) = false&#10;&#10;case lt_antisymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = false → decide (y &amp;lt; x) = false → (x == y) = true" tactic="rw [← lex_eq_false_iff_ge, lex_eq_false_iff_exists]">
                    <AtomNode start="(464, 3)" end="(464, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(464, 6)" end="(464, 54)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(464, 6)" end="(464, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(464, 7)" end="(464, 53)">
                        <OtherNode start="(464, 7)" end="(464, 28)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(464, 7)" end="(464, 8)">
                            <OtherNode start="(464, 7)" end="(464, 8)" kind="patternIgnore">
                              <OtherNode start="(464, 7)" end="(464, 8)" kind="token.«← »">
                                <AtomNode start="(464, 7)" end="(464, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(464, 9)" end="(464, 28)" leading="" trailing="" raw_val="lex_eq_false_iff_ge" val="lex_eq_false_iff_ge" full_name="List.lex_eq_false_iff_ge" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(315, 17)" def_end="(315, 36)"/>
                        </OtherNode>
                        <AtomNode start="(464, 28)" end="(464, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(464, 30)" end="(464, 53)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(464, 30)" end="(464, 53)" leading="" trailing="" raw_val="lex_eq_false_iff_exists" val="lex_eq_false_iff_exists" full_name="List.lex_eq_false_iff_exists" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(390, 9)" def_end="(390, 32)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(464, 53)" end="(464, 54)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(465, 3)" end="(467, 48)" kind="Lean.cdot" state_before="α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₂[j] == l₁[j]) = true) ∧ decide (l₁[i] &amp;lt; l₂[i]) = true) ↔&#10;    l₁ = take l₁.length l₂ ∨ ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]&#10;&#10;case lt_irrefl&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), (x == y) = true → decide (x &amp;lt; y) = false&#10;&#10;case lt_asymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = true → decide (y &amp;lt; x) = false&#10;&#10;case lt_antisymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = false → decide (y &amp;lt; x) = false → (x == y) = true" state_after="case lt_irrefl&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), (x == y) = true → decide (x &amp;lt; y) = false&#10;&#10;case lt_asymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = true → decide (y &amp;lt; x) = false&#10;&#10;case lt_antisymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = false → decide (y &amp;lt; x) = false → (x == y) = true" tactic="· simp only [isEqv_eq, beq_iff_eq, decide_eq_true_eq]&#10;  simp only [eq_comm]&#10;  conv =&amp;gt; lhs; simp +singlePass [exists_comm]">
                    <OtherNode start="(465, 3)" end="(465, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(465, 3)" end="(465, 4)" kind="patternIgnore">
                        <OtherNode start="(465, 3)" end="(465, 4)" kind="token.«· »">
                          <AtomNode start="(465, 3)" end="(465, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(465, 5)" end="(467, 48)">
                      <TacticTacticseq1IndentedNode start="(465, 5)" end="(467, 48)">
                        <NullNode start="(465, 5)" end="(467, 48)">
                          <OtherNode start="(465, 5)" end="(465, 56)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ((l₁.isEqv (take l₁.length l₂) fun x1 x2 =&amp;gt; x1 == x2) = true ∨&#10;      ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (l₂[j] == l₁[j]) = true) ∧ decide (l₁[i] &amp;lt; l₂[i]) = true) ↔&#10;    l₁ = take l₁.length l₂ ∨ ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]" state_after="α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ (l₁ = take l₁.length l₂ ∨ ∃ i h h_1, (∀ (j : Nat) (hj : j &amp;lt; i), l₂[j] = l₁[j]) ∧ l₁[i] &amp;lt; l₂[i]) ↔&#10;    l₁ = take l₁.length l₂ ∨ ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]" tactic="simp only [isEqv_eq, beq_iff_eq, decide_eq_true_eq]">
                            <AtomNode start="(465, 5)" end="(465, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(465, 10)" end="(465, 14)">
                              <AtomNode start="(465, 10)" end="(465, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(465, 15)" end="(465, 56)">
                              <AtomNode start="(465, 15)" end="(465, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(465, 16)" end="(465, 55)">
                                <OtherNode start="(465, 16)" end="(465, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(465, 16)" end="(465, 24)" leading="" trailing="" raw_val="isEqv_eq" val="isEqv_eq" full_name="List.isEqv_eq" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(465, 24)" end="(465, 25)" leading="" trailing=" " val=","/>
                                <OtherNode start="(465, 26)" end="(465, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(465, 26)" end="(465, 36)" leading="" trailing="" raw_val="beq_iff_eq" val="beq_iff_eq" full_name="beq_iff_eq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                                <AtomNode start="(465, 36)" end="(465, 37)" leading="" trailing=" " val=","/>
                                <OtherNode start="(465, 38)" end="(465, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(465, 38)" end="(465, 55)" leading="" trailing="" raw_val="decide_eq_true_eq" val="decide_eq_true_eq" full_name="decide_eq_true_eq" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(465, 55)" end="(465, 56)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(466, 5)" end="(466, 24)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ (l₁ = take l₁.length l₂ ∨ ∃ i h h_1, (∀ (j : Nat) (hj : j &amp;lt; i), l₂[j] = l₁[j]) ∧ l₁[i] &amp;lt; l₂[i]) ↔&#10;    l₁ = take l₁.length l₂ ∨ ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]" state_after="α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ (l₁ = take l₁.length l₂ ∨ ∃ i h h_1, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]) ↔&#10;    l₁ = take l₁.length l₂ ∨ ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]" tactic="simp only [eq_comm]">
                            <AtomNode start="(466, 5)" end="(466, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(466, 10)" end="(466, 14)">
                              <AtomNode start="(466, 10)" end="(466, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(466, 15)" end="(466, 24)">
                              <AtomNode start="(466, 15)" end="(466, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(466, 16)" end="(466, 23)">
                                <OtherNode start="(466, 16)" end="(466, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(466, 16)" end="(466, 23)" leading="" trailing="" raw_val="eq_comm" val="eq_comm" full_name="eq_comm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(466, 23)" end="(466, 24)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(467, 5)" end="(467, 48)" kind="Lean.Parser.Tactic.Conv.conv" state_before="α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ (l₁ = take l₁.length l₂ ∨ ∃ i h h_1, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]) ↔&#10;    l₁ = take l₁.length l₂ ∨ ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]" state_after="no goals" tactic="conv =&amp;gt; lhs; simp +singlePass [exists_comm]">
                            <AtomNode start="(467, 5)" end="(467, 9)" leading="" trailing=" " val="conv"/>
                            <NullNode/>
                            <NullNode/>
                            <AtomNode start="(467, 10)" end="(467, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(467, 13)" end="(467, 48)" kind="Lean.Parser.Tactic.Conv.convSeq">
                              <OtherNode start="(467, 13)" end="(467, 48)" kind="Lean.Parser.Tactic.Conv.convSeq1Indented">
                                <NullNode start="(467, 13)" end="(467, 48)">
                                  <OtherNode start="(467, 13)" end="(467, 16)" kind="Lean.Parser.Tactic.Conv.lhs">
                                    <AtomNode start="(467, 13)" end="(467, 16)" leading="" trailing="" val="lhs"/>
                                  </OtherNode>
                                  <AtomNode start="(467, 16)" end="(467, 17)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(467, 18)" end="(467, 48)" kind="Lean.Parser.Tactic.Conv.simp">
                                    <AtomNode start="(467, 18)" end="(467, 22)" leading="" trailing=" " val="simp"/>
                                    <OtherNode start="(467, 23)" end="(467, 34)" kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode start="(467, 23)" end="(467, 34)">
                                        <OtherNode start="(467, 23)" end="(467, 34)" kind="Lean.Parser.Tactic.configItem">
                                          <OtherNode start="(467, 23)" end="(467, 34)" kind="Lean.Parser.Tactic.posConfigItem">
                                            <AtomNode start="(467, 23)" end="(467, 24)" leading="" trailing="" val="+"/>
                                            <IdentNode start="(467, 24)" end="(467, 34)" leading="" trailing=" " raw_val="singlePass" val="singlePass"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(467, 35)" end="(467, 48)">
                                      <AtomNode start="(467, 35)" end="(467, 36)" leading="" trailing="" val="["/>
                                      <NullNode start="(467, 36)" end="(467, 47)">
                                        <OtherNode start="(467, 36)" end="(467, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(467, 36)" end="(467, 47)" leading="" trailing="" raw_val="exists_comm" val="exists_comm" full_name="exists_comm" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(467, 47)" end="(467, 48)" leading="" trailing="&#10;  " val="]"/>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(468, 3)" end="(468, 34)" kind="Lean.cdot" state_before="case lt_irrefl&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), (x == y) = true → decide (x &amp;lt; y) = false&#10;&#10;case lt_asymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = true → decide (y &amp;lt; x) = false&#10;&#10;case lt_antisymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = false → decide (y &amp;lt; x) = false → (x == y) = true" state_after="case lt_asymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = true → decide (y &amp;lt; x) = false&#10;&#10;case lt_antisymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = false → decide (y &amp;lt; x) = false → (x == y) = true" tactic="· simpa using Std.Irrefl.irrefl">
                    <OtherNode start="(468, 3)" end="(468, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(468, 3)" end="(468, 4)" kind="patternIgnore">
                        <OtherNode start="(468, 3)" end="(468, 4)" kind="token.«· »">
                          <AtomNode start="(468, 3)" end="(468, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(468, 5)" end="(468, 34)">
                      <TacticTacticseq1IndentedNode start="(468, 5)" end="(468, 34)">
                        <NullNode start="(468, 5)" end="(468, 34)">
                          <OtherNode start="(468, 5)" end="(468, 34)" kind="Lean.Parser.Tactic.simpa" state_before="case lt_irrefl&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), (x == y) = true → decide (x &amp;lt; y) = false" state_after="no goals" tactic="simpa using Std.Irrefl.irrefl">
                            <AtomNode start="(468, 5)" end="(468, 10)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(468, 11)" end="(468, 34)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(468, 11)" end="(468, 34)">
                                <AtomNode start="(468, 11)" end="(468, 16)" leading="" trailing=" " val="using"/>
                                <IdentNode start="(468, 17)" end="(468, 34)" leading="" trailing="&#10;  " raw_val="Std.Irrefl.irrefl" val="Std.Irrefl.irrefl" full_name="Std.Irrefl.irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(469, 3)" end="(469, 32)" kind="Lean.cdot" state_before="case lt_asymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = true → decide (y &amp;lt; x) = false&#10;&#10;case lt_antisymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = false → decide (y &amp;lt; x) = false → (x == y) = true" state_after="case lt_antisymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = false → decide (y &amp;lt; x) = false → (x == y) = true" tactic="· simpa using Std.Asymm.asymm">
                    <OtherNode start="(469, 3)" end="(469, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(469, 3)" end="(469, 4)" kind="patternIgnore">
                        <OtherNode start="(469, 3)" end="(469, 4)" kind="token.«· »">
                          <AtomNode start="(469, 3)" end="(469, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(469, 5)" end="(469, 32)">
                      <TacticTacticseq1IndentedNode start="(469, 5)" end="(469, 32)">
                        <NullNode start="(469, 5)" end="(469, 32)">
                          <OtherNode start="(469, 5)" end="(469, 32)" kind="Lean.Parser.Tactic.simpa" state_before="case lt_asymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = true → decide (y &amp;lt; x) = false" state_after="no goals" tactic="simpa using Std.Asymm.asymm">
                            <AtomNode start="(469, 5)" end="(469, 10)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(469, 11)" end="(469, 32)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(469, 11)" end="(469, 32)">
                                <AtomNode start="(469, 11)" end="(469, 16)" leading="" trailing=" " val="using"/>
                                <IdentNode start="(469, 17)" end="(469, 32)" leading="" trailing="&#10;  " raw_val="Std.Asymm.asymm" val="Std.Asymm.asymm" full_name="Std.Asymm.asymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(470, 3)" end="(470, 38)" kind="Lean.cdot" state_before="case lt_antisymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = false → decide (y &amp;lt; x) = false → (x == y) = true" state_after="no goals" tactic="· simpa using Std.Antisymm.antisymm">
                    <OtherNode start="(470, 3)" end="(470, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(470, 3)" end="(470, 4)" kind="patternIgnore">
                        <OtherNode start="(470, 3)" end="(470, 4)" kind="token.«· »">
                          <AtomNode start="(470, 3)" end="(470, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(470, 5)" end="(470, 38)">
                      <TacticTacticseq1IndentedNode start="(470, 5)" end="(470, 38)">
                        <NullNode start="(470, 5)" end="(470, 38)">
                          <OtherNode start="(470, 5)" end="(470, 38)" kind="Lean.Parser.Tactic.simpa" state_before="case lt_antisymm&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ ∀ (x y : α), decide (x &amp;lt; y) = false → decide (y &amp;lt; x) = false → (x == y) = true" state_after="no goals" tactic="simpa using Std.Antisymm.antisymm">
                            <AtomNode start="(470, 5)" end="(470, 10)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(470, 11)" end="(470, 38)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(470, 11)" end="(470, 38)">
                                <AtomNode start="(470, 11)" end="(470, 16)" leading="" trailing=" " val="using"/>
                                <IdentNode start="(470, 17)" end="(470, 38)" leading="" trailing="&#10;&#10;" raw_val="Std.Antisymm.antisymm" val="Std.Antisymm.antisymm" full_name="Std.Antisymm.antisymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(472, 1)" end="(476, 48)" name="append_left_lt" full_name="List.append_left_lt">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(472, 1)" end="(476, 48)" name="append_left_lt" full_name="List.append_left_lt" _is_private_decl="False">
        <AtomNode start="(472, 1)" end="(472, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(472, 9)" end="(472, 23)">
          <IdentNode start="(472, 9)" end="(472, 23)" leading="" trailing=" " raw_val="append_left_lt" val="append_left_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(472, 24)" end="(473, 24)">
          <NullNode start="(472, 24)" end="(472, 64)">
            <OtherNode start="(472, 24)" end="(472, 30)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(472, 24)" end="(472, 25)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(472, 25)" end="(472, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(472, 25)" end="(472, 27)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(472, 28)" end="(472, 29)">
                  <IdentNode start="(472, 28)" end="(472, 29)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(472, 29)" end="(472, 30)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(472, 31)" end="(472, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(472, 31)" end="(472, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(472, 32)" end="(472, 40)">
                <IdentNode start="(472, 32)" end="(472, 34)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(472, 35)" end="(472, 37)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                <IdentNode start="(472, 38)" end="(472, 40)" leading="" trailing=" " raw_val="l₃" val="l₃"/>
              </NullNode>
              <NullNode start="(472, 41)" end="(472, 49)">
                <AtomNode start="(472, 41)" end="(472, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(472, 43)" end="(472, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(472, 43)" end="(472, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(472, 48)" end="(472, 49)">
                    <IdentNode start="(472, 48)" end="(472, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(472, 49)" end="(472, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(472, 51)" end="(472, 64)">
              <AtomNode start="(472, 51)" end="(472, 52)" leading="" trailing="" val="("/>
              <NullNode start="(472, 52)" end="(472, 53)">
                <IdentNode start="(472, 52)" end="(472, 53)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(472, 54)" end="(472, 63)">
                <AtomNode start="(472, 54)" end="(472, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(472, 56)" end="(472, 63)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(472, 56)" end="(472, 58)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  <AtomNode start="(472, 59)" end="(472, 60)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(472, 61)" end="(472, 63)" leading="" trailing="" raw_val="l₃" val="l₃"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(472, 63)" end="(472, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(472, 65)" end="(473, 24)">
            <AtomNode start="(472, 65)" end="(472, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(473, 5)" end="(473, 24)" kind="«term_&amp;lt;_»">
              <OtherNode start="(473, 5)" end="(473, 13)" kind="«term_++_»">
                <IdentNode start="(473, 5)" end="(473, 7)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(473, 8)" end="(473, 10)" leading="" trailing=" " val="++"/>
                <IdentNode start="(473, 11)" end="(473, 13)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
              <AtomNode start="(473, 14)" end="(473, 15)" leading="" trailing=" " val="&amp;lt;"/>
              <OtherNode start="(473, 16)" end="(473, 24)" kind="«term_++_»">
                <IdentNode start="(473, 16)" end="(473, 18)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(473, 19)" end="(473, 21)" leading="" trailing=" " val="++"/>
                <IdentNode start="(473, 22)" end="(473, 24)" leading="" trailing=" " raw_val="l₃" val="l₃"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(473, 25)" end="(476, 48)">
          <AtomNode start="(473, 25)" end="(473, 27)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(473, 28)" end="(476, 48)">
            <AtomNode start="(473, 28)" end="(473, 30)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(474, 3)" end="(476, 48)">
              <TacticTacticseq1IndentedNode start="(474, 3)" end="(476, 48)">
                <NullNode start="(474, 3)" end="(476, 48)">
                  <OtherNode start="(474, 3)" end="(476, 48)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝ : LT α&#10;l₁ l₂ l₃ : List α&#10;h : l₂ &amp;lt; l₃&#10;⊢ l₁ ++ l₂ &amp;lt; l₁ ++ l₃" state_after="no goals" tactic="induction l₁ with&#10;| nil =&amp;gt; simp [h]&#10;| cons a l₁ ih =&amp;gt; simp [cons_lt_cons_iff, ih]">
                    <AtomNode start="(474, 3)" end="(474, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(474, 13)" end="(474, 15)">
                      <OtherNode start="(474, 13)" end="(474, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(474, 13)" end="(474, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(474, 16)" end="(476, 48)">
                      <OtherNode start="(474, 16)" end="(476, 48)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(474, 16)" end="(474, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(475, 3)" end="(476, 48)">
                          <OtherNode start="(475, 3)" end="(475, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(475, 3)" end="(475, 8)">
                              <OtherNode start="(475, 3)" end="(475, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(475, 3)" end="(475, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(475, 5)" end="(475, 8)">
                                  <NullNode/>
                                  <IdentNode start="(475, 5)" end="(475, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(475, 9)" end="(475, 20)">
                              <AtomNode start="(475, 9)" end="(475, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(475, 12)" end="(475, 20)">
                                <TacticTacticseq1IndentedNode start="(475, 12)" end="(475, 20)">
                                  <NullNode start="(475, 12)" end="(475, 20)">
                                    <OtherNode start="(475, 12)" end="(475, 20)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;inst✝ : LT α&#10;l₂ l₃ : List α&#10;h : l₂ &amp;lt; l₃&#10;⊢ [] ++ l₂ &amp;lt; [] ++ l₃" state_after="no goals" tactic="simp [h]">
                                      <AtomNode start="(475, 12)" end="(475, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(475, 17)" end="(475, 20)">
                                        <AtomNode start="(475, 17)" end="(475, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(475, 18)" end="(475, 19)">
                                          <OtherNode start="(475, 18)" end="(475, 19)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(475, 18)" end="(475, 19)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(475, 19)" end="(475, 20)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(476, 3)" end="(476, 48)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(476, 3)" end="(476, 17)">
                              <OtherNode start="(476, 3)" end="(476, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(476, 3)" end="(476, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(476, 5)" end="(476, 9)">
                                  <NullNode/>
                                  <IdentNode start="(476, 5)" end="(476, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(476, 10)" end="(476, 17)">
                                  <IdentNode start="(476, 10)" end="(476, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(476, 12)" end="(476, 14)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                  <IdentNode start="(476, 15)" end="(476, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(476, 18)" end="(476, 48)">
                              <AtomNode start="(476, 18)" end="(476, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(476, 21)" end="(476, 48)">
                                <TacticTacticseq1IndentedNode start="(476, 21)" end="(476, 48)">
                                  <NullNode start="(476, 21)" end="(476, 48)">
                                    <OtherNode start="(476, 21)" end="(476, 48)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;inst✝ : LT α&#10;l₂ l₃ : List α&#10;h : l₂ &amp;lt; l₃&#10;a : α&#10;l₁ : List α&#10;ih : l₁ ++ l₂ &amp;lt; l₁ ++ l₃&#10;⊢ a :: l₁ ++ l₂ &amp;lt; a :: l₁ ++ l₃" state_after="no goals" tactic="simp [cons_lt_cons_iff, ih]">
                                      <AtomNode start="(476, 21)" end="(476, 25)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(476, 26)" end="(476, 48)">
                                        <AtomNode start="(476, 26)" end="(476, 27)" leading="" trailing="" val="["/>
                                        <NullNode start="(476, 27)" end="(476, 47)">
                                          <OtherNode start="(476, 27)" end="(476, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(476, 27)" end="(476, 43)" leading="" trailing="" raw_val="cons_lt_cons_iff" val="cons_lt_cons_iff" full_name="List.cons_lt_cons_iff" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(66, 9)" def_end="(66, 25)"/>
                                          </OtherNode>
                                          <AtomNode start="(476, 43)" end="(476, 44)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(476, 45)" end="(476, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(476, 45)" end="(476, 47)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(476, 47)" end="(476, 48)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(478, 1)" end="(486, 48)" name="append_left_le" full_name="List.append_left_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(478, 1)" end="(486, 48)" name="append_left_le" full_name="List.append_left_le" _is_private_decl="False">
        <AtomNode start="(478, 1)" end="(478, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(478, 9)" end="(478, 23)">
          <IdentNode start="(478, 9)" end="(478, 23)" leading="" trailing=" " raw_val="append_left_le" val="append_left_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(478, 24)" end="(483, 24)">
          <NullNode start="(478, 24)" end="(482, 38)">
            <OtherNode start="(478, 24)" end="(478, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(478, 24)" end="(478, 25)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(478, 25)" end="(478, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(478, 25)" end="(478, 36)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(478, 37)" end="(478, 38)">
                  <IdentNode start="(478, 37)" end="(478, 38)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(478, 38)" end="(478, 39)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(478, 40)" end="(478, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(478, 40)" end="(478, 41)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(478, 41)" end="(478, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(478, 41)" end="(478, 43)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(478, 44)" end="(478, 45)">
                  <IdentNode start="(478, 44)" end="(478, 45)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(478, 45)" end="(478, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(478, 47)" end="(478, 62)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(478, 47)" end="(478, 48)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(478, 48)" end="(478, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(478, 48)" end="(478, 59)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(478, 60)" end="(478, 61)">
                  <IdentNode start="(478, 60)" end="(478, 61)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(478, 61)" end="(478, 62)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(479, 5)" end="(479, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(479, 5)" end="(479, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(479, 6)" end="(479, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(479, 6)" end="(479, 16)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(479, 17)" end="(479, 39)">
                  <OtherNode start="(479, 17)" end="(479, 39)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(479, 17)" end="(479, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(479, 18)" end="(479, 23)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(479, 18)" end="(479, 19)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(479, 18)" end="(479, 19)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(479, 20)" end="(479, 21)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(479, 22)" end="(479, 23)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(479, 22)" end="(479, 23)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(479, 24)" end="(479, 25)" leading="" trailing=" " val=":"/>
                    <NullNode start="(479, 26)" end="(479, 38)">
                      <OtherNode start="(479, 26)" end="(479, 38)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(479, 26)" end="(479, 27)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(479, 28)" end="(479, 29)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(479, 30)" end="(479, 38)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(479, 30)" end="(479, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(479, 32)" end="(479, 33)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(479, 34)" end="(479, 38)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(479, 34)" end="(479, 38)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(479, 38)" end="(479, 39)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(479, 39)" end="(479, 40)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(480, 5)" end="(480, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(480, 5)" end="(480, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(480, 6)" end="(480, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(480, 6)" end="(480, 15)" leading="" trailing=" " raw_val="Std.Asymm" val="Std.Asymm" full_name="Std.Asymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(480, 16)" end="(480, 38)">
                  <OtherNode start="(480, 16)" end="(480, 38)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(480, 16)" end="(480, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(480, 17)" end="(480, 22)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(480, 17)" end="(480, 18)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(480, 17)" end="(480, 18)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(480, 19)" end="(480, 20)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(480, 21)" end="(480, 22)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(480, 21)" end="(480, 22)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(480, 23)" end="(480, 24)" leading="" trailing=" " val=":"/>
                    <NullNode start="(480, 25)" end="(480, 37)">
                      <OtherNode start="(480, 25)" end="(480, 37)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(480, 25)" end="(480, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(480, 27)" end="(480, 28)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(480, 29)" end="(480, 37)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(480, 29)" end="(480, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(480, 31)" end="(480, 32)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(480, 33)" end="(480, 37)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(480, 33)" end="(480, 37)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(480, 37)" end="(480, 38)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(480, 38)" end="(480, 39)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(481, 5)" end="(481, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(481, 5)" end="(481, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(481, 6)" end="(481, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(481, 6)" end="(481, 18)" leading="" trailing=" " raw_val="Std.Antisymm" val="Std.Antisymm" full_name="Std.Antisymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(481, 19)" end="(481, 43)">
                  <OtherNode start="(481, 19)" end="(481, 43)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(481, 19)" end="(481, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(481, 20)" end="(481, 27)" kind="«term¬_»">
                      <AtomNode start="(481, 20)" end="(481, 21)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(481, 22)" end="(481, 27)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(481, 22)" end="(481, 23)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(481, 22)" end="(481, 23)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(481, 24)" end="(481, 25)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(481, 26)" end="(481, 27)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(481, 26)" end="(481, 27)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(481, 28)" end="(481, 29)" leading="" trailing=" " val=":"/>
                    <NullNode start="(481, 30)" end="(481, 42)">
                      <OtherNode start="(481, 30)" end="(481, 42)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(481, 30)" end="(481, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(481, 32)" end="(481, 33)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(481, 34)" end="(481, 42)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(481, 34)" end="(481, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(481, 36)" end="(481, 37)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(481, 38)" end="(481, 42)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(481, 38)" end="(481, 42)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(481, 42)" end="(481, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(481, 43)" end="(481, 44)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(482, 5)" end="(482, 24)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(482, 5)" end="(482, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(482, 6)" end="(482, 14)">
                <IdentNode start="(482, 6)" end="(482, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(482, 9)" end="(482, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                <IdentNode start="(482, 12)" end="(482, 14)" leading="" trailing=" " raw_val="l₃" val="l₃"/>
              </NullNode>
              <NullNode start="(482, 15)" end="(482, 23)">
                <AtomNode start="(482, 15)" end="(482, 16)" leading="" trailing=" " val=":"/>
                <OtherNode start="(482, 17)" end="(482, 23)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(482, 17)" end="(482, 21)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(482, 22)" end="(482, 23)">
                    <IdentNode start="(482, 22)" end="(482, 23)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(482, 23)" end="(482, 24)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(482, 25)" end="(482, 38)">
              <AtomNode start="(482, 25)" end="(482, 26)" leading="" trailing="" val="("/>
              <NullNode start="(482, 26)" end="(482, 27)">
                <IdentNode start="(482, 26)" end="(482, 27)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(482, 28)" end="(482, 37)">
                <AtomNode start="(482, 28)" end="(482, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(482, 30)" end="(482, 37)" kind="«term_≤_»">
                  <IdentNode start="(482, 30)" end="(482, 32)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  <AtomNode start="(482, 33)" end="(482, 34)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(482, 35)" end="(482, 37)" leading="" trailing="" raw_val="l₃" val="l₃"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(482, 37)" end="(482, 38)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(482, 39)" end="(483, 24)">
            <AtomNode start="(482, 39)" end="(482, 40)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(483, 5)" end="(483, 24)" kind="«term_≤_»">
              <OtherNode start="(483, 5)" end="(483, 13)" kind="«term_++_»">
                <IdentNode start="(483, 5)" end="(483, 7)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(483, 8)" end="(483, 10)" leading="" trailing=" " val="++"/>
                <IdentNode start="(483, 11)" end="(483, 13)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
              <AtomNode start="(483, 14)" end="(483, 15)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(483, 16)" end="(483, 24)" kind="«term_++_»">
                <IdentNode start="(483, 16)" end="(483, 18)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(483, 19)" end="(483, 21)" leading="" trailing=" " val="++"/>
                <IdentNode start="(483, 22)" end="(483, 24)" leading="" trailing=" " raw_val="l₃" val="l₃"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(483, 25)" end="(486, 48)">
          <AtomNode start="(483, 25)" end="(483, 27)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(483, 28)" end="(486, 48)">
            <AtomNode start="(483, 28)" end="(483, 30)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(484, 3)" end="(486, 48)">
              <TacticTacticseq1IndentedNode start="(484, 3)" end="(486, 48)">
                <NullNode start="(484, 3)" end="(486, 48)">
                  <OtherNode start="(484, 3)" end="(486, 48)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ l₃ : List α&#10;h : l₂ ≤ l₃&#10;⊢ l₁ ++ l₂ ≤ l₁ ++ l₃" state_after="no goals" tactic="induction l₁ with&#10;| nil =&amp;gt; simp [h]&#10;| cons a l₁ ih =&amp;gt; simp [cons_le_cons_iff, ih]">
                    <AtomNode start="(484, 3)" end="(484, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(484, 13)" end="(484, 15)">
                      <OtherNode start="(484, 13)" end="(484, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(484, 13)" end="(484, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(484, 16)" end="(486, 48)">
                      <OtherNode start="(484, 16)" end="(486, 48)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(484, 16)" end="(484, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(485, 3)" end="(486, 48)">
                          <OtherNode start="(485, 3)" end="(485, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(485, 3)" end="(485, 8)">
                              <OtherNode start="(485, 3)" end="(485, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(485, 3)" end="(485, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(485, 5)" end="(485, 8)">
                                  <NullNode/>
                                  <IdentNode start="(485, 5)" end="(485, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(485, 9)" end="(485, 20)">
                              <AtomNode start="(485, 9)" end="(485, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(485, 12)" end="(485, 20)">
                                <TacticTacticseq1IndentedNode start="(485, 12)" end="(485, 20)">
                                  <NullNode start="(485, 12)" end="(485, 20)">
                                    <OtherNode start="(485, 12)" end="(485, 20)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;h : l₂ ≤ l₃&#10;⊢ [] ++ l₂ ≤ [] ++ l₃" state_after="no goals" tactic="simp [h]">
                                      <AtomNode start="(485, 12)" end="(485, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(485, 17)" end="(485, 20)">
                                        <AtomNode start="(485, 17)" end="(485, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(485, 18)" end="(485, 19)">
                                          <OtherNode start="(485, 18)" end="(485, 19)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(485, 18)" end="(485, 19)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(485, 19)" end="(485, 20)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(486, 3)" end="(486, 48)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(486, 3)" end="(486, 17)">
                              <OtherNode start="(486, 3)" end="(486, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(486, 3)" end="(486, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(486, 5)" end="(486, 9)">
                                  <NullNode/>
                                  <IdentNode start="(486, 5)" end="(486, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(486, 10)" end="(486, 17)">
                                  <IdentNode start="(486, 10)" end="(486, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(486, 12)" end="(486, 14)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                  <IdentNode start="(486, 15)" end="(486, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(486, 18)" end="(486, 48)">
                              <AtomNode start="(486, 18)" end="(486, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(486, 21)" end="(486, 48)">
                                <TacticTacticseq1IndentedNode start="(486, 21)" end="(486, 48)">
                                  <NullNode start="(486, 21)" end="(486, 48)">
                                    <OtherNode start="(486, 21)" end="(486, 48)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;inst✝⁵ : DecidableEq α&#10;inst✝⁴ : LT α&#10;inst✝³ : DecidableLT α&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₂ l₃ : List α&#10;h : l₂ ≤ l₃&#10;a : α&#10;l₁ : List α&#10;ih : l₁ ++ l₂ ≤ l₁ ++ l₃&#10;⊢ a :: l₁ ++ l₂ ≤ a :: l₁ ++ l₃" state_after="no goals" tactic="simp [cons_le_cons_iff, ih]">
                                      <AtomNode start="(486, 21)" end="(486, 25)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(486, 26)" end="(486, 48)">
                                        <AtomNode start="(486, 26)" end="(486, 27)" leading="" trailing="" val="["/>
                                        <NullNode start="(486, 27)" end="(486, 47)">
                                          <OtherNode start="(486, 27)" end="(486, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(486, 27)" end="(486, 43)" leading="" trailing="" raw_val="cons_le_cons_iff" val="cons_le_cons_iff" full_name="List.cons_le_cons_iff" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(79, 9)" def_end="(79, 25)"/>
                                          </OtherNode>
                                          <AtomNode start="(486, 43)" end="(486, 44)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(486, 45)" end="(486, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(486, 45)" end="(486, 47)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(486, 47)" end="(486, 48)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(488, 1)" end="(493, 60)" name="le_append_left" full_name="List.le_append_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(488, 1)" end="(493, 60)" name="le_append_left" full_name="List.le_append_left" _is_private_decl="False">
        <AtomNode start="(488, 1)" end="(488, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(488, 9)" end="(488, 23)">
          <IdentNode start="(488, 9)" end="(488, 23)" leading="" trailing=" " raw_val="le_append_left" val="le_append_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(488, 24)" end="(489, 37)">
          <NullNode start="(488, 24)" end="(489, 21)">
            <OtherNode start="(488, 24)" end="(488, 30)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(488, 24)" end="(488, 25)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(488, 25)" end="(488, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(488, 25)" end="(488, 27)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(488, 28)" end="(488, 29)">
                  <IdentNode start="(488, 28)" end="(488, 29)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(488, 29)" end="(488, 30)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(488, 31)" end="(488, 66)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(488, 31)" end="(488, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(488, 32)" end="(488, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(488, 32)" end="(488, 42)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(488, 43)" end="(488, 65)">
                  <OtherNode start="(488, 43)" end="(488, 65)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(488, 43)" end="(488, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(488, 44)" end="(488, 49)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(488, 44)" end="(488, 45)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(488, 44)" end="(488, 45)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(488, 46)" end="(488, 47)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(488, 48)" end="(488, 49)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(488, 48)" end="(488, 49)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(488, 50)" end="(488, 51)" leading="" trailing=" " val=":"/>
                    <NullNode start="(488, 52)" end="(488, 64)">
                      <OtherNode start="(488, 52)" end="(488, 64)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(488, 52)" end="(488, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(488, 54)" end="(488, 55)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(488, 56)" end="(488, 64)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(488, 56)" end="(488, 57)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(488, 58)" end="(488, 59)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(488, 60)" end="(488, 64)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(488, 60)" end="(488, 64)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(488, 64)" end="(488, 65)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(488, 65)" end="(488, 66)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(489, 5)" end="(489, 21)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(489, 5)" end="(489, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(489, 6)" end="(489, 11)">
                <IdentNode start="(489, 6)" end="(489, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(489, 9)" end="(489, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(489, 12)" end="(489, 20)">
                <AtomNode start="(489, 12)" end="(489, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(489, 14)" end="(489, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(489, 14)" end="(489, 18)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(489, 19)" end="(489, 20)">
                    <IdentNode start="(489, 19)" end="(489, 20)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(489, 20)" end="(489, 21)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(489, 22)" end="(489, 37)">
            <AtomNode start="(489, 22)" end="(489, 23)" leading="" trailing=" " val=":"/>
            <OtherNode start="(489, 24)" end="(489, 37)" kind="«term_≤_»">
              <IdentNode start="(489, 24)" end="(489, 26)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              <AtomNode start="(489, 27)" end="(489, 28)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(489, 29)" end="(489, 37)" kind="«term_++_»">
                <IdentNode start="(489, 29)" end="(489, 31)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(489, 32)" end="(489, 34)" leading="" trailing=" " val="++"/>
                <IdentNode start="(489, 35)" end="(489, 37)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(489, 38)" end="(493, 60)">
          <AtomNode start="(489, 38)" end="(489, 40)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(489, 41)" end="(493, 60)">
            <AtomNode start="(489, 41)" end="(489, 43)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(490, 3)" end="(493, 60)">
              <TacticTacticseq1IndentedNode start="(490, 3)" end="(493, 60)">
                <NullNode start="(490, 3)" end="(493, 60)">
                  <OtherNode start="(490, 3)" end="(490, 10)" kind="Lean.Parser.Tactic.intro" state_before="α : Type u_1&#10;inst✝¹ : LT α&#10;inst✝ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;⊢ l₁ ≤ l₁ ++ l₂" state_after="α : Type u_1&#10;inst✝¹ : LT α&#10;inst✝ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ++ l₂ &amp;lt; l₁&#10;⊢ False" tactic="intro h">
                    <AtomNode start="(490, 3)" end="(490, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(490, 9)" end="(490, 10)">
                      <IdentNode start="(490, 9)" end="(490, 10)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(491, 3)" end="(493, 60)" kind="Lean.Parser.Tactic.match" state_before="α : Type u_1&#10;inst✝¹ : LT α&#10;inst✝ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ ++ l₂ &amp;lt; l₁&#10;⊢ False" state_after="no goals" tactic="match l₁, h with&#10;| nil, h =&amp;gt; simp at h&#10;| cons a l₁, h =&amp;gt; exact le_append_left (by simpa using h)">
                    <AtomNode start="(491, 3)" end="(491, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(491, 9)" end="(491, 14)">
                      <OtherNode start="(491, 9)" end="(491, 11)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(491, 9)" end="(491, 11)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(491, 11)" end="(491, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(491, 13)" end="(491, 14)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(491, 13)" end="(491, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(491, 15)" end="(491, 19)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(492, 3)" end="(493, 60)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(492, 3)" end="(493, 60)">
                        <OtherNode start="(492, 3)" end="(492, 24)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(492, 3)" end="(492, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(492, 5)" end="(492, 11)">
                            <NullNode start="(492, 5)" end="(492, 11)">
                              <IdentNode start="(492, 5)" end="(492, 8)" leading="" trailing="" raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <AtomNode start="(492, 8)" end="(492, 9)" leading="" trailing=" " val=","/>
                              <IdentNode start="(492, 10)" end="(492, 11)" leading="" trailing=" " raw_val="h" val="h"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(492, 12)" end="(492, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(492, 15)" end="(492, 24)">
                            <TacticTacticseq1IndentedNode start="(492, 15)" end="(492, 24)">
                              <NullNode start="(492, 15)" end="(492, 24)">
                                <OtherNode start="(492, 15)" end="(492, 24)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : LT α&#10;inst✝ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h✝ : l₁ ++ l₂ &amp;lt; l₁&#10;h : [] ++ l₂ &amp;lt; []&#10;⊢ False" state_after="no goals" tactic="simp at h">
                                  <AtomNode start="(492, 15)" end="(492, 19)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(492, 20)" end="(492, 24)">
                                    <OtherNode start="(492, 20)" end="(492, 24)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(492, 20)" end="(492, 22)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(492, 23)" end="(492, 24)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(492, 23)" end="(492, 24)">
                                          <IdentNode start="(492, 23)" end="(492, 24)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(493, 3)" end="(493, 60)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(493, 3)" end="(493, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(493, 5)" end="(493, 17)">
                            <NullNode start="(493, 5)" end="(493, 17)">
                              <OtherNode start="(493, 5)" end="(493, 14)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(493, 5)" end="(493, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(493, 10)" end="(493, 14)">
                                  <IdentNode start="(493, 10)" end="(493, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(493, 12)" end="(493, 14)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(493, 14)" end="(493, 15)" leading="" trailing=" " val=","/>
                              <IdentNode start="(493, 16)" end="(493, 17)" leading="" trailing=" " raw_val="h" val="h"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(493, 18)" end="(493, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(493, 21)" end="(493, 60)">
                            <TacticTacticseq1IndentedNode start="(493, 21)" end="(493, 60)">
                              <NullNode start="(493, 21)" end="(493, 60)">
                                <OtherNode start="(493, 21)" end="(493, 60)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝¹ : LT α&#10;inst✝ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;l₁✝ l₂ : List α&#10;h✝ : l₁✝ ++ l₂ &amp;lt; l₁✝&#10;a : α&#10;l₁ : List α&#10;h : a :: l₁ ++ l₂ &amp;lt; a :: l₁&#10;⊢ False" state_after="no goals" tactic="exact le_append_left (by simpa using h)">
                                  <AtomNode start="(493, 21)" end="(493, 26)" leading="" trailing=" " val="exact"/>
                                  <OtherNode start="(493, 27)" end="(493, 60)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(493, 27)" end="(493, 41)" leading="" trailing=" " raw_val="le_append_left" val="le_append_left"/>
                                    <NullNode start="(493, 42)" end="(493, 60)">
                                      <OtherNode start="(493, 42)" end="(493, 60)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(493, 42)" end="(493, 43)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(493, 43)" end="(493, 59)">
                                          <AtomNode start="(493, 43)" end="(493, 45)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(493, 46)" end="(493, 59)">
                                            <TacticTacticseq1IndentedNode start="(493, 46)" end="(493, 59)">
                                              <NullNode start="(493, 46)" end="(493, 59)">
                                                <OtherNode start="(493, 46)" end="(493, 59)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : LT α&#10;inst✝ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;l₁✝ l₂ : List α&#10;h✝ : l₁✝ ++ l₂ &amp;lt; l₁✝&#10;a : α&#10;l₁ : List α&#10;h : a :: l₁ ++ l₂ &amp;lt; a :: l₁&#10;⊢ ?m.115870 ++ ?m.115871 &amp;lt; ?m.115870" state_after="no goals" tactic="simpa using h">
                                                  <AtomNode start="(493, 46)" end="(493, 51)" leading="" trailing=" " val="simpa"/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <OtherNode start="(493, 52)" end="(493, 59)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(493, 52)" end="(493, 59)">
                                                      <AtomNode start="(493, 52)" end="(493, 57)" leading="" trailing=" " val="using"/>
                                                      <IdentNode start="(493, 58)" end="(493, 59)" leading="" trailing="" raw_val="h" val="h"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(493, 59)" end="(493, 60)" leading="" trailing="&#10;&#10;" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(495, 1)" end="(498, 23)" name="IsPrefix.le" full_name="List.IsPrefix.le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(495, 1)" end="(498, 23)" name="IsPrefix.le" full_name="List.IsPrefix.le" _is_private_decl="False">
        <AtomNode start="(495, 1)" end="(495, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(495, 9)" end="(495, 20)">
          <IdentNode start="(495, 9)" end="(495, 20)" leading="" trailing=" " raw_val="IsPrefix.le" val="IsPrefix.le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(495, 21)" end="(496, 47)">
          <NullNode start="(495, 21)" end="(496, 37)">
            <OtherNode start="(495, 21)" end="(495, 27)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(495, 21)" end="(495, 22)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(495, 22)" end="(495, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(495, 22)" end="(495, 24)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(495, 25)" end="(495, 26)">
                  <IdentNode start="(495, 25)" end="(495, 26)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(495, 26)" end="(495, 27)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(495, 28)" end="(495, 63)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(495, 28)" end="(495, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(495, 29)" end="(495, 62)" kind="Lean.Parser.Term.app">
                <IdentNode start="(495, 29)" end="(495, 39)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(495, 40)" end="(495, 62)">
                  <OtherNode start="(495, 40)" end="(495, 62)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(495, 40)" end="(495, 41)" leading="" trailing="" val="("/>
                    <OtherNode start="(495, 41)" end="(495, 46)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(495, 41)" end="(495, 42)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(495, 41)" end="(495, 42)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(495, 43)" end="(495, 44)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(495, 45)" end="(495, 46)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(495, 45)" end="(495, 46)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(495, 47)" end="(495, 48)" leading="" trailing=" " val=":"/>
                    <NullNode start="(495, 49)" end="(495, 61)">
                      <OtherNode start="(495, 49)" end="(495, 61)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(495, 49)" end="(495, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(495, 51)" end="(495, 52)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(495, 53)" end="(495, 61)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(495, 53)" end="(495, 54)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(495, 55)" end="(495, 56)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(495, 57)" end="(495, 61)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(495, 57)" end="(495, 61)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(495, 61)" end="(495, 62)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(495, 62)" end="(495, 63)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(496, 5)" end="(496, 21)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(496, 5)" end="(496, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(496, 6)" end="(496, 11)">
                <IdentNode start="(496, 6)" end="(496, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(496, 9)" end="(496, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(496, 12)" end="(496, 20)">
                <AtomNode start="(496, 12)" end="(496, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(496, 14)" end="(496, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(496, 14)" end="(496, 18)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(496, 19)" end="(496, 20)">
                    <IdentNode start="(496, 19)" end="(496, 20)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(496, 20)" end="(496, 21)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(496, 22)" end="(496, 37)">
              <AtomNode start="(496, 22)" end="(496, 23)" leading="" trailing="" val="("/>
              <NullNode start="(496, 23)" end="(496, 24)">
                <IdentNode start="(496, 23)" end="(496, 24)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(496, 25)" end="(496, 36)">
                <AtomNode start="(496, 25)" end="(496, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(496, 27)" end="(496, 36)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(496, 27)" end="(496, 29)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(496, 30)" end="(496, 33)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(496, 34)" end="(496, 36)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(496, 36)" end="(496, 37)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(496, 38)" end="(496, 47)">
            <AtomNode start="(496, 38)" end="(496, 39)" leading="" trailing=" " val=":"/>
            <OtherNode start="(496, 40)" end="(496, 47)" kind="«term_≤_»">
              <IdentNode start="(496, 40)" end="(496, 42)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              <AtomNode start="(496, 43)" end="(496, 44)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(496, 45)" end="(496, 47)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(496, 48)" end="(498, 23)">
          <AtomNode start="(496, 48)" end="(496, 50)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(496, 51)" end="(498, 23)">
            <AtomNode start="(496, 51)" end="(496, 53)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(497, 3)" end="(498, 23)">
              <TacticTacticseq1IndentedNode start="(497, 3)" end="(498, 23)">
                <NullNode start="(497, 3)" end="(498, 23)">
                  <OtherNode start="(497, 3)" end="(497, 25)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;inst✝¹ : LT α&#10;inst✝ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+: l₂&#10;⊢ l₁ ≤ l₂" state_after="case intro&#10;α : Type u_1&#10;inst✝¹ : LT α&#10;inst✝ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;l₁ w✝ : List α&#10;⊢ l₁ ≤ l₁ ++ w✝" tactic="rcases h with ⟨_, rfl⟩">
                    <AtomNode start="(497, 3)" end="(497, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(497, 10)" end="(497, 11)">
                      <OtherNode start="(497, 10)" end="(497, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(497, 10)" end="(497, 11)" leading="" trailing=" " raw_val="h" val="h"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(497, 12)" end="(497, 25)">
                      <AtomNode start="(497, 12)" end="(497, 16)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(497, 17)" end="(497, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(497, 17)" end="(497, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(497, 17)" end="(497, 25)">
                            <OtherNode start="(497, 17)" end="(497, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(497, 17)" end="(497, 18)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(497, 18)" end="(497, 24)">
                                <OtherNode start="(497, 18)" end="(497, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(497, 18)" end="(497, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(497, 18)" end="(497, 19)">
                                      <OtherNode start="(497, 18)" end="(497, 19)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                        <AtomNode start="(497, 18)" end="(497, 19)" leading="" trailing="" val="_"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(497, 19)" end="(497, 20)" leading="" trailing=" " val=","/>
                                <OtherNode start="(497, 21)" end="(497, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(497, 21)" end="(497, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(497, 21)" end="(497, 24)">
                                      <OtherNode start="(497, 21)" end="(497, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(497, 21)" end="(497, 24)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(497, 24)" end="(497, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(498, 3)" end="(498, 23)" kind="Lean.Parser.Tactic.apply" state_before="case intro&#10;α : Type u_1&#10;inst✝¹ : LT α&#10;inst✝ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;l₁ w✝ : List α&#10;⊢ l₁ ≤ l₁ ++ w✝" state_after="no goals" tactic="apply le_append_left">
                    <AtomNode start="(498, 3)" end="(498, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(498, 9)" end="(498, 23)" leading="" trailing="&#10;&#10;" raw_val="le_append_left" val="le_append_left" full_name="List.le_append_left" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(488, 9)" def_end="(488, 23)"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(500, 1)" end="(510, 34)" name="map_lt" full_name="List.map_lt">
      <CommandDeclmodifiersNode start="(500, 1)" end="(500, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(500, 1)" end="(500, 10)">
          <OtherNode start="(500, 1)" end="(500, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(500, 1)" end="(500, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(500, 11)" end="(510, 34)" name="map_lt" full_name="List.map_lt" _is_private_decl="False">
        <AtomNode start="(500, 11)" end="(500, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(500, 19)" end="(500, 25)">
          <IdentNode start="(500, 19)" end="(500, 25)" leading="" trailing=" " raw_val="map_lt" val="map_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(500, 26)" end="(502, 24)">
          <NullNode start="(500, 26)" end="(501, 78)">
            <OtherNode start="(500, 26)" end="(500, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(500, 26)" end="(500, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(500, 27)" end="(500, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(500, 27)" end="(500, 29)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(500, 30)" end="(500, 31)">
                  <IdentNode start="(500, 30)" end="(500, 31)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(500, 31)" end="(500, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(500, 33)" end="(500, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(500, 33)" end="(500, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(500, 34)" end="(500, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(500, 34)" end="(500, 36)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(500, 37)" end="(500, 38)">
                  <IdentNode start="(500, 37)" end="(500, 38)" leading="" trailing="" raw_val="β" val="β"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(500, 38)" end="(500, 39)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(501, 5)" end="(501, 21)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(501, 5)" end="(501, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(501, 6)" end="(501, 11)">
                <IdentNode start="(501, 6)" end="(501, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(501, 9)" end="(501, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(501, 12)" end="(501, 20)">
                <AtomNode start="(501, 12)" end="(501, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(501, 14)" end="(501, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(501, 14)" end="(501, 18)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(501, 19)" end="(501, 20)">
                    <IdentNode start="(501, 19)" end="(501, 20)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(501, 20)" end="(501, 21)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(501, 22)" end="(501, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(501, 22)" end="(501, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(501, 23)" end="(501, 24)">
                <IdentNode start="(501, 23)" end="(501, 24)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(501, 25)" end="(501, 32)">
                <AtomNode start="(501, 25)" end="(501, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(501, 27)" end="(501, 32)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(501, 27)" end="(501, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(501, 29)" end="(501, 30)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(501, 31)" end="(501, 32)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(501, 32)" end="(501, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(501, 34)" end="(501, 64)">
              <AtomNode start="(501, 34)" end="(501, 35)" leading="" trailing="" val="("/>
              <NullNode start="(501, 35)" end="(501, 36)">
                <IdentNode start="(501, 35)" end="(501, 36)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(501, 37)" end="(501, 63)">
                <AtomNode start="(501, 37)" end="(501, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(501, 39)" end="(501, 63)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(501, 39)" end="(501, 40)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(501, 41)" end="(501, 44)">
                    <IdentNode start="(501, 41)" end="(501, 42)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(501, 43)" end="(501, 44)" leading="" trailing="" raw_val="y" val="y"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(501, 44)" end="(501, 45)" leading="" trailing=" " val=","/>
                  <OtherNode start="(501, 46)" end="(501, 63)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(501, 46)" end="(501, 51)" kind="«term_&amp;lt;_»">
                      <IdentNode start="(501, 46)" end="(501, 47)" leading="" trailing=" " raw_val="x" val="x"/>
                      <AtomNode start="(501, 48)" end="(501, 49)" leading="" trailing=" " val="&amp;lt;"/>
                      <IdentNode start="(501, 50)" end="(501, 51)" leading="" trailing=" " raw_val="y" val="y"/>
                    </OtherNode>
                    <AtomNode start="(501, 52)" end="(501, 53)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(501, 54)" end="(501, 63)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(501, 54)" end="(501, 57)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(501, 54)" end="(501, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(501, 56)" end="(501, 57)">
                          <IdentNode start="(501, 56)" end="(501, 57)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(501, 58)" end="(501, 59)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(501, 60)" end="(501, 63)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(501, 60)" end="(501, 61)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(501, 62)" end="(501, 63)">
                          <IdentNode start="(501, 62)" end="(501, 63)" leading="" trailing="" raw_val="y" val="y"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(501, 63)" end="(501, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(501, 65)" end="(501, 78)">
              <AtomNode start="(501, 65)" end="(501, 66)" leading="" trailing="" val="("/>
              <NullNode start="(501, 66)" end="(501, 67)">
                <IdentNode start="(501, 66)" end="(501, 67)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(501, 68)" end="(501, 77)">
                <AtomNode start="(501, 68)" end="(501, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(501, 70)" end="(501, 77)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(501, 70)" end="(501, 72)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(501, 73)" end="(501, 74)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(501, 75)" end="(501, 77)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(501, 77)" end="(501, 78)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(501, 79)" end="(502, 24)">
            <AtomNode start="(501, 79)" end="(501, 80)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(502, 5)" end="(502, 24)" kind="«term_&amp;lt;_»">
              <OtherNode start="(502, 5)" end="(502, 13)" kind="Lean.Parser.Term.app">
                <IdentNode start="(502, 5)" end="(502, 8)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(502, 9)" end="(502, 13)">
                  <IdentNode start="(502, 9)" end="(502, 10)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(502, 11)" end="(502, 13)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(502, 14)" end="(502, 15)" leading="" trailing=" " val="&amp;lt;"/>
              <OtherNode start="(502, 16)" end="(502, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(502, 16)" end="(502, 19)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(502, 20)" end="(502, 24)">
                  <IdentNode start="(502, 20)" end="(502, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(502, 22)" end="(502, 24)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(502, 25)" end="(510, 34)">
          <AtomNode start="(502, 25)" end="(502, 27)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(502, 28)" end="(510, 34)">
            <AtomNode start="(502, 28)" end="(502, 30)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(503, 3)" end="(510, 34)">
              <TacticTacticseq1IndentedNode start="(503, 3)" end="(510, 34)">
                <NullNode start="(503, 3)" end="(510, 34)">
                  <OtherNode start="(503, 3)" end="(510, 34)" kind="Lean.Parser.Tactic.match" state_before="α : Type u_1&#10;β : Type u_2&#10;inst✝¹ : LT α&#10;inst✝ : LT β&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h : l₁ &amp;lt; l₂&#10;⊢ map f l₁ &amp;lt; map f l₂" state_after="no goals" tactic="match l₁, l₂, h with&#10;| nil, nil, h =&amp;gt; simp at h&#10;| nil, cons b l₂, h =&amp;gt; simp&#10;| cons a l₁, nil, h =&amp;gt; simp at h&#10;| cons a l₁, cons _ l₂, .cons h =&amp;gt;&#10;  simp [cons_lt_cons_iff, List.map_lt w (by simpa using h)]&#10;| cons a l₁, cons b l₂, .rel h =&amp;gt;&#10;  simp [cons_lt_cons_iff, w, h]">
                    <AtomNode start="(503, 3)" end="(503, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(503, 9)" end="(503, 18)">
                      <OtherNode start="(503, 9)" end="(503, 11)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(503, 9)" end="(503, 11)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(503, 11)" end="(503, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(503, 13)" end="(503, 15)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(503, 13)" end="(503, 15)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </OtherNode>
                      <AtomNode start="(503, 15)" end="(503, 16)" leading="" trailing=" " val=","/>
                      <OtherNode start="(503, 17)" end="(503, 18)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(503, 17)" end="(503, 18)" leading="" trailing=" " raw_val="h" val="h"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(503, 19)" end="(503, 23)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(504, 3)" end="(510, 34)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(504, 3)" end="(510, 34)">
                        <OtherNode start="(504, 3)" end="(504, 29)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(504, 3)" end="(504, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(504, 5)" end="(504, 16)">
                            <NullNode start="(504, 5)" end="(504, 16)">
                              <IdentNode start="(504, 5)" end="(504, 8)" leading="" trailing="" raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <AtomNode start="(504, 8)" end="(504, 9)" leading="" trailing=" " val=","/>
                              <IdentNode start="(504, 10)" end="(504, 13)" leading="" trailing="" raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <AtomNode start="(504, 13)" end="(504, 14)" leading="" trailing=" " val=","/>
                              <IdentNode start="(504, 15)" end="(504, 16)" leading="" trailing=" " raw_val="h" val="h"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(504, 17)" end="(504, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(504, 20)" end="(504, 29)">
                            <TacticTacticseq1IndentedNode start="(504, 20)" end="(504, 29)">
                              <NullNode start="(504, 20)" end="(504, 29)">
                                <OtherNode start="(504, 20)" end="(504, 29)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;inst✝¹ : LT α&#10;inst✝ : LT β&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h✝ : l₁ &amp;lt; l₂&#10;h : [] &amp;lt; []&#10;⊢ map f [] &amp;lt; map f []" state_after="no goals" tactic="simp at h">
                                  <AtomNode start="(504, 20)" end="(504, 24)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(504, 25)" end="(504, 29)">
                                    <OtherNode start="(504, 25)" end="(504, 29)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(504, 25)" end="(504, 27)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(504, 28)" end="(504, 29)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(504, 28)" end="(504, 29)">
                                          <IdentNode start="(504, 28)" end="(504, 29)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(505, 3)" end="(505, 30)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(505, 3)" end="(505, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(505, 5)" end="(505, 22)">
                            <NullNode start="(505, 5)" end="(505, 22)">
                              <IdentNode start="(505, 5)" end="(505, 8)" leading="" trailing="" raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <AtomNode start="(505, 8)" end="(505, 9)" leading="" trailing=" " val=","/>
                              <OtherNode start="(505, 10)" end="(505, 19)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(505, 10)" end="(505, 14)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(505, 15)" end="(505, 19)">
                                  <IdentNode start="(505, 15)" end="(505, 16)" leading="" trailing=" " raw_val="b" val="b"/>
                                  <IdentNode start="(505, 17)" end="(505, 19)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(505, 19)" end="(505, 20)" leading="" trailing=" " val=","/>
                              <IdentNode start="(505, 21)" end="(505, 22)" leading="" trailing=" " raw_val="h" val="h"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(505, 23)" end="(505, 25)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(505, 26)" end="(505, 30)">
                            <TacticTacticseq1IndentedNode start="(505, 26)" end="(505, 30)">
                              <NullNode start="(505, 26)" end="(505, 30)">
                                <OtherNode start="(505, 26)" end="(505, 30)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;inst✝¹ : LT α&#10;inst✝ : LT β&#10;l₁ l₂✝ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h✝ : l₁ &amp;lt; l₂✝&#10;b : α&#10;l₂ : List α&#10;h : [] &amp;lt; b :: l₂&#10;⊢ map f [] &amp;lt; map f (b :: l₂)" state_after="no goals" tactic="simp">
                                  <AtomNode start="(505, 26)" end="(505, 30)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(506, 3)" end="(506, 35)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(506, 3)" end="(506, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(506, 5)" end="(506, 22)">
                            <NullNode start="(506, 5)" end="(506, 22)">
                              <OtherNode start="(506, 5)" end="(506, 14)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(506, 5)" end="(506, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(506, 10)" end="(506, 14)">
                                  <IdentNode start="(506, 10)" end="(506, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(506, 12)" end="(506, 14)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(506, 14)" end="(506, 15)" leading="" trailing=" " val=","/>
                              <IdentNode start="(506, 16)" end="(506, 19)" leading="" trailing="" raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <AtomNode start="(506, 19)" end="(506, 20)" leading="" trailing=" " val=","/>
                              <IdentNode start="(506, 21)" end="(506, 22)" leading="" trailing=" " raw_val="h" val="h"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(506, 23)" end="(506, 25)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(506, 26)" end="(506, 35)">
                            <TacticTacticseq1IndentedNode start="(506, 26)" end="(506, 35)">
                              <NullNode start="(506, 26)" end="(506, 35)">
                                <OtherNode start="(506, 26)" end="(506, 35)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;inst✝¹ : LT α&#10;inst✝ : LT β&#10;l₁✝ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h✝ : l₁✝ &amp;lt; l₂&#10;a : α&#10;l₁ : List α&#10;h : a :: l₁ &amp;lt; []&#10;⊢ map f (a :: l₁) &amp;lt; map f []" state_after="no goals" tactic="simp at h">
                                  <AtomNode start="(506, 26)" end="(506, 30)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(506, 31)" end="(506, 35)">
                                    <OtherNode start="(506, 31)" end="(506, 35)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(506, 31)" end="(506, 33)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(506, 34)" end="(506, 35)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(506, 34)" end="(506, 35)">
                                          <IdentNode start="(506, 34)" end="(506, 35)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(507, 3)" end="(508, 62)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(507, 3)" end="(507, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(507, 5)" end="(507, 34)">
                            <NullNode start="(507, 5)" end="(507, 34)">
                              <OtherNode start="(507, 5)" end="(507, 14)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(507, 5)" end="(507, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(507, 10)" end="(507, 14)">
                                  <IdentNode start="(507, 10)" end="(507, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(507, 12)" end="(507, 14)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(507, 14)" end="(507, 15)" leading="" trailing=" " val=","/>
                              <OtherNode start="(507, 16)" end="(507, 25)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(507, 16)" end="(507, 20)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(507, 21)" end="(507, 25)">
                                  <TermHoleNode start="(507, 21)" end="(507, 22)">
                                    <AtomNode start="(507, 21)" end="(507, 22)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <IdentNode start="(507, 23)" end="(507, 25)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(507, 25)" end="(507, 26)" leading="" trailing=" " val=","/>
                              <OtherNode start="(507, 27)" end="(507, 34)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(507, 27)" end="(507, 32)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(507, 27)" end="(507, 28)" leading="" trailing="" val="."/>
                                  <IdentNode start="(507, 28)" end="(507, 32)" leading="" trailing=" " raw_val="cons" val="cons"/>
                                </OtherNode>
                                <NullNode start="(507, 33)" end="(507, 34)">
                                  <IdentNode start="(507, 33)" end="(507, 34)" leading="" trailing=" " raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(507, 35)" end="(507, 37)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(508, 5)" end="(508, 62)">
                            <TacticTacticseq1IndentedNode start="(508, 5)" end="(508, 62)">
                              <NullNode start="(508, 5)" end="(508, 62)">
                                <OtherNode start="(508, 5)" end="(508, 62)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;inst✝¹ : LT α&#10;inst✝ : LT β&#10;l₁✝ l₂✝ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h✝ : l₁✝ &amp;lt; l₂✝&#10;a : α&#10;l₁ l₂ : List α&#10;h : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₁ l₂&#10;⊢ map f (a :: l₁) &amp;lt; map f (a :: l₂)" state_after="no goals" tactic="simp [cons_lt_cons_iff, List.map_lt w (by simpa using h)]">
                                  <AtomNode start="(508, 5)" end="(508, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(508, 10)" end="(508, 62)">
                                    <AtomNode start="(508, 10)" end="(508, 11)" leading="" trailing="" val="["/>
                                    <NullNode start="(508, 11)" end="(508, 61)">
                                      <OtherNode start="(508, 11)" end="(508, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(508, 11)" end="(508, 27)" leading="" trailing="" raw_val="cons_lt_cons_iff" val="cons_lt_cons_iff" full_name="List.cons_lt_cons_iff" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(66, 9)" def_end="(66, 25)"/>
                                      </OtherNode>
                                      <AtomNode start="(508, 27)" end="(508, 28)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(508, 29)" end="(508, 61)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(508, 29)" end="(508, 61)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(508, 29)" end="(508, 40)" leading="" trailing=" " raw_val="List.map_lt" val="List.map_lt"/>
                                          <NullNode start="(508, 41)" end="(508, 61)">
                                            <IdentNode start="(508, 41)" end="(508, 42)" leading="" trailing=" " raw_val="w" val="w"/>
                                            <OtherNode start="(508, 43)" end="(508, 61)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(508, 43)" end="(508, 44)" leading="" trailing="" val="("/>
                                              <TermBytacticNode start="(508, 44)" end="(508, 60)">
                                                <AtomNode start="(508, 44)" end="(508, 46)" leading="" trailing=" " val="by"/>
                                                <TacticTacticseqNode start="(508, 47)" end="(508, 60)">
                                                  <TacticTacticseq1IndentedNode start="(508, 47)" end="(508, 60)">
                                                    <NullNode start="(508, 47)" end="(508, 60)">
                                                      <OtherNode start="(508, 47)" end="(508, 60)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;β : Type u_2&#10;inst✝¹ : LT α&#10;inst✝ : LT β&#10;l₁✝ l₂✝ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h✝ : l₁✝ &amp;lt; l₂✝&#10;a : α&#10;l₁ l₂ : List α&#10;h : Lex (fun x1 x2 =&amp;gt; x1 &amp;lt; x2) l₁ l₂&#10;⊢ ?m.117517 &amp;lt; ?m.117518" state_after="no goals" tactic="simpa using h">
                                                        <AtomNode start="(508, 47)" end="(508, 52)" leading="" trailing=" " val="simpa"/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <OtherNode start="(508, 53)" end="(508, 60)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(508, 53)" end="(508, 60)">
                                                            <AtomNode start="(508, 53)" end="(508, 58)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(508, 59)" end="(508, 60)" leading="" trailing="" raw_val="h" val="h"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </TermBytacticNode>
                                              <AtomNode start="(508, 60)" end="(508, 61)" leading="" trailing="" val=")"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(508, 61)" end="(508, 62)" leading="" trailing="&#10;  " val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(509, 3)" end="(510, 34)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(509, 3)" end="(509, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(509, 5)" end="(509, 33)">
                            <NullNode start="(509, 5)" end="(509, 33)">
                              <OtherNode start="(509, 5)" end="(509, 14)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(509, 5)" end="(509, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(509, 10)" end="(509, 14)">
                                  <IdentNode start="(509, 10)" end="(509, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(509, 12)" end="(509, 14)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(509, 14)" end="(509, 15)" leading="" trailing=" " val=","/>
                              <OtherNode start="(509, 16)" end="(509, 25)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(509, 16)" end="(509, 20)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(509, 21)" end="(509, 25)">
                                  <IdentNode start="(509, 21)" end="(509, 22)" leading="" trailing=" " raw_val="b" val="b"/>
                                  <IdentNode start="(509, 23)" end="(509, 25)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(509, 25)" end="(509, 26)" leading="" trailing=" " val=","/>
                              <OtherNode start="(509, 27)" end="(509, 33)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(509, 27)" end="(509, 31)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(509, 27)" end="(509, 28)" leading="" trailing="" val="."/>
                                  <IdentNode start="(509, 28)" end="(509, 31)" leading="" trailing=" " raw_val="rel" val="rel"/>
                                </OtherNode>
                                <NullNode start="(509, 32)" end="(509, 33)">
                                  <IdentNode start="(509, 32)" end="(509, 33)" leading="" trailing=" " raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(509, 34)" end="(509, 36)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(510, 5)" end="(510, 34)">
                            <TacticTacticseq1IndentedNode start="(510, 5)" end="(510, 34)">
                              <NullNode start="(510, 5)" end="(510, 34)">
                                <OtherNode start="(510, 5)" end="(510, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;inst✝¹ : LT α&#10;inst✝ : LT β&#10;l₁✝ l₂✝ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h✝ : l₁✝ &amp;lt; l₂✝&#10;a : α&#10;l₁ : List α&#10;b : α&#10;l₂ : List α&#10;h : a &amp;lt; b&#10;⊢ map f (a :: l₁) &amp;lt; map f (b :: l₂)" state_after="no goals" tactic="simp [cons_lt_cons_iff, w, h]">
                                  <AtomNode start="(510, 5)" end="(510, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(510, 10)" end="(510, 34)">
                                    <AtomNode start="(510, 10)" end="(510, 11)" leading="" trailing="" val="["/>
                                    <NullNode start="(510, 11)" end="(510, 33)">
                                      <OtherNode start="(510, 11)" end="(510, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(510, 11)" end="(510, 27)" leading="" trailing="" raw_val="cons_lt_cons_iff" val="cons_lt_cons_iff" full_name="List.cons_lt_cons_iff" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(66, 9)" def_end="(66, 25)"/>
                                      </OtherNode>
                                      <AtomNode start="(510, 27)" end="(510, 28)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(510, 29)" end="(510, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(510, 29)" end="(510, 30)" leading="" trailing="" raw_val="w" val="w"/>
                                      </OtherNode>
                                      <AtomNode start="(510, 30)" end="(510, 31)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(510, 32)" end="(510, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(510, 32)" end="(510, 33)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(510, 33)" end="(510, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(512, 1)" end="(529, 27)" name="map_le" full_name="List.map_le">
      <CommandDeclmodifiersNode start="(512, 1)" end="(512, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(512, 1)" end="(512, 10)">
          <OtherNode start="(512, 1)" end="(512, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(512, 1)" end="(512, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(512, 11)" end="(529, 27)" name="map_le" full_name="List.map_le" _is_private_decl="False">
        <AtomNode start="(512, 11)" end="(512, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(512, 19)" end="(512, 25)">
          <IdentNode start="(512, 19)" end="(512, 25)" leading="" trailing=" " raw_val="map_le" val="map_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(512, 26)" end="(520, 24)">
          <NullNode start="(512, 26)" end="(519, 78)">
            <OtherNode start="(512, 26)" end="(512, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(512, 26)" end="(512, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(512, 27)" end="(512, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(512, 27)" end="(512, 38)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(512, 39)" end="(512, 40)">
                  <IdentNode start="(512, 39)" end="(512, 40)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(512, 40)" end="(512, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(512, 42)" end="(512, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(512, 42)" end="(512, 43)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(512, 43)" end="(512, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(512, 43)" end="(512, 45)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(512, 46)" end="(512, 47)">
                  <IdentNode start="(512, 46)" end="(512, 47)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(512, 47)" end="(512, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(512, 49)" end="(512, 64)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(512, 49)" end="(512, 50)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(512, 50)" end="(512, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(512, 50)" end="(512, 61)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(512, 62)" end="(512, 63)">
                  <IdentNode start="(512, 62)" end="(512, 63)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(512, 63)" end="(512, 64)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(512, 65)" end="(512, 80)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(512, 65)" end="(512, 66)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(512, 66)" end="(512, 79)" kind="Lean.Parser.Term.app">
                <IdentNode start="(512, 66)" end="(512, 77)" leading="" trailing=" " raw_val="DecidableEq" val="DecidableEq" full_name="DecidableEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(512, 78)" end="(512, 79)">
                  <IdentNode start="(512, 78)" end="(512, 79)" leading="" trailing="" raw_val="β" val="β"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(512, 79)" end="(512, 80)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(512, 81)" end="(512, 87)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(512, 81)" end="(512, 82)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(512, 82)" end="(512, 86)" kind="Lean.Parser.Term.app">
                <IdentNode start="(512, 82)" end="(512, 84)" leading="" trailing=" " raw_val="LT" val="LT" full_name="LT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(512, 85)" end="(512, 86)">
                  <IdentNode start="(512, 85)" end="(512, 86)" leading="" trailing="" raw_val="β" val="β"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(512, 86)" end="(512, 87)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(512, 88)" end="(512, 103)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(512, 88)" end="(512, 89)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(512, 89)" end="(512, 102)" kind="Lean.Parser.Term.app">
                <IdentNode start="(512, 89)" end="(512, 100)" leading="" trailing=" " raw_val="DecidableLT" val="DecidableLT" full_name="DecidableLT" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(512, 101)" end="(512, 102)">
                  <IdentNode start="(512, 101)" end="(512, 102)" leading="" trailing="" raw_val="β" val="β"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(512, 102)" end="(512, 103)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(513, 5)" end="(513, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(513, 5)" end="(513, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(513, 6)" end="(513, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(513, 6)" end="(513, 16)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(513, 17)" end="(513, 39)">
                  <OtherNode start="(513, 17)" end="(513, 39)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(513, 17)" end="(513, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(513, 18)" end="(513, 23)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(513, 18)" end="(513, 19)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(513, 18)" end="(513, 19)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(513, 20)" end="(513, 21)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(513, 22)" end="(513, 23)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(513, 22)" end="(513, 23)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(513, 24)" end="(513, 25)" leading="" trailing=" " val=":"/>
                    <NullNode start="(513, 26)" end="(513, 38)">
                      <OtherNode start="(513, 26)" end="(513, 38)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(513, 26)" end="(513, 27)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(513, 28)" end="(513, 29)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(513, 30)" end="(513, 38)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(513, 30)" end="(513, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(513, 32)" end="(513, 33)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(513, 34)" end="(513, 38)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(513, 34)" end="(513, 38)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(513, 38)" end="(513, 39)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(513, 39)" end="(513, 40)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(514, 5)" end="(514, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(514, 5)" end="(514, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(514, 6)" end="(514, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(514, 6)" end="(514, 15)" leading="" trailing=" " raw_val="Std.Asymm" val="Std.Asymm" full_name="Std.Asymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(514, 16)" end="(514, 38)">
                  <OtherNode start="(514, 16)" end="(514, 38)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(514, 16)" end="(514, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(514, 17)" end="(514, 22)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(514, 17)" end="(514, 18)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(514, 17)" end="(514, 18)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(514, 19)" end="(514, 20)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(514, 21)" end="(514, 22)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(514, 21)" end="(514, 22)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(514, 23)" end="(514, 24)" leading="" trailing=" " val=":"/>
                    <NullNode start="(514, 25)" end="(514, 37)">
                      <OtherNode start="(514, 25)" end="(514, 37)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(514, 25)" end="(514, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(514, 27)" end="(514, 28)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(514, 29)" end="(514, 37)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(514, 29)" end="(514, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(514, 31)" end="(514, 32)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(514, 33)" end="(514, 37)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(514, 33)" end="(514, 37)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(514, 37)" end="(514, 38)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(514, 38)" end="(514, 39)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(515, 5)" end="(515, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(515, 5)" end="(515, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(515, 6)" end="(515, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(515, 6)" end="(515, 18)" leading="" trailing=" " raw_val="Std.Antisymm" val="Std.Antisymm" full_name="Std.Antisymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(515, 19)" end="(515, 43)">
                  <OtherNode start="(515, 19)" end="(515, 43)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(515, 19)" end="(515, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(515, 20)" end="(515, 27)" kind="«term¬_»">
                      <AtomNode start="(515, 20)" end="(515, 21)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(515, 22)" end="(515, 27)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(515, 22)" end="(515, 23)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(515, 22)" end="(515, 23)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(515, 24)" end="(515, 25)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(515, 26)" end="(515, 27)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(515, 26)" end="(515, 27)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(515, 28)" end="(515, 29)" leading="" trailing=" " val=":"/>
                    <NullNode start="(515, 30)" end="(515, 42)">
                      <OtherNode start="(515, 30)" end="(515, 42)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(515, 30)" end="(515, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(515, 32)" end="(515, 33)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(515, 34)" end="(515, 42)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(515, 34)" end="(515, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                          <AtomNode start="(515, 36)" end="(515, 37)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(515, 38)" end="(515, 42)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(515, 38)" end="(515, 42)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(515, 42)" end="(515, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(515, 43)" end="(515, 44)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(516, 5)" end="(516, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(516, 5)" end="(516, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(516, 6)" end="(516, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(516, 6)" end="(516, 16)" leading="" trailing=" " raw_val="Std.Irrefl" val="Std.Irrefl" full_name="Std.Irrefl" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(516, 17)" end="(516, 39)">
                  <OtherNode start="(516, 17)" end="(516, 39)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(516, 17)" end="(516, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(516, 18)" end="(516, 23)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(516, 18)" end="(516, 19)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(516, 18)" end="(516, 19)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(516, 20)" end="(516, 21)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(516, 22)" end="(516, 23)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(516, 22)" end="(516, 23)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(516, 24)" end="(516, 25)" leading="" trailing=" " val=":"/>
                    <NullNode start="(516, 26)" end="(516, 38)">
                      <OtherNode start="(516, 26)" end="(516, 38)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(516, 26)" end="(516, 27)" leading="" trailing=" " raw_val="β" val="β"/>
                        <AtomNode start="(516, 28)" end="(516, 29)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(516, 30)" end="(516, 38)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(516, 30)" end="(516, 31)" leading="" trailing=" " raw_val="β" val="β"/>
                          <AtomNode start="(516, 32)" end="(516, 33)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(516, 34)" end="(516, 38)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(516, 34)" end="(516, 38)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(516, 38)" end="(516, 39)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(516, 39)" end="(516, 40)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(517, 5)" end="(517, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(517, 5)" end="(517, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(517, 6)" end="(517, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(517, 6)" end="(517, 15)" leading="" trailing=" " raw_val="Std.Asymm" val="Std.Asymm" full_name="Std.Asymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(517, 16)" end="(517, 38)">
                  <OtherNode start="(517, 16)" end="(517, 38)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(517, 16)" end="(517, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(517, 17)" end="(517, 22)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(517, 17)" end="(517, 18)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(517, 17)" end="(517, 18)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(517, 19)" end="(517, 20)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(517, 21)" end="(517, 22)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(517, 21)" end="(517, 22)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(517, 23)" end="(517, 24)" leading="" trailing=" " val=":"/>
                    <NullNode start="(517, 25)" end="(517, 37)">
                      <OtherNode start="(517, 25)" end="(517, 37)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(517, 25)" end="(517, 26)" leading="" trailing=" " raw_val="β" val="β"/>
                        <AtomNode start="(517, 27)" end="(517, 28)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(517, 29)" end="(517, 37)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(517, 29)" end="(517, 30)" leading="" trailing=" " raw_val="β" val="β"/>
                          <AtomNode start="(517, 31)" end="(517, 32)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(517, 33)" end="(517, 37)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(517, 33)" end="(517, 37)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(517, 37)" end="(517, 38)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(517, 38)" end="(517, 39)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(518, 5)" end="(518, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(518, 5)" end="(518, 6)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(518, 6)" end="(518, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(518, 6)" end="(518, 18)" leading="" trailing=" " raw_val="Std.Antisymm" val="Std.Antisymm" full_name="Std.Antisymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(518, 19)" end="(518, 43)">
                  <OtherNode start="(518, 19)" end="(518, 43)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(518, 19)" end="(518, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(518, 20)" end="(518, 27)" kind="«term¬_»">
                      <AtomNode start="(518, 20)" end="(518, 21)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(518, 22)" end="(518, 27)" kind="«term_&amp;lt;_»">
                        <OtherNode start="(518, 22)" end="(518, 23)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(518, 22)" end="(518, 23)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(518, 24)" end="(518, 25)" leading="" trailing=" " val="&amp;lt;"/>
                        <OtherNode start="(518, 26)" end="(518, 27)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(518, 26)" end="(518, 27)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(518, 28)" end="(518, 29)" leading="" trailing=" " val=":"/>
                    <NullNode start="(518, 30)" end="(518, 42)">
                      <OtherNode start="(518, 30)" end="(518, 42)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(518, 30)" end="(518, 31)" leading="" trailing=" " raw_val="β" val="β"/>
                        <AtomNode start="(518, 32)" end="(518, 33)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(518, 34)" end="(518, 42)" kind="Lean.Parser.Term.arrow">
                          <IdentNode start="(518, 34)" end="(518, 35)" leading="" trailing=" " raw_val="β" val="β"/>
                          <AtomNode start="(518, 36)" end="(518, 37)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(518, 38)" end="(518, 42)" kind="Lean.Parser.Term.prop">
                            <AtomNode start="(518, 38)" end="(518, 42)" leading="" trailing="" val="Prop"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(518, 42)" end="(518, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(518, 43)" end="(518, 44)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(519, 5)" end="(519, 21)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(519, 5)" end="(519, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(519, 6)" end="(519, 11)">
                <IdentNode start="(519, 6)" end="(519, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(519, 9)" end="(519, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(519, 12)" end="(519, 20)">
                <AtomNode start="(519, 12)" end="(519, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(519, 14)" end="(519, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(519, 14)" end="(519, 18)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(519, 19)" end="(519, 20)">
                    <IdentNode start="(519, 19)" end="(519, 20)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(519, 20)" end="(519, 21)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(519, 22)" end="(519, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(519, 22)" end="(519, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(519, 23)" end="(519, 24)">
                <IdentNode start="(519, 23)" end="(519, 24)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(519, 25)" end="(519, 32)">
                <AtomNode start="(519, 25)" end="(519, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(519, 27)" end="(519, 32)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(519, 27)" end="(519, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(519, 29)" end="(519, 30)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(519, 31)" end="(519, 32)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(519, 32)" end="(519, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(519, 34)" end="(519, 64)">
              <AtomNode start="(519, 34)" end="(519, 35)" leading="" trailing="" val="("/>
              <NullNode start="(519, 35)" end="(519, 36)">
                <IdentNode start="(519, 35)" end="(519, 36)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(519, 37)" end="(519, 63)">
                <AtomNode start="(519, 37)" end="(519, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(519, 39)" end="(519, 63)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(519, 39)" end="(519, 40)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(519, 41)" end="(519, 44)">
                    <IdentNode start="(519, 41)" end="(519, 42)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(519, 43)" end="(519, 44)" leading="" trailing="" raw_val="y" val="y"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(519, 44)" end="(519, 45)" leading="" trailing=" " val=","/>
                  <OtherNode start="(519, 46)" end="(519, 63)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(519, 46)" end="(519, 51)" kind="«term_&amp;lt;_»">
                      <IdentNode start="(519, 46)" end="(519, 47)" leading="" trailing=" " raw_val="x" val="x"/>
                      <AtomNode start="(519, 48)" end="(519, 49)" leading="" trailing=" " val="&amp;lt;"/>
                      <IdentNode start="(519, 50)" end="(519, 51)" leading="" trailing=" " raw_val="y" val="y"/>
                    </OtherNode>
                    <AtomNode start="(519, 52)" end="(519, 53)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(519, 54)" end="(519, 63)" kind="«term_&amp;lt;_»">
                      <OtherNode start="(519, 54)" end="(519, 57)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(519, 54)" end="(519, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(519, 56)" end="(519, 57)">
                          <IdentNode start="(519, 56)" end="(519, 57)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(519, 58)" end="(519, 59)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(519, 60)" end="(519, 63)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(519, 60)" end="(519, 61)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(519, 62)" end="(519, 63)">
                          <IdentNode start="(519, 62)" end="(519, 63)" leading="" trailing="" raw_val="y" val="y"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(519, 63)" end="(519, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(519, 65)" end="(519, 78)">
              <AtomNode start="(519, 65)" end="(519, 66)" leading="" trailing="" val="("/>
              <NullNode start="(519, 66)" end="(519, 67)">
                <IdentNode start="(519, 66)" end="(519, 67)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(519, 68)" end="(519, 77)">
                <AtomNode start="(519, 68)" end="(519, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(519, 70)" end="(519, 77)" kind="«term_≤_»">
                  <IdentNode start="(519, 70)" end="(519, 72)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(519, 73)" end="(519, 74)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(519, 75)" end="(519, 77)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(519, 77)" end="(519, 78)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(519, 79)" end="(520, 24)">
            <AtomNode start="(519, 79)" end="(519, 80)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(520, 5)" end="(520, 24)" kind="«term_≤_»">
              <OtherNode start="(520, 5)" end="(520, 13)" kind="Lean.Parser.Term.app">
                <IdentNode start="(520, 5)" end="(520, 8)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(520, 9)" end="(520, 13)">
                  <IdentNode start="(520, 9)" end="(520, 10)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(520, 11)" end="(520, 13)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(520, 14)" end="(520, 15)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(520, 16)" end="(520, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(520, 16)" end="(520, 19)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(520, 20)" end="(520, 24)">
                  <IdentNode start="(520, 20)" end="(520, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(520, 22)" end="(520, 24)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(520, 25)" end="(529, 27)">
          <AtomNode start="(520, 25)" end="(520, 27)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(520, 28)" end="(529, 27)">
            <AtomNode start="(520, 28)" end="(520, 30)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(521, 3)" end="(529, 27)">
              <TacticTacticseq1IndentedNode start="(521, 3)" end="(529, 27)">
                <NullNode start="(521, 3)" end="(529, 27)">
                  <OtherNode start="(521, 3)" end="(521, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h : l₁ ≤ l₂&#10;⊢ map f l₁ ≤ map f l₂" state_after="α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h : l₁ = take l₁.length l₂ ∨ ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]&#10;⊢ map f l₁ = take (map f l₁).length (map f l₂) ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]) ∧ (map f l₁)[i] &amp;lt; (map f l₂)[i]" tactic="rw [List.le_iff_exists] at h ⊢">
                    <AtomNode start="(521, 3)" end="(521, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(521, 6)" end="(521, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(521, 6)" end="(521, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(521, 7)" end="(521, 25)">
                        <OtherNode start="(521, 7)" end="(521, 25)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(521, 7)" end="(521, 25)" leading="" trailing="" raw_val="List.le_iff_exists" val="List.le_iff_exists" full_name="List.le_iff_exists" mod_name="Init.Data.List.Lex" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lex.lean" def_start="(455, 19)" def_end="(455, 32)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(521, 25)" end="(521, 26)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(521, 27)" end="(521, 33)">
                      <OtherNode start="(521, 27)" end="(521, 33)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(521, 27)" end="(521, 29)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(521, 30)" end="(521, 33)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(521, 30)" end="(521, 33)">
                            <IdentNode start="(521, 30)" end="(521, 31)" leading="" trailing=" " raw_val="h" val="h"/>
                            <OtherNode start="(521, 32)" end="(521, 33)" kind="Lean.Parser.Tactic.locationType">
                              <OtherNode start="(521, 32)" end="(521, 33)" kind="patternIgnore">
                                <OtherNode start="(521, 32)" end="(521, 33)" kind="token.«⊢»">
                                  <AtomNode start="(521, 32)" end="(521, 33)" leading="" trailing="&#10;  " val="⊢"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(522, 3)" end="(522, 40)" kind="Lean.Parser.Tactic.obtain" state_before="α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h : l₁ = take l₁.length l₂ ∨ ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]) ∧ l₁[i] &amp;lt; l₂[i]&#10;⊢ map f l₁ = take (map f l₁).length (map f l₂) ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]) ∧ (map f l₁)[i] &amp;lt; (map f l₂)[i]" state_after="case inl&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h : l₁ = take l₁.length l₂&#10;⊢ map f l₁ = take (map f l₁).length (map f l₂) ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]) ∧ (map f l₁)[i] &amp;lt; (map f l₂)[i]&#10;&#10;case inr.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ map f l₁ = take (map f l₁).length (map f l₂) ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]) ∧ (map f l₁)[i] &amp;lt; (map f l₂)[i]" tactic="obtain (h | ⟨i, h₁, h₂, w₁, w₂⟩) := h">
                    <AtomNode start="(522, 3)" end="(522, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(522, 10)" end="(522, 35)">
                      <OtherNode start="(522, 10)" end="(522, 35)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(522, 10)" end="(522, 35)">
                          <OtherNode start="(522, 10)" end="(522, 35)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                            <AtomNode start="(522, 10)" end="(522, 11)" leading="" trailing="" val="("/>
                            <OtherNode start="(522, 11)" end="(522, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                              <OtherNode start="(522, 11)" end="(522, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(522, 11)" end="(522, 34)">
                                  <OtherNode start="(522, 11)" end="(522, 12)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                    <IdentNode start="(522, 11)" end="(522, 12)" leading="" trailing=" " raw_val="h" val="h"/>
                                  </OtherNode>
                                  <AtomNode start="(522, 13)" end="(522, 14)" leading="" trailing=" " val="|"/>
                                  <OtherNode start="(522, 15)" end="(522, 34)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(522, 15)" end="(522, 16)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(522, 16)" end="(522, 33)">
                                      <OtherNode start="(522, 16)" end="(522, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(522, 16)" end="(522, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(522, 16)" end="(522, 17)">
                                            <OtherNode start="(522, 16)" end="(522, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(522, 16)" end="(522, 17)" leading="" trailing="" raw_val="i" val="i"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(522, 17)" end="(522, 18)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(522, 19)" end="(522, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(522, 19)" end="(522, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(522, 19)" end="(522, 21)">
                                            <OtherNode start="(522, 19)" end="(522, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(522, 19)" end="(522, 21)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(522, 21)" end="(522, 22)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(522, 23)" end="(522, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(522, 23)" end="(522, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(522, 23)" end="(522, 25)">
                                            <OtherNode start="(522, 23)" end="(522, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(522, 23)" end="(522, 25)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(522, 25)" end="(522, 26)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(522, 27)" end="(522, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(522, 27)" end="(522, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(522, 27)" end="(522, 29)">
                                            <OtherNode start="(522, 27)" end="(522, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(522, 27)" end="(522, 29)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(522, 29)" end="(522, 30)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(522, 31)" end="(522, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(522, 31)" end="(522, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(522, 31)" end="(522, 33)">
                                            <OtherNode start="(522, 31)" end="(522, 33)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(522, 31)" end="(522, 33)" leading="" trailing="" raw_val="w₂" val="w₂"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(522, 33)" end="(522, 34)" leading="" trailing="" val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(522, 34)" end="(522, 35)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(522, 36)" end="(522, 40)">
                      <AtomNode start="(522, 36)" end="(522, 38)" leading="" trailing=" " val=":="/>
                      <NullNode start="(522, 39)" end="(522, 40)">
                        <IdentNode start="(522, 39)" end="(522, 40)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(523, 3)" end="(525, 9)" kind="Lean.cdot" state_before="case inl&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h : l₁ = take l₁.length l₂&#10;⊢ map f l₁ = take (map f l₁).length (map f l₂) ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]) ∧ (map f l₁)[i] &amp;lt; (map f l₂)[i]&#10;&#10;case inr.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ map f l₁ = take (map f l₁).length (map f l₂) ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]) ∧ (map f l₁)[i] &amp;lt; (map f l₂)[i]" state_after="case inr.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ map f l₁ = take (map f l₁).length (map f l₂) ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]) ∧ (map f l₁)[i] &amp;lt; (map f l₂)[i]" tactic="· left&#10;  rw [h]&#10;  simp">
                    <OtherNode start="(523, 3)" end="(523, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(523, 3)" end="(523, 4)" kind="patternIgnore">
                        <OtherNode start="(523, 3)" end="(523, 4)" kind="token.«· »">
                          <AtomNode start="(523, 3)" end="(523, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(523, 5)" end="(525, 9)">
                      <TacticTacticseq1IndentedNode start="(523, 5)" end="(525, 9)">
                        <NullNode start="(523, 5)" end="(525, 9)">
                          <OtherNode start="(523, 5)" end="(523, 9)" kind="Lean.Parser.Tactic.left" state_before="case inl&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h : l₁ = take l₁.length l₂&#10;⊢ map f l₁ = take (map f l₁).length (map f l₂) ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]) ∧ (map f l₁)[i] &amp;lt; (map f l₂)[i]" state_after="case inl.h&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h : l₁ = take l₁.length l₂&#10;⊢ map f l₁ = take (map f l₁).length (map f l₂)" tactic="left">
                            <AtomNode start="(523, 5)" end="(523, 9)" leading="" trailing="&#10;    " val="left"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(524, 5)" end="(524, 11)" kind="Lean.Parser.Tactic.rwSeq" state_before="case inl.h&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h : l₁ = take l₁.length l₂&#10;⊢ map f l₁ = take (map f l₁).length (map f l₂)" state_after="case inl.h&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h : l₁ = take l₁.length l₂&#10;⊢ map f (take l₁.length l₂) = take (map f (take l₁.length l₂)).length (map f l₂)" tactic="rw [h]">
                            <AtomNode start="(524, 5)" end="(524, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(524, 8)" end="(524, 11)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(524, 8)" end="(524, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(524, 9)" end="(524, 10)">
                                <OtherNode start="(524, 9)" end="(524, 10)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(524, 9)" end="(524, 10)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(524, 10)" end="(524, 11)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(525, 5)" end="(525, 9)" kind="Lean.Parser.Tactic.simp" state_before="case inl.h&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;h : l₁ = take l₁.length l₂&#10;⊢ map f (take l₁.length l₂) = take (map f (take l₁.length l₂)).length (map f l₂)" state_after="no goals" tactic="simp">
                            <AtomNode start="(525, 5)" end="(525, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(526, 3)" end="(529, 27)" kind="Lean.cdot" state_before="case inr.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ map f l₁ = take (map f l₁).length (map f l₂) ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]) ∧ (map f l₁)[i] &amp;lt; (map f l₂)[i]" state_after="no goals" tactic="· right&#10;  refine ⟨i, by simpa using h₁, by simpa using h₂, ?_, ?_⟩&#10;  · simp +contextual [w₁]&#10;  · simpa using w _ _ w₂">
                    <OtherNode start="(526, 3)" end="(526, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(526, 3)" end="(526, 4)" kind="patternIgnore">
                        <OtherNode start="(526, 3)" end="(526, 4)" kind="token.«· »">
                          <AtomNode start="(526, 3)" end="(526, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(526, 5)" end="(529, 27)">
                      <TacticTacticseq1IndentedNode start="(526, 5)" end="(529, 27)">
                        <NullNode start="(526, 5)" end="(529, 27)">
                          <OtherNode start="(526, 5)" end="(526, 10)" kind="Lean.Parser.Tactic.right" state_before="case inr.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ map f l₁ = take (map f l₁).length (map f l₂) ∨&#10;    ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]) ∧ (map f l₁)[i] &amp;lt; (map f l₂)[i]" state_after="case inr.intro.intro.intro.intro.h&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]) ∧ (map f l₁)[i] &amp;lt; (map f l₂)[i]" tactic="right">
                            <AtomNode start="(526, 5)" end="(526, 10)" leading="" trailing="&#10;    " val="right"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(527, 5)" end="(527, 61)" kind="Lean.Parser.Tactic.refine" state_before="case inr.intro.intro.intro.intro.h&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ ∃ i h₁ h₂, (∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]) ∧ (map f l₁)[i] &amp;lt; (map f l₂)[i]" state_after="case inr.intro.intro.intro.intro.h.refine_1&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]&#10;&#10;case inr.intro.intro.intro.intro.h.refine_2&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ (map f l₁)[i] &amp;lt; (map f l₂)[i]" tactic="refine ⟨i, by simpa using h₁, by simpa using h₂, ?_, ?_⟩">
                            <AtomNode start="(527, 5)" end="(527, 11)" leading="" trailing=" " val="refine"/>
                            <OtherNode start="(527, 12)" end="(527, 61)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(527, 12)" end="(527, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(527, 13)" end="(527, 60)">
                                <IdentNode start="(527, 13)" end="(527, 14)" leading="" trailing="" raw_val="i" val="i"/>
                                <AtomNode start="(527, 14)" end="(527, 15)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(527, 16)" end="(527, 33)">
                                  <AtomNode start="(527, 16)" end="(527, 18)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(527, 19)" end="(527, 33)">
                                    <TacticTacticseq1IndentedNode start="(527, 19)" end="(527, 33)">
                                      <NullNode start="(527, 19)" end="(527, 33)">
                                        <OtherNode start="(527, 19)" end="(527, 33)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ i &amp;lt; (map f l₁).length" state_after="no goals" tactic="simpa using h₁">
                                          <AtomNode start="(527, 19)" end="(527, 24)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(527, 25)" end="(527, 33)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(527, 25)" end="(527, 33)">
                                              <AtomNode start="(527, 25)" end="(527, 30)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(527, 31)" end="(527, 33)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(527, 33)" end="(527, 34)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(527, 35)" end="(527, 52)">
                                  <AtomNode start="(527, 35)" end="(527, 37)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(527, 38)" end="(527, 52)">
                                    <TacticTacticseq1IndentedNode start="(527, 38)" end="(527, 52)">
                                      <NullNode start="(527, 38)" end="(527, 52)">
                                        <OtherNode start="(527, 38)" end="(527, 52)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ i &amp;lt; (map f l₂).length" state_after="no goals" tactic="simpa using h₂">
                                          <AtomNode start="(527, 38)" end="(527, 43)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(527, 44)" end="(527, 52)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(527, 44)" end="(527, 52)">
                                              <AtomNode start="(527, 44)" end="(527, 49)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(527, 50)" end="(527, 52)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(527, 52)" end="(527, 53)" leading="" trailing=" " val=","/>
                                <OtherNode start="(527, 54)" end="(527, 56)" kind="Lean.Parser.Term.syntheticHole">
                                  <AtomNode start="(527, 54)" end="(527, 55)" leading="" trailing="" val="?"/>
                                  <AtomNode start="(527, 55)" end="(527, 56)" leading="" trailing="" val="_"/>
                                </OtherNode>
                                <AtomNode start="(527, 56)" end="(527, 57)" leading="" trailing=" " val=","/>
                                <OtherNode start="(527, 58)" end="(527, 60)" kind="Lean.Parser.Term.syntheticHole">
                                  <AtomNode start="(527, 58)" end="(527, 59)" leading="" trailing="" val="?"/>
                                  <AtomNode start="(527, 59)" end="(527, 60)" leading="" trailing="" val="_"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(527, 60)" end="(527, 61)" leading="" trailing="&#10;    " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(528, 5)" end="(528, 28)" kind="Lean.cdot" state_before="case inr.intro.intro.intro.intro.h.refine_1&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]&#10;&#10;case inr.intro.intro.intro.intro.h.refine_2&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ (map f l₁)[i] &amp;lt; (map f l₂)[i]" state_after="case inr.intro.intro.intro.intro.h.refine_2&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ (map f l₁)[i] &amp;lt; (map f l₂)[i]" tactic="· simp +contextual [w₁]">
                            <OtherNode start="(528, 5)" end="(528, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(528, 5)" end="(528, 6)" kind="patternIgnore">
                                <OtherNode start="(528, 5)" end="(528, 6)" kind="token.«· »">
                                  <AtomNode start="(528, 5)" end="(528, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(528, 7)" end="(528, 28)">
                              <TacticTacticseq1IndentedNode start="(528, 7)" end="(528, 28)">
                                <NullNode start="(528, 7)" end="(528, 28)">
                                  <OtherNode start="(528, 7)" end="(528, 28)" kind="Lean.Parser.Tactic.simp" state_before="case inr.intro.intro.intro.intro.h.refine_1&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ ∀ (j : Nat) (hj : j &amp;lt; i), (map f l₁)[j] = (map f l₂)[j]" state_after="no goals" tactic="simp +contextual [w₁]">
                                    <AtomNode start="(528, 7)" end="(528, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode start="(528, 12)" end="(528, 23)" kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode start="(528, 12)" end="(528, 23)">
                                        <OtherNode start="(528, 12)" end="(528, 23)" kind="Lean.Parser.Tactic.configItem">
                                          <OtherNode start="(528, 12)" end="(528, 23)" kind="Lean.Parser.Tactic.posConfigItem">
                                            <AtomNode start="(528, 12)" end="(528, 13)" leading="" trailing="" val="+"/>
                                            <IdentNode start="(528, 13)" end="(528, 23)" leading="" trailing=" " raw_val="contextual" val="contextual"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(528, 24)" end="(528, 28)">
                                      <AtomNode start="(528, 24)" end="(528, 25)" leading="" trailing="" val="["/>
                                      <NullNode start="(528, 25)" end="(528, 27)">
                                        <OtherNode start="(528, 25)" end="(528, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(528, 25)" end="(528, 27)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(528, 27)" end="(528, 28)" leading="" trailing="&#10;    " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(529, 5)" end="(529, 27)" kind="Lean.cdot" state_before="case inr.intro.intro.intro.intro.h.refine_2&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ (map f l₁)[i] &amp;lt; (map f l₂)[i]" state_after="no goals" tactic="· simpa using w _ _ w₂">
                            <OtherNode start="(529, 5)" end="(529, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(529, 5)" end="(529, 6)" kind="patternIgnore">
                                <OtherNode start="(529, 5)" end="(529, 6)" kind="token.«· »">
                                  <AtomNode start="(529, 5)" end="(529, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(529, 7)" end="(529, 27)">
                              <TacticTacticseq1IndentedNode start="(529, 7)" end="(529, 27)">
                                <NullNode start="(529, 7)" end="(529, 27)">
                                  <OtherNode start="(529, 7)" end="(529, 27)" kind="Lean.Parser.Tactic.simpa" state_before="case inr.intro.intro.intro.intro.h.refine_2&#10;α : Type u_1&#10;β : Type u_2&#10;inst✝¹¹ : DecidableEq α&#10;inst✝¹⁰ : LT α&#10;inst✝⁹ : DecidableLT α&#10;inst✝⁸ : DecidableEq β&#10;inst✝⁷ : LT β&#10;inst✝⁶ : DecidableLT β&#10;inst✝⁵ : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝⁴ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝³ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;inst✝² : Std.Irrefl fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝¹ : Std.Asymm fun x1 x2 =&amp;gt; x1 &amp;lt; x2&#10;inst✝ : Std.Antisymm fun x1 x2 =&amp;gt; ¬x1 &amp;lt; x2&#10;l₁ l₂ : List α&#10;f : α → β&#10;w : ∀ (x y : α), x &amp;lt; y → f x &amp;lt; f y&#10;i : Nat&#10;h₁ : i &amp;lt; l₁.length&#10;h₂ : i &amp;lt; l₂.length&#10;w₁ : ∀ (j : Nat) (hj : j &amp;lt; i), l₁[j] = l₂[j]&#10;w₂ : l₁[i] &amp;lt; l₂[i]&#10;⊢ (map f l₁)[i] &amp;lt; (map f l₂)[i]" state_after="no goals" tactic="simpa using w _ _ w₂">
                                    <AtomNode start="(529, 7)" end="(529, 12)" leading="" trailing=" " val="simpa"/>
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(529, 13)" end="(529, 27)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(529, 13)" end="(529, 27)">
                                        <AtomNode start="(529, 13)" end="(529, 18)" leading="" trailing=" " val="using"/>
                                        <OtherNode start="(529, 19)" end="(529, 27)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(529, 19)" end="(529, 20)" leading="" trailing=" " raw_val="w" val="w"/>
                                          <NullNode start="(529, 21)" end="(529, 27)">
                                            <TermHoleNode start="(529, 21)" end="(529, 22)">
                                              <AtomNode start="(529, 21)" end="(529, 22)" leading="" trailing=" " val="_"/>
                                            </TermHoleNode>
                                            <TermHoleNode start="(529, 23)" end="(529, 24)">
                                              <AtomNode start="(529, 23)" end="(529, 24)" leading="" trailing=" " val="_"/>
                                            </TermHoleNode>
                                            <IdentNode start="(529, 25)" end="(529, 27)" leading="" trailing="&#10;&#10;" raw_val="w₂" val="w₂"/>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(531, 1)" end="(531, 9)" name="List">
      <AtomNode start="(531, 1)" end="(531, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(531, 5)" end="(531, 9)">
        <IdentNode start="(531, 5)" end="(531, 9)" leading="" trailing="&#10;" raw_val="List" val="List"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(12, 38)" end="(13, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(13, 39)" end="(15, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(17, 1)" end="(17, 34)" text="### Lexicographic ordering -/"/>
    <Comment start="(56, 1)" end="(58, 1)" text="-- This is named with a prime to avoid conflict with `lex [] (b :: bs) lt = true`.&#10;-- Better naming for the `Lex` vs `lex` distinction would be welcome.&#10;"/>
    <Comment start="(299, 1)" end="(299, 67)" text="Variant of `lex_eq_true_iff` using an arbitrary comparator. -/"/>
    <Comment start="(305, 1)" end="(305, 68)" text="Variant of `lex_eq_false_iff` using an arbitrary comparator. -/"/>
    <Comment start="(321, 1)" end="(328, 3)" text="`l₁` is lexicographically less than `l₂` if either&#10;- `l₁` is pairwise equivalent under `· == ·` to `l₂.take l₁.length`,&#10;  and `l₁` is shorter than `l₂` or&#10;- there exists an index `i` such that&#10;  - for all `j &lt; i`, `l₁[j] == l₂[j]` and&#10;  - `l₁[i] &lt; l₂[i]`&#10;-/"/>
    <Comment start="(375, 1)" end="(389, 3)" text="`l₁` is *not* lexicographically less than `l₂`&#10;(which you might think of as &quot;`l₂` is lexicographically greater than or equal to `l₁`&quot;&quot;) if either&#10;- `l₁` is pairwise equivalent under `· == ·` to `l₂.take l₁.length` or&#10;- there exists an index `i` such that&#10;  - for all `j &lt; i`, `l₁[j] == l₂[j]` and&#10;  - `l₂[i] &lt; l₁[i]`&#10;&#10;This formulation requires that `==` and `lt` are compatible in the following senses:&#10;- `==` is symmetric&#10;  (we unnecessarily further assume it is transitive, to make use of the existing typeclasses)&#10;- `lt` is irreflexive with respect to `==` (i.e. if `x == y` then `lt x y = false`&#10;- `lt` is asymmetric  (i.e. `lt x y = true → lt y x = false`)&#10;- `lt` is antisymmetric with respect to `==` (i.e. `lt x y = false → lt y x = false → x == y`)&#10;-/"/>
  </Comments>
</TracedFile>
