<TracedFile path="src/lean/Init/Data/List/Monadic.lean" md5="654c0edef633582359bd01d4eef86592">
  <FileNode start="(1, 1)" end="(542, 9)">
    <ModuleHeaderNode start="(6, 1)" end="(10, 29)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(10, 29)">
        <ModuleImportNode start="(9, 1)" end="(9, 31)" module="Init.Data.List.TakeDrop" path="src/lean/Init/Data/List/TakeDrop.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 31)" leading="" trailing="&#10;" raw_val="Init.Data.List.TakeDrop" val="Init.Data.List.TakeDrop"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 29)" module="Init.Data.List.Attach" path="src/lean/Init/Data/List/Attach.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 29)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.List.Attach" val="Init.Data.List.Attach"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(12, 1)" end="(14, 3)" comment="# Lemmas about `List.mapM` and `List.forM`.&#10;-/">
      <AtomNode start="(12, 1)" end="(12, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(13, 1)" end="(14, 3)" leading="" trailing="&#10;&#10;" val="# Lemmas about `List.mapM` and `List.forM`.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(16, 1)" end="(16, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(16, 1)" end="(16, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(16, 12)" end="(16, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(16, 33)" end="(16, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(17, 1)" end="(17, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(17, 1)" end="(17, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(17, 12)" end="(17, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(17, 34)" end="(17, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(19, 1)" end="(19, 15)" name="List">
      <AtomNode start="(19, 1)" end="(19, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(19, 11)" end="(19, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandOpenNode start="(21, 1)" end="(21, 9)">
      <AtomNode start="(21, 1)" end="(21, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(21, 6)" end="(21, 9)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(21, 6)" end="(21, 9)">
          <IdentNode start="(21, 6)" end="(21, 9)" leading="" trailing="&#10;&#10;" raw_val="Nat" val="Nat"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandModuledocNode start="(23, 1)" end="(23, 29)" comment="## Monadic operations -/">
      <AtomNode start="(23, 1)" end="(23, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(23, 5)" end="(23, 29)" leading="" trailing="&#10;&#10;-- We may want to replace these `simp` attributes with explicit equational lemmas,&#10;-- as we already have for all the non-monadic functions.&#10;" val="## Monadic operations -/"/>
    </CommandModuledocNode>
    <OtherNode start="(27, 1)" end="(27, 73)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(27, 1)" end="(27, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(27, 11)" end="(27, 12)" leading="" trailing="" val="["/>
      <NullNode start="(27, 12)" end="(27, 16)">
        <OtherNode start="(27, 12)" end="(27, 16)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode>
            <NullNode/>
          </TermAttrkindNode>
          <OtherNode start="(27, 12)" end="(27, 16)" kind="Lean.Parser.Attr.simp">
            <AtomNode start="(27, 12)" end="(27, 16)" leading="" trailing="" val="simp"/>
            <NullNode/>
            <NullNode/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(27, 16)" end="(27, 17)" leading="" trailing=" " val="]"/>
      <NullNode start="(27, 18)" end="(27, 73)">
        <IdentNode start="(27, 18)" end="(27, 22)" leading="" trailing=" " raw_val="mapA" val="mapA" full_name="List.mapA" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
        <IdentNode start="(27, 23)" end="(27, 27)" leading="" trailing=" " raw_val="forA" val="forA" full_name="List.forA" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
        <IdentNode start="(27, 28)" end="(27, 38)" leading="" trailing=" " raw_val="filterAuxM" val="filterAuxM" full_name="List.filterAuxM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
        <IdentNode start="(27, 39)" end="(27, 45)" leading="" trailing=" " raw_val="firstM" val="firstM" full_name="List.firstM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
        <IdentNode start="(27, 46)" end="(27, 50)" leading="" trailing=" " raw_val="anyM" val="anyM" full_name="List.anyM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
        <IdentNode start="(27, 51)" end="(27, 55)" leading="" trailing=" " raw_val="allM" val="allM" full_name="List.allM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
        <IdentNode start="(27, 56)" end="(27, 62)" leading="" trailing=" " raw_val="findM?" val="findM?" full_name="List.findM?" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
        <IdentNode start="(27, 63)" end="(27, 73)" leading="" trailing="&#10;&#10;-- Previously `mapM.loop`, `filterMapM.loop`, `forIn.loop`, `forIn'.loop`&#10;-- had attribute `@[simp]`.&#10;-- We don't currently provide simp lemmas,&#10;-- as this is an internal implementation and they don't seem to be needed.&#10;&#10;" raw_val="findSomeM?" val="findSomeM?" full_name="List.findSomeM?" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
      </NullNode>
    </OtherNode>
    <CommandModuledocNode start="(34, 1)" end="(34, 16)" comment="### mapM -/">
      <AtomNode start="(34, 1)" end="(34, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(34, 5)" end="(34, 16)" leading="" trailing="&#10;&#10;" val="### mapM -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(36, 1)" end="(46, 46)" name="mapM'" full_name="List.mapM'">
      <CommandDeclmodifiersNode start="(36, 1)" end="(43, 3)">
        <NullNode start="(36, 1)" end="(43, 3)">
          <CommandDoccommentNode start="(36, 1)" end="(43, 3)" comment="Applies the monadic action `f` on every element in the list, left-to-right, and returns the list of&#10;results.&#10;&#10;This is a non-tail-recursive variant of `List.mapM` that's easier to reason about. It cannot be used&#10;as the main definition and replaced by the tail-recursive version because they can only be proved&#10;equal when `m` is a `LawfulMonad`.&#10;-/">
            <AtomNode start="(36, 1)" end="(36, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(37, 1)" end="(43, 3)" leading="" trailing="&#10;" val="Applies the monadic action `f` on every element in the list, left-to-right, and returns the list of&#10;results.&#10;&#10;This is a non-tail-recursive variant of `List.mapM` that's easier to reason about. It cannot be used&#10;as the main definition and replaced by the tail-recursive version because they can only be proved&#10;equal when `m` is a `LawfulMonad`.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(44, 1)" end="(46, 46)" name="mapM'">
        <AtomNode start="(44, 1)" end="(44, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(44, 5)" end="(44, 10)">
          <IdentNode start="(44, 5)" end="(44, 10)" leading="" trailing=" " raw_val="mapM'" val="mapM'"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(44, 11)" end="(44, 56)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(44, 11)" end="(44, 34)">
            <OtherNode start="(44, 11)" end="(44, 20)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(44, 11)" end="(44, 12)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(44, 12)" end="(44, 19)" kind="Lean.Parser.Term.app">
                <IdentNode start="(44, 12)" end="(44, 17)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(44, 18)" end="(44, 19)">
                  <IdentNode start="(44, 18)" end="(44, 19)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(44, 19)" end="(44, 20)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(44, 21)" end="(44, 34)">
              <AtomNode start="(44, 21)" end="(44, 22)" leading="" trailing="" val="("/>
              <NullNode start="(44, 22)" end="(44, 23)">
                <IdentNode start="(44, 22)" end="(44, 23)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(44, 24)" end="(44, 33)">
                <AtomNode start="(44, 24)" end="(44, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(44, 26)" end="(44, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(44, 26)" end="(44, 27)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(44, 28)" end="(44, 29)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(44, 30)" end="(44, 33)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(44, 30)" end="(44, 31)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(44, 32)" end="(44, 33)">
                      <IdentNode start="(44, 32)" end="(44, 33)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(44, 33)" end="(44, 34)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(44, 35)" end="(44, 56)">
            <TermTypespecNode start="(44, 35)" end="(44, 56)">
              <AtomNode start="(44, 35)" end="(44, 36)" leading="" trailing=" " val=":"/>
              <OtherNode start="(44, 37)" end="(44, 56)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(44, 37)" end="(44, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(44, 37)" end="(44, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(44, 42)" end="(44, 43)">
                    <IdentNode start="(44, 42)" end="(44, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(44, 44)" end="(44, 45)" leading="" trailing=" " val="→"/>
                <OtherNode start="(44, 46)" end="(44, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(44, 46)" end="(44, 47)" leading="" trailing=" " raw_val="m" val="m"/>
                  <NullNode start="(44, 48)" end="(44, 56)">
                    <OtherNode start="(44, 48)" end="(44, 56)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(44, 48)" end="(44, 49)" leading="" trailing="" val="("/>
                      <OtherNode start="(44, 49)" end="(44, 55)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(44, 49)" end="(44, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(44, 54)" end="(44, 55)">
                          <IdentNode start="(44, 54)" end="(44, 55)" leading="" trailing="" raw_val="β" val="β"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(44, 55)" end="(44, 56)" leading="" trailing="&#10;  " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvaleqnsNode start="(45, 3)" end="(46, 46)">
          <OtherNode start="(45, 3)" end="(46, 46)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(45, 3)" end="(46, 46)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(45, 3)" end="(46, 46)">
                <OtherNode start="(45, 3)" end="(45, 18)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(45, 3)" end="(45, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(45, 5)" end="(45, 7)">
                    <NullNode start="(45, 5)" end="(45, 7)">
                      <OtherNode start="(45, 5)" end="(45, 7)" kind="«term[_]»">
                        <AtomNode start="(45, 5)" end="(45, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(45, 6)" end="(45, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(45, 8)" end="(45, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(45, 11)" end="(45, 18)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(45, 11)" end="(45, 15)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(45, 16)" end="(45, 18)">
                      <OtherNode start="(45, 16)" end="(45, 18)" kind="«term[_]»">
                        <AtomNode start="(45, 16)" end="(45, 17)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(45, 17)" end="(45, 18)" leading="" trailing="&#10;  " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(46, 3)" end="(46, 46)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(46, 3)" end="(46, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(46, 5)" end="(46, 11)">
                    <NullNode start="(46, 5)" end="(46, 11)">
                      <OtherNode start="(46, 5)" end="(46, 11)" kind="«term_::_»">
                        <IdentNode start="(46, 5)" end="(46, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(46, 7)" end="(46, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(46, 10)" end="(46, 11)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(46, 12)" end="(46, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(46, 15)" end="(46, 46)" kind="Lean.Parser.Term.termReturn">
                    <AtomNode start="(46, 15)" end="(46, 21)" leading="" trailing=" " val="return"/>
                    <NullNode start="(46, 22)" end="(46, 46)">
                      <OtherNode start="(46, 22)" end="(46, 46)" kind="«term_::_»">
                        <OtherNode start="(46, 22)" end="(46, 29)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(46, 22)" end="(46, 23)" leading="" trailing="" val="("/>
                          <OtherNode start="(46, 23)" end="(46, 28)" kind="Lean.Parser.Term.liftMethod">
                            <AtomNode start="(46, 23)" end="(46, 24)" leading="" trailing=" " val="←"/>
                            <OtherNode start="(46, 25)" end="(46, 28)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(46, 25)" end="(46, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(46, 27)" end="(46, 28)">
                                <IdentNode start="(46, 27)" end="(46, 28)" leading="" trailing="" raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(46, 28)" end="(46, 29)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(46, 30)" end="(46, 32)" leading="" trailing=" " val="::"/>
                        <OtherNode start="(46, 33)" end="(46, 46)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(46, 33)" end="(46, 34)" leading="" trailing="" val="("/>
                          <OtherNode start="(46, 34)" end="(46, 45)" kind="Lean.Parser.Term.liftMethod">
                            <AtomNode start="(46, 34)" end="(46, 35)" leading="" trailing=" " val="←"/>
                            <OtherNode start="(46, 36)" end="(46, 45)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(46, 36)" end="(46, 43)" leading="" trailing=" " raw_val="l.mapM'" val="l.mapM'"/>
                              <NullNode start="(46, 44)" end="(46, 45)">
                                <IdentNode start="(46, 44)" end="(46, 45)" leading="" trailing="" raw_val="f" val="f"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(46, 45)" end="(46, 46)" leading="" trailing="&#10;&#10;" val=")"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(48, 1)" end="(48, 80)" name="mapM'_nil" full_name="List.mapM'_nil">
      <CommandDeclmodifiersNode start="(48, 1)" end="(48, 8)">
        <NullNode/>
        <NullNode start="(48, 1)" end="(48, 8)">
          <OtherNode start="(48, 1)" end="(48, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(48, 1)" end="(48, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(48, 3)" end="(48, 7)">
              <OtherNode start="(48, 3)" end="(48, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(48, 3)" end="(48, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(48, 3)" end="(48, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(48, 7)" end="(48, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(48, 9)" end="(48, 80)" name="mapM'_nil" full_name="List.mapM'_nil" _is_private_decl="False">
        <AtomNode start="(48, 9)" end="(48, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(48, 17)" end="(48, 26)">
          <IdentNode start="(48, 17)" end="(48, 26)" leading="" trailing=" " raw_val="mapM'_nil" val="mapM'_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(48, 27)" end="(48, 73)">
          <NullNode start="(48, 27)" end="(48, 50)">
            <OtherNode start="(48, 27)" end="(48, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(48, 27)" end="(48, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(48, 28)" end="(48, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(48, 28)" end="(48, 33)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(48, 34)" end="(48, 35)">
                  <IdentNode start="(48, 34)" end="(48, 35)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(48, 35)" end="(48, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(48, 37)" end="(48, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(48, 37)" end="(48, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(48, 38)" end="(48, 39)">
                <IdentNode start="(48, 38)" end="(48, 39)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(48, 40)" end="(48, 49)">
                <AtomNode start="(48, 40)" end="(48, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(48, 42)" end="(48, 49)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(48, 42)" end="(48, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(48, 44)" end="(48, 45)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(48, 46)" end="(48, 49)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(48, 46)" end="(48, 47)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(48, 48)" end="(48, 49)">
                      <IdentNode start="(48, 48)" end="(48, 49)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(48, 49)" end="(48, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(48, 51)" end="(48, 73)">
            <AtomNode start="(48, 51)" end="(48, 52)" leading="" trailing=" " val=":"/>
            <OtherNode start="(48, 53)" end="(48, 73)" kind="«term_=_»">
              <OtherNode start="(48, 53)" end="(48, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(48, 53)" end="(48, 58)" leading="" trailing=" " raw_val="mapM'" val="mapM'" full_name="List.mapM'" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(44, 5)" def_end="(44, 10)"/>
                <NullNode start="(48, 59)" end="(48, 63)">
                  <IdentNode start="(48, 59)" end="(48, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(48, 61)" end="(48, 63)" kind="«term[_]»">
                    <AtomNode start="(48, 61)" end="(48, 62)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(48, 62)" end="(48, 63)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(48, 64)" end="(48, 65)" leading="" trailing=" " val="="/>
              <OtherNode start="(48, 66)" end="(48, 73)" kind="Lean.Parser.Term.app">
                <IdentNode start="(48, 66)" end="(48, 70)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(48, 71)" end="(48, 73)">
                  <OtherNode start="(48, 71)" end="(48, 73)" kind="«term[_]»">
                    <AtomNode start="(48, 71)" end="(48, 72)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(48, 72)" end="(48, 73)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(48, 74)" end="(48, 80)">
          <AtomNode start="(48, 74)" end="(48, 76)" leading="" trailing=" " val=":="/>
          <IdentNode start="(48, 77)" end="(48, 80)" leading="" trailing="&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(49, 1)" end="(51, 6)" name="mapM'_cons" full_name="List.mapM'_cons">
      <CommandDeclmodifiersNode start="(49, 1)" end="(49, 8)">
        <NullNode/>
        <NullNode start="(49, 1)" end="(49, 8)">
          <OtherNode start="(49, 1)" end="(49, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(49, 1)" end="(49, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(49, 3)" end="(49, 7)">
              <OtherNode start="(49, 3)" end="(49, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(49, 3)" end="(49, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(49, 3)" end="(49, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(49, 7)" end="(49, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(49, 9)" end="(51, 6)" name="mapM'_cons" full_name="List.mapM'_cons" _is_private_decl="False">
        <AtomNode start="(49, 9)" end="(49, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(49, 17)" end="(49, 27)">
          <IdentNode start="(49, 17)" end="(49, 27)" leading="" trailing=" " raw_val="mapM'_cons" val="mapM'_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(49, 28)" end="(50, 57)">
          <NullNode start="(49, 28)" end="(49, 51)">
            <OtherNode start="(49, 28)" end="(49, 37)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(49, 28)" end="(49, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(49, 29)" end="(49, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(49, 29)" end="(49, 34)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(49, 35)" end="(49, 36)">
                  <IdentNode start="(49, 35)" end="(49, 36)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(49, 36)" end="(49, 37)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(49, 38)" end="(49, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(49, 38)" end="(49, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(49, 39)" end="(49, 40)">
                <IdentNode start="(49, 39)" end="(49, 40)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(49, 41)" end="(49, 50)">
                <AtomNode start="(49, 41)" end="(49, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(49, 43)" end="(49, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(49, 43)" end="(49, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(49, 45)" end="(49, 46)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(49, 47)" end="(49, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(49, 47)" end="(49, 48)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(49, 49)" end="(49, 50)">
                      <IdentNode start="(49, 49)" end="(49, 50)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(49, 50)" end="(49, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(49, 52)" end="(50, 57)">
            <AtomNode start="(49, 52)" end="(49, 53)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(50, 5)" end="(50, 57)" kind="«term_=_»">
              <OtherNode start="(50, 5)" end="(50, 21)" kind="Lean.Parser.Term.app">
                <IdentNode start="(50, 5)" end="(50, 10)" leading="" trailing=" " raw_val="mapM'" val="mapM'" full_name="List.mapM'" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(44, 5)" def_end="(44, 10)"/>
                <NullNode start="(50, 11)" end="(50, 21)">
                  <IdentNode start="(50, 11)" end="(50, 12)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(50, 13)" end="(50, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(50, 13)" end="(50, 14)" leading="" trailing="" val="("/>
                    <OtherNode start="(50, 14)" end="(50, 20)" kind="«term_::_»">
                      <IdentNode start="(50, 14)" end="(50, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(50, 16)" end="(50, 18)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(50, 19)" end="(50, 20)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(50, 20)" end="(50, 21)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(50, 22)" end="(50, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(50, 24)" end="(50, 57)" kind="Lean.Parser.Term.termReturn">
                <AtomNode start="(50, 24)" end="(50, 30)" leading="" trailing=" " val="return"/>
                <NullNode start="(50, 31)" end="(50, 57)">
                  <OtherNode start="(50, 31)" end="(50, 57)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(50, 31)" end="(50, 32)" leading="" trailing="" val="("/>
                    <OtherNode start="(50, 32)" end="(50, 56)" kind="«term_::_»">
                      <OtherNode start="(50, 32)" end="(50, 39)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(50, 32)" end="(50, 33)" leading="" trailing="" val="("/>
                        <OtherNode start="(50, 33)" end="(50, 38)" kind="Lean.Parser.Term.liftMethod">
                          <AtomNode start="(50, 33)" end="(50, 34)" leading="" trailing=" " val="←"/>
                          <OtherNode start="(50, 35)" end="(50, 38)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(50, 35)" end="(50, 36)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(50, 37)" end="(50, 38)">
                              <IdentNode start="(50, 37)" end="(50, 38)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(50, 38)" end="(50, 39)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <AtomNode start="(50, 40)" end="(50, 42)" leading="" trailing=" " val="::"/>
                      <OtherNode start="(50, 43)" end="(50, 56)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(50, 43)" end="(50, 44)" leading="" trailing="" val="("/>
                        <OtherNode start="(50, 44)" end="(50, 55)" kind="Lean.Parser.Term.liftMethod">
                          <AtomNode start="(50, 44)" end="(50, 45)" leading="" trailing=" " val="←"/>
                          <OtherNode start="(50, 46)" end="(50, 55)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(50, 46)" end="(50, 53)" leading="" trailing=" " raw_val="l.mapM'" val="l.mapM'"/>
                            <NullNode start="(50, 54)" end="(50, 55)">
                              <IdentNode start="(50, 54)" end="(50, 55)" leading="" trailing="" raw_val="f" val="f"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(50, 55)" end="(50, 56)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(50, 56)" end="(50, 57)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(50, 58)" end="(51, 6)">
          <AtomNode start="(50, 58)" end="(50, 60)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(51, 3)" end="(51, 6)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(53, 1)" end="(57, 52)" name="mapM'_eq_mapM" full_name="List.mapM'_eq_mapM">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(53, 1)" end="(57, 52)" name="mapM'_eq_mapM" full_name="List.mapM'_eq_mapM" _is_private_decl="False">
        <AtomNode start="(53, 1)" end="(53, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(53, 9)" end="(53, 22)">
          <IdentNode start="(53, 9)" end="(53, 22)" leading="" trailing=" " raw_val="mapM'_eq_mapM" val="mapM'_eq_mapM"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(53, 23)" end="(54, 25)">
          <NullNode start="(53, 23)" end="(53, 75)">
            <OtherNode start="(53, 23)" end="(53, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(53, 23)" end="(53, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(53, 24)" end="(53, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(53, 24)" end="(53, 29)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(53, 30)" end="(53, 31)">
                  <IdentNode start="(53, 30)" end="(53, 31)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(53, 31)" end="(53, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(53, 33)" end="(53, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(53, 33)" end="(53, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(53, 34)" end="(53, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(53, 34)" end="(53, 45)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(53, 46)" end="(53, 47)">
                  <IdentNode start="(53, 46)" end="(53, 47)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(53, 47)" end="(53, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(53, 49)" end="(53, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(53, 49)" end="(53, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(53, 50)" end="(53, 51)">
                <IdentNode start="(53, 50)" end="(53, 51)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(53, 52)" end="(53, 61)">
                <AtomNode start="(53, 52)" end="(53, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(53, 54)" end="(53, 61)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(53, 54)" end="(53, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(53, 56)" end="(53, 57)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(53, 58)" end="(53, 61)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(53, 58)" end="(53, 59)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(53, 60)" end="(53, 61)">
                      <IdentNode start="(53, 60)" end="(53, 61)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(53, 61)" end="(53, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(53, 63)" end="(53, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(53, 63)" end="(53, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(53, 64)" end="(53, 65)">
                <IdentNode start="(53, 64)" end="(53, 65)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(53, 66)" end="(53, 74)">
                <AtomNode start="(53, 66)" end="(53, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(53, 68)" end="(53, 74)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(53, 68)" end="(53, 72)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(53, 73)" end="(53, 74)">
                    <IdentNode start="(53, 73)" end="(53, 74)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(53, 74)" end="(53, 75)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(53, 76)" end="(54, 25)">
            <AtomNode start="(53, 76)" end="(53, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(54, 5)" end="(54, 25)" kind="«term_=_»">
              <OtherNode start="(54, 5)" end="(54, 14)" kind="Lean.Parser.Term.app">
                <IdentNode start="(54, 5)" end="(54, 10)" leading="" trailing=" " raw_val="mapM'" val="mapM'" full_name="List.mapM'" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(44, 5)" def_end="(44, 10)"/>
                <NullNode start="(54, 11)" end="(54, 14)">
                  <IdentNode start="(54, 11)" end="(54, 12)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(54, 13)" end="(54, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(54, 15)" end="(54, 16)" leading="" trailing=" " val="="/>
              <OtherNode start="(54, 17)" end="(54, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(54, 17)" end="(54, 21)" leading="" trailing=" " raw_val="mapM" val="mapM" full_name="List.mapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                <NullNode start="(54, 22)" end="(54, 25)">
                  <IdentNode start="(54, 22)" end="(54, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(54, 24)" end="(54, 25)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(54, 26)" end="(57, 52)">
          <AtomNode start="(54, 26)" end="(54, 28)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(54, 29)" end="(54, 47)">
            <AtomNode start="(54, 29)" end="(54, 31)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(54, 32)" end="(54, 47)">
              <TacticTacticseq1IndentedNode start="(54, 32)" end="(54, 47)">
                <NullNode start="(54, 32)" end="(54, 47)">
                  <OtherNode start="(54, 32)" end="(54, 47)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;l : List α&#10;⊢ mapM' f l = mapM f l" state_after="no goals" tactic="simp [go, mapM]">
                    <AtomNode start="(54, 32)" end="(54, 36)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(54, 37)" end="(54, 47)">
                      <AtomNode start="(54, 37)" end="(54, 38)" leading="" trailing="" val="["/>
                      <NullNode start="(54, 38)" end="(54, 46)">
                        <OtherNode start="(54, 38)" end="(54, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(54, 38)" end="(54, 40)" leading="" trailing="" raw_val="go" val="go"/>
                        </OtherNode>
                        <AtomNode start="(54, 40)" end="(54, 41)" leading="" trailing=" " val=","/>
                        <OtherNode start="(54, 42)" end="(54, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(54, 42)" end="(54, 46)" leading="" trailing="" raw_val="mapM" val="mapM" full_name="List.mapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(54, 46)" end="(54, 47)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(54, 48)" end="(57, 52)">
            <OtherNode start="(54, 48)" end="(57, 52)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(54, 48)" end="(54, 53)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(55, 3)" end="(57, 52)">
                <OtherNode start="(55, 3)" end="(57, 52)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(55, 3)" end="(57, 52)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(55, 3)" end="(57, 52)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(55, 3)" end="(55, 5)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(55, 6)" end="(55, 72)">
                        <TermTypespecNode start="(55, 6)" end="(55, 72)">
                          <AtomNode start="(55, 6)" end="(55, 7)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(55, 8)" end="(55, 72)" kind="Lean.Parser.Term.forall">
                            <AtomNode start="(55, 8)" end="(55, 9)" leading="" trailing=" " val="∀"/>
                            <NullNode start="(55, 10)" end="(55, 15)">
                              <IdentNode start="(55, 10)" end="(55, 11)" leading="" trailing=" " raw_val="l" val="l"/>
                              <IdentNode start="(55, 12)" end="(55, 15)" leading="" trailing="" raw_val="acc" val="acc"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(55, 15)" end="(55, 16)" leading="" trailing=" " val=","/>
                            <OtherNode start="(55, 17)" end="(55, 72)" kind="«term_=_»">
                              <OtherNode start="(55, 17)" end="(55, 34)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(55, 17)" end="(55, 26)" leading="" trailing=" " raw_val="mapM.loop" val="mapM.loop" full_name="List.mapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                <NullNode start="(55, 27)" end="(55, 34)">
                                  <IdentNode start="(55, 27)" end="(55, 28)" leading="" trailing=" " raw_val="f" val="f"/>
                                  <IdentNode start="(55, 29)" end="(55, 30)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(55, 31)" end="(55, 34)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(55, 35)" end="(55, 36)" leading="" trailing=" " val="="/>
                              <OtherNode start="(55, 37)" end="(55, 72)" kind="Lean.Parser.Term.termReturn">
                                <AtomNode start="(55, 37)" end="(55, 43)" leading="" trailing=" " val="return"/>
                                <NullNode start="(55, 44)" end="(55, 72)">
                                  <OtherNode start="(55, 44)" end="(55, 72)" kind="«term_++_»">
                                    <IdentNode start="(55, 44)" end="(55, 55)" leading="" trailing=" " raw_val="acc.reverse" val="acc.reverse"/>
                                    <AtomNode start="(55, 56)" end="(55, 58)" leading="" trailing=" " val="++"/>
                                    <OtherNode start="(55, 59)" end="(55, 72)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(55, 59)" end="(55, 60)" leading="" trailing="" val="("/>
                                      <OtherNode start="(55, 60)" end="(55, 71)" kind="Lean.Parser.Term.liftMethod">
                                        <AtomNode start="(55, 60)" end="(55, 61)" leading="" trailing=" " val="←"/>
                                        <OtherNode start="(55, 62)" end="(55, 71)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(55, 62)" end="(55, 67)" leading="" trailing=" " raw_val="mapM'" val="mapM'" full_name="List.mapM'" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(44, 5)" def_end="(44, 10)"/>
                                          <NullNode start="(55, 68)" end="(55, 71)">
                                            <IdentNode start="(55, 68)" end="(55, 69)" leading="" trailing=" " raw_val="f" val="f"/>
                                            <IdentNode start="(55, 70)" end="(55, 71)" leading="" trailing="" raw_val="l" val="l"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(55, 71)" end="(55, 72)" leading="" trailing="&#10;    " val=")"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(56, 5)" end="(57, 52)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(56, 5)" end="(57, 52)">
                          <OtherNode start="(56, 5)" end="(56, 44)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(56, 5)" end="(56, 6)" leading="" trailing=" " val="|"/>
                            <NullNode start="(56, 7)" end="(56, 14)">
                              <NullNode start="(56, 7)" end="(56, 14)">
                                <OtherNode start="(56, 7)" end="(56, 9)" kind="«term[_]»">
                                  <AtomNode start="(56, 7)" end="(56, 8)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(56, 8)" end="(56, 9)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(56, 9)" end="(56, 10)" leading="" trailing=" " val=","/>
                                <IdentNode start="(56, 11)" end="(56, 14)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(56, 15)" end="(56, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                            <TermBytacticNode start="(56, 18)" end="(56, 44)">
                              <AtomNode start="(56, 18)" end="(56, 20)" leading="" trailing=" " val="by"/>
                              <TacticTacticseqNode start="(56, 21)" end="(56, 44)">
                                <TacticTacticseq1IndentedNode start="(56, 21)" end="(56, 44)">
                                  <NullNode start="(56, 21)" end="(56, 44)">
                                    <OtherNode start="(56, 21)" end="(56, 44)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;l : List α&#10;acc : List β&#10;⊢ mapM.loop f [] acc = do&#10;    let __do_lift ← mapM' f []&#10;    pure (acc.reverse ++ __do_lift)" state_after="no goals" tactic="simp [mapM.loop, mapM']">
                                      <AtomNode start="(56, 21)" end="(56, 25)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(56, 26)" end="(56, 44)">
                                        <AtomNode start="(56, 26)" end="(56, 27)" leading="" trailing="" val="["/>
                                        <NullNode start="(56, 27)" end="(56, 43)">
                                          <OtherNode start="(56, 27)" end="(56, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(56, 27)" end="(56, 36)" leading="" trailing="" raw_val="mapM.loop" val="mapM.loop" full_name="List.mapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(56, 36)" end="(56, 37)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(56, 38)" end="(56, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(56, 38)" end="(56, 43)" leading="" trailing="" raw_val="mapM'" val="mapM'" full_name="List.mapM'" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(44, 5)" def_end="(44, 10)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(56, 43)" end="(56, 44)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </TermBytacticNode>
                          </OtherNode>
                          <OtherNode start="(57, 5)" end="(57, 52)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(57, 5)" end="(57, 6)" leading="" trailing=" " val="|"/>
                            <NullNode start="(57, 7)" end="(57, 16)">
                              <NullNode start="(57, 7)" end="(57, 16)">
                                <OtherNode start="(57, 7)" end="(57, 11)" kind="«term_::_»">
                                  <IdentNode start="(57, 7)" end="(57, 8)" leading="" trailing="" raw_val="a" val="a"/>
                                  <AtomNode start="(57, 8)" end="(57, 10)" leading="" trailing="" val="::"/>
                                  <IdentNode start="(57, 10)" end="(57, 11)" leading="" trailing="" raw_val="l" val="l"/>
                                </OtherNode>
                                <AtomNode start="(57, 11)" end="(57, 12)" leading="" trailing=" " val=","/>
                                <IdentNode start="(57, 13)" end="(57, 16)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(57, 17)" end="(57, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                            <TermBytacticNode start="(57, 20)" end="(57, 52)">
                              <AtomNode start="(57, 20)" end="(57, 22)" leading="" trailing=" " val="by"/>
                              <TacticTacticseqNode start="(57, 23)" end="(57, 52)">
                                <TacticTacticseq1IndentedNode start="(57, 23)" end="(57, 52)">
                                  <NullNode start="(57, 23)" end="(57, 52)">
                                    <OtherNode start="(57, 23)" end="(57, 52)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;l✝ : List α&#10;a : α&#10;l : List α&#10;acc : List β&#10;⊢ mapM.loop f (a :: l) acc = do&#10;    let __do_lift ← mapM' f (a :: l)&#10;    pure (acc.reverse ++ __do_lift)" state_after="no goals" tactic="simp [go l, mapM.loop, mapM']">
                                      <AtomNode start="(57, 23)" end="(57, 27)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(57, 28)" end="(57, 52)">
                                        <AtomNode start="(57, 28)" end="(57, 29)" leading="" trailing="" val="["/>
                                        <NullNode start="(57, 29)" end="(57, 51)">
                                          <OtherNode start="(57, 29)" end="(57, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <OtherNode start="(57, 29)" end="(57, 33)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(57, 29)" end="(57, 31)" leading="" trailing=" " raw_val="go" val="go"/>
                                              <NullNode start="(57, 32)" end="(57, 33)">
                                                <IdentNode start="(57, 32)" end="(57, 33)" leading="" trailing="" raw_val="l" val="l"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(57, 33)" end="(57, 34)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(57, 35)" end="(57, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(57, 35)" end="(57, 44)" leading="" trailing="" raw_val="mapM.loop" val="mapM.loop" full_name="List.mapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(57, 44)" end="(57, 45)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(57, 46)" end="(57, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(57, 46)" end="(57, 51)" leading="" trailing="" raw_val="mapM'" val="mapM'" full_name="List.mapM'" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(44, 5)" def_end="(44, 10)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(57, 51)" end="(57, 52)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </TermBytacticNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(59, 1)" end="(59, 78)" name="mapM_nil" full_name="List.mapM_nil">
      <CommandDeclmodifiersNode start="(59, 1)" end="(59, 8)">
        <NullNode/>
        <NullNode start="(59, 1)" end="(59, 8)">
          <OtherNode start="(59, 1)" end="(59, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(59, 1)" end="(59, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(59, 3)" end="(59, 7)">
              <OtherNode start="(59, 3)" end="(59, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(59, 3)" end="(59, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(59, 3)" end="(59, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(59, 7)" end="(59, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(59, 9)" end="(59, 78)" name="mapM_nil" full_name="List.mapM_nil" _is_private_decl="False">
        <AtomNode start="(59, 9)" end="(59, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(59, 17)" end="(59, 25)">
          <IdentNode start="(59, 17)" end="(59, 25)" leading="" trailing=" " raw_val="mapM_nil" val="mapM_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(59, 26)" end="(59, 71)">
          <NullNode start="(59, 26)" end="(59, 49)">
            <OtherNode start="(59, 26)" end="(59, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(59, 26)" end="(59, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(59, 27)" end="(59, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(59, 27)" end="(59, 32)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(59, 33)" end="(59, 34)">
                  <IdentNode start="(59, 33)" end="(59, 34)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(59, 34)" end="(59, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(59, 36)" end="(59, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(59, 36)" end="(59, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(59, 37)" end="(59, 38)">
                <IdentNode start="(59, 37)" end="(59, 38)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(59, 39)" end="(59, 48)">
                <AtomNode start="(59, 39)" end="(59, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(59, 41)" end="(59, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(59, 41)" end="(59, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(59, 43)" end="(59, 44)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(59, 45)" end="(59, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(59, 45)" end="(59, 46)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(59, 47)" end="(59, 48)">
                      <IdentNode start="(59, 47)" end="(59, 48)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(59, 48)" end="(59, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(59, 50)" end="(59, 71)">
            <AtomNode start="(59, 50)" end="(59, 51)" leading="" trailing=" " val=":"/>
            <OtherNode start="(59, 52)" end="(59, 71)" kind="«term_=_»">
              <OtherNode start="(59, 52)" end="(59, 61)" kind="Lean.Parser.Term.app">
                <OtherNode start="(59, 52)" end="(59, 59)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(59, 52)" end="(59, 54)" kind="«term[_]»">
                    <AtomNode start="(59, 52)" end="(59, 53)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(59, 53)" end="(59, 54)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(59, 54)" end="(59, 55)" leading="" trailing="" val="."/>
                  <IdentNode start="(59, 55)" end="(59, 59)" leading="" trailing=" " raw_val="mapM" val="mapM" full_name="List.mapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(59, 60)" end="(59, 61)">
                  <IdentNode start="(59, 60)" end="(59, 61)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(59, 62)" end="(59, 63)" leading="" trailing=" " val="="/>
              <OtherNode start="(59, 64)" end="(59, 71)" kind="Lean.Parser.Term.app">
                <IdentNode start="(59, 64)" end="(59, 68)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(59, 69)" end="(59, 71)">
                  <OtherNode start="(59, 69)" end="(59, 71)" kind="«term[_]»">
                    <AtomNode start="(59, 69)" end="(59, 70)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(59, 70)" end="(59, 71)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(59, 72)" end="(59, 78)">
          <AtomNode start="(59, 72)" end="(59, 74)" leading="" trailing=" " val=":="/>
          <IdentNode start="(59, 75)" end="(59, 78)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(61, 1)" end="(62, 91)" name="mapM_cons" full_name="List.mapM_cons">
      <CommandDeclmodifiersNode start="(61, 1)" end="(61, 8)">
        <NullNode/>
        <NullNode start="(61, 1)" end="(61, 8)">
          <OtherNode start="(61, 1)" end="(61, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(61, 1)" end="(61, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(61, 3)" end="(61, 7)">
              <OtherNode start="(61, 3)" end="(61, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(61, 3)" end="(61, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(61, 3)" end="(61, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(61, 7)" end="(61, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(61, 9)" end="(62, 91)" name="mapM_cons" full_name="List.mapM_cons" _is_private_decl="False">
        <AtomNode start="(61, 9)" end="(61, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(61, 17)" end="(61, 26)">
          <IdentNode start="(61, 17)" end="(61, 26)" leading="" trailing=" " raw_val="mapM_cons" val="mapM_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(61, 27)" end="(62, 55)">
          <NullNode start="(61, 27)" end="(61, 66)">
            <OtherNode start="(61, 27)" end="(61, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(61, 27)" end="(61, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(61, 28)" end="(61, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(61, 28)" end="(61, 33)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(61, 34)" end="(61, 35)">
                  <IdentNode start="(61, 34)" end="(61, 35)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(61, 35)" end="(61, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(61, 37)" end="(61, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(61, 37)" end="(61, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(61, 38)" end="(61, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(61, 38)" end="(61, 49)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(61, 50)" end="(61, 51)">
                  <IdentNode start="(61, 50)" end="(61, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(61, 51)" end="(61, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(61, 53)" end="(61, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(61, 53)" end="(61, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(61, 54)" end="(61, 55)">
                <IdentNode start="(61, 54)" end="(61, 55)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(61, 56)" end="(61, 65)">
                <AtomNode start="(61, 56)" end="(61, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(61, 58)" end="(61, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(61, 58)" end="(61, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(61, 60)" end="(61, 61)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(61, 62)" end="(61, 65)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(61, 62)" end="(61, 63)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(61, 64)" end="(61, 65)">
                      <IdentNode start="(61, 64)" end="(61, 65)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(61, 65)" end="(61, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(61, 67)" end="(62, 55)">
            <AtomNode start="(61, 67)" end="(61, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(62, 5)" end="(62, 55)" kind="«term_=_»">
              <OtherNode start="(62, 5)" end="(62, 20)" kind="Lean.Parser.Term.app">
                <OtherNode start="(62, 5)" end="(62, 18)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(62, 5)" end="(62, 13)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(62, 5)" end="(62, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(62, 6)" end="(62, 12)" kind="«term_::_»">
                      <IdentNode start="(62, 6)" end="(62, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(62, 8)" end="(62, 10)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(62, 11)" end="(62, 12)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(62, 12)" end="(62, 13)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(62, 13)" end="(62, 14)" leading="" trailing="" val="."/>
                  <IdentNode start="(62, 14)" end="(62, 18)" leading="" trailing=" " raw_val="mapM" val="mapM" full_name="List.mapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(62, 19)" end="(62, 20)">
                  <IdentNode start="(62, 19)" end="(62, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(62, 21)" end="(62, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(62, 23)" end="(62, 55)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(62, 23)" end="(62, 24)" leading="" trailing="" val="("/>
                <OtherNode start="(62, 24)" end="(62, 54)" kind="Lean.Parser.Term.termReturn">
                  <AtomNode start="(62, 24)" end="(62, 30)" leading="" trailing=" " val="return"/>
                  <NullNode start="(62, 31)" end="(62, 54)">
                    <OtherNode start="(62, 31)" end="(62, 54)" kind="«term_::_»">
                      <OtherNode start="(62, 31)" end="(62, 38)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(62, 31)" end="(62, 32)" leading="" trailing="" val="("/>
                        <OtherNode start="(62, 32)" end="(62, 37)" kind="Lean.Parser.Term.liftMethod">
                          <AtomNode start="(62, 32)" end="(62, 33)" leading="" trailing=" " val="←"/>
                          <OtherNode start="(62, 34)" end="(62, 37)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(62, 34)" end="(62, 35)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(62, 36)" end="(62, 37)">
                              <IdentNode start="(62, 36)" end="(62, 37)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(62, 37)" end="(62, 38)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <AtomNode start="(62, 39)" end="(62, 41)" leading="" trailing=" " val="::"/>
                      <OtherNode start="(62, 42)" end="(62, 54)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(62, 42)" end="(62, 43)" leading="" trailing="" val="("/>
                        <OtherNode start="(62, 43)" end="(62, 53)" kind="Lean.Parser.Term.liftMethod">
                          <AtomNode start="(62, 43)" end="(62, 44)" leading="" trailing=" " val="←"/>
                          <OtherNode start="(62, 45)" end="(62, 53)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(62, 45)" end="(62, 51)" leading="" trailing=" " raw_val="l.mapM" val="l.mapM"/>
                            <NullNode start="(62, 52)" end="(62, 53)">
                              <IdentNode start="(62, 52)" end="(62, 53)" leading="" trailing="" raw_val="f" val="f"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(62, 53)" end="(62, 54)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(62, 54)" end="(62, 55)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(62, 56)" end="(62, 91)">
          <AtomNode start="(62, 56)" end="(62, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(62, 59)" end="(62, 91)">
            <AtomNode start="(62, 59)" end="(62, 61)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(62, 62)" end="(62, 91)">
              <TacticTacticseq1IndentedNode start="(62, 62)" end="(62, 91)">
                <NullNode start="(62, 62)" end="(62, 91)">
                  <OtherNode start="(62, 62)" end="(62, 91)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;⊢ mapM f (a :: l) = do&#10;    let __do_lift ← f a&#10;    let __do_lift_1 ← mapM f l&#10;    pure (__do_lift :: __do_lift_1)" state_after="no goals" tactic="simp [← mapM'_eq_mapM, mapM']">
                    <AtomNode start="(62, 62)" end="(62, 66)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(62, 67)" end="(62, 91)">
                      <AtomNode start="(62, 67)" end="(62, 68)" leading="" trailing="" val="["/>
                      <NullNode start="(62, 68)" end="(62, 90)">
                        <OtherNode start="(62, 68)" end="(62, 83)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(62, 68)" end="(62, 69)">
                            <OtherNode start="(62, 68)" end="(62, 69)" kind="patternIgnore">
                              <OtherNode start="(62, 68)" end="(62, 69)" kind="token.«← »">
                                <AtomNode start="(62, 68)" end="(62, 69)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(62, 70)" end="(62, 83)" leading="" trailing="" raw_val="mapM'_eq_mapM" val="mapM'_eq_mapM" full_name="List.mapM'_eq_mapM" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(53, 9)" def_end="(53, 22)"/>
                        </OtherNode>
                        <AtomNode start="(62, 83)" end="(62, 84)" leading="" trailing=" " val=","/>
                        <OtherNode start="(62, 85)" end="(62, 90)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(62, 85)" end="(62, 90)" leading="" trailing="" raw_val="mapM'" val="mapM'" full_name="List.mapM'" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(44, 5)" def_end="(44, 10)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(62, 90)" end="(62, 91)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(64, 1)" end="(66, 27)" name="mapM_pure" full_name="List.mapM_pure">
      <CommandDeclmodifiersNode start="(64, 1)" end="(64, 8)">
        <NullNode/>
        <NullNode start="(64, 1)" end="(64, 8)">
          <OtherNode start="(64, 1)" end="(64, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(64, 1)" end="(64, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(64, 3)" end="(64, 7)">
              <OtherNode start="(64, 3)" end="(64, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(64, 3)" end="(64, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(64, 3)" end="(64, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(64, 7)" end="(64, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(64, 9)" end="(66, 27)" name="mapM_pure" full_name="List.mapM_pure" _is_private_decl="False">
        <AtomNode start="(64, 9)" end="(64, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(64, 17)" end="(64, 26)">
          <IdentNode start="(64, 17)" end="(64, 26)" leading="" trailing=" " raw_val="mapM_pure" val="mapM_pure"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(64, 27)" end="(65, 51)">
          <NullNode start="(64, 27)" end="(64, 77)">
            <OtherNode start="(64, 27)" end="(64, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(64, 27)" end="(64, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(64, 28)" end="(64, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(64, 28)" end="(64, 33)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(64, 34)" end="(64, 35)">
                  <IdentNode start="(64, 34)" end="(64, 35)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(64, 35)" end="(64, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(64, 37)" end="(64, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(64, 37)" end="(64, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(64, 38)" end="(64, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(64, 38)" end="(64, 49)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(64, 50)" end="(64, 51)">
                  <IdentNode start="(64, 50)" end="(64, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(64, 51)" end="(64, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(64, 53)" end="(64, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(64, 53)" end="(64, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(64, 54)" end="(64, 55)">
                <IdentNode start="(64, 54)" end="(64, 55)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(64, 56)" end="(64, 64)">
                <AtomNode start="(64, 56)" end="(64, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(64, 58)" end="(64, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(64, 58)" end="(64, 62)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(64, 63)" end="(64, 64)">
                    <IdentNode start="(64, 63)" end="(64, 64)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(64, 64)" end="(64, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(64, 66)" end="(64, 77)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(64, 66)" end="(64, 67)" leading="" trailing="" val="{"/>
              <NullNode start="(64, 67)" end="(64, 68)">
                <IdentNode start="(64, 67)" end="(64, 68)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(64, 69)" end="(64, 76)">
                <AtomNode start="(64, 69)" end="(64, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(64, 71)" end="(64, 76)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(64, 71)" end="(64, 72)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(64, 73)" end="(64, 74)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(64, 75)" end="(64, 76)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(64, 76)" end="(64, 77)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(64, 78)" end="(65, 51)">
            <AtomNode start="(64, 78)" end="(64, 79)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(65, 5)" end="(65, 51)" kind="«term_=_»">
              <OtherNode start="(65, 5)" end="(65, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(65, 5)" end="(65, 11)" leading="" trailing=" " raw_val="l.mapM" val="l.mapM"/>
                <NullNode start="(65, 12)" end="(65, 34)">
                  <OtherNode start="(65, 12)" end="(65, 20)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(65, 12)" end="(65, 13)" leading="" trailing="" val="("/>
                    <IdentNode start="(65, 13)" end="(65, 14)" leading="" trailing=" " raw_val="m" val="m"/>
                    <AtomNode start="(65, 15)" end="(65, 17)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(65, 18)" end="(65, 19)" leading="" trailing="" raw_val="m" val="m"/>
                    <AtomNode start="(65, 19)" end="(65, 20)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(65, 21)" end="(65, 34)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(65, 21)" end="(65, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(65, 22)" end="(65, 33)" kind="«term_&amp;lt;|_»">
                      <IdentNode start="(65, 22)" end="(65, 26)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(65, 27)" end="(65, 29)" leading="" trailing=" " val="&amp;lt;|"/>
                      <OtherNode start="(65, 30)" end="(65, 33)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(65, 30)" end="(65, 31)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(65, 32)" end="(65, 33)">
                          <OtherNode start="(65, 32)" end="(65, 33)" kind="Lean.Parser.Term.cdot">
                            <AtomNode start="(65, 32)" end="(65, 33)" leading="" trailing="" val="·"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(65, 33)" end="(65, 34)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(65, 35)" end="(65, 36)" leading="" trailing=" " val="="/>
              <OtherNode start="(65, 37)" end="(65, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(65, 37)" end="(65, 41)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(65, 42)" end="(65, 51)">
                  <OtherNode start="(65, 42)" end="(65, 51)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(65, 42)" end="(65, 43)" leading="" trailing="" val="("/>
                    <OtherNode start="(65, 43)" end="(65, 50)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(65, 43)" end="(65, 48)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                      <NullNode start="(65, 49)" end="(65, 50)">
                        <IdentNode start="(65, 49)" end="(65, 50)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(65, 50)" end="(65, 51)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(65, 52)" end="(66, 27)">
          <AtomNode start="(65, 52)" end="(65, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(65, 55)" end="(66, 27)">
            <AtomNode start="(65, 55)" end="(65, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(66, 3)" end="(66, 27)">
              <TacticTacticseq1IndentedNode start="(66, 3)" end="(66, 27)">
                <NullNode start="(66, 3)" end="(66, 27)">
                  <OtherNode start="(66, 3)" end="(66, 27)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → β&#10;⊢ mapM (fun x =&amp;gt; pure (f x)) l = pure (map f l)" state_after="no goals" tactic="induction l &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(66, 3)" end="(66, 14)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(66, 3)" end="(66, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(66, 13)" end="(66, 14)">
                        <OtherNode start="(66, 13)" end="(66, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(66, 13)" end="(66, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(66, 15)" end="(66, 18)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(66, 19)" end="(66, 27)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(66, 19)" end="(66, 27)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(68, 1)" end="(69, 12)" name="mapM_id" full_name="List.mapM_id">
      <CommandDeclmodifiersNode start="(68, 1)" end="(68, 8)">
        <NullNode/>
        <NullNode start="(68, 1)" end="(68, 8)">
          <OtherNode start="(68, 1)" end="(68, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(68, 1)" end="(68, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(68, 3)" end="(68, 7)">
              <OtherNode start="(68, 3)" end="(68, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(68, 3)" end="(68, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(68, 3)" end="(68, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(68, 7)" end="(68, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(68, 9)" end="(69, 12)" name="mapM_id" full_name="List.mapM_id" _is_private_decl="False">
        <AtomNode start="(68, 9)" end="(68, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(68, 17)" end="(68, 24)">
          <IdentNode start="(68, 17)" end="(68, 24)" leading="" trailing=" " raw_val="mapM_id" val="mapM_id"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(68, 25)" end="(68, 73)">
          <NullNode start="(68, 25)" end="(68, 52)">
            <OtherNode start="(68, 25)" end="(68, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(68, 25)" end="(68, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(68, 26)" end="(68, 27)">
                <IdentNode start="(68, 26)" end="(68, 27)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(68, 28)" end="(68, 36)">
                <AtomNode start="(68, 28)" end="(68, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(68, 30)" end="(68, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(68, 30)" end="(68, 34)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(68, 35)" end="(68, 36)">
                    <IdentNode start="(68, 35)" end="(68, 36)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(68, 36)" end="(68, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(68, 38)" end="(68, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(68, 38)" end="(68, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(68, 39)" end="(68, 40)">
                <IdentNode start="(68, 39)" end="(68, 40)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(68, 41)" end="(68, 51)">
                <AtomNode start="(68, 41)" end="(68, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(68, 43)" end="(68, 51)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(68, 43)" end="(68, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(68, 45)" end="(68, 46)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(68, 47)" end="(68, 51)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(68, 47)" end="(68, 49)" leading="" trailing=" " raw_val="Id" val="Id" full_name="Id" mod_name="Init.Control.Id" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Id.lean"/>
                    <NullNode start="(68, 50)" end="(68, 51)">
                      <IdentNode start="(68, 50)" end="(68, 51)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(68, 51)" end="(68, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(68, 53)" end="(68, 73)">
            <AtomNode start="(68, 53)" end="(68, 54)" leading="" trailing=" " val=":"/>
            <OtherNode start="(68, 55)" end="(68, 73)" kind="«term_=_»">
              <OtherNode start="(68, 55)" end="(68, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(68, 55)" end="(68, 61)" leading="" trailing=" " raw_val="l.mapM" val="l.mapM"/>
                <NullNode start="(68, 62)" end="(68, 63)">
                  <IdentNode start="(68, 62)" end="(68, 63)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(68, 64)" end="(68, 65)" leading="" trailing=" " val="="/>
              <OtherNode start="(68, 66)" end="(68, 73)" kind="Lean.Parser.Term.app">
                <IdentNode start="(68, 66)" end="(68, 71)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                <NullNode start="(68, 72)" end="(68, 73)">
                  <IdentNode start="(68, 72)" end="(68, 73)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(68, 74)" end="(69, 12)">
          <AtomNode start="(68, 74)" end="(68, 76)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(69, 3)" end="(69, 12)" leading="" trailing="&#10;&#10;" raw_val="mapM_pure" val="mapM_pure" full_name="List.mapM_pure" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(64, 17)" def_end="(64, 26)"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(71, 1)" end="(72, 96)" name="mapM_append" full_name="List.mapM_append">
      <CommandDeclmodifiersNode start="(71, 1)" end="(71, 8)">
        <NullNode/>
        <NullNode start="(71, 1)" end="(71, 8)">
          <OtherNode start="(71, 1)" end="(71, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(71, 1)" end="(71, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(71, 3)" end="(71, 7)">
              <OtherNode start="(71, 3)" end="(71, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(71, 3)" end="(71, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(71, 3)" end="(71, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(71, 7)" end="(71, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(71, 9)" end="(72, 96)" name="mapM_append" full_name="List.mapM_append" _is_private_decl="False">
        <AtomNode start="(71, 9)" end="(71, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(71, 17)" end="(71, 28)">
          <IdentNode start="(71, 17)" end="(71, 28)" leading="" trailing=" " raw_val="mapM_append" val="mapM_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(71, 29)" end="(72, 64)">
          <NullNode start="(71, 29)" end="(71, 85)">
            <OtherNode start="(71, 29)" end="(71, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(71, 29)" end="(71, 30)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(71, 30)" end="(71, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(71, 30)" end="(71, 35)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(71, 36)" end="(71, 37)">
                  <IdentNode start="(71, 36)" end="(71, 37)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(71, 37)" end="(71, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(71, 39)" end="(71, 54)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(71, 39)" end="(71, 40)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(71, 40)" end="(71, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(71, 40)" end="(71, 51)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(71, 52)" end="(71, 53)">
                  <IdentNode start="(71, 52)" end="(71, 53)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(71, 53)" end="(71, 54)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(71, 55)" end="(71, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(71, 55)" end="(71, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(71, 56)" end="(71, 57)">
                <IdentNode start="(71, 56)" end="(71, 57)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(71, 58)" end="(71, 67)">
                <AtomNode start="(71, 58)" end="(71, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(71, 60)" end="(71, 67)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(71, 60)" end="(71, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(71, 62)" end="(71, 63)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(71, 64)" end="(71, 67)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(71, 64)" end="(71, 65)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(71, 66)" end="(71, 67)">
                      <IdentNode start="(71, 66)" end="(71, 67)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(71, 67)" end="(71, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(71, 69)" end="(71, 85)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(71, 69)" end="(71, 70)" leading="" trailing="" val="{"/>
              <NullNode start="(71, 70)" end="(71, 75)">
                <IdentNode start="(71, 70)" end="(71, 72)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(71, 73)" end="(71, 75)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(71, 76)" end="(71, 84)">
                <AtomNode start="(71, 76)" end="(71, 77)" leading="" trailing=" " val=":"/>
                <OtherNode start="(71, 78)" end="(71, 84)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(71, 78)" end="(71, 82)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(71, 83)" end="(71, 84)">
                    <IdentNode start="(71, 83)" end="(71, 84)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(71, 84)" end="(71, 85)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(71, 86)" end="(72, 64)">
            <AtomNode start="(71, 86)" end="(71, 87)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(72, 5)" end="(72, 64)" kind="«term_=_»">
              <OtherNode start="(72, 5)" end="(72, 22)" kind="Lean.Parser.Term.app">
                <OtherNode start="(72, 5)" end="(72, 20)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(72, 5)" end="(72, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(72, 5)" end="(72, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(72, 6)" end="(72, 14)" kind="«term_++_»">
                      <IdentNode start="(72, 6)" end="(72, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(72, 9)" end="(72, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(72, 12)" end="(72, 14)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </OtherNode>
                    <AtomNode start="(72, 14)" end="(72, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(72, 15)" end="(72, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(72, 16)" end="(72, 20)" leading="" trailing=" " raw_val="mapM" val="mapM" full_name="List.mapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(72, 21)" end="(72, 22)">
                  <IdentNode start="(72, 21)" end="(72, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(72, 23)" end="(72, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(72, 25)" end="(72, 64)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(72, 25)" end="(72, 26)" leading="" trailing="" val="("/>
                <OtherNode start="(72, 26)" end="(72, 63)" kind="Lean.Parser.Term.termReturn">
                  <AtomNode start="(72, 26)" end="(72, 32)" leading="" trailing=" " val="return"/>
                  <NullNode start="(72, 33)" end="(72, 63)">
                    <OtherNode start="(72, 33)" end="(72, 63)" kind="«term_++_»">
                      <OtherNode start="(72, 33)" end="(72, 46)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(72, 33)" end="(72, 34)" leading="" trailing="" val="("/>
                        <OtherNode start="(72, 34)" end="(72, 45)" kind="Lean.Parser.Term.liftMethod">
                          <AtomNode start="(72, 34)" end="(72, 35)" leading="" trailing=" " val="←"/>
                          <OtherNode start="(72, 36)" end="(72, 45)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(72, 36)" end="(72, 43)" leading="" trailing=" " raw_val="l₁.mapM" val="l₁.mapM"/>
                            <NullNode start="(72, 44)" end="(72, 45)">
                              <IdentNode start="(72, 44)" end="(72, 45)" leading="" trailing="" raw_val="f" val="f"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(72, 45)" end="(72, 46)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <AtomNode start="(72, 47)" end="(72, 49)" leading="" trailing=" " val="++"/>
                      <OtherNode start="(72, 50)" end="(72, 63)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(72, 50)" end="(72, 51)" leading="" trailing="" val="("/>
                        <OtherNode start="(72, 51)" end="(72, 62)" kind="Lean.Parser.Term.liftMethod">
                          <AtomNode start="(72, 51)" end="(72, 52)" leading="" trailing=" " val="←"/>
                          <OtherNode start="(72, 53)" end="(72, 62)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(72, 53)" end="(72, 60)" leading="" trailing=" " raw_val="l₂.mapM" val="l₂.mapM"/>
                            <NullNode start="(72, 61)" end="(72, 62)">
                              <IdentNode start="(72, 61)" end="(72, 62)" leading="" trailing="" raw_val="f" val="f"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(72, 62)" end="(72, 63)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(72, 63)" end="(72, 64)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(72, 65)" end="(72, 96)">
          <AtomNode start="(72, 65)" end="(72, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(72, 68)" end="(72, 96)">
            <AtomNode start="(72, 68)" end="(72, 70)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(72, 71)" end="(72, 96)">
              <TacticTacticseq1IndentedNode start="(72, 71)" end="(72, 96)">
                <NullNode start="(72, 71)" end="(72, 96)">
                  <OtherNode start="(72, 71)" end="(72, 96)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;l₁ l₂ : List α&#10;⊢ mapM f (l₁ ++ l₂) = do&#10;    let __do_lift ← mapM f l₁&#10;    let __do_lift_1 ← mapM f l₂&#10;    pure (__do_lift ++ __do_lift_1)" state_after="no goals" tactic="induction l₁ &amp;lt;;&amp;gt; simp [*]">
                    <OtherNode start="(72, 71)" end="(72, 83)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(72, 71)" end="(72, 80)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(72, 81)" end="(72, 83)">
                        <OtherNode start="(72, 81)" end="(72, 83)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(72, 81)" end="(72, 83)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(72, 84)" end="(72, 87)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(72, 88)" end="(72, 96)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(72, 88)" end="(72, 92)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(72, 93)" end="(72, 96)">
                        <AtomNode start="(72, 93)" end="(72, 94)" leading="" trailing="" val="["/>
                        <NullNode start="(72, 94)" end="(72, 95)">
                          <OtherNode start="(72, 94)" end="(72, 95)" kind="Lean.Parser.Tactic.simpStar">
                            <AtomNode start="(72, 94)" end="(72, 95)" leading="" trailing="" val="*"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(72, 95)" end="(72, 96)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(74, 1)" end="(82, 67)" name="foldlM_cons_eq_append" full_name="List.foldlM_cons_eq_append">
      <CommandDeclmodifiersNode start="(74, 1)" end="(74, 58)">
        <NullNode start="(74, 1)" end="(74, 58)">
          <CommandDoccommentNode start="(74, 1)" end="(74, 58)" comment="Auxiliary lemma for `mapM_eq_reverse_foldlM_cons`. -/">
            <AtomNode start="(74, 1)" end="(74, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(74, 5)" end="(74, 58)" leading="" trailing="&#10;" val="Auxiliary lemma for `mapM_eq_reverse_foldlM_cons`. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(75, 1)" end="(82, 67)" name="foldlM_cons_eq_append" full_name="List.foldlM_cons_eq_append" _is_private_decl="False">
        <AtomNode start="(75, 1)" end="(75, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(75, 9)" end="(75, 30)">
          <IdentNode start="(75, 9)" end="(75, 30)" leading="" trailing=" " raw_val="foldlM_cons_eq_append" val="foldlM_cons_eq_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(75, 31)" end="(77, 85)">
          <NullNode start="(75, 31)" end="(75, 106)">
            <OtherNode start="(75, 31)" end="(75, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(75, 31)" end="(75, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(75, 32)" end="(75, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(75, 32)" end="(75, 37)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(75, 38)" end="(75, 39)">
                  <IdentNode start="(75, 38)" end="(75, 39)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(75, 39)" end="(75, 40)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(75, 41)" end="(75, 56)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(75, 41)" end="(75, 42)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(75, 42)" end="(75, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(75, 42)" end="(75, 53)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(75, 54)" end="(75, 55)">
                  <IdentNode start="(75, 54)" end="(75, 55)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(75, 55)" end="(75, 56)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(75, 57)" end="(75, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(75, 57)" end="(75, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(75, 58)" end="(75, 59)">
                <IdentNode start="(75, 58)" end="(75, 59)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(75, 60)" end="(75, 69)">
                <AtomNode start="(75, 60)" end="(75, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(75, 62)" end="(75, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(75, 62)" end="(75, 63)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(75, 64)" end="(75, 65)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(75, 66)" end="(75, 69)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(75, 66)" end="(75, 67)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(75, 68)" end="(75, 69)">
                      <IdentNode start="(75, 68)" end="(75, 69)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(75, 69)" end="(75, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(75, 71)" end="(75, 84)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(75, 71)" end="(75, 72)" leading="" trailing="" val="{"/>
              <NullNode start="(75, 72)" end="(75, 74)">
                <IdentNode start="(75, 72)" end="(75, 74)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(75, 75)" end="(75, 83)">
                <AtomNode start="(75, 75)" end="(75, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(75, 77)" end="(75, 83)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(75, 77)" end="(75, 81)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(75, 82)" end="(75, 83)">
                    <IdentNode start="(75, 82)" end="(75, 83)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(75, 83)" end="(75, 84)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(75, 85)" end="(75, 92)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(75, 85)" end="(75, 86)" leading="" trailing="" val="{"/>
              <NullNode start="(75, 86)" end="(75, 87)">
                <IdentNode start="(75, 86)" end="(75, 87)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(75, 88)" end="(75, 91)">
                <AtomNode start="(75, 88)" end="(75, 89)" leading="" trailing=" " val=":"/>
                <IdentNode start="(75, 90)" end="(75, 91)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(75, 91)" end="(75, 92)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(75, 93)" end="(75, 106)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(75, 93)" end="(75, 94)" leading="" trailing="" val="{"/>
              <NullNode start="(75, 94)" end="(75, 96)">
                <IdentNode start="(75, 94)" end="(75, 96)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(75, 97)" end="(75, 105)">
                <AtomNode start="(75, 97)" end="(75, 98)" leading="" trailing=" " val=":"/>
                <OtherNode start="(75, 99)" end="(75, 105)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(75, 99)" end="(75, 103)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(75, 104)" end="(75, 105)">
                    <IdentNode start="(75, 104)" end="(75, 105)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(75, 105)" end="(75, 106)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(75, 107)" end="(77, 85)">
            <AtomNode start="(75, 107)" end="(75, 108)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(76, 5)" end="(77, 85)" kind="«term_=_»">
              <OtherNode start="(76, 5)" end="(76, 71)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(76, 5)" end="(76, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(76, 6)" end="(76, 70)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(76, 6)" end="(76, 15)" leading="" trailing=" " raw_val="as.foldlM" val="as.foldlM"/>
                  <NullNode start="(76, 16)" end="(76, 70)">
                    <OtherNode start="(76, 16)" end="(76, 33)" kind="Lean.Parser.Term.namedArgument">
                      <AtomNode start="(76, 16)" end="(76, 17)" leading="" trailing="" val="("/>
                      <IdentNode start="(76, 17)" end="(76, 21)" leading="" trailing=" " raw_val="init" val="init"/>
                      <AtomNode start="(76, 22)" end="(76, 24)" leading="" trailing=" " val=":="/>
                      <OtherNode start="(76, 25)" end="(76, 32)" kind="«term_::_»">
                        <IdentNode start="(76, 25)" end="(76, 26)" leading="" trailing=" " raw_val="b" val="b"/>
                        <AtomNode start="(76, 27)" end="(76, 29)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(76, 30)" end="(76, 32)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </OtherNode>
                      <AtomNode start="(76, 32)" end="(76, 33)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(76, 34)" end="(76, 70)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(76, 34)" end="(76, 37)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(76, 38)" end="(76, 70)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(76, 38)" end="(76, 43)">
                          <IdentNode start="(76, 38)" end="(76, 41)" leading="" trailing=" " raw_val="acc" val="acc"/>
                          <IdentNode start="(76, 42)" end="(76, 43)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(76, 44)" end="(76, 46)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(76, 47)" end="(76, 70)" kind="Lean.Parser.Term.termReturn">
                          <AtomNode start="(76, 47)" end="(76, 53)" leading="" trailing=" " val="return"/>
                          <NullNode start="(76, 54)" end="(76, 70)">
                            <OtherNode start="(76, 54)" end="(76, 70)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(76, 54)" end="(76, 55)" leading="" trailing="" val="("/>
                              <OtherNode start="(76, 55)" end="(76, 69)" kind="«term_::_»">
                                <OtherNode start="(76, 55)" end="(76, 62)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(76, 55)" end="(76, 56)" leading="" trailing="" val="("/>
                                  <OtherNode start="(76, 56)" end="(76, 61)" kind="Lean.Parser.Term.liftMethod">
                                    <AtomNode start="(76, 56)" end="(76, 57)" leading="" trailing=" " val="←"/>
                                    <OtherNode start="(76, 58)" end="(76, 61)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(76, 58)" end="(76, 59)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(76, 60)" end="(76, 61)">
                                        <IdentNode start="(76, 60)" end="(76, 61)" leading="" trailing="" raw_val="a" val="a"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <AtomNode start="(76, 61)" end="(76, 62)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <AtomNode start="(76, 63)" end="(76, 65)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(76, 66)" end="(76, 69)" leading="" trailing="" raw_val="acc" val="acc"/>
                              </OtherNode>
                              <AtomNode start="(76, 69)" end="(76, 70)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(76, 70)" end="(76, 71)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(76, 72)" end="(76, 73)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(77, 7)" end="(77, 85)" kind="«term_&amp;lt;$&amp;gt;_»">
                <OtherNode start="(77, 7)" end="(77, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(77, 7)" end="(77, 8)" leading="" trailing="" val="("/>
                  <OtherNode start="(77, 8)" end="(77, 20)" kind="«term_++_»">
                    <OtherNode start="(77, 8)" end="(77, 9)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(77, 8)" end="(77, 9)" leading="" trailing=" " val="·"/>
                    </OtherNode>
                    <AtomNode start="(77, 10)" end="(77, 12)" leading="" trailing=" " val="++"/>
                    <OtherNode start="(77, 13)" end="(77, 20)" kind="«term_::_»">
                      <IdentNode start="(77, 13)" end="(77, 14)" leading="" trailing=" " raw_val="b" val="b"/>
                      <AtomNode start="(77, 15)" end="(77, 17)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(77, 18)" end="(77, 20)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(77, 20)" end="(77, 21)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(77, 22)" end="(77, 25)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(77, 26)" end="(77, 85)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(77, 26)" end="(77, 35)" leading="" trailing=" " raw_val="as.foldlM" val="as.foldlM"/>
                  <NullNode start="(77, 36)" end="(77, 85)">
                    <OtherNode start="(77, 36)" end="(77, 48)" kind="Lean.Parser.Term.namedArgument">
                      <AtomNode start="(77, 36)" end="(77, 37)" leading="" trailing="" val="("/>
                      <IdentNode start="(77, 37)" end="(77, 41)" leading="" trailing=" " raw_val="init" val="init"/>
                      <AtomNode start="(77, 42)" end="(77, 44)" leading="" trailing=" " val=":="/>
                      <OtherNode start="(77, 45)" end="(77, 47)" kind="«term[_]»">
                        <AtomNode start="(77, 45)" end="(77, 46)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(77, 46)" end="(77, 47)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(77, 47)" end="(77, 48)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(77, 49)" end="(77, 85)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(77, 49)" end="(77, 52)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(77, 53)" end="(77, 85)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(77, 53)" end="(77, 58)">
                          <IdentNode start="(77, 53)" end="(77, 56)" leading="" trailing=" " raw_val="acc" val="acc"/>
                          <IdentNode start="(77, 57)" end="(77, 58)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(77, 59)" end="(77, 61)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(77, 62)" end="(77, 85)" kind="Lean.Parser.Term.termReturn">
                          <AtomNode start="(77, 62)" end="(77, 68)" leading="" trailing=" " val="return"/>
                          <NullNode start="(77, 69)" end="(77, 85)">
                            <OtherNode start="(77, 69)" end="(77, 85)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(77, 69)" end="(77, 70)" leading="" trailing="" val="("/>
                              <OtherNode start="(77, 70)" end="(77, 84)" kind="«term_::_»">
                                <OtherNode start="(77, 70)" end="(77, 77)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(77, 70)" end="(77, 71)" leading="" trailing="" val="("/>
                                  <OtherNode start="(77, 71)" end="(77, 76)" kind="Lean.Parser.Term.liftMethod">
                                    <AtomNode start="(77, 71)" end="(77, 72)" leading="" trailing=" " val="←"/>
                                    <OtherNode start="(77, 73)" end="(77, 76)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(77, 73)" end="(77, 74)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(77, 75)" end="(77, 76)">
                                        <IdentNode start="(77, 75)" end="(77, 76)" leading="" trailing="" raw_val="a" val="a"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <AtomNode start="(77, 76)" end="(77, 77)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <AtomNode start="(77, 78)" end="(77, 80)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(77, 81)" end="(77, 84)" leading="" trailing="" raw_val="acc" val="acc"/>
                              </OtherNode>
                              <AtomNode start="(77, 84)" end="(77, 85)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(77, 86)" end="(82, 67)">
          <AtomNode start="(77, 86)" end="(77, 88)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(77, 89)" end="(82, 67)">
            <AtomNode start="(77, 89)" end="(77, 91)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(78, 3)" end="(82, 67)">
              <TacticTacticseq1IndentedNode start="(78, 3)" end="(82, 67)">
                <NullNode start="(78, 3)" end="(82, 67)">
                  <OtherNode start="(78, 3)" end="(82, 67)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;as : List α&#10;b : β&#10;bs : List β&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← f a&#10;        pure (__do_lift :: acc))&#10;      (b :: bs) as =&#10;    (fun x =&amp;gt; x ++ b :: bs) &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← f a&#10;          pure (__do_lift :: acc))&#10;        [] as" state_after="no goals" tactic="induction as generalizing b bs with&#10;| nil =&amp;gt; simp&#10;| cons a as ih =&amp;gt;&#10;  simp only [bind_pure_comp] at ih&#10;  simp [ih, _root_.map_bind, Functor.map_map, Function.comp_def]">
                    <AtomNode start="(78, 3)" end="(78, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(78, 13)" end="(78, 15)">
                      <OtherNode start="(78, 13)" end="(78, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(78, 13)" end="(78, 15)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(78, 16)" end="(78, 33)">
                      <AtomNode start="(78, 16)" end="(78, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(78, 29)" end="(78, 33)">
                        <IdentNode start="(78, 29)" end="(78, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(78, 31)" end="(78, 33)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(78, 34)" end="(82, 67)">
                      <OtherNode start="(78, 34)" end="(82, 67)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(78, 34)" end="(78, 38)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(79, 3)" end="(82, 67)">
                          <OtherNode start="(79, 3)" end="(79, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(79, 3)" end="(79, 8)">
                              <OtherNode start="(79, 3)" end="(79, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(79, 3)" end="(79, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(79, 5)" end="(79, 8)">
                                  <NullNode/>
                                  <IdentNode start="(79, 5)" end="(79, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(79, 9)" end="(79, 16)">
                              <AtomNode start="(79, 9)" end="(79, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(79, 12)" end="(79, 16)">
                                <TacticTacticseq1IndentedNode start="(79, 12)" end="(79, 16)">
                                  <NullNode start="(79, 12)" end="(79, 16)">
                                    <OtherNode start="(79, 12)" end="(79, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;b : β&#10;bs : List β&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← f a&#10;        pure (__do_lift :: acc))&#10;      (b :: bs) [] =&#10;    (fun x =&amp;gt; x ++ b :: bs) &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← f a&#10;          pure (__do_lift :: acc))&#10;        [] []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(79, 12)" end="(79, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(80, 3)" end="(82, 67)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(80, 3)" end="(80, 17)">
                              <OtherNode start="(80, 3)" end="(80, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(80, 3)" end="(80, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(80, 5)" end="(80, 9)">
                                  <NullNode/>
                                  <IdentNode start="(80, 5)" end="(80, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(80, 10)" end="(80, 17)">
                                  <IdentNode start="(80, 10)" end="(80, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(80, 12)" end="(80, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                                  <IdentNode start="(80, 15)" end="(80, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(80, 18)" end="(82, 67)">
                              <AtomNode start="(80, 18)" end="(80, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(81, 5)" end="(82, 67)">
                                <TacticTacticseq1IndentedNode start="(81, 5)" end="(82, 67)">
                                  <NullNode start="(81, 5)" end="(82, 67)">
                                    <OtherNode start="(81, 5)" end="(81, 37)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ {b : β} {bs : List β},&#10;    foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← f a&#10;          pure (__do_lift :: acc))&#10;        (b :: bs) as =&#10;      (fun x =&amp;gt; x ++ b :: bs) &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← f a&#10;            pure (__do_lift :: acc))&#10;          [] as&#10;b : β&#10;bs : List β&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← f a&#10;        pure (__do_lift :: acc))&#10;      (b :: bs) (a :: as) =&#10;    (fun x =&amp;gt; x ++ b :: bs) &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← f a&#10;          pure (__do_lift :: acc))&#10;        [] (a :: as)" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;a : α&#10;as : List α&#10;b : β&#10;bs : List β&#10;ih :&#10;  ∀ {b : β} {bs : List β},&#10;    foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) (b :: bs) as =&#10;      (fun x =&amp;gt; x ++ b :: bs) &amp;lt;$&amp;gt; foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) [] as&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← f a&#10;        pure (__do_lift :: acc))&#10;      (b :: bs) (a :: as) =&#10;    (fun x =&amp;gt; x ++ b :: bs) &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← f a&#10;          pure (__do_lift :: acc))&#10;        [] (a :: as)" tactic="simp only [bind_pure_comp] at ih">
                                      <AtomNode start="(81, 5)" end="(81, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(81, 10)" end="(81, 14)">
                                        <AtomNode start="(81, 10)" end="(81, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(81, 15)" end="(81, 31)">
                                        <AtomNode start="(81, 15)" end="(81, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(81, 16)" end="(81, 30)">
                                          <OtherNode start="(81, 16)" end="(81, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(81, 16)" end="(81, 30)" leading="" trailing="" raw_val="bind_pure_comp" val="bind_pure_comp" full_name="LawfulMonad.bind_pure_comp" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(81, 30)" end="(81, 31)" leading="" trailing=" " val="]"/>
                                      </NullNode>
                                      <NullNode start="(81, 32)" end="(81, 37)">
                                        <OtherNode start="(81, 32)" end="(81, 37)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(81, 32)" end="(81, 34)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(81, 35)" end="(81, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(81, 35)" end="(81, 37)">
                                              <IdentNode start="(81, 35)" end="(81, 37)" leading="" trailing="&#10;    " raw_val="ih" val="ih"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(82, 5)" end="(82, 67)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;a : α&#10;as : List α&#10;b : β&#10;bs : List β&#10;ih :&#10;  ∀ {b : β} {bs : List β},&#10;    foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) (b :: bs) as =&#10;      (fun x =&amp;gt; x ++ b :: bs) &amp;lt;$&amp;gt; foldlM (fun acc a =&amp;gt; (fun a =&amp;gt; a :: acc) &amp;lt;$&amp;gt; f a) [] as&#10;⊢ foldlM&#10;      (fun acc a =&amp;gt; do&#10;        let __do_lift ← f a&#10;        pure (__do_lift :: acc))&#10;      (b :: bs) (a :: as) =&#10;    (fun x =&amp;gt; x ++ b :: bs) &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← f a&#10;          pure (__do_lift :: acc))&#10;        [] (a :: as)" state_after="no goals" tactic="simp [ih, _root_.map_bind, Functor.map_map, Function.comp_def]">
                                      <AtomNode start="(82, 5)" end="(82, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(82, 10)" end="(82, 67)">
                                        <AtomNode start="(82, 10)" end="(82, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(82, 11)" end="(82, 66)">
                                          <OtherNode start="(82, 11)" end="(82, 13)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(82, 11)" end="(82, 13)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(82, 13)" end="(82, 14)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(82, 15)" end="(82, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(82, 15)" end="(82, 30)" leading="" trailing="" raw_val="_root_.map_bind" val="_root_.map_bind" full_name="map_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(82, 30)" end="(82, 31)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(82, 32)" end="(82, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(82, 32)" end="(82, 47)" leading="" trailing="" raw_val="Functor.map_map" val="Functor.map_map" full_name="Functor.map_map" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(82, 47)" end="(82, 48)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(82, 49)" end="(82, 66)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(82, 49)" end="(82, 66)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(82, 66)" end="(82, 67)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(84, 1)" end="(93, 26)" name="mapM_eq_reverse_foldlM_cons" full_name="List.mapM_eq_reverse_foldlM_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(84, 1)" end="(93, 26)" name="mapM_eq_reverse_foldlM_cons" full_name="List.mapM_eq_reverse_foldlM_cons" _is_private_decl="False">
        <AtomNode start="(84, 1)" end="(84, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(84, 9)" end="(84, 36)">
          <IdentNode start="(84, 9)" end="(84, 36)" leading="" trailing=" " raw_val="mapM_eq_reverse_foldlM_cons" val="mapM_eq_reverse_foldlM_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(84, 37)" end="(85, 80)">
          <NullNode start="(84, 37)" end="(84, 89)">
            <OtherNode start="(84, 37)" end="(84, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(84, 37)" end="(84, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(84, 38)" end="(84, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(84, 38)" end="(84, 43)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(84, 44)" end="(84, 45)">
                  <IdentNode start="(84, 44)" end="(84, 45)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(84, 45)" end="(84, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(84, 47)" end="(84, 62)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(84, 47)" end="(84, 48)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(84, 48)" end="(84, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(84, 48)" end="(84, 59)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(84, 60)" end="(84, 61)">
                  <IdentNode start="(84, 60)" end="(84, 61)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(84, 61)" end="(84, 62)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(84, 63)" end="(84, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(84, 63)" end="(84, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(84, 64)" end="(84, 65)">
                <IdentNode start="(84, 64)" end="(84, 65)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(84, 66)" end="(84, 75)">
                <AtomNode start="(84, 66)" end="(84, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(84, 68)" end="(84, 75)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(84, 68)" end="(84, 69)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(84, 70)" end="(84, 71)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(84, 72)" end="(84, 75)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(84, 72)" end="(84, 73)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(84, 74)" end="(84, 75)">
                      <IdentNode start="(84, 74)" end="(84, 75)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(84, 75)" end="(84, 76)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(84, 77)" end="(84, 89)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(84, 77)" end="(84, 78)" leading="" trailing="" val="{"/>
              <NullNode start="(84, 78)" end="(84, 79)">
                <IdentNode start="(84, 78)" end="(84, 79)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(84, 80)" end="(84, 88)">
                <AtomNode start="(84, 80)" end="(84, 81)" leading="" trailing=" " val=":"/>
                <OtherNode start="(84, 82)" end="(84, 88)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(84, 82)" end="(84, 86)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(84, 87)" end="(84, 88)">
                    <IdentNode start="(84, 87)" end="(84, 88)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(84, 88)" end="(84, 89)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(84, 90)" end="(85, 80)">
            <AtomNode start="(84, 90)" end="(84, 91)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(85, 5)" end="(85, 80)" kind="«term_=_»">
              <OtherNode start="(85, 5)" end="(85, 13)" kind="Lean.Parser.Term.app">
                <IdentNode start="(85, 5)" end="(85, 9)" leading="" trailing=" " raw_val="mapM" val="mapM" full_name="List.mapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                <NullNode start="(85, 10)" end="(85, 13)">
                  <IdentNode start="(85, 10)" end="(85, 11)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(85, 12)" end="(85, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(85, 14)" end="(85, 15)" leading="" trailing=" " val="="/>
              <OtherNode start="(85, 16)" end="(85, 80)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(85, 16)" end="(85, 23)" leading="" trailing=" " raw_val="reverse" val="reverse" full_name="List.reverse" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <AtomNode start="(85, 24)" end="(85, 27)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(85, 28)" end="(85, 80)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(85, 28)" end="(85, 29)" leading="" trailing="" val="("/>
                  <OtherNode start="(85, 29)" end="(85, 79)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(85, 29)" end="(85, 37)" leading="" trailing=" " raw_val="l.foldlM" val="l.foldlM"/>
                    <NullNode start="(85, 38)" end="(85, 79)">
                      <OtherNode start="(85, 38)" end="(85, 76)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(85, 38)" end="(85, 39)" leading="" trailing="" val="("/>
                        <OtherNode start="(85, 39)" end="(85, 75)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(85, 39)" end="(85, 42)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(85, 43)" end="(85, 75)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(85, 43)" end="(85, 48)">
                              <IdentNode start="(85, 43)" end="(85, 46)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              <IdentNode start="(85, 47)" end="(85, 48)" leading="" trailing=" " raw_val="a" val="a"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(85, 49)" end="(85, 51)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(85, 52)" end="(85, 75)" kind="Lean.Parser.Term.termReturn">
                              <AtomNode start="(85, 52)" end="(85, 58)" leading="" trailing=" " val="return"/>
                              <NullNode start="(85, 59)" end="(85, 75)">
                                <OtherNode start="(85, 59)" end="(85, 75)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(85, 59)" end="(85, 60)" leading="" trailing="" val="("/>
                                  <OtherNode start="(85, 60)" end="(85, 74)" kind="«term_::_»">
                                    <OtherNode start="(85, 60)" end="(85, 67)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(85, 60)" end="(85, 61)" leading="" trailing="" val="("/>
                                      <OtherNode start="(85, 61)" end="(85, 66)" kind="Lean.Parser.Term.liftMethod">
                                        <AtomNode start="(85, 61)" end="(85, 62)" leading="" trailing=" " val="←"/>
                                        <OtherNode start="(85, 63)" end="(85, 66)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(85, 63)" end="(85, 64)" leading="" trailing=" " raw_val="f" val="f"/>
                                          <NullNode start="(85, 65)" end="(85, 66)">
                                            <IdentNode start="(85, 65)" end="(85, 66)" leading="" trailing="" raw_val="a" val="a"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(85, 66)" end="(85, 67)" leading="" trailing=" " val=")"/>
                                    </OtherNode>
                                    <AtomNode start="(85, 68)" end="(85, 70)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(85, 71)" end="(85, 74)" leading="" trailing="" raw_val="acc" val="acc"/>
                                  </OtherNode>
                                  <AtomNode start="(85, 74)" end="(85, 75)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(85, 75)" end="(85, 76)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <OtherNode start="(85, 77)" end="(85, 79)" kind="«term[_]»">
                        <AtomNode start="(85, 77)" end="(85, 78)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(85, 78)" end="(85, 79)" leading="" trailing="" val="]"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(85, 79)" end="(85, 80)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(85, 81)" end="(93, 26)">
          <AtomNode start="(85, 81)" end="(85, 83)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(85, 84)" end="(93, 26)">
            <AtomNode start="(85, 84)" end="(85, 86)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(86, 3)" end="(93, 26)">
              <TacticTacticseq1IndentedNode start="(86, 3)" end="(93, 26)">
                <NullNode start="(86, 3)" end="(93, 26)">
                  <OtherNode start="(86, 3)" end="(86, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;l : List α&#10;⊢ mapM f l =&#10;    reverse &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← f a&#10;          pure (__do_lift :: acc))&#10;        [] l" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;l : List α&#10;⊢ mapM' f l =&#10;    reverse &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← f a&#10;          pure (__do_lift :: acc))&#10;        [] l" tactic="rw [← mapM'_eq_mapM]">
                    <AtomNode start="(86, 3)" end="(86, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(86, 6)" end="(86, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(86, 6)" end="(86, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(86, 7)" end="(86, 22)">
                        <OtherNode start="(86, 7)" end="(86, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(86, 7)" end="(86, 8)">
                            <OtherNode start="(86, 7)" end="(86, 8)" kind="patternIgnore">
                              <OtherNode start="(86, 7)" end="(86, 8)" kind="token.«← »">
                                <AtomNode start="(86, 7)" end="(86, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(86, 9)" end="(86, 22)" leading="" trailing="" raw_val="mapM'_eq_mapM" val="mapM'_eq_mapM" full_name="List.mapM'_eq_mapM" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(53, 9)" def_end="(53, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(86, 22)" end="(86, 23)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(87, 3)" end="(93, 26)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;l : List α&#10;⊢ mapM' f l =&#10;    reverse &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← f a&#10;          pure (__do_lift :: acc))&#10;        [] l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons a as ih =&amp;gt;&#10;  simp only [mapM'_cons, ih, bind_map_left, foldlM_cons, LawfulMonad.bind_assoc, pure_bind,&#10;    foldlM_cons_eq_append, _root_.map_bind, Functor.map_map, Function.comp_def, reverse_append,&#10;    reverse_cons, reverse_nil, nil_append, singleton_append]&#10;  simp [bind_pure_comp]">
                    <AtomNode start="(87, 3)" end="(87, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(87, 13)" end="(87, 14)">
                      <OtherNode start="(87, 13)" end="(87, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(87, 13)" end="(87, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(87, 15)" end="(93, 26)">
                      <OtherNode start="(87, 15)" end="(93, 26)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(87, 15)" end="(87, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(88, 3)" end="(93, 26)">
                          <OtherNode start="(88, 3)" end="(88, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(88, 3)" end="(88, 8)">
                              <OtherNode start="(88, 3)" end="(88, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(88, 3)" end="(88, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(88, 5)" end="(88, 8)">
                                  <NullNode/>
                                  <IdentNode start="(88, 5)" end="(88, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(88, 9)" end="(88, 16)">
                              <AtomNode start="(88, 9)" end="(88, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(88, 12)" end="(88, 16)">
                                <TacticTacticseq1IndentedNode start="(88, 12)" end="(88, 16)">
                                  <NullNode start="(88, 12)" end="(88, 16)">
                                    <OtherNode start="(88, 12)" end="(88, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;⊢ mapM' f [] =&#10;    reverse &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← f a&#10;          pure (__do_lift :: acc))&#10;        [] []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(88, 12)" end="(88, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(89, 3)" end="(93, 26)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(89, 3)" end="(89, 17)">
                              <OtherNode start="(89, 3)" end="(89, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(89, 3)" end="(89, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(89, 5)" end="(89, 9)">
                                  <NullNode/>
                                  <IdentNode start="(89, 5)" end="(89, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(89, 10)" end="(89, 17)">
                                  <IdentNode start="(89, 10)" end="(89, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(89, 12)" end="(89, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                                  <IdentNode start="(89, 15)" end="(89, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(89, 18)" end="(93, 26)">
                              <AtomNode start="(89, 18)" end="(89, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(90, 5)" end="(93, 26)">
                                <TacticTacticseq1IndentedNode start="(90, 5)" end="(93, 26)">
                                  <NullNode start="(90, 5)" end="(93, 26)">
                                    <OtherNode start="(90, 5)" end="(92, 63)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;a : α&#10;as : List α&#10;ih :&#10;  mapM' f as =&#10;    reverse &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← f a&#10;          pure (__do_lift :: acc))&#10;        [] as&#10;⊢ mapM' f (a :: as) =&#10;    reverse &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← f a&#10;          pure (__do_lift :: acc))&#10;        [] (a :: as)" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;a : α&#10;as : List α&#10;ih :&#10;  mapM' f as =&#10;    reverse &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← f a&#10;          pure (__do_lift :: acc))&#10;        [] as&#10;⊢ (do&#10;      let __do_lift ← f a&#10;      let a ←&#10;        foldlM&#10;            (fun acc a =&amp;gt; do&#10;              let __do_lift ← f a&#10;              pure (__do_lift :: acc))&#10;            [] as&#10;      pure (__do_lift :: a.reverse)) =&#10;    do&#10;    let a ← f a&#10;    (fun a_1 =&amp;gt; a :: a_1.reverse) &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← f a&#10;            pure (__do_lift :: acc))&#10;          [] as" tactic="simp only [mapM'_cons, ih, bind_map_left, foldlM_cons, LawfulMonad.bind_assoc, pure_bind,&#10;  foldlM_cons_eq_append, _root_.map_bind, Functor.map_map, Function.comp_def, reverse_append,&#10;  reverse_cons, reverse_nil, nil_append, singleton_append]">
                                      <AtomNode start="(90, 5)" end="(90, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(90, 10)" end="(90, 14)">
                                        <AtomNode start="(90, 10)" end="(90, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(90, 15)" end="(92, 63)">
                                        <AtomNode start="(90, 15)" end="(90, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(90, 16)" end="(92, 62)">
                                          <OtherNode start="(90, 16)" end="(90, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(90, 16)" end="(90, 26)" leading="" trailing="" raw_val="mapM'_cons" val="mapM'_cons" full_name="List.mapM'_cons" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(49, 17)" def_end="(49, 27)"/>
                                          </OtherNode>
                                          <AtomNode start="(90, 26)" end="(90, 27)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(90, 28)" end="(90, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(90, 28)" end="(90, 30)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(90, 30)" end="(90, 31)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(90, 32)" end="(90, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(90, 32)" end="(90, 45)" leading="" trailing="" raw_val="bind_map_left" val="bind_map_left" full_name="bind_map_left" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(90, 45)" end="(90, 46)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(90, 47)" end="(90, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(90, 47)" end="(90, 58)" leading="" trailing="" raw_val="foldlM_cons" val="foldlM_cons" full_name="List.foldlM_cons" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(90, 58)" end="(90, 59)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(90, 60)" end="(90, 82)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(90, 60)" end="(90, 82)" leading="" trailing="" raw_val="LawfulMonad.bind_assoc" val="LawfulMonad.bind_assoc" full_name="LawfulMonad.bind_assoc" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(90, 82)" end="(90, 83)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(90, 84)" end="(90, 93)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(90, 84)" end="(90, 93)" leading="" trailing="" raw_val="pure_bind" val="pure_bind" full_name="LawfulMonad.pure_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(90, 93)" end="(90, 94)" leading="" trailing="&#10;      " val=","/>
                                          <OtherNode start="(91, 7)" end="(91, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(91, 7)" end="(91, 28)" leading="" trailing="" raw_val="foldlM_cons_eq_append" val="foldlM_cons_eq_append" full_name="List.foldlM_cons_eq_append" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(75, 9)" def_end="(75, 30)"/>
                                          </OtherNode>
                                          <AtomNode start="(91, 28)" end="(91, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(91, 30)" end="(91, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(91, 30)" end="(91, 45)" leading="" trailing="" raw_val="_root_.map_bind" val="_root_.map_bind" full_name="map_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(91, 45)" end="(91, 46)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(91, 47)" end="(91, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(91, 47)" end="(91, 62)" leading="" trailing="" raw_val="Functor.map_map" val="Functor.map_map" full_name="Functor.map_map" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(91, 62)" end="(91, 63)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(91, 64)" end="(91, 81)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(91, 64)" end="(91, 81)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(91, 81)" end="(91, 82)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(91, 83)" end="(91, 97)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(91, 83)" end="(91, 97)" leading="" trailing="" raw_val="reverse_append" val="reverse_append" full_name="List.reverse_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(91, 97)" end="(91, 98)" leading="" trailing="&#10;      " val=","/>
                                          <OtherNode start="(92, 7)" end="(92, 19)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(92, 7)" end="(92, 19)" leading="" trailing="" raw_val="reverse_cons" val="reverse_cons" full_name="List.reverse_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(92, 19)" end="(92, 20)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(92, 21)" end="(92, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(92, 21)" end="(92, 32)" leading="" trailing="" raw_val="reverse_nil" val="reverse_nil" full_name="List.reverse_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(92, 32)" end="(92, 33)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(92, 34)" end="(92, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(92, 34)" end="(92, 44)" leading="" trailing="" raw_val="nil_append" val="nil_append" full_name="List.nil_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(92, 44)" end="(92, 45)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(92, 46)" end="(92, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(92, 46)" end="(92, 62)" leading="" trailing="" raw_val="singleton_append" val="singleton_append" full_name="List.singleton_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(92, 62)" end="(92, 63)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(93, 5)" end="(93, 26)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m β&#10;a : α&#10;as : List α&#10;ih :&#10;  mapM' f as =&#10;    reverse &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun acc a =&amp;gt; do&#10;          let __do_lift ← f a&#10;          pure (__do_lift :: acc))&#10;        [] as&#10;⊢ (do&#10;      let __do_lift ← f a&#10;      let a ←&#10;        foldlM&#10;            (fun acc a =&amp;gt; do&#10;              let __do_lift ← f a&#10;              pure (__do_lift :: acc))&#10;            [] as&#10;      pure (__do_lift :: a.reverse)) =&#10;    do&#10;    let a ← f a&#10;    (fun a_1 =&amp;gt; a :: a_1.reverse) &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun acc a =&amp;gt; do&#10;            let __do_lift ← f a&#10;            pure (__do_lift :: acc))&#10;          [] as" state_after="no goals" tactic="simp [bind_pure_comp]">
                                      <AtomNode start="(93, 5)" end="(93, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(93, 10)" end="(93, 26)">
                                        <AtomNode start="(93, 10)" end="(93, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(93, 11)" end="(93, 25)">
                                          <OtherNode start="(93, 11)" end="(93, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(93, 11)" end="(93, 25)" leading="" trailing="" raw_val="bind_pure_comp" val="bind_pure_comp" full_name="LawfulMonad.bind_pure_comp" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(93, 25)" end="(93, 26)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(95, 1)" end="(95, 22)" comment="### filterMapM -/">
      <AtomNode start="(95, 1)" end="(95, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(95, 5)" end="(95, 22)" leading="" trailing="&#10;&#10;" val="### filterMapM -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(97, 1)" end="(97, 99)" name="filterMapM_nil" full_name="List.filterMapM_nil">
      <CommandDeclmodifiersNode start="(97, 1)" end="(97, 8)">
        <NullNode/>
        <NullNode start="(97, 1)" end="(97, 8)">
          <OtherNode start="(97, 1)" end="(97, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(97, 1)" end="(97, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(97, 3)" end="(97, 7)">
              <OtherNode start="(97, 3)" end="(97, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(97, 3)" end="(97, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(97, 3)" end="(97, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(97, 7)" end="(97, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(97, 9)" end="(97, 99)" name="filterMapM_nil" full_name="List.filterMapM_nil" _is_private_decl="False">
        <AtomNode start="(97, 9)" end="(97, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(97, 17)" end="(97, 31)">
          <IdentNode start="(97, 17)" end="(97, 31)" leading="" trailing=" " raw_val="filterMapM_nil" val="filterMapM_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(97, 32)" end="(97, 92)">
          <NullNode start="(97, 32)" end="(97, 64)">
            <OtherNode start="(97, 32)" end="(97, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(97, 32)" end="(97, 33)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(97, 33)" end="(97, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(97, 33)" end="(97, 38)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(97, 39)" end="(97, 40)">
                  <IdentNode start="(97, 39)" end="(97, 40)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(97, 40)" end="(97, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(97, 42)" end="(97, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(97, 42)" end="(97, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(97, 43)" end="(97, 44)">
                <IdentNode start="(97, 43)" end="(97, 44)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(97, 45)" end="(97, 63)">
                <AtomNode start="(97, 45)" end="(97, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(97, 47)" end="(97, 63)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(97, 47)" end="(97, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(97, 49)" end="(97, 50)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(97, 51)" end="(97, 63)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(97, 51)" end="(97, 52)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(97, 53)" end="(97, 63)">
                      <OtherNode start="(97, 53)" end="(97, 63)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(97, 53)" end="(97, 54)" leading="" trailing="" val="("/>
                        <OtherNode start="(97, 54)" end="(97, 62)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(97, 54)" end="(97, 60)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(97, 61)" end="(97, 62)">
                            <IdentNode start="(97, 61)" end="(97, 62)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(97, 62)" end="(97, 63)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(97, 63)" end="(97, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(97, 65)" end="(97, 92)">
            <AtomNode start="(97, 65)" end="(97, 66)" leading="" trailing=" " val=":"/>
            <OtherNode start="(97, 67)" end="(97, 92)" kind="«term_=_»">
              <OtherNode start="(97, 67)" end="(97, 82)" kind="Lean.Parser.Term.app">
                <OtherNode start="(97, 67)" end="(97, 80)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(97, 67)" end="(97, 69)" kind="«term[_]»">
                    <AtomNode start="(97, 67)" end="(97, 68)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(97, 68)" end="(97, 69)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(97, 69)" end="(97, 70)" leading="" trailing="" val="."/>
                  <IdentNode start="(97, 70)" end="(97, 80)" leading="" trailing=" " raw_val="filterMapM" val="filterMapM" full_name="List.filterMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(97, 81)" end="(97, 82)">
                  <IdentNode start="(97, 81)" end="(97, 82)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(97, 83)" end="(97, 84)" leading="" trailing=" " val="="/>
              <OtherNode start="(97, 85)" end="(97, 92)" kind="Lean.Parser.Term.app">
                <IdentNode start="(97, 85)" end="(97, 89)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(97, 90)" end="(97, 92)">
                  <OtherNode start="(97, 90)" end="(97, 92)" kind="«term[_]»">
                    <AtomNode start="(97, 90)" end="(97, 91)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(97, 91)" end="(97, 92)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(97, 93)" end="(97, 99)">
          <AtomNode start="(97, 93)" end="(97, 95)" leading="" trailing=" " val=":="/>
          <IdentNode start="(97, 96)" end="(97, 99)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(99, 1)" end="(110, 11)" name="filterMapM_loop_eq" full_name="List.filterMapM_loop_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(99, 1)" end="(110, 11)" name="filterMapM_loop_eq" full_name="List.filterMapM_loop_eq" _is_private_decl="False">
        <AtomNode start="(99, 1)" end="(99, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(99, 9)" end="(99, 27)">
          <IdentNode start="(99, 9)" end="(99, 27)" leading="" trailing=" " raw_val="filterMapM_loop_eq" val="filterMapM_loop_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(99, 28)" end="(100, 76)">
          <NullNode start="(99, 28)" end="(99, 104)">
            <OtherNode start="(99, 28)" end="(99, 37)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(99, 28)" end="(99, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(99, 29)" end="(99, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(99, 29)" end="(99, 34)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(99, 35)" end="(99, 36)">
                  <IdentNode start="(99, 35)" end="(99, 36)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(99, 36)" end="(99, 37)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(99, 38)" end="(99, 53)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(99, 38)" end="(99, 39)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(99, 39)" end="(99, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(99, 39)" end="(99, 50)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(99, 51)" end="(99, 52)">
                  <IdentNode start="(99, 51)" end="(99, 52)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(99, 52)" end="(99, 53)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(99, 54)" end="(99, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(99, 54)" end="(99, 55)" leading="" trailing="" val="{"/>
              <NullNode start="(99, 55)" end="(99, 56)">
                <IdentNode start="(99, 55)" end="(99, 56)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(99, 57)" end="(99, 75)">
                <AtomNode start="(99, 57)" end="(99, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(99, 59)" end="(99, 75)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(99, 59)" end="(99, 60)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(99, 61)" end="(99, 62)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(99, 63)" end="(99, 75)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(99, 63)" end="(99, 64)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(99, 65)" end="(99, 75)">
                      <OtherNode start="(99, 65)" end="(99, 75)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(99, 65)" end="(99, 66)" leading="" trailing="" val="("/>
                        <OtherNode start="(99, 66)" end="(99, 74)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(99, 66)" end="(99, 72)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(99, 73)" end="(99, 74)">
                            <IdentNode start="(99, 73)" end="(99, 74)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(99, 74)" end="(99, 75)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(99, 75)" end="(99, 76)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(99, 77)" end="(99, 89)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(99, 77)" end="(99, 78)" leading="" trailing="" val="{"/>
              <NullNode start="(99, 78)" end="(99, 79)">
                <IdentNode start="(99, 78)" end="(99, 79)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(99, 80)" end="(99, 88)">
                <AtomNode start="(99, 80)" end="(99, 81)" leading="" trailing=" " val=":"/>
                <OtherNode start="(99, 82)" end="(99, 88)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(99, 82)" end="(99, 86)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(99, 87)" end="(99, 88)">
                    <IdentNode start="(99, 87)" end="(99, 88)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(99, 88)" end="(99, 89)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(99, 90)" end="(99, 104)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(99, 90)" end="(99, 91)" leading="" trailing="" val="{"/>
              <NullNode start="(99, 91)" end="(99, 94)">
                <IdentNode start="(99, 91)" end="(99, 94)" leading="" trailing=" " raw_val="acc" val="acc"/>
              </NullNode>
              <NullNode start="(99, 95)" end="(99, 103)">
                <AtomNode start="(99, 95)" end="(99, 96)" leading="" trailing=" " val=":"/>
                <OtherNode start="(99, 97)" end="(99, 103)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(99, 97)" end="(99, 101)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(99, 102)" end="(99, 103)">
                    <IdentNode start="(99, 102)" end="(99, 103)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(99, 103)" end="(99, 104)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(99, 105)" end="(100, 76)">
            <AtomNode start="(99, 105)" end="(99, 106)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(100, 5)" end="(100, 76)" kind="«term_=_»">
              <OtherNode start="(100, 5)" end="(100, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(100, 5)" end="(100, 20)" leading="" trailing=" " raw_val="filterMapM.loop" val="filterMapM.loop" full_name="List.filterMapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                <NullNode start="(100, 21)" end="(100, 28)">
                  <IdentNode start="(100, 21)" end="(100, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(100, 23)" end="(100, 24)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(100, 25)" end="(100, 28)" leading="" trailing=" " raw_val="acc" val="acc"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(100, 29)" end="(100, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(100, 31)" end="(100, 76)" kind="«term_&amp;lt;$&amp;gt;_»">
                <OtherNode start="(100, 31)" end="(100, 49)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(100, 31)" end="(100, 32)" leading="" trailing="" val="("/>
                  <OtherNode start="(100, 32)" end="(100, 48)" kind="«term_++_»">
                    <IdentNode start="(100, 32)" end="(100, 43)" leading="" trailing=" " raw_val="acc.reverse" val="acc.reverse"/>
                    <AtomNode start="(100, 44)" end="(100, 46)" leading="" trailing=" " val="++"/>
                    <OtherNode start="(100, 47)" end="(100, 48)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(100, 47)" end="(100, 48)" leading="" trailing="" val="·"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(100, 48)" end="(100, 49)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(100, 50)" end="(100, 53)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(100, 54)" end="(100, 76)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(100, 54)" end="(100, 69)" leading="" trailing=" " raw_val="filterMapM.loop" val="filterMapM.loop" full_name="List.filterMapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                  <NullNode start="(100, 70)" end="(100, 76)">
                    <IdentNode start="(100, 70)" end="(100, 71)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(100, 72)" end="(100, 73)" leading="" trailing=" " raw_val="l" val="l"/>
                    <OtherNode start="(100, 74)" end="(100, 76)" kind="«term[_]»">
                      <AtomNode start="(100, 74)" end="(100, 75)" leading="" trailing="" val="["/>
                      <NullNode/>
                      <AtomNode start="(100, 75)" end="(100, 76)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(100, 77)" end="(110, 11)">
          <AtomNode start="(100, 77)" end="(100, 79)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(100, 80)" end="(110, 11)">
            <AtomNode start="(100, 80)" end="(100, 82)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(101, 3)" end="(110, 11)">
              <TacticTacticseq1IndentedNode start="(101, 3)" end="(110, 11)">
                <NullNode start="(101, 3)" end="(110, 11)">
                  <OtherNode start="(101, 3)" end="(110, 11)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;l : List α&#10;acc : List β&#10;⊢ filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []" state_after="no goals" tactic="induction l generalizing acc with&#10;| nil =&amp;gt; simp [filterMapM.loop]&#10;| cons a l ih =&amp;gt;&#10;  simp only [filterMapM.loop, _root_.map_bind]&#10;  congr&#10;  funext b?&#10;  split &amp;lt;;&amp;gt; rename_i b&#10;  · apply ih&#10;  · rw [ih, ih (acc := [b])]&#10;    simp">
                    <AtomNode start="(101, 3)" end="(101, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(101, 13)" end="(101, 14)">
                      <OtherNode start="(101, 13)" end="(101, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(101, 13)" end="(101, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(101, 15)" end="(101, 31)">
                      <AtomNode start="(101, 15)" end="(101, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(101, 28)" end="(101, 31)">
                        <IdentNode start="(101, 28)" end="(101, 31)" leading="" trailing=" " raw_val="acc" val="acc"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(101, 32)" end="(110, 11)">
                      <OtherNode start="(101, 32)" end="(110, 11)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(101, 32)" end="(101, 36)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(102, 3)" end="(110, 11)">
                          <OtherNode start="(102, 3)" end="(102, 34)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(102, 3)" end="(102, 8)">
                              <OtherNode start="(102, 3)" end="(102, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(102, 3)" end="(102, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(102, 5)" end="(102, 8)">
                                  <NullNode/>
                                  <IdentNode start="(102, 5)" end="(102, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(102, 9)" end="(102, 34)">
                              <AtomNode start="(102, 9)" end="(102, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(102, 12)" end="(102, 34)">
                                <TacticTacticseq1IndentedNode start="(102, 12)" end="(102, 34)">
                                  <NullNode start="(102, 12)" end="(102, 34)">
                                    <OtherNode start="(102, 12)" end="(102, 34)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;acc : List β&#10;⊢ filterMapM.loop f [] acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f [] []" state_after="no goals" tactic="simp [filterMapM.loop]">
                                      <AtomNode start="(102, 12)" end="(102, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(102, 17)" end="(102, 34)">
                                        <AtomNode start="(102, 17)" end="(102, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(102, 18)" end="(102, 33)">
                                          <OtherNode start="(102, 18)" end="(102, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(102, 18)" end="(102, 33)" leading="" trailing="" raw_val="filterMapM.loop" val="filterMapM.loop" full_name="List.filterMapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(102, 33)" end="(102, 34)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(103, 3)" end="(110, 11)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(103, 3)" end="(103, 16)">
                              <OtherNode start="(103, 3)" end="(103, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(103, 3)" end="(103, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(103, 5)" end="(103, 9)">
                                  <NullNode/>
                                  <IdentNode start="(103, 5)" end="(103, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(103, 10)" end="(103, 16)">
                                  <IdentNode start="(103, 10)" end="(103, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(103, 12)" end="(103, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(103, 14)" end="(103, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(103, 17)" end="(110, 11)">
                              <AtomNode start="(103, 17)" end="(103, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(104, 5)" end="(110, 11)">
                                <TacticTacticseq1IndentedNode start="(104, 5)" end="(110, 11)">
                                  <NullNode start="(104, 5)" end="(110, 11)">
                                    <OtherNode start="(104, 5)" end="(104, 49)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;⊢ filterMapM.loop f (a :: l) acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f (a :: l) []" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;⊢ (do&#10;      let __do_lift ← f a&#10;      match __do_lift with&#10;        | none =&amp;gt; filterMapM.loop f l acc&#10;        | some b =&amp;gt; filterMapM.loop f l (b :: acc)) =&#10;    do&#10;    let a ← f a&#10;    (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt;&#10;        match a with&#10;        | none =&amp;gt; filterMapM.loop f l []&#10;        | some b =&amp;gt; filterMapM.loop f l [b]" tactic="simp only [filterMapM.loop, _root_.map_bind]">
                                      <AtomNode start="(104, 5)" end="(104, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(104, 10)" end="(104, 14)">
                                        <AtomNode start="(104, 10)" end="(104, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(104, 15)" end="(104, 49)">
                                        <AtomNode start="(104, 15)" end="(104, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(104, 16)" end="(104, 48)">
                                          <OtherNode start="(104, 16)" end="(104, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(104, 16)" end="(104, 31)" leading="" trailing="" raw_val="filterMapM.loop" val="filterMapM.loop" full_name="List.filterMapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(104, 31)" end="(104, 32)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(104, 33)" end="(104, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(104, 33)" end="(104, 48)" leading="" trailing="" raw_val="_root_.map_bind" val="_root_.map_bind" full_name="map_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(104, 48)" end="(104, 49)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(105, 5)" end="(105, 10)" kind="Lean.Parser.Tactic.congr" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;⊢ (do&#10;      let __do_lift ← f a&#10;      match __do_lift with&#10;        | none =&amp;gt; filterMapM.loop f l acc&#10;        | some b =&amp;gt; filterMapM.loop f l (b :: acc)) =&#10;    do&#10;    let a ← f a&#10;    (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt;&#10;        match a with&#10;        | none =&amp;gt; filterMapM.loop f l []&#10;        | some b =&amp;gt; filterMapM.loop f l [b]" state_after="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | none =&amp;gt; filterMapM.loop f l acc&#10;      | some b =&amp;gt; filterMapM.loop f l (b :: acc)) =&#10;    fun a =&amp;gt;&#10;    (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt;&#10;      match a with&#10;      | none =&amp;gt; filterMapM.loop f l []&#10;      | some b =&amp;gt; filterMapM.loop f l [b]" tactic="congr">
                                      <AtomNode start="(105, 5)" end="(105, 10)" leading="" trailing="&#10;    " val="congr"/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(106, 5)" end="(106, 14)" kind="tacticFunext___" state_before="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | none =&amp;gt; filterMapM.loop f l acc&#10;      | some b =&amp;gt; filterMapM.loop f l (b :: acc)) =&#10;    fun a =&amp;gt;&#10;    (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt;&#10;      match a with&#10;      | none =&amp;gt; filterMapM.loop f l []&#10;      | some b =&amp;gt; filterMapM.loop f l [b]" state_after="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;b? : Option β&#10;⊢ (match b? with&#10;    | none =&amp;gt; filterMapM.loop f l acc&#10;    | some b =&amp;gt; filterMapM.loop f l (b :: acc)) =&#10;    (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt;&#10;      match b? with&#10;      | none =&amp;gt; filterMapM.loop f l []&#10;      | some b =&amp;gt; filterMapM.loop f l [b]" tactic="funext b?">
                                      <AtomNode start="(106, 5)" end="(106, 11)" leading="" trailing=" " val="funext"/>
                                      <NullNode start="(106, 12)" end="(106, 14)">
                                        <IdentNode start="(106, 12)" end="(106, 14)" leading="" trailing="&#10;    " raw_val="b?" val="b?"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(107, 5)" end="(107, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;b? : Option β&#10;⊢ (match b? with&#10;    | none =&amp;gt; filterMapM.loop f l acc&#10;    | some b =&amp;gt; filterMapM.loop f l (b :: acc)) =&#10;    (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt;&#10;      match b? with&#10;      | none =&amp;gt; filterMapM.loop f l []&#10;      | some b =&amp;gt; filterMapM.loop f l [b]" state_after="case cons.e_a.h.h_1&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;b : Option β&#10;⊢ filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;&#10;case cons.e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ filterMapM.loop f l (b :: acc) = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l [b]" tactic="split &amp;lt;;&amp;gt; rename_i b">
                                      <OtherNode start="(107, 5)" end="(107, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(107, 5)" end="(107, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(107, 11)" end="(107, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(107, 15)" end="(107, 25)" kind="Lean.Parser.Tactic.renameI">
                                        <AtomNode start="(107, 15)" end="(107, 23)" leading="" trailing=" " val="rename_i"/>
                                        <NullNode start="(107, 24)" end="(107, 25)">
                                          <LeanBinderidentNode start="(107, 24)" end="(107, 25)">
                                            <IdentNode start="(107, 24)" end="(107, 25)" leading="" trailing="&#10;    " raw_val="b" val="b"/>
                                          </LeanBinderidentNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(108, 5)" end="(108, 15)" kind="Lean.cdot" state_before="case cons.e_a.h.h_1&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;b : Option β&#10;⊢ filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;&#10;case cons.e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ filterMapM.loop f l (b :: acc) = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l [b]" state_after="case cons.e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ filterMapM.loop f l (b :: acc) = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l [b]" tactic="· apply ih">
                                      <OtherNode start="(108, 5)" end="(108, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(108, 5)" end="(108, 6)" kind="patternIgnore">
                                          <OtherNode start="(108, 5)" end="(108, 6)" kind="token.«· »">
                                            <AtomNode start="(108, 5)" end="(108, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(108, 7)" end="(108, 15)">
                                        <TacticTacticseq1IndentedNode start="(108, 7)" end="(108, 15)">
                                          <NullNode start="(108, 7)" end="(108, 15)">
                                            <OtherNode start="(108, 7)" end="(108, 15)" kind="Lean.Parser.Tactic.apply" state_before="case cons.e_a.h.h_1&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;b : Option β&#10;⊢ filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []" state_after="no goals" tactic="apply ih">
                                              <AtomNode start="(108, 7)" end="(108, 12)" leading="" trailing=" " val="apply"/>
                                              <IdentNode start="(108, 13)" end="(108, 15)" leading="" trailing="&#10;    " raw_val="ih" val="ih"/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(109, 5)" end="(110, 11)" kind="Lean.cdot" state_before="case cons.e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ filterMapM.loop f l (b :: acc) = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l [b]" state_after="no goals" tactic="· rw [ih, ih (acc := [b])]&#10;  simp">
                                      <OtherNode start="(109, 5)" end="(109, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(109, 5)" end="(109, 6)" kind="patternIgnore">
                                          <OtherNode start="(109, 5)" end="(109, 6)" kind="token.«· »">
                                            <AtomNode start="(109, 5)" end="(109, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(109, 7)" end="(110, 11)">
                                        <TacticTacticseq1IndentedNode start="(109, 7)" end="(110, 11)">
                                          <NullNode start="(109, 7)" end="(110, 11)">
                                            <OtherNode start="(109, 7)" end="(109, 31)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ filterMapM.loop f l (b :: acc) = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l [b]" state_after="case cons.e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ (fun x =&amp;gt; (b :: acc).reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l [] =&#10;    (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; (fun x =&amp;gt; [b].reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []" tactic="rw [ih, ih (acc := [b])]">
                                              <AtomNode start="(109, 7)" end="(109, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(109, 10)" end="(109, 31)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(109, 10)" end="(109, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(109, 11)" end="(109, 30)">
                                                  <OtherNode start="(109, 11)" end="(109, 13)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(109, 11)" end="(109, 13)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                  <AtomNode start="(109, 13)" end="(109, 14)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(109, 15)" end="(109, 30)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <OtherNode start="(109, 15)" end="(109, 30)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(109, 15)" end="(109, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                      <NullNode start="(109, 18)" end="(109, 30)">
                                                        <OtherNode start="(109, 18)" end="(109, 30)" kind="Lean.Parser.Term.namedArgument">
                                                          <AtomNode start="(109, 18)" end="(109, 19)" leading="" trailing="" val="("/>
                                                          <IdentNode start="(109, 19)" end="(109, 22)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                                          <AtomNode start="(109, 23)" end="(109, 25)" leading="" trailing=" " val=":="/>
                                                          <OtherNode start="(109, 26)" end="(109, 29)" kind="«term[_]»">
                                                            <AtomNode start="(109, 26)" end="(109, 27)" leading="" trailing="" val="["/>
                                                            <NullNode start="(109, 27)" end="(109, 28)">
                                                            <IdentNode start="(109, 27)" end="(109, 28)" leading="" trailing="" raw_val="b" val="b"/>
                                                            </NullNode>
                                                            <AtomNode start="(109, 28)" end="(109, 29)" leading="" trailing="" val="]"/>
                                                          </OtherNode>
                                                          <AtomNode start="(109, 29)" end="(109, 30)" leading="" trailing="" val=")"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(109, 30)" end="(109, 31)" leading="" trailing="&#10;      " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(110, 7)" end="(110, 11)" kind="Lean.Parser.Tactic.simp" state_before="case cons.e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List β}, filterMapM.loop f l acc = (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []&#10;acc : List β&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ (fun x =&amp;gt; (b :: acc).reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l [] =&#10;    (fun x =&amp;gt; acc.reverse ++ x) &amp;lt;$&amp;gt; (fun x =&amp;gt; [b].reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l []" state_after="no goals" tactic="simp">
                                              <AtomNode start="(110, 7)" end="(110, 11)" leading="" trailing="&#10;&#10;" val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(112, 1)" end="(124, 9)" name="filterMapM_cons" full_name="List.filterMapM_cons">
      <CommandDeclmodifiersNode start="(112, 1)" end="(112, 8)">
        <NullNode/>
        <NullNode start="(112, 1)" end="(112, 8)">
          <OtherNode start="(112, 1)" end="(112, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(112, 1)" end="(112, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(112, 3)" end="(112, 7)">
              <OtherNode start="(112, 3)" end="(112, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(112, 3)" end="(112, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(112, 3)" end="(112, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(112, 7)" end="(112, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(112, 9)" end="(124, 9)" name="filterMapM_cons" full_name="List.filterMapM_cons" _is_private_decl="False">
        <AtomNode start="(112, 9)" end="(112, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(112, 17)" end="(112, 32)">
          <IdentNode start="(112, 17)" end="(112, 32)" leading="" trailing=" " raw_val="filterMapM_cons" val="filterMapM_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(112, 33)" end="(116, 51)">
          <NullNode start="(112, 33)" end="(112, 81)">
            <OtherNode start="(112, 33)" end="(112, 42)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(112, 33)" end="(112, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(112, 34)" end="(112, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(112, 34)" end="(112, 39)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(112, 40)" end="(112, 41)">
                  <IdentNode start="(112, 40)" end="(112, 41)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(112, 41)" end="(112, 42)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(112, 43)" end="(112, 58)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(112, 43)" end="(112, 44)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(112, 44)" end="(112, 57)" kind="Lean.Parser.Term.app">
                <IdentNode start="(112, 44)" end="(112, 55)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(112, 56)" end="(112, 57)">
                  <IdentNode start="(112, 56)" end="(112, 57)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(112, 57)" end="(112, 58)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(112, 59)" end="(112, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(112, 59)" end="(112, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(112, 60)" end="(112, 61)">
                <IdentNode start="(112, 60)" end="(112, 61)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(112, 62)" end="(112, 80)">
                <AtomNode start="(112, 62)" end="(112, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(112, 64)" end="(112, 80)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(112, 64)" end="(112, 65)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(112, 66)" end="(112, 67)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(112, 68)" end="(112, 80)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(112, 68)" end="(112, 69)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(112, 70)" end="(112, 80)">
                      <OtherNode start="(112, 70)" end="(112, 80)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(112, 70)" end="(112, 71)" leading="" trailing="" val="("/>
                        <OtherNode start="(112, 71)" end="(112, 79)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(112, 71)" end="(112, 77)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(112, 78)" end="(112, 79)">
                            <IdentNode start="(112, 78)" end="(112, 79)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(112, 79)" end="(112, 80)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(112, 80)" end="(112, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(112, 82)" end="(116, 51)">
            <AtomNode start="(112, 82)" end="(112, 83)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(113, 5)" end="(116, 51)" kind="«term_=_»">
              <OtherNode start="(113, 5)" end="(113, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(113, 5)" end="(113, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(113, 5)" end="(113, 13)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(113, 5)" end="(113, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(113, 6)" end="(113, 12)" kind="«term_::_»">
                      <IdentNode start="(113, 6)" end="(113, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(113, 8)" end="(113, 10)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(113, 11)" end="(113, 12)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(113, 12)" end="(113, 13)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(113, 13)" end="(113, 14)" leading="" trailing="" val="."/>
                  <IdentNode start="(113, 14)" end="(113, 24)" leading="" trailing=" " raw_val="filterMapM" val="filterMapM" full_name="List.filterMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(113, 25)" end="(113, 26)">
                  <IdentNode start="(113, 25)" end="(113, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(113, 27)" end="(113, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(113, 29)" end="(116, 51)" kind="Lean.Parser.Term.do">
                <AtomNode start="(113, 29)" end="(113, 31)" leading="" trailing="&#10;      " val="do"/>
                <OtherNode start="(114, 7)" end="(116, 51)" kind="Lean.Parser.Term.doSeqIndent">
                  <NullNode start="(114, 7)" end="(116, 51)">
                    <OtherNode start="(114, 7)" end="(116, 51)" kind="Lean.Parser.Term.doSeqItem">
                      <OtherNode start="(114, 7)" end="(116, 51)" kind="Lean.Parser.Term.doMatch">
                        <AtomNode start="(114, 7)" end="(114, 12)" leading="" trailing=" " val="match"/>
                        <NullNode/>
                        <NullNode/>
                        <NullNode start="(114, 13)" end="(114, 20)">
                          <OtherNode start="(114, 13)" end="(114, 20)" kind="Lean.Parser.Term.matchDiscr">
                            <NullNode/>
                            <OtherNode start="(114, 13)" end="(114, 20)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(114, 13)" end="(114, 14)" leading="" trailing="" val="("/>
                              <OtherNode start="(114, 14)" end="(114, 19)" kind="Lean.Parser.Term.liftMethod">
                                <AtomNode start="(114, 14)" end="(114, 15)" leading="" trailing=" " val="←"/>
                                <OtherNode start="(114, 16)" end="(114, 19)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(114, 16)" end="(114, 17)" leading="" trailing=" " raw_val="f" val="f"/>
                                  <NullNode start="(114, 18)" end="(114, 19)">
                                    <IdentNode start="(114, 18)" end="(114, 19)" leading="" trailing="" raw_val="a" val="a"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(114, 19)" end="(114, 20)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(114, 21)" end="(114, 25)" leading="" trailing="&#10;      " val="with"/>
                        <OtherNode start="(115, 7)" end="(116, 51)" kind="Lean.Parser.Term.matchAlts">
                          <NullNode start="(115, 7)" end="(116, 51)">
                            <OtherNode start="(115, 7)" end="(115, 31)" kind="Lean.Parser.Term.matchAlt">
                              <AtomNode start="(115, 7)" end="(115, 8)" leading="" trailing=" " val="|"/>
                              <NullNode start="(115, 9)" end="(115, 13)">
                                <NullNode start="(115, 9)" end="(115, 13)">
                                  <IdentNode start="(115, 9)" end="(115, 13)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </NullNode>
                              </NullNode>
                              <AtomNode start="(115, 14)" end="(115, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(115, 17)" end="(115, 31)" kind="Lean.Parser.Term.doSeqIndent">
                                <NullNode start="(115, 17)" end="(115, 31)">
                                  <OtherNode start="(115, 17)" end="(115, 31)" kind="Lean.Parser.Term.doSeqItem">
                                    <OtherNode start="(115, 17)" end="(115, 31)" kind="Lean.Parser.Term.doExpr">
                                      <OtherNode start="(115, 17)" end="(115, 31)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(115, 17)" end="(115, 27)" leading="" trailing=" " raw_val="filterMapM" val="filterMapM" full_name="List.filterMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                        <NullNode start="(115, 28)" end="(115, 31)">
                                          <IdentNode start="(115, 28)" end="(115, 29)" leading="" trailing=" " raw_val="f" val="f"/>
                                          <IdentNode start="(115, 30)" end="(115, 31)" leading="" trailing="&#10;      " raw_val="l" val="l"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                            <OtherNode start="(116, 7)" end="(116, 51)" kind="Lean.Parser.Term.matchAlt">
                              <AtomNode start="(116, 7)" end="(116, 8)" leading="" trailing=" " val="|"/>
                              <NullNode start="(116, 9)" end="(116, 15)">
                                <NullNode start="(116, 9)" end="(116, 15)">
                                  <OtherNode start="(116, 9)" end="(116, 15)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(116, 9)" end="(116, 13)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(116, 14)" end="(116, 15)">
                                      <IdentNode start="(116, 14)" end="(116, 15)" leading="" trailing=" " raw_val="b" val="b"/>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                              </NullNode>
                              <AtomNode start="(116, 16)" end="(116, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(116, 19)" end="(116, 51)" kind="Lean.Parser.Term.doSeqIndent">
                                <NullNode start="(116, 19)" end="(116, 51)">
                                  <OtherNode start="(116, 19)" end="(116, 51)" kind="Lean.Parser.Term.doSeqItem">
                                    <OtherNode start="(116, 19)" end="(116, 51)" kind="Lean.Parser.Term.doReturn">
                                      <AtomNode start="(116, 19)" end="(116, 25)" leading="" trailing=" " val="return"/>
                                      <NullNode start="(116, 26)" end="(116, 51)">
                                        <OtherNode start="(116, 26)" end="(116, 51)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(116, 26)" end="(116, 27)" leading="" trailing="" val="("/>
                                          <OtherNode start="(116, 27)" end="(116, 50)" kind="«term_::_»">
                                            <IdentNode start="(116, 27)" end="(116, 28)" leading="" trailing=" " raw_val="b" val="b"/>
                                            <AtomNode start="(116, 29)" end="(116, 31)" leading="" trailing=" " val="::"/>
                                            <OtherNode start="(116, 32)" end="(116, 50)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(116, 32)" end="(116, 33)" leading="" trailing="" val="("/>
                                              <OtherNode start="(116, 33)" end="(116, 49)" kind="Lean.Parser.Term.liftMethod">
                                                <AtomNode start="(116, 33)" end="(116, 34)" leading="" trailing=" " val="←"/>
                                                <OtherNode start="(116, 35)" end="(116, 49)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(116, 35)" end="(116, 45)" leading="" trailing=" " raw_val="filterMapM" val="filterMapM" full_name="List.filterMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                                  <NullNode start="(116, 46)" end="(116, 49)">
                                                    <IdentNode start="(116, 46)" end="(116, 47)" leading="" trailing=" " raw_val="f" val="f"/>
                                                    <IdentNode start="(116, 48)" end="(116, 49)" leading="" trailing="" raw_val="l" val="l"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(116, 49)" end="(116, 50)" leading="" trailing="" val=")"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(116, 50)" end="(116, 51)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                      <NullNode/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(116, 52)" end="(124, 9)">
          <AtomNode start="(116, 52)" end="(116, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(116, 55)" end="(124, 9)">
            <AtomNode start="(116, 55)" end="(116, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(117, 3)" end="(124, 9)">
              <TacticTacticseq1IndentedNode start="(117, 3)" end="(124, 9)">
                <NullNode start="(117, 3)" end="(124, 9)">
                  <OtherNode start="(117, 3)" end="(117, 57)" kind="Lean.Parser.Tactic.Conv.conv" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;⊢ filterMapM f (a :: l) = do&#10;    let __do_lift ← f a&#10;    match __do_lift with&#10;      | none =&amp;gt; filterMapM f l&#10;      | some b =&amp;gt; do&#10;        let __do_lift ← filterMapM f l&#10;        pure (b :: __do_lift)" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;⊢ (do&#10;      let __do_lift ← f a&#10;      match __do_lift with&#10;        | none =&amp;gt; filterMapM.loop f l []&#10;        | some b =&amp;gt; filterMapM.loop f l [b]) =&#10;    do&#10;    let __do_lift ← f a&#10;    match __do_lift with&#10;      | none =&amp;gt; filterMapM f l&#10;      | some b =&amp;gt; do&#10;        let __do_lift ← filterMapM f l&#10;        pure (b :: __do_lift)" tactic="conv =&amp;gt; lhs; unfold filterMapM; unfold filterMapM.loop">
                    <AtomNode start="(117, 3)" end="(117, 7)" leading="" trailing=" " val="conv"/>
                    <NullNode/>
                    <NullNode/>
                    <AtomNode start="(117, 8)" end="(117, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(117, 11)" end="(117, 57)" kind="Lean.Parser.Tactic.Conv.convSeq">
                      <OtherNode start="(117, 11)" end="(117, 57)" kind="Lean.Parser.Tactic.Conv.convSeq1Indented">
                        <NullNode start="(117, 11)" end="(117, 57)">
                          <OtherNode start="(117, 11)" end="(117, 14)" kind="Lean.Parser.Tactic.Conv.lhs">
                            <AtomNode start="(117, 11)" end="(117, 14)" leading="" trailing="" val="lhs"/>
                          </OtherNode>
                          <AtomNode start="(117, 14)" end="(117, 15)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(117, 16)" end="(117, 33)" kind="Lean.Parser.Tactic.Conv.unfold">
                            <AtomNode start="(117, 16)" end="(117, 22)" leading="" trailing=" " val="unfold"/>
                            <NullNode start="(117, 23)" end="(117, 33)">
                              <IdentNode start="(117, 23)" end="(117, 33)" leading="" trailing="" raw_val="filterMapM" val="filterMapM" full_name="List.filterMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(117, 33)" end="(117, 34)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(117, 35)" end="(117, 57)" kind="Lean.Parser.Tactic.Conv.unfold">
                            <AtomNode start="(117, 35)" end="(117, 41)" leading="" trailing=" " val="unfold"/>
                            <NullNode start="(117, 42)" end="(117, 57)">
                              <IdentNode start="(117, 42)" end="(117, 57)" leading="" trailing="&#10;  " raw_val="filterMapM.loop" val="filterMapM.loop" full_name="List.filterMapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(118, 3)" end="(118, 8)" kind="Lean.Parser.Tactic.congr" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;⊢ (do&#10;      let __do_lift ← f a&#10;      match __do_lift with&#10;        | none =&amp;gt; filterMapM.loop f l []&#10;        | some b =&amp;gt; filterMapM.loop f l [b]) =&#10;    do&#10;    let __do_lift ← f a&#10;    match __do_lift with&#10;      | none =&amp;gt; filterMapM f l&#10;      | some b =&amp;gt; do&#10;        let __do_lift ← filterMapM f l&#10;        pure (b :: __do_lift)" state_after="case e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | none =&amp;gt; filterMapM.loop f l []&#10;      | some b =&amp;gt; filterMapM.loop f l [b]) =&#10;    fun __do_lift =&amp;gt;&#10;    match __do_lift with&#10;    | none =&amp;gt; filterMapM f l&#10;    | some b =&amp;gt; do&#10;      let __do_lift ← filterMapM f l&#10;      pure (b :: __do_lift)" tactic="congr">
                    <AtomNode start="(118, 3)" end="(118, 8)" leading="" trailing="&#10;  " val="congr"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(119, 3)" end="(119, 12)" kind="tacticFunext___" state_before="case e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | none =&amp;gt; filterMapM.loop f l []&#10;      | some b =&amp;gt; filterMapM.loop f l [b]) =&#10;    fun __do_lift =&amp;gt;&#10;    match __do_lift with&#10;    | none =&amp;gt; filterMapM f l&#10;    | some b =&amp;gt; do&#10;      let __do_lift ← filterMapM f l&#10;      pure (b :: __do_lift)" state_after="case e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;b? : Option β&#10;⊢ (match b? with&#10;    | none =&amp;gt; filterMapM.loop f l []&#10;    | some b =&amp;gt; filterMapM.loop f l [b]) =&#10;    match b? with&#10;    | none =&amp;gt; filterMapM f l&#10;    | some b =&amp;gt; do&#10;      let __do_lift ← filterMapM f l&#10;      pure (b :: __do_lift)" tactic="funext b?">
                    <AtomNode start="(119, 3)" end="(119, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(119, 10)" end="(119, 12)">
                      <IdentNode start="(119, 10)" end="(119, 12)" leading="" trailing="&#10;  " raw_val="b?" val="b?"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(120, 3)" end="(120, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;b? : Option β&#10;⊢ (match b? with&#10;    | none =&amp;gt; filterMapM.loop f l []&#10;    | some b =&amp;gt; filterMapM.loop f l [b]) =&#10;    match b? with&#10;    | none =&amp;gt; filterMapM f l&#10;    | some b =&amp;gt; do&#10;      let __do_lift ← filterMapM f l&#10;      pure (b :: __do_lift)" state_after="case e_a.h.h_1&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;b : Option β&#10;⊢ filterMapM.loop f l [] =&#10;    match none with&#10;    | none =&amp;gt; filterMapM f l&#10;    | some b =&amp;gt; do&#10;      let __do_lift ← filterMapM f l&#10;      pure (b :: __do_lift)&#10;&#10;case e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ filterMapM.loop f l [b] =&#10;    match some b with&#10;    | none =&amp;gt; filterMapM f l&#10;    | some b =&amp;gt; do&#10;      let __do_lift ← filterMapM f l&#10;      pure (b :: __do_lift)" tactic="split &amp;lt;;&amp;gt; rename_i b">
                    <OtherNode start="(120, 3)" end="(120, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(120, 3)" end="(120, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(120, 9)" end="(120, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(120, 13)" end="(120, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(120, 13)" end="(120, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(120, 22)" end="(120, 23)">
                        <LeanBinderidentNode start="(120, 22)" end="(120, 23)">
                          <IdentNode start="(120, 22)" end="(120, 23)" leading="" trailing="&#10;  " raw_val="b" val="b"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(121, 3)" end="(121, 22)" kind="Lean.cdot" state_before="case e_a.h.h_1&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;b : Option β&#10;⊢ filterMapM.loop f l [] =&#10;    match none with&#10;    | none =&amp;gt; filterMapM f l&#10;    | some b =&amp;gt; do&#10;      let __do_lift ← filterMapM f l&#10;      pure (b :: __do_lift)&#10;&#10;case e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ filterMapM.loop f l [b] =&#10;    match some b with&#10;    | none =&amp;gt; filterMapM f l&#10;    | some b =&amp;gt; do&#10;      let __do_lift ← filterMapM f l&#10;      pure (b :: __do_lift)" state_after="case e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ filterMapM.loop f l [b] =&#10;    match some b with&#10;    | none =&amp;gt; filterMapM f l&#10;    | some b =&amp;gt; do&#10;      let __do_lift ← filterMapM f l&#10;      pure (b :: __do_lift)" tactic="· simp [filterMapM]">
                    <OtherNode start="(121, 3)" end="(121, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(121, 3)" end="(121, 4)" kind="patternIgnore">
                        <OtherNode start="(121, 3)" end="(121, 4)" kind="token.«· »">
                          <AtomNode start="(121, 3)" end="(121, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(121, 5)" end="(121, 22)">
                      <TacticTacticseq1IndentedNode start="(121, 5)" end="(121, 22)">
                        <NullNode start="(121, 5)" end="(121, 22)">
                          <OtherNode start="(121, 5)" end="(121, 22)" kind="Lean.Parser.Tactic.simp" state_before="case e_a.h.h_1&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;b : Option β&#10;⊢ filterMapM.loop f l [] =&#10;    match none with&#10;    | none =&amp;gt; filterMapM f l&#10;    | some b =&amp;gt; do&#10;      let __do_lift ← filterMapM f l&#10;      pure (b :: __do_lift)" state_after="no goals" tactic="simp [filterMapM]">
                            <AtomNode start="(121, 5)" end="(121, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(121, 10)" end="(121, 22)">
                              <AtomNode start="(121, 10)" end="(121, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(121, 11)" end="(121, 21)">
                                <OtherNode start="(121, 11)" end="(121, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(121, 11)" end="(121, 21)" leading="" trailing="" raw_val="filterMapM" val="filterMapM" full_name="List.filterMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(121, 21)" end="(121, 22)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(122, 3)" end="(124, 9)" kind="Lean.cdot" state_before="case e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ filterMapM.loop f l [b] =&#10;    match some b with&#10;    | none =&amp;gt; filterMapM f l&#10;    | some b =&amp;gt; do&#10;      let __do_lift ← filterMapM f l&#10;      pure (b :: __do_lift)" state_after="no goals" tactic="· simp only [bind_pure_comp]&#10;  rw [filterMapM_loop_eq, filterMapM]&#10;  simp">
                    <OtherNode start="(122, 3)" end="(122, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(122, 3)" end="(122, 4)" kind="patternIgnore">
                        <OtherNode start="(122, 3)" end="(122, 4)" kind="token.«· »">
                          <AtomNode start="(122, 3)" end="(122, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(122, 5)" end="(124, 9)">
                      <TacticTacticseq1IndentedNode start="(122, 5)" end="(124, 9)">
                        <NullNode start="(122, 5)" end="(124, 9)">
                          <OtherNode start="(122, 5)" end="(122, 31)" kind="Lean.Parser.Tactic.simp" state_before="case e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ filterMapM.loop f l [b] =&#10;    match some b with&#10;    | none =&amp;gt; filterMapM f l&#10;    | some b =&amp;gt; do&#10;      let __do_lift ← filterMapM f l&#10;      pure (b :: __do_lift)" state_after="case e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ filterMapM.loop f l [b] = cons b &amp;lt;$&amp;gt; filterMapM f l" tactic="simp only [bind_pure_comp]">
                            <AtomNode start="(122, 5)" end="(122, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(122, 10)" end="(122, 14)">
                              <AtomNode start="(122, 10)" end="(122, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(122, 15)" end="(122, 31)">
                              <AtomNode start="(122, 15)" end="(122, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(122, 16)" end="(122, 30)">
                                <OtherNode start="(122, 16)" end="(122, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(122, 16)" end="(122, 30)" leading="" trailing="" raw_val="bind_pure_comp" val="bind_pure_comp" full_name="LawfulMonad.bind_pure_comp" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(122, 30)" end="(122, 31)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(123, 5)" end="(123, 40)" kind="Lean.Parser.Tactic.rwSeq" state_before="case e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ filterMapM.loop f l [b] = cons b &amp;lt;$&amp;gt; filterMapM f l" state_after="case e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ (fun x =&amp;gt; [b].reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l [] = cons b &amp;lt;$&amp;gt; filterMapM.loop f l []" tactic="rw [filterMapM_loop_eq, filterMapM]">
                            <AtomNode start="(123, 5)" end="(123, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(123, 8)" end="(123, 40)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(123, 8)" end="(123, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(123, 9)" end="(123, 39)">
                                <OtherNode start="(123, 9)" end="(123, 27)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(123, 9)" end="(123, 27)" leading="" trailing="" raw_val="filterMapM_loop_eq" val="filterMapM_loop_eq" full_name="List.filterMapM_loop_eq" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(99, 9)" def_end="(99, 27)"/>
                                </OtherNode>
                                <AtomNode start="(123, 27)" end="(123, 28)" leading="" trailing=" " val=","/>
                                <OtherNode start="(123, 29)" end="(123, 39)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(123, 29)" end="(123, 39)" leading="" trailing="" raw_val="filterMapM" val="filterMapM" full_name="List.filterMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(123, 39)" end="(123, 40)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(124, 5)" end="(124, 9)" kind="Lean.Parser.Tactic.simp" state_before="case e_a.h.h_2&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (Option β)&#10;__do_lift✝ : Option β&#10;b : β&#10;⊢ (fun x =&amp;gt; [b].reverse ++ x) &amp;lt;$&amp;gt; filterMapM.loop f l [] = cons b &amp;lt;$&amp;gt; filterMapM.loop f l []" state_after="no goals" tactic="simp">
                            <AtomNode start="(124, 5)" end="(124, 9)" leading="" trailing="&#10;&#10;" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(126, 1)" end="(126, 20)" comment="### flatMapM -/">
      <AtomNode start="(126, 1)" end="(126, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(126, 5)" end="(126, 20)" leading="" trailing="&#10;&#10;" val="### flatMapM -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(128, 1)" end="(128, 93)" name="flatMapM_nil" full_name="List.flatMapM_nil">
      <CommandDeclmodifiersNode start="(128, 1)" end="(128, 8)">
        <NullNode/>
        <NullNode start="(128, 1)" end="(128, 8)">
          <OtherNode start="(128, 1)" end="(128, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(128, 1)" end="(128, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(128, 3)" end="(128, 7)">
              <OtherNode start="(128, 3)" end="(128, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(128, 3)" end="(128, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(128, 3)" end="(128, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(128, 7)" end="(128, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(128, 9)" end="(128, 93)" name="flatMapM_nil" full_name="List.flatMapM_nil" _is_private_decl="False">
        <AtomNode start="(128, 9)" end="(128, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(128, 17)" end="(128, 29)">
          <IdentNode start="(128, 17)" end="(128, 29)" leading="" trailing=" " raw_val="flatMapM_nil" val="flatMapM_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(128, 30)" end="(128, 86)">
          <NullNode start="(128, 30)" end="(128, 60)">
            <OtherNode start="(128, 30)" end="(128, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(128, 30)" end="(128, 31)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(128, 31)" end="(128, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(128, 31)" end="(128, 36)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(128, 37)" end="(128, 38)">
                  <IdentNode start="(128, 37)" end="(128, 38)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(128, 38)" end="(128, 39)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(128, 40)" end="(128, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(128, 40)" end="(128, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(128, 41)" end="(128, 42)">
                <IdentNode start="(128, 41)" end="(128, 42)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(128, 43)" end="(128, 59)">
                <AtomNode start="(128, 43)" end="(128, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(128, 45)" end="(128, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(128, 45)" end="(128, 46)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(128, 47)" end="(128, 48)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(128, 49)" end="(128, 59)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(128, 49)" end="(128, 50)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(128, 51)" end="(128, 59)">
                      <OtherNode start="(128, 51)" end="(128, 59)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(128, 51)" end="(128, 52)" leading="" trailing="" val="("/>
                        <OtherNode start="(128, 52)" end="(128, 58)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(128, 52)" end="(128, 56)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(128, 57)" end="(128, 58)">
                            <IdentNode start="(128, 57)" end="(128, 58)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(128, 58)" end="(128, 59)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(128, 59)" end="(128, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(128, 61)" end="(128, 86)">
            <AtomNode start="(128, 61)" end="(128, 62)" leading="" trailing=" " val=":"/>
            <OtherNode start="(128, 63)" end="(128, 86)" kind="«term_=_»">
              <OtherNode start="(128, 63)" end="(128, 76)" kind="Lean.Parser.Term.app">
                <OtherNode start="(128, 63)" end="(128, 74)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(128, 63)" end="(128, 65)" kind="«term[_]»">
                    <AtomNode start="(128, 63)" end="(128, 64)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(128, 64)" end="(128, 65)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(128, 65)" end="(128, 66)" leading="" trailing="" val="."/>
                  <IdentNode start="(128, 66)" end="(128, 74)" leading="" trailing=" " raw_val="flatMapM" val="flatMapM" full_name="List.flatMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(128, 75)" end="(128, 76)">
                  <IdentNode start="(128, 75)" end="(128, 76)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(128, 77)" end="(128, 78)" leading="" trailing=" " val="="/>
              <OtherNode start="(128, 79)" end="(128, 86)" kind="Lean.Parser.Term.app">
                <IdentNode start="(128, 79)" end="(128, 83)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(128, 84)" end="(128, 86)">
                  <OtherNode start="(128, 84)" end="(128, 86)" kind="«term[_]»">
                    <AtomNode start="(128, 84)" end="(128, 85)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(128, 85)" end="(128, 86)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(128, 87)" end="(128, 93)">
          <AtomNode start="(128, 87)" end="(128, 89)" leading="" trailing=" " val=":="/>
          <IdentNode start="(128, 90)" end="(128, 93)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(130, 1)" end="(139, 9)" name="flatMapM_loop_eq" full_name="List.flatMapM_loop_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(130, 1)" end="(139, 9)" name="flatMapM_loop_eq" full_name="List.flatMapM_loop_eq" _is_private_decl="False">
        <AtomNode start="(130, 1)" end="(130, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(130, 9)" end="(130, 25)">
          <IdentNode start="(130, 9)" end="(130, 25)" leading="" trailing=" " raw_val="flatMapM_loop_eq" val="flatMapM_loop_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(130, 26)" end="(131, 80)">
          <NullNode start="(130, 26)" end="(130, 107)">
            <OtherNode start="(130, 26)" end="(130, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(130, 26)" end="(130, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(130, 27)" end="(130, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(130, 27)" end="(130, 32)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(130, 33)" end="(130, 34)">
                  <IdentNode start="(130, 33)" end="(130, 34)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(130, 34)" end="(130, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(130, 36)" end="(130, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(130, 36)" end="(130, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(130, 37)" end="(130, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(130, 37)" end="(130, 48)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(130, 49)" end="(130, 50)">
                  <IdentNode start="(130, 49)" end="(130, 50)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(130, 50)" end="(130, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(130, 52)" end="(130, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(130, 52)" end="(130, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(130, 53)" end="(130, 54)">
                <IdentNode start="(130, 53)" end="(130, 54)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(130, 55)" end="(130, 71)">
                <AtomNode start="(130, 55)" end="(130, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(130, 57)" end="(130, 71)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(130, 57)" end="(130, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(130, 59)" end="(130, 60)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(130, 61)" end="(130, 71)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(130, 61)" end="(130, 62)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(130, 63)" end="(130, 71)">
                      <OtherNode start="(130, 63)" end="(130, 71)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(130, 63)" end="(130, 64)" leading="" trailing="" val="("/>
                        <OtherNode start="(130, 64)" end="(130, 70)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(130, 64)" end="(130, 68)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(130, 69)" end="(130, 70)">
                            <IdentNode start="(130, 69)" end="(130, 70)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(130, 70)" end="(130, 71)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(130, 71)" end="(130, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(130, 73)" end="(130, 85)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(130, 73)" end="(130, 74)" leading="" trailing="" val="{"/>
              <NullNode start="(130, 74)" end="(130, 75)">
                <IdentNode start="(130, 74)" end="(130, 75)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(130, 76)" end="(130, 84)">
                <AtomNode start="(130, 76)" end="(130, 77)" leading="" trailing=" " val=":"/>
                <OtherNode start="(130, 78)" end="(130, 84)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(130, 78)" end="(130, 82)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(130, 83)" end="(130, 84)">
                    <IdentNode start="(130, 83)" end="(130, 84)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(130, 84)" end="(130, 85)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(130, 86)" end="(130, 107)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(130, 86)" end="(130, 87)" leading="" trailing="" val="{"/>
              <NullNode start="(130, 87)" end="(130, 90)">
                <IdentNode start="(130, 87)" end="(130, 90)" leading="" trailing=" " raw_val="acc" val="acc"/>
              </NullNode>
              <NullNode start="(130, 91)" end="(130, 106)">
                <AtomNode start="(130, 91)" end="(130, 92)" leading="" trailing=" " val=":"/>
                <OtherNode start="(130, 93)" end="(130, 106)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(130, 93)" end="(130, 97)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(130, 98)" end="(130, 106)">
                    <OtherNode start="(130, 98)" end="(130, 106)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(130, 98)" end="(130, 99)" leading="" trailing="" val="("/>
                      <OtherNode start="(130, 99)" end="(130, 105)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(130, 99)" end="(130, 103)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(130, 104)" end="(130, 105)">
                          <IdentNode start="(130, 104)" end="(130, 105)" leading="" trailing="" raw_val="β" val="β"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(130, 105)" end="(130, 106)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(130, 106)" end="(130, 107)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(130, 108)" end="(131, 80)">
            <AtomNode start="(130, 108)" end="(130, 109)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(131, 5)" end="(131, 80)" kind="«term_=_»">
              <OtherNode start="(131, 5)" end="(131, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(131, 5)" end="(131, 18)" leading="" trailing=" " raw_val="flatMapM.loop" val="flatMapM.loop" full_name="List.flatMapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                <NullNode start="(131, 19)" end="(131, 26)">
                  <IdentNode start="(131, 19)" end="(131, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(131, 21)" end="(131, 22)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(131, 23)" end="(131, 26)" leading="" trailing=" " raw_val="acc" val="acc"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(131, 27)" end="(131, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(131, 29)" end="(131, 80)" kind="«term_&amp;lt;$&amp;gt;_»">
                <OtherNode start="(131, 29)" end="(131, 55)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(131, 29)" end="(131, 30)" leading="" trailing="" val="("/>
                  <OtherNode start="(131, 30)" end="(131, 54)" kind="«term_++_»">
                    <IdentNode start="(131, 30)" end="(131, 49)" leading="" trailing=" " raw_val="acc.reverse.flatten" val="acc.reverse.flatten"/>
                    <AtomNode start="(131, 50)" end="(131, 52)" leading="" trailing=" " val="++"/>
                    <OtherNode start="(131, 53)" end="(131, 54)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(131, 53)" end="(131, 54)" leading="" trailing="" val="·"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(131, 54)" end="(131, 55)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(131, 56)" end="(131, 59)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(131, 60)" end="(131, 80)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(131, 60)" end="(131, 73)" leading="" trailing=" " raw_val="flatMapM.loop" val="flatMapM.loop" full_name="List.flatMapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                  <NullNode start="(131, 74)" end="(131, 80)">
                    <IdentNode start="(131, 74)" end="(131, 75)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(131, 76)" end="(131, 77)" leading="" trailing=" " raw_val="l" val="l"/>
                    <OtherNode start="(131, 78)" end="(131, 80)" kind="«term[_]»">
                      <AtomNode start="(131, 78)" end="(131, 79)" leading="" trailing="" val="["/>
                      <NullNode/>
                      <AtomNode start="(131, 79)" end="(131, 80)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(131, 81)" end="(139, 9)">
          <AtomNode start="(131, 81)" end="(131, 83)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(131, 84)" end="(139, 9)">
            <AtomNode start="(131, 84)" end="(131, 86)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(132, 3)" end="(139, 9)">
              <TacticTacticseq1IndentedNode start="(132, 3)" end="(139, 9)">
                <NullNode start="(132, 3)" end="(139, 9)">
                  <OtherNode start="(132, 3)" end="(139, 9)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;l : List α&#10;acc : List (List β)&#10;⊢ flatMapM.loop f l acc = (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l []" state_after="no goals" tactic="induction l generalizing acc with&#10;| nil =&amp;gt; simp [flatMapM.loop]&#10;| cons a l ih =&amp;gt;&#10;  simp only [flatMapM.loop, append_nil, _root_.map_bind]&#10;  congr&#10;  funext bs&#10;  rw [ih, ih (acc := [bs])]&#10;  simp">
                    <AtomNode start="(132, 3)" end="(132, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(132, 13)" end="(132, 14)">
                      <OtherNode start="(132, 13)" end="(132, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(132, 13)" end="(132, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(132, 15)" end="(132, 31)">
                      <AtomNode start="(132, 15)" end="(132, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(132, 28)" end="(132, 31)">
                        <IdentNode start="(132, 28)" end="(132, 31)" leading="" trailing=" " raw_val="acc" val="acc"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(132, 32)" end="(139, 9)">
                      <OtherNode start="(132, 32)" end="(139, 9)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(132, 32)" end="(132, 36)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(133, 3)" end="(139, 9)">
                          <OtherNode start="(133, 3)" end="(133, 32)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(133, 3)" end="(133, 8)">
                              <OtherNode start="(133, 3)" end="(133, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(133, 3)" end="(133, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(133, 5)" end="(133, 8)">
                                  <NullNode/>
                                  <IdentNode start="(133, 5)" end="(133, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(133, 9)" end="(133, 32)">
                              <AtomNode start="(133, 9)" end="(133, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(133, 12)" end="(133, 32)">
                                <TacticTacticseq1IndentedNode start="(133, 12)" end="(133, 32)">
                                  <NullNode start="(133, 12)" end="(133, 32)">
                                    <OtherNode start="(133, 12)" end="(133, 32)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;acc : List (List β)&#10;⊢ flatMapM.loop f [] acc = (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f [] []" state_after="no goals" tactic="simp [flatMapM.loop]">
                                      <AtomNode start="(133, 12)" end="(133, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(133, 17)" end="(133, 32)">
                                        <AtomNode start="(133, 17)" end="(133, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(133, 18)" end="(133, 31)">
                                          <OtherNode start="(133, 18)" end="(133, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(133, 18)" end="(133, 31)" leading="" trailing="" raw_val="flatMapM.loop" val="flatMapM.loop" full_name="List.flatMapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(133, 31)" end="(133, 32)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(134, 3)" end="(139, 9)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(134, 3)" end="(134, 16)">
                              <OtherNode start="(134, 3)" end="(134, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(134, 3)" end="(134, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(134, 5)" end="(134, 9)">
                                  <NullNode/>
                                  <IdentNode start="(134, 5)" end="(134, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(134, 10)" end="(134, 16)">
                                  <IdentNode start="(134, 10)" end="(134, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(134, 12)" end="(134, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(134, 14)" end="(134, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(134, 17)" end="(139, 9)">
                              <AtomNode start="(134, 17)" end="(134, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(135, 5)" end="(139, 9)">
                                <TacticTacticseq1IndentedNode start="(135, 5)" end="(139, 9)">
                                  <NullNode start="(135, 5)" end="(139, 9)">
                                    <OtherNode start="(135, 5)" end="(135, 59)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List (List β)}, flatMapM.loop f l acc = (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l []&#10;acc : List (List β)&#10;⊢ flatMapM.loop f (a :: l) acc = (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f (a :: l) []" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List (List β)}, flatMapM.loop f l acc = (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l []&#10;acc : List (List β)&#10;⊢ (do&#10;      let bs' ← f a&#10;      flatMapM.loop f l (bs' :: acc)) =&#10;    do&#10;    let a ← f a&#10;    (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l [a]" tactic="simp only [flatMapM.loop, append_nil, _root_.map_bind]">
                                      <AtomNode start="(135, 5)" end="(135, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(135, 10)" end="(135, 14)">
                                        <AtomNode start="(135, 10)" end="(135, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(135, 15)" end="(135, 59)">
                                        <AtomNode start="(135, 15)" end="(135, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(135, 16)" end="(135, 58)">
                                          <OtherNode start="(135, 16)" end="(135, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(135, 16)" end="(135, 29)" leading="" trailing="" raw_val="flatMapM.loop" val="flatMapM.loop" full_name="List.flatMapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(135, 29)" end="(135, 30)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(135, 31)" end="(135, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(135, 31)" end="(135, 41)" leading="" trailing="" raw_val="append_nil" val="append_nil" full_name="List.append_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(135, 41)" end="(135, 42)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(135, 43)" end="(135, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(135, 43)" end="(135, 58)" leading="" trailing="" raw_val="_root_.map_bind" val="_root_.map_bind" full_name="map_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(135, 58)" end="(135, 59)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(136, 5)" end="(136, 10)" kind="Lean.Parser.Tactic.congr" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List (List β)}, flatMapM.loop f l acc = (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l []&#10;acc : List (List β)&#10;⊢ (do&#10;      let bs' ← f a&#10;      flatMapM.loop f l (bs' :: acc)) =&#10;    do&#10;    let a ← f a&#10;    (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l [a]" state_after="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List (List β)}, flatMapM.loop f l acc = (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l []&#10;acc : List (List β)&#10;⊢ (fun bs' =&amp;gt; flatMapM.loop f l (bs' :: acc)) = fun a =&amp;gt; (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l [a]" tactic="congr">
                                      <AtomNode start="(136, 5)" end="(136, 10)" leading="" trailing="&#10;    " val="congr"/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(137, 5)" end="(137, 14)" kind="tacticFunext___" state_before="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List (List β)}, flatMapM.loop f l acc = (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l []&#10;acc : List (List β)&#10;⊢ (fun bs' =&amp;gt; flatMapM.loop f l (bs' :: acc)) = fun a =&amp;gt; (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l [a]" state_after="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List (List β)}, flatMapM.loop f l acc = (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l []&#10;acc : List (List β)&#10;bs : List β&#10;⊢ flatMapM.loop f l (bs :: acc) = (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l [bs]" tactic="funext bs">
                                      <AtomNode start="(137, 5)" end="(137, 11)" leading="" trailing=" " val="funext"/>
                                      <NullNode start="(137, 12)" end="(137, 14)">
                                        <IdentNode start="(137, 12)" end="(137, 14)" leading="" trailing="&#10;    " raw_val="bs" val="bs"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(138, 5)" end="(138, 30)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List (List β)}, flatMapM.loop f l acc = (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l []&#10;acc : List (List β)&#10;bs : List β&#10;⊢ flatMapM.loop f l (bs :: acc) = (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l [bs]" state_after="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List (List β)}, flatMapM.loop f l acc = (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l []&#10;acc : List (List β)&#10;bs : List β&#10;⊢ (fun x =&amp;gt; (bs :: acc).reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l [] =&#10;    (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; (fun x =&amp;gt; [bs].reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l []" tactic="rw [ih, ih (acc := [bs])]">
                                      <AtomNode start="(138, 5)" end="(138, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(138, 8)" end="(138, 30)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(138, 8)" end="(138, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(138, 9)" end="(138, 29)">
                                          <OtherNode start="(138, 9)" end="(138, 11)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(138, 9)" end="(138, 11)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(138, 11)" end="(138, 12)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(138, 13)" end="(138, 29)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <OtherNode start="(138, 13)" end="(138, 29)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(138, 13)" end="(138, 15)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                              <NullNode start="(138, 16)" end="(138, 29)">
                                                <OtherNode start="(138, 16)" end="(138, 29)" kind="Lean.Parser.Term.namedArgument">
                                                  <AtomNode start="(138, 16)" end="(138, 17)" leading="" trailing="" val="("/>
                                                  <IdentNode start="(138, 17)" end="(138, 20)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                                  <AtomNode start="(138, 21)" end="(138, 23)" leading="" trailing=" " val=":="/>
                                                  <OtherNode start="(138, 24)" end="(138, 28)" kind="«term[_]»">
                                                    <AtomNode start="(138, 24)" end="(138, 25)" leading="" trailing="" val="["/>
                                                    <NullNode start="(138, 25)" end="(138, 27)">
                                                      <IdentNode start="(138, 25)" end="(138, 27)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                    </NullNode>
                                                    <AtomNode start="(138, 27)" end="(138, 28)" leading="" trailing="" val="]"/>
                                                  </OtherNode>
                                                  <AtomNode start="(138, 28)" end="(138, 29)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(138, 29)" end="(138, 30)" leading="" trailing="&#10;    " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(139, 5)" end="(139, 9)" kind="Lean.Parser.Tactic.simp" state_before="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;a : α&#10;l : List α&#10;ih : ∀ {acc : List (List β)}, flatMapM.loop f l acc = (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l []&#10;acc : List (List β)&#10;bs : List β&#10;⊢ (fun x =&amp;gt; (bs :: acc).reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l [] =&#10;    (fun x =&amp;gt; acc.reverse.flatten ++ x) &amp;lt;$&amp;gt; (fun x =&amp;gt; [bs].reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(139, 5)" end="(139, 9)" leading="" trailing="&#10;&#10;" val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(141, 1)" end="(149, 7)" name="flatMapM_cons" full_name="List.flatMapM_cons">
      <CommandDeclmodifiersNode start="(141, 1)" end="(141, 8)">
        <NullNode/>
        <NullNode start="(141, 1)" end="(141, 8)">
          <OtherNode start="(141, 1)" end="(141, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(141, 1)" end="(141, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(141, 3)" end="(141, 7)">
              <OtherNode start="(141, 3)" end="(141, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(141, 3)" end="(141, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(141, 3)" end="(141, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(141, 7)" end="(141, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(141, 9)" end="(149, 7)" name="flatMapM_cons" full_name="List.flatMapM_cons" _is_private_decl="False">
        <AtomNode start="(141, 9)" end="(141, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(141, 17)" end="(141, 30)">
          <IdentNode start="(141, 17)" end="(141, 30)" leading="" trailing=" " raw_val="flatMapM_cons" val="flatMapM_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(141, 31)" end="(144, 38)">
          <NullNode start="(141, 31)" end="(141, 77)">
            <OtherNode start="(141, 31)" end="(141, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(141, 31)" end="(141, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(141, 32)" end="(141, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(141, 32)" end="(141, 37)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(141, 38)" end="(141, 39)">
                  <IdentNode start="(141, 38)" end="(141, 39)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(141, 39)" end="(141, 40)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(141, 41)" end="(141, 56)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(141, 41)" end="(141, 42)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(141, 42)" end="(141, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(141, 42)" end="(141, 53)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(141, 54)" end="(141, 55)">
                  <IdentNode start="(141, 54)" end="(141, 55)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(141, 55)" end="(141, 56)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(141, 57)" end="(141, 77)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(141, 57)" end="(141, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(141, 58)" end="(141, 59)">
                <IdentNode start="(141, 58)" end="(141, 59)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(141, 60)" end="(141, 76)">
                <AtomNode start="(141, 60)" end="(141, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(141, 62)" end="(141, 76)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(141, 62)" end="(141, 63)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(141, 64)" end="(141, 65)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(141, 66)" end="(141, 76)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(141, 66)" end="(141, 67)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(141, 68)" end="(141, 76)">
                      <OtherNode start="(141, 68)" end="(141, 76)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(141, 68)" end="(141, 69)" leading="" trailing="" val="("/>
                        <OtherNode start="(141, 69)" end="(141, 75)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(141, 69)" end="(141, 73)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(141, 74)" end="(141, 75)">
                            <IdentNode start="(141, 74)" end="(141, 75)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(141, 75)" end="(141, 76)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(141, 76)" end="(141, 77)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(141, 78)" end="(144, 38)">
            <AtomNode start="(141, 78)" end="(141, 79)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(142, 5)" end="(144, 38)" kind="«term_=_»">
              <OtherNode start="(142, 5)" end="(142, 24)" kind="Lean.Parser.Term.app">
                <OtherNode start="(142, 5)" end="(142, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(142, 5)" end="(142, 13)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(142, 5)" end="(142, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(142, 6)" end="(142, 12)" kind="«term_::_»">
                      <IdentNode start="(142, 6)" end="(142, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(142, 8)" end="(142, 10)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(142, 11)" end="(142, 12)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(142, 12)" end="(142, 13)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(142, 13)" end="(142, 14)" leading="" trailing="" val="."/>
                  <IdentNode start="(142, 14)" end="(142, 22)" leading="" trailing=" " raw_val="flatMapM" val="flatMapM" full_name="List.flatMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(142, 23)" end="(142, 24)">
                  <IdentNode start="(142, 23)" end="(142, 24)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(142, 25)" end="(142, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(142, 27)" end="(144, 38)" kind="Lean.Parser.Term.do">
                <AtomNode start="(142, 27)" end="(142, 29)" leading="" trailing="&#10;      " val="do"/>
                <OtherNode start="(143, 7)" end="(144, 38)" kind="Lean.Parser.Term.doSeqIndent">
                  <NullNode start="(143, 7)" end="(144, 38)">
                    <OtherNode start="(143, 7)" end="(143, 19)" kind="Lean.Parser.Term.doSeqItem">
                      <OtherNode start="(143, 7)" end="(143, 19)" kind="Lean.Parser.Term.doLetArrow">
                        <AtomNode start="(143, 7)" end="(143, 10)" leading="" trailing=" " val="let"/>
                        <NullNode/>
                        <OtherNode start="(143, 11)" end="(143, 19)" kind="Lean.Parser.Term.doIdDecl">
                          <IdentNode start="(143, 11)" end="(143, 13)" leading="" trailing=" " raw_val="bs" val="bs"/>
                          <NullNode/>
                          <AtomNode start="(143, 14)" end="(143, 15)" leading="" trailing=" " val="←"/>
                          <OtherNode start="(143, 16)" end="(143, 19)" kind="Lean.Parser.Term.doExpr">
                            <OtherNode start="(143, 16)" end="(143, 19)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(143, 16)" end="(143, 17)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(143, 18)" end="(143, 19)">
                                <IdentNode start="(143, 18)" end="(143, 19)" leading="" trailing="&#10;      " raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(144, 7)" end="(144, 38)" kind="Lean.Parser.Term.doSeqItem">
                      <OtherNode start="(144, 7)" end="(144, 38)" kind="Lean.Parser.Term.doReturn">
                        <AtomNode start="(144, 7)" end="(144, 13)" leading="" trailing=" " val="return"/>
                        <NullNode start="(144, 14)" end="(144, 38)">
                          <OtherNode start="(144, 14)" end="(144, 38)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(144, 14)" end="(144, 15)" leading="" trailing="" val="("/>
                            <OtherNode start="(144, 15)" end="(144, 37)" kind="«term_++_»">
                              <IdentNode start="(144, 15)" end="(144, 17)" leading="" trailing=" " raw_val="bs" val="bs"/>
                              <AtomNode start="(144, 18)" end="(144, 20)" leading="" trailing=" " val="++"/>
                              <OtherNode start="(144, 21)" end="(144, 37)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(144, 21)" end="(144, 22)" leading="" trailing="" val="("/>
                                <OtherNode start="(144, 22)" end="(144, 36)" kind="Lean.Parser.Term.liftMethod">
                                  <AtomNode start="(144, 22)" end="(144, 23)" leading="" trailing=" " val="←"/>
                                  <OtherNode start="(144, 24)" end="(144, 36)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(144, 24)" end="(144, 34)" leading="" trailing=" " raw_val="l.flatMapM" val="l.flatMapM"/>
                                    <NullNode start="(144, 35)" end="(144, 36)">
                                      <IdentNode start="(144, 35)" end="(144, 36)" leading="" trailing="" raw_val="f" val="f"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(144, 36)" end="(144, 37)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(144, 37)" end="(144, 38)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <NullNode/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(144, 39)" end="(149, 7)">
          <AtomNode start="(144, 39)" end="(144, 41)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(144, 42)" end="(149, 7)">
            <AtomNode start="(144, 42)" end="(144, 44)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(145, 3)" end="(149, 7)">
              <TacticTacticseq1IndentedNode start="(145, 3)" end="(149, 7)">
                <NullNode start="(145, 3)" end="(149, 7)">
                  <OtherNode start="(145, 3)" end="(145, 53)" kind="Lean.Parser.Tactic.Conv.conv" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;⊢ flatMapM f (a :: l) = do&#10;    let bs ← f a&#10;    let __do_lift ← flatMapM f l&#10;    pure (bs ++ __do_lift)" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;⊢ (do&#10;      let bs' ← f a&#10;      flatMapM.loop f l [bs']) =&#10;    do&#10;    let bs ← f a&#10;    let __do_lift ← flatMapM f l&#10;    pure (bs ++ __do_lift)" tactic="conv =&amp;gt; lhs; unfold flatMapM; unfold flatMapM.loop">
                    <AtomNode start="(145, 3)" end="(145, 7)" leading="" trailing=" " val="conv"/>
                    <NullNode/>
                    <NullNode/>
                    <AtomNode start="(145, 8)" end="(145, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(145, 11)" end="(145, 53)" kind="Lean.Parser.Tactic.Conv.convSeq">
                      <OtherNode start="(145, 11)" end="(145, 53)" kind="Lean.Parser.Tactic.Conv.convSeq1Indented">
                        <NullNode start="(145, 11)" end="(145, 53)">
                          <OtherNode start="(145, 11)" end="(145, 14)" kind="Lean.Parser.Tactic.Conv.lhs">
                            <AtomNode start="(145, 11)" end="(145, 14)" leading="" trailing="" val="lhs"/>
                          </OtherNode>
                          <AtomNode start="(145, 14)" end="(145, 15)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(145, 16)" end="(145, 31)" kind="Lean.Parser.Tactic.Conv.unfold">
                            <AtomNode start="(145, 16)" end="(145, 22)" leading="" trailing=" " val="unfold"/>
                            <NullNode start="(145, 23)" end="(145, 31)">
                              <IdentNode start="(145, 23)" end="(145, 31)" leading="" trailing="" raw_val="flatMapM" val="flatMapM" full_name="List.flatMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(145, 31)" end="(145, 32)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(145, 33)" end="(145, 53)" kind="Lean.Parser.Tactic.Conv.unfold">
                            <AtomNode start="(145, 33)" end="(145, 39)" leading="" trailing=" " val="unfold"/>
                            <NullNode start="(145, 40)" end="(145, 53)">
                              <IdentNode start="(145, 40)" end="(145, 53)" leading="" trailing="&#10;  " raw_val="flatMapM.loop" val="flatMapM.loop" full_name="List.flatMapM.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(146, 3)" end="(146, 8)" kind="Lean.Parser.Tactic.congr" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;⊢ (do&#10;      let bs' ← f a&#10;      flatMapM.loop f l [bs']) =&#10;    do&#10;    let bs ← f a&#10;    let __do_lift ← flatMapM f l&#10;    pure (bs ++ __do_lift)" state_after="case e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;⊢ (fun bs' =&amp;gt; flatMapM.loop f l [bs']) = fun bs =&amp;gt; do&#10;    let __do_lift ← flatMapM f l&#10;    pure (bs ++ __do_lift)" tactic="congr">
                    <AtomNode start="(146, 3)" end="(146, 8)" leading="" trailing="&#10;  " val="congr"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(147, 3)" end="(147, 12)" kind="tacticFunext___" state_before="case e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;⊢ (fun bs' =&amp;gt; flatMapM.loop f l [bs']) = fun bs =&amp;gt; do&#10;    let __do_lift ← flatMapM f l&#10;    pure (bs ++ __do_lift)" state_after="case e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;bs : List β&#10;⊢ flatMapM.loop f l [bs] = do&#10;    let __do_lift ← flatMapM f l&#10;    pure (bs ++ __do_lift)" tactic="funext bs">
                    <AtomNode start="(147, 3)" end="(147, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(147, 10)" end="(147, 12)">
                      <IdentNode start="(147, 10)" end="(147, 12)" leading="" trailing="&#10;  " raw_val="bs" val="bs"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(148, 3)" end="(148, 34)" kind="Lean.Parser.Tactic.rwSeq" state_before="case e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;bs : List β&#10;⊢ flatMapM.loop f l [bs] = do&#10;    let __do_lift ← flatMapM f l&#10;    pure (bs ++ __do_lift)" state_after="case e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;bs : List β&#10;⊢ (fun x =&amp;gt; [bs].reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l [] = do&#10;    let __do_lift ← flatMapM.loop f l []&#10;    pure (bs ++ __do_lift)" tactic="rw [flatMapM_loop_eq, flatMapM]">
                    <AtomNode start="(148, 3)" end="(148, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(148, 6)" end="(148, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(148, 6)" end="(148, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(148, 7)" end="(148, 33)">
                        <OtherNode start="(148, 7)" end="(148, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(148, 7)" end="(148, 23)" leading="" trailing="" raw_val="flatMapM_loop_eq" val="flatMapM_loop_eq" full_name="List.flatMapM_loop_eq" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(130, 9)" def_end="(130, 25)"/>
                        </OtherNode>
                        <AtomNode start="(148, 23)" end="(148, 24)" leading="" trailing=" " val=","/>
                        <OtherNode start="(148, 25)" end="(148, 33)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(148, 25)" end="(148, 33)" leading="" trailing="" raw_val="flatMapM" val="flatMapM" full_name="List.flatMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(148, 33)" end="(148, 34)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(149, 3)" end="(149, 7)" kind="Lean.Parser.Tactic.simp" state_before="case e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;a : α&#10;l : List α&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → m (List β)&#10;bs : List β&#10;⊢ (fun x =&amp;gt; [bs].reverse.flatten ++ x) &amp;lt;$&amp;gt; flatMapM.loop f l [] = do&#10;    let __do_lift ← flatMapM.loop f l []&#10;    pure (bs ++ __do_lift)" state_after="no goals" tactic="simp">
                    <AtomNode start="(149, 3)" end="(149, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(151, 1)" end="(151, 29)" comment="### foldlM and foldrM -/">
      <AtomNode start="(151, 1)" end="(151, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(151, 5)" end="(151, 29)" leading="" trailing="&#10;&#10;" val="### foldlM and foldrM -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(153, 1)" end="(155, 47)" name="foldlM_map" full_name="List.foldlM_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(153, 1)" end="(155, 47)" name="foldlM_map" full_name="List.foldlM_map" _is_private_decl="False">
        <AtomNode start="(153, 1)" end="(153, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(153, 9)" end="(153, 19)">
          <IdentNode start="(153, 9)" end="(153, 19)" leading="" trailing=" " raw_val="foldlM_map" val="foldlM_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(153, 20)" end="(154, 67)">
          <NullNode start="(153, 20)" end="(153, 87)">
            <OtherNode start="(153, 20)" end="(153, 29)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(153, 20)" end="(153, 21)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(153, 21)" end="(153, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(153, 21)" end="(153, 26)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(153, 27)" end="(153, 28)">
                  <IdentNode start="(153, 27)" end="(153, 28)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(153, 28)" end="(153, 29)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(153, 30)" end="(153, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(153, 30)" end="(153, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(153, 31)" end="(153, 32)">
                <IdentNode start="(153, 31)" end="(153, 32)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(153, 33)" end="(153, 42)">
                <AtomNode start="(153, 33)" end="(153, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(153, 35)" end="(153, 42)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(153, 35)" end="(153, 37)" leading="" trailing=" " raw_val="β₁" val="β₁"/>
                  <AtomNode start="(153, 38)" end="(153, 39)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(153, 40)" end="(153, 42)" leading="" trailing="" raw_val="β₂" val="β₂"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(153, 42)" end="(153, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(153, 44)" end="(153, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(153, 44)" end="(153, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(153, 45)" end="(153, 46)">
                <IdentNode start="(153, 45)" end="(153, 46)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(153, 47)" end="(153, 61)">
                <AtomNode start="(153, 47)" end="(153, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(153, 49)" end="(153, 61)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(153, 49)" end="(153, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(153, 51)" end="(153, 52)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(153, 53)" end="(153, 61)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(153, 53)" end="(153, 55)" leading="" trailing=" " raw_val="β₂" val="β₂"/>
                    <AtomNode start="(153, 56)" end="(153, 57)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(153, 58)" end="(153, 61)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(153, 58)" end="(153, 59)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(153, 60)" end="(153, 61)">
                        <IdentNode start="(153, 60)" end="(153, 61)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(153, 61)" end="(153, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(153, 63)" end="(153, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(153, 63)" end="(153, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(153, 64)" end="(153, 65)">
                <IdentNode start="(153, 64)" end="(153, 65)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(153, 66)" end="(153, 75)">
                <AtomNode start="(153, 66)" end="(153, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(153, 68)" end="(153, 75)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(153, 68)" end="(153, 72)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(153, 73)" end="(153, 75)">
                    <IdentNode start="(153, 73)" end="(153, 75)" leading="" trailing="" raw_val="β₁" val="β₁"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(153, 75)" end="(153, 76)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(153, 77)" end="(153, 87)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(153, 77)" end="(153, 78)" leading="" trailing="" val="{"/>
              <NullNode start="(153, 78)" end="(153, 82)">
                <IdentNode start="(153, 78)" end="(153, 82)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(153, 83)" end="(153, 86)">
                <AtomNode start="(153, 83)" end="(153, 84)" leading="" trailing=" " val=":"/>
                <IdentNode start="(153, 85)" end="(153, 86)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(153, 86)" end="(153, 87)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(153, 88)" end="(154, 67)">
            <AtomNode start="(153, 88)" end="(153, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(154, 5)" end="(154, 67)" kind="«term_=_»">
              <OtherNode start="(154, 5)" end="(154, 28)" kind="Lean.Parser.Term.app">
                <OtherNode start="(154, 5)" end="(154, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(154, 5)" end="(154, 14)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(154, 5)" end="(154, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(154, 6)" end="(154, 13)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(154, 6)" end="(154, 11)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                      <NullNode start="(154, 12)" end="(154, 13)">
                        <IdentNode start="(154, 12)" end="(154, 13)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(154, 13)" end="(154, 14)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(154, 14)" end="(154, 15)" leading="" trailing="" val="."/>
                  <IdentNode start="(154, 15)" end="(154, 21)" leading="" trailing=" " raw_val="foldlM" val="foldlM" full_name="List.foldlM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(154, 22)" end="(154, 28)">
                  <IdentNode start="(154, 22)" end="(154, 23)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(154, 24)" end="(154, 28)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(154, 29)" end="(154, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(154, 31)" end="(154, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(154, 31)" end="(154, 39)" leading="" trailing=" " raw_val="l.foldlM" val="l.foldlM"/>
                <NullNode start="(154, 40)" end="(154, 67)">
                  <OtherNode start="(154, 40)" end="(154, 62)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(154, 40)" end="(154, 41)" leading="" trailing="" val="("/>
                    <OtherNode start="(154, 41)" end="(154, 61)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(154, 41)" end="(154, 44)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(154, 45)" end="(154, 61)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(154, 45)" end="(154, 48)">
                          <IdentNode start="(154, 45)" end="(154, 46)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(154, 47)" end="(154, 48)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(154, 49)" end="(154, 51)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(154, 52)" end="(154, 61)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(154, 52)" end="(154, 53)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(154, 54)" end="(154, 61)">
                            <IdentNode start="(154, 54)" end="(154, 55)" leading="" trailing=" " raw_val="x" val="x"/>
                            <OtherNode start="(154, 56)" end="(154, 61)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(154, 56)" end="(154, 57)" leading="" trailing="" val="("/>
                              <OtherNode start="(154, 57)" end="(154, 60)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(154, 57)" end="(154, 58)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(154, 59)" end="(154, 60)">
                                  <IdentNode start="(154, 59)" end="(154, 60)" leading="" trailing="" raw_val="y" val="y"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(154, 60)" end="(154, 61)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(154, 61)" end="(154, 62)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(154, 63)" end="(154, 67)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(154, 68)" end="(155, 47)">
          <AtomNode start="(154, 68)" end="(154, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(154, 71)" end="(155, 47)">
            <AtomNode start="(154, 71)" end="(154, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(155, 3)" end="(155, 47)">
              <TacticTacticseq1IndentedNode start="(155, 3)" end="(155, 47)">
                <NullNode start="(155, 3)" end="(155, 47)">
                  <OtherNode start="(155, 3)" end="(155, 47)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;β₁ : Type u_3&#10;β₂ : Type u_4&#10;α : Type u_1&#10;inst✝ : Monad m&#10;f : β₁ → β₂&#10;g : α → β₂ → m α&#10;l : List β₁&#10;init : α&#10;⊢ foldlM g init (map f l) = foldlM (fun x y =&amp;gt; g x (f y)) init l" state_after="no goals" tactic="induction l generalizing g init &amp;lt;;&amp;gt; simp [*]">
                    <OtherNode start="(155, 3)" end="(155, 34)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(155, 3)" end="(155, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(155, 13)" end="(155, 14)">
                        <OtherNode start="(155, 13)" end="(155, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(155, 13)" end="(155, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode start="(155, 15)" end="(155, 34)">
                        <AtomNode start="(155, 15)" end="(155, 27)" leading="" trailing=" " val="generalizing"/>
                        <NullNode start="(155, 28)" end="(155, 34)">
                          <IdentNode start="(155, 28)" end="(155, 29)" leading="" trailing=" " raw_val="g" val="g"/>
                          <IdentNode start="(155, 30)" end="(155, 34)" leading="" trailing=" " raw_val="init" val="init"/>
                        </NullNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(155, 35)" end="(155, 38)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(155, 39)" end="(155, 47)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(155, 39)" end="(155, 43)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(155, 44)" end="(155, 47)">
                        <AtomNode start="(155, 44)" end="(155, 45)" leading="" trailing="" val="["/>
                        <NullNode start="(155, 45)" end="(155, 46)">
                          <OtherNode start="(155, 45)" end="(155, 46)" kind="Lean.Parser.Tactic.simpStar">
                            <AtomNode start="(155, 45)" end="(155, 46)" leading="" trailing="" val="*"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(155, 46)" end="(155, 47)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(157, 1)" end="(159, 47)" name="foldrM_map" full_name="List.foldrM_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(157, 1)" end="(159, 47)" name="foldrM_map" full_name="List.foldrM_map" _is_private_decl="False">
        <AtomNode start="(157, 1)" end="(157, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(157, 9)" end="(157, 19)">
          <IdentNode start="(157, 9)" end="(157, 19)" leading="" trailing=" " raw_val="foldrM_map" val="foldrM_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(157, 20)" end="(158, 67)">
          <NullNode start="(157, 20)" end="(157, 103)">
            <OtherNode start="(157, 20)" end="(157, 29)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(157, 20)" end="(157, 21)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(157, 21)" end="(157, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(157, 21)" end="(157, 26)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(157, 27)" end="(157, 28)">
                  <IdentNode start="(157, 27)" end="(157, 28)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(157, 28)" end="(157, 29)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(157, 30)" end="(157, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(157, 30)" end="(157, 31)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(157, 31)" end="(157, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(157, 31)" end="(157, 42)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(157, 43)" end="(157, 44)">
                  <IdentNode start="(157, 43)" end="(157, 44)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(157, 44)" end="(157, 45)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(157, 46)" end="(157, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(157, 46)" end="(157, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(157, 47)" end="(157, 48)">
                <IdentNode start="(157, 47)" end="(157, 48)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(157, 49)" end="(157, 58)">
                <AtomNode start="(157, 49)" end="(157, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(157, 51)" end="(157, 58)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(157, 51)" end="(157, 53)" leading="" trailing=" " raw_val="β₁" val="β₁"/>
                  <AtomNode start="(157, 54)" end="(157, 55)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(157, 56)" end="(157, 58)" leading="" trailing="" raw_val="β₂" val="β₂"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(157, 58)" end="(157, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(157, 60)" end="(157, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(157, 60)" end="(157, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(157, 61)" end="(157, 62)">
                <IdentNode start="(157, 61)" end="(157, 62)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(157, 63)" end="(157, 77)">
                <AtomNode start="(157, 63)" end="(157, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(157, 65)" end="(157, 77)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(157, 65)" end="(157, 67)" leading="" trailing=" " raw_val="β₂" val="β₂"/>
                  <AtomNode start="(157, 68)" end="(157, 69)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(157, 70)" end="(157, 77)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(157, 70)" end="(157, 71)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(157, 72)" end="(157, 73)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(157, 74)" end="(157, 77)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(157, 74)" end="(157, 75)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(157, 76)" end="(157, 77)">
                        <IdentNode start="(157, 76)" end="(157, 77)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(157, 77)" end="(157, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(157, 79)" end="(157, 92)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(157, 79)" end="(157, 80)" leading="" trailing="" val="{"/>
              <NullNode start="(157, 80)" end="(157, 81)">
                <IdentNode start="(157, 80)" end="(157, 81)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(157, 82)" end="(157, 91)">
                <AtomNode start="(157, 82)" end="(157, 83)" leading="" trailing=" " val=":"/>
                <OtherNode start="(157, 84)" end="(157, 91)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(157, 84)" end="(157, 88)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(157, 89)" end="(157, 91)">
                    <IdentNode start="(157, 89)" end="(157, 91)" leading="" trailing="" raw_val="β₁" val="β₁"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(157, 91)" end="(157, 92)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(157, 93)" end="(157, 103)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(157, 93)" end="(157, 94)" leading="" trailing="" val="{"/>
              <NullNode start="(157, 94)" end="(157, 98)">
                <IdentNode start="(157, 94)" end="(157, 98)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(157, 99)" end="(157, 102)">
                <AtomNode start="(157, 99)" end="(157, 100)" leading="" trailing=" " val=":"/>
                <IdentNode start="(157, 101)" end="(157, 102)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(157, 102)" end="(157, 103)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(157, 104)" end="(158, 67)">
            <AtomNode start="(157, 104)" end="(157, 105)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(158, 5)" end="(158, 67)" kind="«term_=_»">
              <OtherNode start="(158, 5)" end="(158, 28)" kind="Lean.Parser.Term.app">
                <OtherNode start="(158, 5)" end="(158, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(158, 5)" end="(158, 14)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(158, 5)" end="(158, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(158, 6)" end="(158, 13)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(158, 6)" end="(158, 11)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                      <NullNode start="(158, 12)" end="(158, 13)">
                        <IdentNode start="(158, 12)" end="(158, 13)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(158, 13)" end="(158, 14)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(158, 14)" end="(158, 15)" leading="" trailing="" val="."/>
                  <IdentNode start="(158, 15)" end="(158, 21)" leading="" trailing=" " raw_val="foldrM" val="foldrM" full_name="List.foldrM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(158, 22)" end="(158, 28)">
                  <IdentNode start="(158, 22)" end="(158, 23)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(158, 24)" end="(158, 28)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(158, 29)" end="(158, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(158, 31)" end="(158, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(158, 31)" end="(158, 39)" leading="" trailing=" " raw_val="l.foldrM" val="l.foldrM"/>
                <NullNode start="(158, 40)" end="(158, 67)">
                  <OtherNode start="(158, 40)" end="(158, 62)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(158, 40)" end="(158, 41)" leading="" trailing="" val="("/>
                    <OtherNode start="(158, 41)" end="(158, 61)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(158, 41)" end="(158, 44)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(158, 45)" end="(158, 61)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(158, 45)" end="(158, 48)">
                          <IdentNode start="(158, 45)" end="(158, 46)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(158, 47)" end="(158, 48)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(158, 49)" end="(158, 51)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(158, 52)" end="(158, 61)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(158, 52)" end="(158, 53)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(158, 54)" end="(158, 61)">
                            <OtherNode start="(158, 54)" end="(158, 59)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(158, 54)" end="(158, 55)" leading="" trailing="" val="("/>
                              <OtherNode start="(158, 55)" end="(158, 58)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(158, 55)" end="(158, 56)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(158, 57)" end="(158, 58)">
                                  <IdentNode start="(158, 57)" end="(158, 58)" leading="" trailing="" raw_val="x" val="x"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(158, 58)" end="(158, 59)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <IdentNode start="(158, 60)" end="(158, 61)" leading="" trailing="" raw_val="y" val="y"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(158, 61)" end="(158, 62)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(158, 63)" end="(158, 67)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(158, 68)" end="(159, 47)">
          <AtomNode start="(158, 68)" end="(158, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(158, 71)" end="(159, 47)">
            <AtomNode start="(158, 71)" end="(158, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(159, 3)" end="(159, 47)">
              <TacticTacticseq1IndentedNode start="(159, 3)" end="(159, 47)">
                <NullNode start="(159, 3)" end="(159, 47)">
                  <OtherNode start="(159, 3)" end="(159, 47)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;β₁ : Type u_3&#10;β₂ : Type u_4&#10;α : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : β₁ → β₂&#10;g : β₂ → α → m α&#10;l : List β₁&#10;init : α&#10;⊢ foldrM g init (map f l) = foldrM (fun x y =&amp;gt; g (f x) y) init l" state_after="no goals" tactic="induction l generalizing g init &amp;lt;;&amp;gt; simp [*]">
                    <OtherNode start="(159, 3)" end="(159, 34)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(159, 3)" end="(159, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(159, 13)" end="(159, 14)">
                        <OtherNode start="(159, 13)" end="(159, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(159, 13)" end="(159, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode start="(159, 15)" end="(159, 34)">
                        <AtomNode start="(159, 15)" end="(159, 27)" leading="" trailing=" " val="generalizing"/>
                        <NullNode start="(159, 28)" end="(159, 34)">
                          <IdentNode start="(159, 28)" end="(159, 29)" leading="" trailing=" " raw_val="g" val="g"/>
                          <IdentNode start="(159, 30)" end="(159, 34)" leading="" trailing=" " raw_val="init" val="init"/>
                        </NullNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(159, 35)" end="(159, 38)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(159, 39)" end="(159, 47)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(159, 39)" end="(159, 43)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(159, 44)" end="(159, 47)">
                        <AtomNode start="(159, 44)" end="(159, 45)" leading="" trailing="" val="["/>
                        <NullNode start="(159, 45)" end="(159, 46)">
                          <OtherNode start="(159, 45)" end="(159, 46)" kind="Lean.Parser.Tactic.simpStar">
                            <AtomNode start="(159, 45)" end="(159, 46)" leading="" trailing="" val="*"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(159, 46)" end="(159, 47)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(161, 1)" end="(168, 28)" name="foldlM_filterMap" full_name="List.foldlM_filterMap">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(161, 1)" end="(168, 28)" name="foldlM_filterMap" full_name="List.foldlM_filterMap" _is_private_decl="False">
        <AtomNode start="(161, 1)" end="(161, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(161, 9)" end="(161, 25)">
          <IdentNode start="(161, 9)" end="(161, 25)" leading="" trailing=" " raw_val="foldlM_filterMap" val="foldlM_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(161, 26)" end="(163, 83)">
          <NullNode start="(161, 26)" end="(161, 112)">
            <OtherNode start="(161, 26)" end="(161, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(161, 26)" end="(161, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(161, 27)" end="(161, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(161, 27)" end="(161, 32)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(161, 33)" end="(161, 34)">
                  <IdentNode start="(161, 33)" end="(161, 34)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(161, 34)" end="(161, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(161, 36)" end="(161, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(161, 36)" end="(161, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(161, 37)" end="(161, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(161, 37)" end="(161, 48)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(161, 49)" end="(161, 50)">
                  <IdentNode start="(161, 49)" end="(161, 50)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(161, 50)" end="(161, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(161, 52)" end="(161, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(161, 52)" end="(161, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(161, 53)" end="(161, 54)">
                <IdentNode start="(161, 53)" end="(161, 54)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(161, 55)" end="(161, 69)">
                <AtomNode start="(161, 55)" end="(161, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(161, 57)" end="(161, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(161, 57)" end="(161, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(161, 59)" end="(161, 60)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(161, 61)" end="(161, 69)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(161, 61)" end="(161, 67)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(161, 68)" end="(161, 69)">
                      <IdentNode start="(161, 68)" end="(161, 69)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(161, 69)" end="(161, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(161, 71)" end="(161, 88)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(161, 71)" end="(161, 72)" leading="" trailing="" val="{"/>
              <NullNode start="(161, 72)" end="(161, 73)">
                <IdentNode start="(161, 72)" end="(161, 73)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(161, 74)" end="(161, 87)">
                <AtomNode start="(161, 74)" end="(161, 75)" leading="" trailing=" " val=":"/>
                <OtherNode start="(161, 76)" end="(161, 87)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(161, 76)" end="(161, 77)" leading="" trailing=" " raw_val="γ" val="γ"/>
                  <AtomNode start="(161, 78)" end="(161, 79)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(161, 80)" end="(161, 87)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(161, 80)" end="(161, 81)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(161, 82)" end="(161, 83)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(161, 84)" end="(161, 87)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(161, 84)" end="(161, 85)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(161, 86)" end="(161, 87)">
                        <IdentNode start="(161, 86)" end="(161, 87)" leading="" trailing="" raw_val="γ" val="γ"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(161, 87)" end="(161, 88)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(161, 89)" end="(161, 101)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(161, 89)" end="(161, 90)" leading="" trailing="" val="{"/>
              <NullNode start="(161, 90)" end="(161, 91)">
                <IdentNode start="(161, 90)" end="(161, 91)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(161, 92)" end="(161, 100)">
                <AtomNode start="(161, 92)" end="(161, 93)" leading="" trailing=" " val=":"/>
                <OtherNode start="(161, 94)" end="(161, 100)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(161, 94)" end="(161, 98)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(161, 99)" end="(161, 100)">
                    <IdentNode start="(161, 99)" end="(161, 100)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(161, 100)" end="(161, 101)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(161, 102)" end="(161, 112)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(161, 102)" end="(161, 103)" leading="" trailing="" val="{"/>
              <NullNode start="(161, 103)" end="(161, 107)">
                <IdentNode start="(161, 103)" end="(161, 107)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(161, 108)" end="(161, 111)">
                <AtomNode start="(161, 108)" end="(161, 109)" leading="" trailing=" " val=":"/>
                <IdentNode start="(161, 110)" end="(161, 111)" leading="" trailing="" raw_val="γ" val="γ"/>
              </NullNode>
              <AtomNode start="(161, 111)" end="(161, 112)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(161, 113)" end="(163, 83)">
            <AtomNode start="(161, 113)" end="(161, 114)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(162, 5)" end="(163, 83)" kind="«term_=_»">
              <OtherNode start="(162, 5)" end="(162, 34)" kind="Lean.Parser.Term.app">
                <OtherNode start="(162, 5)" end="(162, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(162, 5)" end="(162, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(162, 5)" end="(162, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(162, 6)" end="(162, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(162, 6)" end="(162, 17)" leading="" trailing=" " raw_val="l.filterMap" val="l.filterMap"/>
                      <NullNode start="(162, 18)" end="(162, 19)">
                        <IdentNode start="(162, 18)" end="(162, 19)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(162, 19)" end="(162, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(162, 20)" end="(162, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(162, 21)" end="(162, 27)" leading="" trailing=" " raw_val="foldlM" val="foldlM" full_name="List.foldlM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(162, 28)" end="(162, 34)">
                  <IdentNode start="(162, 28)" end="(162, 29)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(162, 30)" end="(162, 34)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(162, 35)" end="(162, 36)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(163, 7)" end="(163, 83)" kind="Lean.Parser.Term.app">
                <IdentNode start="(163, 7)" end="(163, 15)" leading="" trailing=" " raw_val="l.foldlM" val="l.foldlM"/>
                <NullNode start="(163, 16)" end="(163, 83)">
                  <OtherNode start="(163, 16)" end="(163, 78)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(163, 16)" end="(163, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(163, 17)" end="(163, 77)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(163, 17)" end="(163, 20)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(163, 21)" end="(163, 77)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(163, 21)" end="(163, 24)">
                          <IdentNode start="(163, 21)" end="(163, 22)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(163, 23)" end="(163, 24)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(163, 25)" end="(163, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(163, 28)" end="(163, 77)" kind="Lean.Parser.Term.match">
                          <AtomNode start="(163, 28)" end="(163, 33)" leading="" trailing=" " val="match"/>
                          <NullNode/>
                          <NullNode/>
                          <NullNode start="(163, 34)" end="(163, 37)">
                            <OtherNode start="(163, 34)" end="(163, 37)" kind="Lean.Parser.Term.matchDiscr">
                              <NullNode/>
                              <OtherNode start="(163, 34)" end="(163, 37)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(163, 34)" end="(163, 35)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(163, 36)" end="(163, 37)">
                                  <IdentNode start="(163, 36)" end="(163, 37)" leading="" trailing=" " raw_val="y" val="y"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <AtomNode start="(163, 38)" end="(163, 42)" leading="" trailing=" " val="with"/>
                          <OtherNode start="(163, 43)" end="(163, 77)" kind="Lean.Parser.Term.matchAlts">
                            <NullNode start="(163, 43)" end="(163, 77)">
                              <OtherNode start="(163, 43)" end="(163, 60)" kind="Lean.Parser.Term.matchAlt">
                                <AtomNode start="(163, 43)" end="(163, 44)" leading="" trailing=" " val="|"/>
                                <NullNode start="(163, 45)" end="(163, 51)">
                                  <NullNode start="(163, 45)" end="(163, 51)">
                                    <OtherNode start="(163, 45)" end="(163, 51)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(163, 45)" end="(163, 49)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(163, 50)" end="(163, 51)">
                                        <IdentNode start="(163, 50)" end="(163, 51)" leading="" trailing=" " raw_val="b" val="b"/>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(163, 52)" end="(163, 54)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(163, 55)" end="(163, 60)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(163, 55)" end="(163, 56)" leading="" trailing=" " raw_val="g" val="g"/>
                                  <NullNode start="(163, 57)" end="(163, 60)">
                                    <IdentNode start="(163, 57)" end="(163, 58)" leading="" trailing=" " raw_val="x" val="x"/>
                                    <IdentNode start="(163, 59)" end="(163, 60)" leading="" trailing=" " raw_val="b" val="b"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(163, 61)" end="(163, 77)" kind="Lean.Parser.Term.matchAlt">
                                <AtomNode start="(163, 61)" end="(163, 62)" leading="" trailing=" " val="|"/>
                                <NullNode start="(163, 63)" end="(163, 67)">
                                  <NullNode start="(163, 63)" end="(163, 67)">
                                    <IdentNode start="(163, 63)" end="(163, 67)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(163, 68)" end="(163, 70)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(163, 71)" end="(163, 77)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(163, 71)" end="(163, 75)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(163, 76)" end="(163, 77)">
                                    <IdentNode start="(163, 76)" end="(163, 77)" leading="" trailing="" raw_val="x" val="x"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(163, 77)" end="(163, 78)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(163, 79)" end="(163, 83)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(163, 84)" end="(168, 28)">
          <AtomNode start="(163, 84)" end="(163, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(163, 87)" end="(168, 28)">
            <AtomNode start="(163, 87)" end="(163, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(164, 3)" end="(168, 28)">
              <TacticTacticseq1IndentedNode start="(164, 3)" end="(168, 28)">
                <NullNode start="(164, 3)" end="(168, 28)">
                  <OtherNode start="(164, 3)" end="(168, 28)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : γ → β → m γ&#10;l : List α&#10;init : γ&#10;⊢ foldlM g init (filterMap f l) =&#10;    foldlM&#10;      (fun x y =&amp;gt;&#10;        match f y with&#10;        | some b =&amp;gt; g x b&#10;        | none =&amp;gt; pure x)&#10;      init l" state_after="no goals" tactic="induction l generalizing init with&#10;| nil =&amp;gt; rfl&#10;| cons a l ih =&amp;gt;&#10;  simp only [filterMap_cons, foldlM_cons]&#10;  cases f a &amp;lt;;&amp;gt; simp [ih]">
                    <AtomNode start="(164, 3)" end="(164, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(164, 13)" end="(164, 14)">
                      <OtherNode start="(164, 13)" end="(164, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(164, 13)" end="(164, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(164, 15)" end="(164, 32)">
                      <AtomNode start="(164, 15)" end="(164, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(164, 28)" end="(164, 32)">
                        <IdentNode start="(164, 28)" end="(164, 32)" leading="" trailing=" " raw_val="init" val="init"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(164, 33)" end="(168, 28)">
                      <OtherNode start="(164, 33)" end="(168, 28)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(164, 33)" end="(164, 37)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(165, 3)" end="(168, 28)">
                          <OtherNode start="(165, 3)" end="(165, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(165, 3)" end="(165, 8)">
                              <OtherNode start="(165, 3)" end="(165, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(165, 3)" end="(165, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(165, 5)" end="(165, 8)">
                                  <NullNode/>
                                  <IdentNode start="(165, 5)" end="(165, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(165, 9)" end="(165, 15)">
                              <AtomNode start="(165, 9)" end="(165, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(165, 12)" end="(165, 15)">
                                <TacticTacticseq1IndentedNode start="(165, 12)" end="(165, 15)">
                                  <NullNode start="(165, 12)" end="(165, 15)">
                                    <OtherNode start="(165, 12)" end="(165, 15)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : γ → β → m γ&#10;init : γ&#10;⊢ foldlM g init (filterMap f []) =&#10;    foldlM&#10;      (fun x y =&amp;gt;&#10;        match f y with&#10;        | some b =&amp;gt; g x b&#10;        | none =&amp;gt; pure x)&#10;      init []" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(165, 12)" end="(165, 15)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(166, 3)" end="(168, 28)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(166, 3)" end="(166, 16)">
                              <OtherNode start="(166, 3)" end="(166, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(166, 3)" end="(166, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(166, 5)" end="(166, 9)">
                                  <NullNode/>
                                  <IdentNode start="(166, 5)" end="(166, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(166, 10)" end="(166, 16)">
                                  <IdentNode start="(166, 10)" end="(166, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(166, 12)" end="(166, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(166, 14)" end="(166, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(166, 17)" end="(168, 28)">
                              <AtomNode start="(166, 17)" end="(166, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(167, 5)" end="(168, 28)">
                                <TacticTacticseq1IndentedNode start="(167, 5)" end="(168, 28)">
                                  <NullNode start="(167, 5)" end="(168, 28)">
                                    <OtherNode start="(167, 5)" end="(167, 44)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : γ → β → m γ&#10;a : α&#10;l : List α&#10;ih :&#10;  ∀ {init : γ},&#10;    foldlM g init (filterMap f l) =&#10;      foldlM&#10;        (fun x y =&amp;gt;&#10;          match f y with&#10;          | some b =&amp;gt; g x b&#10;          | none =&amp;gt; pure x)&#10;        init l&#10;init : γ&#10;⊢ foldlM g init (filterMap f (a :: l)) =&#10;    foldlM&#10;      (fun x y =&amp;gt;&#10;        match f y with&#10;        | some b =&amp;gt; g x b&#10;        | none =&amp;gt; pure x)&#10;      init (a :: l)" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : γ → β → m γ&#10;a : α&#10;l : List α&#10;ih :&#10;  ∀ {init : γ},&#10;    foldlM g init (filterMap f l) =&#10;      foldlM&#10;        (fun x y =&amp;gt;&#10;          match f y with&#10;          | some b =&amp;gt; g x b&#10;          | none =&amp;gt; pure x)&#10;        init l&#10;init : γ&#10;⊢ foldlM g init&#10;      (match f a with&#10;      | none =&amp;gt; filterMap f l&#10;      | some b =&amp;gt; b :: filterMap f l) =&#10;    do&#10;    let init ←&#10;      match f a with&#10;        | some b =&amp;gt; g init b&#10;        | none =&amp;gt; pure init&#10;    foldlM&#10;        (fun x y =&amp;gt;&#10;          match f y with&#10;          | some b =&amp;gt; g x b&#10;          | none =&amp;gt; pure x)&#10;        init l" tactic="simp only [filterMap_cons, foldlM_cons]">
                                      <AtomNode start="(167, 5)" end="(167, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(167, 10)" end="(167, 14)">
                                        <AtomNode start="(167, 10)" end="(167, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(167, 15)" end="(167, 44)">
                                        <AtomNode start="(167, 15)" end="(167, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(167, 16)" end="(167, 43)">
                                          <OtherNode start="(167, 16)" end="(167, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(167, 16)" end="(167, 30)" leading="" trailing="" raw_val="filterMap_cons" val="filterMap_cons" full_name="List.filterMap_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(167, 30)" end="(167, 31)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(167, 32)" end="(167, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(167, 32)" end="(167, 43)" leading="" trailing="" raw_val="foldlM_cons" val="foldlM_cons" full_name="List.foldlM_cons" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(167, 43)" end="(167, 44)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(168, 5)" end="(168, 28)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : γ → β → m γ&#10;a : α&#10;l : List α&#10;ih :&#10;  ∀ {init : γ},&#10;    foldlM g init (filterMap f l) =&#10;      foldlM&#10;        (fun x y =&amp;gt;&#10;          match f y with&#10;          | some b =&amp;gt; g x b&#10;          | none =&amp;gt; pure x)&#10;        init l&#10;init : γ&#10;⊢ foldlM g init&#10;      (match f a with&#10;      | none =&amp;gt; filterMap f l&#10;      | some b =&amp;gt; b :: filterMap f l) =&#10;    do&#10;    let init ←&#10;      match f a with&#10;        | some b =&amp;gt; g init b&#10;        | none =&amp;gt; pure init&#10;    foldlM&#10;        (fun x y =&amp;gt;&#10;          match f y with&#10;          | some b =&amp;gt; g x b&#10;          | none =&amp;gt; pure x)&#10;        init l" state_after="no goals" tactic="cases f a &amp;lt;;&amp;gt; simp [ih]">
                                      <OtherNode start="(168, 5)" end="(168, 14)" kind="Lean.Parser.Tactic.cases">
                                        <AtomNode start="(168, 5)" end="(168, 10)" leading="" trailing=" " val="cases"/>
                                        <NullNode start="(168, 11)" end="(168, 14)">
                                          <OtherNode start="(168, 11)" end="(168, 14)" kind="Lean.Parser.Tactic.elimTarget">
                                            <NullNode/>
                                            <OtherNode start="(168, 11)" end="(168, 14)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(168, 11)" end="(168, 12)" leading="" trailing=" " raw_val="f" val="f"/>
                                              <NullNode start="(168, 13)" end="(168, 14)">
                                                <IdentNode start="(168, 13)" end="(168, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(168, 15)" end="(168, 18)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(168, 19)" end="(168, 28)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(168, 19)" end="(168, 23)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(168, 24)" end="(168, 28)">
                                          <AtomNode start="(168, 24)" end="(168, 25)" leading="" trailing="" val="["/>
                                          <NullNode start="(168, 25)" end="(168, 27)">
                                            <OtherNode start="(168, 25)" end="(168, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(168, 25)" end="(168, 27)" leading="" trailing="" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(168, 27)" end="(168, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(170, 1)" end="(177, 28)" name="foldrM_filterMap" full_name="List.foldrM_filterMap">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(170, 1)" end="(177, 28)" name="foldrM_filterMap" full_name="List.foldrM_filterMap" _is_private_decl="False">
        <AtomNode start="(170, 1)" end="(170, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(170, 9)" end="(170, 25)">
          <IdentNode start="(170, 9)" end="(170, 25)" leading="" trailing=" " raw_val="foldrM_filterMap" val="foldrM_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(170, 26)" end="(172, 83)">
          <NullNode start="(170, 26)" end="(170, 112)">
            <OtherNode start="(170, 26)" end="(170, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(170, 26)" end="(170, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(170, 27)" end="(170, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(170, 27)" end="(170, 32)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(170, 33)" end="(170, 34)">
                  <IdentNode start="(170, 33)" end="(170, 34)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(170, 34)" end="(170, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(170, 36)" end="(170, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(170, 36)" end="(170, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(170, 37)" end="(170, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(170, 37)" end="(170, 48)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(170, 49)" end="(170, 50)">
                  <IdentNode start="(170, 49)" end="(170, 50)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(170, 50)" end="(170, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(170, 52)" end="(170, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(170, 52)" end="(170, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(170, 53)" end="(170, 54)">
                <IdentNode start="(170, 53)" end="(170, 54)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(170, 55)" end="(170, 69)">
                <AtomNode start="(170, 55)" end="(170, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(170, 57)" end="(170, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(170, 57)" end="(170, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(170, 59)" end="(170, 60)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(170, 61)" end="(170, 69)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(170, 61)" end="(170, 67)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(170, 68)" end="(170, 69)">
                      <IdentNode start="(170, 68)" end="(170, 69)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(170, 69)" end="(170, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(170, 71)" end="(170, 88)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(170, 71)" end="(170, 72)" leading="" trailing="" val="{"/>
              <NullNode start="(170, 72)" end="(170, 73)">
                <IdentNode start="(170, 72)" end="(170, 73)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(170, 74)" end="(170, 87)">
                <AtomNode start="(170, 74)" end="(170, 75)" leading="" trailing=" " val=":"/>
                <OtherNode start="(170, 76)" end="(170, 87)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(170, 76)" end="(170, 77)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(170, 78)" end="(170, 79)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(170, 80)" end="(170, 87)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(170, 80)" end="(170, 81)" leading="" trailing=" " raw_val="γ" val="γ"/>
                    <AtomNode start="(170, 82)" end="(170, 83)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(170, 84)" end="(170, 87)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(170, 84)" end="(170, 85)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(170, 86)" end="(170, 87)">
                        <IdentNode start="(170, 86)" end="(170, 87)" leading="" trailing="" raw_val="γ" val="γ"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(170, 87)" end="(170, 88)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(170, 89)" end="(170, 101)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(170, 89)" end="(170, 90)" leading="" trailing="" val="{"/>
              <NullNode start="(170, 90)" end="(170, 91)">
                <IdentNode start="(170, 90)" end="(170, 91)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(170, 92)" end="(170, 100)">
                <AtomNode start="(170, 92)" end="(170, 93)" leading="" trailing=" " val=":"/>
                <OtherNode start="(170, 94)" end="(170, 100)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(170, 94)" end="(170, 98)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(170, 99)" end="(170, 100)">
                    <IdentNode start="(170, 99)" end="(170, 100)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(170, 100)" end="(170, 101)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(170, 102)" end="(170, 112)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(170, 102)" end="(170, 103)" leading="" trailing="" val="{"/>
              <NullNode start="(170, 103)" end="(170, 107)">
                <IdentNode start="(170, 103)" end="(170, 107)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(170, 108)" end="(170, 111)">
                <AtomNode start="(170, 108)" end="(170, 109)" leading="" trailing=" " val=":"/>
                <IdentNode start="(170, 110)" end="(170, 111)" leading="" trailing="" raw_val="γ" val="γ"/>
              </NullNode>
              <AtomNode start="(170, 111)" end="(170, 112)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(170, 113)" end="(172, 83)">
            <AtomNode start="(170, 113)" end="(170, 114)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(171, 5)" end="(172, 83)" kind="«term_=_»">
              <OtherNode start="(171, 5)" end="(171, 34)" kind="Lean.Parser.Term.app">
                <OtherNode start="(171, 5)" end="(171, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(171, 5)" end="(171, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(171, 5)" end="(171, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(171, 6)" end="(171, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(171, 6)" end="(171, 17)" leading="" trailing=" " raw_val="l.filterMap" val="l.filterMap"/>
                      <NullNode start="(171, 18)" end="(171, 19)">
                        <IdentNode start="(171, 18)" end="(171, 19)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(171, 19)" end="(171, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(171, 20)" end="(171, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(171, 21)" end="(171, 27)" leading="" trailing=" " raw_val="foldrM" val="foldrM" full_name="List.foldrM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(171, 28)" end="(171, 34)">
                  <IdentNode start="(171, 28)" end="(171, 29)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(171, 30)" end="(171, 34)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(171, 35)" end="(171, 36)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(172, 7)" end="(172, 83)" kind="Lean.Parser.Term.app">
                <IdentNode start="(172, 7)" end="(172, 15)" leading="" trailing=" " raw_val="l.foldrM" val="l.foldrM"/>
                <NullNode start="(172, 16)" end="(172, 83)">
                  <OtherNode start="(172, 16)" end="(172, 78)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(172, 16)" end="(172, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(172, 17)" end="(172, 77)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(172, 17)" end="(172, 20)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(172, 21)" end="(172, 77)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(172, 21)" end="(172, 24)">
                          <IdentNode start="(172, 21)" end="(172, 22)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(172, 23)" end="(172, 24)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(172, 25)" end="(172, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(172, 28)" end="(172, 77)" kind="Lean.Parser.Term.match">
                          <AtomNode start="(172, 28)" end="(172, 33)" leading="" trailing=" " val="match"/>
                          <NullNode/>
                          <NullNode/>
                          <NullNode start="(172, 34)" end="(172, 37)">
                            <OtherNode start="(172, 34)" end="(172, 37)" kind="Lean.Parser.Term.matchDiscr">
                              <NullNode/>
                              <OtherNode start="(172, 34)" end="(172, 37)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(172, 34)" end="(172, 35)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(172, 36)" end="(172, 37)">
                                  <IdentNode start="(172, 36)" end="(172, 37)" leading="" trailing=" " raw_val="x" val="x"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <AtomNode start="(172, 38)" end="(172, 42)" leading="" trailing=" " val="with"/>
                          <OtherNode start="(172, 43)" end="(172, 77)" kind="Lean.Parser.Term.matchAlts">
                            <NullNode start="(172, 43)" end="(172, 77)">
                              <OtherNode start="(172, 43)" end="(172, 60)" kind="Lean.Parser.Term.matchAlt">
                                <AtomNode start="(172, 43)" end="(172, 44)" leading="" trailing=" " val="|"/>
                                <NullNode start="(172, 45)" end="(172, 51)">
                                  <NullNode start="(172, 45)" end="(172, 51)">
                                    <OtherNode start="(172, 45)" end="(172, 51)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(172, 45)" end="(172, 49)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(172, 50)" end="(172, 51)">
                                        <IdentNode start="(172, 50)" end="(172, 51)" leading="" trailing=" " raw_val="b" val="b"/>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(172, 52)" end="(172, 54)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(172, 55)" end="(172, 60)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(172, 55)" end="(172, 56)" leading="" trailing=" " raw_val="g" val="g"/>
                                  <NullNode start="(172, 57)" end="(172, 60)">
                                    <IdentNode start="(172, 57)" end="(172, 58)" leading="" trailing=" " raw_val="b" val="b"/>
                                    <IdentNode start="(172, 59)" end="(172, 60)" leading="" trailing=" " raw_val="y" val="y"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(172, 61)" end="(172, 77)" kind="Lean.Parser.Term.matchAlt">
                                <AtomNode start="(172, 61)" end="(172, 62)" leading="" trailing=" " val="|"/>
                                <NullNode start="(172, 63)" end="(172, 67)">
                                  <NullNode start="(172, 63)" end="(172, 67)">
                                    <IdentNode start="(172, 63)" end="(172, 67)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(172, 68)" end="(172, 70)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(172, 71)" end="(172, 77)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(172, 71)" end="(172, 75)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(172, 76)" end="(172, 77)">
                                    <IdentNode start="(172, 76)" end="(172, 77)" leading="" trailing="" raw_val="y" val="y"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(172, 77)" end="(172, 78)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(172, 79)" end="(172, 83)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(172, 84)" end="(177, 28)">
          <AtomNode start="(172, 84)" end="(172, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(172, 87)" end="(177, 28)">
            <AtomNode start="(172, 87)" end="(172, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(173, 3)" end="(177, 28)">
              <TacticTacticseq1IndentedNode start="(173, 3)" end="(177, 28)">
                <NullNode start="(173, 3)" end="(177, 28)">
                  <OtherNode start="(173, 3)" end="(177, 28)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : β → γ → m γ&#10;l : List α&#10;init : γ&#10;⊢ foldrM g init (filterMap f l) =&#10;    foldrM&#10;      (fun x y =&amp;gt;&#10;        match f x with&#10;        | some b =&amp;gt; g b y&#10;        | none =&amp;gt; pure y)&#10;      init l" state_after="no goals" tactic="induction l generalizing init with&#10;| nil =&amp;gt; rfl&#10;| cons a l ih =&amp;gt;&#10;  simp only [filterMap_cons, foldrM_cons]&#10;  cases f a &amp;lt;;&amp;gt; simp [ih]">
                    <AtomNode start="(173, 3)" end="(173, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(173, 13)" end="(173, 14)">
                      <OtherNode start="(173, 13)" end="(173, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(173, 13)" end="(173, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(173, 15)" end="(173, 32)">
                      <AtomNode start="(173, 15)" end="(173, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(173, 28)" end="(173, 32)">
                        <IdentNode start="(173, 28)" end="(173, 32)" leading="" trailing=" " raw_val="init" val="init"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(173, 33)" end="(177, 28)">
                      <OtherNode start="(173, 33)" end="(177, 28)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(173, 33)" end="(173, 37)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(174, 3)" end="(177, 28)">
                          <OtherNode start="(174, 3)" end="(174, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(174, 3)" end="(174, 8)">
                              <OtherNode start="(174, 3)" end="(174, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(174, 3)" end="(174, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(174, 5)" end="(174, 8)">
                                  <NullNode/>
                                  <IdentNode start="(174, 5)" end="(174, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(174, 9)" end="(174, 15)">
                              <AtomNode start="(174, 9)" end="(174, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(174, 12)" end="(174, 15)">
                                <TacticTacticseq1IndentedNode start="(174, 12)" end="(174, 15)">
                                  <NullNode start="(174, 12)" end="(174, 15)">
                                    <OtherNode start="(174, 12)" end="(174, 15)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : β → γ → m γ&#10;init : γ&#10;⊢ foldrM g init (filterMap f []) =&#10;    foldrM&#10;      (fun x y =&amp;gt;&#10;        match f x with&#10;        | some b =&amp;gt; g b y&#10;        | none =&amp;gt; pure y)&#10;      init []" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(174, 12)" end="(174, 15)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(175, 3)" end="(177, 28)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(175, 3)" end="(175, 16)">
                              <OtherNode start="(175, 3)" end="(175, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(175, 3)" end="(175, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(175, 5)" end="(175, 9)">
                                  <NullNode/>
                                  <IdentNode start="(175, 5)" end="(175, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(175, 10)" end="(175, 16)">
                                  <IdentNode start="(175, 10)" end="(175, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(175, 12)" end="(175, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(175, 14)" end="(175, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(175, 17)" end="(177, 28)">
                              <AtomNode start="(175, 17)" end="(175, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(176, 5)" end="(177, 28)">
                                <TacticTacticseq1IndentedNode start="(176, 5)" end="(177, 28)">
                                  <NullNode start="(176, 5)" end="(177, 28)">
                                    <OtherNode start="(176, 5)" end="(176, 44)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : β → γ → m γ&#10;a : α&#10;l : List α&#10;ih :&#10;  ∀ {init : γ},&#10;    foldrM g init (filterMap f l) =&#10;      foldrM&#10;        (fun x y =&amp;gt;&#10;          match f x with&#10;          | some b =&amp;gt; g b y&#10;          | none =&amp;gt; pure y)&#10;        init l&#10;init : γ&#10;⊢ foldrM g init (filterMap f (a :: l)) =&#10;    foldrM&#10;      (fun x y =&amp;gt;&#10;        match f x with&#10;        | some b =&amp;gt; g b y&#10;        | none =&amp;gt; pure y)&#10;      init (a :: l)" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : β → γ → m γ&#10;a : α&#10;l : List α&#10;ih :&#10;  ∀ {init : γ},&#10;    foldrM g init (filterMap f l) =&#10;      foldrM&#10;        (fun x y =&amp;gt;&#10;          match f x with&#10;          | some b =&amp;gt; g b y&#10;          | none =&amp;gt; pure y)&#10;        init l&#10;init : γ&#10;⊢ foldrM g init&#10;      (match f a with&#10;      | none =&amp;gt; filterMap f l&#10;      | some b =&amp;gt; b :: filterMap f l) =&#10;    do&#10;    let y ←&#10;      foldrM&#10;          (fun x y =&amp;gt;&#10;            match f x with&#10;            | some b =&amp;gt; g b y&#10;            | none =&amp;gt; pure y)&#10;          init l&#10;    match f a with&#10;      | some b =&amp;gt; g b y&#10;      | none =&amp;gt; pure y" tactic="simp only [filterMap_cons, foldrM_cons]">
                                      <AtomNode start="(176, 5)" end="(176, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(176, 10)" end="(176, 14)">
                                        <AtomNode start="(176, 10)" end="(176, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(176, 15)" end="(176, 44)">
                                        <AtomNode start="(176, 15)" end="(176, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(176, 16)" end="(176, 43)">
                                          <OtherNode start="(176, 16)" end="(176, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(176, 16)" end="(176, 30)" leading="" trailing="" raw_val="filterMap_cons" val="filterMap_cons" full_name="List.filterMap_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(176, 30)" end="(176, 31)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(176, 32)" end="(176, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(176, 32)" end="(176, 43)" leading="" trailing="" raw_val="foldrM_cons" val="foldrM_cons" full_name="List.foldrM_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(176, 43)" end="(176, 44)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(177, 5)" end="(177, 28)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → Option β&#10;g : β → γ → m γ&#10;a : α&#10;l : List α&#10;ih :&#10;  ∀ {init : γ},&#10;    foldrM g init (filterMap f l) =&#10;      foldrM&#10;        (fun x y =&amp;gt;&#10;          match f x with&#10;          | some b =&amp;gt; g b y&#10;          | none =&amp;gt; pure y)&#10;        init l&#10;init : γ&#10;⊢ foldrM g init&#10;      (match f a with&#10;      | none =&amp;gt; filterMap f l&#10;      | some b =&amp;gt; b :: filterMap f l) =&#10;    do&#10;    let y ←&#10;      foldrM&#10;          (fun x y =&amp;gt;&#10;            match f x with&#10;            | some b =&amp;gt; g b y&#10;            | none =&amp;gt; pure y)&#10;          init l&#10;    match f a with&#10;      | some b =&amp;gt; g b y&#10;      | none =&amp;gt; pure y" state_after="no goals" tactic="cases f a &amp;lt;;&amp;gt; simp [ih]">
                                      <OtherNode start="(177, 5)" end="(177, 14)" kind="Lean.Parser.Tactic.cases">
                                        <AtomNode start="(177, 5)" end="(177, 10)" leading="" trailing=" " val="cases"/>
                                        <NullNode start="(177, 11)" end="(177, 14)">
                                          <OtherNode start="(177, 11)" end="(177, 14)" kind="Lean.Parser.Tactic.elimTarget">
                                            <NullNode/>
                                            <OtherNode start="(177, 11)" end="(177, 14)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(177, 11)" end="(177, 12)" leading="" trailing=" " raw_val="f" val="f"/>
                                              <NullNode start="(177, 13)" end="(177, 14)">
                                                <IdentNode start="(177, 13)" end="(177, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(177, 15)" end="(177, 18)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(177, 19)" end="(177, 28)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(177, 19)" end="(177, 23)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(177, 24)" end="(177, 28)">
                                          <AtomNode start="(177, 24)" end="(177, 25)" leading="" trailing="" val="["/>
                                          <NullNode start="(177, 25)" end="(177, 27)">
                                            <OtherNode start="(177, 25)" end="(177, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(177, 25)" end="(177, 27)" leading="" trailing="" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(177, 27)" end="(177, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(179, 1)" end="(186, 24)" name="foldlM_filter" full_name="List.foldlM_filter">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(179, 1)" end="(186, 24)" name="foldlM_filter" full_name="List.foldlM_filter" _is_private_decl="False">
        <AtomNode start="(179, 1)" end="(179, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(179, 9)" end="(179, 22)">
          <IdentNode start="(179, 9)" end="(179, 22)" leading="" trailing=" " raw_val="foldlM_filter" val="foldlM_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(179, 23)" end="(181, 63)">
          <NullNode start="(179, 23)" end="(179, 105)">
            <OtherNode start="(179, 23)" end="(179, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(179, 23)" end="(179, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(179, 24)" end="(179, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(179, 24)" end="(179, 29)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(179, 30)" end="(179, 31)">
                  <IdentNode start="(179, 30)" end="(179, 31)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(179, 31)" end="(179, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(179, 33)" end="(179, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(179, 33)" end="(179, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(179, 34)" end="(179, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(179, 34)" end="(179, 45)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(179, 46)" end="(179, 47)">
                  <IdentNode start="(179, 46)" end="(179, 47)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(179, 47)" end="(179, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(179, 49)" end="(179, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(179, 49)" end="(179, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(179, 50)" end="(179, 51)">
                <IdentNode start="(179, 50)" end="(179, 51)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(179, 52)" end="(179, 62)">
                <AtomNode start="(179, 52)" end="(179, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(179, 54)" end="(179, 62)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(179, 54)" end="(179, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(179, 56)" end="(179, 57)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(179, 58)" end="(179, 62)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(179, 62)" end="(179, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(179, 64)" end="(179, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(179, 64)" end="(179, 65)" leading="" trailing="" val="{"/>
              <NullNode start="(179, 65)" end="(179, 66)">
                <IdentNode start="(179, 65)" end="(179, 66)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(179, 67)" end="(179, 80)">
                <AtomNode start="(179, 67)" end="(179, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(179, 69)" end="(179, 80)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(179, 69)" end="(179, 70)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(179, 71)" end="(179, 72)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(179, 73)" end="(179, 80)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(179, 73)" end="(179, 74)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(179, 75)" end="(179, 76)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(179, 77)" end="(179, 80)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(179, 77)" end="(179, 78)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(179, 79)" end="(179, 80)">
                        <IdentNode start="(179, 79)" end="(179, 80)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(179, 80)" end="(179, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(179, 82)" end="(179, 94)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(179, 82)" end="(179, 83)" leading="" trailing="" val="{"/>
              <NullNode start="(179, 83)" end="(179, 84)">
                <IdentNode start="(179, 83)" end="(179, 84)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(179, 85)" end="(179, 93)">
                <AtomNode start="(179, 85)" end="(179, 86)" leading="" trailing=" " val=":"/>
                <OtherNode start="(179, 87)" end="(179, 93)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(179, 87)" end="(179, 91)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(179, 92)" end="(179, 93)">
                    <IdentNode start="(179, 92)" end="(179, 93)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(179, 93)" end="(179, 94)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(179, 95)" end="(179, 105)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(179, 95)" end="(179, 96)" leading="" trailing="" val="{"/>
              <NullNode start="(179, 96)" end="(179, 100)">
                <IdentNode start="(179, 96)" end="(179, 100)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(179, 101)" end="(179, 104)">
                <AtomNode start="(179, 101)" end="(179, 102)" leading="" trailing=" " val=":"/>
                <IdentNode start="(179, 103)" end="(179, 104)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(179, 104)" end="(179, 105)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(179, 106)" end="(181, 63)">
            <AtomNode start="(179, 106)" end="(179, 107)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(180, 5)" end="(181, 63)" kind="«term_=_»">
              <OtherNode start="(180, 5)" end="(180, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(180, 5)" end="(180, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(180, 5)" end="(180, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(180, 5)" end="(180, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(180, 6)" end="(180, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(180, 6)" end="(180, 14)" leading="" trailing=" " raw_val="l.filter" val="l.filter"/>
                      <NullNode start="(180, 15)" end="(180, 16)">
                        <IdentNode start="(180, 15)" end="(180, 16)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(180, 16)" end="(180, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(180, 17)" end="(180, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(180, 18)" end="(180, 24)" leading="" trailing=" " raw_val="foldlM" val="foldlM" full_name="List.foldlM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(180, 25)" end="(180, 31)">
                  <IdentNode start="(180, 25)" end="(180, 26)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(180, 27)" end="(180, 31)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(180, 32)" end="(180, 33)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(181, 7)" end="(181, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(181, 7)" end="(181, 15)" leading="" trailing=" " raw_val="l.foldlM" val="l.foldlM"/>
                <NullNode start="(181, 16)" end="(181, 63)">
                  <OtherNode start="(181, 16)" end="(181, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(181, 16)" end="(181, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(181, 17)" end="(181, 57)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(181, 17)" end="(181, 20)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(181, 21)" end="(181, 57)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(181, 21)" end="(181, 24)">
                          <IdentNode start="(181, 21)" end="(181, 22)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(181, 23)" end="(181, 24)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(181, 25)" end="(181, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(181, 28)" end="(181, 57)" kind="termIfThenElse">
                          <AtomNode start="(181, 28)" end="(181, 30)" leading="" trailing=" " val="if"/>
                          <OtherNode start="(181, 31)" end="(181, 34)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(181, 31)" end="(181, 32)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(181, 33)" end="(181, 34)">
                              <IdentNode start="(181, 33)" end="(181, 34)" leading="" trailing=" " raw_val="y" val="y"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(181, 35)" end="(181, 39)" leading="" trailing=" " val="then"/>
                          <OtherNode start="(181, 40)" end="(181, 45)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(181, 40)" end="(181, 41)" leading="" trailing=" " raw_val="g" val="g"/>
                            <NullNode start="(181, 42)" end="(181, 45)">
                              <IdentNode start="(181, 42)" end="(181, 43)" leading="" trailing=" " raw_val="x" val="x"/>
                              <IdentNode start="(181, 44)" end="(181, 45)" leading="" trailing=" " raw_val="y" val="y"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(181, 46)" end="(181, 50)" leading="" trailing=" " val="else"/>
                          <OtherNode start="(181, 51)" end="(181, 57)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(181, 51)" end="(181, 55)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(181, 56)" end="(181, 57)">
                              <IdentNode start="(181, 56)" end="(181, 57)" leading="" trailing="" raw_val="x" val="x"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(181, 57)" end="(181, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(181, 59)" end="(181, 63)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(181, 64)" end="(186, 24)">
          <AtomNode start="(181, 64)" end="(181, 66)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(181, 67)" end="(186, 24)">
            <AtomNode start="(181, 67)" end="(181, 69)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(182, 3)" end="(186, 24)">
              <TacticTacticseq1IndentedNode start="(182, 3)" end="(186, 24)">
                <NullNode start="(182, 3)" end="(186, 24)">
                  <OtherNode start="(182, 3)" end="(186, 24)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : β → α → m β&#10;l : List α&#10;init : β&#10;⊢ foldlM g init (filter p l) = foldlM (fun x y =&amp;gt; if p y = true then g x y else pure x) init l" state_after="no goals" tactic="induction l generalizing init with&#10;| nil =&amp;gt; rfl&#10;| cons a l ih =&amp;gt;&#10;  simp only [filter_cons, foldlM_cons]&#10;  split &amp;lt;;&amp;gt; simp [ih]">
                    <AtomNode start="(182, 3)" end="(182, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(182, 13)" end="(182, 14)">
                      <OtherNode start="(182, 13)" end="(182, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(182, 13)" end="(182, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(182, 15)" end="(182, 32)">
                      <AtomNode start="(182, 15)" end="(182, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(182, 28)" end="(182, 32)">
                        <IdentNode start="(182, 28)" end="(182, 32)" leading="" trailing=" " raw_val="init" val="init"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(182, 33)" end="(186, 24)">
                      <OtherNode start="(182, 33)" end="(186, 24)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(182, 33)" end="(182, 37)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(183, 3)" end="(186, 24)">
                          <OtherNode start="(183, 3)" end="(183, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(183, 3)" end="(183, 8)">
                              <OtherNode start="(183, 3)" end="(183, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(183, 3)" end="(183, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(183, 5)" end="(183, 8)">
                                  <NullNode/>
                                  <IdentNode start="(183, 5)" end="(183, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(183, 9)" end="(183, 15)">
                              <AtomNode start="(183, 9)" end="(183, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(183, 12)" end="(183, 15)">
                                <TacticTacticseq1IndentedNode start="(183, 12)" end="(183, 15)">
                                  <NullNode start="(183, 12)" end="(183, 15)">
                                    <OtherNode start="(183, 12)" end="(183, 15)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : β → α → m β&#10;init : β&#10;⊢ foldlM g init (filter p []) = foldlM (fun x y =&amp;gt; if p y = true then g x y else pure x) init []" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(183, 12)" end="(183, 15)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(184, 3)" end="(186, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(184, 3)" end="(184, 16)">
                              <OtherNode start="(184, 3)" end="(184, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(184, 3)" end="(184, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(184, 5)" end="(184, 9)">
                                  <NullNode/>
                                  <IdentNode start="(184, 5)" end="(184, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(184, 10)" end="(184, 16)">
                                  <IdentNode start="(184, 10)" end="(184, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(184, 12)" end="(184, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(184, 14)" end="(184, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(184, 17)" end="(186, 24)">
                              <AtomNode start="(184, 17)" end="(184, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(185, 5)" end="(186, 24)">
                                <TacticTacticseq1IndentedNode start="(185, 5)" end="(186, 24)">
                                  <NullNode start="(185, 5)" end="(186, 24)">
                                    <OtherNode start="(185, 5)" end="(185, 41)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : β → α → m β&#10;a : α&#10;l : List α&#10;ih : ∀ {init : β}, foldlM g init (filter p l) = foldlM (fun x y =&amp;gt; if p y = true then g x y else pure x) init l&#10;init : β&#10;⊢ foldlM g init (filter p (a :: l)) = foldlM (fun x y =&amp;gt; if p y = true then g x y else pure x) init (a :: l)" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : β → α → m β&#10;a : α&#10;l : List α&#10;ih : ∀ {init : β}, foldlM g init (filter p l) = foldlM (fun x y =&amp;gt; if p y = true then g x y else pure x) init l&#10;init : β&#10;⊢ foldlM g init (if p a = true then a :: filter p l else filter p l) = do&#10;    let init ← if p a = true then g init a else pure init&#10;    foldlM (fun x y =&amp;gt; if p y = true then g x y else pure x) init l" tactic="simp only [filter_cons, foldlM_cons]">
                                      <AtomNode start="(185, 5)" end="(185, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(185, 10)" end="(185, 14)">
                                        <AtomNode start="(185, 10)" end="(185, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(185, 15)" end="(185, 41)">
                                        <AtomNode start="(185, 15)" end="(185, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(185, 16)" end="(185, 40)">
                                          <OtherNode start="(185, 16)" end="(185, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(185, 16)" end="(185, 27)" leading="" trailing="" raw_val="filter_cons" val="filter_cons" full_name="List.filter_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(185, 27)" end="(185, 28)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(185, 29)" end="(185, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(185, 29)" end="(185, 40)" leading="" trailing="" raw_val="foldlM_cons" val="foldlM_cons" full_name="List.foldlM_cons" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(185, 40)" end="(185, 41)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(186, 5)" end="(186, 24)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : β → α → m β&#10;a : α&#10;l : List α&#10;ih : ∀ {init : β}, foldlM g init (filter p l) = foldlM (fun x y =&amp;gt; if p y = true then g x y else pure x) init l&#10;init : β&#10;⊢ foldlM g init (if p a = true then a :: filter p l else filter p l) = do&#10;    let init ← if p a = true then g init a else pure init&#10;    foldlM (fun x y =&amp;gt; if p y = true then g x y else pure x) init l" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [ih]">
                                      <OtherNode start="(186, 5)" end="(186, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(186, 5)" end="(186, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(186, 11)" end="(186, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(186, 15)" end="(186, 24)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(186, 15)" end="(186, 19)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(186, 20)" end="(186, 24)">
                                          <AtomNode start="(186, 20)" end="(186, 21)" leading="" trailing="" val="["/>
                                          <NullNode start="(186, 21)" end="(186, 23)">
                                            <OtherNode start="(186, 21)" end="(186, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(186, 21)" end="(186, 23)" leading="" trailing="" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(186, 23)" end="(186, 24)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(188, 1)" end="(195, 24)" name="foldrM_filter" full_name="List.foldrM_filter">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(188, 1)" end="(195, 24)" name="foldrM_filter" full_name="List.foldrM_filter" _is_private_decl="False">
        <AtomNode start="(188, 1)" end="(188, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(188, 9)" end="(188, 22)">
          <IdentNode start="(188, 9)" end="(188, 22)" leading="" trailing=" " raw_val="foldrM_filter" val="foldrM_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(188, 23)" end="(190, 63)">
          <NullNode start="(188, 23)" end="(188, 105)">
            <OtherNode start="(188, 23)" end="(188, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(188, 23)" end="(188, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(188, 24)" end="(188, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(188, 24)" end="(188, 29)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(188, 30)" end="(188, 31)">
                  <IdentNode start="(188, 30)" end="(188, 31)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(188, 31)" end="(188, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(188, 33)" end="(188, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(188, 33)" end="(188, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(188, 34)" end="(188, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(188, 34)" end="(188, 45)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(188, 46)" end="(188, 47)">
                  <IdentNode start="(188, 46)" end="(188, 47)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(188, 47)" end="(188, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(188, 49)" end="(188, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(188, 49)" end="(188, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(188, 50)" end="(188, 51)">
                <IdentNode start="(188, 50)" end="(188, 51)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(188, 52)" end="(188, 62)">
                <AtomNode start="(188, 52)" end="(188, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(188, 54)" end="(188, 62)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(188, 54)" end="(188, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(188, 56)" end="(188, 57)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(188, 58)" end="(188, 62)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(188, 62)" end="(188, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(188, 64)" end="(188, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(188, 64)" end="(188, 65)" leading="" trailing="" val="{"/>
              <NullNode start="(188, 65)" end="(188, 66)">
                <IdentNode start="(188, 65)" end="(188, 66)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(188, 67)" end="(188, 80)">
                <AtomNode start="(188, 67)" end="(188, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(188, 69)" end="(188, 80)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(188, 69)" end="(188, 70)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(188, 71)" end="(188, 72)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(188, 73)" end="(188, 80)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(188, 73)" end="(188, 74)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(188, 75)" end="(188, 76)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(188, 77)" end="(188, 80)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(188, 77)" end="(188, 78)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(188, 79)" end="(188, 80)">
                        <IdentNode start="(188, 79)" end="(188, 80)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(188, 80)" end="(188, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(188, 82)" end="(188, 94)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(188, 82)" end="(188, 83)" leading="" trailing="" val="{"/>
              <NullNode start="(188, 83)" end="(188, 84)">
                <IdentNode start="(188, 83)" end="(188, 84)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(188, 85)" end="(188, 93)">
                <AtomNode start="(188, 85)" end="(188, 86)" leading="" trailing=" " val=":"/>
                <OtherNode start="(188, 87)" end="(188, 93)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(188, 87)" end="(188, 91)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(188, 92)" end="(188, 93)">
                    <IdentNode start="(188, 92)" end="(188, 93)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(188, 93)" end="(188, 94)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(188, 95)" end="(188, 105)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(188, 95)" end="(188, 96)" leading="" trailing="" val="{"/>
              <NullNode start="(188, 96)" end="(188, 100)">
                <IdentNode start="(188, 96)" end="(188, 100)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(188, 101)" end="(188, 104)">
                <AtomNode start="(188, 101)" end="(188, 102)" leading="" trailing=" " val=":"/>
                <IdentNode start="(188, 103)" end="(188, 104)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(188, 104)" end="(188, 105)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(188, 106)" end="(190, 63)">
            <AtomNode start="(188, 106)" end="(188, 107)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(189, 5)" end="(190, 63)" kind="«term_=_»">
              <OtherNode start="(189, 5)" end="(189, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(189, 5)" end="(189, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(189, 5)" end="(189, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(189, 5)" end="(189, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(189, 6)" end="(189, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(189, 6)" end="(189, 14)" leading="" trailing=" " raw_val="l.filter" val="l.filter"/>
                      <NullNode start="(189, 15)" end="(189, 16)">
                        <IdentNode start="(189, 15)" end="(189, 16)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(189, 16)" end="(189, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(189, 17)" end="(189, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(189, 18)" end="(189, 24)" leading="" trailing=" " raw_val="foldrM" val="foldrM" full_name="List.foldrM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(189, 25)" end="(189, 31)">
                  <IdentNode start="(189, 25)" end="(189, 26)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(189, 27)" end="(189, 31)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(189, 32)" end="(189, 33)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(190, 7)" end="(190, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(190, 7)" end="(190, 15)" leading="" trailing=" " raw_val="l.foldrM" val="l.foldrM"/>
                <NullNode start="(190, 16)" end="(190, 63)">
                  <OtherNode start="(190, 16)" end="(190, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(190, 16)" end="(190, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(190, 17)" end="(190, 57)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(190, 17)" end="(190, 20)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(190, 21)" end="(190, 57)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(190, 21)" end="(190, 24)">
                          <IdentNode start="(190, 21)" end="(190, 22)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(190, 23)" end="(190, 24)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(190, 25)" end="(190, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(190, 28)" end="(190, 57)" kind="termIfThenElse">
                          <AtomNode start="(190, 28)" end="(190, 30)" leading="" trailing=" " val="if"/>
                          <OtherNode start="(190, 31)" end="(190, 34)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(190, 31)" end="(190, 32)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(190, 33)" end="(190, 34)">
                              <IdentNode start="(190, 33)" end="(190, 34)" leading="" trailing=" " raw_val="x" val="x"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(190, 35)" end="(190, 39)" leading="" trailing=" " val="then"/>
                          <OtherNode start="(190, 40)" end="(190, 45)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(190, 40)" end="(190, 41)" leading="" trailing=" " raw_val="g" val="g"/>
                            <NullNode start="(190, 42)" end="(190, 45)">
                              <IdentNode start="(190, 42)" end="(190, 43)" leading="" trailing=" " raw_val="x" val="x"/>
                              <IdentNode start="(190, 44)" end="(190, 45)" leading="" trailing=" " raw_val="y" val="y"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(190, 46)" end="(190, 50)" leading="" trailing=" " val="else"/>
                          <OtherNode start="(190, 51)" end="(190, 57)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(190, 51)" end="(190, 55)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(190, 56)" end="(190, 57)">
                              <IdentNode start="(190, 56)" end="(190, 57)" leading="" trailing="" raw_val="y" val="y"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(190, 57)" end="(190, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(190, 59)" end="(190, 63)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(190, 64)" end="(195, 24)">
          <AtomNode start="(190, 64)" end="(190, 66)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(190, 67)" end="(195, 24)">
            <AtomNode start="(190, 67)" end="(190, 69)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(191, 3)" end="(195, 24)">
              <TacticTacticseq1IndentedNode start="(191, 3)" end="(195, 24)">
                <NullNode start="(191, 3)" end="(195, 24)">
                  <OtherNode start="(191, 3)" end="(195, 24)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : α → β → m β&#10;l : List α&#10;init : β&#10;⊢ foldrM g init (filter p l) = foldrM (fun x y =&amp;gt; if p x = true then g x y else pure y) init l" state_after="no goals" tactic="induction l generalizing init with&#10;| nil =&amp;gt; rfl&#10;| cons a l ih =&amp;gt;&#10;  simp only [filter_cons, foldrM_cons]&#10;  split &amp;lt;;&amp;gt; simp [ih]">
                    <AtomNode start="(191, 3)" end="(191, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(191, 13)" end="(191, 14)">
                      <OtherNode start="(191, 13)" end="(191, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(191, 13)" end="(191, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(191, 15)" end="(191, 32)">
                      <AtomNode start="(191, 15)" end="(191, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(191, 28)" end="(191, 32)">
                        <IdentNode start="(191, 28)" end="(191, 32)" leading="" trailing=" " raw_val="init" val="init"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(191, 33)" end="(195, 24)">
                      <OtherNode start="(191, 33)" end="(195, 24)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(191, 33)" end="(191, 37)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(192, 3)" end="(195, 24)">
                          <OtherNode start="(192, 3)" end="(192, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(192, 3)" end="(192, 8)">
                              <OtherNode start="(192, 3)" end="(192, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(192, 3)" end="(192, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(192, 5)" end="(192, 8)">
                                  <NullNode/>
                                  <IdentNode start="(192, 5)" end="(192, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(192, 9)" end="(192, 15)">
                              <AtomNode start="(192, 9)" end="(192, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(192, 12)" end="(192, 15)">
                                <TacticTacticseq1IndentedNode start="(192, 12)" end="(192, 15)">
                                  <NullNode start="(192, 12)" end="(192, 15)">
                                    <OtherNode start="(192, 12)" end="(192, 15)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : α → β → m β&#10;init : β&#10;⊢ foldrM g init (filter p []) = foldrM (fun x y =&amp;gt; if p x = true then g x y else pure y) init []" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(192, 12)" end="(192, 15)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(193, 3)" end="(195, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(193, 3)" end="(193, 16)">
                              <OtherNode start="(193, 3)" end="(193, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(193, 3)" end="(193, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(193, 5)" end="(193, 9)">
                                  <NullNode/>
                                  <IdentNode start="(193, 5)" end="(193, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(193, 10)" end="(193, 16)">
                                  <IdentNode start="(193, 10)" end="(193, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(193, 12)" end="(193, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(193, 14)" end="(193, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(193, 17)" end="(195, 24)">
                              <AtomNode start="(193, 17)" end="(193, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(194, 5)" end="(195, 24)">
                                <TacticTacticseq1IndentedNode start="(194, 5)" end="(195, 24)">
                                  <NullNode start="(194, 5)" end="(195, 24)">
                                    <OtherNode start="(194, 5)" end="(194, 41)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : α → β → m β&#10;a : α&#10;l : List α&#10;ih : ∀ {init : β}, foldrM g init (filter p l) = foldrM (fun x y =&amp;gt; if p x = true then g x y else pure y) init l&#10;init : β&#10;⊢ foldrM g init (filter p (a :: l)) = foldrM (fun x y =&amp;gt; if p x = true then g x y else pure y) init (a :: l)" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : α → β → m β&#10;a : α&#10;l : List α&#10;ih : ∀ {init : β}, foldrM g init (filter p l) = foldrM (fun x y =&amp;gt; if p x = true then g x y else pure y) init l&#10;init : β&#10;⊢ foldrM g init (if p a = true then a :: filter p l else filter p l) = do&#10;    let y ← foldrM (fun x y =&amp;gt; if p x = true then g x y else pure y) init l&#10;    if p a = true then g a y else pure y" tactic="simp only [filter_cons, foldrM_cons]">
                                      <AtomNode start="(194, 5)" end="(194, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(194, 10)" end="(194, 14)">
                                        <AtomNode start="(194, 10)" end="(194, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(194, 15)" end="(194, 41)">
                                        <AtomNode start="(194, 15)" end="(194, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(194, 16)" end="(194, 40)">
                                          <OtherNode start="(194, 16)" end="(194, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(194, 16)" end="(194, 27)" leading="" trailing="" raw_val="filter_cons" val="filter_cons" full_name="List.filter_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(194, 27)" end="(194, 28)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(194, 29)" end="(194, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(194, 29)" end="(194, 40)" leading="" trailing="" raw_val="foldrM_cons" val="foldrM_cons" full_name="List.foldrM_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(194, 40)" end="(194, 41)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(195, 5)" end="(195, 24)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;g : α → β → m β&#10;a : α&#10;l : List α&#10;ih : ∀ {init : β}, foldrM g init (filter p l) = foldrM (fun x y =&amp;gt; if p x = true then g x y else pure y) init l&#10;init : β&#10;⊢ foldrM g init (if p a = true then a :: filter p l else filter p l) = do&#10;    let y ← foldrM (fun x y =&amp;gt; if p x = true then g x y else pure y) init l&#10;    if p a = true then g a y else pure y" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [ih]">
                                      <OtherNode start="(195, 5)" end="(195, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(195, 5)" end="(195, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(195, 11)" end="(195, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(195, 15)" end="(195, 24)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(195, 15)" end="(195, 19)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(195, 20)" end="(195, 24)">
                                          <AtomNode start="(195, 20)" end="(195, 21)" leading="" trailing="" val="["/>
                                          <NullNode start="(195, 21)" end="(195, 23)">
                                            <OtherNode start="(195, 21)" end="(195, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(195, 21)" end="(195, 23)" leading="" trailing="" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(195, 23)" end="(195, 24)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(197, 1)" end="(202, 41)" name="foldlM_attachWith" full_name="List.foldlM_attachWith">
      <CommandDeclmodifiersNode start="(197, 1)" end="(197, 8)">
        <NullNode/>
        <NullNode start="(197, 1)" end="(197, 8)">
          <OtherNode start="(197, 1)" end="(197, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(197, 1)" end="(197, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(197, 3)" end="(197, 7)">
              <OtherNode start="(197, 3)" end="(197, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(197, 3)" end="(197, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(197, 3)" end="(197, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(197, 7)" end="(197, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(197, 9)" end="(202, 41)" name="foldlM_attachWith" full_name="List.foldlM_attachWith" _is_private_decl="False">
        <AtomNode start="(197, 9)" end="(197, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(197, 17)" end="(197, 34)">
          <IdentNode start="(197, 17)" end="(197, 34)" leading="" trailing=" " raw_val="foldlM_attachWith" val="foldlM_attachWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(197, 35)" end="(199, 87)">
          <NullNode start="(197, 35)" end="(198, 87)">
            <OtherNode start="(197, 35)" end="(197, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(197, 35)" end="(197, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(197, 36)" end="(197, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(197, 36)" end="(197, 41)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(197, 42)" end="(197, 43)">
                  <IdentNode start="(197, 42)" end="(197, 43)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(197, 43)" end="(197, 44)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(198, 5)" end="(198, 17)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(198, 5)" end="(198, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(198, 6)" end="(198, 7)">
                <IdentNode start="(198, 6)" end="(198, 7)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(198, 8)" end="(198, 16)">
                <AtomNode start="(198, 8)" end="(198, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(198, 10)" end="(198, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(198, 10)" end="(198, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(198, 15)" end="(198, 16)">
                    <IdentNode start="(198, 15)" end="(198, 16)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(198, 16)" end="(198, 17)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(198, 18)" end="(198, 32)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(198, 18)" end="(198, 19)" leading="" trailing="" val="{"/>
              <NullNode start="(198, 19)" end="(198, 20)">
                <IdentNode start="(198, 19)" end="(198, 20)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(198, 21)" end="(198, 31)">
                <AtomNode start="(198, 21)" end="(198, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(198, 23)" end="(198, 31)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(198, 23)" end="(198, 24)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(198, 25)" end="(198, 26)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(198, 27)" end="(198, 31)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(198, 27)" end="(198, 31)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(198, 31)" end="(198, 32)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(198, 33)" end="(198, 55)">
              <AtomNode start="(198, 33)" end="(198, 34)" leading="" trailing="" val="("/>
              <NullNode start="(198, 34)" end="(198, 35)">
                <IdentNode start="(198, 34)" end="(198, 35)" leading="" trailing=" " raw_val="H" val="H"/>
              </NullNode>
              <NullNode start="(198, 36)" end="(198, 54)">
                <AtomNode start="(198, 36)" end="(198, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(198, 38)" end="(198, 54)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(198, 38)" end="(198, 39)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(198, 40)" end="(198, 41)">
                    <IdentNode start="(198, 40)" end="(198, 41)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(198, 41)" end="(198, 42)" leading="" trailing=" " val=","/>
                  <OtherNode start="(198, 43)" end="(198, 54)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(198, 43)" end="(198, 48)" kind="«term_∈_»">
                      <IdentNode start="(198, 43)" end="(198, 44)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(198, 45)" end="(198, 46)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(198, 47)" end="(198, 48)" leading="" trailing=" " raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(198, 49)" end="(198, 50)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(198, 51)" end="(198, 54)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(198, 51)" end="(198, 52)" leading="" trailing=" " raw_val="q" val="q"/>
                      <NullNode start="(198, 53)" end="(198, 54)">
                        <IdentNode start="(198, 53)" end="(198, 54)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(198, 54)" end="(198, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(198, 56)" end="(198, 83)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(198, 56)" end="(198, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(198, 57)" end="(198, 58)">
                <IdentNode start="(198, 57)" end="(198, 58)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(198, 59)" end="(198, 82)">
                <AtomNode start="(198, 59)" end="(198, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(198, 61)" end="(198, 82)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(198, 61)" end="(198, 62)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(198, 63)" end="(198, 64)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(198, 65)" end="(198, 82)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(198, 65)" end="(198, 76)" kind="«term{_:_//_}»">
                      <AtomNode start="(198, 65)" end="(198, 66)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(198, 67)" end="(198, 68)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(198, 69)" end="(198, 71)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(198, 72)" end="(198, 75)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(198, 72)" end="(198, 73)" leading="" trailing=" " raw_val="q" val="q"/>
                        <NullNode start="(198, 74)" end="(198, 75)">
                          <IdentNode start="(198, 74)" end="(198, 75)" leading="" trailing="" raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(198, 75)" end="(198, 76)" leading="" trailing=" " val="}"/>
                    </OtherNode>
                    <AtomNode start="(198, 77)" end="(198, 78)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(198, 79)" end="(198, 82)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(198, 79)" end="(198, 80)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(198, 81)" end="(198, 82)">
                        <IdentNode start="(198, 81)" end="(198, 82)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(198, 82)" end="(198, 83)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(198, 84)" end="(198, 87)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(198, 84)" end="(198, 85)" leading="" trailing="" val="{"/>
              <NullNode start="(198, 85)" end="(198, 86)">
                <IdentNode start="(198, 85)" end="(198, 86)" leading="" trailing="" raw_val="b" val="b"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(198, 86)" end="(198, 87)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(198, 88)" end="(199, 87)">
            <AtomNode start="(198, 88)" end="(198, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(199, 5)" end="(199, 87)" kind="«term_=_»">
              <OtherNode start="(199, 5)" end="(199, 34)" kind="Lean.Parser.Term.app">
                <OtherNode start="(199, 5)" end="(199, 30)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(199, 5)" end="(199, 23)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(199, 5)" end="(199, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(199, 6)" end="(199, 22)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(199, 6)" end="(199, 18)" leading="" trailing=" " raw_val="l.attachWith" val="l.attachWith"/>
                      <NullNode start="(199, 19)" end="(199, 22)">
                        <IdentNode start="(199, 19)" end="(199, 20)" leading="" trailing=" " raw_val="q" val="q"/>
                        <IdentNode start="(199, 21)" end="(199, 22)" leading="" trailing="" raw_val="H" val="H"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(199, 22)" end="(199, 23)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(199, 23)" end="(199, 24)" leading="" trailing="" val="."/>
                  <IdentNode start="(199, 24)" end="(199, 30)" leading="" trailing=" " raw_val="foldlM" val="foldlM" full_name="List.foldlM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(199, 31)" end="(199, 34)">
                  <IdentNode start="(199, 31)" end="(199, 32)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(199, 33)" end="(199, 34)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(199, 35)" end="(199, 36)" leading="" trailing=" " val="="/>
              <OtherNode start="(199, 37)" end="(199, 87)" kind="Lean.Parser.Term.app">
                <IdentNode start="(199, 37)" end="(199, 52)" leading="" trailing=" " raw_val="l.attach.foldlM" val="l.attach.foldlM"/>
                <NullNode start="(199, 53)" end="(199, 87)">
                  <OtherNode start="(199, 53)" end="(199, 85)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(199, 53)" end="(199, 54)" leading="" trailing="" val="("/>
                    <OtherNode start="(199, 54)" end="(199, 84)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(199, 54)" end="(199, 57)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(199, 58)" end="(199, 84)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(199, 58)" end="(199, 66)">
                          <IdentNode start="(199, 58)" end="(199, 59)" leading="" trailing=" " raw_val="b" val="b"/>
                          <OtherNode start="(199, 60)" end="(199, 66)" kind="Lean.Parser.Term.anonymousCtor">
                            <AtomNode start="(199, 60)" end="(199, 61)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(199, 61)" end="(199, 65)">
                              <IdentNode start="(199, 61)" end="(199, 62)" leading="" trailing="" raw_val="a" val="a"/>
                              <AtomNode start="(199, 62)" end="(199, 63)" leading="" trailing=" " val=","/>
                              <IdentNode start="(199, 64)" end="(199, 65)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                            <AtomNode start="(199, 65)" end="(199, 66)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(199, 67)" end="(199, 69)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(199, 70)" end="(199, 84)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(199, 70)" end="(199, 71)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(199, 72)" end="(199, 84)">
                            <IdentNode start="(199, 72)" end="(199, 73)" leading="" trailing=" " raw_val="b" val="b"/>
                            <OtherNode start="(199, 74)" end="(199, 84)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(199, 74)" end="(199, 75)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(199, 75)" end="(199, 83)">
                                <IdentNode start="(199, 75)" end="(199, 76)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(199, 76)" end="(199, 77)" leading="" trailing=" " val=","/>
                                <OtherNode start="(199, 78)" end="(199, 83)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(199, 78)" end="(199, 79)" leading="" trailing=" " raw_val="H" val="H"/>
                                  <NullNode start="(199, 80)" end="(199, 83)">
                                    <TermHoleNode start="(199, 80)" end="(199, 81)">
                                      <AtomNode start="(199, 80)" end="(199, 81)" leading="" trailing=" " val="_"/>
                                    </TermHoleNode>
                                    <IdentNode start="(199, 82)" end="(199, 83)" leading="" trailing="" raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(199, 83)" end="(199, 84)" leading="" trailing="" val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(199, 84)" end="(199, 85)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(199, 86)" end="(199, 87)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(199, 88)" end="(202, 41)">
          <AtomNode start="(199, 88)" end="(199, 90)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(199, 91)" end="(202, 41)">
            <AtomNode start="(199, 91)" end="(199, 93)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(200, 3)" end="(202, 41)">
              <TacticTacticseq1IndentedNode start="(200, 3)" end="(202, 41)">
                <NullNode start="(200, 3)" end="(202, 41)">
                  <OtherNode start="(200, 3)" end="(202, 41)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;l : List α&#10;q : α → Prop&#10;H : ∀ (a : α), a ∈ l → q a&#10;f : β → { x // q x } → m β&#10;b : β&#10;⊢ foldlM f b (l.attachWith q H) =&#10;    foldlM&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, h⟩ =&amp;gt; f b ⟨a, ⋯⟩)&#10;      b l.attach" state_after="no goals" tactic="induction l generalizing b with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt; simp [ih, foldlM_map]">
                    <AtomNode start="(200, 3)" end="(200, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(200, 13)" end="(200, 14)">
                      <OtherNode start="(200, 13)" end="(200, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(200, 13)" end="(200, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(200, 15)" end="(200, 29)">
                      <AtomNode start="(200, 15)" end="(200, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(200, 28)" end="(200, 29)">
                        <IdentNode start="(200, 28)" end="(200, 29)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(200, 30)" end="(202, 41)">
                      <OtherNode start="(200, 30)" end="(202, 41)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(200, 30)" end="(200, 34)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(201, 3)" end="(202, 41)">
                          <OtherNode start="(201, 3)" end="(201, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(201, 3)" end="(201, 8)">
                              <OtherNode start="(201, 3)" end="(201, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(201, 3)" end="(201, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(201, 5)" end="(201, 8)">
                                  <NullNode/>
                                  <IdentNode start="(201, 5)" end="(201, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(201, 9)" end="(201, 16)">
                              <AtomNode start="(201, 9)" end="(201, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(201, 12)" end="(201, 16)">
                                <TacticTacticseq1IndentedNode start="(201, 12)" end="(201, 16)">
                                  <NullNode start="(201, 12)" end="(201, 16)">
                                    <OtherNode start="(201, 12)" end="(201, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;q : α → Prop&#10;f : β → { x // q x } → m β&#10;H : ∀ (a : α), a ∈ [] → q a&#10;b : β&#10;⊢ foldlM f b ([].attachWith q H) =&#10;    foldlM&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, h⟩ =&amp;gt; f b ⟨a, ⋯⟩)&#10;      b [].attach" state_after="no goals" tactic="simp">
                                      <AtomNode start="(201, 12)" end="(201, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(202, 3)" end="(202, 41)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(202, 3)" end="(202, 16)">
                              <OtherNode start="(202, 3)" end="(202, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(202, 3)" end="(202, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(202, 5)" end="(202, 9)">
                                  <NullNode/>
                                  <IdentNode start="(202, 5)" end="(202, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(202, 10)" end="(202, 16)">
                                  <IdentNode start="(202, 10)" end="(202, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(202, 12)" end="(202, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(202, 14)" end="(202, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(202, 17)" end="(202, 41)">
                              <AtomNode start="(202, 17)" end="(202, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(202, 20)" end="(202, 41)">
                                <TacticTacticseq1IndentedNode start="(202, 20)" end="(202, 41)">
                                  <NullNode start="(202, 20)" end="(202, 41)">
                                    <OtherNode start="(202, 20)" end="(202, 41)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;q : α → Prop&#10;f : β → { x // q x } → m β&#10;a : α&#10;l : List α&#10;ih :&#10;  ∀ (H : ∀ (a : α), a ∈ l → q a) {b : β},&#10;    foldlM f b (l.attachWith q H) =&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match x with&#10;          | ⟨a, h⟩ =&amp;gt; f b ⟨a, ⋯⟩)&#10;        b l.attach&#10;H : ∀ (a_1 : α), a_1 ∈ a :: l → q a_1&#10;b : β&#10;⊢ foldlM f b ((a :: l).attachWith q H) =&#10;    foldlM&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a_1, h⟩ =&amp;gt; f b ⟨a_1, ⋯⟩)&#10;      b (a :: l).attach" state_after="no goals" tactic="simp [ih, foldlM_map]">
                                      <AtomNode start="(202, 20)" end="(202, 24)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(202, 25)" end="(202, 41)">
                                        <AtomNode start="(202, 25)" end="(202, 26)" leading="" trailing="" val="["/>
                                        <NullNode start="(202, 26)" end="(202, 40)">
                                          <OtherNode start="(202, 26)" end="(202, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(202, 26)" end="(202, 28)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(202, 28)" end="(202, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(202, 30)" end="(202, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(202, 30)" end="(202, 40)" leading="" trailing="" raw_val="foldlM_map" val="foldlM_map" full_name="List.foldlM_map" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(153, 9)" def_end="(153, 19)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(202, 40)" end="(202, 41)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(204, 1)" end="(209, 41)" name="foldrM_attachWith" full_name="List.foldrM_attachWith">
      <CommandDeclmodifiersNode start="(204, 1)" end="(204, 8)">
        <NullNode/>
        <NullNode start="(204, 1)" end="(204, 8)">
          <OtherNode start="(204, 1)" end="(204, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(204, 1)" end="(204, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(204, 3)" end="(204, 7)">
              <OtherNode start="(204, 3)" end="(204, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(204, 3)" end="(204, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(204, 3)" end="(204, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(204, 7)" end="(204, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(204, 9)" end="(209, 41)" name="foldrM_attachWith" full_name="List.foldrM_attachWith" _is_private_decl="False">
        <AtomNode start="(204, 9)" end="(204, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(204, 17)" end="(204, 34)">
          <IdentNode start="(204, 17)" end="(204, 34)" leading="" trailing=" " raw_val="foldrM_attachWith" val="foldrM_attachWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(204, 35)" end="(206, 90)">
          <NullNode start="(204, 35)" end="(205, 87)">
            <OtherNode start="(204, 35)" end="(204, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(204, 35)" end="(204, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(204, 36)" end="(204, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(204, 36)" end="(204, 41)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(204, 42)" end="(204, 43)">
                  <IdentNode start="(204, 42)" end="(204, 43)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(204, 43)" end="(204, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(204, 45)" end="(204, 60)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(204, 45)" end="(204, 46)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(204, 46)" end="(204, 59)" kind="Lean.Parser.Term.app">
                <IdentNode start="(204, 46)" end="(204, 57)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(204, 58)" end="(204, 59)">
                  <IdentNode start="(204, 58)" end="(204, 59)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(204, 59)" end="(204, 60)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(205, 5)" end="(205, 17)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(205, 5)" end="(205, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(205, 6)" end="(205, 7)">
                <IdentNode start="(205, 6)" end="(205, 7)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(205, 8)" end="(205, 16)">
                <AtomNode start="(205, 8)" end="(205, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(205, 10)" end="(205, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(205, 10)" end="(205, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(205, 15)" end="(205, 16)">
                    <IdentNode start="(205, 15)" end="(205, 16)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(205, 16)" end="(205, 17)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(205, 18)" end="(205, 32)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(205, 18)" end="(205, 19)" leading="" trailing="" val="{"/>
              <NullNode start="(205, 19)" end="(205, 20)">
                <IdentNode start="(205, 19)" end="(205, 20)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(205, 21)" end="(205, 31)">
                <AtomNode start="(205, 21)" end="(205, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(205, 23)" end="(205, 31)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(205, 23)" end="(205, 24)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(205, 25)" end="(205, 26)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(205, 27)" end="(205, 31)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(205, 27)" end="(205, 31)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(205, 31)" end="(205, 32)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(205, 33)" end="(205, 55)">
              <AtomNode start="(205, 33)" end="(205, 34)" leading="" trailing="" val="("/>
              <NullNode start="(205, 34)" end="(205, 35)">
                <IdentNode start="(205, 34)" end="(205, 35)" leading="" trailing=" " raw_val="H" val="H"/>
              </NullNode>
              <NullNode start="(205, 36)" end="(205, 54)">
                <AtomNode start="(205, 36)" end="(205, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(205, 38)" end="(205, 54)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(205, 38)" end="(205, 39)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(205, 40)" end="(205, 41)">
                    <IdentNode start="(205, 40)" end="(205, 41)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(205, 41)" end="(205, 42)" leading="" trailing=" " val=","/>
                  <OtherNode start="(205, 43)" end="(205, 54)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(205, 43)" end="(205, 48)" kind="«term_∈_»">
                      <IdentNode start="(205, 43)" end="(205, 44)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(205, 45)" end="(205, 46)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(205, 47)" end="(205, 48)" leading="" trailing=" " raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(205, 49)" end="(205, 50)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(205, 51)" end="(205, 54)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(205, 51)" end="(205, 52)" leading="" trailing=" " raw_val="q" val="q"/>
                      <NullNode start="(205, 53)" end="(205, 54)">
                        <IdentNode start="(205, 53)" end="(205, 54)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(205, 54)" end="(205, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(205, 56)" end="(205, 83)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(205, 56)" end="(205, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(205, 57)" end="(205, 58)">
                <IdentNode start="(205, 57)" end="(205, 58)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(205, 59)" end="(205, 82)">
                <AtomNode start="(205, 59)" end="(205, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(205, 61)" end="(205, 82)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(205, 61)" end="(205, 72)" kind="«term{_:_//_}»">
                    <AtomNode start="(205, 61)" end="(205, 62)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(205, 63)" end="(205, 64)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(205, 65)" end="(205, 67)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(205, 68)" end="(205, 71)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(205, 68)" end="(205, 69)" leading="" trailing=" " raw_val="q" val="q"/>
                      <NullNode start="(205, 70)" end="(205, 71)">
                        <IdentNode start="(205, 70)" end="(205, 71)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(205, 71)" end="(205, 72)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(205, 73)" end="(205, 74)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(205, 75)" end="(205, 82)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(205, 75)" end="(205, 76)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(205, 77)" end="(205, 78)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(205, 79)" end="(205, 82)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(205, 79)" end="(205, 80)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(205, 81)" end="(205, 82)">
                        <IdentNode start="(205, 81)" end="(205, 82)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(205, 82)" end="(205, 83)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(205, 84)" end="(205, 87)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(205, 84)" end="(205, 85)" leading="" trailing="" val="{"/>
              <NullNode start="(205, 85)" end="(205, 86)">
                <IdentNode start="(205, 85)" end="(205, 86)" leading="" trailing="" raw_val="b" val="b"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(205, 86)" end="(205, 87)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(205, 88)" end="(206, 90)">
            <AtomNode start="(205, 88)" end="(205, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(206, 5)" end="(206, 90)" kind="«term_=_»">
              <OtherNode start="(206, 5)" end="(206, 34)" kind="Lean.Parser.Term.app">
                <OtherNode start="(206, 5)" end="(206, 30)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(206, 5)" end="(206, 23)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(206, 5)" end="(206, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(206, 6)" end="(206, 22)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(206, 6)" end="(206, 18)" leading="" trailing=" " raw_val="l.attachWith" val="l.attachWith"/>
                      <NullNode start="(206, 19)" end="(206, 22)">
                        <IdentNode start="(206, 19)" end="(206, 20)" leading="" trailing=" " raw_val="q" val="q"/>
                        <IdentNode start="(206, 21)" end="(206, 22)" leading="" trailing="" raw_val="H" val="H"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(206, 22)" end="(206, 23)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(206, 23)" end="(206, 24)" leading="" trailing="" val="."/>
                  <IdentNode start="(206, 24)" end="(206, 30)" leading="" trailing=" " raw_val="foldrM" val="foldrM" full_name="List.foldrM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(206, 31)" end="(206, 34)">
                  <IdentNode start="(206, 31)" end="(206, 32)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(206, 33)" end="(206, 34)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(206, 35)" end="(206, 36)" leading="" trailing=" " val="="/>
              <OtherNode start="(206, 37)" end="(206, 90)" kind="Lean.Parser.Term.app">
                <IdentNode start="(206, 37)" end="(206, 52)" leading="" trailing=" " raw_val="l.attach.foldrM" val="l.attach.foldrM"/>
                <NullNode start="(206, 53)" end="(206, 90)">
                  <OtherNode start="(206, 53)" end="(206, 88)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(206, 53)" end="(206, 54)" leading="" trailing="" val="("/>
                    <OtherNode start="(206, 54)" end="(206, 87)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(206, 54)" end="(206, 57)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(206, 58)" end="(206, 87)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(206, 58)" end="(206, 63)">
                          <IdentNode start="(206, 58)" end="(206, 59)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(206, 60)" end="(206, 63)" leading="" trailing=" " raw_val="acc" val="acc"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(206, 64)" end="(206, 66)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(206, 67)" end="(206, 87)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(206, 67)" end="(206, 68)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(206, 69)" end="(206, 87)">
                            <OtherNode start="(206, 69)" end="(206, 83)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(206, 69)" end="(206, 70)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(206, 70)" end="(206, 82)">
                                <OtherNode start="(206, 70)" end="(206, 73)" kind="Lean.Parser.Term.proj">
                                  <IdentNode start="(206, 70)" end="(206, 71)" leading="" trailing="" raw_val="a" val="a"/>
                                  <AtomNode start="(206, 71)" end="(206, 72)" leading="" trailing="" val="."/>
                                  <OtherNode start="(206, 72)" end="(206, 73)" kind="fieldIdx">
                                    <AtomNode start="(206, 72)" end="(206, 73)" leading="" trailing="" val="1"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(206, 73)" end="(206, 74)" leading="" trailing=" " val=","/>
                                <OtherNode start="(206, 75)" end="(206, 82)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(206, 75)" end="(206, 76)" leading="" trailing=" " raw_val="H" val="H"/>
                                  <NullNode start="(206, 77)" end="(206, 82)">
                                    <TermHoleNode start="(206, 77)" end="(206, 78)">
                                      <AtomNode start="(206, 77)" end="(206, 78)" leading="" trailing=" " val="_"/>
                                    </TermHoleNode>
                                    <OtherNode start="(206, 79)" end="(206, 82)" kind="Lean.Parser.Term.proj">
                                      <IdentNode start="(206, 79)" end="(206, 80)" leading="" trailing="" raw_val="a" val="a"/>
                                      <AtomNode start="(206, 80)" end="(206, 81)" leading="" trailing="" val="."/>
                                      <OtherNode start="(206, 81)" end="(206, 82)" kind="fieldIdx">
                                        <AtomNode start="(206, 81)" end="(206, 82)" leading="" trailing="" val="2"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(206, 82)" end="(206, 83)" leading="" trailing=" " val="⟩"/>
                            </OtherNode>
                            <IdentNode start="(206, 84)" end="(206, 87)" leading="" trailing="" raw_val="acc" val="acc"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(206, 87)" end="(206, 88)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(206, 89)" end="(206, 90)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(206, 91)" end="(209, 41)">
          <AtomNode start="(206, 91)" end="(206, 93)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(206, 94)" end="(209, 41)">
            <AtomNode start="(206, 94)" end="(206, 96)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(207, 3)" end="(209, 41)">
              <TacticTacticseq1IndentedNode start="(207, 3)" end="(209, 41)">
                <NullNode start="(207, 3)" end="(209, 41)">
                  <OtherNode start="(207, 3)" end="(209, 41)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;q : α → Prop&#10;H : ∀ (a : α), a ∈ l → q a&#10;f : { x // q x } → β → m β&#10;b : β&#10;⊢ foldrM f b (l.attachWith q H) = foldrM (fun a acc =&amp;gt; f ⟨a.val, ⋯⟩ acc) b l.attach" state_after="no goals" tactic="induction l generalizing b with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt; simp [ih, foldrM_map]">
                    <AtomNode start="(207, 3)" end="(207, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(207, 13)" end="(207, 14)">
                      <OtherNode start="(207, 13)" end="(207, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(207, 13)" end="(207, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(207, 15)" end="(207, 29)">
                      <AtomNode start="(207, 15)" end="(207, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(207, 28)" end="(207, 29)">
                        <IdentNode start="(207, 28)" end="(207, 29)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(207, 30)" end="(209, 41)">
                      <OtherNode start="(207, 30)" end="(209, 41)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(207, 30)" end="(207, 34)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(208, 3)" end="(209, 41)">
                          <OtherNode start="(208, 3)" end="(208, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(208, 3)" end="(208, 8)">
                              <OtherNode start="(208, 3)" end="(208, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(208, 3)" end="(208, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(208, 5)" end="(208, 8)">
                                  <NullNode/>
                                  <IdentNode start="(208, 5)" end="(208, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(208, 9)" end="(208, 16)">
                              <AtomNode start="(208, 9)" end="(208, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(208, 12)" end="(208, 16)">
                                <TacticTacticseq1IndentedNode start="(208, 12)" end="(208, 16)">
                                  <NullNode start="(208, 12)" end="(208, 16)">
                                    <OtherNode start="(208, 12)" end="(208, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;q : α → Prop&#10;f : { x // q x } → β → m β&#10;H : ∀ (a : α), a ∈ [] → q a&#10;b : β&#10;⊢ foldrM f b ([].attachWith q H) = foldrM (fun a acc =&amp;gt; f ⟨a.val, ⋯⟩ acc) b [].attach" state_after="no goals" tactic="simp">
                                      <AtomNode start="(208, 12)" end="(208, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(209, 3)" end="(209, 41)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(209, 3)" end="(209, 16)">
                              <OtherNode start="(209, 3)" end="(209, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(209, 3)" end="(209, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(209, 5)" end="(209, 9)">
                                  <NullNode/>
                                  <IdentNode start="(209, 5)" end="(209, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(209, 10)" end="(209, 16)">
                                  <IdentNode start="(209, 10)" end="(209, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(209, 12)" end="(209, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(209, 14)" end="(209, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(209, 17)" end="(209, 41)">
                              <AtomNode start="(209, 17)" end="(209, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(209, 20)" end="(209, 41)">
                                <TacticTacticseq1IndentedNode start="(209, 20)" end="(209, 41)">
                                  <NullNode start="(209, 20)" end="(209, 41)">
                                    <OtherNode start="(209, 20)" end="(209, 41)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;q : α → Prop&#10;f : { x // q x } → β → m β&#10;a : α&#10;l : List α&#10;ih :&#10;  ∀ (H : ∀ (a : α), a ∈ l → q a) {b : β},&#10;    foldrM f b (l.attachWith q H) = foldrM (fun a acc =&amp;gt; f ⟨a.val, ⋯⟩ acc) b l.attach&#10;H : ∀ (a_1 : α), a_1 ∈ a :: l → q a_1&#10;b : β&#10;⊢ foldrM f b ((a :: l).attachWith q H) = foldrM (fun a_1 acc =&amp;gt; f ⟨a_1.val, ⋯⟩ acc) b (a :: l).attach" state_after="no goals" tactic="simp [ih, foldrM_map]">
                                      <AtomNode start="(209, 20)" end="(209, 24)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(209, 25)" end="(209, 41)">
                                        <AtomNode start="(209, 25)" end="(209, 26)" leading="" trailing="" val="["/>
                                        <NullNode start="(209, 26)" end="(209, 40)">
                                          <OtherNode start="(209, 26)" end="(209, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(209, 26)" end="(209, 28)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(209, 28)" end="(209, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(209, 30)" end="(209, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(209, 30)" end="(209, 40)" leading="" trailing="" raw_val="foldrM_map" val="foldrM_map" full_name="List.foldrM_map" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(157, 9)" def_end="(157, 19)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(209, 40)" end="(209, 41)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(211, 1)" end="(211, 16)" comment="### forM -/">
      <AtomNode start="(211, 1)" end="(211, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(211, 5)" end="(211, 16)" leading="" trailing="&#10;&#10;" val="### forM -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(213, 1)" end="(214, 83)" name="forM_nil'" full_name="List.forM_nil'">
      <CommandDeclmodifiersNode start="(213, 1)" end="(213, 47)">
        <NullNode/>
        <NullNode start="(213, 1)" end="(213, 47)">
          <OtherNode start="(213, 1)" end="(213, 47)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(213, 1)" end="(213, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(213, 3)" end="(213, 46)">
              <OtherNode start="(213, 3)" end="(213, 46)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(213, 3)" end="(213, 46)" kind="Lean.deprecated">
                  <AtomNode start="(213, 3)" end="(213, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(213, 14)" end="(213, 22)">
                    <IdentNode start="(213, 14)" end="(213, 22)" leading="" trailing=" " raw_val="forM_nil" val="forM_nil" full_name="List.forM_nil" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(213, 23)" end="(213, 46)">
                    <AtomNode start="(213, 23)" end="(213, 24)" leading="" trailing="" val="("/>
                    <AtomNode start="(213, 24)" end="(213, 29)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(213, 30)" end="(213, 32)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(213, 33)" end="(213, 45)" kind="str">
                      <AtomNode start="(213, 33)" end="(213, 45)" leading="" trailing="" val="&amp;quot;2025-01-31&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(213, 45)" end="(213, 46)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(213, 46)" end="(213, 47)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(214, 1)" end="(214, 83)" name="forM_nil'" full_name="List.forM_nil'" _is_private_decl="False">
        <AtomNode start="(214, 1)" end="(214, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(214, 9)" end="(214, 18)">
          <IdentNode start="(214, 9)" end="(214, 18)" leading="" trailing=" " raw_val="forM_nil'" val="forM_nil'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(214, 19)" end="(214, 76)">
          <NullNode start="(214, 19)" end="(214, 28)">
            <OtherNode start="(214, 19)" end="(214, 28)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(214, 19)" end="(214, 20)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(214, 20)" end="(214, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(214, 20)" end="(214, 25)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(214, 26)" end="(214, 27)">
                  <IdentNode start="(214, 26)" end="(214, 27)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(214, 27)" end="(214, 28)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(214, 29)" end="(214, 76)">
            <AtomNode start="(214, 29)" end="(214, 30)" leading="" trailing=" " val=":"/>
            <OtherNode start="(214, 31)" end="(214, 76)" kind="«term_=_»">
              <OtherNode start="(214, 31)" end="(214, 51)" kind="Lean.Parser.Term.app">
                <OtherNode start="(214, 31)" end="(214, 49)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(214, 31)" end="(214, 44)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(214, 31)" end="(214, 32)" leading="" trailing="" val="("/>
                    <OtherNode start="(214, 32)" end="(214, 34)" kind="«term[_]»">
                      <AtomNode start="(214, 32)" end="(214, 33)" leading="" trailing="" val="["/>
                      <NullNode/>
                      <AtomNode start="(214, 33)" end="(214, 34)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <AtomNode start="(214, 35)" end="(214, 36)" leading="" trailing=" " val=":"/>
                    <NullNode start="(214, 37)" end="(214, 43)">
                      <OtherNode start="(214, 37)" end="(214, 43)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(214, 37)" end="(214, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(214, 42)" end="(214, 43)">
                          <IdentNode start="(214, 42)" end="(214, 43)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(214, 43)" end="(214, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(214, 44)" end="(214, 45)" leading="" trailing="" val="."/>
                  <IdentNode start="(214, 45)" end="(214, 49)" leading="" trailing=" " raw_val="forM" val="forM" full_name="List.forM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(214, 50)" end="(214, 51)">
                  <IdentNode start="(214, 50)" end="(214, 51)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(214, 52)" end="(214, 53)" leading="" trailing=" " val="="/>
              <OtherNode start="(214, 54)" end="(214, 76)" kind="Lean.Parser.Term.typeAscription">
                <AtomNode start="(214, 54)" end="(214, 55)" leading="" trailing="" val="("/>
                <OtherNode start="(214, 55)" end="(214, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(214, 55)" end="(214, 59)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(214, 60)" end="(214, 65)">
                    <OtherNode start="(214, 60)" end="(214, 65)" kind="Lean.Parser.Term.dotIdent">
                      <AtomNode start="(214, 60)" end="(214, 61)" leading="" trailing="" val="."/>
                      <IdentNode start="(214, 61)" end="(214, 65)" leading="" trailing=" " raw_val="unit" val="unit"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(214, 66)" end="(214, 67)" leading="" trailing=" " val=":"/>
                <NullNode start="(214, 68)" end="(214, 75)">
                  <OtherNode start="(214, 68)" end="(214, 75)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(214, 68)" end="(214, 69)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(214, 70)" end="(214, 75)">
                      <IdentNode start="(214, 70)" end="(214, 75)" leading="" trailing="" raw_val="PUnit" val="PUnit" full_name="PUnit" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(214, 75)" end="(214, 76)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(214, 77)" end="(214, 83)">
          <AtomNode start="(214, 77)" end="(214, 79)" leading="" trailing=" " val=":="/>
          <IdentNode start="(214, 80)" end="(214, 83)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(216, 1)" end="(219, 17)" name="forM_cons'" full_name="List.forM_cons'">
      <CommandDeclmodifiersNode start="(216, 1)" end="(216, 48)">
        <NullNode/>
        <NullNode start="(216, 1)" end="(216, 48)">
          <OtherNode start="(216, 1)" end="(216, 48)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(216, 1)" end="(216, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(216, 3)" end="(216, 47)">
              <OtherNode start="(216, 3)" end="(216, 47)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(216, 3)" end="(216, 47)" kind="Lean.deprecated">
                  <AtomNode start="(216, 3)" end="(216, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(216, 14)" end="(216, 23)">
                    <IdentNode start="(216, 14)" end="(216, 23)" leading="" trailing=" " raw_val="forM_cons" val="forM_cons" full_name="List.forM_cons" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(216, 24)" end="(216, 47)">
                    <AtomNode start="(216, 24)" end="(216, 25)" leading="" trailing="" val="("/>
                    <AtomNode start="(216, 25)" end="(216, 30)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(216, 31)" end="(216, 33)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(216, 34)" end="(216, 46)" kind="str">
                      <AtomNode start="(216, 34)" end="(216, 46)" leading="" trailing="" val="&amp;quot;2025-01-31&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(216, 46)" end="(216, 47)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(216, 47)" end="(216, 48)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(217, 1)" end="(219, 17)" name="forM_cons'" full_name="List.forM_cons'" _is_private_decl="False">
        <AtomNode start="(217, 1)" end="(217, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(217, 9)" end="(217, 19)">
          <IdentNode start="(217, 9)" end="(217, 19)" leading="" trailing=" " raw_val="forM_cons'" val="forM_cons'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(217, 20)" end="(218, 60)">
          <NullNode start="(217, 20)" end="(217, 29)">
            <OtherNode start="(217, 20)" end="(217, 29)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(217, 20)" end="(217, 21)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(217, 21)" end="(217, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(217, 21)" end="(217, 26)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(217, 27)" end="(217, 28)">
                  <IdentNode start="(217, 27)" end="(217, 28)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(217, 28)" end="(217, 29)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(217, 30)" end="(218, 60)">
            <AtomNode start="(217, 30)" end="(217, 31)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(218, 5)" end="(218, 60)" kind="«term_=_»">
              <OtherNode start="(218, 5)" end="(218, 19)" kind="Lean.Parser.Term.app">
                <OtherNode start="(218, 5)" end="(218, 17)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(218, 5)" end="(218, 12)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(218, 5)" end="(218, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(218, 6)" end="(218, 11)" kind="«term_::_»">
                      <IdentNode start="(218, 6)" end="(218, 7)" leading="" trailing="" raw_val="a" val="a"/>
                      <AtomNode start="(218, 7)" end="(218, 9)" leading="" trailing="" val="::"/>
                      <IdentNode start="(218, 9)" end="(218, 11)" leading="" trailing="" raw_val="as" val="as"/>
                    </OtherNode>
                    <AtomNode start="(218, 11)" end="(218, 12)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(218, 12)" end="(218, 13)" leading="" trailing="" val="."/>
                  <IdentNode start="(218, 13)" end="(218, 17)" leading="" trailing=" " raw_val="forM" val="forM" full_name="List.forM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(218, 18)" end="(218, 19)">
                  <IdentNode start="(218, 18)" end="(218, 19)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(218, 20)" end="(218, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(218, 22)" end="(218, 60)" kind="Lean.Parser.Term.typeAscription">
                <AtomNode start="(218, 22)" end="(218, 23)" leading="" trailing="" val="("/>
                <OtherNode start="(218, 23)" end="(218, 49)" kind="«term_&amp;gt;&amp;gt;=_»">
                  <OtherNode start="(218, 23)" end="(218, 26)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(218, 23)" end="(218, 24)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(218, 25)" end="(218, 26)">
                      <IdentNode start="(218, 25)" end="(218, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(218, 27)" end="(218, 30)" leading="" trailing=" " val="&amp;gt;&amp;gt;="/>
                  <OtherNode start="(218, 31)" end="(218, 49)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(218, 31)" end="(218, 34)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(218, 35)" end="(218, 49)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(218, 35)" end="(218, 36)">
                        <TermHoleNode start="(218, 35)" end="(218, 36)">
                          <AtomNode start="(218, 35)" end="(218, 36)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(218, 37)" end="(218, 39)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(218, 40)" end="(218, 49)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(218, 40)" end="(218, 47)" leading="" trailing=" " raw_val="as.forM" val="as.forM"/>
                        <NullNode start="(218, 48)" end="(218, 49)">
                          <IdentNode start="(218, 48)" end="(218, 49)" leading="" trailing=" " raw_val="f" val="f"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(218, 50)" end="(218, 51)" leading="" trailing=" " val=":"/>
                <NullNode start="(218, 52)" end="(218, 59)">
                  <OtherNode start="(218, 52)" end="(218, 59)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(218, 52)" end="(218, 53)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(218, 54)" end="(218, 59)">
                      <IdentNode start="(218, 54)" end="(218, 59)" leading="" trailing="" raw_val="PUnit" val="PUnit" full_name="PUnit" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(218, 59)" end="(218, 60)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(218, 61)" end="(219, 17)">
          <AtomNode start="(218, 61)" end="(218, 63)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(219, 3)" end="(219, 17)" leading="" trailing="&#10;&#10;" raw_val="List.forM_cons" val="List.forM_cons" full_name="List.forM_cons" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(221, 1)" end="(223, 28)" name="forM_append" full_name="List.forM_append">
      <CommandDeclmodifiersNode start="(221, 1)" end="(221, 8)">
        <NullNode/>
        <NullNode start="(221, 1)" end="(221, 8)">
          <OtherNode start="(221, 1)" end="(221, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(221, 1)" end="(221, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(221, 3)" end="(221, 7)">
              <OtherNode start="(221, 3)" end="(221, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(221, 3)" end="(221, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(221, 3)" end="(221, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(221, 7)" end="(221, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(221, 9)" end="(223, 28)" name="forM_append" full_name="List.forM_append" _is_private_decl="False">
        <AtomNode start="(221, 9)" end="(221, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(221, 17)" end="(221, 28)">
          <IdentNode start="(221, 17)" end="(221, 28)" leading="" trailing=" " raw_val="forM_append" val="forM_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(221, 29)" end="(222, 50)">
          <NullNode start="(221, 29)" end="(221, 89)">
            <OtherNode start="(221, 29)" end="(221, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(221, 29)" end="(221, 30)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(221, 30)" end="(221, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(221, 30)" end="(221, 35)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(221, 36)" end="(221, 37)">
                  <IdentNode start="(221, 36)" end="(221, 37)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(221, 37)" end="(221, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(221, 39)" end="(221, 54)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(221, 39)" end="(221, 40)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(221, 40)" end="(221, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(221, 40)" end="(221, 51)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(221, 52)" end="(221, 53)">
                  <IdentNode start="(221, 52)" end="(221, 53)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(221, 53)" end="(221, 54)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(221, 55)" end="(221, 71)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(221, 55)" end="(221, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(221, 56)" end="(221, 61)">
                <IdentNode start="(221, 56)" end="(221, 58)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(221, 59)" end="(221, 61)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(221, 62)" end="(221, 70)">
                <AtomNode start="(221, 62)" end="(221, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(221, 64)" end="(221, 70)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(221, 64)" end="(221, 68)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(221, 69)" end="(221, 70)">
                    <IdentNode start="(221, 69)" end="(221, 70)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(221, 70)" end="(221, 71)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(221, 72)" end="(221, 89)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(221, 72)" end="(221, 73)" leading="" trailing="" val="{"/>
              <NullNode start="(221, 73)" end="(221, 74)">
                <IdentNode start="(221, 73)" end="(221, 74)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(221, 75)" end="(221, 88)">
                <AtomNode start="(221, 75)" end="(221, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(221, 77)" end="(221, 88)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(221, 77)" end="(221, 78)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(221, 79)" end="(221, 80)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(221, 81)" end="(221, 88)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(221, 81)" end="(221, 82)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(221, 83)" end="(221, 88)">
                      <IdentNode start="(221, 83)" end="(221, 88)" leading="" trailing="" raw_val="PUnit" val="PUnit" full_name="PUnit" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(221, 88)" end="(221, 89)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(221, 90)" end="(222, 50)">
            <AtomNode start="(221, 90)" end="(221, 91)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(222, 5)" end="(222, 50)" kind="«term_=_»">
              <OtherNode start="(222, 5)" end="(222, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(222, 5)" end="(222, 9)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <NullNode start="(222, 10)" end="(222, 22)">
                  <OtherNode start="(222, 10)" end="(222, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(222, 10)" end="(222, 11)" leading="" trailing="" val="("/>
                    <OtherNode start="(222, 11)" end="(222, 19)" kind="«term_++_»">
                      <IdentNode start="(222, 11)" end="(222, 13)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(222, 14)" end="(222, 16)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(222, 17)" end="(222, 19)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </OtherNode>
                    <AtomNode start="(222, 19)" end="(222, 20)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(222, 21)" end="(222, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(222, 23)" end="(222, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(222, 25)" end="(222, 50)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(222, 25)" end="(222, 26)" leading="" trailing="" val="("/>
                <OtherNode start="(222, 26)" end="(222, 49)" kind="Lean.Parser.Term.do">
                  <AtomNode start="(222, 26)" end="(222, 28)" leading="" trailing=" " val="do"/>
                  <OtherNode start="(222, 29)" end="(222, 49)" kind="Lean.Parser.Term.doSeqIndent">
                    <NullNode start="(222, 29)" end="(222, 49)">
                      <OtherNode start="(222, 29)" end="(222, 39)" kind="Lean.Parser.Term.doSeqItem">
                        <OtherNode start="(222, 29)" end="(222, 38)" kind="Lean.Parser.Term.doExpr">
                          <OtherNode start="(222, 29)" end="(222, 38)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(222, 29)" end="(222, 33)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                            <NullNode start="(222, 34)" end="(222, 38)">
                              <IdentNode start="(222, 34)" end="(222, 36)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                              <IdentNode start="(222, 37)" end="(222, 38)" leading="" trailing="" raw_val="f" val="f"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <NullNode start="(222, 38)" end="(222, 39)">
                          <AtomNode start="(222, 38)" end="(222, 39)" leading="" trailing=" " val=";"/>
                        </NullNode>
                      </OtherNode>
                      <OtherNode start="(222, 40)" end="(222, 49)" kind="Lean.Parser.Term.doSeqItem">
                        <OtherNode start="(222, 40)" end="(222, 49)" kind="Lean.Parser.Term.doExpr">
                          <OtherNode start="(222, 40)" end="(222, 49)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(222, 40)" end="(222, 44)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                            <NullNode start="(222, 45)" end="(222, 49)">
                              <IdentNode start="(222, 45)" end="(222, 47)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                              <IdentNode start="(222, 48)" end="(222, 49)" leading="" trailing="" raw_val="f" val="f"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(222, 49)" end="(222, 50)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(222, 51)" end="(223, 28)">
          <AtomNode start="(222, 51)" end="(222, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(222, 54)" end="(223, 28)">
            <AtomNode start="(222, 54)" end="(222, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(223, 3)" end="(223, 28)">
              <TacticTacticseq1IndentedNode start="(223, 3)" end="(223, 28)">
                <NullNode start="(223, 3)" end="(223, 28)">
                  <OtherNode start="(223, 3)" end="(223, 28)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l₁ l₂ : List α&#10;f : α → m PUnit&#10;⊢ forM (l₁ ++ l₂) f = do&#10;    forM l₁ f&#10;    forM l₂ f" state_after="no goals" tactic="induction l₁ &amp;lt;;&amp;gt; simp [*]">
                    <OtherNode start="(223, 3)" end="(223, 15)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(223, 3)" end="(223, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(223, 13)" end="(223, 15)">
                        <OtherNode start="(223, 13)" end="(223, 15)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(223, 13)" end="(223, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(223, 16)" end="(223, 19)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(223, 20)" end="(223, 28)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(223, 20)" end="(223, 24)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(223, 25)" end="(223, 28)">
                        <AtomNode start="(223, 25)" end="(223, 26)" leading="" trailing="" val="["/>
                        <NullNode start="(223, 26)" end="(223, 27)">
                          <OtherNode start="(223, 26)" end="(223, 27)" kind="Lean.Parser.Tactic.simpStar">
                            <AtomNode start="(223, 26)" end="(223, 27)" leading="" trailing="" val="*"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(223, 27)" end="(223, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(225, 1)" end="(227, 27)" name="forM_map" full_name="List.forM_map">
      <CommandDeclmodifiersNode start="(225, 1)" end="(225, 8)">
        <NullNode/>
        <NullNode start="(225, 1)" end="(225, 8)">
          <OtherNode start="(225, 1)" end="(225, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(225, 1)" end="(225, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(225, 3)" end="(225, 7)">
              <OtherNode start="(225, 3)" end="(225, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(225, 3)" end="(225, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(225, 3)" end="(225, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(225, 7)" end="(225, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(225, 9)" end="(227, 27)" name="forM_map" full_name="List.forM_map" _is_private_decl="False">
        <AtomNode start="(225, 9)" end="(225, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(225, 17)" end="(225, 25)">
          <IdentNode start="(225, 17)" end="(225, 25)" leading="" trailing=" " raw_val="forM_map" val="forM_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(225, 26)" end="(226, 49)">
          <NullNode start="(225, 26)" end="(225, 94)">
            <OtherNode start="(225, 26)" end="(225, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(225, 26)" end="(225, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(225, 27)" end="(225, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(225, 27)" end="(225, 32)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(225, 33)" end="(225, 34)">
                  <IdentNode start="(225, 33)" end="(225, 34)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(225, 34)" end="(225, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(225, 36)" end="(225, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(225, 36)" end="(225, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(225, 37)" end="(225, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(225, 37)" end="(225, 48)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(225, 49)" end="(225, 50)">
                  <IdentNode start="(225, 49)" end="(225, 50)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(225, 50)" end="(225, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(225, 52)" end="(225, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(225, 52)" end="(225, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(225, 53)" end="(225, 54)">
                <IdentNode start="(225, 53)" end="(225, 54)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(225, 55)" end="(225, 63)">
                <AtomNode start="(225, 55)" end="(225, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(225, 57)" end="(225, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(225, 57)" end="(225, 61)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(225, 62)" end="(225, 63)">
                    <IdentNode start="(225, 62)" end="(225, 63)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(225, 63)" end="(225, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(225, 65)" end="(225, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(225, 65)" end="(225, 66)" leading="" trailing="" val="{"/>
              <NullNode start="(225, 66)" end="(225, 67)">
                <IdentNode start="(225, 66)" end="(225, 67)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(225, 68)" end="(225, 75)">
                <AtomNode start="(225, 68)" end="(225, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(225, 70)" end="(225, 75)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(225, 70)" end="(225, 71)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(225, 72)" end="(225, 73)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(225, 74)" end="(225, 75)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(225, 75)" end="(225, 76)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(225, 77)" end="(225, 94)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(225, 77)" end="(225, 78)" leading="" trailing="" val="{"/>
              <NullNode start="(225, 78)" end="(225, 79)">
                <IdentNode start="(225, 78)" end="(225, 79)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(225, 80)" end="(225, 93)">
                <AtomNode start="(225, 80)" end="(225, 81)" leading="" trailing=" " val=":"/>
                <OtherNode start="(225, 82)" end="(225, 93)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(225, 82)" end="(225, 83)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(225, 84)" end="(225, 85)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(225, 86)" end="(225, 93)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(225, 86)" end="(225, 87)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(225, 88)" end="(225, 93)">
                      <IdentNode start="(225, 88)" end="(225, 93)" leading="" trailing="" raw_val="PUnit" val="PUnit" full_name="PUnit" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(225, 93)" end="(225, 94)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(225, 95)" end="(226, 49)">
            <AtomNode start="(225, 95)" end="(225, 96)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(226, 5)" end="(226, 49)" kind="«term_=_»">
              <OtherNode start="(226, 5)" end="(226, 21)" kind="Lean.Parser.Term.app">
                <IdentNode start="(226, 5)" end="(226, 9)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <NullNode start="(226, 10)" end="(226, 21)">
                  <OtherNode start="(226, 10)" end="(226, 19)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(226, 10)" end="(226, 11)" leading="" trailing="" val="("/>
                    <OtherNode start="(226, 11)" end="(226, 18)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(226, 11)" end="(226, 16)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                      <NullNode start="(226, 17)" end="(226, 18)">
                        <IdentNode start="(226, 17)" end="(226, 18)" leading="" trailing="" raw_val="g" val="g"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(226, 18)" end="(226, 19)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(226, 20)" end="(226, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(226, 22)" end="(226, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(226, 24)" end="(226, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(226, 24)" end="(226, 28)" leading="" trailing=" " raw_val="forM" val="forM" full_name="ForM.forM" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <NullNode start="(226, 29)" end="(226, 49)">
                  <IdentNode start="(226, 29)" end="(226, 30)" leading="" trailing=" " raw_val="l" val="l"/>
                  <OtherNode start="(226, 31)" end="(226, 49)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(226, 31)" end="(226, 32)" leading="" trailing="" val="("/>
                    <OtherNode start="(226, 32)" end="(226, 48)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(226, 32)" end="(226, 35)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(226, 36)" end="(226, 48)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(226, 36)" end="(226, 37)">
                          <IdentNode start="(226, 36)" end="(226, 37)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(226, 38)" end="(226, 40)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(226, 41)" end="(226, 48)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(226, 41)" end="(226, 42)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(226, 43)" end="(226, 48)">
                            <OtherNode start="(226, 43)" end="(226, 48)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(226, 43)" end="(226, 44)" leading="" trailing="" val="("/>
                              <OtherNode start="(226, 44)" end="(226, 47)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(226, 44)" end="(226, 45)" leading="" trailing=" " raw_val="g" val="g"/>
                                <NullNode start="(226, 46)" end="(226, 47)">
                                  <IdentNode start="(226, 46)" end="(226, 47)" leading="" trailing="" raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(226, 47)" end="(226, 48)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(226, 48)" end="(226, 49)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(226, 50)" end="(227, 27)">
          <AtomNode start="(226, 50)" end="(226, 52)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(226, 53)" end="(227, 27)">
            <AtomNode start="(226, 53)" end="(226, 55)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(227, 3)" end="(227, 27)">
              <TacticTacticseq1IndentedNode start="(227, 3)" end="(227, 27)">
                <NullNode start="(227, 3)" end="(227, 27)">
                  <OtherNode start="(227, 3)" end="(227, 27)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;g : α → β&#10;f : β → m PUnit&#10;⊢ forM (map g l) f = forM l fun a =&amp;gt; f (g a)" state_after="no goals" tactic="induction l &amp;lt;;&amp;gt; simp [*]">
                    <OtherNode start="(227, 3)" end="(227, 14)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(227, 3)" end="(227, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(227, 13)" end="(227, 14)">
                        <OtherNode start="(227, 13)" end="(227, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(227, 13)" end="(227, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(227, 15)" end="(227, 18)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(227, 19)" end="(227, 27)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(227, 19)" end="(227, 23)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(227, 24)" end="(227, 27)">
                        <AtomNode start="(227, 24)" end="(227, 25)" leading="" trailing="" val="["/>
                        <NullNode start="(227, 25)" end="(227, 26)">
                          <OtherNode start="(227, 25)" end="(227, 26)" kind="Lean.Parser.Tactic.simpStar">
                            <AtomNode start="(227, 25)" end="(227, 26)" leading="" trailing="" val="*"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(227, 26)" end="(227, 27)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(229, 1)" end="(229, 18)" comment="### forIn' -/">
      <AtomNode start="(229, 1)" end="(229, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(229, 5)" end="(229, 18)" leading="" trailing="&#10;&#10;" val="### forIn' -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(231, 1)" end="(246, 16)" name="forIn'_loop_congr" full_name="List.forIn'_loop_congr">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(231, 1)" end="(246, 16)" name="forIn'_loop_congr" full_name="List.forIn'_loop_congr" _is_private_decl="False">
        <AtomNode start="(231, 1)" end="(231, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(231, 9)" end="(231, 26)">
          <IdentNode start="(231, 9)" end="(231, 26)" leading="" trailing=" " raw_val="forIn'_loop_congr" val="forIn'_loop_congr"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(231, 27)" end="(235, 95)">
          <NullNode start="(231, 27)" end="(235, 41)">
            <OtherNode start="(231, 27)" end="(231, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(231, 27)" end="(231, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(231, 28)" end="(231, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(231, 28)" end="(231, 33)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(231, 34)" end="(231, 35)">
                  <IdentNode start="(231, 34)" end="(231, 35)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(231, 35)" end="(231, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(231, 37)" end="(231, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(231, 37)" end="(231, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(231, 38)" end="(231, 43)">
                <IdentNode start="(231, 38)" end="(231, 40)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(231, 41)" end="(231, 43)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(231, 44)" end="(231, 52)">
                <AtomNode start="(231, 44)" end="(231, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(231, 46)" end="(231, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(231, 46)" end="(231, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(231, 51)" end="(231, 52)">
                    <IdentNode start="(231, 51)" end="(231, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(231, 52)" end="(231, 53)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(232, 5)" end="(232, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(232, 5)" end="(232, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(232, 6)" end="(232, 7)">
                <IdentNode start="(232, 6)" end="(232, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(232, 8)" end="(232, 50)">
                <AtomNode start="(232, 8)" end="(232, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(232, 10)" end="(232, 50)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(232, 10)" end="(232, 18)">
                    <AtomNode start="(232, 10)" end="(232, 11)" leading="" trailing="" val="("/>
                    <NullNode start="(232, 11)" end="(232, 13)">
                      <IdentNode start="(232, 11)" end="(232, 13)" leading="" trailing=" " raw_val="a'" val="a'"/>
                    </NullNode>
                    <NullNode start="(232, 14)" end="(232, 17)">
                      <AtomNode start="(232, 14)" end="(232, 15)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(232, 16)" end="(232, 17)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(232, 17)" end="(232, 18)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(232, 19)" end="(232, 20)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(232, 21)" end="(232, 50)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(232, 21)" end="(232, 28)" kind="«term_∈_»">
                      <IdentNode start="(232, 21)" end="(232, 23)" leading="" trailing=" " raw_val="a'" val="a'"/>
                      <AtomNode start="(232, 24)" end="(232, 25)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(232, 26)" end="(232, 28)" leading="" trailing=" " raw_val="as" val="as"/>
                    </OtherNode>
                    <AtomNode start="(232, 29)" end="(232, 30)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(232, 31)" end="(232, 50)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(232, 31)" end="(232, 32)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(232, 33)" end="(232, 34)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(232, 35)" end="(232, 50)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(232, 35)" end="(232, 36)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(232, 37)" end="(232, 50)">
                          <OtherNode start="(232, 37)" end="(232, 50)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(232, 37)" end="(232, 38)" leading="" trailing="" val="("/>
                            <OtherNode start="(232, 38)" end="(232, 49)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(232, 38)" end="(232, 47)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(232, 48)" end="(232, 49)">
                                <IdentNode start="(232, 48)" end="(232, 49)" leading="" trailing="" raw_val="β" val="β"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(232, 49)" end="(232, 50)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(232, 50)" end="(232, 51)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(233, 5)" end="(233, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(233, 5)" end="(233, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(233, 6)" end="(233, 7)">
                <IdentNode start="(233, 6)" end="(233, 7)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(233, 8)" end="(233, 50)">
                <AtomNode start="(233, 8)" end="(233, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(233, 10)" end="(233, 50)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(233, 10)" end="(233, 18)">
                    <AtomNode start="(233, 10)" end="(233, 11)" leading="" trailing="" val="("/>
                    <NullNode start="(233, 11)" end="(233, 13)">
                      <IdentNode start="(233, 11)" end="(233, 13)" leading="" trailing=" " raw_val="a'" val="a'"/>
                    </NullNode>
                    <NullNode start="(233, 14)" end="(233, 17)">
                      <AtomNode start="(233, 14)" end="(233, 15)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(233, 16)" end="(233, 17)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(233, 17)" end="(233, 18)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(233, 19)" end="(233, 20)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(233, 21)" end="(233, 50)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(233, 21)" end="(233, 28)" kind="«term_∈_»">
                      <IdentNode start="(233, 21)" end="(233, 23)" leading="" trailing=" " raw_val="a'" val="a'"/>
                      <AtomNode start="(233, 24)" end="(233, 25)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(233, 26)" end="(233, 28)" leading="" trailing=" " raw_val="bs" val="bs"/>
                    </OtherNode>
                    <AtomNode start="(233, 29)" end="(233, 30)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(233, 31)" end="(233, 50)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(233, 31)" end="(233, 32)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(233, 33)" end="(233, 34)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(233, 35)" end="(233, 50)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(233, 35)" end="(233, 36)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(233, 37)" end="(233, 50)">
                          <OtherNode start="(233, 37)" end="(233, 50)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(233, 37)" end="(233, 38)" leading="" trailing="" val="("/>
                            <OtherNode start="(233, 38)" end="(233, 49)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(233, 38)" end="(233, 47)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(233, 48)" end="(233, 49)">
                                <IdentNode start="(233, 48)" end="(233, 49)" leading="" trailing="" raw_val="β" val="β"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(233, 49)" end="(233, 50)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(233, 50)" end="(233, 51)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(234, 5)" end="(234, 12)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(234, 5)" end="(234, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(234, 6)" end="(234, 7)">
                <IdentNode start="(234, 6)" end="(234, 7)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(234, 8)" end="(234, 11)">
                <AtomNode start="(234, 8)" end="(234, 9)" leading="" trailing=" " val=":"/>
                <IdentNode start="(234, 10)" end="(234, 11)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(234, 11)" end="(234, 12)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(234, 13)" end="(234, 39)">
              <AtomNode start="(234, 13)" end="(234, 14)" leading="" trailing="" val="("/>
              <NullNode start="(234, 14)" end="(234, 16)">
                <IdentNode start="(234, 14)" end="(234, 16)" leading="" trailing=" " raw_val="ha" val="ha"/>
              </NullNode>
              <NullNode start="(234, 17)" end="(234, 38)">
                <AtomNode start="(234, 17)" end="(234, 18)" leading="" trailing=" " val=":"/>
                <OtherNode start="(234, 19)" end="(234, 38)" kind="«term∃_,_»">
                  <AtomNode start="(234, 19)" end="(234, 20)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(234, 21)" end="(234, 23)" kind="Lean.explicitBinders">
                    <OtherNode start="(234, 21)" end="(234, 23)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(234, 21)" end="(234, 23)">
                        <LeanBinderidentNode start="(234, 21)" end="(234, 23)">
                          <IdentNode start="(234, 21)" end="(234, 23)" leading="" trailing="" raw_val="ys" val="ys"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(234, 23)" end="(234, 24)" leading="" trailing=" " val=","/>
                  <OtherNode start="(234, 25)" end="(234, 38)" kind="«term_=_»">
                    <OtherNode start="(234, 25)" end="(234, 33)" kind="«term_++_»">
                      <IdentNode start="(234, 25)" end="(234, 27)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      <AtomNode start="(234, 28)" end="(234, 30)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(234, 31)" end="(234, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(234, 34)" end="(234, 35)" leading="" trailing=" " val="="/>
                    <IdentNode start="(234, 36)" end="(234, 38)" leading="" trailing="" raw_val="as" val="as"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(234, 38)" end="(234, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(234, 40)" end="(234, 66)">
              <AtomNode start="(234, 40)" end="(234, 41)" leading="" trailing="" val="("/>
              <NullNode start="(234, 41)" end="(234, 43)">
                <IdentNode start="(234, 41)" end="(234, 43)" leading="" trailing=" " raw_val="hb" val="hb"/>
              </NullNode>
              <NullNode start="(234, 44)" end="(234, 65)">
                <AtomNode start="(234, 44)" end="(234, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(234, 46)" end="(234, 65)" kind="«term∃_,_»">
                  <AtomNode start="(234, 46)" end="(234, 47)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(234, 48)" end="(234, 50)" kind="Lean.explicitBinders">
                    <OtherNode start="(234, 48)" end="(234, 50)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(234, 48)" end="(234, 50)">
                        <LeanBinderidentNode start="(234, 48)" end="(234, 50)">
                          <IdentNode start="(234, 48)" end="(234, 50)" leading="" trailing="" raw_val="ys" val="ys"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(234, 50)" end="(234, 51)" leading="" trailing=" " val=","/>
                  <OtherNode start="(234, 52)" end="(234, 65)" kind="«term_=_»">
                    <OtherNode start="(234, 52)" end="(234, 60)" kind="«term_++_»">
                      <IdentNode start="(234, 52)" end="(234, 54)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      <AtomNode start="(234, 55)" end="(234, 57)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(234, 58)" end="(234, 60)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(234, 61)" end="(234, 62)" leading="" trailing=" " val="="/>
                    <IdentNode start="(234, 63)" end="(234, 65)" leading="" trailing="" raw_val="bs" val="bs"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(234, 65)" end="(234, 66)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(235, 5)" end="(235, 41)">
              <AtomNode start="(235, 5)" end="(235, 6)" leading="" trailing="" val="("/>
              <NullNode start="(235, 6)" end="(235, 7)">
                <IdentNode start="(235, 6)" end="(235, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(235, 8)" end="(235, 40)">
                <AtomNode start="(235, 8)" end="(235, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(235, 10)" end="(235, 40)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(235, 10)" end="(235, 11)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(235, 12)" end="(235, 20)">
                    <IdentNode start="(235, 12)" end="(235, 13)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(235, 14)" end="(235, 15)" leading="" trailing=" " raw_val="m" val="m"/>
                    <IdentNode start="(235, 16)" end="(235, 18)" leading="" trailing=" " raw_val="m'" val="m'"/>
                    <IdentNode start="(235, 19)" end="(235, 20)" leading="" trailing="" raw_val="b" val="b"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(235, 20)" end="(235, 21)" leading="" trailing=" " val=","/>
                  <OtherNode start="(235, 22)" end="(235, 40)" kind="«term_=_»">
                    <OtherNode start="(235, 22)" end="(235, 29)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(235, 22)" end="(235, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(235, 24)" end="(235, 29)">
                        <IdentNode start="(235, 24)" end="(235, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(235, 26)" end="(235, 27)" leading="" trailing=" " raw_val="m" val="m"/>
                        <IdentNode start="(235, 28)" end="(235, 29)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(235, 30)" end="(235, 31)" leading="" trailing=" " val="="/>
                    <OtherNode start="(235, 32)" end="(235, 40)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(235, 32)" end="(235, 33)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(235, 34)" end="(235, 40)">
                        <IdentNode start="(235, 34)" end="(235, 35)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(235, 36)" end="(235, 38)" leading="" trailing=" " raw_val="m'" val="m'"/>
                        <IdentNode start="(235, 39)" end="(235, 40)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(235, 40)" end="(235, 41)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(235, 42)" end="(235, 95)">
            <AtomNode start="(235, 42)" end="(235, 43)" leading="" trailing=" " val=":"/>
            <OtherNode start="(235, 44)" end="(235, 95)" kind="«term_=_»">
              <OtherNode start="(235, 44)" end="(235, 68)" kind="Lean.Parser.Term.app">
                <IdentNode start="(235, 44)" end="(235, 55)" leading="" trailing=" " raw_val="forIn'.loop" val="forIn'.loop" full_name="List.forIn'.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                <NullNode start="(235, 56)" end="(235, 68)">
                  <IdentNode start="(235, 56)" end="(235, 58)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(235, 59)" end="(235, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(235, 61)" end="(235, 63)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(235, 64)" end="(235, 65)" leading="" trailing=" " raw_val="b" val="b"/>
                  <IdentNode start="(235, 66)" end="(235, 68)" leading="" trailing=" " raw_val="ha" val="ha"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(235, 69)" end="(235, 70)" leading="" trailing=" " val="="/>
              <OtherNode start="(235, 71)" end="(235, 95)" kind="Lean.Parser.Term.app">
                <IdentNode start="(235, 71)" end="(235, 82)" leading="" trailing=" " raw_val="forIn'.loop" val="forIn'.loop" full_name="List.forIn'.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                <NullNode start="(235, 83)" end="(235, 95)">
                  <IdentNode start="(235, 83)" end="(235, 85)" leading="" trailing=" " raw_val="bs" val="bs"/>
                  <IdentNode start="(235, 86)" end="(235, 87)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(235, 88)" end="(235, 90)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(235, 91)" end="(235, 92)" leading="" trailing=" " raw_val="b" val="b"/>
                  <IdentNode start="(235, 93)" end="(235, 95)" leading="" trailing="  " raw_val="hb" val="hb"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(235, 97)" end="(246, 16)">
          <AtomNode start="(235, 97)" end="(235, 99)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(235, 100)" end="(246, 16)">
            <AtomNode start="(235, 100)" end="(235, 102)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(236, 3)" end="(246, 16)">
              <TacticTacticseq1IndentedNode start="(236, 3)" end="(246, 16)">
                <NullNode start="(236, 3)" end="(246, 16)">
                  <OtherNode start="(236, 3)" end="(246, 16)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;xs : List α&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;b : β&#10;ha : ∃ ys, ys ++ xs = as&#10;hb : ∃ ys, ys ++ xs = bs&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;⊢ forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb" state_after="no goals" tactic="induction xs generalizing b with&#10;| nil =&amp;gt; simp [forIn'.loop]&#10;| cons a xs ih =&amp;gt;&#10;  simp only [forIn'.loop] at *&#10;  congr 1&#10;  · rw [h]&#10;  · funext s&#10;    obtain b | b := s&#10;    · rfl&#10;    · simp&#10;      rw [ih]">
                    <AtomNode start="(236, 3)" end="(236, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(236, 13)" end="(236, 15)">
                      <OtherNode start="(236, 13)" end="(236, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(236, 13)" end="(236, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(236, 16)" end="(236, 30)">
                      <AtomNode start="(236, 16)" end="(236, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(236, 29)" end="(236, 30)">
                        <IdentNode start="(236, 29)" end="(236, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(236, 31)" end="(246, 16)">
                      <OtherNode start="(236, 31)" end="(246, 16)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(236, 31)" end="(236, 35)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(237, 3)" end="(246, 16)">
                          <OtherNode start="(237, 3)" end="(237, 30)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(237, 3)" end="(237, 8)">
                              <OtherNode start="(237, 3)" end="(237, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(237, 3)" end="(237, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(237, 5)" end="(237, 8)">
                                  <NullNode/>
                                  <IdentNode start="(237, 5)" end="(237, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(237, 9)" end="(237, 30)">
                              <AtomNode start="(237, 9)" end="(237, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(237, 12)" end="(237, 30)">
                                <TacticTacticseq1IndentedNode start="(237, 12)" end="(237, 30)">
                                  <NullNode start="(237, 12)" end="(237, 30)">
                                    <OtherNode start="(237, 12)" end="(237, 30)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;b : β&#10;ha : ∃ ys, ys ++ [] = as&#10;hb : ∃ ys, ys ++ [] = bs&#10;⊢ forIn'.loop as f [] b ha = forIn'.loop bs g [] b hb" state_after="no goals" tactic="simp [forIn'.loop]">
                                      <AtomNode start="(237, 12)" end="(237, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(237, 17)" end="(237, 30)">
                                        <AtomNode start="(237, 17)" end="(237, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(237, 18)" end="(237, 29)">
                                          <OtherNode start="(237, 18)" end="(237, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(237, 18)" end="(237, 29)" leading="" trailing="" raw_val="forIn'.loop" val="forIn'.loop" full_name="List.forIn'.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(237, 29)" end="(237, 30)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(238, 3)" end="(246, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(238, 3)" end="(238, 17)">
                              <OtherNode start="(238, 3)" end="(238, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(238, 3)" end="(238, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(238, 5)" end="(238, 9)">
                                  <NullNode/>
                                  <IdentNode start="(238, 5)" end="(238, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(238, 10)" end="(238, 17)">
                                  <IdentNode start="(238, 10)" end="(238, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(238, 12)" end="(238, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(238, 15)" end="(238, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(238, 18)" end="(246, 16)">
                              <AtomNode start="(238, 18)" end="(238, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(239, 5)" end="(246, 16)">
                                <TacticTacticseq1IndentedNode start="(239, 5)" end="(246, 16)">
                                  <NullNode start="(239, 5)" end="(246, 16)">
                                    <OtherNode start="(239, 5)" end="(239, 33)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;⊢ forIn'.loop as f (a :: xs) b ha = forIn'.loop bs g (a :: xs) b hb" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;⊢ (do&#10;      let __do_lift ← f a ⋯ b&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    do&#10;    let __do_lift ← g a ⋯ b&#10;    match __do_lift with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" tactic="simp only [forIn'.loop] at *">
                                      <AtomNode start="(239, 5)" end="(239, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(239, 10)" end="(239, 14)">
                                        <AtomNode start="(239, 10)" end="(239, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(239, 15)" end="(239, 28)">
                                        <AtomNode start="(239, 15)" end="(239, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(239, 16)" end="(239, 27)">
                                          <OtherNode start="(239, 16)" end="(239, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(239, 16)" end="(239, 27)" leading="" trailing="" raw_val="forIn'.loop" val="forIn'.loop" full_name="List.forIn'.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(239, 27)" end="(239, 28)" leading="" trailing=" " val="]"/>
                                      </NullNode>
                                      <NullNode start="(239, 29)" end="(239, 33)">
                                        <OtherNode start="(239, 29)" end="(239, 33)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(239, 29)" end="(239, 31)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(239, 32)" end="(239, 33)" kind="Lean.Parser.Tactic.locationWildcard">
                                            <AtomNode start="(239, 32)" end="(239, 33)" leading="" trailing="&#10;    " val="*"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(240, 5)" end="(240, 12)" kind="Lean.Parser.Tactic.congr" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;⊢ (do&#10;      let __do_lift ← f a ⋯ b&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    do&#10;    let __do_lift ← g a ⋯ b&#10;    match __do_lift with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" state_after="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;⊢ f a ⋯ b = g a ⋯ b&#10;&#10;case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    fun __do_lift =&amp;gt;&#10;    match __do_lift with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" tactic="congr 1">
                                      <AtomNode start="(240, 5)" end="(240, 10)" leading="" trailing=" " val="congr"/>
                                      <NullNode start="(240, 11)" end="(240, 12)">
                                        <OtherNode start="(240, 11)" end="(240, 12)" kind="num">
                                          <AtomNode start="(240, 11)" end="(240, 12)" leading="" trailing="&#10;    " val="1"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(241, 5)" end="(241, 13)" kind="Lean.cdot" state_before="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;⊢ f a ⋯ b = g a ⋯ b&#10;&#10;case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    fun __do_lift =&amp;gt;&#10;    match __do_lift with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" state_after="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    fun __do_lift =&amp;gt;&#10;    match __do_lift with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" tactic="· rw [h]">
                                      <OtherNode start="(241, 5)" end="(241, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(241, 5)" end="(241, 6)" kind="patternIgnore">
                                          <OtherNode start="(241, 5)" end="(241, 6)" kind="token.«· »">
                                            <AtomNode start="(241, 5)" end="(241, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(241, 7)" end="(241, 13)">
                                        <TacticTacticseq1IndentedNode start="(241, 7)" end="(241, 13)">
                                          <NullNode start="(241, 7)" end="(241, 13)">
                                            <OtherNode start="(241, 7)" end="(241, 13)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;⊢ f a ⋯ b = g a ⋯ b" state_after="no goals" tactic="rw [h]">
                                              <AtomNode start="(241, 7)" end="(241, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(241, 10)" end="(241, 13)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(241, 10)" end="(241, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(241, 11)" end="(241, 12)">
                                                  <OtherNode start="(241, 11)" end="(241, 12)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(241, 11)" end="(241, 12)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(241, 12)" end="(241, 13)" leading="" trailing="&#10;    " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(242, 5)" end="(246, 16)" kind="Lean.cdot" state_before="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    fun __do_lift =&amp;gt;&#10;    match __do_lift with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" state_after="no goals" tactic="· funext s&#10;  obtain b | b := s&#10;  · rfl&#10;  · simp&#10;    rw [ih]">
                                      <OtherNode start="(242, 5)" end="(242, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(242, 5)" end="(242, 6)" kind="patternIgnore">
                                          <OtherNode start="(242, 5)" end="(242, 6)" kind="token.«· »">
                                            <AtomNode start="(242, 5)" end="(242, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(242, 7)" end="(246, 16)">
                                        <TacticTacticseq1IndentedNode start="(242, 7)" end="(246, 16)">
                                          <NullNode start="(242, 7)" end="(246, 16)">
                                            <OtherNode start="(242, 7)" end="(242, 15)" kind="tacticFunext___" state_before="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    fun __do_lift =&amp;gt;&#10;    match __do_lift with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" state_after="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;s : ForInStep β&#10;⊢ (match s with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    match s with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" tactic="funext s">
                                              <AtomNode start="(242, 7)" end="(242, 13)" leading="" trailing=" " val="funext"/>
                                              <NullNode start="(242, 14)" end="(242, 15)">
                                                <IdentNode start="(242, 14)" end="(242, 15)" leading="" trailing="&#10;      " raw_val="s" val="s"/>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(243, 7)" end="(243, 24)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;s : ForInStep β&#10;⊢ (match s with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    match s with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" state_after="case cons.e_a.h.done&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b✝ : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯&#10;&#10;case cons.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b✝ : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" tactic="obtain b | b := s">
                                              <AtomNode start="(243, 7)" end="(243, 13)" leading="" trailing=" " val="obtain"/>
                                              <NullNode start="(243, 14)" end="(243, 19)">
                                                <OtherNode start="(243, 14)" end="(243, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(243, 14)" end="(243, 19)">
                                                    <OtherNode start="(243, 14)" end="(243, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(243, 14)" end="(243, 15)" leading="" trailing=" " raw_val="b" val="b"/>
                                                    </OtherNode>
                                                    <AtomNode start="(243, 16)" end="(243, 17)" leading="" trailing=" " val="|"/>
                                                    <OtherNode start="(243, 18)" end="(243, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(243, 18)" end="(243, 19)" leading="" trailing=" " raw_val="b" val="b"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                              <NullNode start="(243, 20)" end="(243, 24)">
                                                <AtomNode start="(243, 20)" end="(243, 22)" leading="" trailing=" " val=":="/>
                                                <NullNode start="(243, 23)" end="(243, 24)">
                                                  <IdentNode start="(243, 23)" end="(243, 24)" leading="" trailing="&#10;      " raw_val="s" val="s"/>
                                                </NullNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(244, 7)" end="(244, 12)" kind="Lean.cdot" state_before="case cons.e_a.h.done&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b✝ : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯&#10;&#10;case cons.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b✝ : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" state_after="case cons.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b✝ : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" tactic="· rfl">
                                              <OtherNode start="(244, 7)" end="(244, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(244, 7)" end="(244, 8)" kind="patternIgnore">
                                                  <OtherNode start="(244, 7)" end="(244, 8)" kind="token.«· »">
                                                    <AtomNode start="(244, 7)" end="(244, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(244, 9)" end="(244, 12)">
                                                <TacticTacticseq1IndentedNode start="(244, 9)" end="(244, 12)">
                                                  <NullNode start="(244, 9)" end="(244, 12)">
                                                    <OtherNode start="(244, 9)" end="(244, 12)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case cons.e_a.h.done&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b✝ : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" state_after="no goals" tactic="rfl">
                                                      <AtomNode start="(244, 9)" end="(244, 12)" leading="" trailing="&#10;      " val="rfl"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(245, 7)" end="(246, 16)" kind="Lean.cdot" state_before="case cons.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b✝ : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" state_after="no goals" tactic="· simp&#10;  rw [ih]">
                                              <OtherNode start="(245, 7)" end="(245, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(245, 7)" end="(245, 8)" kind="patternIgnore">
                                                  <OtherNode start="(245, 7)" end="(245, 8)" kind="token.«· »">
                                                    <AtomNode start="(245, 7)" end="(245, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(245, 9)" end="(246, 16)">
                                                <TacticTacticseq1IndentedNode start="(245, 9)" end="(246, 16)">
                                                  <NullNode start="(245, 9)" end="(246, 16)">
                                                    <OtherNode start="(245, 9)" end="(245, 13)" kind="Lean.Parser.Tactic.simp" state_before="case cons.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b✝ : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as f xs b ⋯) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop bs g xs b ⋯" state_after="case cons.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b✝ : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;b : β&#10;⊢ forIn'.loop as f xs b ⋯ = forIn'.loop bs g xs b ⋯" tactic="simp">
                                                      <AtomNode start="(245, 9)" end="(245, 13)" leading="" trailing="&#10;        " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(246, 9)" end="(246, 16)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ as) (m' : a ∈ bs) (b : β), f a m_1 b = g a m' b&#10;a : α&#10;xs : List α&#10;ih :&#10;  ∀ {b : β} (ha : ∃ ys, ys ++ xs = as) (hb : ∃ ys, ys ++ xs = bs), forIn'.loop as f xs b ha = forIn'.loop bs g xs b hb&#10;b✝ : β&#10;ha : ∃ ys, ys ++ a :: xs = as&#10;hb : ∃ ys, ys ++ a :: xs = bs&#10;b : β&#10;⊢ forIn'.loop as f xs b ⋯ = forIn'.loop bs g xs b ⋯" state_after="no goals" tactic="rw [ih]">
                                                      <AtomNode start="(246, 9)" end="(246, 11)" leading="" trailing=" " val="rw"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <OtherNode start="(246, 12)" end="(246, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                        <AtomNode start="(246, 12)" end="(246, 13)" leading="" trailing="" val="["/>
                                                        <NullNode start="(246, 13)" end="(246, 15)">
                                                          <OtherNode start="(246, 13)" end="(246, 15)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(246, 13)" end="(246, 15)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(246, 15)" end="(246, 16)" leading="" trailing="&#10;&#10;" val="]"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(248, 1)" end="(259, 8)" name="forIn'_cons" full_name="List.forIn'_cons">
      <CommandDeclmodifiersNode start="(248, 1)" end="(248, 8)">
        <NullNode/>
        <NullNode start="(248, 1)" end="(248, 8)">
          <OtherNode start="(248, 1)" end="(248, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(248, 1)" end="(248, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(248, 3)" end="(248, 7)">
              <OtherNode start="(248, 3)" end="(248, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(248, 3)" end="(248, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(248, 3)" end="(248, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(248, 7)" end="(248, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(248, 9)" end="(259, 8)" name="forIn'_cons" full_name="List.forIn'_cons" _is_private_decl="False">
        <AtomNode start="(248, 9)" end="(248, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(248, 17)" end="(248, 28)">
          <IdentNode start="(248, 17)" end="(248, 28)" leading="" trailing=" " raw_val="forIn'_cons" val="forIn'_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(248, 29)" end="(251, 117)">
          <NullNode start="(248, 29)" end="(249, 64)">
            <OtherNode start="(248, 29)" end="(248, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(248, 29)" end="(248, 30)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(248, 30)" end="(248, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(248, 30)" end="(248, 35)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(248, 36)" end="(248, 37)">
                  <IdentNode start="(248, 36)" end="(248, 37)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(248, 37)" end="(248, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(248, 39)" end="(248, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(248, 39)" end="(248, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(248, 40)" end="(248, 41)">
                <IdentNode start="(248, 40)" end="(248, 41)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(248, 42)" end="(248, 45)">
                <AtomNode start="(248, 42)" end="(248, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(248, 44)" end="(248, 45)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(248, 45)" end="(248, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(248, 47)" end="(248, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(248, 47)" end="(248, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(248, 48)" end="(248, 50)">
                <IdentNode start="(248, 48)" end="(248, 50)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(248, 51)" end="(248, 59)">
                <AtomNode start="(248, 51)" end="(248, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(248, 53)" end="(248, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(248, 53)" end="(248, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(248, 58)" end="(248, 59)">
                    <IdentNode start="(248, 58)" end="(248, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(248, 59)" end="(248, 60)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(249, 5)" end="(249, 56)">
              <AtomNode start="(249, 5)" end="(249, 6)" leading="" trailing="" val="("/>
              <NullNode start="(249, 6)" end="(249, 7)">
                <IdentNode start="(249, 6)" end="(249, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(249, 8)" end="(249, 55)">
                <AtomNode start="(249, 8)" end="(249, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(249, 10)" end="(249, 55)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(249, 10)" end="(249, 18)">
                    <AtomNode start="(249, 10)" end="(249, 11)" leading="" trailing="" val="("/>
                    <NullNode start="(249, 11)" end="(249, 13)">
                      <IdentNode start="(249, 11)" end="(249, 13)" leading="" trailing=" " raw_val="a'" val="a'"/>
                    </NullNode>
                    <NullNode start="(249, 14)" end="(249, 17)">
                      <AtomNode start="(249, 14)" end="(249, 15)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(249, 16)" end="(249, 17)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(249, 17)" end="(249, 18)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(249, 19)" end="(249, 20)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(249, 21)" end="(249, 55)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(249, 21)" end="(249, 33)" kind="«term_∈_»">
                      <IdentNode start="(249, 21)" end="(249, 23)" leading="" trailing=" " raw_val="a'" val="a'"/>
                      <AtomNode start="(249, 24)" end="(249, 25)" leading="" trailing=" " val="∈"/>
                      <OtherNode start="(249, 26)" end="(249, 33)" kind="«term_::_»">
                        <IdentNode start="(249, 26)" end="(249, 27)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(249, 28)" end="(249, 30)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(249, 31)" end="(249, 33)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(249, 34)" end="(249, 35)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(249, 36)" end="(249, 55)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(249, 36)" end="(249, 37)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(249, 38)" end="(249, 39)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(249, 40)" end="(249, 55)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(249, 40)" end="(249, 41)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(249, 42)" end="(249, 55)">
                          <OtherNode start="(249, 42)" end="(249, 55)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(249, 42)" end="(249, 43)" leading="" trailing="" val="("/>
                            <OtherNode start="(249, 43)" end="(249, 54)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(249, 43)" end="(249, 52)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(249, 53)" end="(249, 54)">
                                <IdentNode start="(249, 53)" end="(249, 54)" leading="" trailing="" raw_val="β" val="β"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(249, 54)" end="(249, 55)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(249, 55)" end="(249, 56)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(249, 57)" end="(249, 64)">
              <AtomNode start="(249, 57)" end="(249, 58)" leading="" trailing="" val="("/>
              <NullNode start="(249, 58)" end="(249, 59)">
                <IdentNode start="(249, 58)" end="(249, 59)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(249, 60)" end="(249, 63)">
                <AtomNode start="(249, 60)" end="(249, 61)" leading="" trailing=" " val=":"/>
                <IdentNode start="(249, 62)" end="(249, 63)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(249, 63)" end="(249, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(249, 65)" end="(251, 117)">
            <AtomNode start="(249, 65)" end="(249, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(250, 5)" end="(251, 117)" kind="«term_=_»">
              <OtherNode start="(250, 5)" end="(250, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(250, 5)" end="(250, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(250, 12)" end="(250, 23)">
                  <OtherNode start="(250, 12)" end="(250, 19)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(250, 12)" end="(250, 13)" leading="" trailing="" val="("/>
                    <OtherNode start="(250, 13)" end="(250, 18)" kind="«term_::_»">
                      <IdentNode start="(250, 13)" end="(250, 14)" leading="" trailing="" raw_val="a" val="a"/>
                      <AtomNode start="(250, 14)" end="(250, 16)" leading="" trailing="" val="::"/>
                      <IdentNode start="(250, 16)" end="(250, 18)" leading="" trailing="" raw_val="as" val="as"/>
                    </OtherNode>
                    <AtomNode start="(250, 18)" end="(250, 19)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(250, 20)" end="(250, 21)" leading="" trailing=" " raw_val="b" val="b"/>
                  <IdentNode start="(250, 22)" end="(250, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(250, 24)" end="(250, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(250, 26)" end="(251, 117)" kind="«term_&amp;gt;&amp;gt;=_»">
                <OtherNode start="(250, 26)" end="(250, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(250, 26)" end="(250, 27)" leading="" trailing=" " raw_val="f" val="f"/>
                  <NullNode start="(250, 28)" end="(250, 45)">
                    <IdentNode start="(250, 28)" end="(250, 29)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(250, 30)" end="(250, 43)" leading="" trailing=" " raw_val="mem_cons_self" val="mem_cons_self" full_name="List.mem_cons_self" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                    <IdentNode start="(250, 44)" end="(250, 45)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(250, 46)" end="(250, 49)" leading="" trailing="&#10;      " val="&amp;gt;&amp;gt;="/>
                <OtherNode start="(251, 7)" end="(251, 117)" kind="Lean.Parser.Term.fun">
                  <AtomNode start="(251, 7)" end="(251, 10)" leading="" trailing=" " val="fun"/>
                  <OtherNode start="(251, 11)" end="(251, 117)" kind="Lean.Parser.Term.matchAlts">
                    <NullNode start="(251, 11)" end="(251, 117)">
                      <OtherNode start="(251, 11)" end="(251, 39)" kind="Lean.Parser.Term.matchAlt">
                        <AtomNode start="(251, 11)" end="(251, 12)" leading="" trailing=" " val="|"/>
                        <NullNode start="(251, 13)" end="(251, 29)">
                          <NullNode start="(251, 13)" end="(251, 29)">
                            <OtherNode start="(251, 13)" end="(251, 29)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(251, 13)" end="(251, 27)" leading="" trailing=" " raw_val="ForInStep.done" val="ForInStep.done" full_name="ForInStep.done" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(251, 28)" end="(251, 29)">
                                <IdentNode start="(251, 28)" end="(251, 29)" leading="" trailing=" " raw_val="b" val="b"/>
                              </NullNode>
                            </OtherNode>
                          </NullNode>
                        </NullNode>
                        <AtomNode start="(251, 30)" end="(251, 32)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(251, 33)" end="(251, 39)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(251, 33)" end="(251, 37)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(251, 38)" end="(251, 39)">
                            <IdentNode start="(251, 38)" end="(251, 39)" leading="" trailing=" " raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(251, 40)" end="(251, 117)" kind="Lean.Parser.Term.matchAlt">
                        <AtomNode start="(251, 40)" end="(251, 41)" leading="" trailing=" " val="|"/>
                        <NullNode start="(251, 42)" end="(251, 59)">
                          <NullNode start="(251, 42)" end="(251, 59)">
                            <OtherNode start="(251, 42)" end="(251, 59)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(251, 42)" end="(251, 57)" leading="" trailing=" " raw_val="ForInStep.yield" val="ForInStep.yield" full_name="ForInStep.yield" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(251, 58)" end="(251, 59)">
                                <IdentNode start="(251, 58)" end="(251, 59)" leading="" trailing=" " raw_val="b" val="b"/>
                              </NullNode>
                            </OtherNode>
                          </NullNode>
                        </NullNode>
                        <AtomNode start="(251, 60)" end="(251, 62)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(251, 63)" end="(251, 117)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(251, 63)" end="(251, 69)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                          <NullNode start="(251, 70)" end="(251, 117)">
                            <IdentNode start="(251, 70)" end="(251, 72)" leading="" trailing=" " raw_val="as" val="as"/>
                            <IdentNode start="(251, 73)" end="(251, 74)" leading="" trailing=" " raw_val="b" val="b"/>
                            <OtherNode start="(251, 75)" end="(251, 117)" kind="Lean.Parser.Term.fun">
                              <AtomNode start="(251, 75)" end="(251, 78)" leading="" trailing=" " val="fun"/>
                              <OtherNode start="(251, 79)" end="(251, 117)" kind="Lean.Parser.Term.basicFun">
                                <NullNode start="(251, 79)" end="(251, 85)">
                                  <IdentNode start="(251, 79)" end="(251, 81)" leading="" trailing=" " raw_val="a'" val="a'"/>
                                  <IdentNode start="(251, 82)" end="(251, 83)" leading="" trailing=" " raw_val="m" val="m"/>
                                  <IdentNode start="(251, 84)" end="(251, 85)" leading="" trailing=" " raw_val="b" val="b"/>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(251, 86)" end="(251, 88)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(251, 89)" end="(251, 117)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(251, 89)" end="(251, 90)" leading="" trailing=" " raw_val="f" val="f"/>
                                  <NullNode start="(251, 91)" end="(251, 117)">
                                    <IdentNode start="(251, 91)" end="(251, 93)" leading="" trailing=" " raw_val="a'" val="a'"/>
                                    <OtherNode start="(251, 94)" end="(251, 115)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(251, 94)" end="(251, 95)" leading="" trailing="" val="("/>
                                      <OtherNode start="(251, 95)" end="(251, 114)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(251, 95)" end="(251, 110)" leading="" trailing=" " raw_val="mem_cons_of_mem" val="mem_cons_of_mem" full_name="List.mem_cons_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                        <NullNode start="(251, 111)" end="(251, 114)">
                                          <IdentNode start="(251, 111)" end="(251, 112)" leading="" trailing=" " raw_val="a" val="a"/>
                                          <IdentNode start="(251, 113)" end="(251, 114)" leading="" trailing="" raw_val="m" val="m"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(251, 114)" end="(251, 115)" leading="" trailing=" " val=")"/>
                                    </OtherNode>
                                    <IdentNode start="(251, 116)" end="(251, 117)" leading="" trailing=" " raw_val="b" val="b"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(251, 118)" end="(259, 8)">
          <AtomNode start="(251, 118)" end="(251, 120)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(251, 121)" end="(259, 8)">
            <AtomNode start="(251, 121)" end="(251, 123)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(252, 3)" end="(259, 8)">
              <TacticTacticseq1IndentedNode start="(252, 3)" end="(259, 8)">
                <NullNode start="(252, 3)" end="(259, 8)">
                  <OtherNode start="(252, 3)" end="(252, 47)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b : β&#10;⊢ forIn' (a :: as) b f = do&#10;    let x ← f a ⋯ b&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b : β&#10;⊢ (do&#10;      let __do_lift ← f a ⋯ b&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn'.loop (a :: as) f as b ⋯) =&#10;    do&#10;    let x ← f a ⋯ b&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn'.loop as (fun a' m b =&amp;gt; f a' ⋯ b) as b ⋯" tactic="simp only [forIn', List.forIn', forIn'.loop]">
                    <AtomNode start="(252, 3)" end="(252, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(252, 8)" end="(252, 12)">
                      <AtomNode start="(252, 8)" end="(252, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(252, 13)" end="(252, 47)">
                      <AtomNode start="(252, 13)" end="(252, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(252, 14)" end="(252, 46)">
                        <OtherNode start="(252, 14)" end="(252, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(252, 14)" end="(252, 20)" leading="" trailing="" raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                        <AtomNode start="(252, 20)" end="(252, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(252, 22)" end="(252, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(252, 22)" end="(252, 33)" leading="" trailing="" raw_val="List.forIn'" val="List.forIn'" full_name="List.forIn'" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                        </OtherNode>
                        <AtomNode start="(252, 33)" end="(252, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(252, 35)" end="(252, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(252, 35)" end="(252, 46)" leading="" trailing="" raw_val="forIn'.loop" val="forIn'.loop" full_name="List.forIn'.loop" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(252, 46)" end="(252, 47)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(253, 3)" end="(253, 10)" kind="Lean.Parser.Tactic.congr" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b : β&#10;⊢ (do&#10;      let __do_lift ← f a ⋯ b&#10;      match __do_lift with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn'.loop (a :: as) f as b ⋯) =&#10;    do&#10;    let x ← f a ⋯ b&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn'.loop as (fun a' m b =&amp;gt; f a' ⋯ b) as b ⋯" state_after="case e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b : β&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn'.loop (a :: as) f as b ⋯) =&#10;    fun x =&amp;gt;&#10;    match x with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as (fun a' m b =&amp;gt; f a' ⋯ b) as b ⋯" tactic="congr 1">
                    <AtomNode start="(253, 3)" end="(253, 8)" leading="" trailing=" " val="congr"/>
                    <NullNode start="(253, 9)" end="(253, 10)">
                      <OtherNode start="(253, 9)" end="(253, 10)" kind="num">
                        <AtomNode start="(253, 9)" end="(253, 10)" leading="" trailing="&#10;  " val="1"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(254, 3)" end="(254, 11)" kind="tacticFunext___" state_before="case e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b : β&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn'.loop (a :: as) f as b ⋯) =&#10;    fun x =&amp;gt;&#10;    match x with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as (fun a' m b =&amp;gt; f a' ⋯ b) as b ⋯" state_after="case e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b : β&#10;s : ForInStep β&#10;⊢ (match s with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop (a :: as) f as b ⋯) =&#10;    match s with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as (fun a' m b =&amp;gt; f a' ⋯ b) as b ⋯" tactic="funext s">
                    <AtomNode start="(254, 3)" end="(254, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(254, 10)" end="(254, 11)">
                      <IdentNode start="(254, 10)" end="(254, 11)" leading="" trailing="&#10;  " raw_val="s" val="s"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(255, 3)" end="(255, 20)" kind="Lean.Parser.Tactic.obtain" state_before="case e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b : β&#10;s : ForInStep β&#10;⊢ (match s with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop (a :: as) f as b ⋯) =&#10;    match s with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as (fun a' m b =&amp;gt; f a' ⋯ b) as b ⋯" state_after="case e_a.h.done&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b✝ b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop (a :: as) f as b ⋯) =&#10;    match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as (fun a' m b =&amp;gt; f a' ⋯ b) as b ⋯&#10;&#10;case e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b✝ b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop (a :: as) f as b ⋯) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as (fun a' m b =&amp;gt; f a' ⋯ b) as b ⋯" tactic="obtain b | b := s">
                    <AtomNode start="(255, 3)" end="(255, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(255, 10)" end="(255, 15)">
                      <OtherNode start="(255, 10)" end="(255, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(255, 10)" end="(255, 15)">
                          <OtherNode start="(255, 10)" end="(255, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                            <IdentNode start="(255, 10)" end="(255, 11)" leading="" trailing=" " raw_val="b" val="b"/>
                          </OtherNode>
                          <AtomNode start="(255, 12)" end="(255, 13)" leading="" trailing=" " val="|"/>
                          <OtherNode start="(255, 14)" end="(255, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                            <IdentNode start="(255, 14)" end="(255, 15)" leading="" trailing=" " raw_val="b" val="b"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(255, 16)" end="(255, 20)">
                      <AtomNode start="(255, 16)" end="(255, 18)" leading="" trailing=" " val=":="/>
                      <NullNode start="(255, 19)" end="(255, 20)">
                        <IdentNode start="(255, 19)" end="(255, 20)" leading="" trailing="&#10;  " raw_val="s" val="s"/>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(256, 3)" end="(256, 8)" kind="Lean.cdot" state_before="case e_a.h.done&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b✝ b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop (a :: as) f as b ⋯) =&#10;    match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as (fun a' m b =&amp;gt; f a' ⋯ b) as b ⋯&#10;&#10;case e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b✝ b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop (a :: as) f as b ⋯) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as (fun a' m b =&amp;gt; f a' ⋯ b) as b ⋯" state_after="case e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b✝ b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop (a :: as) f as b ⋯) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as (fun a' m b =&amp;gt; f a' ⋯ b) as b ⋯" tactic="· rfl">
                    <OtherNode start="(256, 3)" end="(256, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(256, 3)" end="(256, 4)" kind="patternIgnore">
                        <OtherNode start="(256, 3)" end="(256, 4)" kind="token.«· »">
                          <AtomNode start="(256, 3)" end="(256, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(256, 5)" end="(256, 8)">
                      <TacticTacticseq1IndentedNode start="(256, 5)" end="(256, 8)">
                        <NullNode start="(256, 5)" end="(256, 8)">
                          <OtherNode start="(256, 5)" end="(256, 8)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case e_a.h.done&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b✝ b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop (a :: as) f as b ⋯) =&#10;    match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as (fun a' m b =&amp;gt; f a' ⋯ b) as b ⋯" state_after="no goals" tactic="rfl">
                            <AtomNode start="(256, 5)" end="(256, 8)" leading="" trailing="&#10;  " val="rfl"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(257, 3)" end="(259, 8)" kind="Lean.cdot" state_before="case e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b✝ b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop (a :: as) f as b ⋯) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as (fun a' m b =&amp;gt; f a' ⋯ b) as b ⋯" state_after="no goals" tactic="· apply forIn'_loop_congr&#10;  intros&#10;  rfl">
                    <OtherNode start="(257, 3)" end="(257, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(257, 3)" end="(257, 4)" kind="patternIgnore">
                        <OtherNode start="(257, 3)" end="(257, 4)" kind="token.«· »">
                          <AtomNode start="(257, 3)" end="(257, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(257, 5)" end="(259, 8)">
                      <TacticTacticseq1IndentedNode start="(257, 5)" end="(259, 8)">
                        <NullNode start="(257, 5)" end="(259, 8)">
                          <OtherNode start="(257, 5)" end="(257, 28)" kind="Lean.Parser.Tactic.apply" state_before="case e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b✝ b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop (a :: as) f as b ⋯) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn'.loop as (fun a' m b =&amp;gt; f a' ⋯ b) as b ⋯" state_after="case e_a.h.yield.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b✝ b : β&#10;⊢ ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (m' : a_1 ∈ as) (b : β), f a_1 m_1 b = f a_1 ⋯ b" tactic="apply forIn'_loop_congr">
                            <AtomNode start="(257, 5)" end="(257, 10)" leading="" trailing=" " val="apply"/>
                            <IdentNode start="(257, 11)" end="(257, 28)" leading="" trailing="&#10;    " raw_val="forIn'_loop_congr" val="forIn'_loop_congr" full_name="List.forIn'_loop_congr" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(231, 9)" def_end="(231, 26)"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(258, 5)" end="(258, 11)" kind="Lean.Parser.Tactic.intros" state_before="case e_a.h.yield.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b✝ b : β&#10;⊢ ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (m' : a_1 ∈ as) (b : β), f a_1 m_1 b = f a_1 ⋯ b" state_after="case e_a.h.yield.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b✝¹ b : β&#10;a✝ : α&#10;m✝ : a✝ ∈ a :: as&#10;m'✝ : a✝ ∈ as&#10;b✝ : β&#10;⊢ f a✝ m✝ b✝ = f a✝ ⋯ b✝" tactic="intros">
                            <AtomNode start="(258, 5)" end="(258, 11)" leading="" trailing="&#10;    " val="intros"/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(259, 5)" end="(259, 8)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case e_a.h.yield.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;b✝¹ b : β&#10;a✝ : α&#10;m✝ : a✝ ∈ a :: as&#10;m'✝ : a✝ ∈ as&#10;b✝ : β&#10;⊢ f a✝ m✝ b✝ = f a✝ ⋯ b✝" state_after="no goals" tactic="rfl">
                            <AtomNode start="(259, 5)" end="(259, 8)" leading="" trailing="&#10;&#10;" val="rfl"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(261, 1)" end="(264, 31)" name="forIn_cons" full_name="List.forIn_cons">
      <CommandDeclmodifiersNode start="(261, 1)" end="(261, 8)">
        <NullNode/>
        <NullNode start="(261, 1)" end="(261, 8)">
          <OtherNode start="(261, 1)" end="(261, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(261, 1)" end="(261, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(261, 3)" end="(261, 7)">
              <OtherNode start="(261, 3)" end="(261, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(261, 3)" end="(261, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(261, 3)" end="(261, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(261, 7)" end="(261, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(261, 9)" end="(264, 31)" name="forIn_cons" full_name="List.forIn_cons" _is_private_decl="False">
        <AtomNode start="(261, 9)" end="(261, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(261, 17)" end="(261, 27)">
          <IdentNode start="(261, 17)" end="(261, 27)" leading="" trailing=" " raw_val="forIn_cons" val="forIn_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(261, 28)" end="(262, 103)">
          <NullNode start="(261, 28)" end="(261, 97)">
            <OtherNode start="(261, 28)" end="(261, 37)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(261, 28)" end="(261, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(261, 29)" end="(261, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(261, 29)" end="(261, 34)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(261, 35)" end="(261, 36)">
                  <IdentNode start="(261, 35)" end="(261, 36)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(261, 36)" end="(261, 37)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(261, 38)" end="(261, 67)">
              <AtomNode start="(261, 38)" end="(261, 39)" leading="" trailing="" val="("/>
              <NullNode start="(261, 39)" end="(261, 40)">
                <IdentNode start="(261, 39)" end="(261, 40)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(261, 41)" end="(261, 66)">
                <AtomNode start="(261, 41)" end="(261, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(261, 43)" end="(261, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(261, 43)" end="(261, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(261, 45)" end="(261, 46)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(261, 47)" end="(261, 66)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(261, 47)" end="(261, 48)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(261, 49)" end="(261, 50)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(261, 51)" end="(261, 66)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(261, 51)" end="(261, 52)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(261, 53)" end="(261, 66)">
                        <OtherNode start="(261, 53)" end="(261, 66)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(261, 53)" end="(261, 54)" leading="" trailing="" val="("/>
                          <OtherNode start="(261, 54)" end="(261, 65)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(261, 54)" end="(261, 63)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                            <NullNode start="(261, 64)" end="(261, 65)">
                              <IdentNode start="(261, 64)" end="(261, 65)" leading="" trailing="" raw_val="β" val="β"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(261, 65)" end="(261, 66)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(261, 66)" end="(261, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(261, 68)" end="(261, 75)">
              <AtomNode start="(261, 68)" end="(261, 69)" leading="" trailing="" val="("/>
              <NullNode start="(261, 69)" end="(261, 70)">
                <IdentNode start="(261, 69)" end="(261, 70)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(261, 71)" end="(261, 74)">
                <AtomNode start="(261, 71)" end="(261, 72)" leading="" trailing=" " val=":"/>
                <IdentNode start="(261, 73)" end="(261, 74)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(261, 74)" end="(261, 75)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(261, 76)" end="(261, 89)">
              <AtomNode start="(261, 76)" end="(261, 77)" leading="" trailing="" val="("/>
              <NullNode start="(261, 77)" end="(261, 79)">
                <IdentNode start="(261, 77)" end="(261, 79)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(261, 80)" end="(261, 88)">
                <AtomNode start="(261, 80)" end="(261, 81)" leading="" trailing=" " val=":"/>
                <OtherNode start="(261, 82)" end="(261, 88)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(261, 82)" end="(261, 86)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(261, 87)" end="(261, 88)">
                    <IdentNode start="(261, 87)" end="(261, 88)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(261, 88)" end="(261, 89)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(261, 90)" end="(261, 97)">
              <AtomNode start="(261, 90)" end="(261, 91)" leading="" trailing="" val="("/>
              <NullNode start="(261, 91)" end="(261, 92)">
                <IdentNode start="(261, 91)" end="(261, 92)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(261, 93)" end="(261, 96)">
                <AtomNode start="(261, 93)" end="(261, 94)" leading="" trailing=" " val=":"/>
                <IdentNode start="(261, 95)" end="(261, 96)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(261, 96)" end="(261, 97)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(261, 98)" end="(262, 103)">
            <AtomNode start="(261, 98)" end="(261, 99)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(262, 5)" end="(262, 103)" kind="«term_=_»">
              <OtherNode start="(262, 5)" end="(262, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(262, 5)" end="(262, 10)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(262, 11)" end="(262, 22)">
                  <OtherNode start="(262, 11)" end="(262, 18)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(262, 11)" end="(262, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(262, 12)" end="(262, 17)" kind="«term_::_»">
                      <IdentNode start="(262, 12)" end="(262, 13)" leading="" trailing="" raw_val="a" val="a"/>
                      <AtomNode start="(262, 13)" end="(262, 15)" leading="" trailing="" val="::"/>
                      <IdentNode start="(262, 15)" end="(262, 17)" leading="" trailing="" raw_val="as" val="as"/>
                    </OtherNode>
                    <AtomNode start="(262, 17)" end="(262, 18)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(262, 19)" end="(262, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                  <IdentNode start="(262, 21)" end="(262, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(262, 23)" end="(262, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(262, 25)" end="(262, 103)" kind="«term_&amp;gt;&amp;gt;=_»">
                <OtherNode start="(262, 25)" end="(262, 30)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(262, 25)" end="(262, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                  <NullNode start="(262, 27)" end="(262, 30)">
                    <IdentNode start="(262, 27)" end="(262, 28)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(262, 29)" end="(262, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(262, 31)" end="(262, 34)" leading="" trailing=" " val="&amp;gt;&amp;gt;="/>
                <OtherNode start="(262, 35)" end="(262, 103)" kind="Lean.Parser.Term.fun">
                  <AtomNode start="(262, 35)" end="(262, 38)" leading="" trailing=" " val="fun"/>
                  <OtherNode start="(262, 39)" end="(262, 103)" kind="Lean.Parser.Term.matchAlts">
                    <NullNode start="(262, 39)" end="(262, 103)">
                      <OtherNode start="(262, 39)" end="(262, 67)" kind="Lean.Parser.Term.matchAlt">
                        <AtomNode start="(262, 39)" end="(262, 40)" leading="" trailing=" " val="|"/>
                        <NullNode start="(262, 41)" end="(262, 57)">
                          <NullNode start="(262, 41)" end="(262, 57)">
                            <OtherNode start="(262, 41)" end="(262, 57)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(262, 41)" end="(262, 55)" leading="" trailing=" " raw_val="ForInStep.done" val="ForInStep.done" full_name="ForInStep.done" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(262, 56)" end="(262, 57)">
                                <IdentNode start="(262, 56)" end="(262, 57)" leading="" trailing=" " raw_val="b" val="b"/>
                              </NullNode>
                            </OtherNode>
                          </NullNode>
                        </NullNode>
                        <AtomNode start="(262, 58)" end="(262, 60)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(262, 61)" end="(262, 67)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(262, 61)" end="(262, 65)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(262, 66)" end="(262, 67)">
                            <IdentNode start="(262, 66)" end="(262, 67)" leading="" trailing=" " raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(262, 68)" end="(262, 103)" kind="Lean.Parser.Term.matchAlt">
                        <AtomNode start="(262, 68)" end="(262, 69)" leading="" trailing=" " val="|"/>
                        <NullNode start="(262, 70)" end="(262, 87)">
                          <NullNode start="(262, 70)" end="(262, 87)">
                            <OtherNode start="(262, 70)" end="(262, 87)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(262, 70)" end="(262, 85)" leading="" trailing=" " raw_val="ForInStep.yield" val="ForInStep.yield" full_name="ForInStep.yield" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(262, 86)" end="(262, 87)">
                                <IdentNode start="(262, 86)" end="(262, 87)" leading="" trailing=" " raw_val="b" val="b"/>
                              </NullNode>
                            </OtherNode>
                          </NullNode>
                        </NullNode>
                        <AtomNode start="(262, 88)" end="(262, 90)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(262, 91)" end="(262, 103)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(262, 91)" end="(262, 96)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                          <NullNode start="(262, 97)" end="(262, 103)">
                            <IdentNode start="(262, 97)" end="(262, 99)" leading="" trailing=" " raw_val="as" val="as"/>
                            <IdentNode start="(262, 100)" end="(262, 101)" leading="" trailing=" " raw_val="b" val="b"/>
                            <IdentNode start="(262, 102)" end="(262, 103)" leading="" trailing=" " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(262, 104)" end="(264, 31)">
          <AtomNode start="(262, 104)" end="(262, 106)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(262, 107)" end="(264, 31)">
            <AtomNode start="(262, 107)" end="(262, 109)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(263, 3)" end="(264, 31)">
              <TacticTacticseq1IndentedNode start="(263, 3)" end="(264, 31)">
                <NullNode start="(263, 3)" end="(264, 31)">
                  <OtherNode start="(263, 3)" end="(263, 67)" kind="Lean.Parser.Tactic.tacticHave_" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;b : β&#10;⊢ forIn (a :: as) b f = do&#10;    let x ← f a b&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn as b f" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;b : β&#10;this :&#10;  (forIn' (a :: as) b fun a' x b =&amp;gt; f a' b) = do&#10;    let x ← f a b&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' b&#10;⊢ forIn (a :: as) b f = do&#10;    let x ← f a b&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn as b f" tactic="have := forIn'_cons (a := a) (as := as) (fun a' _ b =&amp;gt; f a' b) b">
                    <AtomNode start="(263, 3)" end="(263, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(263, 8)" end="(263, 67)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(263, 8)" end="(263, 67)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(263, 8)" end="(263, 8)" kind="Lean.Parser.Term.haveId">
                          <OtherNode start="(263, 8)" end="(263, 8)" kind="hygieneInfo">
                            <IdentNode start="(263, 8)" end="(263, 8)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                          </OtherNode>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(263, 8)" end="(263, 10)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(263, 11)" end="(263, 67)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(263, 11)" end="(263, 22)" leading="" trailing=" " raw_val="forIn'_cons" val="forIn'_cons" full_name="List.forIn'_cons" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(248, 17)" def_end="(248, 28)"/>
                          <NullNode start="(263, 23)" end="(263, 67)">
                            <OtherNode start="(263, 23)" end="(263, 31)" kind="Lean.Parser.Term.namedArgument">
                              <AtomNode start="(263, 23)" end="(263, 24)" leading="" trailing="" val="("/>
                              <IdentNode start="(263, 24)" end="(263, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                              <AtomNode start="(263, 26)" end="(263, 28)" leading="" trailing=" " val=":="/>
                              <IdentNode start="(263, 29)" end="(263, 30)" leading="" trailing="" raw_val="a" val="a"/>
                              <AtomNode start="(263, 30)" end="(263, 31)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <OtherNode start="(263, 32)" end="(263, 42)" kind="Lean.Parser.Term.namedArgument">
                              <AtomNode start="(263, 32)" end="(263, 33)" leading="" trailing="" val="("/>
                              <IdentNode start="(263, 33)" end="(263, 35)" leading="" trailing=" " raw_val="as" val="as"/>
                              <AtomNode start="(263, 36)" end="(263, 38)" leading="" trailing=" " val=":="/>
                              <IdentNode start="(263, 39)" end="(263, 41)" leading="" trailing="" raw_val="as" val="as"/>
                              <AtomNode start="(263, 41)" end="(263, 42)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <OtherNode start="(263, 43)" end="(263, 65)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(263, 43)" end="(263, 44)" leading="" trailing="" val="("/>
                              <OtherNode start="(263, 44)" end="(263, 64)" kind="Lean.Parser.Term.fun">
                                <AtomNode start="(263, 44)" end="(263, 47)" leading="" trailing=" " val="fun"/>
                                <OtherNode start="(263, 48)" end="(263, 64)" kind="Lean.Parser.Term.basicFun">
                                  <NullNode start="(263, 48)" end="(263, 54)">
                                    <IdentNode start="(263, 48)" end="(263, 50)" leading="" trailing=" " raw_val="a'" val="a'"/>
                                    <TermHoleNode start="(263, 51)" end="(263, 52)">
                                      <AtomNode start="(263, 51)" end="(263, 52)" leading="" trailing=" " val="_"/>
                                    </TermHoleNode>
                                    <IdentNode start="(263, 53)" end="(263, 54)" leading="" trailing=" " raw_val="b" val="b"/>
                                  </NullNode>
                                  <NullNode/>
                                  <AtomNode start="(263, 55)" end="(263, 57)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <OtherNode start="(263, 58)" end="(263, 64)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(263, 58)" end="(263, 59)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <NullNode start="(263, 60)" end="(263, 64)">
                                      <IdentNode start="(263, 60)" end="(263, 62)" leading="" trailing=" " raw_val="a'" val="a'"/>
                                      <IdentNode start="(263, 63)" end="(263, 64)" leading="" trailing="" raw_val="b" val="b"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(263, 64)" end="(263, 65)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <IdentNode start="(263, 66)" end="(263, 67)" leading="" trailing="&#10;  " raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(264, 3)" end="(264, 31)" kind="Lean.Parser.Tactic.simpa" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;b : β&#10;this :&#10;  (forIn' (a :: as) b fun a' x b =&amp;gt; f a' b) = do&#10;    let x ← f a b&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' b&#10;⊢ forIn (a :: as) b f = do&#10;    let x ← f a b&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn as b f" state_after="no goals" tactic="simpa only [forIn'_eq_forIn]">
                    <AtomNode start="(264, 3)" end="(264, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(264, 9)" end="(264, 31)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode start="(264, 9)" end="(264, 13)">
                        <AtomNode start="(264, 9)" end="(264, 13)" leading="" trailing=" " val="only"/>
                      </NullNode>
                      <NullNode start="(264, 14)" end="(264, 31)">
                        <OtherNode start="(264, 14)" end="(264, 31)" kind="Lean.Parser.Tactic.simpArgs">
                          <AtomNode start="(264, 14)" end="(264, 15)" leading="" trailing="" val="["/>
                          <NullNode start="(264, 15)" end="(264, 30)">
                            <OtherNode start="(264, 15)" end="(264, 30)" kind="Lean.Parser.Tactic.simpLemma">
                              <NullNode/>
                              <NullNode/>
                              <IdentNode start="(264, 15)" end="(264, 30)" leading="" trailing="" raw_val="forIn'_eq_forIn" val="forIn'_eq_forIn" full_name="forIn'_eq_forIn" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                            </OtherNode>
                          </NullNode>
                          <AtomNode start="(264, 30)" end="(264, 31)" leading="" trailing="&#10;&#10;" val="]"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(266, 1)" end="(291, 44)" name="forIn'_congr" full_name="List.forIn'_congr">
      <CommandDeclmodifiersNode start="(266, 1)" end="(266, 9)">
        <NullNode/>
        <NullNode start="(266, 1)" end="(266, 9)">
          <OtherNode start="(266, 1)" end="(266, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(266, 1)" end="(266, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(266, 3)" end="(266, 8)">
              <OtherNode start="(266, 3)" end="(266, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(266, 3)" end="(266, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(266, 3)" end="(266, 8)" leading="" trailing="" raw_val="congr" val="congr"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(266, 8)" end="(266, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(266, 10)" end="(291, 44)" name="forIn'_congr" full_name="List.forIn'_congr" _is_private_decl="False">
        <AtomNode start="(266, 10)" end="(266, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(266, 18)" end="(266, 30)">
          <IdentNode start="(266, 18)" end="(266, 30)" leading="" trailing=" " raw_val="forIn'_congr" val="forIn'_congr"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(266, 31)" end="(271, 35)">
          <NullNode start="(266, 31)" end="(270, 58)">
            <OtherNode start="(266, 31)" end="(266, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(266, 31)" end="(266, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(266, 32)" end="(266, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(266, 32)" end="(266, 37)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(266, 38)" end="(266, 39)">
                  <IdentNode start="(266, 38)" end="(266, 39)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(266, 39)" end="(266, 40)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(266, 41)" end="(266, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(266, 41)" end="(266, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(266, 42)" end="(266, 47)">
                <IdentNode start="(266, 42)" end="(266, 44)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(266, 45)" end="(266, 47)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(266, 48)" end="(266, 56)">
                <AtomNode start="(266, 48)" end="(266, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(266, 50)" end="(266, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(266, 50)" end="(266, 54)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(266, 55)" end="(266, 56)">
                    <IdentNode start="(266, 55)" end="(266, 56)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(266, 56)" end="(266, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(266, 58)" end="(266, 71)">
              <AtomNode start="(266, 58)" end="(266, 59)" leading="" trailing="" val="("/>
              <NullNode start="(266, 59)" end="(266, 60)">
                <IdentNode start="(266, 59)" end="(266, 60)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(266, 61)" end="(266, 70)">
                <AtomNode start="(266, 61)" end="(266, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(266, 63)" end="(266, 70)" kind="«term_=_»">
                  <IdentNode start="(266, 63)" end="(266, 65)" leading="" trailing=" " raw_val="as" val="as"/>
                  <AtomNode start="(266, 66)" end="(266, 67)" leading="" trailing=" " val="="/>
                  <IdentNode start="(266, 68)" end="(266, 70)" leading="" trailing="" raw_val="bs" val="bs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(266, 70)" end="(266, 71)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(267, 5)" end="(267, 15)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(267, 5)" end="(267, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(267, 6)" end="(267, 10)">
                <IdentNode start="(267, 6)" end="(267, 7)" leading="" trailing=" " raw_val="b" val="b"/>
                <IdentNode start="(267, 8)" end="(267, 10)" leading="" trailing=" " raw_val="b'" val="b'"/>
              </NullNode>
              <NullNode start="(267, 11)" end="(267, 14)">
                <AtomNode start="(267, 11)" end="(267, 12)" leading="" trailing=" " val=":"/>
                <IdentNode start="(267, 13)" end="(267, 14)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(267, 14)" end="(267, 15)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(267, 16)" end="(267, 29)">
              <AtomNode start="(267, 16)" end="(267, 17)" leading="" trailing="" val="("/>
              <NullNode start="(267, 17)" end="(267, 19)">
                <IdentNode start="(267, 17)" end="(267, 19)" leading="" trailing=" " raw_val="hb" val="hb"/>
              </NullNode>
              <NullNode start="(267, 20)" end="(267, 28)">
                <AtomNode start="(267, 20)" end="(267, 21)" leading="" trailing=" " val=":"/>
                <OtherNode start="(267, 22)" end="(267, 28)" kind="«term_=_»">
                  <IdentNode start="(267, 22)" end="(267, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                  <AtomNode start="(267, 24)" end="(267, 25)" leading="" trailing=" " val="="/>
                  <IdentNode start="(267, 26)" end="(267, 28)" leading="" trailing="" raw_val="b'" val="b'"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(267, 28)" end="(267, 29)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(268, 5)" end="(268, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(268, 5)" end="(268, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(268, 6)" end="(268, 7)">
                <IdentNode start="(268, 6)" end="(268, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(268, 8)" end="(268, 50)">
                <AtomNode start="(268, 8)" end="(268, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(268, 10)" end="(268, 50)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(268, 10)" end="(268, 18)">
                    <AtomNode start="(268, 10)" end="(268, 11)" leading="" trailing="" val="("/>
                    <NullNode start="(268, 11)" end="(268, 13)">
                      <IdentNode start="(268, 11)" end="(268, 13)" leading="" trailing=" " raw_val="a'" val="a'"/>
                    </NullNode>
                    <NullNode start="(268, 14)" end="(268, 17)">
                      <AtomNode start="(268, 14)" end="(268, 15)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(268, 16)" end="(268, 17)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(268, 17)" end="(268, 18)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(268, 19)" end="(268, 20)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(268, 21)" end="(268, 50)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(268, 21)" end="(268, 28)" kind="«term_∈_»">
                      <IdentNode start="(268, 21)" end="(268, 23)" leading="" trailing=" " raw_val="a'" val="a'"/>
                      <AtomNode start="(268, 24)" end="(268, 25)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(268, 26)" end="(268, 28)" leading="" trailing=" " raw_val="as" val="as"/>
                    </OtherNode>
                    <AtomNode start="(268, 29)" end="(268, 30)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(268, 31)" end="(268, 50)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(268, 31)" end="(268, 32)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(268, 33)" end="(268, 34)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(268, 35)" end="(268, 50)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(268, 35)" end="(268, 36)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(268, 37)" end="(268, 50)">
                          <OtherNode start="(268, 37)" end="(268, 50)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(268, 37)" end="(268, 38)" leading="" trailing="" val="("/>
                            <OtherNode start="(268, 38)" end="(268, 49)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(268, 38)" end="(268, 47)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(268, 48)" end="(268, 49)">
                                <IdentNode start="(268, 48)" end="(268, 49)" leading="" trailing="" raw_val="β" val="β"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(268, 49)" end="(268, 50)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(268, 50)" end="(268, 51)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(269, 5)" end="(269, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(269, 5)" end="(269, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(269, 6)" end="(269, 7)">
                <IdentNode start="(269, 6)" end="(269, 7)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(269, 8)" end="(269, 50)">
                <AtomNode start="(269, 8)" end="(269, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(269, 10)" end="(269, 50)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(269, 10)" end="(269, 18)">
                    <AtomNode start="(269, 10)" end="(269, 11)" leading="" trailing="" val="("/>
                    <NullNode start="(269, 11)" end="(269, 13)">
                      <IdentNode start="(269, 11)" end="(269, 13)" leading="" trailing=" " raw_val="a'" val="a'"/>
                    </NullNode>
                    <NullNode start="(269, 14)" end="(269, 17)">
                      <AtomNode start="(269, 14)" end="(269, 15)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(269, 16)" end="(269, 17)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(269, 17)" end="(269, 18)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(269, 19)" end="(269, 20)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(269, 21)" end="(269, 50)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(269, 21)" end="(269, 28)" kind="«term_∈_»">
                      <IdentNode start="(269, 21)" end="(269, 23)" leading="" trailing=" " raw_val="a'" val="a'"/>
                      <AtomNode start="(269, 24)" end="(269, 25)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(269, 26)" end="(269, 28)" leading="" trailing=" " raw_val="bs" val="bs"/>
                    </OtherNode>
                    <AtomNode start="(269, 29)" end="(269, 30)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(269, 31)" end="(269, 50)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(269, 31)" end="(269, 32)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(269, 33)" end="(269, 34)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(269, 35)" end="(269, 50)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(269, 35)" end="(269, 36)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(269, 37)" end="(269, 50)">
                          <OtherNode start="(269, 37)" end="(269, 50)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(269, 37)" end="(269, 38)" leading="" trailing="" val="("/>
                            <OtherNode start="(269, 38)" end="(269, 49)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(269, 38)" end="(269, 47)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(269, 48)" end="(269, 49)">
                                <IdentNode start="(269, 48)" end="(269, 49)" leading="" trailing="" raw_val="β" val="β"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(269, 49)" end="(269, 50)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(269, 50)" end="(269, 51)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(270, 5)" end="(270, 58)">
              <AtomNode start="(270, 5)" end="(270, 6)" leading="" trailing="" val="("/>
              <NullNode start="(270, 6)" end="(270, 7)">
                <IdentNode start="(270, 6)" end="(270, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(270, 8)" end="(270, 57)">
                <AtomNode start="(270, 8)" end="(270, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(270, 10)" end="(270, 57)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(270, 10)" end="(270, 11)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(270, 12)" end="(270, 17)">
                    <IdentNode start="(270, 12)" end="(270, 13)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(270, 14)" end="(270, 15)" leading="" trailing=" " raw_val="m" val="m"/>
                    <IdentNode start="(270, 16)" end="(270, 17)" leading="" trailing="" raw_val="b" val="b"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(270, 17)" end="(270, 18)" leading="" trailing=" " val=","/>
                  <OtherNode start="(270, 19)" end="(270, 57)" kind="«term_=_»">
                    <OtherNode start="(270, 19)" end="(270, 47)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(270, 19)" end="(270, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(270, 21)" end="(270, 47)">
                        <IdentNode start="(270, 21)" end="(270, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                        <OtherNode start="(270, 23)" end="(270, 45)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(270, 23)" end="(270, 24)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(270, 24)" end="(270, 44)">
                            <AtomNode start="(270, 24)" end="(270, 26)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(270, 27)" end="(270, 44)">
                              <TacticTacticseq1IndentedNode start="(270, 27)" end="(270, 44)">
                                <NullNode start="(270, 27)" end="(270, 44)">
                                  <OtherNode start="(270, 27)" end="(270, 44)" kind="Lean.Parser.Tactic.simpa" state_before="m✝ : Type ?u.55669 → Type ?u.55591&#10;α : Type ?u.55596&#10;β : Type ?u.55669&#10;inst✝ : Monad m✝&#10;as bs : List α&#10;w : as = bs&#10;b✝ b' : β&#10;hb : b✝ = b'&#10;f : (a' : α) → a' ∈ as → β → m✝ (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m✝ (ForInStep β)&#10;a : α&#10;m : a ∈ bs&#10;b : β&#10;⊢ a ∈ as" state_after="no goals" tactic="simpa [w] using m">
                                    <AtomNode start="(270, 27)" end="(270, 32)" leading="" trailing=" " val="simpa"/>
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(270, 33)" end="(270, 44)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(270, 33)" end="(270, 36)">
                                        <OtherNode start="(270, 33)" end="(270, 36)" kind="Lean.Parser.Tactic.simpArgs">
                                          <AtomNode start="(270, 33)" end="(270, 34)" leading="" trailing="" val="["/>
                                          <NullNode start="(270, 34)" end="(270, 35)">
                                            <OtherNode start="(270, 34)" end="(270, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(270, 34)" end="(270, 35)" leading="" trailing="" raw_val="w" val="w"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(270, 35)" end="(270, 36)" leading="" trailing=" " val="]"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode start="(270, 37)" end="(270, 44)">
                                        <AtomNode start="(270, 37)" end="(270, 42)" leading="" trailing=" " val="using"/>
                                        <IdentNode start="(270, 43)" end="(270, 44)" leading="" trailing="" raw_val="m" val="m"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(270, 44)" end="(270, 45)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <IdentNode start="(270, 46)" end="(270, 47)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(270, 48)" end="(270, 49)" leading="" trailing=" " val="="/>
                    <OtherNode start="(270, 50)" end="(270, 57)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(270, 50)" end="(270, 51)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(270, 52)" end="(270, 57)">
                        <IdentNode start="(270, 52)" end="(270, 53)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(270, 54)" end="(270, 55)" leading="" trailing=" " raw_val="m" val="m"/>
                        <IdentNode start="(270, 56)" end="(270, 57)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(270, 57)" end="(270, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(270, 59)" end="(271, 35)">
            <AtomNode start="(270, 59)" end="(270, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(271, 5)" end="(271, 35)" kind="«term_=_»">
              <OtherNode start="(271, 5)" end="(271, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(271, 5)" end="(271, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(271, 12)" end="(271, 18)">
                  <IdentNode start="(271, 12)" end="(271, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(271, 15)" end="(271, 16)" leading="" trailing=" " raw_val="b" val="b"/>
                  <IdentNode start="(271, 17)" end="(271, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(271, 19)" end="(271, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(271, 21)" end="(271, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(271, 21)" end="(271, 27)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(271, 28)" end="(271, 35)">
                  <IdentNode start="(271, 28)" end="(271, 30)" leading="" trailing=" " raw_val="bs" val="bs"/>
                  <IdentNode start="(271, 31)" end="(271, 33)" leading="" trailing=" " raw_val="b'" val="b'"/>
                  <IdentNode start="(271, 34)" end="(271, 35)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(271, 36)" end="(291, 44)">
          <AtomNode start="(271, 36)" end="(271, 38)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(271, 39)" end="(291, 44)">
            <AtomNode start="(271, 39)" end="(271, 41)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(272, 3)" end="(291, 44)">
              <TacticTacticseq1IndentedNode start="(272, 3)" end="(291, 44)">
                <NullNode start="(272, 3)" end="(291, 44)">
                  <OtherNode start="(272, 3)" end="(291, 44)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as bs : List α&#10;w : as = bs&#10;b b' : β&#10;hb : b = b'&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ bs) (b : β), f a ⋯ b = g a m_1 b&#10;⊢ forIn' as b f = forIn' bs b' g" state_after="no goals" tactic="induction bs generalizing as b b' with&#10;| nil =&amp;gt;&#10;  subst w&#10;  simp [hb, forIn'_nil]&#10;| cons b bs ih =&amp;gt;&#10;  cases as with&#10;  | nil =&amp;gt; simp at w&#10;  | cons a as =&amp;gt;&#10;    simp only [cons.injEq] at w&#10;    obtain ⟨rfl, rfl⟩ := w&#10;    simp only [forIn'_cons]&#10;    congr 1&#10;    · simp [h, hb]&#10;    · funext s&#10;      obtain b | b := s&#10;      · rfl&#10;      · simp&#10;        rw [ih rfl rfl]&#10;        intro a m b&#10;        exact h a (mem_cons_of_mem _ m) b">
                    <AtomNode start="(272, 3)" end="(272, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(272, 13)" end="(272, 15)">
                      <OtherNode start="(272, 13)" end="(272, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(272, 13)" end="(272, 15)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(272, 16)" end="(272, 36)">
                      <AtomNode start="(272, 16)" end="(272, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(272, 29)" end="(272, 36)">
                        <IdentNode start="(272, 29)" end="(272, 31)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(272, 32)" end="(272, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(272, 34)" end="(272, 36)" leading="" trailing=" " raw_val="b'" val="b'"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(272, 37)" end="(291, 44)">
                      <OtherNode start="(272, 37)" end="(291, 44)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(272, 37)" end="(272, 41)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(273, 3)" end="(291, 44)">
                          <OtherNode start="(273, 3)" end="(275, 26)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(273, 3)" end="(273, 8)">
                              <OtherNode start="(273, 3)" end="(273, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(273, 3)" end="(273, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(273, 5)" end="(273, 8)">
                                  <NullNode/>
                                  <IdentNode start="(273, 5)" end="(273, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(273, 9)" end="(275, 26)">
                              <AtomNode start="(273, 9)" end="(273, 11)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(274, 5)" end="(275, 26)">
                                <TacticTacticseq1IndentedNode start="(274, 5)" end="(275, 26)">
                                  <NullNode start="(274, 5)" end="(275, 26)">
                                    <OtherNode start="(274, 5)" end="(274, 12)" kind="Lean.Parser.Tactic.subst" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;as : List α&#10;w : as = []&#10;b b' : β&#10;hb : b = b'&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ [] → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ []) (b : β), f a ⋯ b = g a m_1 b&#10;⊢ forIn' as b f = forIn' [] b' g" state_after="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;g f : (a' : α) → a' ∈ [] → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ []) (b : β), f a ⋯ b = g a m_1 b&#10;⊢ forIn' [] b f = forIn' [] b' g" tactic="subst w">
                                      <AtomNode start="(274, 5)" end="(274, 10)" leading="" trailing=" " val="subst"/>
                                      <NullNode start="(274, 11)" end="(274, 12)">
                                        <IdentNode start="(274, 11)" end="(274, 12)" leading="" trailing="&#10;    " raw_val="w" val="w"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(275, 5)" end="(275, 26)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;g f : (a' : α) → a' ∈ [] → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ []) (b : β), f a ⋯ b = g a m_1 b&#10;⊢ forIn' [] b f = forIn' [] b' g" state_after="no goals" tactic="simp [hb, forIn'_nil]">
                                      <AtomNode start="(275, 5)" end="(275, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(275, 10)" end="(275, 26)">
                                        <AtomNode start="(275, 10)" end="(275, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(275, 11)" end="(275, 25)">
                                          <OtherNode start="(275, 11)" end="(275, 13)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(275, 11)" end="(275, 13)" leading="" trailing="" raw_val="hb" val="hb"/>
                                          </OtherNode>
                                          <AtomNode start="(275, 13)" end="(275, 14)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(275, 15)" end="(275, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(275, 15)" end="(275, 25)" leading="" trailing="" raw_val="forIn'_nil" val="forIn'_nil" full_name="List.forIn'_nil" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(275, 25)" end="(275, 26)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(276, 3)" end="(291, 44)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(276, 3)" end="(276, 17)">
                              <OtherNode start="(276, 3)" end="(276, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(276, 3)" end="(276, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(276, 5)" end="(276, 9)">
                                  <NullNode/>
                                  <IdentNode start="(276, 5)" end="(276, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(276, 10)" end="(276, 17)">
                                  <IdentNode start="(276, 10)" end="(276, 11)" leading="" trailing=" " raw_val="b" val="b"/>
                                  <IdentNode start="(276, 12)" end="(276, 14)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                  <IdentNode start="(276, 15)" end="(276, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(276, 18)" end="(291, 44)">
                              <AtomNode start="(276, 18)" end="(276, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(277, 5)" end="(291, 44)">
                                <TacticTacticseq1IndentedNode start="(277, 5)" end="(291, 44)">
                                  <NullNode start="(277, 5)" end="(291, 44)">
                                    <OtherNode start="(277, 5)" end="(291, 44)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ : α&#10;bs : List α&#10;ih :&#10;  ∀ {as : List α} (w : as = bs) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as → β → m (ForInStep β)} {g : (a' : α) → a' ∈ bs → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ bs) (b : β), f a ⋯ b = g a m_1 b) → forIn' as b f = forIn' bs b' g&#10;as : List α&#10;w : as = b✝ :: bs&#10;b b' : β&#10;hb : b = b'&#10;f : (a' : α) → a' ∈ as → β → m (ForInStep β)&#10;g : (a' : α) → a' ∈ b✝ :: bs → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ b✝ :: bs) (b : β), f a ⋯ b = g a m_1 b&#10;⊢ forIn' as b f = forIn' (b✝ :: bs) b' g" state_after="no goals" tactic="cases as with&#10;| nil =&amp;gt; simp at w&#10;| cons a as =&amp;gt;&#10;  simp only [cons.injEq] at w&#10;  obtain ⟨rfl, rfl⟩ := w&#10;  simp only [forIn'_cons]&#10;  congr 1&#10;  · simp [h, hb]&#10;  · funext s&#10;    obtain b | b := s&#10;    · rfl&#10;    · simp&#10;      rw [ih rfl rfl]&#10;      intro a m b&#10;      exact h a (mem_cons_of_mem _ m) b">
                                      <AtomNode start="(277, 5)" end="(277, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(277, 11)" end="(277, 13)">
                                        <OtherNode start="(277, 11)" end="(277, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(277, 11)" end="(277, 13)" leading="" trailing=" " raw_val="as" val="as"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(277, 14)" end="(291, 44)">
                                        <OtherNode start="(277, 14)" end="(291, 44)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(277, 14)" end="(277, 18)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(278, 5)" end="(291, 44)">
                                            <OtherNode start="(278, 5)" end="(278, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(278, 5)" end="(278, 10)">
                                                <OtherNode start="(278, 5)" end="(278, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(278, 5)" end="(278, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(278, 7)" end="(278, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(278, 7)" end="(278, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(278, 11)" end="(278, 23)">
                                                <AtomNode start="(278, 11)" end="(278, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(278, 14)" end="(278, 23)">
                                                  <TacticTacticseq1IndentedNode start="(278, 14)" end="(278, 23)">
                                                    <NullNode start="(278, 14)" end="(278, 23)">
                                                      <OtherNode start="(278, 14)" end="(278, 23)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ : α&#10;bs : List α&#10;ih :&#10;  ∀ {as : List α} (w : as = bs) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as → β → m (ForInStep β)} {g : (a' : α) → a' ∈ bs → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ bs) (b : β), f a ⋯ b = g a m_1 b) → forIn' as b f = forIn' bs b' g&#10;b b' : β&#10;hb : b = b'&#10;g : (a' : α) → a' ∈ b✝ :: bs → β → m (ForInStep β)&#10;w : [] = b✝ :: bs&#10;f : (a' : α) → a' ∈ [] → β → m (ForInStep β)&#10;h : ∀ (a : α) (m_1 : a ∈ b✝ :: bs) (b : β), f a ⋯ b = g a m_1 b&#10;⊢ forIn' [] b f = forIn' (b✝ :: bs) b' g" state_after="no goals" tactic="simp at w">
                                                        <AtomNode start="(278, 14)" end="(278, 18)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(278, 19)" end="(278, 23)">
                                                          <OtherNode start="(278, 19)" end="(278, 23)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(278, 19)" end="(278, 21)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(278, 22)" end="(278, 23)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(278, 22)" end="(278, 23)">
                                                            <IdentNode start="(278, 22)" end="(278, 23)" leading="" trailing="&#10;    " raw_val="w" val="w"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(279, 5)" end="(291, 44)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(279, 5)" end="(279, 16)">
                                                <OtherNode start="(279, 5)" end="(279, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(279, 5)" end="(279, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(279, 7)" end="(279, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(279, 7)" end="(279, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(279, 12)" end="(279, 16)">
                                                    <IdentNode start="(279, 12)" end="(279, 13)" leading="" trailing=" " raw_val="a" val="a"/>
                                                    <IdentNode start="(279, 14)" end="(279, 16)" leading="" trailing=" " raw_val="as" val="as"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(279, 17)" end="(291, 44)">
                                                <AtomNode start="(279, 17)" end="(279, 19)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(280, 7)" end="(291, 44)">
                                                  <TacticTacticseq1IndentedNode start="(280, 7)" end="(291, 44)">
                                                    <NullNode start="(280, 7)" end="(291, 44)">
                                                      <OtherNode start="(280, 7)" end="(280, 34)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ : α&#10;bs : List α&#10;ih :&#10;  ∀ {as : List α} (w : as = bs) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as → β → m (ForInStep β)} {g : (a' : α) → a' ∈ bs → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ bs) (b : β), f a ⋯ b = g a m_1 b) → forIn' as b f = forIn' bs b' g&#10;b b' : β&#10;hb : b = b'&#10;g : (a' : α) → a' ∈ b✝ :: bs → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;w : a :: as = b✝ :: bs&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ b✝ :: bs) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;⊢ forIn' (a :: as) b f = forIn' (b✝ :: bs) b' g" state_after="case cons.cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ : α&#10;bs : List α&#10;ih :&#10;  ∀ {as : List α} (w : as = bs) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as → β → m (ForInStep β)} {g : (a' : α) → a' ∈ bs → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ bs) (b : β), f a ⋯ b = g a m_1 b) → forIn' as b f = forIn' bs b' g&#10;b b' : β&#10;hb : b = b'&#10;g : (a' : α) → a' ∈ b✝ :: bs → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;w✝ : a :: as = b✝ :: bs&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ b✝ :: bs) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;w : a = b✝ ∧ as = bs&#10;⊢ forIn' (a :: as) b f = forIn' (b✝ :: bs) b' g" tactic="simp only [cons.injEq] at w">
                                                        <AtomNode start="(280, 7)" end="(280, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode start="(280, 12)" end="(280, 16)">
                                                          <AtomNode start="(280, 12)" end="(280, 16)" leading="" trailing=" " val="only"/>
                                                        </NullNode>
                                                        <NullNode start="(280, 17)" end="(280, 29)">
                                                          <AtomNode start="(280, 17)" end="(280, 18)" leading="" trailing="" val="["/>
                                                          <NullNode start="(280, 18)" end="(280, 28)">
                                                            <OtherNode start="(280, 18)" end="(280, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(280, 18)" end="(280, 28)" leading="" trailing="" raw_val="cons.injEq" val="cons.injEq" full_name="List.cons.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(280, 28)" end="(280, 29)" leading="" trailing=" " val="]"/>
                                                        </NullNode>
                                                        <NullNode start="(280, 30)" end="(280, 34)">
                                                          <OtherNode start="(280, 30)" end="(280, 34)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(280, 30)" end="(280, 32)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(280, 33)" end="(280, 34)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(280, 33)" end="(280, 34)">
                                                            <IdentNode start="(280, 33)" end="(280, 34)" leading="" trailing="&#10;      " raw_val="w" val="w"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(281, 7)" end="(281, 29)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ : α&#10;bs : List α&#10;ih :&#10;  ∀ {as : List α} (w : as = bs) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as → β → m (ForInStep β)} {g : (a' : α) → a' ∈ bs → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ bs) (b : β), f a ⋯ b = g a m_1 b) → forIn' as b f = forIn' bs b' g&#10;b b' : β&#10;hb : b = b'&#10;g : (a' : α) → a' ∈ b✝ :: bs → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;w✝ : a :: as = b✝ :: bs&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ b✝ :: bs) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;w : a = b✝ ∧ as = bs&#10;⊢ forIn' (a :: as) b f = forIn' (b✝ :: bs) b' g" state_after="case cons.cons.intro&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;⊢ forIn' (a :: as) b f = forIn' (a :: as) b' g" tactic="obtain ⟨rfl, rfl⟩ := w">
                                                        <AtomNode start="(281, 7)" end="(281, 13)" leading="" trailing=" " val="obtain"/>
                                                        <NullNode start="(281, 14)" end="(281, 24)">
                                                          <OtherNode start="(281, 14)" end="(281, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(281, 14)" end="(281, 24)">
                                                            <OtherNode start="(281, 14)" end="(281, 24)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(281, 14)" end="(281, 15)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(281, 15)" end="(281, 23)">
                                                            <OtherNode start="(281, 15)" end="(281, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(281, 15)" end="(281, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(281, 15)" end="(281, 18)">
                                                            <OtherNode start="(281, 15)" end="(281, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(281, 15)" end="(281, 18)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(281, 18)" end="(281, 19)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(281, 20)" end="(281, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(281, 20)" end="(281, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(281, 20)" end="(281, 23)">
                                                            <OtherNode start="(281, 20)" end="(281, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(281, 20)" end="(281, 23)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(281, 23)" end="(281, 24)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <NullNode/>
                                                        <NullNode start="(281, 25)" end="(281, 29)">
                                                          <AtomNode start="(281, 25)" end="(281, 27)" leading="" trailing=" " val=":="/>
                                                          <NullNode start="(281, 28)" end="(281, 29)">
                                                            <IdentNode start="(281, 28)" end="(281, 29)" leading="" trailing="&#10;      " raw_val="w" val="w"/>
                                                          </NullNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(282, 7)" end="(282, 30)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.intro&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;⊢ forIn' (a :: as) b f = forIn' (a :: as) b' g" state_after="case cons.cons.intro&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;⊢ (do&#10;      let x ← f a ⋯ b&#10;      match x with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    do&#10;    let x ← g a ⋯ b'&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" tactic="simp only [forIn'_cons]">
                                                        <AtomNode start="(282, 7)" end="(282, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode start="(282, 12)" end="(282, 16)">
                                                          <AtomNode start="(282, 12)" end="(282, 16)" leading="" trailing=" " val="only"/>
                                                        </NullNode>
                                                        <NullNode start="(282, 17)" end="(282, 30)">
                                                          <AtomNode start="(282, 17)" end="(282, 18)" leading="" trailing="" val="["/>
                                                          <NullNode start="(282, 18)" end="(282, 29)">
                                                            <OtherNode start="(282, 18)" end="(282, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(282, 18)" end="(282, 29)" leading="" trailing="" raw_val="forIn'_cons" val="forIn'_cons" full_name="List.forIn'_cons" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(248, 17)" def_end="(248, 28)"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(282, 29)" end="(282, 30)" leading="" trailing="&#10;      " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(283, 7)" end="(283, 14)" kind="Lean.Parser.Tactic.congr" state_before="case cons.cons.intro&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;⊢ (do&#10;      let x ← f a ⋯ b&#10;      match x with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    do&#10;    let x ← g a ⋯ b'&#10;    match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" state_after="case cons.cons.intro.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;⊢ f a ⋯ b = g a ⋯ b'&#10;&#10;case cons.cons.intro.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;⊢ (fun x =&amp;gt;&#10;      match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    fun x =&amp;gt;&#10;    match x with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" tactic="congr 1">
                                                        <AtomNode start="(283, 7)" end="(283, 12)" leading="" trailing=" " val="congr"/>
                                                        <NullNode start="(283, 13)" end="(283, 14)">
                                                          <OtherNode start="(283, 13)" end="(283, 14)" kind="num">
                                                            <AtomNode start="(283, 13)" end="(283, 14)" leading="" trailing="&#10;      " val="1"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(284, 7)" end="(284, 21)" kind="Lean.cdot" state_before="case cons.cons.intro.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;⊢ f a ⋯ b = g a ⋯ b'&#10;&#10;case cons.cons.intro.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;⊢ (fun x =&amp;gt;&#10;      match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    fun x =&amp;gt;&#10;    match x with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" state_after="case cons.cons.intro.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;⊢ (fun x =&amp;gt;&#10;      match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    fun x =&amp;gt;&#10;    match x with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" tactic="· simp [h, hb]">
                                                        <OtherNode start="(284, 7)" end="(284, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(284, 7)" end="(284, 8)" kind="patternIgnore">
                                                            <OtherNode start="(284, 7)" end="(284, 8)" kind="token.«· »">
                                                            <AtomNode start="(284, 7)" end="(284, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(284, 9)" end="(284, 21)">
                                                          <TacticTacticseq1IndentedNode start="(284, 9)" end="(284, 21)">
                                                            <NullNode start="(284, 9)" end="(284, 21)">
                                                            <OtherNode start="(284, 9)" end="(284, 21)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.intro.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;⊢ f a ⋯ b = g a ⋯ b'" state_after="no goals" tactic="simp [h, hb]">
                                                            <AtomNode start="(284, 9)" end="(284, 13)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(284, 14)" end="(284, 21)">
                                                            <AtomNode start="(284, 14)" end="(284, 15)" leading="" trailing="" val="["/>
                                                            <NullNode start="(284, 15)" end="(284, 20)">
                                                            <OtherNode start="(284, 15)" end="(284, 16)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(284, 15)" end="(284, 16)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            <AtomNode start="(284, 16)" end="(284, 17)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(284, 18)" end="(284, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(284, 18)" end="(284, 20)" leading="" trailing="" raw_val="hb" val="hb"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(284, 20)" end="(284, 21)" leading="" trailing="&#10;      " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(285, 7)" end="(291, 44)" kind="Lean.cdot" state_before="case cons.cons.intro.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;⊢ (fun x =&amp;gt;&#10;      match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    fun x =&amp;gt;&#10;    match x with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" state_after="no goals" tactic="· funext s&#10;  obtain b | b := s&#10;  · rfl&#10;  · simp&#10;    rw [ih rfl rfl]&#10;    intro a m b&#10;    exact h a (mem_cons_of_mem _ m) b">
                                                        <OtherNode start="(285, 7)" end="(285, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(285, 7)" end="(285, 8)" kind="patternIgnore">
                                                            <OtherNode start="(285, 7)" end="(285, 8)" kind="token.«· »">
                                                            <AtomNode start="(285, 7)" end="(285, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(285, 9)" end="(291, 44)">
                                                          <TacticTacticseq1IndentedNode start="(285, 9)" end="(291, 44)">
                                                            <NullNode start="(285, 9)" end="(291, 44)">
                                                            <OtherNode start="(285, 9)" end="(285, 17)" kind="tacticFunext___" state_before="case cons.cons.intro.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;⊢ (fun x =&amp;gt;&#10;      match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    fun x =&amp;gt;&#10;    match x with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" state_after="case cons.cons.intro.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;s : ForInStep β&#10;⊢ (match s with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    match s with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" tactic="funext s">
                                                            <AtomNode start="(285, 9)" end="(285, 15)" leading="" trailing=" " val="funext"/>
                                                            <NullNode start="(285, 16)" end="(285, 17)">
                                                            <IdentNode start="(285, 16)" end="(285, 17)" leading="" trailing="&#10;        " raw_val="s" val="s"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(286, 9)" end="(286, 26)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.cons.intro.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b b' : β&#10;hb : b = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;s : ForInStep β&#10;⊢ (match s with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    match s with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" state_after="case cons.cons.intro.e_a.h.done&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ b' : β&#10;hb : b✝ = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b&#10;&#10;case cons.cons.intro.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ b' : β&#10;hb : b✝ = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" tactic="obtain b | b := s">
                                                            <AtomNode start="(286, 9)" end="(286, 15)" leading="" trailing=" " val="obtain"/>
                                                            <NullNode start="(286, 16)" end="(286, 21)">
                                                            <OtherNode start="(286, 16)" end="(286, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(286, 16)" end="(286, 21)">
                                                            <OtherNode start="(286, 16)" end="(286, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(286, 16)" end="(286, 17)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            </OtherNode>
                                                            <AtomNode start="(286, 18)" end="(286, 19)" leading="" trailing=" " val="|"/>
                                                            <OtherNode start="(286, 20)" end="(286, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(286, 20)" end="(286, 21)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode start="(286, 22)" end="(286, 26)">
                                                            <AtomNode start="(286, 22)" end="(286, 24)" leading="" trailing=" " val=":="/>
                                                            <NullNode start="(286, 25)" end="(286, 26)">
                                                            <IdentNode start="(286, 25)" end="(286, 26)" leading="" trailing="&#10;        " raw_val="s" val="s"/>
                                                            </NullNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(287, 9)" end="(287, 14)" kind="Lean.cdot" state_before="case cons.cons.intro.e_a.h.done&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ b' : β&#10;hb : b✝ = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b&#10;&#10;case cons.cons.intro.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ b' : β&#10;hb : b✝ = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" state_after="case cons.cons.intro.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ b' : β&#10;hb : b✝ = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" tactic="· rfl">
                                                            <OtherNode start="(287, 9)" end="(287, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(287, 9)" end="(287, 10)" kind="patternIgnore">
                                                            <OtherNode start="(287, 9)" end="(287, 10)" kind="token.«· »">
                                                            <AtomNode start="(287, 9)" end="(287, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(287, 11)" end="(287, 14)">
                                                            <TacticTacticseq1IndentedNode start="(287, 11)" end="(287, 14)">
                                                            <NullNode start="(287, 11)" end="(287, 14)">
                                                            <OtherNode start="(287, 11)" end="(287, 14)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case cons.cons.intro.e_a.h.done&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ b' : β&#10;hb : b✝ = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" state_after="no goals" tactic="rfl">
                                                            <AtomNode start="(287, 11)" end="(287, 14)" leading="" trailing="&#10;        " val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(288, 9)" end="(291, 44)" kind="Lean.cdot" state_before="case cons.cons.intro.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ b' : β&#10;hb : b✝ = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" state_after="no goals" tactic="· simp&#10;  rw [ih rfl rfl]&#10;  intro a m b&#10;  exact h a (mem_cons_of_mem _ m) b">
                                                            <OtherNode start="(288, 9)" end="(288, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(288, 9)" end="(288, 10)" kind="patternIgnore">
                                                            <OtherNode start="(288, 9)" end="(288, 10)" kind="token.«· »">
                                                            <AtomNode start="(288, 9)" end="(288, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(288, 11)" end="(291, 44)">
                                                            <TacticTacticseq1IndentedNode start="(288, 11)" end="(291, 44)">
                                                            <NullNode start="(288, 11)" end="(291, 44)">
                                                            <OtherNode start="(288, 11)" end="(288, 15)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.intro.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ b' : β&#10;hb : b✝ = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" state_after="case cons.cons.intro.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ b' : β&#10;hb : b✝ = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;b : β&#10;⊢ (forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) = forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" tactic="simp">
                                                            <AtomNode start="(288, 11)" end="(288, 15)" leading="" trailing="&#10;          " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(289, 11)" end="(289, 26)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.cons.intro.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ b' : β&#10;hb : b✝ = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;b : β&#10;⊢ (forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) = forIn' as b fun a' m b =&amp;gt; g a' ⋯ b" state_after="case cons.cons.intro.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ b' : β&#10;hb : b✝ = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;b : β&#10;⊢ ∀ (a_1 : α) (m_1 : a_1 ∈ as) (b : β), f a_1 ⋯ b = g a_1 ⋯ b" tactic="rw [ih rfl rfl]">
                                                            <AtomNode start="(289, 11)" end="(289, 13)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(289, 14)" end="(289, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(289, 14)" end="(289, 15)" leading="" trailing="" val="["/>
                                                            <NullNode start="(289, 15)" end="(289, 25)">
                                                            <OtherNode start="(289, 15)" end="(289, 25)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <OtherNode start="(289, 15)" end="(289, 25)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(289, 15)" end="(289, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(289, 18)" end="(289, 25)">
                                                            <IdentNode start="(289, 18)" end="(289, 21)" leading="" trailing=" " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            <IdentNode start="(289, 22)" end="(289, 25)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(289, 25)" end="(289, 26)" leading="" trailing="&#10;          " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(290, 11)" end="(290, 22)" kind="Lean.Parser.Tactic.intro" state_before="case cons.cons.intro.e_a.h.yield&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;b✝ b' : β&#10;hb : b✝ = b'&#10;a : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m (ForInStep β)},&#10;        (∀ (a : α) (m_1 : a ∈ as) (b : β), f a ⋯ b = g a m_1 b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a :: as → β → m (ForInStep β)&#10;w : a :: as = a :: as&#10;h : ∀ (a_1 : α) (m_1 : a_1 ∈ a :: as) (b : β), f a_1 ⋯ b = g a_1 m_1 b&#10;b : β&#10;⊢ ∀ (a_1 : α) (m_1 : a_1 ∈ as) (b : β), f a_1 ⋯ b = g a_1 ⋯ b" state_after="case cons.cons.intro.e_a.h.yield&#10;m✝ : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m✝&#10;b✝¹ b' : β&#10;hb : b✝¹ = b'&#10;a✝ : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a✝ :: as → β → m✝ (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m✝ (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m✝ (ForInStep β)},&#10;        (∀ (a : α) (m : a ∈ as) (b : β), f a ⋯ b = g a m b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a✝ :: as → β → m✝ (ForInStep β)&#10;w : a✝ :: as = a✝ :: as&#10;h : ∀ (a : α) (m : a ∈ a✝ :: as) (b : β), f a ⋯ b = g a m b&#10;b✝ : β&#10;a : α&#10;m : a ∈ as&#10;b : β&#10;⊢ f a ⋯ b = g a ⋯ b" tactic="intro a m b">
                                                            <AtomNode start="(290, 11)" end="(290, 16)" leading="" trailing=" " val="intro"/>
                                                            <NullNode start="(290, 17)" end="(290, 22)">
                                                            <IdentNode start="(290, 17)" end="(290, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <IdentNode start="(290, 19)" end="(290, 20)" leading="" trailing=" " raw_val="m" val="m"/>
                                                            <IdentNode start="(290, 21)" end="(290, 22)" leading="" trailing="&#10;          " raw_val="b" val="b"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(291, 11)" end="(291, 44)" kind="Lean.Parser.Tactic.exact" state_before="case cons.cons.intro.e_a.h.yield&#10;m✝ : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m✝&#10;b✝¹ b' : β&#10;hb : b✝¹ = b'&#10;a✝ : α&#10;as : List α&#10;f : (a' : α) → a' ∈ a✝ :: as → β → m✝ (ForInStep β)&#10;ih :&#10;  ∀ {as_1 : List α} (w : as_1 = as) {b b' : β},&#10;    b = b' →&#10;      ∀ {f : (a' : α) → a' ∈ as_1 → β → m✝ (ForInStep β)} {g : (a' : α) → a' ∈ as → β → m✝ (ForInStep β)},&#10;        (∀ (a : α) (m : a ∈ as) (b : β), f a ⋯ b = g a m b) → forIn' as_1 b f = forIn' as b' g&#10;g : (a' : α) → a' ∈ a✝ :: as → β → m✝ (ForInStep β)&#10;w : a✝ :: as = a✝ :: as&#10;h : ∀ (a : α) (m : a ∈ a✝ :: as) (b : β), f a ⋯ b = g a m b&#10;b✝ : β&#10;a : α&#10;m : a ∈ as&#10;b : β&#10;⊢ f a ⋯ b = g a ⋯ b" state_after="no goals" tactic="exact h a (mem_cons_of_mem _ m) b">
                                                            <AtomNode start="(291, 11)" end="(291, 16)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(291, 17)" end="(291, 44)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(291, 17)" end="(291, 18)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <NullNode start="(291, 19)" end="(291, 44)">
                                                            <IdentNode start="(291, 19)" end="(291, 20)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <OtherNode start="(291, 21)" end="(291, 42)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(291, 21)" end="(291, 22)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(291, 22)" end="(291, 41)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(291, 22)" end="(291, 37)" leading="" trailing=" " raw_val="mem_cons_of_mem" val="mem_cons_of_mem" full_name="List.mem_cons_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            <NullNode start="(291, 38)" end="(291, 41)">
                                                            <TermHoleNode start="(291, 38)" end="(291, 39)">
                                                            <AtomNode start="(291, 38)" end="(291, 39)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(291, 40)" end="(291, 41)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(291, 41)" end="(291, 42)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <IdentNode start="(291, 43)" end="(291, 44)" leading="" trailing="&#10;&#10;" raw_val="b" val="b"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(293, 1)" end="(324, 33)" name="forIn'_eq_foldlM" full_name="List.forIn'_eq_foldlM">
      <CommandDeclmodifiersNode start="(293, 1)" end="(296, 3)">
        <NullNode start="(293, 1)" end="(296, 3)">
          <CommandDoccommentNode start="(293, 1)" end="(296, 3)" comment="We can express a for loop over a list as a fold,&#10;in which whenever we reach `.done b` we keep that value through the rest of the fold.&#10;-/">
            <AtomNode start="(293, 1)" end="(293, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(294, 1)" end="(296, 3)" leading="" trailing="&#10;" val="We can express a for loop over a list as a fold,&#10;in which whenever we reach `.done b` we keep that value through the rest of the fold.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(297, 1)" end="(324, 33)" name="forIn'_eq_foldlM" full_name="List.forIn'_eq_foldlM" _is_private_decl="False">
        <AtomNode start="(297, 1)" end="(297, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(297, 9)" end="(297, 25)">
          <IdentNode start="(297, 9)" end="(297, 25)" leading="" trailing=" " raw_val="forIn'_eq_foldlM" val="forIn'_eq_foldlM"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(297, 26)" end="(302, 60)">
          <NullNode start="(297, 26)" end="(298, 72)">
            <OtherNode start="(297, 26)" end="(297, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(297, 26)" end="(297, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(297, 27)" end="(297, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(297, 27)" end="(297, 32)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(297, 33)" end="(297, 34)">
                  <IdentNode start="(297, 33)" end="(297, 34)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(297, 34)" end="(297, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(297, 36)" end="(297, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(297, 36)" end="(297, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(297, 37)" end="(297, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(297, 37)" end="(297, 48)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(297, 49)" end="(297, 50)">
                  <IdentNode start="(297, 49)" end="(297, 50)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(297, 50)" end="(297, 51)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(298, 5)" end="(298, 17)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(298, 5)" end="(298, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(298, 6)" end="(298, 7)">
                <IdentNode start="(298, 6)" end="(298, 7)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(298, 8)" end="(298, 16)">
                <AtomNode start="(298, 8)" end="(298, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(298, 10)" end="(298, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(298, 10)" end="(298, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(298, 15)" end="(298, 16)">
                    <IdentNode start="(298, 15)" end="(298, 16)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(298, 16)" end="(298, 17)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(298, 18)" end="(298, 61)">
              <AtomNode start="(298, 18)" end="(298, 19)" leading="" trailing="" val="("/>
              <NullNode start="(298, 19)" end="(298, 20)">
                <IdentNode start="(298, 19)" end="(298, 20)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(298, 21)" end="(298, 60)">
                <AtomNode start="(298, 21)" end="(298, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(298, 23)" end="(298, 60)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(298, 23)" end="(298, 30)">
                    <AtomNode start="(298, 23)" end="(298, 24)" leading="" trailing="" val="("/>
                    <NullNode start="(298, 24)" end="(298, 25)">
                      <IdentNode start="(298, 24)" end="(298, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(298, 26)" end="(298, 29)">
                      <AtomNode start="(298, 26)" end="(298, 27)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(298, 28)" end="(298, 29)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(298, 29)" end="(298, 30)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(298, 31)" end="(298, 32)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(298, 33)" end="(298, 60)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(298, 33)" end="(298, 38)" kind="«term_∈_»">
                      <IdentNode start="(298, 33)" end="(298, 34)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(298, 35)" end="(298, 36)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(298, 37)" end="(298, 38)" leading="" trailing=" " raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(298, 39)" end="(298, 40)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(298, 41)" end="(298, 60)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(298, 41)" end="(298, 42)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(298, 43)" end="(298, 44)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(298, 45)" end="(298, 60)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(298, 45)" end="(298, 46)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(298, 47)" end="(298, 60)">
                          <OtherNode start="(298, 47)" end="(298, 60)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(298, 47)" end="(298, 48)" leading="" trailing="" val="("/>
                            <OtherNode start="(298, 48)" end="(298, 59)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(298, 48)" end="(298, 57)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(298, 58)" end="(298, 59)">
                                <IdentNode start="(298, 58)" end="(298, 59)" leading="" trailing="" raw_val="β" val="β"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(298, 59)" end="(298, 60)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(298, 60)" end="(298, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(298, 62)" end="(298, 72)">
              <AtomNode start="(298, 62)" end="(298, 63)" leading="" trailing="" val="("/>
              <NullNode start="(298, 63)" end="(298, 67)">
                <IdentNode start="(298, 63)" end="(298, 67)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(298, 68)" end="(298, 71)">
                <AtomNode start="(298, 68)" end="(298, 69)" leading="" trailing=" " val=":"/>
                <IdentNode start="(298, 70)" end="(298, 71)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(298, 71)" end="(298, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(298, 73)" end="(302, 60)">
            <AtomNode start="(298, 73)" end="(298, 74)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(299, 5)" end="(302, 60)" kind="«term_=_»">
              <OtherNode start="(299, 5)" end="(299, 20)" kind="Lean.Parser.Term.app">
                <IdentNode start="(299, 5)" end="(299, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(299, 12)" end="(299, 20)">
                  <IdentNode start="(299, 12)" end="(299, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(299, 14)" end="(299, 18)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(299, 19)" end="(299, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(299, 21)" end="(299, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(299, 23)" end="(302, 60)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(299, 23)" end="(299, 38)" leading="" trailing=" " raw_val="ForInStep.value" val="ForInStep.value" full_name="ForInStep.value" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <AtomNode start="(299, 39)" end="(299, 42)" leading="" trailing="&#10;      " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(300, 7)" end="(302, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(300, 7)" end="(300, 22)" leading="" trailing=" " raw_val="l.attach.foldlM" val="l.attach.foldlM"/>
                  <NullNode start="(300, 23)" end="(302, 60)">
                    <OtherNode start="(300, 23)" end="(302, 37)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(300, 23)" end="(300, 24)" leading="" trailing="" val="("/>
                      <OtherNode start="(300, 24)" end="(302, 36)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(300, 24)" end="(300, 27)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(300, 28)" end="(302, 36)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(300, 28)" end="(300, 36)">
                            <IdentNode start="(300, 28)" end="(300, 29)" leading="" trailing=" " raw_val="b" val="b"/>
                            <OtherNode start="(300, 30)" end="(300, 36)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(300, 30)" end="(300, 31)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(300, 31)" end="(300, 35)">
                                <IdentNode start="(300, 31)" end="(300, 32)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(300, 32)" end="(300, 33)" leading="" trailing=" " val=","/>
                                <IdentNode start="(300, 34)" end="(300, 35)" leading="" trailing="" raw_val="m" val="m"/>
                              </NullNode>
                              <AtomNode start="(300, 35)" end="(300, 36)" leading="" trailing=" " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(300, 37)" end="(300, 39)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(300, 40)" end="(302, 36)" kind="Lean.Parser.Term.match">
                            <AtomNode start="(300, 40)" end="(300, 45)" leading="" trailing=" " val="match"/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(300, 46)" end="(300, 47)">
                              <OtherNode start="(300, 46)" end="(300, 47)" kind="Lean.Parser.Term.matchDiscr">
                                <NullNode/>
                                <IdentNode start="(300, 46)" end="(300, 47)" leading="" trailing=" " raw_val="b" val="b"/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(300, 48)" end="(300, 52)" leading="" trailing="&#10;        " val="with"/>
                            <OtherNode start="(301, 9)" end="(302, 36)" kind="Lean.Parser.Term.matchAlts">
                              <NullNode start="(301, 9)" end="(302, 36)">
                                <OtherNode start="(301, 9)" end="(301, 30)" kind="Lean.Parser.Term.matchAlt">
                                  <AtomNode start="(301, 9)" end="(301, 10)" leading="" trailing=" " val="|"/>
                                  <NullNode start="(301, 11)" end="(301, 19)">
                                    <NullNode start="(301, 11)" end="(301, 19)">
                                      <OtherNode start="(301, 11)" end="(301, 19)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(301, 11)" end="(301, 17)" kind="Lean.Parser.Term.dotIdent">
                                          <AtomNode start="(301, 11)" end="(301, 12)" leading="" trailing="" val="."/>
                                          <IdentNode start="(301, 12)" end="(301, 17)" leading="" trailing=" " raw_val="yield" val="yield"/>
                                        </OtherNode>
                                        <NullNode start="(301, 18)" end="(301, 19)">
                                          <IdentNode start="(301, 18)" end="(301, 19)" leading="" trailing=" " raw_val="b" val="b"/>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(301, 20)" end="(301, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <OtherNode start="(301, 23)" end="(301, 30)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(301, 23)" end="(301, 24)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <NullNode start="(301, 25)" end="(301, 30)">
                                      <IdentNode start="(301, 25)" end="(301, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                                      <IdentNode start="(301, 27)" end="(301, 28)" leading="" trailing=" " raw_val="m" val="m"/>
                                      <IdentNode start="(301, 29)" end="(301, 30)" leading="" trailing="&#10;        " raw_val="b" val="b"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <OtherNode start="(302, 9)" end="(302, 36)" kind="Lean.Parser.Term.matchAlt">
                                  <AtomNode start="(302, 9)" end="(302, 10)" leading="" trailing=" " val="|"/>
                                  <NullNode start="(302, 11)" end="(302, 18)">
                                    <NullNode start="(302, 11)" end="(302, 18)">
                                      <OtherNode start="(302, 11)" end="(302, 18)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(302, 11)" end="(302, 16)" kind="Lean.Parser.Term.dotIdent">
                                          <AtomNode start="(302, 11)" end="(302, 12)" leading="" trailing="" val="."/>
                                          <IdentNode start="(302, 12)" end="(302, 16)" leading="" trailing=" " raw_val="done" val="done"/>
                                        </OtherNode>
                                        <NullNode start="(302, 17)" end="(302, 18)">
                                          <IdentNode start="(302, 17)" end="(302, 18)" leading="" trailing=" " raw_val="b" val="b"/>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(302, 19)" end="(302, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <OtherNode start="(302, 22)" end="(302, 36)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(302, 22)" end="(302, 26)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(302, 27)" end="(302, 36)">
                                      <OtherNode start="(302, 27)" end="(302, 36)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(302, 27)" end="(302, 28)" leading="" trailing="" val="("/>
                                        <OtherNode start="(302, 28)" end="(302, 35)" kind="Lean.Parser.Term.app">
                                          <OtherNode start="(302, 28)" end="(302, 33)" kind="Lean.Parser.Term.dotIdent">
                                            <AtomNode start="(302, 28)" end="(302, 29)" leading="" trailing="" val="."/>
                                            <IdentNode start="(302, 29)" end="(302, 33)" leading="" trailing=" " raw_val="done" val="done"/>
                                          </OtherNode>
                                          <NullNode start="(302, 34)" end="(302, 35)">
                                            <IdentNode start="(302, 34)" end="(302, 35)" leading="" trailing="" raw_val="b" val="b"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(302, 35)" end="(302, 36)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(302, 36)" end="(302, 37)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(302, 38)" end="(302, 60)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(302, 38)" end="(302, 39)" leading="" trailing="" val="("/>
                      <OtherNode start="(302, 39)" end="(302, 59)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(302, 39)" end="(302, 54)" leading="" trailing=" " raw_val="ForInStep.yield" val="ForInStep.yield" full_name="ForInStep.yield" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        <NullNode start="(302, 55)" end="(302, 59)">
                          <IdentNode start="(302, 55)" end="(302, 59)" leading="" trailing="" raw_val="init" val="init"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(302, 59)" end="(302, 60)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(302, 61)" end="(324, 33)">
          <AtomNode start="(302, 61)" end="(302, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(302, 64)" end="(324, 33)">
            <AtomNode start="(302, 64)" end="(302, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(303, 3)" end="(324, 33)">
              <TacticTacticseq1IndentedNode start="(303, 3)" end="(324, 33)">
                <NullNode start="(303, 3)" end="(324, 33)">
                  <OtherNode start="(303, 3)" end="(324, 33)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : (a : α) → a ∈ l → β → m (ForInStep β)&#10;init : β&#10;⊢ forIn' l init f =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match x with&#10;          | ⟨a, m_1⟩ =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a m_1 b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) l.attach" state_after="no goals" tactic="induction l generalizing init with&#10;| nil =&amp;gt; simp&#10;| cons a as ih =&amp;gt;&#10;  simp only [forIn'_cons, attach_cons, foldlM_cons, _root_.map_bind]&#10;  congr 1&#10;  funext x&#10;  match x with&#10;  | .done b =&amp;gt;&#10;    clear ih&#10;    dsimp&#10;    induction as with&#10;    | nil =&amp;gt; simp&#10;    | cons a as ih =&amp;gt;&#10;      simp only [attach_cons, map_cons, map_map, Function.comp_def, foldlM_cons, pure_bind]&#10;      specialize ih (fun a m b =&amp;gt; f a (by&#10;        simp only [mem_cons] at m&#10;        rcases m with rfl|m&#10;        · apply mem_cons_self&#10;        · exact mem_cons_of_mem _ (mem_cons_of_mem _ m)) b)&#10;      simp [ih, List.foldlM_map]&#10;  | .yield b =&amp;gt;&#10;    simp [ih, List.foldlM_map]">
                    <AtomNode start="(303, 3)" end="(303, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(303, 13)" end="(303, 14)">
                      <OtherNode start="(303, 13)" end="(303, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(303, 13)" end="(303, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(303, 15)" end="(303, 32)">
                      <AtomNode start="(303, 15)" end="(303, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(303, 28)" end="(303, 32)">
                        <IdentNode start="(303, 28)" end="(303, 32)" leading="" trailing=" " raw_val="init" val="init"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(303, 33)" end="(324, 33)">
                      <OtherNode start="(303, 33)" end="(324, 33)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(303, 33)" end="(303, 37)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(304, 3)" end="(324, 33)">
                          <OtherNode start="(304, 3)" end="(304, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(304, 3)" end="(304, 8)">
                              <OtherNode start="(304, 3)" end="(304, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(304, 3)" end="(304, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(304, 5)" end="(304, 8)">
                                  <NullNode/>
                                  <IdentNode start="(304, 5)" end="(304, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(304, 9)" end="(304, 16)">
                              <AtomNode start="(304, 9)" end="(304, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(304, 12)" end="(304, 16)">
                                <TacticTacticseq1IndentedNode start="(304, 12)" end="(304, 16)">
                                  <NullNode start="(304, 12)" end="(304, 16)">
                                    <OtherNode start="(304, 12)" end="(304, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : (a : α) → a ∈ [] → β → m (ForInStep β)&#10;init : β&#10;⊢ forIn' [] init f =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match x with&#10;          | ⟨a, m_1⟩ =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a m_1 b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) [].attach" state_after="no goals" tactic="simp">
                                      <AtomNode start="(304, 12)" end="(304, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(305, 3)" end="(324, 33)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(305, 3)" end="(305, 17)">
                              <OtherNode start="(305, 3)" end="(305, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(305, 3)" end="(305, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(305, 5)" end="(305, 9)">
                                  <NullNode/>
                                  <IdentNode start="(305, 5)" end="(305, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(305, 10)" end="(305, 17)">
                                  <IdentNode start="(305, 10)" end="(305, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(305, 12)" end="(305, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                                  <IdentNode start="(305, 15)" end="(305, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(305, 18)" end="(324, 33)">
                              <AtomNode start="(305, 18)" end="(305, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(306, 5)" end="(324, 33)">
                                <TacticTacticseq1IndentedNode start="(306, 5)" end="(324, 33)">
                                  <NullNode start="(306, 5)" end="(324, 33)">
                                    <OtherNode start="(306, 5)" end="(306, 71)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ as → β → m (ForInStep β)) (init : β),&#10;    forIn' as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match x with&#10;            | ⟨a, m_1⟩ =&amp;gt;&#10;              match b with&#10;              | ForInStep.yield b =&amp;gt; f a m_1 b&#10;              | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as.attach&#10;f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)&#10;init : β&#10;⊢ forIn' (a :: as) init f =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match x with&#10;          | ⟨a_1, m_1⟩ =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a_1 m_1 b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) (a :: as).attach" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ as → β → m (ForInStep β)) (init : β),&#10;    forIn' as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match x with&#10;            | ⟨a, m_1⟩ =&amp;gt;&#10;              match b with&#10;              | ForInStep.yield b =&amp;gt; f a m_1 b&#10;              | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as.attach&#10;f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)&#10;init : β&#10;⊢ (do&#10;      let x ← f a ⋯ init&#10;      match x with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    do&#10;    let a_1 ← f a ⋯ init&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          a_1 (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" tactic="simp only [forIn'_cons, attach_cons, foldlM_cons, _root_.map_bind]">
                                      <AtomNode start="(306, 5)" end="(306, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(306, 10)" end="(306, 14)">
                                        <AtomNode start="(306, 10)" end="(306, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(306, 15)" end="(306, 71)">
                                        <AtomNode start="(306, 15)" end="(306, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(306, 16)" end="(306, 70)">
                                          <OtherNode start="(306, 16)" end="(306, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(306, 16)" end="(306, 27)" leading="" trailing="" raw_val="forIn'_cons" val="forIn'_cons" full_name="List.forIn'_cons" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(248, 17)" def_end="(248, 28)"/>
                                          </OtherNode>
                                          <AtomNode start="(306, 27)" end="(306, 28)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(306, 29)" end="(306, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(306, 29)" end="(306, 40)" leading="" trailing="" raw_val="attach_cons" val="attach_cons" full_name="List.attach_cons" mod_name="Init.Data.List.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Attach.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(306, 40)" end="(306, 41)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(306, 42)" end="(306, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(306, 42)" end="(306, 53)" leading="" trailing="" raw_val="foldlM_cons" val="foldlM_cons" full_name="List.foldlM_cons" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(306, 53)" end="(306, 54)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(306, 55)" end="(306, 70)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(306, 55)" end="(306, 70)" leading="" trailing="" raw_val="_root_.map_bind" val="_root_.map_bind" full_name="map_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(306, 70)" end="(306, 71)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(307, 5)" end="(307, 12)" kind="Lean.Parser.Tactic.congr" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ as → β → m (ForInStep β)) (init : β),&#10;    forIn' as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match x with&#10;            | ⟨a, m_1⟩ =&amp;gt;&#10;              match b with&#10;              | ForInStep.yield b =&amp;gt; f a m_1 b&#10;              | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as.attach&#10;f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)&#10;init : β&#10;⊢ (do&#10;      let x ← f a ⋯ init&#10;      match x with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    do&#10;    let a_1 ← f a ⋯ init&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          a_1 (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" state_after="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ as → β → m (ForInStep β)) (init : β),&#10;    forIn' as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match x with&#10;            | ⟨a, m_1⟩ =&amp;gt;&#10;              match b with&#10;              | ForInStep.yield b =&amp;gt; f a m_1 b&#10;              | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as.attach&#10;f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)&#10;init : β&#10;⊢ (fun x =&amp;gt;&#10;      match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    fun a_1 =&amp;gt;&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        a_1 (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" tactic="congr 1">
                                      <AtomNode start="(307, 5)" end="(307, 10)" leading="" trailing=" " val="congr"/>
                                      <NullNode start="(307, 11)" end="(307, 12)">
                                        <OtherNode start="(307, 11)" end="(307, 12)" kind="num">
                                          <AtomNode start="(307, 11)" end="(307, 12)" leading="" trailing="&#10;    " val="1"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(308, 5)" end="(308, 13)" kind="tacticFunext___" state_before="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ as → β → m (ForInStep β)) (init : β),&#10;    forIn' as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match x with&#10;            | ⟨a, m_1⟩ =&amp;gt;&#10;              match b with&#10;              | ForInStep.yield b =&amp;gt; f a m_1 b&#10;              | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as.attach&#10;f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)&#10;init : β&#10;⊢ (fun x =&amp;gt;&#10;      match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    fun a_1 =&amp;gt;&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        a_1 (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" state_after="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ as → β → m (ForInStep β)) (init : β),&#10;    forIn' as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match x with&#10;            | ⟨a, m_1⟩ =&amp;gt;&#10;              match b with&#10;              | ForInStep.yield b =&amp;gt; f a m_1 b&#10;              | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as.attach&#10;f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)&#10;init : β&#10;x : ForInStep β&#10;⊢ (match x with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        x (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" tactic="funext x">
                                      <AtomNode start="(308, 5)" end="(308, 11)" leading="" trailing=" " val="funext"/>
                                      <NullNode start="(308, 12)" end="(308, 13)">
                                        <IdentNode start="(308, 12)" end="(308, 13)" leading="" trailing="&#10;    " raw_val="x" val="x"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(309, 5)" end="(324, 33)" kind="Lean.Parser.Tactic.match" state_before="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ as → β → m (ForInStep β)) (init : β),&#10;    forIn' as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match x with&#10;            | ⟨a, m_1⟩ =&amp;gt;&#10;              match b with&#10;              | ForInStep.yield b =&amp;gt; f a m_1 b&#10;              | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as.attach&#10;f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)&#10;init : β&#10;x : ForInStep β&#10;⊢ (match x with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        x (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" state_after="no goals" tactic="match x with&#10;| .done b =&amp;gt;&#10;  clear ih&#10;  dsimp&#10;  induction as with&#10;  | nil =&amp;gt; simp&#10;  | cons a as ih =&amp;gt;&#10;    simp only [attach_cons, map_cons, map_map, Function.comp_def, foldlM_cons, pure_bind]&#10;    specialize ih (fun a m b =&amp;gt; f a (by&#10;      simp only [mem_cons] at m&#10;      rcases m with rfl|m&#10;      · apply mem_cons_self&#10;      · exact mem_cons_of_mem _ (mem_cons_of_mem _ m)) b)&#10;    simp [ih, List.foldlM_map]&#10;| .yield b =&amp;gt;&#10;  simp [ih, List.foldlM_map]">
                                      <AtomNode start="(309, 5)" end="(309, 10)" leading="" trailing=" " val="match"/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(309, 11)" end="(309, 12)">
                                        <OtherNode start="(309, 11)" end="(309, 12)" kind="Lean.Parser.Term.matchDiscr">
                                          <NullNode/>
                                          <IdentNode start="(309, 11)" end="(309, 12)" leading="" trailing=" " raw_val="x" val="x"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(309, 13)" end="(309, 17)" leading="" trailing="&#10;    " val="with"/>
                                      <OtherNode start="(310, 5)" end="(324, 33)" kind="Lean.Parser.Term.matchAlts">
                                        <NullNode start="(310, 5)" end="(324, 33)">
                                          <OtherNode start="(310, 5)" end="(322, 35)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(310, 5)" end="(310, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(310, 7)" end="(310, 14)">
                                              <NullNode start="(310, 7)" end="(310, 14)">
                                                <OtherNode start="(310, 7)" end="(310, 14)" kind="Lean.Parser.Term.app">
                                                  <OtherNode start="(310, 7)" end="(310, 12)" kind="Lean.Parser.Term.dotIdent">
                                                    <AtomNode start="(310, 7)" end="(310, 8)" leading="" trailing="" val="."/>
                                                    <IdentNode start="(310, 8)" end="(310, 12)" leading="" trailing=" " raw_val="done" val="done"/>
                                                  </OtherNode>
                                                  <NullNode start="(310, 13)" end="(310, 14)">
                                                    <IdentNode start="(310, 13)" end="(310, 14)" leading="" trailing=" " raw_val="b" val="b"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(310, 15)" end="(310, 17)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(311, 7)" end="(322, 35)">
                                              <TacticTacticseq1IndentedNode start="(311, 7)" end="(322, 35)">
                                                <NullNode start="(311, 7)" end="(322, 35)">
                                                  <OtherNode start="(311, 7)" end="(311, 15)" kind="Lean.Parser.Tactic.clear" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ as → β → m (ForInStep β)) (init : β),&#10;    forIn' as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match x with&#10;            | ⟨a, m_1⟩ =&amp;gt;&#10;              match b with&#10;              | ForInStep.yield b =&amp;gt; f a m_1 b&#10;              | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as.attach&#10;f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a : α&#10;as : List α&#10;f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" tactic="clear ih">
                                                    <AtomNode start="(311, 7)" end="(311, 12)" leading="" trailing=" " val="clear"/>
                                                    <NullNode start="(311, 13)" end="(311, 15)">
                                                      <IdentNode start="(311, 13)" end="(311, 15)" leading="" trailing="&#10;      " raw_val="ih" val="ih"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(312, 7)" end="(312, 12)" kind="Lean.Parser.Tactic.dsimp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a : α&#10;as : List α&#10;f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a : α&#10;as : List α&#10;f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;⊢ pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" tactic="dsimp">
                                                    <AtomNode start="(312, 7)" end="(312, 12)" leading="" trailing="&#10;      " val="dsimp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(313, 7)" end="(322, 35)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a : α&#10;as : List α&#10;f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;⊢ pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" state_after="no goals" tactic="induction as with&#10;| nil =&amp;gt; simp&#10;| cons a as ih =&amp;gt;&#10;  simp only [attach_cons, map_cons, map_map, Function.comp_def, foldlM_cons, pure_bind]&#10;  specialize ih (fun a m b =&amp;gt; f a (by&#10;    simp only [mem_cons] at m&#10;    rcases m with rfl|m&#10;    · apply mem_cons_self&#10;    · exact mem_cons_of_mem _ (mem_cons_of_mem _ m)) b)&#10;  simp [ih, List.foldlM_map]">
                                                    <AtomNode start="(313, 7)" end="(313, 16)" leading="" trailing=" " val="induction"/>
                                                    <NullNode start="(313, 17)" end="(313, 19)">
                                                      <OtherNode start="(313, 17)" end="(313, 19)" kind="Lean.Parser.Tactic.elimTarget">
                                                        <NullNode/>
                                                        <IdentNode start="(313, 17)" end="(313, 19)" leading="" trailing=" " raw_val="as" val="as"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(313, 20)" end="(322, 35)">
                                                      <OtherNode start="(313, 20)" end="(322, 35)" kind="Lean.Parser.Tactic.inductionAlts">
                                                        <AtomNode start="(313, 20)" end="(313, 24)" leading="" trailing="&#10;      " val="with"/>
                                                        <NullNode/>
                                                        <NullNode start="(314, 7)" end="(322, 35)">
                                                          <OtherNode start="(314, 7)" end="(314, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(314, 7)" end="(314, 12)">
                                                            <OtherNode start="(314, 7)" end="(314, 12)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(314, 7)" end="(314, 8)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(314, 9)" end="(314, 12)">
                                                            <NullNode/>
                                                            <IdentNode start="(314, 9)" end="(314, 12)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </GroupNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(314, 13)" end="(314, 20)">
                                                            <AtomNode start="(314, 13)" end="(314, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(314, 16)" end="(314, 20)">
                                                            <TacticTacticseq1IndentedNode start="(314, 16)" end="(314, 20)">
                                                            <NullNode start="(314, 16)" end="(314, 20)">
                                                            <OtherNode start="(314, 16)" end="(314, 20)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a : α&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;f : (a_1 : α) → a_1 ∈ [a] → β → m (ForInStep β)&#10;⊢ pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) [].attach)" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(314, 16)" end="(314, 20)" leading="" trailing="&#10;      " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <OtherNode start="(315, 7)" end="(322, 35)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(315, 7)" end="(315, 21)">
                                                            <OtherNode start="(315, 7)" end="(315, 21)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(315, 7)" end="(315, 8)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(315, 9)" end="(315, 13)">
                                                            <NullNode/>
                                                            <IdentNode start="(315, 9)" end="(315, 13)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </GroupNode>
                                                            <NullNode start="(315, 14)" end="(315, 21)">
                                                            <IdentNode start="(315, 14)" end="(315, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <IdentNode start="(315, 16)" end="(315, 18)" leading="" trailing=" " raw_val="as" val="as"/>
                                                            <IdentNode start="(315, 19)" end="(315, 21)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(315, 22)" end="(322, 35)">
                                                            <AtomNode start="(315, 22)" end="(315, 24)" leading="" trailing="&#10;        " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(316, 9)" end="(322, 35)">
                                                            <TacticTacticseq1IndentedNode start="(316, 9)" end="(322, 35)">
                                                            <NullNode start="(316, 9)" end="(322, 35)">
                                                            <OtherNode start="(316, 9)" end="(316, 94)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a✝ : α&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ a✝ :: as → β → m (ForInStep β)),&#10;    pure b =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a_1 : α) → a_1 ∈ a✝ :: a :: as → β → m (ForInStep β)&#10;⊢ pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) (a :: as).attach)" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a✝ : α&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ a✝ :: as → β → m (ForInStep β)),&#10;    pure b =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a_1 : α) → a_1 ∈ a✝ :: a :: as → β → m (ForInStep β)&#10;⊢ pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" tactic="simp only [attach_cons, map_cons, map_map, Function.comp_def, foldlM_cons, pure_bind]">
                                                            <AtomNode start="(316, 9)" end="(316, 13)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(316, 14)" end="(316, 18)">
                                                            <AtomNode start="(316, 14)" end="(316, 18)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(316, 19)" end="(316, 94)">
                                                            <AtomNode start="(316, 19)" end="(316, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(316, 20)" end="(316, 93)">
                                                            <OtherNode start="(316, 20)" end="(316, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(316, 20)" end="(316, 31)" leading="" trailing="" raw_val="attach_cons" val="attach_cons" full_name="List.attach_cons" mod_name="Init.Data.List.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Attach.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(316, 31)" end="(316, 32)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(316, 33)" end="(316, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(316, 33)" end="(316, 41)" leading="" trailing="" raw_val="map_cons" val="map_cons" full_name="List.map_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(316, 41)" end="(316, 42)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(316, 43)" end="(316, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(316, 43)" end="(316, 50)" leading="" trailing="" raw_val="map_map" val="map_map" full_name="List.map_map" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(316, 50)" end="(316, 51)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(316, 52)" end="(316, 69)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(316, 52)" end="(316, 69)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(316, 69)" end="(316, 70)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(316, 71)" end="(316, 82)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(316, 71)" end="(316, 82)" leading="" trailing="" raw_val="foldlM_cons" val="foldlM_cons" full_name="List.foldlM_cons" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(316, 82)" end="(316, 83)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(316, 84)" end="(316, 93)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(316, 84)" end="(316, 93)" leading="" trailing="" raw_val="pure_bind" val="pure_bind" full_name="LawfulMonad.pure_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(316, 93)" end="(316, 94)" leading="" trailing="&#10;        " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(317, 9)" end="(321, 62)" kind="Lean.Parser.Tactic.specialize" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a✝ : α&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ a✝ :: as → β → m (ForInStep β)),&#10;    pure b =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a_1 : α) → a_1 ∈ a✝ :: a :: as → β → m (ForInStep β)&#10;⊢ pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a✝ : α&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;a : α&#10;as : List α&#10;ih✝ :&#10;  ∀ (f : (a : α) → a ∈ a✝ :: as → β → m (ForInStep β)),&#10;    pure b =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a_1 : α) → a_1 ∈ a✝ :: a :: as → β → m (ForInStep β)&#10;ih :&#10;  pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b_1 x =&amp;gt;&#10;          match b_1 with&#10;          | ForInStep.yield b_2 =&amp;gt; f x.val ⋯ b_2&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;⊢ pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" tactic="specialize ih (fun a m b =&amp;gt; f a (by&#10;  simp only [mem_cons] at m&#10;  rcases m with rfl|m&#10;  · apply mem_cons_self&#10;  · exact mem_cons_of_mem _ (mem_cons_of_mem _ m)) b)">
                                                            <AtomNode start="(317, 9)" end="(317, 19)" leading="" trailing=" " val="specialize"/>
                                                            <OtherNode start="(317, 20)" end="(321, 62)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(317, 20)" end="(317, 22)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(317, 23)" end="(321, 62)">
                                                            <OtherNode start="(317, 23)" end="(321, 62)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(317, 23)" end="(317, 24)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(317, 24)" end="(321, 61)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(317, 24)" end="(317, 27)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(317, 28)" end="(321, 61)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(317, 28)" end="(317, 33)">
                                                            <IdentNode start="(317, 28)" end="(317, 29)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <IdentNode start="(317, 30)" end="(317, 31)" leading="" trailing=" " raw_val="m" val="m"/>
                                                            <IdentNode start="(317, 32)" end="(317, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(317, 34)" end="(317, 36)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(317, 37)" end="(321, 61)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(317, 37)" end="(317, 38)" leading="" trailing=" " raw_val="f" val="f"/>
                                                            <NullNode start="(317, 39)" end="(321, 61)">
                                                            <IdentNode start="(317, 39)" end="(317, 40)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <OtherNode start="(317, 41)" end="(321, 59)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(317, 41)" end="(317, 42)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(317, 42)" end="(321, 58)">
                                                            <AtomNode start="(317, 42)" end="(317, 44)" leading="" trailing="&#10;          " val="by"/>
                                                            <TacticTacticseqNode start="(318, 11)" end="(321, 58)">
                                                            <TacticTacticseq1IndentedNode start="(318, 11)" end="(321, 58)">
                                                            <NullNode start="(318, 11)" end="(321, 58)">
                                                            <OtherNode start="(318, 11)" end="(318, 36)" kind="Lean.Parser.Tactic.simp" state_before="m✝ : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m✝&#10;inst✝ : LawfulMonad m✝&#10;a✝¹ : α&#10;init : β&#10;x : ForInStep β&#10;b✝ : β&#10;a✝ : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ a✝¹ :: as → β → m✝ (ForInStep β)),&#10;    pure b✝ =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b✝) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a : α) → a ∈ a✝¹ :: a✝ :: as → β → m✝ (ForInStep β)&#10;a : α&#10;m : a ∈ a✝¹ :: as&#10;b : β&#10;⊢ a ∈ a✝¹ :: a✝ :: as" state_after="m✝ : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m✝&#10;inst✝ : LawfulMonad m✝&#10;a✝¹ : α&#10;init : β&#10;x : ForInStep β&#10;b✝ : β&#10;a✝ : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ a✝¹ :: as → β → m✝ (ForInStep β)),&#10;    pure b✝ =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b✝) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a : α) → a ∈ a✝¹ :: a✝ :: as → β → m✝ (ForInStep β)&#10;a : α&#10;b : β&#10;m : a = a✝¹ ∨ a ∈ as&#10;⊢ a ∈ a✝¹ :: a✝ :: as" tactic="simp only [mem_cons] at m">
                                                            <AtomNode start="(318, 11)" end="(318, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(318, 16)" end="(318, 20)">
                                                            <AtomNode start="(318, 16)" end="(318, 20)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(318, 21)" end="(318, 31)">
                                                            <AtomNode start="(318, 21)" end="(318, 22)" leading="" trailing="" val="["/>
                                                            <NullNode start="(318, 22)" end="(318, 30)">
                                                            <OtherNode start="(318, 22)" end="(318, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(318, 22)" end="(318, 30)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(318, 30)" end="(318, 31)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(318, 32)" end="(318, 36)">
                                                            <OtherNode start="(318, 32)" end="(318, 36)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(318, 32)" end="(318, 34)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(318, 35)" end="(318, 36)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(318, 35)" end="(318, 36)">
                                                            <IdentNode start="(318, 35)" end="(318, 36)" leading="" trailing="&#10;          " raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(319, 11)" end="(319, 30)" kind="Lean.Parser.Tactic.rcases" state_before="m✝ : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m✝&#10;inst✝ : LawfulMonad m✝&#10;a✝¹ : α&#10;init : β&#10;x : ForInStep β&#10;b✝ : β&#10;a✝ : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ a✝¹ :: as → β → m✝ (ForInStep β)),&#10;    pure b✝ =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b✝) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a : α) → a ∈ a✝¹ :: a✝ :: as → β → m✝ (ForInStep β)&#10;a : α&#10;b : β&#10;m : a = a✝¹ ∨ a ∈ as&#10;⊢ a ∈ a✝¹ :: a✝ :: as" state_after="case inl&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;init : β&#10;x : ForInStep β&#10;b✝ : β&#10;a✝ : α&#10;as : List α&#10;a : α&#10;b : β&#10;ih :&#10;  ∀ (f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)),&#10;    pure b✝ =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b✝) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a_1 : α) → a_1 ∈ a :: a✝ :: as → β → m (ForInStep β)&#10;⊢ a ∈ a :: a✝ :: as&#10;&#10;case inr&#10;m✝ : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m✝&#10;inst✝ : LawfulMonad m✝&#10;a✝¹ : α&#10;init : β&#10;x : ForInStep β&#10;b✝ : β&#10;a✝ : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ a✝¹ :: as → β → m✝ (ForInStep β)),&#10;    pure b✝ =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b✝) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a : α) → a ∈ a✝¹ :: a✝ :: as → β → m✝ (ForInStep β)&#10;a : α&#10;b : β&#10;m : a ∈ as&#10;⊢ a ∈ a✝¹ :: a✝ :: as" tactic="rcases m with rfl|m">
                                                            <AtomNode start="(319, 11)" end="(319, 17)" leading="" trailing=" " val="rcases"/>
                                                            <NullNode start="(319, 18)" end="(319, 19)">
                                                            <OtherNode start="(319, 18)" end="(319, 19)" kind="Lean.Parser.Tactic.elimTarget">
                                                            <NullNode/>
                                                            <IdentNode start="(319, 18)" end="(319, 19)" leading="" trailing=" " raw_val="m" val="m"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(319, 20)" end="(319, 30)">
                                                            <AtomNode start="(319, 20)" end="(319, 24)" leading="" trailing=" " val="with"/>
                                                            <OtherNode start="(319, 25)" end="(319, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(319, 25)" end="(319, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(319, 25)" end="(319, 30)">
                                                            <OtherNode start="(319, 25)" end="(319, 28)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(319, 25)" end="(319, 28)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            <AtomNode start="(319, 28)" end="(319, 29)" leading="" trailing="" val="|"/>
                                                            <OtherNode start="(319, 29)" end="(319, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(319, 29)" end="(319, 30)" leading="" trailing="&#10;          " raw_val="m" val="m"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(320, 11)" end="(320, 32)" kind="Lean.cdot" state_before="case inl&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;init : β&#10;x : ForInStep β&#10;b✝ : β&#10;a✝ : α&#10;as : List α&#10;a : α&#10;b : β&#10;ih :&#10;  ∀ (f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)),&#10;    pure b✝ =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b✝) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a_1 : α) → a_1 ∈ a :: a✝ :: as → β → m (ForInStep β)&#10;⊢ a ∈ a :: a✝ :: as&#10;&#10;case inr&#10;m✝ : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m✝&#10;inst✝ : LawfulMonad m✝&#10;a✝¹ : α&#10;init : β&#10;x : ForInStep β&#10;b✝ : β&#10;a✝ : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ a✝¹ :: as → β → m✝ (ForInStep β)),&#10;    pure b✝ =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b✝) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a : α) → a ∈ a✝¹ :: a✝ :: as → β → m✝ (ForInStep β)&#10;a : α&#10;b : β&#10;m : a ∈ as&#10;⊢ a ∈ a✝¹ :: a✝ :: as" state_after="case inr&#10;m✝ : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m✝&#10;inst✝ : LawfulMonad m✝&#10;a✝¹ : α&#10;init : β&#10;x : ForInStep β&#10;b✝ : β&#10;a✝ : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ a✝¹ :: as → β → m✝ (ForInStep β)),&#10;    pure b✝ =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b✝) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a : α) → a ∈ a✝¹ :: a✝ :: as → β → m✝ (ForInStep β)&#10;a : α&#10;b : β&#10;m : a ∈ as&#10;⊢ a ∈ a✝¹ :: a✝ :: as" tactic="· apply mem_cons_self">
                                                            <OtherNode start="(320, 11)" end="(320, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(320, 11)" end="(320, 12)" kind="patternIgnore">
                                                            <OtherNode start="(320, 11)" end="(320, 12)" kind="token.«· »">
                                                            <AtomNode start="(320, 11)" end="(320, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(320, 13)" end="(320, 32)">
                                                            <TacticTacticseq1IndentedNode start="(320, 13)" end="(320, 32)">
                                                            <NullNode start="(320, 13)" end="(320, 32)">
                                                            <OtherNode start="(320, 13)" end="(320, 32)" kind="Lean.Parser.Tactic.apply" state_before="case inl&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;init : β&#10;x : ForInStep β&#10;b✝ : β&#10;a✝ : α&#10;as : List α&#10;a : α&#10;b : β&#10;ih :&#10;  ∀ (f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)),&#10;    pure b✝ =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b✝) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a_1 : α) → a_1 ∈ a :: a✝ :: as → β → m (ForInStep β)&#10;⊢ a ∈ a :: a✝ :: as" state_after="no goals" tactic="apply mem_cons_self">
                                                            <AtomNode start="(320, 13)" end="(320, 18)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(320, 19)" end="(320, 32)" leading="" trailing="&#10;          " raw_val="mem_cons_self" val="mem_cons_self" full_name="List.mem_cons_self" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(321, 11)" end="(321, 58)" kind="Lean.cdot" state_before="case inr&#10;m✝ : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m✝&#10;inst✝ : LawfulMonad m✝&#10;a✝¹ : α&#10;init : β&#10;x : ForInStep β&#10;b✝ : β&#10;a✝ : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ a✝¹ :: as → β → m✝ (ForInStep β)),&#10;    pure b✝ =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b✝) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a : α) → a ∈ a✝¹ :: a✝ :: as → β → m✝ (ForInStep β)&#10;a : α&#10;b : β&#10;m : a ∈ as&#10;⊢ a ∈ a✝¹ :: a✝ :: as" state_after="no goals" tactic="· exact mem_cons_of_mem _ (mem_cons_of_mem _ m)">
                                                            <OtherNode start="(321, 11)" end="(321, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(321, 11)" end="(321, 12)" kind="patternIgnore">
                                                            <OtherNode start="(321, 11)" end="(321, 12)" kind="token.«· »">
                                                            <AtomNode start="(321, 11)" end="(321, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(321, 13)" end="(321, 58)">
                                                            <TacticTacticseq1IndentedNode start="(321, 13)" end="(321, 58)">
                                                            <NullNode start="(321, 13)" end="(321, 58)">
                                                            <OtherNode start="(321, 13)" end="(321, 58)" kind="Lean.Parser.Tactic.exact" state_before="case inr&#10;m✝ : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m✝&#10;inst✝ : LawfulMonad m✝&#10;a✝¹ : α&#10;init : β&#10;x : ForInStep β&#10;b✝ : β&#10;a✝ : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ a✝¹ :: as → β → m✝ (ForInStep β)),&#10;    pure b✝ =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b✝) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a : α) → a ∈ a✝¹ :: a✝ :: as → β → m✝ (ForInStep β)&#10;a : α&#10;b : β&#10;m : a ∈ as&#10;⊢ a ∈ a✝¹ :: a✝ :: as" state_after="no goals" tactic="exact mem_cons_of_mem _ (mem_cons_of_mem _ m)">
                                                            <AtomNode start="(321, 13)" end="(321, 18)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(321, 19)" end="(321, 58)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(321, 19)" end="(321, 34)" leading="" trailing=" " raw_val="mem_cons_of_mem" val="mem_cons_of_mem" full_name="List.mem_cons_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            <NullNode start="(321, 35)" end="(321, 58)">
                                                            <TermHoleNode start="(321, 35)" end="(321, 36)">
                                                            <AtomNode start="(321, 35)" end="(321, 36)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(321, 37)" end="(321, 58)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(321, 37)" end="(321, 38)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(321, 38)" end="(321, 57)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(321, 38)" end="(321, 53)" leading="" trailing=" " raw_val="mem_cons_of_mem" val="mem_cons_of_mem" full_name="List.mem_cons_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            <NullNode start="(321, 54)" end="(321, 57)">
                                                            <TermHoleNode start="(321, 54)" end="(321, 55)">
                                                            <AtomNode start="(321, 54)" end="(321, 55)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(321, 56)" end="(321, 57)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(321, 57)" end="(321, 58)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(321, 58)" end="(321, 59)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <IdentNode start="(321, 60)" end="(321, 61)" leading="" trailing="" raw_val="b" val="b"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(321, 61)" end="(321, 62)" leading="" trailing="&#10;        " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(322, 9)" end="(322, 35)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a✝ : α&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;a : α&#10;as : List α&#10;ih✝ :&#10;  ∀ (f : (a : α) → a ∈ a✝ :: as → β → m (ForInStep β)),&#10;    pure b =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;f : (a_1 : α) → a_1 ∈ a✝ :: a :: as → β → m (ForInStep β)&#10;ih :&#10;  pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b_1 x =&amp;gt;&#10;          match b_1 with&#10;          | ForInStep.yield b_2 =&amp;gt; f x.val ⋯ b_2&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)&#10;⊢ pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" state_after="no goals" tactic="simp [ih, List.foldlM_map]">
                                                            <AtomNode start="(322, 9)" end="(322, 13)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(322, 14)" end="(322, 35)">
                                                            <AtomNode start="(322, 14)" end="(322, 15)" leading="" trailing="" val="["/>
                                                            <NullNode start="(322, 15)" end="(322, 34)">
                                                            <OtherNode start="(322, 15)" end="(322, 17)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(322, 15)" end="(322, 17)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <AtomNode start="(322, 17)" end="(322, 18)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(322, 19)" end="(322, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(322, 19)" end="(322, 34)" leading="" trailing="" raw_val="List.foldlM_map" val="List.foldlM_map" full_name="List.foldlM_map" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(153, 9)" def_end="(153, 19)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(322, 34)" end="(322, 35)" leading="" trailing="&#10;    " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <OtherNode start="(323, 5)" end="(324, 33)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(323, 5)" end="(323, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(323, 7)" end="(323, 15)">
                                              <NullNode start="(323, 7)" end="(323, 15)">
                                                <OtherNode start="(323, 7)" end="(323, 15)" kind="Lean.Parser.Term.app">
                                                  <OtherNode start="(323, 7)" end="(323, 13)" kind="Lean.Parser.Term.dotIdent">
                                                    <AtomNode start="(323, 7)" end="(323, 8)" leading="" trailing="" val="."/>
                                                    <IdentNode start="(323, 8)" end="(323, 13)" leading="" trailing=" " raw_val="yield" val="yield"/>
                                                  </OtherNode>
                                                  <NullNode start="(323, 14)" end="(323, 15)">
                                                    <IdentNode start="(323, 14)" end="(323, 15)" leading="" trailing=" " raw_val="b" val="b"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(323, 16)" end="(323, 18)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(324, 7)" end="(324, 33)">
                                              <TacticTacticseq1IndentedNode start="(324, 7)" end="(324, 33)">
                                                <NullNode start="(324, 7)" end="(324, 33)">
                                                  <OtherNode start="(324, 7)" end="(324, 33)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (f : (a : α) → a ∈ as → β → m (ForInStep β)) (init : β),&#10;    forIn' as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b x =&amp;gt;&#10;            match x with&#10;            | ⟨a, m_1⟩ =&amp;gt;&#10;              match b with&#10;              | ForInStep.yield b =&amp;gt; f a m_1 b&#10;              | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as.attach&#10;f : (a_1 : α) → a_1 ∈ a :: as → β → m (ForInStep β)&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn' as b fun a' m b =&amp;gt; f a' ⋯ b) =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield b) (map (fun x =&amp;gt; ⟨x.val, ⋯⟩) as.attach)" state_after="no goals" tactic="simp [ih, List.foldlM_map]">
                                                    <AtomNode start="(324, 7)" end="(324, 11)" leading="" trailing=" " val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(324, 12)" end="(324, 33)">
                                                      <AtomNode start="(324, 12)" end="(324, 13)" leading="" trailing="" val="["/>
                                                      <NullNode start="(324, 13)" end="(324, 32)">
                                                        <OtherNode start="(324, 13)" end="(324, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(324, 13)" end="(324, 15)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                        </OtherNode>
                                                        <AtomNode start="(324, 15)" end="(324, 16)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(324, 17)" end="(324, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(324, 17)" end="(324, 32)" leading="" trailing="" raw_val="List.foldlM_map" val="List.foldlM_map" full_name="List.foldlM_map" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(153, 9)" def_end="(153, 19)"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(324, 32)" end="(324, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                                                    </NullNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(326, 1)" end="(332, 52)" name="forIn'_yield_eq_foldlM" full_name="List.forIn'_yield_eq_foldlM">
      <CommandDeclmodifiersNode start="(326, 1)" end="(327, 8)">
        <NullNode start="(326, 1)" end="(326, 76)">
          <CommandDoccommentNode start="(326, 1)" end="(326, 76)" comment="We can express a for loop over a list which always yields as a fold. -/">
            <AtomNode start="(326, 1)" end="(326, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(326, 5)" end="(326, 76)" leading="" trailing="&#10;" val="We can express a for loop over a list which always yields as a fold. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(327, 1)" end="(327, 8)">
          <OtherNode start="(327, 1)" end="(327, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(327, 1)" end="(327, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(327, 3)" end="(327, 7)">
              <OtherNode start="(327, 3)" end="(327, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(327, 3)" end="(327, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(327, 3)" end="(327, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(327, 7)" end="(327, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(327, 9)" end="(332, 52)" name="forIn'_yield_eq_foldlM" full_name="List.forIn'_yield_eq_foldlM" _is_private_decl="False">
        <AtomNode start="(327, 9)" end="(327, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(327, 17)" end="(327, 39)">
          <IdentNode start="(327, 17)" end="(327, 39)" leading="" trailing=" " raw_val="forIn'_yield_eq_foldlM" val="forIn'_yield_eq_foldlM"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(327, 40)" end="(330, 65)">
          <NullNode start="(327, 40)" end="(328, 94)">
            <OtherNode start="(327, 40)" end="(327, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(327, 40)" end="(327, 41)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(327, 41)" end="(327, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(327, 41)" end="(327, 46)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(327, 47)" end="(327, 48)">
                  <IdentNode start="(327, 47)" end="(327, 48)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(327, 48)" end="(327, 49)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(327, 50)" end="(327, 65)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(327, 50)" end="(327, 51)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(327, 51)" end="(327, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(327, 51)" end="(327, 62)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(327, 63)" end="(327, 64)">
                  <IdentNode start="(327, 63)" end="(327, 64)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(327, 64)" end="(327, 65)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(328, 5)" end="(328, 17)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(328, 5)" end="(328, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(328, 6)" end="(328, 7)">
                <IdentNode start="(328, 6)" end="(328, 7)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(328, 8)" end="(328, 16)">
                <AtomNode start="(328, 8)" end="(328, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(328, 10)" end="(328, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(328, 10)" end="(328, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(328, 15)" end="(328, 16)">
                    <IdentNode start="(328, 15)" end="(328, 16)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(328, 16)" end="(328, 17)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(328, 18)" end="(328, 49)">
              <AtomNode start="(328, 18)" end="(328, 19)" leading="" trailing="" val="("/>
              <NullNode start="(328, 19)" end="(328, 20)">
                <IdentNode start="(328, 19)" end="(328, 20)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(328, 21)" end="(328, 48)">
                <AtomNode start="(328, 21)" end="(328, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(328, 23)" end="(328, 48)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(328, 23)" end="(328, 30)">
                    <AtomNode start="(328, 23)" end="(328, 24)" leading="" trailing="" val="("/>
                    <NullNode start="(328, 24)" end="(328, 25)">
                      <IdentNode start="(328, 24)" end="(328, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(328, 26)" end="(328, 29)">
                      <AtomNode start="(328, 26)" end="(328, 27)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(328, 28)" end="(328, 29)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(328, 29)" end="(328, 30)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(328, 31)" end="(328, 32)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(328, 33)" end="(328, 48)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(328, 33)" end="(328, 38)" kind="«term_∈_»">
                      <IdentNode start="(328, 33)" end="(328, 34)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(328, 35)" end="(328, 36)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(328, 37)" end="(328, 38)" leading="" trailing=" " raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(328, 39)" end="(328, 40)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(328, 41)" end="(328, 48)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(328, 41)" end="(328, 42)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(328, 43)" end="(328, 44)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(328, 45)" end="(328, 48)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(328, 45)" end="(328, 46)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(328, 47)" end="(328, 48)">
                          <IdentNode start="(328, 47)" end="(328, 48)" leading="" trailing="" raw_val="γ" val="γ"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(328, 48)" end="(328, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(328, 50)" end="(328, 83)">
              <AtomNode start="(328, 50)" end="(328, 51)" leading="" trailing="" val="("/>
              <NullNode start="(328, 51)" end="(328, 52)">
                <IdentNode start="(328, 51)" end="(328, 52)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(328, 53)" end="(328, 82)">
                <AtomNode start="(328, 53)" end="(328, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(328, 55)" end="(328, 82)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(328, 55)" end="(328, 62)">
                    <AtomNode start="(328, 55)" end="(328, 56)" leading="" trailing="" val="("/>
                    <NullNode start="(328, 56)" end="(328, 57)">
                      <IdentNode start="(328, 56)" end="(328, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(328, 58)" end="(328, 61)">
                      <AtomNode start="(328, 58)" end="(328, 59)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(328, 60)" end="(328, 61)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(328, 61)" end="(328, 62)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(328, 63)" end="(328, 64)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(328, 65)" end="(328, 82)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(328, 65)" end="(328, 70)" kind="«term_∈_»">
                      <IdentNode start="(328, 65)" end="(328, 66)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(328, 67)" end="(328, 68)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(328, 69)" end="(328, 70)" leading="" trailing=" " raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(328, 71)" end="(328, 72)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(328, 73)" end="(328, 82)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(328, 73)" end="(328, 74)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(328, 75)" end="(328, 76)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(328, 77)" end="(328, 82)" kind="Lean.Parser.Term.arrow">
                        <IdentNode start="(328, 77)" end="(328, 78)" leading="" trailing=" " raw_val="γ" val="γ"/>
                        <AtomNode start="(328, 79)" end="(328, 80)" leading="" trailing=" " val="→"/>
                        <IdentNode start="(328, 81)" end="(328, 82)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(328, 82)" end="(328, 83)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(328, 84)" end="(328, 94)">
              <AtomNode start="(328, 84)" end="(328, 85)" leading="" trailing="" val="("/>
              <NullNode start="(328, 85)" end="(328, 89)">
                <IdentNode start="(328, 85)" end="(328, 89)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(328, 90)" end="(328, 93)">
                <AtomNode start="(328, 90)" end="(328, 91)" leading="" trailing=" " val=":"/>
                <IdentNode start="(328, 92)" end="(328, 93)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(328, 93)" end="(328, 94)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(328, 95)" end="(330, 65)">
            <AtomNode start="(328, 95)" end="(328, 96)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(329, 5)" end="(330, 65)" kind="«term_=_»">
              <OtherNode start="(329, 5)" end="(329, 75)" kind="Lean.Parser.Term.app">
                <IdentNode start="(329, 5)" end="(329, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(329, 12)" end="(329, 75)">
                  <IdentNode start="(329, 12)" end="(329, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(329, 14)" end="(329, 18)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(329, 19)" end="(329, 75)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(329, 19)" end="(329, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(329, 20)" end="(329, 74)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(329, 20)" end="(329, 23)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(329, 24)" end="(329, 74)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(329, 24)" end="(329, 29)">
                          <IdentNode start="(329, 24)" end="(329, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(329, 26)" end="(329, 27)" leading="" trailing=" " raw_val="m" val="m"/>
                          <IdentNode start="(329, 28)" end="(329, 29)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(329, 30)" end="(329, 32)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(329, 33)" end="(329, 74)" kind="«term_&amp;lt;$&amp;gt;_»">
                          <OtherNode start="(329, 33)" end="(329, 62)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(329, 33)" end="(329, 34)" leading="" trailing="" val="("/>
                            <OtherNode start="(329, 34)" end="(329, 61)" kind="Lean.Parser.Term.fun">
                              <AtomNode start="(329, 34)" end="(329, 37)" leading="" trailing=" " val="fun"/>
                              <OtherNode start="(329, 38)" end="(329, 61)" kind="Lean.Parser.Term.basicFun">
                                <NullNode start="(329, 38)" end="(329, 39)">
                                  <IdentNode start="(329, 38)" end="(329, 39)" leading="" trailing=" " raw_val="c" val="c"/>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(329, 40)" end="(329, 42)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(329, 43)" end="(329, 61)" kind="Lean.Parser.Term.app">
                                  <OtherNode start="(329, 43)" end="(329, 49)" kind="Lean.Parser.Term.dotIdent">
                                    <AtomNode start="(329, 43)" end="(329, 44)" leading="" trailing="" val="."/>
                                    <IdentNode start="(329, 44)" end="(329, 49)" leading="" trailing=" " raw_val="yield" val="yield"/>
                                  </OtherNode>
                                  <NullNode start="(329, 50)" end="(329, 61)">
                                    <OtherNode start="(329, 50)" end="(329, 61)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(329, 50)" end="(329, 51)" leading="" trailing="" val="("/>
                                      <OtherNode start="(329, 51)" end="(329, 60)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(329, 51)" end="(329, 52)" leading="" trailing=" " raw_val="g" val="g"/>
                                        <NullNode start="(329, 53)" end="(329, 60)">
                                          <IdentNode start="(329, 53)" end="(329, 54)" leading="" trailing=" " raw_val="a" val="a"/>
                                          <IdentNode start="(329, 55)" end="(329, 56)" leading="" trailing=" " raw_val="m" val="m"/>
                                          <IdentNode start="(329, 57)" end="(329, 58)" leading="" trailing=" " raw_val="b" val="b"/>
                                          <IdentNode start="(329, 59)" end="(329, 60)" leading="" trailing="" raw_val="c" val="c"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(329, 60)" end="(329, 61)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(329, 61)" end="(329, 62)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <AtomNode start="(329, 63)" end="(329, 66)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                          <OtherNode start="(329, 67)" end="(329, 74)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(329, 67)" end="(329, 68)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(329, 69)" end="(329, 74)">
                              <IdentNode start="(329, 69)" end="(329, 70)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(329, 71)" end="(329, 72)" leading="" trailing=" " raw_val="m" val="m"/>
                              <IdentNode start="(329, 73)" end="(329, 74)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(329, 74)" end="(329, 75)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(329, 76)" end="(329, 77)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(330, 7)" end="(330, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(330, 7)" end="(330, 22)" leading="" trailing=" " raw_val="l.attach.foldlM" val="l.attach.foldlM"/>
                <NullNode start="(330, 23)" end="(330, 65)">
                  <OtherNode start="(330, 23)" end="(330, 60)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(330, 23)" end="(330, 24)" leading="" trailing="" val="("/>
                    <OtherNode start="(330, 24)" end="(330, 59)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(330, 24)" end="(330, 27)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(330, 28)" end="(330, 59)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(330, 28)" end="(330, 36)">
                          <IdentNode start="(330, 28)" end="(330, 29)" leading="" trailing=" " raw_val="b" val="b"/>
                          <OtherNode start="(330, 30)" end="(330, 36)" kind="Lean.Parser.Term.anonymousCtor">
                            <AtomNode start="(330, 30)" end="(330, 31)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(330, 31)" end="(330, 35)">
                              <IdentNode start="(330, 31)" end="(330, 32)" leading="" trailing="" raw_val="a" val="a"/>
                              <AtomNode start="(330, 32)" end="(330, 33)" leading="" trailing=" " val=","/>
                              <IdentNode start="(330, 34)" end="(330, 35)" leading="" trailing="" raw_val="m" val="m"/>
                            </NullNode>
                            <AtomNode start="(330, 35)" end="(330, 36)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(330, 37)" end="(330, 39)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(330, 40)" end="(330, 59)" kind="«term_&amp;lt;$&amp;gt;_»">
                          <OtherNode start="(330, 40)" end="(330, 47)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(330, 40)" end="(330, 41)" leading="" trailing=" " raw_val="g" val="g"/>
                            <NullNode start="(330, 42)" end="(330, 47)">
                              <IdentNode start="(330, 42)" end="(330, 43)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(330, 44)" end="(330, 45)" leading="" trailing=" " raw_val="m" val="m"/>
                              <IdentNode start="(330, 46)" end="(330, 47)" leading="" trailing=" " raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(330, 48)" end="(330, 51)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                          <OtherNode start="(330, 52)" end="(330, 59)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(330, 52)" end="(330, 53)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(330, 54)" end="(330, 59)">
                              <IdentNode start="(330, 54)" end="(330, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(330, 56)" end="(330, 57)" leading="" trailing=" " raw_val="m" val="m"/>
                              <IdentNode start="(330, 58)" end="(330, 59)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(330, 59)" end="(330, 60)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(330, 61)" end="(330, 65)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(330, 66)" end="(332, 52)">
          <AtomNode start="(330, 66)" end="(330, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(330, 69)" end="(332, 52)">
            <AtomNode start="(330, 69)" end="(330, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(331, 3)" end="(332, 52)">
              <TacticTacticseq1IndentedNode start="(331, 3)" end="(332, 52)">
                <NullNode start="(331, 3)" end="(332, 52)">
                  <OtherNode start="(331, 3)" end="(331, 31)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : (a : α) → a ∈ l → β → m γ&#10;g : (a : α) → a ∈ l → β → γ → β&#10;init : β&#10;⊢ (forIn' l init fun a m_1 b =&amp;gt; (fun c =&amp;gt; ForInStep.yield (g a m_1 b c)) &amp;lt;$&amp;gt; f a m_1 b) =&#10;    foldlM&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, m_1⟩ =&amp;gt; g a m_1 b &amp;lt;$&amp;gt; f a m_1 b)&#10;      init l.attach" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : (a : α) → a ∈ l → β → m γ&#10;g : (a : α) → a ∈ l → β → γ → β&#10;init : β&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; (fun c =&amp;gt; ForInStep.yield (g x.val ⋯ b c)) &amp;lt;$&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) l.attach =&#10;    foldlM (fun b x =&amp;gt; g x.val ⋯ b &amp;lt;$&amp;gt; f x.val ⋯ b) init l.attach" tactic="simp only [forIn'_eq_foldlM]">
                    <AtomNode start="(331, 3)" end="(331, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(331, 8)" end="(331, 12)">
                      <AtomNode start="(331, 8)" end="(331, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(331, 13)" end="(331, 31)">
                      <AtomNode start="(331, 13)" end="(331, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(331, 14)" end="(331, 30)">
                        <OtherNode start="(331, 14)" end="(331, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(331, 14)" end="(331, 30)" leading="" trailing="" raw_val="forIn'_eq_foldlM" val="forIn'_eq_foldlM" full_name="List.forIn'_eq_foldlM" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(297, 9)" def_end="(297, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(331, 30)" end="(331, 31)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(332, 3)" end="(332, 52)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : (a : α) → a ∈ l → β → m γ&#10;g : (a : α) → a ∈ l → β → γ → β&#10;init : β&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; (fun c =&amp;gt; ForInStep.yield (g x.val ⋯ b c)) &amp;lt;$&amp;gt; f x.val ⋯ b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) l.attach =&#10;    foldlM (fun b x =&amp;gt; g x.val ⋯ b &amp;lt;$&amp;gt; f x.val ⋯ b) init l.attach" state_after="no goals" tactic="induction l.attach generalizing init &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(332, 3)" end="(332, 39)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(332, 3)" end="(332, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(332, 13)" end="(332, 21)">
                        <OtherNode start="(332, 13)" end="(332, 21)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(332, 13)" end="(332, 21)" leading="" trailing=" " raw_val="l.attach" val="l.attach"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode start="(332, 22)" end="(332, 39)">
                        <AtomNode start="(332, 22)" end="(332, 34)" leading="" trailing=" " val="generalizing"/>
                        <NullNode start="(332, 35)" end="(332, 39)">
                          <IdentNode start="(332, 35)" end="(332, 39)" leading="" trailing=" " raw_val="init" val="init"/>
                        </NullNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(332, 40)" end="(332, 43)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(332, 44)" end="(332, 52)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(332, 44)" end="(332, 52)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(334, 1)" end="(339, 52)" name="forIn'_pure_yield_eq_foldl" full_name="List.forIn'_pure_yield_eq_foldl">
      <CommandDeclmodifiersNode start="(334, 1)" end="(334, 8)">
        <NullNode/>
        <NullNode start="(334, 1)" end="(334, 8)">
          <OtherNode start="(334, 1)" end="(334, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(334, 1)" end="(334, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(334, 3)" end="(334, 7)">
              <OtherNode start="(334, 3)" end="(334, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(334, 3)" end="(334, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(334, 3)" end="(334, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(334, 7)" end="(334, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(334, 9)" end="(339, 52)" name="forIn'_pure_yield_eq_foldl" full_name="List.forIn'_pure_yield_eq_foldl" _is_private_decl="False">
        <AtomNode start="(334, 9)" end="(334, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(334, 17)" end="(334, 43)">
          <IdentNode start="(334, 17)" end="(334, 43)" leading="" trailing=" " raw_val="forIn'_pure_yield_eq_foldl" val="forIn'_pure_yield_eq_foldl"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(334, 44)" end="(337, 68)">
          <NullNode start="(334, 44)" end="(335, 58)">
            <OtherNode start="(334, 44)" end="(334, 53)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(334, 44)" end="(334, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(334, 45)" end="(334, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(334, 45)" end="(334, 50)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(334, 51)" end="(334, 52)">
                  <IdentNode start="(334, 51)" end="(334, 52)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(334, 52)" end="(334, 53)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(334, 54)" end="(334, 69)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(334, 54)" end="(334, 55)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(334, 55)" end="(334, 68)" kind="Lean.Parser.Term.app">
                <IdentNode start="(334, 55)" end="(334, 66)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(334, 67)" end="(334, 68)">
                  <IdentNode start="(334, 67)" end="(334, 68)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(334, 68)" end="(334, 69)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(335, 5)" end="(335, 17)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(335, 5)" end="(335, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(335, 6)" end="(335, 7)">
                <IdentNode start="(335, 6)" end="(335, 7)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(335, 8)" end="(335, 16)">
                <AtomNode start="(335, 8)" end="(335, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(335, 10)" end="(335, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(335, 10)" end="(335, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(335, 15)" end="(335, 16)">
                    <IdentNode start="(335, 15)" end="(335, 16)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(335, 16)" end="(335, 17)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(335, 18)" end="(335, 47)">
              <AtomNode start="(335, 18)" end="(335, 19)" leading="" trailing="" val="("/>
              <NullNode start="(335, 19)" end="(335, 20)">
                <IdentNode start="(335, 19)" end="(335, 20)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(335, 21)" end="(335, 46)">
                <AtomNode start="(335, 21)" end="(335, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(335, 23)" end="(335, 46)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(335, 23)" end="(335, 30)">
                    <AtomNode start="(335, 23)" end="(335, 24)" leading="" trailing="" val="("/>
                    <NullNode start="(335, 24)" end="(335, 25)">
                      <IdentNode start="(335, 24)" end="(335, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(335, 26)" end="(335, 29)">
                      <AtomNode start="(335, 26)" end="(335, 27)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(335, 28)" end="(335, 29)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(335, 29)" end="(335, 30)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(335, 31)" end="(335, 32)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(335, 33)" end="(335, 46)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(335, 33)" end="(335, 38)" kind="«term_∈_»">
                      <IdentNode start="(335, 33)" end="(335, 34)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(335, 35)" end="(335, 36)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(335, 37)" end="(335, 38)" leading="" trailing=" " raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(335, 39)" end="(335, 40)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(335, 41)" end="(335, 46)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(335, 41)" end="(335, 42)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(335, 43)" end="(335, 44)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(335, 45)" end="(335, 46)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(335, 46)" end="(335, 47)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(335, 48)" end="(335, 58)">
              <AtomNode start="(335, 48)" end="(335, 49)" leading="" trailing="" val="("/>
              <NullNode start="(335, 49)" end="(335, 53)">
                <IdentNode start="(335, 49)" end="(335, 53)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(335, 54)" end="(335, 57)">
                <AtomNode start="(335, 54)" end="(335, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(335, 56)" end="(335, 57)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(335, 57)" end="(335, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(335, 59)" end="(337, 68)">
            <AtomNode start="(335, 59)" end="(335, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(336, 5)" end="(337, 68)" kind="«term_=_»">
              <OtherNode start="(336, 5)" end="(336, 57)" kind="Lean.Parser.Term.app">
                <IdentNode start="(336, 5)" end="(336, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(336, 12)" end="(336, 57)">
                  <IdentNode start="(336, 12)" end="(336, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(336, 14)" end="(336, 18)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(336, 19)" end="(336, 57)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(336, 19)" end="(336, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(336, 20)" end="(336, 56)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(336, 20)" end="(336, 23)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(336, 24)" end="(336, 56)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(336, 24)" end="(336, 29)">
                          <IdentNode start="(336, 24)" end="(336, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(336, 26)" end="(336, 27)" leading="" trailing=" " raw_val="m" val="m"/>
                          <IdentNode start="(336, 28)" end="(336, 29)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(336, 30)" end="(336, 32)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(336, 33)" end="(336, 56)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(336, 33)" end="(336, 37)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(336, 38)" end="(336, 56)">
                            <OtherNode start="(336, 38)" end="(336, 56)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(336, 38)" end="(336, 39)" leading="" trailing="" val="("/>
                              <OtherNode start="(336, 39)" end="(336, 55)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(336, 39)" end="(336, 45)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(336, 39)" end="(336, 40)" leading="" trailing="" val="."/>
                                  <IdentNode start="(336, 40)" end="(336, 45)" leading="" trailing=" " raw_val="yield" val="yield"/>
                                </OtherNode>
                                <NullNode start="(336, 46)" end="(336, 55)">
                                  <OtherNode start="(336, 46)" end="(336, 55)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(336, 46)" end="(336, 47)" leading="" trailing="" val="("/>
                                    <OtherNode start="(336, 47)" end="(336, 54)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(336, 47)" end="(336, 48)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(336, 49)" end="(336, 54)">
                                        <IdentNode start="(336, 49)" end="(336, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                                        <IdentNode start="(336, 51)" end="(336, 52)" leading="" trailing=" " raw_val="m" val="m"/>
                                        <IdentNode start="(336, 53)" end="(336, 54)" leading="" trailing="" raw_val="b" val="b"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(336, 54)" end="(336, 55)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(336, 55)" end="(336, 56)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(336, 56)" end="(336, 57)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(336, 58)" end="(336, 59)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(337, 7)" end="(337, 68)" kind="Lean.Parser.Term.app">
                <IdentNode start="(337, 7)" end="(337, 11)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(337, 12)" end="(337, 68)">
                  <OtherNode start="(337, 12)" end="(337, 20)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(337, 12)" end="(337, 13)" leading="" trailing="" val="("/>
                    <IdentNode start="(337, 13)" end="(337, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                    <AtomNode start="(337, 15)" end="(337, 17)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(337, 18)" end="(337, 19)" leading="" trailing="" raw_val="m" val="m"/>
                    <AtomNode start="(337, 19)" end="(337, 20)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(337, 21)" end="(337, 68)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(337, 21)" end="(337, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(337, 22)" end="(337, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(337, 22)" end="(337, 36)" leading="" trailing=" " raw_val="l.attach.foldl" val="l.attach.foldl"/>
                      <NullNode start="(337, 37)" end="(337, 67)">
                        <OtherNode start="(337, 37)" end="(337, 62)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(337, 37)" end="(337, 38)" leading="" trailing="" val="("/>
                          <OtherNode start="(337, 38)" end="(337, 61)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(337, 38)" end="(337, 41)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(337, 42)" end="(337, 61)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(337, 42)" end="(337, 50)">
                                <IdentNode start="(337, 42)" end="(337, 43)" leading="" trailing=" " raw_val="b" val="b"/>
                                <OtherNode start="(337, 44)" end="(337, 50)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(337, 44)" end="(337, 45)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(337, 45)" end="(337, 49)">
                                    <IdentNode start="(337, 45)" end="(337, 46)" leading="" trailing="" raw_val="a" val="a"/>
                                    <AtomNode start="(337, 46)" end="(337, 47)" leading="" trailing=" " val=","/>
                                    <IdentNode start="(337, 48)" end="(337, 49)" leading="" trailing="" raw_val="h" val="h"/>
                                  </NullNode>
                                  <AtomNode start="(337, 49)" end="(337, 50)" leading="" trailing=" " val="⟩"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(337, 51)" end="(337, 53)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(337, 54)" end="(337, 61)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(337, 54)" end="(337, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(337, 56)" end="(337, 61)">
                                  <IdentNode start="(337, 56)" end="(337, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(337, 58)" end="(337, 59)" leading="" trailing=" " raw_val="h" val="h"/>
                                  <IdentNode start="(337, 60)" end="(337, 61)" leading="" trailing="" raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(337, 61)" end="(337, 62)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <IdentNode start="(337, 63)" end="(337, 67)" leading="" trailing="" raw_val="init" val="init"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(337, 67)" end="(337, 68)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(337, 69)" end="(339, 52)">
          <AtomNode start="(337, 69)" end="(337, 71)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(337, 72)" end="(339, 52)">
            <AtomNode start="(337, 72)" end="(337, 74)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(338, 3)" end="(339, 52)">
              <TacticTacticseq1IndentedNode start="(338, 3)" end="(339, 52)">
                <NullNode start="(338, 3)" end="(339, 52)">
                  <OtherNode start="(338, 3)" end="(338, 31)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : (a : α) → a ∈ l → β → β&#10;init : β&#10;⊢ (forIn' l init fun a m_1 b =&amp;gt; pure (ForInStep.yield (f a m_1 b))) =&#10;    pure&#10;      (foldl&#10;        (fun b x =&amp;gt;&#10;          match x with&#10;          | ⟨a, h⟩ =&amp;gt; f a h b)&#10;        init l.attach)" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : (a : α) → a ∈ l → β → β&#10;init : β&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; pure (ForInStep.yield (f x.val ⋯ b))&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) l.attach =&#10;    pure (foldl (fun b x =&amp;gt; f x.val ⋯ b) init l.attach)" tactic="simp only [forIn'_eq_foldlM]">
                    <AtomNode start="(338, 3)" end="(338, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(338, 8)" end="(338, 12)">
                      <AtomNode start="(338, 8)" end="(338, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(338, 13)" end="(338, 31)">
                      <AtomNode start="(338, 13)" end="(338, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(338, 14)" end="(338, 30)">
                        <OtherNode start="(338, 14)" end="(338, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(338, 14)" end="(338, 30)" leading="" trailing="" raw_val="forIn'_eq_foldlM" val="forIn'_eq_foldlM" full_name="List.forIn'_eq_foldlM" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(297, 9)" def_end="(297, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(338, 30)" end="(338, 31)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(339, 3)" end="(339, 52)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : (a : α) → a ∈ l → β → β&#10;init : β&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; pure (ForInStep.yield (f x.val ⋯ b))&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) l.attach =&#10;    pure (foldl (fun b x =&amp;gt; f x.val ⋯ b) init l.attach)" state_after="no goals" tactic="induction l.attach generalizing init &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(339, 3)" end="(339, 39)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(339, 3)" end="(339, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(339, 13)" end="(339, 21)">
                        <OtherNode start="(339, 13)" end="(339, 21)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(339, 13)" end="(339, 21)" leading="" trailing=" " raw_val="l.attach" val="l.attach"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode start="(339, 22)" end="(339, 39)">
                        <AtomNode start="(339, 22)" end="(339, 34)" leading="" trailing=" " val="generalizing"/>
                        <NullNode start="(339, 35)" end="(339, 39)">
                          <IdentNode start="(339, 35)" end="(339, 39)" leading="" trailing=" " raw_val="init" val="init"/>
                        </NullNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(339, 40)" end="(339, 43)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(339, 44)" end="(339, 52)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(339, 44)" end="(339, 52)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(341, 1)" end="(346, 52)" name="forIn'_yield_eq_foldl" full_name="List.forIn'_yield_eq_foldl">
      <CommandDeclmodifiersNode start="(341, 1)" end="(341, 8)">
        <NullNode/>
        <NullNode start="(341, 1)" end="(341, 8)">
          <OtherNode start="(341, 1)" end="(341, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(341, 1)" end="(341, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(341, 3)" end="(341, 7)">
              <OtherNode start="(341, 3)" end="(341, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(341, 3)" end="(341, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(341, 3)" end="(341, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(341, 7)" end="(341, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(341, 9)" end="(346, 52)" name="forIn'_yield_eq_foldl" full_name="List.forIn'_yield_eq_foldl" _is_private_decl="False">
        <AtomNode start="(341, 9)" end="(341, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(341, 17)" end="(341, 38)">
          <IdentNode start="(341, 17)" end="(341, 38)" leading="" trailing="&#10;    " raw_val="forIn'_yield_eq_foldl" val="forIn'_yield_eq_foldl"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(342, 5)" end="(344, 52)">
          <NullNode start="(342, 5)" end="(342, 58)">
            <OtherNode start="(342, 5)" end="(342, 17)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(342, 5)" end="(342, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(342, 6)" end="(342, 7)">
                <IdentNode start="(342, 6)" end="(342, 7)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(342, 8)" end="(342, 16)">
                <AtomNode start="(342, 8)" end="(342, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(342, 10)" end="(342, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(342, 10)" end="(342, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(342, 15)" end="(342, 16)">
                    <IdentNode start="(342, 15)" end="(342, 16)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(342, 16)" end="(342, 17)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(342, 18)" end="(342, 47)">
              <AtomNode start="(342, 18)" end="(342, 19)" leading="" trailing="" val="("/>
              <NullNode start="(342, 19)" end="(342, 20)">
                <IdentNode start="(342, 19)" end="(342, 20)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(342, 21)" end="(342, 46)">
                <AtomNode start="(342, 21)" end="(342, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(342, 23)" end="(342, 46)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(342, 23)" end="(342, 30)">
                    <AtomNode start="(342, 23)" end="(342, 24)" leading="" trailing="" val="("/>
                    <NullNode start="(342, 24)" end="(342, 25)">
                      <IdentNode start="(342, 24)" end="(342, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(342, 26)" end="(342, 29)">
                      <AtomNode start="(342, 26)" end="(342, 27)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(342, 28)" end="(342, 29)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(342, 29)" end="(342, 30)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(342, 31)" end="(342, 32)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(342, 33)" end="(342, 46)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(342, 33)" end="(342, 38)" kind="«term_∈_»">
                      <IdentNode start="(342, 33)" end="(342, 34)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(342, 35)" end="(342, 36)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(342, 37)" end="(342, 38)" leading="" trailing=" " raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(342, 39)" end="(342, 40)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(342, 41)" end="(342, 46)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(342, 41)" end="(342, 42)" leading="" trailing=" " raw_val="β" val="β"/>
                      <AtomNode start="(342, 43)" end="(342, 44)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(342, 45)" end="(342, 46)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(342, 46)" end="(342, 47)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(342, 48)" end="(342, 58)">
              <AtomNode start="(342, 48)" end="(342, 49)" leading="" trailing="" val="("/>
              <NullNode start="(342, 49)" end="(342, 53)">
                <IdentNode start="(342, 49)" end="(342, 53)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(342, 54)" end="(342, 57)">
                <AtomNode start="(342, 54)" end="(342, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(342, 56)" end="(342, 57)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(342, 57)" end="(342, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(342, 59)" end="(344, 52)">
            <AtomNode start="(342, 59)" end="(342, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(343, 5)" end="(344, 52)" kind="«term_=_»">
              <OtherNode start="(343, 5)" end="(343, 60)" kind="Lean.Parser.Term.app">
                <IdentNode start="(343, 5)" end="(343, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(343, 12)" end="(343, 60)">
                  <OtherNode start="(343, 12)" end="(343, 21)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(343, 12)" end="(343, 13)" leading="" trailing="" val="("/>
                    <IdentNode start="(343, 13)" end="(343, 14)" leading="" trailing=" " raw_val="m" val="m"/>
                    <AtomNode start="(343, 15)" end="(343, 17)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(343, 18)" end="(343, 20)" leading="" trailing="" raw_val="Id" val="Id" full_name="Id" mod_name="Init.Control.Id" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Id.lean"/>
                    <AtomNode start="(343, 20)" end="(343, 21)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(343, 22)" end="(343, 23)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(343, 24)" end="(343, 28)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(343, 29)" end="(343, 60)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(343, 29)" end="(343, 30)" leading="" trailing="" val="("/>
                    <OtherNode start="(343, 30)" end="(343, 59)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(343, 30)" end="(343, 33)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(343, 34)" end="(343, 59)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(343, 34)" end="(343, 39)">
                          <IdentNode start="(343, 34)" end="(343, 35)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(343, 36)" end="(343, 37)" leading="" trailing=" " raw_val="m" val="m"/>
                          <IdentNode start="(343, 38)" end="(343, 39)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(343, 40)" end="(343, 42)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(343, 43)" end="(343, 59)" kind="Lean.Parser.Term.app">
                          <OtherNode start="(343, 43)" end="(343, 49)" kind="Lean.Parser.Term.dotIdent">
                            <AtomNode start="(343, 43)" end="(343, 44)" leading="" trailing="" val="."/>
                            <IdentNode start="(343, 44)" end="(343, 49)" leading="" trailing=" " raw_val="yield" val="yield"/>
                          </OtherNode>
                          <NullNode start="(343, 50)" end="(343, 59)">
                            <OtherNode start="(343, 50)" end="(343, 59)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(343, 50)" end="(343, 51)" leading="" trailing="" val="("/>
                              <OtherNode start="(343, 51)" end="(343, 58)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(343, 51)" end="(343, 52)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(343, 53)" end="(343, 58)">
                                  <IdentNode start="(343, 53)" end="(343, 54)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(343, 55)" end="(343, 56)" leading="" trailing=" " raw_val="m" val="m"/>
                                  <IdentNode start="(343, 57)" end="(343, 58)" leading="" trailing="" raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(343, 58)" end="(343, 59)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(343, 59)" end="(343, 60)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(343, 61)" end="(343, 62)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(344, 7)" end="(344, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(344, 7)" end="(344, 21)" leading="" trailing=" " raw_val="l.attach.foldl" val="l.attach.foldl"/>
                <NullNode start="(344, 22)" end="(344, 52)">
                  <OtherNode start="(344, 22)" end="(344, 47)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(344, 22)" end="(344, 23)" leading="" trailing="" val="("/>
                    <OtherNode start="(344, 23)" end="(344, 46)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(344, 23)" end="(344, 26)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(344, 27)" end="(344, 46)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(344, 27)" end="(344, 35)">
                          <IdentNode start="(344, 27)" end="(344, 28)" leading="" trailing=" " raw_val="b" val="b"/>
                          <OtherNode start="(344, 29)" end="(344, 35)" kind="Lean.Parser.Term.anonymousCtor">
                            <AtomNode start="(344, 29)" end="(344, 30)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(344, 30)" end="(344, 34)">
                              <IdentNode start="(344, 30)" end="(344, 31)" leading="" trailing="" raw_val="a" val="a"/>
                              <AtomNode start="(344, 31)" end="(344, 32)" leading="" trailing=" " val=","/>
                              <IdentNode start="(344, 33)" end="(344, 34)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                            <AtomNode start="(344, 34)" end="(344, 35)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(344, 36)" end="(344, 38)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(344, 39)" end="(344, 46)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(344, 39)" end="(344, 40)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(344, 41)" end="(344, 46)">
                            <IdentNode start="(344, 41)" end="(344, 42)" leading="" trailing=" " raw_val="a" val="a"/>
                            <IdentNode start="(344, 43)" end="(344, 44)" leading="" trailing=" " raw_val="h" val="h"/>
                            <IdentNode start="(344, 45)" end="(344, 46)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(344, 46)" end="(344, 47)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(344, 48)" end="(344, 52)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(344, 53)" end="(346, 52)">
          <AtomNode start="(344, 53)" end="(344, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(344, 56)" end="(346, 52)">
            <AtomNode start="(344, 56)" end="(344, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(345, 3)" end="(346, 52)">
              <TacticTacticseq1IndentedNode start="(345, 3)" end="(346, 52)">
                <NullNode start="(345, 3)" end="(346, 52)">
                  <OtherNode start="(345, 3)" end="(345, 31)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (a : α) → a ∈ l → β → β&#10;init : β&#10;⊢ (forIn' l init fun a m b =&amp;gt; ForInStep.yield (f a m b)) =&#10;    foldl&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨a, h⟩ =&amp;gt; f a h b)&#10;      init l.attach" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (a : α) → a ∈ l → β → β&#10;init : β&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; ForInStep.yield (f x.val ⋯ b)&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) l.attach =&#10;    foldl (fun b x =&amp;gt; f x.val ⋯ b) init l.attach" tactic="simp only [forIn'_eq_foldlM]">
                    <AtomNode start="(345, 3)" end="(345, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(345, 8)" end="(345, 12)">
                      <AtomNode start="(345, 8)" end="(345, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(345, 13)" end="(345, 31)">
                      <AtomNode start="(345, 13)" end="(345, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(345, 14)" end="(345, 30)">
                        <OtherNode start="(345, 14)" end="(345, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(345, 14)" end="(345, 30)" leading="" trailing="" raw_val="forIn'_eq_foldlM" val="forIn'_eq_foldlM" full_name="List.forIn'_eq_foldlM" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(297, 9)" def_end="(297, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(345, 30)" end="(345, 31)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(346, 3)" end="(346, 52)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (a : α) → a ∈ l → β → β&#10;init : β&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b x =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; ForInStep.yield (f x.val ⋯ b)&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) l.attach =&#10;    foldl (fun b x =&amp;gt; f x.val ⋯ b) init l.attach" state_after="no goals" tactic="induction l.attach generalizing init &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(346, 3)" end="(346, 39)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(346, 3)" end="(346, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(346, 13)" end="(346, 21)">
                        <OtherNode start="(346, 13)" end="(346, 21)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(346, 13)" end="(346, 21)" leading="" trailing=" " raw_val="l.attach" val="l.attach"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode start="(346, 22)" end="(346, 39)">
                        <AtomNode start="(346, 22)" end="(346, 34)" leading="" trailing=" " val="generalizing"/>
                        <NullNode start="(346, 35)" end="(346, 39)">
                          <IdentNode start="(346, 35)" end="(346, 39)" leading="" trailing=" " raw_val="init" val="init"/>
                        </NullNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(346, 40)" end="(346, 43)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(346, 44)" end="(346, 52)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(346, 44)" end="(346, 52)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(348, 1)" end="(351, 45)" name="forIn'_map" full_name="List.forIn'_map">
      <CommandDeclmodifiersNode start="(348, 1)" end="(348, 8)">
        <NullNode/>
        <NullNode start="(348, 1)" end="(348, 8)">
          <OtherNode start="(348, 1)" end="(348, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(348, 1)" end="(348, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(348, 3)" end="(348, 7)">
              <OtherNode start="(348, 3)" end="(348, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(348, 3)" end="(348, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(348, 3)" end="(348, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(348, 7)" end="(348, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(348, 9)" end="(351, 45)" name="forIn'_map" full_name="List.forIn'_map" _is_private_decl="False">
        <AtomNode start="(348, 9)" end="(348, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(348, 17)" end="(348, 27)">
          <IdentNode start="(348, 17)" end="(348, 27)" leading="" trailing=" " raw_val="forIn'_map" val="forIn'_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(348, 28)" end="(350, 86)">
          <NullNode start="(348, 28)" end="(349, 79)">
            <OtherNode start="(348, 28)" end="(348, 37)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(348, 28)" end="(348, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(348, 29)" end="(348, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(348, 29)" end="(348, 34)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(348, 35)" end="(348, 36)">
                  <IdentNode start="(348, 35)" end="(348, 36)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(348, 36)" end="(348, 37)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(348, 38)" end="(348, 53)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(348, 38)" end="(348, 39)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(348, 39)" end="(348, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(348, 39)" end="(348, 50)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(348, 51)" end="(348, 52)">
                  <IdentNode start="(348, 51)" end="(348, 52)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(348, 52)" end="(348, 53)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(349, 5)" end="(349, 17)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(349, 5)" end="(349, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(349, 6)" end="(349, 7)">
                <IdentNode start="(349, 6)" end="(349, 7)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(349, 8)" end="(349, 16)">
                <AtomNode start="(349, 8)" end="(349, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(349, 10)" end="(349, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(349, 10)" end="(349, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(349, 15)" end="(349, 16)">
                    <IdentNode start="(349, 15)" end="(349, 16)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(349, 16)" end="(349, 17)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(349, 18)" end="(349, 29)">
              <AtomNode start="(349, 18)" end="(349, 19)" leading="" trailing="" val="("/>
              <NullNode start="(349, 19)" end="(349, 20)">
                <IdentNode start="(349, 19)" end="(349, 20)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(349, 21)" end="(349, 28)">
                <AtomNode start="(349, 21)" end="(349, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(349, 23)" end="(349, 28)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(349, 23)" end="(349, 24)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(349, 25)" end="(349, 26)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(349, 27)" end="(349, 28)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(349, 28)" end="(349, 29)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(349, 30)" end="(349, 79)">
              <AtomNode start="(349, 30)" end="(349, 31)" leading="" trailing="" val="("/>
              <NullNode start="(349, 31)" end="(349, 32)">
                <IdentNode start="(349, 31)" end="(349, 32)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(349, 33)" end="(349, 78)">
                <AtomNode start="(349, 33)" end="(349, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(349, 35)" end="(349, 78)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(349, 35)" end="(349, 42)">
                    <AtomNode start="(349, 35)" end="(349, 36)" leading="" trailing="" val="("/>
                    <NullNode start="(349, 36)" end="(349, 37)">
                      <IdentNode start="(349, 36)" end="(349, 37)" leading="" trailing=" " raw_val="b" val="b"/>
                    </NullNode>
                    <NullNode start="(349, 38)" end="(349, 41)">
                      <AtomNode start="(349, 38)" end="(349, 39)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(349, 40)" end="(349, 41)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(349, 41)" end="(349, 42)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(349, 43)" end="(349, 44)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(349, 45)" end="(349, 78)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(349, 45)" end="(349, 56)" kind="«term_∈_»">
                      <IdentNode start="(349, 45)" end="(349, 46)" leading="" trailing=" " raw_val="b" val="b"/>
                      <AtomNode start="(349, 47)" end="(349, 48)" leading="" trailing=" " val="∈"/>
                      <OtherNode start="(349, 49)" end="(349, 56)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(349, 49)" end="(349, 54)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                        <NullNode start="(349, 55)" end="(349, 56)">
                          <IdentNode start="(349, 55)" end="(349, 56)" leading="" trailing=" " raw_val="g" val="g"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(349, 57)" end="(349, 58)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(349, 59)" end="(349, 78)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(349, 59)" end="(349, 60)" leading="" trailing=" " raw_val="γ" val="γ"/>
                      <AtomNode start="(349, 61)" end="(349, 62)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(349, 63)" end="(349, 78)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(349, 63)" end="(349, 64)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(349, 65)" end="(349, 78)">
                          <OtherNode start="(349, 65)" end="(349, 78)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(349, 65)" end="(349, 66)" leading="" trailing="" val="("/>
                            <OtherNode start="(349, 66)" end="(349, 77)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(349, 66)" end="(349, 75)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                              <NullNode start="(349, 76)" end="(349, 77)">
                                <IdentNode start="(349, 76)" end="(349, 77)" leading="" trailing="" raw_val="γ" val="γ"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(349, 77)" end="(349, 78)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(349, 78)" end="(349, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(349, 80)" end="(350, 86)">
            <AtomNode start="(349, 80)" end="(349, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(350, 5)" end="(350, 86)" kind="«term_=_»">
              <OtherNode start="(350, 5)" end="(350, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(350, 5)" end="(350, 11)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(350, 12)" end="(350, 28)">
                  <OtherNode start="(350, 12)" end="(350, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(350, 12)" end="(350, 13)" leading="" trailing="" val="("/>
                    <OtherNode start="(350, 13)" end="(350, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(350, 13)" end="(350, 18)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                      <NullNode start="(350, 19)" end="(350, 20)">
                        <IdentNode start="(350, 19)" end="(350, 20)" leading="" trailing="" raw_val="g" val="g"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(350, 20)" end="(350, 21)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(350, 22)" end="(350, 26)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(350, 27)" end="(350, 28)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(350, 29)" end="(350, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(350, 31)" end="(350, 86)" kind="Lean.Parser.Term.app">
                <IdentNode start="(350, 31)" end="(350, 37)" leading="" trailing=" " raw_val="forIn'" val="forIn'" full_name="ForIn'.forIn'" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(350, 38)" end="(350, 86)">
                  <IdentNode start="(350, 38)" end="(350, 39)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(350, 40)" end="(350, 44)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(350, 45)" end="(350, 86)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(350, 45)" end="(350, 48)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(350, 49)" end="(350, 86)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(350, 49)" end="(350, 54)">
                        <IdentNode start="(350, 49)" end="(350, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(350, 51)" end="(350, 52)" leading="" trailing=" " raw_val="h" val="h"/>
                        <IdentNode start="(350, 53)" end="(350, 54)" leading="" trailing=" " raw_val="y" val="y"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(350, 55)" end="(350, 57)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(350, 58)" end="(350, 86)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(350, 58)" end="(350, 59)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(350, 60)" end="(350, 86)">
                          <OtherNode start="(350, 60)" end="(350, 65)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(350, 60)" end="(350, 61)" leading="" trailing="" val="("/>
                            <OtherNode start="(350, 61)" end="(350, 64)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(350, 61)" end="(350, 62)" leading="" trailing=" " raw_val="g" val="g"/>
                              <NullNode start="(350, 63)" end="(350, 64)">
                                <IdentNode start="(350, 63)" end="(350, 64)" leading="" trailing="" raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(350, 64)" end="(350, 65)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <OtherNode start="(350, 66)" end="(350, 84)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(350, 66)" end="(350, 67)" leading="" trailing="" val="("/>
                            <OtherNode start="(350, 67)" end="(350, 83)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(350, 67)" end="(350, 81)" leading="" trailing=" " raw_val="mem_map_of_mem" val="mem_map_of_mem" full_name="List.mem_map_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                              <NullNode start="(350, 82)" end="(350, 83)">
                                <IdentNode start="(350, 82)" end="(350, 83)" leading="" trailing="" raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(350, 83)" end="(350, 84)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <IdentNode start="(350, 85)" end="(350, 86)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(350, 87)" end="(351, 45)">
          <AtomNode start="(350, 87)" end="(350, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(350, 90)" end="(351, 45)">
            <AtomNode start="(350, 90)" end="(350, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(351, 3)" end="(351, 45)">
              <TacticTacticseq1IndentedNode start="(351, 3)" end="(351, 45)">
                <NullNode start="(351, 3)" end="(351, 45)">
                  <OtherNode start="(351, 3)" end="(351, 45)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;init : γ&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;g : α → β&#10;f : (b : β) → b ∈ map g l → γ → m (ForInStep γ)&#10;⊢ forIn' (map g l) init f = forIn' l init fun a h y =&amp;gt; f (g a) ⋯ y" state_after="no goals" tactic="induction l generalizing init &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(351, 3)" end="(351, 32)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(351, 3)" end="(351, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(351, 13)" end="(351, 14)">
                        <OtherNode start="(351, 13)" end="(351, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(351, 13)" end="(351, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode start="(351, 15)" end="(351, 32)">
                        <AtomNode start="(351, 15)" end="(351, 27)" leading="" trailing=" " val="generalizing"/>
                        <NullNode start="(351, 28)" end="(351, 32)">
                          <IdentNode start="(351, 28)" end="(351, 32)" leading="" trailing=" " raw_val="init" val="init"/>
                        </NullNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(351, 33)" end="(351, 36)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(351, 37)" end="(351, 45)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(351, 37)" end="(351, 45)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(353, 1)" end="(377, 16)" name="forIn_eq_foldlM" full_name="List.forIn_eq_foldlM">
      <CommandDeclmodifiersNode start="(353, 1)" end="(356, 3)">
        <NullNode start="(353, 1)" end="(356, 3)">
          <CommandDoccommentNode start="(353, 1)" end="(356, 3)" comment="We can express a for loop over a list as a fold,&#10;in which whenever we reach `.done b` we keep that value through the rest of the fold.&#10;-/">
            <AtomNode start="(353, 1)" end="(353, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(354, 1)" end="(356, 3)" leading="" trailing="&#10;" val="We can express a for loop over a list as a fold,&#10;in which whenever we reach `.done b` we keep that value through the rest of the fold.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(357, 1)" end="(377, 16)" name="forIn_eq_foldlM" full_name="List.forIn_eq_foldlM" _is_private_decl="False">
        <AtomNode start="(357, 1)" end="(357, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(357, 9)" end="(357, 24)">
          <IdentNode start="(357, 9)" end="(357, 24)" leading="" trailing=" " raw_val="forIn_eq_foldlM" val="forIn_eq_foldlM"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(357, 25)" end="(362, 60)">
          <NullNode start="(357, 25)" end="(358, 58)">
            <OtherNode start="(357, 25)" end="(357, 34)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(357, 25)" end="(357, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(357, 26)" end="(357, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(357, 26)" end="(357, 31)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(357, 32)" end="(357, 33)">
                  <IdentNode start="(357, 32)" end="(357, 33)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(357, 33)" end="(357, 34)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(357, 35)" end="(357, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(357, 35)" end="(357, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(357, 36)" end="(357, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(357, 36)" end="(357, 47)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(357, 48)" end="(357, 49)">
                  <IdentNode start="(357, 48)" end="(357, 49)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(357, 49)" end="(357, 50)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(358, 5)" end="(358, 17)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(358, 5)" end="(358, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(358, 6)" end="(358, 7)">
                <IdentNode start="(358, 6)" end="(358, 7)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(358, 8)" end="(358, 16)">
                <AtomNode start="(358, 8)" end="(358, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(358, 10)" end="(358, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(358, 10)" end="(358, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(358, 15)" end="(358, 16)">
                    <IdentNode start="(358, 15)" end="(358, 16)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(358, 16)" end="(358, 17)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(358, 18)" end="(358, 47)">
              <AtomNode start="(358, 18)" end="(358, 19)" leading="" trailing="" val="("/>
              <NullNode start="(358, 19)" end="(358, 20)">
                <IdentNode start="(358, 19)" end="(358, 20)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(358, 21)" end="(358, 46)">
                <AtomNode start="(358, 21)" end="(358, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(358, 23)" end="(358, 46)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(358, 23)" end="(358, 24)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(358, 25)" end="(358, 26)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(358, 27)" end="(358, 46)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(358, 27)" end="(358, 28)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(358, 29)" end="(358, 30)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(358, 31)" end="(358, 46)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(358, 31)" end="(358, 32)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(358, 33)" end="(358, 46)">
                        <OtherNode start="(358, 33)" end="(358, 46)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(358, 33)" end="(358, 34)" leading="" trailing="" val="("/>
                          <OtherNode start="(358, 34)" end="(358, 45)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(358, 34)" end="(358, 43)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                            <NullNode start="(358, 44)" end="(358, 45)">
                              <IdentNode start="(358, 44)" end="(358, 45)" leading="" trailing="" raw_val="β" val="β"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(358, 45)" end="(358, 46)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(358, 46)" end="(358, 47)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(358, 48)" end="(358, 58)">
              <AtomNode start="(358, 48)" end="(358, 49)" leading="" trailing="" val="("/>
              <NullNode start="(358, 49)" end="(358, 53)">
                <IdentNode start="(358, 49)" end="(358, 53)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(358, 54)" end="(358, 57)">
                <AtomNode start="(358, 54)" end="(358, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(358, 56)" end="(358, 57)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(358, 57)" end="(358, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(358, 59)" end="(362, 60)">
            <AtomNode start="(358, 59)" end="(358, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(359, 5)" end="(362, 60)" kind="«term_=_»">
              <OtherNode start="(359, 5)" end="(359, 19)" kind="Lean.Parser.Term.app">
                <IdentNode start="(359, 5)" end="(359, 10)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(359, 11)" end="(359, 19)">
                  <IdentNode start="(359, 11)" end="(359, 12)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(359, 13)" end="(359, 17)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(359, 18)" end="(359, 19)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(359, 20)" end="(359, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(359, 22)" end="(362, 60)" kind="«term_&amp;lt;$&amp;gt;_»">
                <IdentNode start="(359, 22)" end="(359, 37)" leading="" trailing=" " raw_val="ForInStep.value" val="ForInStep.value" full_name="ForInStep.value" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                <AtomNode start="(359, 38)" end="(359, 41)" leading="" trailing="&#10;      " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(360, 7)" end="(362, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(360, 7)" end="(360, 15)" leading="" trailing=" " raw_val="l.foldlM" val="l.foldlM"/>
                  <NullNode start="(360, 16)" end="(362, 60)">
                    <OtherNode start="(360, 16)" end="(362, 37)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(360, 16)" end="(360, 17)" leading="" trailing="" val="("/>
                      <OtherNode start="(360, 17)" end="(362, 36)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(360, 17)" end="(360, 20)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(360, 21)" end="(362, 36)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(360, 21)" end="(360, 24)">
                            <IdentNode start="(360, 21)" end="(360, 22)" leading="" trailing=" " raw_val="b" val="b"/>
                            <IdentNode start="(360, 23)" end="(360, 24)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(360, 25)" end="(360, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(360, 28)" end="(362, 36)" kind="Lean.Parser.Term.match">
                            <AtomNode start="(360, 28)" end="(360, 33)" leading="" trailing=" " val="match"/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(360, 34)" end="(360, 35)">
                              <OtherNode start="(360, 34)" end="(360, 35)" kind="Lean.Parser.Term.matchDiscr">
                                <NullNode/>
                                <IdentNode start="(360, 34)" end="(360, 35)" leading="" trailing=" " raw_val="b" val="b"/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(360, 36)" end="(360, 40)" leading="" trailing="&#10;        " val="with"/>
                            <OtherNode start="(361, 9)" end="(362, 36)" kind="Lean.Parser.Term.matchAlts">
                              <NullNode start="(361, 9)" end="(362, 36)">
                                <OtherNode start="(361, 9)" end="(361, 28)" kind="Lean.Parser.Term.matchAlt">
                                  <AtomNode start="(361, 9)" end="(361, 10)" leading="" trailing=" " val="|"/>
                                  <NullNode start="(361, 11)" end="(361, 19)">
                                    <NullNode start="(361, 11)" end="(361, 19)">
                                      <OtherNode start="(361, 11)" end="(361, 19)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(361, 11)" end="(361, 17)" kind="Lean.Parser.Term.dotIdent">
                                          <AtomNode start="(361, 11)" end="(361, 12)" leading="" trailing="" val="."/>
                                          <IdentNode start="(361, 12)" end="(361, 17)" leading="" trailing=" " raw_val="yield" val="yield"/>
                                        </OtherNode>
                                        <NullNode start="(361, 18)" end="(361, 19)">
                                          <IdentNode start="(361, 18)" end="(361, 19)" leading="" trailing=" " raw_val="b" val="b"/>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(361, 20)" end="(361, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <OtherNode start="(361, 23)" end="(361, 28)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(361, 23)" end="(361, 24)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <NullNode start="(361, 25)" end="(361, 28)">
                                      <IdentNode start="(361, 25)" end="(361, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                                      <IdentNode start="(361, 27)" end="(361, 28)" leading="" trailing="&#10;        " raw_val="b" val="b"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <OtherNode start="(362, 9)" end="(362, 36)" kind="Lean.Parser.Term.matchAlt">
                                  <AtomNode start="(362, 9)" end="(362, 10)" leading="" trailing=" " val="|"/>
                                  <NullNode start="(362, 11)" end="(362, 18)">
                                    <NullNode start="(362, 11)" end="(362, 18)">
                                      <OtherNode start="(362, 11)" end="(362, 18)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(362, 11)" end="(362, 16)" kind="Lean.Parser.Term.dotIdent">
                                          <AtomNode start="(362, 11)" end="(362, 12)" leading="" trailing="" val="."/>
                                          <IdentNode start="(362, 12)" end="(362, 16)" leading="" trailing=" " raw_val="done" val="done"/>
                                        </OtherNode>
                                        <NullNode start="(362, 17)" end="(362, 18)">
                                          <IdentNode start="(362, 17)" end="(362, 18)" leading="" trailing=" " raw_val="b" val="b"/>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(362, 19)" end="(362, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <OtherNode start="(362, 22)" end="(362, 36)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(362, 22)" end="(362, 26)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(362, 27)" end="(362, 36)">
                                      <OtherNode start="(362, 27)" end="(362, 36)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(362, 27)" end="(362, 28)" leading="" trailing="" val="("/>
                                        <OtherNode start="(362, 28)" end="(362, 35)" kind="Lean.Parser.Term.app">
                                          <OtherNode start="(362, 28)" end="(362, 33)" kind="Lean.Parser.Term.dotIdent">
                                            <AtomNode start="(362, 28)" end="(362, 29)" leading="" trailing="" val="."/>
                                            <IdentNode start="(362, 29)" end="(362, 33)" leading="" trailing=" " raw_val="done" val="done"/>
                                          </OtherNode>
                                          <NullNode start="(362, 34)" end="(362, 35)">
                                            <IdentNode start="(362, 34)" end="(362, 35)" leading="" trailing="" raw_val="b" val="b"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(362, 35)" end="(362, 36)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(362, 36)" end="(362, 37)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(362, 38)" end="(362, 60)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(362, 38)" end="(362, 39)" leading="" trailing="" val="("/>
                      <OtherNode start="(362, 39)" end="(362, 59)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(362, 39)" end="(362, 54)" leading="" trailing=" " raw_val="ForInStep.yield" val="ForInStep.yield" full_name="ForInStep.yield" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        <NullNode start="(362, 55)" end="(362, 59)">
                          <IdentNode start="(362, 55)" end="(362, 59)" leading="" trailing="" raw_val="init" val="init"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(362, 59)" end="(362, 60)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(362, 61)" end="(377, 16)">
          <AtomNode start="(362, 61)" end="(362, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(362, 64)" end="(377, 16)">
            <AtomNode start="(362, 64)" end="(362, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(363, 3)" end="(377, 16)">
              <TacticTacticseq1IndentedNode start="(363, 3)" end="(377, 16)">
                <NullNode start="(363, 3)" end="(377, 16)">
                  <OtherNode start="(363, 3)" end="(377, 16)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → β → m (ForInStep β)&#10;init : β&#10;⊢ forIn l init f =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) l" state_after="no goals" tactic="induction l generalizing init with&#10;| nil =&amp;gt; simp&#10;| cons a as ih =&amp;gt;&#10;  simp only [foldlM_cons, bind_pure_comp, forIn_cons, _root_.map_bind]&#10;  congr 1&#10;  funext x&#10;  match x with&#10;  | .done b =&amp;gt;&#10;    clear ih&#10;    dsimp&#10;    induction as with&#10;    | nil =&amp;gt; simp&#10;    | cons a as ih =&amp;gt; simp [ih]&#10;  | .yield b =&amp;gt;&#10;    simp [ih]">
                    <AtomNode start="(363, 3)" end="(363, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(363, 13)" end="(363, 14)">
                      <OtherNode start="(363, 13)" end="(363, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(363, 13)" end="(363, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(363, 15)" end="(363, 32)">
                      <AtomNode start="(363, 15)" end="(363, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(363, 28)" end="(363, 32)">
                        <IdentNode start="(363, 28)" end="(363, 32)" leading="" trailing=" " raw_val="init" val="init"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(363, 33)" end="(377, 16)">
                      <OtherNode start="(363, 33)" end="(377, 16)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(363, 33)" end="(363, 37)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(364, 3)" end="(377, 16)">
                          <OtherNode start="(364, 3)" end="(364, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(364, 3)" end="(364, 8)">
                              <OtherNode start="(364, 3)" end="(364, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(364, 3)" end="(364, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(364, 5)" end="(364, 8)">
                                  <NullNode/>
                                  <IdentNode start="(364, 5)" end="(364, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(364, 9)" end="(364, 16)">
                              <AtomNode start="(364, 9)" end="(364, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(364, 12)" end="(364, 16)">
                                <TacticTacticseq1IndentedNode start="(364, 12)" end="(364, 16)">
                                  <NullNode start="(364, 12)" end="(364, 16)">
                                    <OtherNode start="(364, 12)" end="(364, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;init : β&#10;⊢ forIn [] init f =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(364, 12)" end="(364, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(365, 3)" end="(377, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(365, 3)" end="(365, 17)">
                              <OtherNode start="(365, 3)" end="(365, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(365, 3)" end="(365, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(365, 5)" end="(365, 9)">
                                  <NullNode/>
                                  <IdentNode start="(365, 5)" end="(365, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(365, 10)" end="(365, 17)">
                                  <IdentNode start="(365, 10)" end="(365, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(365, 12)" end="(365, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                                  <IdentNode start="(365, 15)" end="(365, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(365, 18)" end="(377, 16)">
                              <AtomNode start="(365, 18)" end="(365, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(366, 5)" end="(377, 16)">
                                <TacticTacticseq1IndentedNode start="(366, 5)" end="(377, 16)">
                                  <NullNode start="(366, 5)" end="(377, 16)">
                                    <OtherNode start="(366, 5)" end="(366, 73)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (init : β),&#10;    forIn as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b a =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as&#10;init : β&#10;⊢ forIn (a :: as) init f =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) (a :: as)" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (init : β),&#10;    forIn as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b a =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as&#10;init : β&#10;⊢ (do&#10;      let x ← f a init&#10;      match x with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn as b f) =&#10;    do&#10;    let a ← f a init&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b a =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          a as" tactic="simp only [foldlM_cons, bind_pure_comp, forIn_cons, _root_.map_bind]">
                                      <AtomNode start="(366, 5)" end="(366, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(366, 10)" end="(366, 14)">
                                        <AtomNode start="(366, 10)" end="(366, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(366, 15)" end="(366, 73)">
                                        <AtomNode start="(366, 15)" end="(366, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(366, 16)" end="(366, 72)">
                                          <OtherNode start="(366, 16)" end="(366, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(366, 16)" end="(366, 27)" leading="" trailing="" raw_val="foldlM_cons" val="foldlM_cons" full_name="List.foldlM_cons" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(366, 27)" end="(366, 28)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(366, 29)" end="(366, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(366, 29)" end="(366, 43)" leading="" trailing="" raw_val="bind_pure_comp" val="bind_pure_comp" full_name="LawfulMonad.bind_pure_comp" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(366, 43)" end="(366, 44)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(366, 45)" end="(366, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(366, 45)" end="(366, 55)" leading="" trailing="" raw_val="forIn_cons" val="forIn_cons" full_name="List.forIn_cons" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(261, 17)" def_end="(261, 27)"/>
                                          </OtherNode>
                                          <AtomNode start="(366, 55)" end="(366, 56)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(366, 57)" end="(366, 72)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(366, 57)" end="(366, 72)" leading="" trailing="" raw_val="_root_.map_bind" val="_root_.map_bind" full_name="map_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(366, 72)" end="(366, 73)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(367, 5)" end="(367, 12)" kind="Lean.Parser.Tactic.congr" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (init : β),&#10;    forIn as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b a =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as&#10;init : β&#10;⊢ (do&#10;      let x ← f a init&#10;      match x with&#10;        | ForInStep.done b =&amp;gt; pure b&#10;        | ForInStep.yield b =&amp;gt; forIn as b f) =&#10;    do&#10;    let a ← f a init&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b a =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          a as" state_after="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (init : β),&#10;    forIn as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b a =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as&#10;init : β&#10;⊢ (fun x =&amp;gt;&#10;      match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn as b f) =&#10;    fun a =&amp;gt;&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        a as" tactic="congr 1">
                                      <AtomNode start="(367, 5)" end="(367, 10)" leading="" trailing=" " val="congr"/>
                                      <NullNode start="(367, 11)" end="(367, 12)">
                                        <OtherNode start="(367, 11)" end="(367, 12)" kind="num">
                                          <AtomNode start="(367, 11)" end="(367, 12)" leading="" trailing="&#10;    " val="1"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(368, 5)" end="(368, 13)" kind="tacticFunext___" state_before="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (init : β),&#10;    forIn as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b a =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as&#10;init : β&#10;⊢ (fun x =&amp;gt;&#10;      match x with&#10;      | ForInStep.done b =&amp;gt; pure b&#10;      | ForInStep.yield b =&amp;gt; forIn as b f) =&#10;    fun a =&amp;gt;&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        a as" state_after="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (init : β),&#10;    forIn as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b a =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as&#10;init : β&#10;x : ForInStep β&#10;⊢ (match x with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn as b f) =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        x as" tactic="funext x">
                                      <AtomNode start="(368, 5)" end="(368, 11)" leading="" trailing=" " val="funext"/>
                                      <NullNode start="(368, 12)" end="(368, 13)">
                                        <IdentNode start="(368, 12)" end="(368, 13)" leading="" trailing="&#10;    " raw_val="x" val="x"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(369, 5)" end="(377, 16)" kind="Lean.Parser.Tactic.match" state_before="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (init : β),&#10;    forIn as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b a =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as&#10;init : β&#10;x : ForInStep β&#10;⊢ (match x with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn as b f) =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        x as" state_after="no goals" tactic="match x with&#10;| .done b =&amp;gt;&#10;  clear ih&#10;  dsimp&#10;  induction as with&#10;  | nil =&amp;gt; simp&#10;  | cons a as ih =&amp;gt; simp [ih]&#10;| .yield b =&amp;gt;&#10;  simp [ih]">
                                      <AtomNode start="(369, 5)" end="(369, 10)" leading="" trailing=" " val="match"/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(369, 11)" end="(369, 12)">
                                        <OtherNode start="(369, 11)" end="(369, 12)" kind="Lean.Parser.Term.matchDiscr">
                                          <NullNode/>
                                          <IdentNode start="(369, 11)" end="(369, 12)" leading="" trailing=" " raw_val="x" val="x"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(369, 13)" end="(369, 17)" leading="" trailing="&#10;    " val="with"/>
                                      <OtherNode start="(370, 5)" end="(377, 16)" kind="Lean.Parser.Term.matchAlts">
                                        <NullNode start="(370, 5)" end="(377, 16)">
                                          <OtherNode start="(370, 5)" end="(375, 34)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(370, 5)" end="(370, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(370, 7)" end="(370, 14)">
                                              <NullNode start="(370, 7)" end="(370, 14)">
                                                <OtherNode start="(370, 7)" end="(370, 14)" kind="Lean.Parser.Term.app">
                                                  <OtherNode start="(370, 7)" end="(370, 12)" kind="Lean.Parser.Term.dotIdent">
                                                    <AtomNode start="(370, 7)" end="(370, 8)" leading="" trailing="" val="."/>
                                                    <IdentNode start="(370, 8)" end="(370, 12)" leading="" trailing=" " raw_val="done" val="done"/>
                                                  </OtherNode>
                                                  <NullNode start="(370, 13)" end="(370, 14)">
                                                    <IdentNode start="(370, 13)" end="(370, 14)" leading="" trailing=" " raw_val="b" val="b"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(370, 15)" end="(370, 17)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(371, 7)" end="(375, 34)">
                                              <TacticTacticseq1IndentedNode start="(371, 7)" end="(375, 34)">
                                                <NullNode start="(371, 7)" end="(375, 34)">
                                                  <OtherNode start="(371, 7)" end="(371, 15)" kind="Lean.Parser.Tactic.clear" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (init : β),&#10;    forIn as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b a =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn as b f) =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) as" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn as b f) =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) as" tactic="clear ih">
                                                    <AtomNode start="(371, 7)" end="(371, 12)" leading="" trailing=" " val="clear"/>
                                                    <NullNode start="(371, 13)" end="(371, 15)">
                                                      <IdentNode start="(371, 13)" end="(371, 15)" leading="" trailing="&#10;      " raw_val="ih" val="ih"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(372, 7)" end="(372, 12)" kind="Lean.Parser.Tactic.dsimp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;⊢ (match ForInStep.done b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn as b f) =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) as" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;⊢ pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) as" tactic="dsimp">
                                                    <AtomNode start="(372, 7)" end="(372, 12)" leading="" trailing="&#10;      " val="dsimp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(373, 7)" end="(375, 34)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;⊢ pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) as" state_after="no goals" tactic="induction as with&#10;| nil =&amp;gt; simp&#10;| cons a as ih =&amp;gt; simp [ih]">
                                                    <AtomNode start="(373, 7)" end="(373, 16)" leading="" trailing=" " val="induction"/>
                                                    <NullNode start="(373, 17)" end="(373, 19)">
                                                      <OtherNode start="(373, 17)" end="(373, 19)" kind="Lean.Parser.Tactic.elimTarget">
                                                        <NullNode/>
                                                        <IdentNode start="(373, 17)" end="(373, 19)" leading="" trailing=" " raw_val="as" val="as"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(373, 20)" end="(375, 34)">
                                                      <OtherNode start="(373, 20)" end="(375, 34)" kind="Lean.Parser.Tactic.inductionAlts">
                                                        <AtomNode start="(373, 20)" end="(373, 24)" leading="" trailing="&#10;      " val="with"/>
                                                        <NullNode/>
                                                        <NullNode start="(374, 7)" end="(375, 34)">
                                                          <OtherNode start="(374, 7)" end="(374, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(374, 7)" end="(374, 12)">
                                                            <OtherNode start="(374, 7)" end="(374, 12)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(374, 7)" end="(374, 8)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(374, 9)" end="(374, 12)">
                                                            <NullNode/>
                                                            <IdentNode start="(374, 9)" end="(374, 12)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </GroupNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(374, 13)" end="(374, 20)">
                                                            <AtomNode start="(374, 13)" end="(374, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(374, 16)" end="(374, 20)">
                                                            <TacticTacticseq1IndentedNode start="(374, 16)" end="(374, 20)">
                                                            <NullNode start="(374, 16)" end="(374, 20)">
                                                            <OtherNode start="(374, 16)" end="(374, 20)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;⊢ pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) []" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(374, 16)" end="(374, 20)" leading="" trailing="&#10;      " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <OtherNode start="(375, 7)" end="(375, 34)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(375, 7)" end="(375, 21)">
                                                            <OtherNode start="(375, 7)" end="(375, 21)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(375, 7)" end="(375, 8)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(375, 9)" end="(375, 13)">
                                                            <NullNode/>
                                                            <IdentNode start="(375, 9)" end="(375, 13)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </GroupNode>
                                                            <NullNode start="(375, 14)" end="(375, 21)">
                                                            <IdentNode start="(375, 14)" end="(375, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <IdentNode start="(375, 16)" end="(375, 18)" leading="" trailing=" " raw_val="as" val="as"/>
                                                            <IdentNode start="(375, 19)" end="(375, 21)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(375, 22)" end="(375, 34)">
                                                            <AtomNode start="(375, 22)" end="(375, 24)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(375, 25)" end="(375, 34)">
                                                            <TacticTacticseq1IndentedNode start="(375, 25)" end="(375, 34)">
                                                            <NullNode start="(375, 25)" end="(375, 34)">
                                                            <OtherNode start="(375, 25)" end="(375, 34)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a✝ : α&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;a : α&#10;as : List α&#10;ih :&#10;  pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) as&#10;⊢ pure b =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.done b) (a :: as)" state_after="no goals" tactic="simp [ih]">
                                                            <AtomNode start="(375, 25)" end="(375, 29)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(375, 30)" end="(375, 34)">
                                                            <AtomNode start="(375, 30)" end="(375, 31)" leading="" trailing="" val="["/>
                                                            <NullNode start="(375, 31)" end="(375, 33)">
                                                            <OtherNode start="(375, 31)" end="(375, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(375, 31)" end="(375, 33)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(375, 33)" end="(375, 34)" leading="" trailing="&#10;    " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <OtherNode start="(376, 5)" end="(377, 16)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(376, 5)" end="(376, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(376, 7)" end="(376, 15)">
                                              <NullNode start="(376, 7)" end="(376, 15)">
                                                <OtherNode start="(376, 7)" end="(376, 15)" kind="Lean.Parser.Term.app">
                                                  <OtherNode start="(376, 7)" end="(376, 13)" kind="Lean.Parser.Term.dotIdent">
                                                    <AtomNode start="(376, 7)" end="(376, 8)" leading="" trailing="" val="."/>
                                                    <IdentNode start="(376, 8)" end="(376, 13)" leading="" trailing=" " raw_val="yield" val="yield"/>
                                                  </OtherNode>
                                                  <NullNode start="(376, 14)" end="(376, 15)">
                                                    <IdentNode start="(376, 14)" end="(376, 15)" leading="" trailing=" " raw_val="b" val="b"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(376, 16)" end="(376, 18)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(377, 7)" end="(377, 16)">
                                              <TacticTacticseq1IndentedNode start="(377, 7)" end="(377, 16)">
                                                <NullNode start="(377, 7)" end="(377, 16)">
                                                  <OtherNode start="(377, 7)" end="(377, 16)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;f : α → β → m (ForInStep β)&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ (init : β),&#10;    forIn as init f =&#10;      ForInStep.value &amp;lt;$&amp;gt;&#10;        foldlM&#10;          (fun b a =&amp;gt;&#10;            match b with&#10;            | ForInStep.yield b =&amp;gt; f a b&#10;            | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;          (ForInStep.yield init) as&#10;init : β&#10;x : ForInStep β&#10;b : β&#10;⊢ (match ForInStep.yield b with&#10;    | ForInStep.done b =&amp;gt; pure b&#10;    | ForInStep.yield b =&amp;gt; forIn as b f) =&#10;    ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield b) as" state_after="no goals" tactic="simp [ih]">
                                                    <AtomNode start="(377, 7)" end="(377, 11)" leading="" trailing=" " val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(377, 12)" end="(377, 16)">
                                                      <AtomNode start="(377, 12)" end="(377, 13)" leading="" trailing="" val="["/>
                                                      <NullNode start="(377, 13)" end="(377, 15)">
                                                        <OtherNode start="(377, 13)" end="(377, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(377, 13)" end="(377, 15)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(377, 15)" end="(377, 16)" leading="" trailing="&#10;&#10;" val="]"/>
                                                    </NullNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(379, 1)" end="(385, 45)" name="forIn_yield_eq_foldlM" full_name="List.forIn_yield_eq_foldlM">
      <CommandDeclmodifiersNode start="(379, 1)" end="(380, 8)">
        <NullNode start="(379, 1)" end="(379, 76)">
          <CommandDoccommentNode start="(379, 1)" end="(379, 76)" comment="We can express a for loop over a list which always yields as a fold. -/">
            <AtomNode start="(379, 1)" end="(379, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(379, 5)" end="(379, 76)" leading="" trailing="&#10;" val="We can express a for loop over a list which always yields as a fold. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(380, 1)" end="(380, 8)">
          <OtherNode start="(380, 1)" end="(380, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(380, 1)" end="(380, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(380, 3)" end="(380, 7)">
              <OtherNode start="(380, 3)" end="(380, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(380, 3)" end="(380, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(380, 3)" end="(380, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(380, 7)" end="(380, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(380, 9)" end="(385, 45)" name="forIn_yield_eq_foldlM" full_name="List.forIn_yield_eq_foldlM" _is_private_decl="False">
        <AtomNode start="(380, 9)" end="(380, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(380, 17)" end="(380, 38)">
          <IdentNode start="(380, 17)" end="(380, 38)" leading="" trailing=" " raw_val="forIn_yield_eq_foldlM" val="forIn_yield_eq_foldlM"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(380, 39)" end="(383, 49)">
          <NullNode start="(380, 39)" end="(381, 66)">
            <OtherNode start="(380, 39)" end="(380, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(380, 39)" end="(380, 40)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(380, 40)" end="(380, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(380, 40)" end="(380, 45)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(380, 46)" end="(380, 47)">
                  <IdentNode start="(380, 46)" end="(380, 47)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(380, 47)" end="(380, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(380, 49)" end="(380, 64)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(380, 49)" end="(380, 50)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(380, 50)" end="(380, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(380, 50)" end="(380, 61)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(380, 62)" end="(380, 63)">
                  <IdentNode start="(380, 62)" end="(380, 63)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(380, 63)" end="(380, 64)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(381, 5)" end="(381, 17)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(381, 5)" end="(381, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(381, 6)" end="(381, 7)">
                <IdentNode start="(381, 6)" end="(381, 7)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(381, 8)" end="(381, 16)">
                <AtomNode start="(381, 8)" end="(381, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(381, 10)" end="(381, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(381, 10)" end="(381, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(381, 15)" end="(381, 16)">
                    <IdentNode start="(381, 15)" end="(381, 16)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(381, 16)" end="(381, 17)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(381, 18)" end="(381, 35)">
              <AtomNode start="(381, 18)" end="(381, 19)" leading="" trailing="" val="("/>
              <NullNode start="(381, 19)" end="(381, 20)">
                <IdentNode start="(381, 19)" end="(381, 20)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(381, 21)" end="(381, 34)">
                <AtomNode start="(381, 21)" end="(381, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(381, 23)" end="(381, 34)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(381, 23)" end="(381, 24)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(381, 25)" end="(381, 26)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(381, 27)" end="(381, 34)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(381, 27)" end="(381, 28)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(381, 29)" end="(381, 30)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(381, 31)" end="(381, 34)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(381, 31)" end="(381, 32)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(381, 33)" end="(381, 34)">
                        <IdentNode start="(381, 33)" end="(381, 34)" leading="" trailing="" raw_val="γ" val="γ"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(381, 34)" end="(381, 35)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(381, 36)" end="(381, 55)">
              <AtomNode start="(381, 36)" end="(381, 37)" leading="" trailing="" val="("/>
              <NullNode start="(381, 37)" end="(381, 38)">
                <IdentNode start="(381, 37)" end="(381, 38)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(381, 39)" end="(381, 54)">
                <AtomNode start="(381, 39)" end="(381, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(381, 41)" end="(381, 54)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(381, 41)" end="(381, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(381, 43)" end="(381, 44)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(381, 45)" end="(381, 54)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(381, 45)" end="(381, 46)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(381, 47)" end="(381, 48)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(381, 49)" end="(381, 54)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(381, 49)" end="(381, 50)" leading="" trailing=" " raw_val="γ" val="γ"/>
                      <AtomNode start="(381, 51)" end="(381, 52)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(381, 53)" end="(381, 54)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(381, 54)" end="(381, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(381, 56)" end="(381, 66)">
              <AtomNode start="(381, 56)" end="(381, 57)" leading="" trailing="" val="("/>
              <NullNode start="(381, 57)" end="(381, 61)">
                <IdentNode start="(381, 57)" end="(381, 61)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(381, 62)" end="(381, 65)">
                <AtomNode start="(381, 62)" end="(381, 63)" leading="" trailing=" " val=":"/>
                <IdentNode start="(381, 64)" end="(381, 65)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(381, 65)" end="(381, 66)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(381, 67)" end="(383, 49)">
            <AtomNode start="(381, 67)" end="(381, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(382, 5)" end="(383, 49)" kind="«term_=_»">
              <OtherNode start="(382, 5)" end="(382, 68)" kind="Lean.Parser.Term.app">
                <IdentNode start="(382, 5)" end="(382, 10)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(382, 11)" end="(382, 68)">
                  <IdentNode start="(382, 11)" end="(382, 12)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(382, 13)" end="(382, 17)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(382, 18)" end="(382, 68)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(382, 18)" end="(382, 19)" leading="" trailing="" val="("/>
                    <OtherNode start="(382, 19)" end="(382, 67)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(382, 19)" end="(382, 22)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(382, 23)" end="(382, 67)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(382, 23)" end="(382, 26)">
                          <IdentNode start="(382, 23)" end="(382, 24)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(382, 25)" end="(382, 26)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(382, 27)" end="(382, 29)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(382, 30)" end="(382, 67)" kind="«term_&amp;lt;$&amp;gt;_»">
                          <OtherNode start="(382, 30)" end="(382, 57)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(382, 30)" end="(382, 31)" leading="" trailing="" val="("/>
                            <OtherNode start="(382, 31)" end="(382, 56)" kind="Lean.Parser.Term.fun">
                              <AtomNode start="(382, 31)" end="(382, 34)" leading="" trailing=" " val="fun"/>
                              <OtherNode start="(382, 35)" end="(382, 56)" kind="Lean.Parser.Term.basicFun">
                                <NullNode start="(382, 35)" end="(382, 36)">
                                  <IdentNode start="(382, 35)" end="(382, 36)" leading="" trailing=" " raw_val="c" val="c"/>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(382, 37)" end="(382, 39)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(382, 40)" end="(382, 56)" kind="Lean.Parser.Term.app">
                                  <OtherNode start="(382, 40)" end="(382, 46)" kind="Lean.Parser.Term.dotIdent">
                                    <AtomNode start="(382, 40)" end="(382, 41)" leading="" trailing="" val="."/>
                                    <IdentNode start="(382, 41)" end="(382, 46)" leading="" trailing=" " raw_val="yield" val="yield"/>
                                  </OtherNode>
                                  <NullNode start="(382, 47)" end="(382, 56)">
                                    <OtherNode start="(382, 47)" end="(382, 56)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(382, 47)" end="(382, 48)" leading="" trailing="" val="("/>
                                      <OtherNode start="(382, 48)" end="(382, 55)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(382, 48)" end="(382, 49)" leading="" trailing=" " raw_val="g" val="g"/>
                                        <NullNode start="(382, 50)" end="(382, 55)">
                                          <IdentNode start="(382, 50)" end="(382, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                                          <IdentNode start="(382, 52)" end="(382, 53)" leading="" trailing=" " raw_val="b" val="b"/>
                                          <IdentNode start="(382, 54)" end="(382, 55)" leading="" trailing="" raw_val="c" val="c"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(382, 55)" end="(382, 56)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(382, 56)" end="(382, 57)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <AtomNode start="(382, 58)" end="(382, 61)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                          <OtherNode start="(382, 62)" end="(382, 67)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(382, 62)" end="(382, 63)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(382, 64)" end="(382, 67)">
                              <IdentNode start="(382, 64)" end="(382, 65)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(382, 66)" end="(382, 67)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(382, 67)" end="(382, 68)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(382, 69)" end="(382, 70)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(383, 7)" end="(383, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(383, 7)" end="(383, 15)" leading="" trailing=" " raw_val="l.foldlM" val="l.foldlM"/>
                <NullNode start="(383, 16)" end="(383, 49)">
                  <OtherNode start="(383, 16)" end="(383, 44)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(383, 16)" end="(383, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(383, 17)" end="(383, 43)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(383, 17)" end="(383, 20)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(383, 21)" end="(383, 43)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(383, 21)" end="(383, 24)">
                          <IdentNode start="(383, 21)" end="(383, 22)" leading="" trailing=" " raw_val="b" val="b"/>
                          <IdentNode start="(383, 23)" end="(383, 24)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(383, 25)" end="(383, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(383, 28)" end="(383, 43)" kind="«term_&amp;lt;$&amp;gt;_»">
                          <OtherNode start="(383, 28)" end="(383, 33)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(383, 28)" end="(383, 29)" leading="" trailing=" " raw_val="g" val="g"/>
                            <NullNode start="(383, 30)" end="(383, 33)">
                              <IdentNode start="(383, 30)" end="(383, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(383, 32)" end="(383, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(383, 34)" end="(383, 37)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                          <OtherNode start="(383, 38)" end="(383, 43)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(383, 38)" end="(383, 39)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(383, 40)" end="(383, 43)">
                              <IdentNode start="(383, 40)" end="(383, 41)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(383, 42)" end="(383, 43)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(383, 43)" end="(383, 44)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(383, 45)" end="(383, 49)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(383, 50)" end="(385, 45)">
          <AtomNode start="(383, 50)" end="(383, 52)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(383, 53)" end="(385, 45)">
            <AtomNode start="(383, 53)" end="(383, 55)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(384, 3)" end="(385, 45)">
              <TacticTacticseq1IndentedNode start="(384, 3)" end="(385, 45)">
                <NullNode start="(384, 3)" end="(385, 45)">
                  <OtherNode start="(384, 3)" end="(384, 30)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → β → m γ&#10;g : α → β → γ → β&#10;init : β&#10;⊢ (forIn l init fun a b =&amp;gt; (fun c =&amp;gt; ForInStep.yield (g a b c)) &amp;lt;$&amp;gt; f a b) = foldlM (fun b a =&amp;gt; g a b &amp;lt;$&amp;gt; f a b) init l" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → β → m γ&#10;g : α → β → γ → β&#10;init : β&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; (fun c =&amp;gt; ForInStep.yield (g a b c)) &amp;lt;$&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) l =&#10;    foldlM (fun b a =&amp;gt; g a b &amp;lt;$&amp;gt; f a b) init l" tactic="simp only [forIn_eq_foldlM]">
                    <AtomNode start="(384, 3)" end="(384, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(384, 8)" end="(384, 12)">
                      <AtomNode start="(384, 8)" end="(384, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(384, 13)" end="(384, 30)">
                      <AtomNode start="(384, 13)" end="(384, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(384, 14)" end="(384, 29)">
                        <OtherNode start="(384, 14)" end="(384, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(384, 14)" end="(384, 29)" leading="" trailing="" raw_val="forIn_eq_foldlM" val="forIn_eq_foldlM" full_name="List.forIn_eq_foldlM" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(357, 9)" def_end="(357, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(384, 29)" end="(384, 30)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(385, 3)" end="(385, 45)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β γ : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → β → m γ&#10;g : α → β → γ → β&#10;init : β&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; (fun c =&amp;gt; ForInStep.yield (g a b c)) &amp;lt;$&amp;gt; f a b&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) l =&#10;    foldlM (fun b a =&amp;gt; g a b &amp;lt;$&amp;gt; f a b) init l" state_after="no goals" tactic="induction l generalizing init &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(385, 3)" end="(385, 32)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(385, 3)" end="(385, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(385, 13)" end="(385, 14)">
                        <OtherNode start="(385, 13)" end="(385, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(385, 13)" end="(385, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode start="(385, 15)" end="(385, 32)">
                        <AtomNode start="(385, 15)" end="(385, 27)" leading="" trailing=" " val="generalizing"/>
                        <NullNode start="(385, 28)" end="(385, 32)">
                          <IdentNode start="(385, 28)" end="(385, 32)" leading="" trailing=" " raw_val="init" val="init"/>
                        </NullNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(385, 33)" end="(385, 36)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(385, 37)" end="(385, 45)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(385, 37)" end="(385, 45)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(387, 1)" end="(392, 45)" name="forIn_pure_yield_eq_foldl" full_name="List.forIn_pure_yield_eq_foldl">
      <CommandDeclmodifiersNode start="(387, 1)" end="(387, 8)">
        <NullNode/>
        <NullNode start="(387, 1)" end="(387, 8)">
          <OtherNode start="(387, 1)" end="(387, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(387, 1)" end="(387, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(387, 3)" end="(387, 7)">
              <OtherNode start="(387, 3)" end="(387, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(387, 3)" end="(387, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(387, 3)" end="(387, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(387, 7)" end="(387, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(387, 9)" end="(392, 45)" name="forIn_pure_yield_eq_foldl" full_name="List.forIn_pure_yield_eq_foldl" _is_private_decl="False">
        <AtomNode start="(387, 9)" end="(387, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(387, 17)" end="(387, 42)">
          <IdentNode start="(387, 17)" end="(387, 42)" leading="" trailing=" " raw_val="forIn_pure_yield_eq_foldl" val="forIn_pure_yield_eq_foldl"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(387, 43)" end="(390, 54)">
          <NullNode start="(387, 43)" end="(388, 44)">
            <OtherNode start="(387, 43)" end="(387, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(387, 43)" end="(387, 44)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(387, 44)" end="(387, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(387, 44)" end="(387, 49)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(387, 50)" end="(387, 51)">
                  <IdentNode start="(387, 50)" end="(387, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(387, 51)" end="(387, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(387, 53)" end="(387, 68)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(387, 53)" end="(387, 54)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(387, 54)" end="(387, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(387, 54)" end="(387, 65)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(387, 66)" end="(387, 67)">
                  <IdentNode start="(387, 66)" end="(387, 67)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(387, 67)" end="(387, 68)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(388, 5)" end="(388, 17)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(388, 5)" end="(388, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(388, 6)" end="(388, 7)">
                <IdentNode start="(388, 6)" end="(388, 7)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(388, 8)" end="(388, 16)">
                <AtomNode start="(388, 8)" end="(388, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(388, 10)" end="(388, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(388, 10)" end="(388, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(388, 15)" end="(388, 16)">
                    <IdentNode start="(388, 15)" end="(388, 16)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(388, 16)" end="(388, 17)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(388, 18)" end="(388, 33)">
              <AtomNode start="(388, 18)" end="(388, 19)" leading="" trailing="" val="("/>
              <NullNode start="(388, 19)" end="(388, 20)">
                <IdentNode start="(388, 19)" end="(388, 20)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(388, 21)" end="(388, 32)">
                <AtomNode start="(388, 21)" end="(388, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(388, 23)" end="(388, 32)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(388, 23)" end="(388, 24)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(388, 25)" end="(388, 26)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(388, 27)" end="(388, 32)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(388, 27)" end="(388, 28)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(388, 29)" end="(388, 30)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(388, 31)" end="(388, 32)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(388, 32)" end="(388, 33)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(388, 34)" end="(388, 44)">
              <AtomNode start="(388, 34)" end="(388, 35)" leading="" trailing="" val="("/>
              <NullNode start="(388, 35)" end="(388, 39)">
                <IdentNode start="(388, 35)" end="(388, 39)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(388, 40)" end="(388, 43)">
                <AtomNode start="(388, 40)" end="(388, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(388, 42)" end="(388, 43)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(388, 43)" end="(388, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(388, 45)" end="(390, 54)">
            <AtomNode start="(388, 45)" end="(388, 46)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(389, 5)" end="(390, 54)" kind="«term_=_»">
              <OtherNode start="(389, 5)" end="(389, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(389, 5)" end="(389, 10)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(389, 11)" end="(389, 52)">
                  <IdentNode start="(389, 11)" end="(389, 12)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(389, 13)" end="(389, 17)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(389, 18)" end="(389, 52)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(389, 18)" end="(389, 19)" leading="" trailing="" val="("/>
                    <OtherNode start="(389, 19)" end="(389, 51)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(389, 19)" end="(389, 22)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(389, 23)" end="(389, 51)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(389, 23)" end="(389, 26)">
                          <IdentNode start="(389, 23)" end="(389, 24)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(389, 25)" end="(389, 26)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(389, 27)" end="(389, 29)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(389, 30)" end="(389, 51)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(389, 30)" end="(389, 34)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(389, 35)" end="(389, 51)">
                            <OtherNode start="(389, 35)" end="(389, 51)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(389, 35)" end="(389, 36)" leading="" trailing="" val="("/>
                              <OtherNode start="(389, 36)" end="(389, 50)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(389, 36)" end="(389, 42)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(389, 36)" end="(389, 37)" leading="" trailing="" val="."/>
                                  <IdentNode start="(389, 37)" end="(389, 42)" leading="" trailing=" " raw_val="yield" val="yield"/>
                                </OtherNode>
                                <NullNode start="(389, 43)" end="(389, 50)">
                                  <OtherNode start="(389, 43)" end="(389, 50)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(389, 43)" end="(389, 44)" leading="" trailing="" val="("/>
                                    <OtherNode start="(389, 44)" end="(389, 49)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(389, 44)" end="(389, 45)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(389, 46)" end="(389, 49)">
                                        <IdentNode start="(389, 46)" end="(389, 47)" leading="" trailing=" " raw_val="a" val="a"/>
                                        <IdentNode start="(389, 48)" end="(389, 49)" leading="" trailing="" raw_val="b" val="b"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(389, 49)" end="(389, 50)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(389, 50)" end="(389, 51)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(389, 51)" end="(389, 52)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(389, 53)" end="(389, 54)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(390, 7)" end="(390, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(390, 7)" end="(390, 11)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(390, 12)" end="(390, 54)">
                  <OtherNode start="(390, 12)" end="(390, 20)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(390, 12)" end="(390, 13)" leading="" trailing="" val="("/>
                    <IdentNode start="(390, 13)" end="(390, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                    <AtomNode start="(390, 15)" end="(390, 17)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(390, 18)" end="(390, 19)" leading="" trailing="" raw_val="m" val="m"/>
                    <AtomNode start="(390, 19)" end="(390, 20)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(390, 21)" end="(390, 54)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(390, 21)" end="(390, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(390, 22)" end="(390, 53)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(390, 22)" end="(390, 29)" leading="" trailing=" " raw_val="l.foldl" val="l.foldl"/>
                      <NullNode start="(390, 30)" end="(390, 53)">
                        <OtherNode start="(390, 30)" end="(390, 48)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(390, 30)" end="(390, 31)" leading="" trailing="" val="("/>
                          <OtherNode start="(390, 31)" end="(390, 47)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(390, 31)" end="(390, 34)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(390, 35)" end="(390, 47)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(390, 35)" end="(390, 38)">
                                <IdentNode start="(390, 35)" end="(390, 36)" leading="" trailing=" " raw_val="b" val="b"/>
                                <IdentNode start="(390, 37)" end="(390, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(390, 39)" end="(390, 41)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(390, 42)" end="(390, 47)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(390, 42)" end="(390, 43)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(390, 44)" end="(390, 47)">
                                  <IdentNode start="(390, 44)" end="(390, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(390, 46)" end="(390, 47)" leading="" trailing="" raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(390, 47)" end="(390, 48)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <IdentNode start="(390, 49)" end="(390, 53)" leading="" trailing="" raw_val="init" val="init"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(390, 53)" end="(390, 54)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(390, 55)" end="(392, 45)">
          <AtomNode start="(390, 55)" end="(390, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(390, 58)" end="(392, 45)">
            <AtomNode start="(390, 58)" end="(390, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(391, 3)" end="(392, 45)">
              <TacticTacticseq1IndentedNode start="(391, 3)" end="(392, 45)">
                <NullNode start="(391, 3)" end="(392, 45)">
                  <OtherNode start="(391, 3)" end="(391, 30)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → β → β&#10;init : β&#10;⊢ (forIn l init fun a b =&amp;gt; pure (ForInStep.yield (f a b))) = pure (foldl (fun b a =&amp;gt; f a b) init l)" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → β → β&#10;init : β&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; pure (ForInStep.yield (f a b))&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) l =&#10;    pure (foldl (fun b a =&amp;gt; f a b) init l)" tactic="simp only [forIn_eq_foldlM]">
                    <AtomNode start="(391, 3)" end="(391, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(391, 8)" end="(391, 12)">
                      <AtomNode start="(391, 8)" end="(391, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(391, 13)" end="(391, 30)">
                      <AtomNode start="(391, 13)" end="(391, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(391, 14)" end="(391, 29)">
                        <OtherNode start="(391, 14)" end="(391, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(391, 14)" end="(391, 29)" leading="" trailing="" raw_val="forIn_eq_foldlM" val="forIn_eq_foldlM" full_name="List.forIn_eq_foldlM" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(357, 9)" def_end="(357, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(391, 29)" end="(391, 30)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(392, 3)" end="(392, 45)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;f : α → β → β&#10;init : β&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; pure (ForInStep.yield (f a b))&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) l =&#10;    pure (foldl (fun b a =&amp;gt; f a b) init l)" state_after="no goals" tactic="induction l generalizing init &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(392, 3)" end="(392, 32)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(392, 3)" end="(392, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(392, 13)" end="(392, 14)">
                        <OtherNode start="(392, 13)" end="(392, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(392, 13)" end="(392, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode start="(392, 15)" end="(392, 32)">
                        <AtomNode start="(392, 15)" end="(392, 27)" leading="" trailing=" " val="generalizing"/>
                        <NullNode start="(392, 28)" end="(392, 32)">
                          <IdentNode start="(392, 28)" end="(392, 32)" leading="" trailing=" " raw_val="init" val="init"/>
                        </NullNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(392, 33)" end="(392, 36)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(392, 37)" end="(392, 45)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(392, 37)" end="(392, 45)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(394, 1)" end="(399, 45)" name="forIn_yield_eq_foldl" full_name="List.forIn_yield_eq_foldl">
      <CommandDeclmodifiersNode start="(394, 1)" end="(394, 8)">
        <NullNode/>
        <NullNode start="(394, 1)" end="(394, 8)">
          <OtherNode start="(394, 1)" end="(394, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(394, 1)" end="(394, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(394, 3)" end="(394, 7)">
              <OtherNode start="(394, 3)" end="(394, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(394, 3)" end="(394, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(394, 3)" end="(394, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(394, 7)" end="(394, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(394, 9)" end="(399, 45)" name="forIn_yield_eq_foldl" full_name="List.forIn_yield_eq_foldl" _is_private_decl="False">
        <AtomNode start="(394, 9)" end="(394, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(394, 17)" end="(394, 37)">
          <IdentNode start="(394, 17)" end="(394, 37)" leading="" trailing="&#10;    " raw_val="forIn_yield_eq_foldl" val="forIn_yield_eq_foldl"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(395, 5)" end="(397, 38)">
          <NullNode start="(395, 5)" end="(395, 44)">
            <OtherNode start="(395, 5)" end="(395, 17)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(395, 5)" end="(395, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(395, 6)" end="(395, 7)">
                <IdentNode start="(395, 6)" end="(395, 7)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(395, 8)" end="(395, 16)">
                <AtomNode start="(395, 8)" end="(395, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(395, 10)" end="(395, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(395, 10)" end="(395, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(395, 15)" end="(395, 16)">
                    <IdentNode start="(395, 15)" end="(395, 16)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(395, 16)" end="(395, 17)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(395, 18)" end="(395, 33)">
              <AtomNode start="(395, 18)" end="(395, 19)" leading="" trailing="" val="("/>
              <NullNode start="(395, 19)" end="(395, 20)">
                <IdentNode start="(395, 19)" end="(395, 20)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(395, 21)" end="(395, 32)">
                <AtomNode start="(395, 21)" end="(395, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(395, 23)" end="(395, 32)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(395, 23)" end="(395, 24)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(395, 25)" end="(395, 26)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(395, 27)" end="(395, 32)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(395, 27)" end="(395, 28)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(395, 29)" end="(395, 30)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(395, 31)" end="(395, 32)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(395, 32)" end="(395, 33)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(395, 34)" end="(395, 44)">
              <AtomNode start="(395, 34)" end="(395, 35)" leading="" trailing="" val="("/>
              <NullNode start="(395, 35)" end="(395, 39)">
                <IdentNode start="(395, 35)" end="(395, 39)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(395, 40)" end="(395, 43)">
                <AtomNode start="(395, 40)" end="(395, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(395, 42)" end="(395, 43)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(395, 43)" end="(395, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(395, 45)" end="(397, 38)">
            <AtomNode start="(395, 45)" end="(395, 46)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(396, 5)" end="(397, 38)" kind="«term_=_»">
              <OtherNode start="(396, 5)" end="(396, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(396, 5)" end="(396, 10)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(396, 11)" end="(396, 55)">
                  <OtherNode start="(396, 11)" end="(396, 20)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(396, 11)" end="(396, 12)" leading="" trailing="" val="("/>
                    <IdentNode start="(396, 12)" end="(396, 13)" leading="" trailing=" " raw_val="m" val="m"/>
                    <AtomNode start="(396, 14)" end="(396, 16)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(396, 17)" end="(396, 19)" leading="" trailing="" raw_val="Id" val="Id" full_name="Id" mod_name="Init.Control.Id" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Id.lean"/>
                    <AtomNode start="(396, 19)" end="(396, 20)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(396, 21)" end="(396, 22)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(396, 23)" end="(396, 27)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(396, 28)" end="(396, 55)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(396, 28)" end="(396, 29)" leading="" trailing="" val="("/>
                    <OtherNode start="(396, 29)" end="(396, 54)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(396, 29)" end="(396, 32)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(396, 33)" end="(396, 54)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(396, 33)" end="(396, 36)">
                          <IdentNode start="(396, 33)" end="(396, 34)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(396, 35)" end="(396, 36)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(396, 37)" end="(396, 39)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(396, 40)" end="(396, 54)" kind="Lean.Parser.Term.app">
                          <OtherNode start="(396, 40)" end="(396, 46)" kind="Lean.Parser.Term.dotIdent">
                            <AtomNode start="(396, 40)" end="(396, 41)" leading="" trailing="" val="."/>
                            <IdentNode start="(396, 41)" end="(396, 46)" leading="" trailing=" " raw_val="yield" val="yield"/>
                          </OtherNode>
                          <NullNode start="(396, 47)" end="(396, 54)">
                            <OtherNode start="(396, 47)" end="(396, 54)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(396, 47)" end="(396, 48)" leading="" trailing="" val="("/>
                              <OtherNode start="(396, 48)" end="(396, 53)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(396, 48)" end="(396, 49)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(396, 50)" end="(396, 53)">
                                  <IdentNode start="(396, 50)" end="(396, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(396, 52)" end="(396, 53)" leading="" trailing="" raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(396, 53)" end="(396, 54)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(396, 54)" end="(396, 55)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(396, 56)" end="(396, 57)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(397, 7)" end="(397, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(397, 7)" end="(397, 14)" leading="" trailing=" " raw_val="l.foldl" val="l.foldl"/>
                <NullNode start="(397, 15)" end="(397, 38)">
                  <OtherNode start="(397, 15)" end="(397, 33)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(397, 15)" end="(397, 16)" leading="" trailing="" val="("/>
                    <OtherNode start="(397, 16)" end="(397, 32)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(397, 16)" end="(397, 19)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(397, 20)" end="(397, 32)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(397, 20)" end="(397, 23)">
                          <IdentNode start="(397, 20)" end="(397, 21)" leading="" trailing=" " raw_val="b" val="b"/>
                          <IdentNode start="(397, 22)" end="(397, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(397, 24)" end="(397, 26)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(397, 27)" end="(397, 32)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(397, 27)" end="(397, 28)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(397, 29)" end="(397, 32)">
                            <IdentNode start="(397, 29)" end="(397, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                            <IdentNode start="(397, 31)" end="(397, 32)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(397, 32)" end="(397, 33)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(397, 34)" end="(397, 38)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(397, 39)" end="(399, 45)">
          <AtomNode start="(397, 39)" end="(397, 41)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(397, 42)" end="(399, 45)">
            <AtomNode start="(397, 42)" end="(397, 44)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(398, 3)" end="(399, 45)">
              <TacticTacticseq1IndentedNode start="(398, 3)" end="(399, 45)">
                <NullNode start="(398, 3)" end="(399, 45)">
                  <OtherNode start="(398, 3)" end="(398, 30)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : α → β → β&#10;init : β&#10;⊢ (forIn l init fun a b =&amp;gt; ForInStep.yield (f a b)) = foldl (fun b a =&amp;gt; f a b) init l" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : α → β → β&#10;init : β&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; ForInStep.yield (f a b)&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) l =&#10;    foldl (fun b a =&amp;gt; f a b) init l" tactic="simp only [forIn_eq_foldlM]">
                    <AtomNode start="(398, 3)" end="(398, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(398, 8)" end="(398, 12)">
                      <AtomNode start="(398, 8)" end="(398, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(398, 13)" end="(398, 30)">
                      <AtomNode start="(398, 13)" end="(398, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(398, 14)" end="(398, 29)">
                        <OtherNode start="(398, 14)" end="(398, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(398, 14)" end="(398, 29)" leading="" trailing="" raw_val="forIn_eq_foldlM" val="forIn_eq_foldlM" full_name="List.forIn_eq_foldlM" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(357, 9)" def_end="(357, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(398, 29)" end="(398, 30)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(399, 3)" end="(399, 45)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : α → β → β&#10;init : β&#10;⊢ ForInStep.value &amp;lt;$&amp;gt;&#10;      foldlM&#10;        (fun b a =&amp;gt;&#10;          match b with&#10;          | ForInStep.yield b =&amp;gt; ForInStep.yield (f a b)&#10;          | ForInStep.done b =&amp;gt; pure (ForInStep.done b))&#10;        (ForInStep.yield init) l =&#10;    foldl (fun b a =&amp;gt; f a b) init l" state_after="no goals" tactic="induction l generalizing init &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(399, 3)" end="(399, 32)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(399, 3)" end="(399, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(399, 13)" end="(399, 14)">
                        <OtherNode start="(399, 13)" end="(399, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(399, 13)" end="(399, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode start="(399, 15)" end="(399, 32)">
                        <AtomNode start="(399, 15)" end="(399, 27)" leading="" trailing=" " val="generalizing"/>
                        <NullNode start="(399, 28)" end="(399, 32)">
                          <IdentNode start="(399, 28)" end="(399, 32)" leading="" trailing=" " raw_val="init" val="init"/>
                        </NullNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(399, 33)" end="(399, 36)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(399, 37)" end="(399, 45)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(399, 37)" end="(399, 45)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(401, 1)" end="(404, 45)" name="forIn_map" full_name="List.forIn_map">
      <CommandDeclmodifiersNode start="(401, 1)" end="(401, 8)">
        <NullNode/>
        <NullNode start="(401, 1)" end="(401, 8)">
          <OtherNode start="(401, 1)" end="(401, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(401, 1)" end="(401, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(401, 3)" end="(401, 7)">
              <OtherNode start="(401, 3)" end="(401, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(401, 3)" end="(401, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(401, 3)" end="(401, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(401, 7)" end="(401, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(401, 9)" end="(404, 45)" name="forIn_map" full_name="List.forIn_map" _is_private_decl="False">
        <AtomNode start="(401, 9)" end="(401, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(401, 17)" end="(401, 26)">
          <IdentNode start="(401, 17)" end="(401, 26)" leading="" trailing=" " raw_val="forIn_map" val="forIn_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(401, 27)" end="(403, 63)">
          <NullNode start="(401, 27)" end="(402, 59)">
            <OtherNode start="(401, 27)" end="(401, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(401, 27)" end="(401, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(401, 28)" end="(401, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(401, 28)" end="(401, 33)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(401, 34)" end="(401, 35)">
                  <IdentNode start="(401, 34)" end="(401, 35)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(401, 35)" end="(401, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(401, 37)" end="(401, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(401, 37)" end="(401, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(401, 38)" end="(401, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(401, 38)" end="(401, 49)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(401, 50)" end="(401, 51)">
                  <IdentNode start="(401, 50)" end="(401, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(401, 51)" end="(401, 52)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(402, 5)" end="(402, 17)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(402, 5)" end="(402, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(402, 6)" end="(402, 7)">
                <IdentNode start="(402, 6)" end="(402, 7)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(402, 8)" end="(402, 16)">
                <AtomNode start="(402, 8)" end="(402, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(402, 10)" end="(402, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(402, 10)" end="(402, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(402, 15)" end="(402, 16)">
                    <IdentNode start="(402, 15)" end="(402, 16)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(402, 16)" end="(402, 17)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(402, 18)" end="(402, 29)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(402, 18)" end="(402, 19)" leading="" trailing="" val="{"/>
              <NullNode start="(402, 19)" end="(402, 20)">
                <IdentNode start="(402, 19)" end="(402, 20)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(402, 21)" end="(402, 28)">
                <AtomNode start="(402, 21)" end="(402, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(402, 23)" end="(402, 28)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(402, 23)" end="(402, 24)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(402, 25)" end="(402, 26)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(402, 27)" end="(402, 28)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(402, 28)" end="(402, 29)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(402, 30)" end="(402, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(402, 30)" end="(402, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(402, 31)" end="(402, 32)">
                <IdentNode start="(402, 31)" end="(402, 32)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(402, 33)" end="(402, 58)">
                <AtomNode start="(402, 33)" end="(402, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(402, 35)" end="(402, 58)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(402, 35)" end="(402, 36)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(402, 37)" end="(402, 38)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(402, 39)" end="(402, 58)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(402, 39)" end="(402, 40)" leading="" trailing=" " raw_val="γ" val="γ"/>
                    <AtomNode start="(402, 41)" end="(402, 42)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(402, 43)" end="(402, 58)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(402, 43)" end="(402, 44)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(402, 45)" end="(402, 58)">
                        <OtherNode start="(402, 45)" end="(402, 58)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(402, 45)" end="(402, 46)" leading="" trailing="" val="("/>
                          <OtherNode start="(402, 46)" end="(402, 57)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(402, 46)" end="(402, 55)" leading="" trailing=" " raw_val="ForInStep" val="ForInStep" full_name="ForInStep" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                            <NullNode start="(402, 56)" end="(402, 57)">
                              <IdentNode start="(402, 56)" end="(402, 57)" leading="" trailing="" raw_val="γ" val="γ"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(402, 57)" end="(402, 58)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(402, 58)" end="(402, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(402, 60)" end="(403, 63)">
            <AtomNode start="(402, 60)" end="(402, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(403, 5)" end="(403, 63)" kind="«term_=_»">
              <OtherNode start="(403, 5)" end="(403, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(403, 5)" end="(403, 10)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(403, 11)" end="(403, 27)">
                  <OtherNode start="(403, 11)" end="(403, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(403, 11)" end="(403, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(403, 12)" end="(403, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(403, 12)" end="(403, 17)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                      <NullNode start="(403, 18)" end="(403, 19)">
                        <IdentNode start="(403, 18)" end="(403, 19)" leading="" trailing="" raw_val="g" val="g"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(403, 19)" end="(403, 20)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(403, 21)" end="(403, 25)" leading="" trailing=" " raw_val="init" val="init"/>
                  <IdentNode start="(403, 26)" end="(403, 27)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(403, 28)" end="(403, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(403, 30)" end="(403, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(403, 30)" end="(403, 35)" leading="" trailing=" " raw_val="forIn" val="forIn" full_name="ForIn.forIn" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(403, 36)" end="(403, 63)">
                  <IdentNode start="(403, 36)" end="(403, 37)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(403, 38)" end="(403, 42)" leading="" trailing=" " raw_val="init" val="init"/>
                  <OtherNode start="(403, 43)" end="(403, 63)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(403, 43)" end="(403, 46)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(403, 47)" end="(403, 63)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(403, 47)" end="(403, 50)">
                        <IdentNode start="(403, 47)" end="(403, 48)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(403, 49)" end="(403, 50)" leading="" trailing=" " raw_val="y" val="y"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(403, 51)" end="(403, 53)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(403, 54)" end="(403, 63)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(403, 54)" end="(403, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(403, 56)" end="(403, 63)">
                          <OtherNode start="(403, 56)" end="(403, 61)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(403, 56)" end="(403, 57)" leading="" trailing="" val="("/>
                            <OtherNode start="(403, 57)" end="(403, 60)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(403, 57)" end="(403, 58)" leading="" trailing=" " raw_val="g" val="g"/>
                              <NullNode start="(403, 59)" end="(403, 60)">
                                <IdentNode start="(403, 59)" end="(403, 60)" leading="" trailing="" raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(403, 60)" end="(403, 61)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <IdentNode start="(403, 62)" end="(403, 63)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(403, 64)" end="(404, 45)">
          <AtomNode start="(403, 64)" end="(403, 66)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(403, 67)" end="(404, 45)">
            <AtomNode start="(403, 67)" end="(403, 69)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(404, 3)" end="(404, 45)">
              <TacticTacticseq1IndentedNode start="(404, 3)" end="(404, 45)">
                <NullNode start="(404, 3)" end="(404, 45)">
                  <OtherNode start="(404, 3)" end="(404, 45)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;γ : Type u_1&#10;init : γ&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;l : List α&#10;g : α → β&#10;f : β → γ → m (ForInStep γ)&#10;⊢ forIn (map g l) init f = forIn l init fun a y =&amp;gt; f (g a) y" state_after="no goals" tactic="induction l generalizing init &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(404, 3)" end="(404, 32)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(404, 3)" end="(404, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(404, 13)" end="(404, 14)">
                        <OtherNode start="(404, 13)" end="(404, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(404, 13)" end="(404, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode start="(404, 15)" end="(404, 32)">
                        <AtomNode start="(404, 15)" end="(404, 27)" leading="" trailing=" " val="generalizing"/>
                        <NullNode start="(404, 28)" end="(404, 32)">
                          <IdentNode start="(404, 28)" end="(404, 32)" leading="" trailing=" " raw_val="init" val="init"/>
                        </NullNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(404, 33)" end="(404, 36)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(404, 37)" end="(404, 45)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(404, 37)" end="(404, 45)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(406, 1)" end="(406, 25)" comment="### allM and anyM -/">
      <AtomNode start="(406, 1)" end="(406, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(406, 5)" end="(406, 25)" leading="" trailing="&#10;&#10;" val="### allM and anyM -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(408, 1)" end="(416, 23)" name="allM_eq_not_anyM_not" full_name="List.allM_eq_not_anyM_not">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(408, 1)" end="(416, 23)" name="allM_eq_not_anyM_not" full_name="List.allM_eq_not_anyM_not" _is_private_decl="False">
        <AtomNode start="(408, 1)" end="(408, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(408, 9)" end="(408, 29)">
          <IdentNode start="(408, 9)" end="(408, 29)" leading="" trailing=" " raw_val="allM_eq_not_anyM_not" val="allM_eq_not_anyM_not"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(408, 30)" end="(409, 50)">
          <NullNode start="(408, 30)" end="(408, 86)">
            <OtherNode start="(408, 30)" end="(408, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(408, 30)" end="(408, 31)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(408, 31)" end="(408, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(408, 31)" end="(408, 36)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(408, 37)" end="(408, 38)">
                  <IdentNode start="(408, 37)" end="(408, 38)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(408, 38)" end="(408, 39)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(408, 40)" end="(408, 55)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(408, 40)" end="(408, 41)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(408, 41)" end="(408, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(408, 41)" end="(408, 52)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(408, 53)" end="(408, 54)">
                  <IdentNode start="(408, 53)" end="(408, 54)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(408, 54)" end="(408, 55)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(408, 56)" end="(408, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(408, 56)" end="(408, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(408, 57)" end="(408, 58)">
                <IdentNode start="(408, 57)" end="(408, 58)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(408, 59)" end="(408, 71)">
                <AtomNode start="(408, 59)" end="(408, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(408, 61)" end="(408, 71)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(408, 61)" end="(408, 62)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(408, 63)" end="(408, 64)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(408, 65)" end="(408, 71)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(408, 65)" end="(408, 66)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(408, 67)" end="(408, 71)">
                      <IdentNode start="(408, 67)" end="(408, 71)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(408, 71)" end="(408, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(408, 73)" end="(408, 86)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(408, 73)" end="(408, 74)" leading="" trailing="" val="{"/>
              <NullNode start="(408, 74)" end="(408, 76)">
                <IdentNode start="(408, 74)" end="(408, 76)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(408, 77)" end="(408, 85)">
                <AtomNode start="(408, 77)" end="(408, 78)" leading="" trailing=" " val=":"/>
                <OtherNode start="(408, 79)" end="(408, 85)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(408, 79)" end="(408, 83)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(408, 84)" end="(408, 85)">
                    <IdentNode start="(408, 84)" end="(408, 85)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(408, 85)" end="(408, 86)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(408, 87)" end="(409, 50)">
            <AtomNode start="(408, 87)" end="(408, 88)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(409, 5)" end="(409, 50)" kind="«term_=_»">
              <OtherNode start="(409, 5)" end="(409, 14)" kind="Lean.Parser.Term.app">
                <IdentNode start="(409, 5)" end="(409, 9)" leading="" trailing=" " raw_val="allM" val="allM" full_name="List.allM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                <NullNode start="(409, 10)" end="(409, 14)">
                  <IdentNode start="(409, 10)" end="(409, 11)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(409, 12)" end="(409, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(409, 15)" end="(409, 16)" leading="" trailing=" " val="="/>
              <OtherNode start="(409, 17)" end="(409, 50)" kind="«term_&amp;lt;$&amp;gt;_»">
                <OtherNode start="(409, 17)" end="(409, 22)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(409, 17)" end="(409, 18)" leading="" trailing="" val="("/>
                  <OtherNode start="(409, 18)" end="(409, 21)" kind="term!_">
                    <AtomNode start="(409, 18)" end="(409, 19)" leading="" trailing=" " val="!"/>
                    <OtherNode start="(409, 20)" end="(409, 21)" kind="Lean.Parser.Term.cdot">
                      <AtomNode start="(409, 20)" end="(409, 21)" leading="" trailing="" val="·"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(409, 21)" end="(409, 22)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(409, 23)" end="(409, 26)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                <OtherNode start="(409, 27)" end="(409, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(409, 27)" end="(409, 31)" leading="" trailing=" " raw_val="anyM" val="anyM" full_name="List.anyM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                  <NullNode start="(409, 32)" end="(409, 50)">
                    <OtherNode start="(409, 32)" end="(409, 47)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(409, 32)" end="(409, 33)" leading="" trailing="" val="("/>
                      <OtherNode start="(409, 33)" end="(409, 46)" kind="«term_&amp;lt;$&amp;gt;_»">
                        <OtherNode start="(409, 33)" end="(409, 38)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(409, 33)" end="(409, 34)" leading="" trailing="" val="("/>
                          <OtherNode start="(409, 34)" end="(409, 37)" kind="term!_">
                            <AtomNode start="(409, 34)" end="(409, 35)" leading="" trailing=" " val="!"/>
                            <OtherNode start="(409, 36)" end="(409, 37)" kind="Lean.Parser.Term.cdot">
                              <AtomNode start="(409, 36)" end="(409, 37)" leading="" trailing="" val="·"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(409, 37)" end="(409, 38)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(409, 39)" end="(409, 42)" leading="" trailing=" " val="&amp;lt;$&amp;gt;"/>
                        <OtherNode start="(409, 43)" end="(409, 46)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(409, 43)" end="(409, 44)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(409, 45)" end="(409, 46)">
                            <OtherNode start="(409, 45)" end="(409, 46)" kind="Lean.Parser.Term.cdot">
                              <AtomNode start="(409, 45)" end="(409, 46)" leading="" trailing="" val="·"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(409, 46)" end="(409, 47)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(409, 48)" end="(409, 50)" leading="" trailing=" " raw_val="as" val="as"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(409, 51)" end="(416, 23)">
          <AtomNode start="(409, 51)" end="(409, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(409, 54)" end="(416, 23)">
            <AtomNode start="(409, 54)" end="(409, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(410, 3)" end="(416, 23)">
              <TacticTacticseq1IndentedNode start="(410, 3)" end="(416, 23)">
                <NullNode start="(410, 3)" end="(416, 23)">
                  <OtherNode start="(410, 3)" end="(416, 23)" kind="Lean.Parser.Tactic.induction" state_before="m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;as : List α&#10;⊢ allM p as = (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) as" state_after="no goals" tactic="induction as with&#10;| nil =&amp;gt; simp&#10;| cons a as ih =&amp;gt;&#10;  simp only [allM, anyM, bind_map_left, _root_.map_bind]&#10;  congr&#10;  funext b&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(410, 3)" end="(410, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(410, 13)" end="(410, 15)">
                      <OtherNode start="(410, 13)" end="(410, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(410, 13)" end="(410, 15)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(410, 16)" end="(416, 23)">
                      <OtherNode start="(410, 16)" end="(416, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(410, 16)" end="(410, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(411, 3)" end="(416, 23)">
                          <OtherNode start="(411, 3)" end="(411, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(411, 3)" end="(411, 8)">
                              <OtherNode start="(411, 3)" end="(411, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(411, 3)" end="(411, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(411, 5)" end="(411, 8)">
                                  <NullNode/>
                                  <IdentNode start="(411, 5)" end="(411, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(411, 9)" end="(411, 16)">
                              <AtomNode start="(411, 9)" end="(411, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(411, 12)" end="(411, 16)">
                                <TacticTacticseq1IndentedNode start="(411, 12)" end="(411, 16)">
                                  <NullNode start="(411, 12)" end="(411, 16)">
                                    <OtherNode start="(411, 12)" end="(411, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;⊢ allM p [] = (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(411, 12)" end="(411, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(412, 3)" end="(416, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(412, 3)" end="(412, 17)">
                              <OtherNode start="(412, 3)" end="(412, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(412, 3)" end="(412, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(412, 5)" end="(412, 9)">
                                  <NullNode/>
                                  <IdentNode start="(412, 5)" end="(412, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(412, 10)" end="(412, 17)">
                                  <IdentNode start="(412, 10)" end="(412, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(412, 12)" end="(412, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                                  <IdentNode start="(412, 15)" end="(412, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(412, 18)" end="(416, 23)">
                              <AtomNode start="(412, 18)" end="(412, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(413, 5)" end="(416, 23)">
                                <TacticTacticseq1IndentedNode start="(413, 5)" end="(416, 23)">
                                  <NullNode start="(413, 5)" end="(416, 23)">
                                    <OtherNode start="(413, 5)" end="(413, 59)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;a : α&#10;as : List α&#10;ih : allM p as = (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) as&#10;⊢ allM p (a :: as) = (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) (a :: as)" state_after="case cons&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;a : α&#10;as : List α&#10;ih : allM p as = (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) as&#10;⊢ (do&#10;      let __do_lift ← p a&#10;      match __do_lift with&#10;        | true =&amp;gt; allM p as&#10;        | false =&amp;gt; pure false) =&#10;    do&#10;    let a ← p a&#10;    (fun x =&amp;gt; !x) &amp;lt;$&amp;gt;&#10;        match !a with&#10;        | true =&amp;gt; pure true&#10;        | false =&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) as" tactic="simp only [allM, anyM, bind_map_left, _root_.map_bind]">
                                      <AtomNode start="(413, 5)" end="(413, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(413, 10)" end="(413, 14)">
                                        <AtomNode start="(413, 10)" end="(413, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(413, 15)" end="(413, 59)">
                                        <AtomNode start="(413, 15)" end="(413, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(413, 16)" end="(413, 58)">
                                          <OtherNode start="(413, 16)" end="(413, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(413, 16)" end="(413, 20)" leading="" trailing="" raw_val="allM" val="allM" full_name="List.allM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(413, 20)" end="(413, 21)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(413, 22)" end="(413, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(413, 22)" end="(413, 26)" leading="" trailing="" raw_val="anyM" val="anyM" full_name="List.anyM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(413, 26)" end="(413, 27)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(413, 28)" end="(413, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(413, 28)" end="(413, 41)" leading="" trailing="" raw_val="bind_map_left" val="bind_map_left" full_name="bind_map_left" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(413, 41)" end="(413, 42)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(413, 43)" end="(413, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(413, 43)" end="(413, 58)" leading="" trailing="" raw_val="_root_.map_bind" val="_root_.map_bind" full_name="map_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(413, 58)" end="(413, 59)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(414, 5)" end="(414, 10)" kind="Lean.Parser.Tactic.congr" state_before="case cons&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;a : α&#10;as : List α&#10;ih : allM p as = (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) as&#10;⊢ (do&#10;      let __do_lift ← p a&#10;      match __do_lift with&#10;        | true =&amp;gt; allM p as&#10;        | false =&amp;gt; pure false) =&#10;    do&#10;    let a ← p a&#10;    (fun x =&amp;gt; !x) &amp;lt;$&amp;gt;&#10;        match !a with&#10;        | true =&amp;gt; pure true&#10;        | false =&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) as" state_after="case cons.e_a&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;a : α&#10;as : List α&#10;ih : allM p as = (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) as&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | true =&amp;gt; allM p as&#10;      | false =&amp;gt; pure false) =&#10;    fun a =&amp;gt;&#10;    (fun x =&amp;gt; !x) &amp;lt;$&amp;gt;&#10;      match !a with&#10;      | true =&amp;gt; pure true&#10;      | false =&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) as" tactic="congr">
                                      <AtomNode start="(414, 5)" end="(414, 10)" leading="" trailing="&#10;    " val="congr"/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(415, 5)" end="(415, 13)" kind="tacticFunext___" state_before="case cons.e_a&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;a : α&#10;as : List α&#10;ih : allM p as = (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) as&#10;⊢ (fun __do_lift =&amp;gt;&#10;      match __do_lift with&#10;      | true =&amp;gt; allM p as&#10;      | false =&amp;gt; pure false) =&#10;    fun a =&amp;gt;&#10;    (fun x =&amp;gt; !x) &amp;lt;$&amp;gt;&#10;      match !a with&#10;      | true =&amp;gt; pure true&#10;      | false =&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) as" state_after="case cons.e_a.h&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;a : α&#10;as : List α&#10;ih : allM p as = (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) as&#10;b : Bool&#10;⊢ (match b with&#10;    | true =&amp;gt; allM p as&#10;    | false =&amp;gt; pure false) =&#10;    (fun x =&amp;gt; !x) &amp;lt;$&amp;gt;&#10;      match !b with&#10;      | true =&amp;gt; pure true&#10;      | false =&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) as" tactic="funext b">
                                      <AtomNode start="(415, 5)" end="(415, 11)" leading="" trailing=" " val="funext"/>
                                      <NullNode start="(415, 12)" end="(415, 13)">
                                        <IdentNode start="(415, 12)" end="(415, 13)" leading="" trailing="&#10;    " raw_val="b" val="b"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(416, 5)" end="(416, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.e_a.h&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → m Bool&#10;a : α&#10;as : List α&#10;ih : allM p as = (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) as&#10;b : Bool&#10;⊢ (match b with&#10;    | true =&amp;gt; allM p as&#10;    | false =&amp;gt; pure false) =&#10;    (fun x =&amp;gt; !x) &amp;lt;$&amp;gt;&#10;      match !b with&#10;      | true =&amp;gt; pure true&#10;      | false =&amp;gt; anyM (fun x =&amp;gt; (fun x =&amp;gt; !x) &amp;lt;$&amp;gt; p x) as" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(416, 5)" end="(416, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(416, 5)" end="(416, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(416, 11)" end="(416, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(416, 15)" end="(416, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(416, 15)" end="(416, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(418, 1)" end="(424, 23)" name="anyM_pure" full_name="List.anyM_pure">
      <CommandDeclmodifiersNode start="(418, 1)" end="(418, 8)">
        <NullNode/>
        <NullNode start="(418, 1)" end="(418, 8)">
          <OtherNode start="(418, 1)" end="(418, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(418, 1)" end="(418, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(418, 3)" end="(418, 7)">
              <OtherNode start="(418, 3)" end="(418, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(418, 3)" end="(418, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(418, 3)" end="(418, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(418, 7)" end="(418, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(418, 9)" end="(424, 23)" name="anyM_pure" full_name="List.anyM_pure" _is_private_decl="False">
        <AtomNode start="(418, 9)" end="(418, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(418, 17)" end="(418, 26)">
          <IdentNode start="(418, 17)" end="(418, 26)" leading="" trailing=" " raw_val="anyM_pure" val="anyM_pure"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(418, 27)" end="(419, 53)">
          <NullNode start="(418, 27)" end="(418, 81)">
            <OtherNode start="(418, 27)" end="(418, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(418, 27)" end="(418, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(418, 28)" end="(418, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(418, 28)" end="(418, 33)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(418, 34)" end="(418, 35)">
                  <IdentNode start="(418, 34)" end="(418, 35)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(418, 35)" end="(418, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(418, 37)" end="(418, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(418, 37)" end="(418, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(418, 38)" end="(418, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(418, 38)" end="(418, 49)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(418, 50)" end="(418, 51)">
                  <IdentNode start="(418, 50)" end="(418, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(418, 51)" end="(418, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(418, 53)" end="(418, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(418, 53)" end="(418, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(418, 54)" end="(418, 55)">
                <IdentNode start="(418, 54)" end="(418, 55)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(418, 56)" end="(418, 66)">
                <AtomNode start="(418, 56)" end="(418, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(418, 58)" end="(418, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(418, 58)" end="(418, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(418, 60)" end="(418, 61)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(418, 62)" end="(418, 66)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(418, 66)" end="(418, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(418, 68)" end="(418, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(418, 68)" end="(418, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(418, 69)" end="(418, 71)">
                <IdentNode start="(418, 69)" end="(418, 71)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(418, 72)" end="(418, 80)">
                <AtomNode start="(418, 72)" end="(418, 73)" leading="" trailing=" " val=":"/>
                <OtherNode start="(418, 74)" end="(418, 80)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(418, 74)" end="(418, 78)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(418, 79)" end="(418, 80)">
                    <IdentNode start="(418, 79)" end="(418, 80)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(418, 80)" end="(418, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(418, 82)" end="(419, 53)">
            <AtomNode start="(418, 82)" end="(418, 83)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(419, 5)" end="(419, 53)" kind="«term_=_»">
              <OtherNode start="(419, 5)" end="(419, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(419, 5)" end="(419, 12)" leading="" trailing=" " raw_val="as.anyM" val="as.anyM"/>
                <NullNode start="(419, 13)" end="(419, 35)">
                  <OtherNode start="(419, 13)" end="(419, 21)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(419, 13)" end="(419, 14)" leading="" trailing="" val="("/>
                    <IdentNode start="(419, 14)" end="(419, 15)" leading="" trailing=" " raw_val="m" val="m"/>
                    <AtomNode start="(419, 16)" end="(419, 18)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(419, 19)" end="(419, 20)" leading="" trailing="" raw_val="m" val="m"/>
                    <AtomNode start="(419, 20)" end="(419, 21)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(419, 22)" end="(419, 35)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(419, 22)" end="(419, 23)" leading="" trailing="" val="("/>
                    <OtherNode start="(419, 23)" end="(419, 34)" kind="«term_&amp;lt;|_»">
                      <IdentNode start="(419, 23)" end="(419, 27)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(419, 28)" end="(419, 30)" leading="" trailing=" " val="&amp;lt;|"/>
                      <OtherNode start="(419, 31)" end="(419, 34)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(419, 31)" end="(419, 32)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(419, 33)" end="(419, 34)">
                          <OtherNode start="(419, 33)" end="(419, 34)" kind="Lean.Parser.Term.cdot">
                            <AtomNode start="(419, 33)" end="(419, 34)" leading="" trailing="" val="·"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(419, 34)" end="(419, 35)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(419, 36)" end="(419, 37)" leading="" trailing=" " val="="/>
              <OtherNode start="(419, 38)" end="(419, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(419, 38)" end="(419, 42)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(419, 43)" end="(419, 53)">
                  <OtherNode start="(419, 43)" end="(419, 53)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(419, 43)" end="(419, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(419, 44)" end="(419, 52)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(419, 44)" end="(419, 50)" leading="" trailing=" " raw_val="as.any" val="as.any"/>
                      <NullNode start="(419, 51)" end="(419, 52)">
                        <IdentNode start="(419, 51)" end="(419, 52)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(419, 52)" end="(419, 53)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(419, 54)" end="(424, 23)">
          <AtomNode start="(419, 54)" end="(419, 56)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(419, 57)" end="(424, 23)">
            <AtomNode start="(419, 57)" end="(419, 59)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(420, 3)" end="(424, 23)">
              <TacticTacticseq1IndentedNode start="(420, 3)" end="(424, 23)">
                <NullNode start="(420, 3)" end="(424, 23)">
                  <OtherNode start="(420, 3)" end="(424, 23)" kind="Lean.Parser.Tactic.induction" state_before="m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;as : List α&#10;⊢ anyM (fun x =&amp;gt; pure (p x)) as = pure (as.any p)" state_after="no goals" tactic="induction as with&#10;| nil =&amp;gt; simp&#10;| cons a as ih =&amp;gt;&#10;  simp only [anyM, ih, pure_bind, all_cons]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(420, 3)" end="(420, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(420, 13)" end="(420, 15)">
                      <OtherNode start="(420, 13)" end="(420, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(420, 13)" end="(420, 15)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(420, 16)" end="(424, 23)">
                      <OtherNode start="(420, 16)" end="(424, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(420, 16)" end="(420, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(421, 3)" end="(424, 23)">
                          <OtherNode start="(421, 3)" end="(421, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(421, 3)" end="(421, 8)">
                              <OtherNode start="(421, 3)" end="(421, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(421, 3)" end="(421, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(421, 5)" end="(421, 8)">
                                  <NullNode/>
                                  <IdentNode start="(421, 5)" end="(421, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(421, 9)" end="(421, 16)">
                              <AtomNode start="(421, 9)" end="(421, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(421, 12)" end="(421, 16)">
                                <TacticTacticseq1IndentedNode start="(421, 12)" end="(421, 16)">
                                  <NullNode start="(421, 12)" end="(421, 16)">
                                    <OtherNode start="(421, 12)" end="(421, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;⊢ anyM (fun x =&amp;gt; pure (p x)) [] = pure ([].any p)" state_after="no goals" tactic="simp">
                                      <AtomNode start="(421, 12)" end="(421, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(422, 3)" end="(424, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(422, 3)" end="(422, 17)">
                              <OtherNode start="(422, 3)" end="(422, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(422, 3)" end="(422, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(422, 5)" end="(422, 9)">
                                  <NullNode/>
                                  <IdentNode start="(422, 5)" end="(422, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(422, 10)" end="(422, 17)">
                                  <IdentNode start="(422, 10)" end="(422, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(422, 12)" end="(422, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                                  <IdentNode start="(422, 15)" end="(422, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(422, 18)" end="(424, 23)">
                              <AtomNode start="(422, 18)" end="(422, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(423, 5)" end="(424, 23)">
                                <TacticTacticseq1IndentedNode start="(423, 5)" end="(424, 23)">
                                  <NullNode start="(423, 5)" end="(424, 23)">
                                    <OtherNode start="(423, 5)" end="(423, 46)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;a : α&#10;as : List α&#10;ih : anyM (fun x =&amp;gt; pure (p x)) as = pure (as.any p)&#10;⊢ anyM (fun x =&amp;gt; pure (p x)) (a :: as) = pure ((a :: as).any p)" state_after="case cons&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;a : α&#10;as : List α&#10;ih : anyM (fun x =&amp;gt; pure (p x)) as = pure (as.any p)&#10;⊢ (match p a with&#10;    | true =&amp;gt; pure true&#10;    | false =&amp;gt; pure (as.any p)) =&#10;    pure ((a :: as).any p)" tactic="simp only [anyM, ih, pure_bind, all_cons]">
                                      <AtomNode start="(423, 5)" end="(423, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(423, 10)" end="(423, 14)">
                                        <AtomNode start="(423, 10)" end="(423, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(423, 15)" end="(423, 46)">
                                        <AtomNode start="(423, 15)" end="(423, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(423, 16)" end="(423, 45)">
                                          <OtherNode start="(423, 16)" end="(423, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(423, 16)" end="(423, 20)" leading="" trailing="" raw_val="anyM" val="anyM" full_name="List.anyM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(423, 20)" end="(423, 21)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(423, 22)" end="(423, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(423, 22)" end="(423, 24)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(423, 24)" end="(423, 25)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(423, 26)" end="(423, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(423, 26)" end="(423, 35)" leading="" trailing="" raw_val="pure_bind" val="pure_bind" full_name="LawfulMonad.pure_bind" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(423, 35)" end="(423, 36)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(423, 37)" end="(423, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(423, 37)" end="(423, 45)" leading="" trailing="" raw_val="all_cons" val="all_cons" full_name="List.all_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(423, 45)" end="(423, 46)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(424, 5)" end="(424, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;a : α&#10;as : List α&#10;ih : anyM (fun x =&amp;gt; pure (p x)) as = pure (as.any p)&#10;⊢ (match p a with&#10;    | true =&amp;gt; pure true&#10;    | false =&amp;gt; pure (as.any p)) =&#10;    pure ((a :: as).any p)" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(424, 5)" end="(424, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(424, 5)" end="(424, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(424, 11)" end="(424, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(424, 15)" end="(424, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(424, 15)" end="(424, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(426, 1)" end="(428, 50)" name="allM_pure" full_name="List.allM_pure">
      <CommandDeclmodifiersNode start="(426, 1)" end="(426, 8)">
        <NullNode/>
        <NullNode start="(426, 1)" end="(426, 8)">
          <OtherNode start="(426, 1)" end="(426, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(426, 1)" end="(426, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(426, 3)" end="(426, 7)">
              <OtherNode start="(426, 3)" end="(426, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(426, 3)" end="(426, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(426, 3)" end="(426, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(426, 7)" end="(426, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(426, 9)" end="(428, 50)" name="allM_pure" full_name="List.allM_pure" _is_private_decl="False">
        <AtomNode start="(426, 9)" end="(426, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(426, 17)" end="(426, 26)">
          <IdentNode start="(426, 17)" end="(426, 26)" leading="" trailing=" " raw_val="allM_pure" val="allM_pure"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(426, 27)" end="(427, 53)">
          <NullNode start="(426, 27)" end="(426, 81)">
            <OtherNode start="(426, 27)" end="(426, 36)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(426, 27)" end="(426, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(426, 28)" end="(426, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(426, 28)" end="(426, 33)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(426, 34)" end="(426, 35)">
                  <IdentNode start="(426, 34)" end="(426, 35)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(426, 35)" end="(426, 36)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(426, 37)" end="(426, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(426, 37)" end="(426, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(426, 38)" end="(426, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(426, 38)" end="(426, 49)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(426, 50)" end="(426, 51)">
                  <IdentNode start="(426, 50)" end="(426, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(426, 51)" end="(426, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(426, 53)" end="(426, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(426, 53)" end="(426, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(426, 54)" end="(426, 55)">
                <IdentNode start="(426, 54)" end="(426, 55)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(426, 56)" end="(426, 66)">
                <AtomNode start="(426, 56)" end="(426, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(426, 58)" end="(426, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(426, 58)" end="(426, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(426, 60)" end="(426, 61)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(426, 62)" end="(426, 66)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(426, 66)" end="(426, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(426, 68)" end="(426, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(426, 68)" end="(426, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(426, 69)" end="(426, 71)">
                <IdentNode start="(426, 69)" end="(426, 71)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(426, 72)" end="(426, 80)">
                <AtomNode start="(426, 72)" end="(426, 73)" leading="" trailing=" " val=":"/>
                <OtherNode start="(426, 74)" end="(426, 80)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(426, 74)" end="(426, 78)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(426, 79)" end="(426, 80)">
                    <IdentNode start="(426, 79)" end="(426, 80)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(426, 80)" end="(426, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(426, 82)" end="(427, 53)">
            <AtomNode start="(426, 82)" end="(426, 83)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(427, 5)" end="(427, 53)" kind="«term_=_»">
              <OtherNode start="(427, 5)" end="(427, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(427, 5)" end="(427, 12)" leading="" trailing=" " raw_val="as.allM" val="as.allM"/>
                <NullNode start="(427, 13)" end="(427, 35)">
                  <OtherNode start="(427, 13)" end="(427, 21)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(427, 13)" end="(427, 14)" leading="" trailing="" val="("/>
                    <IdentNode start="(427, 14)" end="(427, 15)" leading="" trailing=" " raw_val="m" val="m"/>
                    <AtomNode start="(427, 16)" end="(427, 18)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(427, 19)" end="(427, 20)" leading="" trailing="" raw_val="m" val="m"/>
                    <AtomNode start="(427, 20)" end="(427, 21)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(427, 22)" end="(427, 35)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(427, 22)" end="(427, 23)" leading="" trailing="" val="("/>
                    <OtherNode start="(427, 23)" end="(427, 34)" kind="«term_&amp;lt;|_»">
                      <IdentNode start="(427, 23)" end="(427, 27)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(427, 28)" end="(427, 30)" leading="" trailing=" " val="&amp;lt;|"/>
                      <OtherNode start="(427, 31)" end="(427, 34)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(427, 31)" end="(427, 32)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(427, 33)" end="(427, 34)">
                          <OtherNode start="(427, 33)" end="(427, 34)" kind="Lean.Parser.Term.cdot">
                            <AtomNode start="(427, 33)" end="(427, 34)" leading="" trailing="" val="·"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(427, 34)" end="(427, 35)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(427, 36)" end="(427, 37)" leading="" trailing=" " val="="/>
              <OtherNode start="(427, 38)" end="(427, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(427, 38)" end="(427, 42)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(427, 43)" end="(427, 53)">
                  <OtherNode start="(427, 43)" end="(427, 53)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(427, 43)" end="(427, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(427, 44)" end="(427, 52)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(427, 44)" end="(427, 50)" leading="" trailing=" " raw_val="as.all" val="as.all"/>
                      <NullNode start="(427, 51)" end="(427, 52)">
                        <IdentNode start="(427, 51)" end="(427, 52)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(427, 52)" end="(427, 53)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(427, 54)" end="(428, 50)">
          <AtomNode start="(427, 54)" end="(427, 56)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(427, 57)" end="(428, 50)">
            <AtomNode start="(427, 57)" end="(427, 59)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(428, 3)" end="(428, 50)">
              <TacticTacticseq1IndentedNode start="(428, 3)" end="(428, 50)">
                <NullNode start="(428, 3)" end="(428, 50)">
                  <OtherNode start="(428, 3)" end="(428, 50)" kind="Lean.Parser.Tactic.simp" state_before="m : Type → Type u_1&#10;α : Type u_2&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Bool&#10;as : List α&#10;⊢ allM (fun x =&amp;gt; pure (p x)) as = pure (as.all p)" state_after="no goals" tactic="simp [allM_eq_not_anyM_not, all_eq_not_any_not]">
                    <AtomNode start="(428, 3)" end="(428, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(428, 8)" end="(428, 50)">
                      <AtomNode start="(428, 8)" end="(428, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(428, 9)" end="(428, 49)">
                        <OtherNode start="(428, 9)" end="(428, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(428, 9)" end="(428, 29)" leading="" trailing="" raw_val="allM_eq_not_anyM_not" val="allM_eq_not_anyM_not" full_name="List.allM_eq_not_anyM_not" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(408, 9)" def_end="(408, 29)"/>
                        </OtherNode>
                        <AtomNode start="(428, 29)" end="(428, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(428, 31)" end="(428, 49)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(428, 31)" end="(428, 49)" leading="" trailing="" raw_val="all_eq_not_any_not" val="all_eq_not_any_not" full_name="List.all_eq_not_any_not" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(428, 49)" end="(428, 50)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(430, 1)" end="(430, 95)" comment="### Recognizing higher order functions using a function that only depends on the value. -/">
      <AtomNode start="(430, 1)" end="(430, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(430, 5)" end="(430, 95)" leading="" trailing="&#10;&#10;" val="### Recognizing higher order functions using a function that only depends on the value. -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(432, 1)" end="(443, 33)" name="foldlM_subtype" full_name="List.foldlM_subtype">
      <CommandDeclmodifiersNode start="(432, 1)" end="(436, 8)">
        <NullNode start="(432, 1)" end="(435, 3)">
          <CommandDoccommentNode start="(432, 1)" end="(435, 3)" comment="This lemma identifies monadic folds over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/">
            <AtomNode start="(432, 1)" end="(432, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(433, 1)" end="(435, 3)" leading="" trailing="&#10;" val="This lemma identifies monadic folds over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(436, 1)" end="(436, 8)">
          <OtherNode start="(436, 1)" end="(436, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(436, 1)" end="(436, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(436, 3)" end="(436, 7)">
              <OtherNode start="(436, 3)" end="(436, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(436, 3)" end="(436, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(436, 3)" end="(436, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(436, 7)" end="(436, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(436, 9)" end="(443, 33)" name="foldlM_subtype" full_name="List.foldlM_subtype" _is_private_decl="False">
        <AtomNode start="(436, 9)" end="(436, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(436, 17)" end="(436, 31)">
          <IdentNode start="(436, 17)" end="(436, 31)" leading="" trailing=" " raw_val="foldlM_subtype" val="foldlM_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(436, 32)" end="(439, 41)">
          <NullNode start="(436, 32)" end="(438, 39)">
            <OtherNode start="(436, 32)" end="(436, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(436, 32)" end="(436, 33)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(436, 33)" end="(436, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(436, 33)" end="(436, 38)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(436, 39)" end="(436, 40)">
                  <IdentNode start="(436, 39)" end="(436, 40)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(436, 40)" end="(436, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(436, 42)" end="(436, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(436, 42)" end="(436, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(436, 43)" end="(436, 44)">
                <IdentNode start="(436, 43)" end="(436, 44)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(436, 45)" end="(436, 55)">
                <AtomNode start="(436, 45)" end="(436, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(436, 47)" end="(436, 55)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(436, 47)" end="(436, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(436, 49)" end="(436, 50)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(436, 51)" end="(436, 55)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(436, 51)" end="(436, 55)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(436, 55)" end="(436, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(436, 57)" end="(436, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(436, 57)" end="(436, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(436, 58)" end="(436, 59)">
                <IdentNode start="(436, 58)" end="(436, 59)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(436, 60)" end="(436, 79)">
                <AtomNode start="(436, 60)" end="(436, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(436, 62)" end="(436, 79)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(436, 62)" end="(436, 66)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(436, 67)" end="(436, 79)">
                    <OtherNode start="(436, 67)" end="(436, 79)" kind="«term{_:_//_}»">
                      <AtomNode start="(436, 67)" end="(436, 68)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(436, 69)" end="(436, 70)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(436, 71)" end="(436, 73)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(436, 74)" end="(436, 77)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(436, 74)" end="(436, 75)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(436, 76)" end="(436, 77)">
                          <IdentNode start="(436, 76)" end="(436, 77)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(436, 78)" end="(436, 79)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(436, 79)" end="(436, 80)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(437, 5)" end="(437, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(437, 5)" end="(437, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(437, 6)" end="(437, 7)">
                <IdentNode start="(437, 6)" end="(437, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(437, 8)" end="(437, 32)">
                <AtomNode start="(437, 8)" end="(437, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(437, 10)" end="(437, 32)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(437, 10)" end="(437, 11)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(437, 12)" end="(437, 13)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(437, 14)" end="(437, 32)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(437, 14)" end="(437, 26)" kind="«term{_:_//_}»">
                      <AtomNode start="(437, 14)" end="(437, 15)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(437, 16)" end="(437, 17)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(437, 18)" end="(437, 20)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(437, 21)" end="(437, 24)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(437, 21)" end="(437, 22)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(437, 23)" end="(437, 24)">
                          <IdentNode start="(437, 23)" end="(437, 24)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(437, 25)" end="(437, 26)" leading="" trailing=" " val="}"/>
                    </OtherNode>
                    <AtomNode start="(437, 27)" end="(437, 28)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(437, 29)" end="(437, 32)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(437, 29)" end="(437, 30)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(437, 31)" end="(437, 32)">
                        <IdentNode start="(437, 31)" end="(437, 32)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(437, 32)" end="(437, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(437, 34)" end="(437, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(437, 34)" end="(437, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(437, 35)" end="(437, 36)">
                <IdentNode start="(437, 35)" end="(437, 36)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(437, 37)" end="(437, 50)">
                <AtomNode start="(437, 37)" end="(437, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(437, 39)" end="(437, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(437, 39)" end="(437, 40)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(437, 41)" end="(437, 42)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(437, 43)" end="(437, 50)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(437, 43)" end="(437, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(437, 45)" end="(437, 46)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(437, 47)" end="(437, 50)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(437, 47)" end="(437, 48)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(437, 49)" end="(437, 50)">
                        <IdentNode start="(437, 49)" end="(437, 50)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(437, 50)" end="(437, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(437, 52)" end="(437, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(437, 52)" end="(437, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(437, 53)" end="(437, 54)">
                <IdentNode start="(437, 53)" end="(437, 54)" leading="" trailing=" " raw_val="x" val="x"/>
              </NullNode>
              <NullNode start="(437, 55)" end="(437, 58)">
                <AtomNode start="(437, 55)" end="(437, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(437, 57)" end="(437, 58)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(437, 58)" end="(437, 59)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(438, 5)" end="(438, 39)">
              <AtomNode start="(438, 5)" end="(438, 6)" leading="" trailing="" val="("/>
              <NullNode start="(438, 6)" end="(438, 8)">
                <IdentNode start="(438, 6)" end="(438, 8)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(438, 9)" end="(438, 38)">
                <AtomNode start="(438, 9)" end="(438, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(438, 11)" end="(438, 38)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(438, 11)" end="(438, 12)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(438, 13)" end="(438, 18)">
                    <IdentNode start="(438, 13)" end="(438, 14)" leading="" trailing=" " raw_val="b" val="b"/>
                    <IdentNode start="(438, 15)" end="(438, 16)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(438, 17)" end="(438, 18)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(438, 18)" end="(438, 19)" leading="" trailing=" " val=","/>
                  <OtherNode start="(438, 20)" end="(438, 38)" kind="«term_=_»">
                    <OtherNode start="(438, 20)" end="(438, 30)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(438, 20)" end="(438, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(438, 22)" end="(438, 30)">
                        <IdentNode start="(438, 22)" end="(438, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                        <OtherNode start="(438, 24)" end="(438, 30)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(438, 24)" end="(438, 25)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(438, 25)" end="(438, 29)">
                            <IdentNode start="(438, 25)" end="(438, 26)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(438, 26)" end="(438, 27)" leading="" trailing=" " val=","/>
                            <IdentNode start="(438, 28)" end="(438, 29)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(438, 29)" end="(438, 30)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(438, 31)" end="(438, 32)" leading="" trailing=" " val="="/>
                    <OtherNode start="(438, 33)" end="(438, 38)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(438, 33)" end="(438, 34)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(438, 35)" end="(438, 38)">
                        <IdentNode start="(438, 35)" end="(438, 36)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(438, 37)" end="(438, 38)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(438, 38)" end="(438, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(438, 40)" end="(439, 41)">
            <AtomNode start="(438, 40)" end="(438, 41)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(439, 5)" end="(439, 41)" kind="«term_=_»">
              <OtherNode start="(439, 5)" end="(439, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(439, 5)" end="(439, 13)" leading="" trailing=" " raw_val="l.foldlM" val="l.foldlM"/>
                <NullNode start="(439, 14)" end="(439, 17)">
                  <IdentNode start="(439, 14)" end="(439, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(439, 16)" end="(439, 17)" leading="" trailing=" " raw_val="x" val="x"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(439, 18)" end="(439, 19)" leading="" trailing=" " val="="/>
              <OtherNode start="(439, 20)" end="(439, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(439, 20)" end="(439, 37)" leading="" trailing=" " raw_val="l.unattach.foldlM" val="l.unattach.foldlM"/>
                <NullNode start="(439, 38)" end="(439, 41)">
                  <IdentNode start="(439, 38)" end="(439, 39)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(439, 40)" end="(439, 41)" leading="" trailing=" " raw_val="x" val="x"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(439, 42)" end="(443, 33)">
          <AtomNode start="(439, 42)" end="(439, 44)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(439, 45)" end="(443, 33)">
            <AtomNode start="(439, 45)" end="(439, 47)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(440, 3)" end="(443, 33)">
              <TacticTacticseq1IndentedNode start="(440, 3)" end="(443, 33)">
                <NullNode start="(440, 3)" end="(443, 33)">
                  <OtherNode start="(440, 3)" end="(440, 18)" kind="Lean.Parser.Tactic.unfold" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : β → { x // p x } → m β&#10;g : β → α → m β&#10;x : β&#10;hf : ∀ (b : β) (x : α) (h : p x), f b ⟨x, h⟩ = g b x&#10;⊢ foldlM f x l = foldlM g x l.unattach" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : β → { x // p x } → m β&#10;g : β → α → m β&#10;x : β&#10;hf : ∀ (b : β) (x : α) (h : p x), f b ⟨x, h⟩ = g b x&#10;⊢ foldlM f x l = foldlM g x (map (fun x =&amp;gt; x.val) l)" tactic="unfold unattach">
                    <AtomNode start="(440, 3)" end="(440, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(440, 10)" end="(440, 18)">
                      <IdentNode start="(440, 10)" end="(440, 18)" leading="" trailing="&#10;  " raw_val="unattach" val="unattach" full_name="List.unattach" mod_name="Init.Data.List.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Attach.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(441, 3)" end="(443, 33)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : β → { x // p x } → m β&#10;g : β → α → m β&#10;x : β&#10;hf : ∀ (b : β) (x : α) (h : p x), f b ⟨x, h⟩ = g b x&#10;⊢ foldlM f x l = foldlM g x (map (fun x =&amp;gt; x.val) l)" state_after="no goals" tactic="induction l generalizing x with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt; simp [ih, hf]">
                    <AtomNode start="(441, 3)" end="(441, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(441, 13)" end="(441, 14)">
                      <OtherNode start="(441, 13)" end="(441, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(441, 13)" end="(441, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(441, 15)" end="(441, 29)">
                      <AtomNode start="(441, 15)" end="(441, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(441, 28)" end="(441, 29)">
                        <IdentNode start="(441, 28)" end="(441, 29)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(441, 30)" end="(443, 33)">
                      <OtherNode start="(441, 30)" end="(443, 33)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(441, 30)" end="(441, 34)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(442, 3)" end="(443, 33)">
                          <OtherNode start="(442, 3)" end="(442, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(442, 3)" end="(442, 8)">
                              <OtherNode start="(442, 3)" end="(442, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(442, 3)" end="(442, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(442, 5)" end="(442, 8)">
                                  <NullNode/>
                                  <IdentNode start="(442, 5)" end="(442, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(442, 9)" end="(442, 16)">
                              <AtomNode start="(442, 9)" end="(442, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(442, 12)" end="(442, 16)">
                                <TacticTacticseq1IndentedNode start="(442, 12)" end="(442, 16)">
                                  <NullNode start="(442, 12)" end="(442, 16)">
                                    <OtherNode start="(442, 12)" end="(442, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;p : α → Prop&#10;f : β → { x // p x } → m β&#10;g : β → α → m β&#10;hf : ∀ (b : β) (x : α) (h : p x), f b ⟨x, h⟩ = g b x&#10;x : β&#10;⊢ foldlM f x [] = foldlM g x (map (fun x =&amp;gt; x.val) [])" state_after="no goals" tactic="simp">
                                      <AtomNode start="(442, 12)" end="(442, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(443, 3)" end="(443, 33)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(443, 3)" end="(443, 16)">
                              <OtherNode start="(443, 3)" end="(443, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(443, 3)" end="(443, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(443, 5)" end="(443, 9)">
                                  <NullNode/>
                                  <IdentNode start="(443, 5)" end="(443, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(443, 10)" end="(443, 16)">
                                  <IdentNode start="(443, 10)" end="(443, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(443, 12)" end="(443, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(443, 14)" end="(443, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(443, 17)" end="(443, 33)">
                              <AtomNode start="(443, 17)" end="(443, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(443, 20)" end="(443, 33)">
                                <TacticTacticseq1IndentedNode start="(443, 20)" end="(443, 33)">
                                  <NullNode start="(443, 20)" end="(443, 33)">
                                    <OtherNode start="(443, 20)" end="(443, 33)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;p : α → Prop&#10;f : β → { x // p x } → m β&#10;g : β → α → m β&#10;hf : ∀ (b : β) (x : α) (h : p x), f b ⟨x, h⟩ = g b x&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : ∀ {x : β}, foldlM f x l = foldlM g x (map (fun x =&amp;gt; x.val) l)&#10;x : β&#10;⊢ foldlM f x (a :: l) = foldlM g x (map (fun x =&amp;gt; x.val) (a :: l))" state_after="no goals" tactic="simp [ih, hf]">
                                      <AtomNode start="(443, 20)" end="(443, 24)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(443, 25)" end="(443, 33)">
                                        <AtomNode start="(443, 25)" end="(443, 26)" leading="" trailing="" val="["/>
                                        <NullNode start="(443, 26)" end="(443, 32)">
                                          <OtherNode start="(443, 26)" end="(443, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(443, 26)" end="(443, 28)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(443, 28)" end="(443, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(443, 30)" end="(443, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(443, 30)" end="(443, 32)" leading="" trailing="" raw_val="hf" val="hf"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(443, 32)" end="(443, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(445, 1)" end="(447, 17)" name="foldlM_wfParam" full_name="List.foldlM_wfParam">
      <CommandDeclmodifiersNode start="(445, 1)" end="(445, 17)">
        <NullNode/>
        <NullNode start="(445, 1)" end="(445, 17)">
          <OtherNode start="(445, 1)" end="(445, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(445, 1)" end="(445, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(445, 3)" end="(445, 16)">
              <OtherNode start="(445, 3)" end="(445, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(445, 3)" end="(445, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(445, 3)" end="(445, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(445, 16)" end="(445, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(445, 18)" end="(447, 17)" name="foldlM_wfParam" full_name="List.foldlM_wfParam" _is_private_decl="False">
        <AtomNode start="(445, 18)" end="(445, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(445, 26)" end="(445, 40)">
          <IdentNode start="(445, 26)" end="(445, 40)" leading="" trailing=" " raw_val="foldlM_wfParam" val="foldlM_wfParam"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(445, 41)" end="(446, 66)">
          <NullNode start="(445, 41)" end="(445, 93)">
            <OtherNode start="(445, 41)" end="(445, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(445, 41)" end="(445, 42)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(445, 42)" end="(445, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(445, 42)" end="(445, 47)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(445, 48)" end="(445, 49)">
                  <IdentNode start="(445, 48)" end="(445, 49)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(445, 49)" end="(445, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(445, 51)" end="(445, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(445, 51)" end="(445, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(445, 52)" end="(445, 54)">
                <IdentNode start="(445, 52)" end="(445, 54)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(445, 55)" end="(445, 63)">
                <AtomNode start="(445, 55)" end="(445, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(445, 57)" end="(445, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(445, 57)" end="(445, 61)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(445, 62)" end="(445, 63)">
                    <IdentNode start="(445, 62)" end="(445, 63)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(445, 63)" end="(445, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(445, 65)" end="(445, 82)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(445, 65)" end="(445, 66)" leading="" trailing="" val="{"/>
              <NullNode start="(445, 66)" end="(445, 67)">
                <IdentNode start="(445, 66)" end="(445, 67)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(445, 68)" end="(445, 81)">
                <AtomNode start="(445, 68)" end="(445, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(445, 70)" end="(445, 81)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(445, 70)" end="(445, 71)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(445, 72)" end="(445, 73)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(445, 74)" end="(445, 81)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(445, 74)" end="(445, 75)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(445, 76)" end="(445, 77)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(445, 78)" end="(445, 81)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(445, 78)" end="(445, 79)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(445, 80)" end="(445, 81)">
                        <IdentNode start="(445, 80)" end="(445, 81)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(445, 81)" end="(445, 82)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(445, 83)" end="(445, 93)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(445, 83)" end="(445, 84)" leading="" trailing="" val="{"/>
              <NullNode start="(445, 84)" end="(445, 88)">
                <IdentNode start="(445, 84)" end="(445, 88)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(445, 89)" end="(445, 92)">
                <AtomNode start="(445, 89)" end="(445, 90)" leading="" trailing=" " val=":"/>
                <IdentNode start="(445, 91)" end="(445, 92)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(445, 92)" end="(445, 93)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(445, 94)" end="(446, 66)">
            <AtomNode start="(445, 94)" end="(445, 95)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(446, 5)" end="(446, 66)" kind="«term_=_»">
              <OtherNode start="(446, 5)" end="(446, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(446, 5)" end="(446, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(446, 5)" end="(446, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(446, 5)" end="(446, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(446, 6)" end="(446, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(446, 6)" end="(446, 13)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                      <NullNode start="(446, 14)" end="(446, 16)">
                        <IdentNode start="(446, 14)" end="(446, 16)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(446, 16)" end="(446, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(446, 17)" end="(446, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(446, 18)" end="(446, 24)" leading="" trailing=" " raw_val="foldlM" val="foldlM" full_name="List.foldlM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(446, 25)" end="(446, 31)">
                  <IdentNode start="(446, 25)" end="(446, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(446, 27)" end="(446, 31)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(446, 32)" end="(446, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(446, 34)" end="(446, 66)" kind="Lean.Parser.Term.app">
                <IdentNode start="(446, 34)" end="(446, 59)" leading="" trailing=" " raw_val="xs.attach.unattach.foldlM" val="xs.attach.unattach.foldlM"/>
                <NullNode start="(446, 60)" end="(446, 66)">
                  <IdentNode start="(446, 60)" end="(446, 61)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(446, 62)" end="(446, 66)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(446, 67)" end="(447, 17)">
          <AtomNode start="(446, 67)" end="(446, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(446, 70)" end="(447, 17)">
            <AtomNode start="(446, 70)" end="(446, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(447, 3)" end="(447, 17)">
              <TacticTacticseq1IndentedNode start="(447, 3)" end="(447, 17)">
                <NullNode start="(447, 3)" end="(447, 17)">
                  <OtherNode start="(447, 3)" end="(447, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;xs : List α&#10;f : β → α → m β&#10;init : β&#10;⊢ foldlM f init (wfParam xs) = foldlM f init xs.attach.unattach" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(447, 3)" end="(447, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(447, 8)" end="(447, 17)">
                      <AtomNode start="(447, 8)" end="(447, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(447, 9)" end="(447, 16)">
                        <OtherNode start="(447, 9)" end="(447, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(447, 9)" end="(447, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(447, 16)" end="(447, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(449, 1)" end="(453, 17)" name="foldlM_unattach" full_name="List.foldlM_unattach">
      <CommandDeclmodifiersNode start="(449, 1)" end="(449, 17)">
        <NullNode/>
        <NullNode start="(449, 1)" end="(449, 17)">
          <OtherNode start="(449, 1)" end="(449, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(449, 1)" end="(449, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(449, 3)" end="(449, 16)">
              <OtherNode start="(449, 3)" end="(449, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(449, 3)" end="(449, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(449, 3)" end="(449, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(449, 16)" end="(449, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(449, 18)" end="(453, 17)" name="foldlM_unattach" full_name="List.foldlM_unattach" _is_private_decl="False">
        <AtomNode start="(449, 18)" end="(449, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(449, 26)" end="(449, 41)">
          <IdentNode start="(449, 26)" end="(449, 41)" leading="" trailing=" " raw_val="foldlM_unattach" val="foldlM_unattach"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(449, 42)" end="(452, 22)">
          <NullNode start="(449, 42)" end="(449, 119)">
            <OtherNode start="(449, 42)" end="(449, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(449, 42)" end="(449, 43)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(449, 43)" end="(449, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(449, 43)" end="(449, 48)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(449, 49)" end="(449, 50)">
                  <IdentNode start="(449, 49)" end="(449, 50)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(449, 50)" end="(449, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(449, 52)" end="(449, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(449, 52)" end="(449, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(449, 53)" end="(449, 54)">
                <IdentNode start="(449, 53)" end="(449, 54)" leading="" trailing=" " raw_val="P" val="P"/>
              </NullNode>
              <NullNode start="(449, 55)" end="(449, 65)">
                <AtomNode start="(449, 55)" end="(449, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(449, 57)" end="(449, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(449, 57)" end="(449, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(449, 59)" end="(449, 60)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(449, 61)" end="(449, 65)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(449, 61)" end="(449, 65)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(449, 65)" end="(449, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(449, 67)" end="(449, 90)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(449, 67)" end="(449, 68)" leading="" trailing="" val="{"/>
              <NullNode start="(449, 68)" end="(449, 70)">
                <IdentNode start="(449, 68)" end="(449, 70)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(449, 71)" end="(449, 89)">
                <AtomNode start="(449, 71)" end="(449, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(449, 73)" end="(449, 89)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(449, 73)" end="(449, 77)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(449, 78)" end="(449, 89)">
                    <OtherNode start="(449, 78)" end="(449, 89)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(449, 78)" end="(449, 79)" leading="" trailing="" val="("/>
                      <OtherNode start="(449, 79)" end="(449, 88)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(449, 79)" end="(449, 86)" leading="" trailing=" " raw_val="Subtype" val="Subtype" full_name="Subtype" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(449, 87)" end="(449, 88)">
                          <IdentNode start="(449, 87)" end="(449, 88)" leading="" trailing="" raw_val="P" val="P"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(449, 88)" end="(449, 89)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(449, 89)" end="(449, 90)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(449, 91)" end="(449, 108)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(449, 91)" end="(449, 92)" leading="" trailing="" val="{"/>
              <NullNode start="(449, 92)" end="(449, 93)">
                <IdentNode start="(449, 92)" end="(449, 93)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(449, 94)" end="(449, 107)">
                <AtomNode start="(449, 94)" end="(449, 95)" leading="" trailing=" " val=":"/>
                <OtherNode start="(449, 96)" end="(449, 107)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(449, 96)" end="(449, 97)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(449, 98)" end="(449, 99)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(449, 100)" end="(449, 107)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(449, 100)" end="(449, 101)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(449, 102)" end="(449, 103)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(449, 104)" end="(449, 107)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(449, 104)" end="(449, 105)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(449, 106)" end="(449, 107)">
                        <IdentNode start="(449, 106)" end="(449, 107)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(449, 107)" end="(449, 108)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(449, 109)" end="(449, 119)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(449, 109)" end="(449, 110)" leading="" trailing="" val="{"/>
              <NullNode start="(449, 110)" end="(449, 114)">
                <IdentNode start="(449, 110)" end="(449, 114)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(449, 115)" end="(449, 118)">
                <AtomNode start="(449, 115)" end="(449, 116)" leading="" trailing=" " val=":"/>
                <IdentNode start="(449, 117)" end="(449, 118)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(449, 118)" end="(449, 119)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(449, 120)" end="(452, 22)">
            <AtomNode start="(449, 120)" end="(449, 121)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(450, 5)" end="(452, 22)" kind="«term_=_»">
              <OtherNode start="(450, 5)" end="(450, 30)" kind="Lean.Parser.Term.app">
                <IdentNode start="(450, 5)" end="(450, 23)" leading="" trailing=" " raw_val="xs.unattach.foldlM" val="xs.unattach.foldlM"/>
                <NullNode start="(450, 24)" end="(450, 30)">
                  <IdentNode start="(450, 24)" end="(450, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(450, 26)" end="(450, 30)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(450, 31)" end="(450, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(450, 33)" end="(452, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(450, 33)" end="(450, 42)" leading="" trailing=" " raw_val="xs.foldlM" val="xs.foldlM"/>
                <NullNode start="(450, 43)" end="(452, 22)">
                  <OtherNode start="(450, 43)" end="(450, 57)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(450, 43)" end="(450, 44)" leading="" trailing="" val="("/>
                    <IdentNode start="(450, 44)" end="(450, 48)" leading="" trailing=" " raw_val="init" val="init"/>
                    <AtomNode start="(450, 49)" end="(450, 51)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(450, 52)" end="(450, 56)" leading="" trailing="" raw_val="init" val="init"/>
                    <AtomNode start="(450, 56)" end="(450, 57)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(450, 58)" end="(452, 22)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(450, 58)" end="(450, 61)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(450, 62)" end="(452, 22)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(450, 62)" end="(450, 70)">
                        <IdentNode start="(450, 62)" end="(450, 63)" leading="" trailing=" " raw_val="b" val="b"/>
                        <OtherNode start="(450, 64)" end="(450, 70)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(450, 64)" end="(450, 65)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(450, 65)" end="(450, 69)">
                            <IdentNode start="(450, 65)" end="(450, 66)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(450, 66)" end="(450, 67)" leading="" trailing=" " val=","/>
                            <IdentNode start="(450, 68)" end="(450, 69)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(450, 69)" end="(450, 70)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(450, 71)" end="(450, 73)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                      <OtherNode start="(451, 7)" end="(452, 22)" kind="«term_&amp;lt;|_»">
                        <OtherNode start="(451, 7)" end="(451, 25)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(451, 7)" end="(451, 21)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                          <NullNode start="(451, 22)" end="(451, 25)">
                            <IdentNode start="(451, 22)" end="(451, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                            <IdentNode start="(451, 24)" end="(451, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(451, 26)" end="(451, 28)" leading="" trailing=" " val="&amp;lt;|"/>
                        <OtherNode start="(451, 29)" end="(452, 22)" kind="«term_&amp;lt;|_»">
                          <OtherNode start="(451, 29)" end="(451, 51)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(451, 29)" end="(451, 43)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                            <NullNode start="(451, 44)" end="(451, 51)">
                              <IdentNode start="(451, 44)" end="(451, 45)" leading="" trailing=" " raw_val="x" val="x"/>
                              <OtherNode start="(451, 46)" end="(451, 51)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(451, 46)" end="(451, 47)" leading="" trailing="" val="("/>
                                <OtherNode start="(451, 47)" end="(451, 50)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(451, 47)" end="(451, 48)" leading="" trailing=" " raw_val="f" val="f"/>
                                  <NullNode start="(451, 49)" end="(451, 50)">
                                    <IdentNode start="(451, 49)" end="(451, 50)" leading="" trailing="" raw_val="b" val="b"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(451, 50)" end="(451, 51)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(451, 52)" end="(451, 54)" leading="" trailing=" " val="&amp;lt;|"/>
                          <OtherNode start="(451, 55)" end="(452, 22)" kind="«term_&amp;lt;|_»">
                            <OtherNode start="(451, 55)" end="(451, 74)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(451, 55)" end="(451, 69)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                              <NullNode start="(451, 70)" end="(451, 74)">
                                <IdentNode start="(451, 70)" end="(451, 71)" leading="" trailing=" " raw_val="h" val="h"/>
                                <OtherNode start="(451, 72)" end="(451, 74)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(451, 72)" end="(451, 73)" leading="" trailing="" val="("/>
                                  <NullNode/>
                                  <AtomNode start="(451, 73)" end="(451, 74)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(451, 75)" end="(451, 77)" leading="" trailing="&#10;      " val="&amp;lt;|"/>
                            <OtherNode start="(452, 7)" end="(452, 22)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(452, 7)" end="(452, 8)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(452, 9)" end="(452, 22)">
                                <IdentNode start="(452, 9)" end="(452, 10)" leading="" trailing=" " raw_val="b" val="b"/>
                                <OtherNode start="(452, 11)" end="(452, 22)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(452, 11)" end="(452, 12)" leading="" trailing="" val="("/>
                                  <OtherNode start="(452, 12)" end="(452, 21)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(452, 12)" end="(452, 19)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                    <NullNode start="(452, 20)" end="(452, 21)">
                                      <IdentNode start="(452, 20)" end="(452, 21)" leading="" trailing="" raw_val="x" val="x"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(452, 21)" end="(452, 22)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(452, 23)" end="(453, 17)">
          <AtomNode start="(452, 23)" end="(452, 25)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(452, 26)" end="(453, 17)">
            <AtomNode start="(452, 26)" end="(452, 28)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(453, 3)" end="(453, 17)">
              <TacticTacticseq1IndentedNode start="(453, 3)" end="(453, 17)">
                <NullNode start="(453, 3)" end="(453, 17)">
                  <OtherNode start="(453, 3)" end="(453, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝ : Monad m&#10;P : α → Prop&#10;xs : List (Subtype P)&#10;f : β → α → m β&#10;init : β&#10;⊢ foldlM f init xs.unattach =&#10;    foldlM&#10;      (fun b x =&amp;gt;&#10;        match x with&#10;        | ⟨x, h⟩ =&amp;gt; binderNameHint b f (binderNameHint x (f b) (binderNameHint h () (f b (wfParam x)))))&#10;      init xs" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(453, 3)" end="(453, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(453, 8)" end="(453, 17)">
                      <AtomNode start="(453, 8)" end="(453, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(453, 9)" end="(453, 16)">
                        <OtherNode start="(453, 9)" end="(453, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(453, 9)" end="(453, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(453, 16)" end="(453, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(455, 1)" end="(470, 14)" name="foldrM_subtype" full_name="List.foldrM_subtype">
      <CommandDeclmodifiersNode start="(455, 1)" end="(459, 8)">
        <NullNode start="(455, 1)" end="(458, 3)">
          <CommandDoccommentNode start="(455, 1)" end="(458, 3)" comment="This lemma identifies monadic folds over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/">
            <AtomNode start="(455, 1)" end="(455, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(456, 1)" end="(458, 3)" leading="" trailing="&#10;" val="This lemma identifies monadic folds over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(459, 1)" end="(459, 8)">
          <OtherNode start="(459, 1)" end="(459, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(459, 1)" end="(459, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(459, 3)" end="(459, 7)">
              <OtherNode start="(459, 3)" end="(459, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(459, 3)" end="(459, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(459, 3)" end="(459, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(459, 7)" end="(459, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(459, 9)" end="(470, 14)" name="foldrM_subtype" full_name="List.foldrM_subtype" _is_private_decl="False">
        <AtomNode start="(459, 9)" end="(459, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(459, 17)" end="(459, 31)">
          <IdentNode start="(459, 17)" end="(459, 31)" leading="" trailing=" " raw_val="foldrM_subtype" val="foldrM_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(459, 32)" end="(462, 41)">
          <NullNode start="(459, 32)" end="(461, 39)">
            <OtherNode start="(459, 32)" end="(459, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(459, 32)" end="(459, 33)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(459, 33)" end="(459, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(459, 33)" end="(459, 38)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(459, 39)" end="(459, 40)">
                  <IdentNode start="(459, 39)" end="(459, 40)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(459, 40)" end="(459, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(459, 42)" end="(459, 57)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(459, 42)" end="(459, 43)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(459, 43)" end="(459, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(459, 43)" end="(459, 54)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(459, 55)" end="(459, 56)">
                  <IdentNode start="(459, 55)" end="(459, 56)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(459, 56)" end="(459, 57)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(459, 58)" end="(459, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(459, 58)" end="(459, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(459, 59)" end="(459, 60)">
                <IdentNode start="(459, 59)" end="(459, 60)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(459, 61)" end="(459, 71)">
                <AtomNode start="(459, 61)" end="(459, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(459, 63)" end="(459, 71)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(459, 63)" end="(459, 64)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(459, 65)" end="(459, 66)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(459, 67)" end="(459, 71)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(459, 67)" end="(459, 71)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(459, 71)" end="(459, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(459, 73)" end="(459, 96)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(459, 73)" end="(459, 74)" leading="" trailing="" val="{"/>
              <NullNode start="(459, 74)" end="(459, 75)">
                <IdentNode start="(459, 74)" end="(459, 75)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(459, 76)" end="(459, 95)">
                <AtomNode start="(459, 76)" end="(459, 77)" leading="" trailing=" " val=":"/>
                <OtherNode start="(459, 78)" end="(459, 95)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(459, 78)" end="(459, 82)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(459, 83)" end="(459, 95)">
                    <OtherNode start="(459, 83)" end="(459, 95)" kind="«term{_:_//_}»">
                      <AtomNode start="(459, 83)" end="(459, 84)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(459, 85)" end="(459, 86)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(459, 87)" end="(459, 89)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(459, 90)" end="(459, 93)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(459, 90)" end="(459, 91)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(459, 92)" end="(459, 93)">
                          <IdentNode start="(459, 92)" end="(459, 93)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(459, 94)" end="(459, 95)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(459, 95)" end="(459, 96)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(460, 5)" end="(460, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(460, 5)" end="(460, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(460, 6)" end="(460, 7)">
                <IdentNode start="(460, 6)" end="(460, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(460, 8)" end="(460, 32)">
                <AtomNode start="(460, 8)" end="(460, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(460, 10)" end="(460, 32)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(460, 10)" end="(460, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(460, 10)" end="(460, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(460, 12)" end="(460, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(460, 14)" end="(460, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(460, 17)" end="(460, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(460, 17)" end="(460, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(460, 19)" end="(460, 20)">
                        <IdentNode start="(460, 19)" end="(460, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(460, 21)" end="(460, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(460, 23)" end="(460, 24)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(460, 25)" end="(460, 32)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(460, 25)" end="(460, 26)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(460, 27)" end="(460, 28)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(460, 29)" end="(460, 32)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(460, 29)" end="(460, 30)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(460, 31)" end="(460, 32)">
                        <IdentNode start="(460, 31)" end="(460, 32)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(460, 32)" end="(460, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(460, 34)" end="(460, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(460, 34)" end="(460, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(460, 35)" end="(460, 36)">
                <IdentNode start="(460, 35)" end="(460, 36)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(460, 37)" end="(460, 50)">
                <AtomNode start="(460, 37)" end="(460, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(460, 39)" end="(460, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(460, 39)" end="(460, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(460, 41)" end="(460, 42)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(460, 43)" end="(460, 50)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(460, 43)" end="(460, 44)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(460, 45)" end="(460, 46)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(460, 47)" end="(460, 50)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(460, 47)" end="(460, 48)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(460, 49)" end="(460, 50)">
                        <IdentNode start="(460, 49)" end="(460, 50)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(460, 50)" end="(460, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(460, 52)" end="(460, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(460, 52)" end="(460, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(460, 53)" end="(460, 54)">
                <IdentNode start="(460, 53)" end="(460, 54)" leading="" trailing=" " raw_val="x" val="x"/>
              </NullNode>
              <NullNode start="(460, 55)" end="(460, 58)">
                <AtomNode start="(460, 55)" end="(460, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(460, 57)" end="(460, 58)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(460, 58)" end="(460, 59)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(461, 5)" end="(461, 39)">
              <AtomNode start="(461, 5)" end="(461, 6)" leading="" trailing="" val="("/>
              <NullNode start="(461, 6)" end="(461, 8)">
                <IdentNode start="(461, 6)" end="(461, 8)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(461, 9)" end="(461, 38)">
                <AtomNode start="(461, 9)" end="(461, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(461, 11)" end="(461, 38)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(461, 11)" end="(461, 12)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(461, 13)" end="(461, 18)">
                    <IdentNode start="(461, 13)" end="(461, 14)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(461, 15)" end="(461, 16)" leading="" trailing=" " raw_val="h" val="h"/>
                    <IdentNode start="(461, 17)" end="(461, 18)" leading="" trailing="" raw_val="b" val="b"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(461, 18)" end="(461, 19)" leading="" trailing=" " val=","/>
                  <OtherNode start="(461, 20)" end="(461, 38)" kind="«term_=_»">
                    <OtherNode start="(461, 20)" end="(461, 30)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(461, 20)" end="(461, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(461, 22)" end="(461, 30)">
                        <OtherNode start="(461, 22)" end="(461, 28)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(461, 22)" end="(461, 23)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(461, 23)" end="(461, 27)">
                            <IdentNode start="(461, 23)" end="(461, 24)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(461, 24)" end="(461, 25)" leading="" trailing=" " val=","/>
                            <IdentNode start="(461, 26)" end="(461, 27)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(461, 27)" end="(461, 28)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                        <IdentNode start="(461, 29)" end="(461, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(461, 31)" end="(461, 32)" leading="" trailing=" " val="="/>
                    <OtherNode start="(461, 33)" end="(461, 38)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(461, 33)" end="(461, 34)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(461, 35)" end="(461, 38)">
                        <IdentNode start="(461, 35)" end="(461, 36)" leading="" trailing=" " raw_val="x" val="x"/>
                        <IdentNode start="(461, 37)" end="(461, 38)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(461, 38)" end="(461, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(461, 40)" end="(462, 41)">
            <AtomNode start="(461, 40)" end="(461, 41)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(462, 5)" end="(462, 41)" kind="«term_=_»">
              <OtherNode start="(462, 5)" end="(462, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(462, 5)" end="(462, 13)" leading="" trailing=" " raw_val="l.foldrM" val="l.foldrM"/>
                <NullNode start="(462, 14)" end="(462, 17)">
                  <IdentNode start="(462, 14)" end="(462, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(462, 16)" end="(462, 17)" leading="" trailing=" " raw_val="x" val="x"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(462, 18)" end="(462, 19)" leading="" trailing=" " val="="/>
              <OtherNode start="(462, 20)" end="(462, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(462, 20)" end="(462, 37)" leading="" trailing=" " raw_val="l.unattach.foldrM" val="l.unattach.foldrM"/>
                <NullNode start="(462, 38)" end="(462, 41)">
                  <IdentNode start="(462, 38)" end="(462, 39)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(462, 40)" end="(462, 41)" leading="" trailing=" " raw_val="x" val="x"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(462, 42)" end="(470, 14)">
          <AtomNode start="(462, 42)" end="(462, 44)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(462, 45)" end="(470, 14)">
            <AtomNode start="(462, 45)" end="(462, 47)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(463, 3)" end="(470, 14)">
              <TacticTacticseq1IndentedNode start="(463, 3)" end="(470, 14)">
                <NullNode start="(463, 3)" end="(470, 14)">
                  <OtherNode start="(463, 3)" end="(463, 18)" kind="Lean.Parser.Tactic.unfold" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;x : β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;⊢ foldrM f x l = foldrM g x l.unattach" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;x : β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;⊢ foldrM f x l = foldrM g x (map (fun x =&amp;gt; x.val) l)" tactic="unfold unattach">
                    <AtomNode start="(463, 3)" end="(463, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(463, 10)" end="(463, 18)">
                      <IdentNode start="(463, 10)" end="(463, 18)" leading="" trailing="&#10;  " raw_val="unattach" val="unattach" full_name="List.unattach" mod_name="Init.Data.List.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Attach.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(464, 3)" end="(470, 14)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;x : β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;⊢ foldrM f x l = foldrM g x (map (fun x =&amp;gt; x.val) l)" state_after="no goals" tactic="induction l generalizing x with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt;&#10;  simp [ih, hf, foldrM_cons]&#10;  congr&#10;  funext b&#10;  simp [hf]">
                    <AtomNode start="(464, 3)" end="(464, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(464, 13)" end="(464, 14)">
                      <OtherNode start="(464, 13)" end="(464, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(464, 13)" end="(464, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(464, 15)" end="(464, 29)">
                      <AtomNode start="(464, 15)" end="(464, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(464, 28)" end="(464, 29)">
                        <IdentNode start="(464, 28)" end="(464, 29)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(464, 30)" end="(470, 14)">
                      <OtherNode start="(464, 30)" end="(470, 14)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(464, 30)" end="(464, 34)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(465, 3)" end="(470, 14)">
                          <OtherNode start="(465, 3)" end="(465, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(465, 3)" end="(465, 8)">
                              <OtherNode start="(465, 3)" end="(465, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(465, 3)" end="(465, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(465, 5)" end="(465, 8)">
                                  <NullNode/>
                                  <IdentNode start="(465, 5)" end="(465, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(465, 9)" end="(465, 16)">
                              <AtomNode start="(465, 9)" end="(465, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(465, 12)" end="(465, 16)">
                                <TacticTacticseq1IndentedNode start="(465, 12)" end="(465, 16)">
                                  <NullNode start="(465, 12)" end="(465, 16)">
                                    <OtherNode start="(465, 12)" end="(465, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;x : β&#10;⊢ foldrM f x [] = foldrM g x (map (fun x =&amp;gt; x.val) [])" state_after="no goals" tactic="simp">
                                      <AtomNode start="(465, 12)" end="(465, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(466, 3)" end="(470, 14)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(466, 3)" end="(466, 16)">
                              <OtherNode start="(466, 3)" end="(466, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(466, 3)" end="(466, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(466, 5)" end="(466, 9)">
                                  <NullNode/>
                                  <IdentNode start="(466, 5)" end="(466, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(466, 10)" end="(466, 16)">
                                  <IdentNode start="(466, 10)" end="(466, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(466, 12)" end="(466, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(466, 14)" end="(466, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(466, 17)" end="(470, 14)">
                              <AtomNode start="(466, 17)" end="(466, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(467, 5)" end="(470, 14)">
                                <TacticTacticseq1IndentedNode start="(467, 5)" end="(470, 14)">
                                  <NullNode start="(467, 5)" end="(470, 14)">
                                    <OtherNode start="(467, 5)" end="(467, 31)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : ∀ {x : β}, foldrM f x l = foldrM g x (map (fun x =&amp;gt; x.val) l)&#10;x : β&#10;⊢ foldrM f x (a :: l) = foldrM g x (map (fun x =&amp;gt; x.val) (a :: l))" state_after="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : ∀ {x : β}, foldrM f x l = foldrM g x (map (fun x =&amp;gt; x.val) l)&#10;x : β&#10;⊢ foldrM g x l.unattach &amp;gt;&amp;gt;= f a = foldrM g x l.unattach &amp;gt;&amp;gt;= g a.val" tactic="simp [ih, hf, foldrM_cons]">
                                      <AtomNode start="(467, 5)" end="(467, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(467, 10)" end="(467, 31)">
                                        <AtomNode start="(467, 10)" end="(467, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(467, 11)" end="(467, 30)">
                                          <OtherNode start="(467, 11)" end="(467, 13)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(467, 11)" end="(467, 13)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(467, 13)" end="(467, 14)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(467, 15)" end="(467, 17)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(467, 15)" end="(467, 17)" leading="" trailing="" raw_val="hf" val="hf"/>
                                          </OtherNode>
                                          <AtomNode start="(467, 17)" end="(467, 18)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(467, 19)" end="(467, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(467, 19)" end="(467, 30)" leading="" trailing="" raw_val="foldrM_cons" val="foldrM_cons" full_name="List.foldrM_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(467, 30)" end="(467, 31)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(468, 5)" end="(468, 10)" kind="Lean.Parser.Tactic.congr" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : ∀ {x : β}, foldrM f x l = foldrM g x (map (fun x =&amp;gt; x.val) l)&#10;x : β&#10;⊢ foldrM g x l.unattach &amp;gt;&amp;gt;= f a = foldrM g x l.unattach &amp;gt;&amp;gt;= g a.val" state_after="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : ∀ {x : β}, foldrM f x l = foldrM g x (map (fun x =&amp;gt; x.val) l)&#10;x : β&#10;⊢ f a = g a.val" tactic="congr">
                                      <AtomNode start="(468, 5)" end="(468, 10)" leading="" trailing="&#10;    " val="congr"/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(469, 5)" end="(469, 13)" kind="tacticFunext___" state_before="case cons.e_a&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : ∀ {x : β}, foldrM f x l = foldrM g x (map (fun x =&amp;gt; x.val) l)&#10;x : β&#10;⊢ f a = g a.val" state_after="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : ∀ {x : β}, foldrM f x l = foldrM g x (map (fun x =&amp;gt; x.val) l)&#10;x b : β&#10;⊢ f a b = g a.val b" tactic="funext b">
                                      <AtomNode start="(469, 5)" end="(469, 11)" leading="" trailing=" " val="funext"/>
                                      <NullNode start="(469, 12)" end="(469, 13)">
                                        <IdentNode start="(469, 12)" end="(469, 13)" leading="" trailing="&#10;    " raw_val="b" val="b"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(470, 5)" end="(470, 14)" kind="Lean.Parser.Tactic.simp" state_before="case cons.e_a.h&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → β → m β&#10;g : α → β → m β&#10;hf : ∀ (x : α) (h : p x) (b : β), f ⟨x, h⟩ b = g x b&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : ∀ {x : β}, foldrM f x l = foldrM g x (map (fun x =&amp;gt; x.val) l)&#10;x b : β&#10;⊢ f a b = g a.val b" state_after="no goals" tactic="simp [hf]">
                                      <AtomNode start="(470, 5)" end="(470, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(470, 10)" end="(470, 14)">
                                        <AtomNode start="(470, 10)" end="(470, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(470, 11)" end="(470, 13)">
                                          <OtherNode start="(470, 11)" end="(470, 13)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(470, 11)" end="(470, 13)" leading="" trailing="" raw_val="hf" val="hf"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(470, 13)" end="(470, 14)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(472, 1)" end="(474, 17)" name="foldrM_wfParam" full_name="List.foldrM_wfParam">
      <CommandDeclmodifiersNode start="(472, 1)" end="(472, 17)">
        <NullNode/>
        <NullNode start="(472, 1)" end="(472, 17)">
          <OtherNode start="(472, 1)" end="(472, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(472, 1)" end="(472, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(472, 3)" end="(472, 16)">
              <OtherNode start="(472, 3)" end="(472, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(472, 3)" end="(472, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(472, 3)" end="(472, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(472, 16)" end="(472, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(472, 18)" end="(474, 17)" name="foldrM_wfParam" full_name="List.foldrM_wfParam" _is_private_decl="False">
        <AtomNode start="(472, 18)" end="(472, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(472, 26)" end="(472, 40)">
          <IdentNode start="(472, 26)" end="(472, 40)" leading="" trailing=" " raw_val="foldrM_wfParam" val="foldrM_wfParam"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(472, 41)" end="(473, 66)">
          <NullNode start="(472, 41)" end="(472, 109)">
            <OtherNode start="(472, 41)" end="(472, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(472, 41)" end="(472, 42)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(472, 42)" end="(472, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(472, 42)" end="(472, 47)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(472, 48)" end="(472, 49)">
                  <IdentNode start="(472, 48)" end="(472, 49)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(472, 49)" end="(472, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(472, 51)" end="(472, 66)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(472, 51)" end="(472, 52)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(472, 52)" end="(472, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(472, 52)" end="(472, 63)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(472, 64)" end="(472, 65)">
                  <IdentNode start="(472, 64)" end="(472, 65)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(472, 65)" end="(472, 66)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(472, 67)" end="(472, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(472, 67)" end="(472, 68)" leading="" trailing="" val="{"/>
              <NullNode start="(472, 68)" end="(472, 70)">
                <IdentNode start="(472, 68)" end="(472, 70)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(472, 71)" end="(472, 79)">
                <AtomNode start="(472, 71)" end="(472, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(472, 73)" end="(472, 79)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(472, 73)" end="(472, 77)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(472, 78)" end="(472, 79)">
                    <IdentNode start="(472, 78)" end="(472, 79)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(472, 79)" end="(472, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(472, 81)" end="(472, 98)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(472, 81)" end="(472, 82)" leading="" trailing="" val="{"/>
              <NullNode start="(472, 82)" end="(472, 83)">
                <IdentNode start="(472, 82)" end="(472, 83)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(472, 84)" end="(472, 97)">
                <AtomNode start="(472, 84)" end="(472, 85)" leading="" trailing=" " val=":"/>
                <OtherNode start="(472, 86)" end="(472, 97)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(472, 86)" end="(472, 87)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(472, 88)" end="(472, 89)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(472, 90)" end="(472, 97)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(472, 90)" end="(472, 91)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(472, 92)" end="(472, 93)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(472, 94)" end="(472, 97)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(472, 94)" end="(472, 95)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(472, 96)" end="(472, 97)">
                        <IdentNode start="(472, 96)" end="(472, 97)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(472, 97)" end="(472, 98)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(472, 99)" end="(472, 109)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(472, 99)" end="(472, 100)" leading="" trailing="" val="{"/>
              <NullNode start="(472, 100)" end="(472, 104)">
                <IdentNode start="(472, 100)" end="(472, 104)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(472, 105)" end="(472, 108)">
                <AtomNode start="(472, 105)" end="(472, 106)" leading="" trailing=" " val=":"/>
                <IdentNode start="(472, 107)" end="(472, 108)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(472, 108)" end="(472, 109)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(472, 110)" end="(473, 66)">
            <AtomNode start="(472, 110)" end="(472, 111)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(473, 5)" end="(473, 66)" kind="«term_=_»">
              <OtherNode start="(473, 5)" end="(473, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(473, 5)" end="(473, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(473, 5)" end="(473, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(473, 5)" end="(473, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(473, 6)" end="(473, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(473, 6)" end="(473, 13)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                      <NullNode start="(473, 14)" end="(473, 16)">
                        <IdentNode start="(473, 14)" end="(473, 16)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(473, 16)" end="(473, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(473, 17)" end="(473, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(473, 18)" end="(473, 24)" leading="" trailing=" " raw_val="foldrM" val="foldrM" full_name="List.foldrM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(473, 25)" end="(473, 31)">
                  <IdentNode start="(473, 25)" end="(473, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(473, 27)" end="(473, 31)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(473, 32)" end="(473, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(473, 34)" end="(473, 66)" kind="Lean.Parser.Term.app">
                <IdentNode start="(473, 34)" end="(473, 59)" leading="" trailing=" " raw_val="xs.attach.unattach.foldrM" val="xs.attach.unattach.foldrM"/>
                <NullNode start="(473, 60)" end="(473, 66)">
                  <IdentNode start="(473, 60)" end="(473, 61)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(473, 62)" end="(473, 66)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(473, 67)" end="(474, 17)">
          <AtomNode start="(473, 67)" end="(473, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(473, 70)" end="(474, 17)">
            <AtomNode start="(473, 70)" end="(473, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(474, 3)" end="(474, 17)">
              <TacticTacticseq1IndentedNode start="(474, 3)" end="(474, 17)">
                <NullNode start="(474, 3)" end="(474, 17)">
                  <OtherNode start="(474, 3)" end="(474, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : List α&#10;f : α → β → m β&#10;init : β&#10;⊢ foldrM f init (wfParam xs) = foldrM f init xs.attach.unattach" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(474, 3)" end="(474, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(474, 8)" end="(474, 17)">
                      <AtomNode start="(474, 8)" end="(474, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(474, 9)" end="(474, 16)">
                        <OtherNode start="(474, 9)" end="(474, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(474, 9)" end="(474, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(474, 16)" end="(474, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(476, 1)" end="(480, 17)" name="foldrM_unattach" full_name="List.foldrM_unattach">
      <CommandDeclmodifiersNode start="(476, 1)" end="(476, 17)">
        <NullNode/>
        <NullNode start="(476, 1)" end="(476, 17)">
          <OtherNode start="(476, 1)" end="(476, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(476, 1)" end="(476, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(476, 3)" end="(476, 16)">
              <OtherNode start="(476, 3)" end="(476, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(476, 3)" end="(476, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(476, 3)" end="(476, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(476, 16)" end="(476, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(476, 18)" end="(480, 17)" name="foldrM_unattach" full_name="List.foldrM_unattach" _is_private_decl="False">
        <AtomNode start="(476, 18)" end="(476, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(476, 26)" end="(476, 41)">
          <IdentNode start="(476, 26)" end="(476, 41)" leading="" trailing=" " raw_val="foldrM_unattach" val="foldrM_unattach"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(476, 42)" end="(479, 22)">
          <NullNode start="(476, 42)" end="(476, 135)">
            <OtherNode start="(476, 42)" end="(476, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(476, 42)" end="(476, 43)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(476, 43)" end="(476, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(476, 43)" end="(476, 48)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(476, 49)" end="(476, 50)">
                  <IdentNode start="(476, 49)" end="(476, 50)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(476, 50)" end="(476, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(476, 52)" end="(476, 67)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(476, 52)" end="(476, 53)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(476, 53)" end="(476, 66)" kind="Lean.Parser.Term.app">
                <IdentNode start="(476, 53)" end="(476, 64)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(476, 65)" end="(476, 66)">
                  <IdentNode start="(476, 65)" end="(476, 66)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(476, 66)" end="(476, 67)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(476, 68)" end="(476, 82)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(476, 68)" end="(476, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(476, 69)" end="(476, 70)">
                <IdentNode start="(476, 69)" end="(476, 70)" leading="" trailing=" " raw_val="P" val="P"/>
              </NullNode>
              <NullNode start="(476, 71)" end="(476, 81)">
                <AtomNode start="(476, 71)" end="(476, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(476, 73)" end="(476, 81)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(476, 73)" end="(476, 74)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(476, 75)" end="(476, 76)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(476, 77)" end="(476, 81)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(476, 77)" end="(476, 81)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(476, 81)" end="(476, 82)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(476, 83)" end="(476, 106)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(476, 83)" end="(476, 84)" leading="" trailing="" val="{"/>
              <NullNode start="(476, 84)" end="(476, 86)">
                <IdentNode start="(476, 84)" end="(476, 86)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(476, 87)" end="(476, 105)">
                <AtomNode start="(476, 87)" end="(476, 88)" leading="" trailing=" " val=":"/>
                <OtherNode start="(476, 89)" end="(476, 105)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(476, 89)" end="(476, 93)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(476, 94)" end="(476, 105)">
                    <OtherNode start="(476, 94)" end="(476, 105)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(476, 94)" end="(476, 95)" leading="" trailing="" val="("/>
                      <OtherNode start="(476, 95)" end="(476, 104)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(476, 95)" end="(476, 102)" leading="" trailing=" " raw_val="Subtype" val="Subtype" full_name="Subtype" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(476, 103)" end="(476, 104)">
                          <IdentNode start="(476, 103)" end="(476, 104)" leading="" trailing="" raw_val="P" val="P"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(476, 104)" end="(476, 105)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(476, 105)" end="(476, 106)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(476, 107)" end="(476, 124)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(476, 107)" end="(476, 108)" leading="" trailing="" val="{"/>
              <NullNode start="(476, 108)" end="(476, 109)">
                <IdentNode start="(476, 108)" end="(476, 109)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(476, 110)" end="(476, 123)">
                <AtomNode start="(476, 110)" end="(476, 111)" leading="" trailing=" " val=":"/>
                <OtherNode start="(476, 112)" end="(476, 123)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(476, 112)" end="(476, 113)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(476, 114)" end="(476, 115)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(476, 116)" end="(476, 123)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(476, 116)" end="(476, 117)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(476, 118)" end="(476, 119)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(476, 120)" end="(476, 123)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(476, 120)" end="(476, 121)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(476, 122)" end="(476, 123)">
                        <IdentNode start="(476, 122)" end="(476, 123)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(476, 123)" end="(476, 124)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(476, 125)" end="(476, 135)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(476, 125)" end="(476, 126)" leading="" trailing="" val="{"/>
              <NullNode start="(476, 126)" end="(476, 130)">
                <IdentNode start="(476, 126)" end="(476, 130)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(476, 131)" end="(476, 134)">
                <AtomNode start="(476, 131)" end="(476, 132)" leading="" trailing=" " val=":"/>
                <IdentNode start="(476, 133)" end="(476, 134)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(476, 134)" end="(476, 135)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(476, 136)" end="(479, 22)">
            <AtomNode start="(476, 136)" end="(476, 137)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(477, 5)" end="(479, 22)" kind="«term_=_»">
              <OtherNode start="(477, 5)" end="(477, 30)" kind="Lean.Parser.Term.app">
                <IdentNode start="(477, 5)" end="(477, 23)" leading="" trailing=" " raw_val="xs.unattach.foldrM" val="xs.unattach.foldrM"/>
                <NullNode start="(477, 24)" end="(477, 30)">
                  <IdentNode start="(477, 24)" end="(477, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(477, 26)" end="(477, 30)" leading="" trailing=" " raw_val="init" val="init"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(477, 31)" end="(477, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(477, 33)" end="(479, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(477, 33)" end="(477, 42)" leading="" trailing=" " raw_val="xs.foldrM" val="xs.foldrM"/>
                <NullNode start="(477, 43)" end="(479, 22)">
                  <OtherNode start="(477, 43)" end="(477, 57)" kind="Lean.Parser.Term.namedArgument">
                    <AtomNode start="(477, 43)" end="(477, 44)" leading="" trailing="" val="("/>
                    <IdentNode start="(477, 44)" end="(477, 48)" leading="" trailing=" " raw_val="init" val="init"/>
                    <AtomNode start="(477, 49)" end="(477, 51)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(477, 52)" end="(477, 56)" leading="" trailing="" raw_val="init" val="init"/>
                    <AtomNode start="(477, 56)" end="(477, 57)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(477, 58)" end="(479, 22)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(477, 58)" end="(477, 61)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(477, 62)" end="(479, 22)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(477, 62)" end="(477, 70)">
                        <OtherNode start="(477, 62)" end="(477, 68)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(477, 62)" end="(477, 63)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(477, 63)" end="(477, 67)">
                            <IdentNode start="(477, 63)" end="(477, 64)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(477, 64)" end="(477, 65)" leading="" trailing=" " val=","/>
                            <IdentNode start="(477, 66)" end="(477, 67)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(477, 67)" end="(477, 68)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                        <IdentNode start="(477, 69)" end="(477, 70)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(477, 71)" end="(477, 73)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                      <OtherNode start="(478, 7)" end="(479, 22)" kind="«term_&amp;lt;|_»">
                        <OtherNode start="(478, 7)" end="(478, 25)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(478, 7)" end="(478, 21)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                          <NullNode start="(478, 22)" end="(478, 25)">
                            <IdentNode start="(478, 22)" end="(478, 23)" leading="" trailing=" " raw_val="x" val="x"/>
                            <IdentNode start="(478, 24)" end="(478, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(478, 26)" end="(478, 28)" leading="" trailing=" " val="&amp;lt;|"/>
                        <OtherNode start="(478, 29)" end="(479, 22)" kind="«term_&amp;lt;|_»">
                          <OtherNode start="(478, 29)" end="(478, 48)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(478, 29)" end="(478, 43)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                            <NullNode start="(478, 44)" end="(478, 48)">
                              <IdentNode start="(478, 44)" end="(478, 45)" leading="" trailing=" " raw_val="h" val="h"/>
                              <OtherNode start="(478, 46)" end="(478, 48)" kind="Lean.Parser.Term.tuple">
                                <AtomNode start="(478, 46)" end="(478, 47)" leading="" trailing="" val="("/>
                                <NullNode/>
                                <AtomNode start="(478, 47)" end="(478, 48)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(478, 49)" end="(478, 51)" leading="" trailing=" " val="&amp;lt;|"/>
                          <OtherNode start="(478, 52)" end="(479, 22)" kind="«term_&amp;lt;|_»">
                            <OtherNode start="(478, 52)" end="(478, 74)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(478, 52)" end="(478, 66)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                              <NullNode start="(478, 67)" end="(478, 74)">
                                <IdentNode start="(478, 67)" end="(478, 68)" leading="" trailing=" " raw_val="b" val="b"/>
                                <OtherNode start="(478, 69)" end="(478, 74)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(478, 69)" end="(478, 70)" leading="" trailing="" val="("/>
                                  <OtherNode start="(478, 70)" end="(478, 73)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(478, 70)" end="(478, 71)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <NullNode start="(478, 72)" end="(478, 73)">
                                      <IdentNode start="(478, 72)" end="(478, 73)" leading="" trailing="" raw_val="x" val="x"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(478, 73)" end="(478, 74)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(478, 75)" end="(478, 77)" leading="" trailing="&#10;      " val="&amp;lt;|"/>
                            <OtherNode start="(479, 7)" end="(479, 22)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(479, 7)" end="(479, 8)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(479, 9)" end="(479, 22)">
                                <OtherNode start="(479, 9)" end="(479, 20)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(479, 9)" end="(479, 10)" leading="" trailing="" val="("/>
                                  <OtherNode start="(479, 10)" end="(479, 19)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(479, 10)" end="(479, 17)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                    <NullNode start="(479, 18)" end="(479, 19)">
                                      <IdentNode start="(479, 18)" end="(479, 19)" leading="" trailing="" raw_val="x" val="x"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(479, 19)" end="(479, 20)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <IdentNode start="(479, 21)" end="(479, 22)" leading="" trailing=" " raw_val="b" val="b"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(479, 23)" end="(480, 17)">
          <AtomNode start="(479, 23)" end="(479, 25)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(479, 26)" end="(480, 17)">
            <AtomNode start="(479, 26)" end="(479, 28)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(480, 3)" end="(480, 17)">
              <TacticTacticseq1IndentedNode start="(480, 3)" end="(480, 17)">
                <NullNode start="(480, 3)" end="(480, 17)">
                  <OtherNode start="(480, 3)" end="(480, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;P : α → Prop&#10;xs : List (Subtype P)&#10;f : α → β → m β&#10;init : β&#10;⊢ foldrM f init xs.unattach =&#10;    foldrM&#10;      (fun x b =&amp;gt;&#10;        match x with&#10;        | ⟨x, h⟩ =&amp;gt; binderNameHint x f (binderNameHint h () (binderNameHint b (f x) (f (wfParam x) b))))&#10;      init xs" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(480, 3)" end="(480, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(480, 8)" end="(480, 17)">
                      <AtomNode start="(480, 8)" end="(480, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(480, 9)" end="(480, 16)">
                        <OtherNode start="(480, 9)" end="(480, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(480, 9)" end="(480, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(480, 16)" end="(480, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(482, 1)" end="(493, 33)" name="mapM_subtype" full_name="List.mapM_subtype">
      <CommandDeclmodifiersNode start="(482, 1)" end="(486, 8)">
        <NullNode start="(482, 1)" end="(485, 3)">
          <CommandDoccommentNode start="(482, 1)" end="(485, 3)" comment="This lemma identifies monadic maps over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/">
            <AtomNode start="(482, 1)" end="(482, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(483, 1)" end="(485, 3)" leading="" trailing="&#10;" val="This lemma identifies monadic maps over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(486, 1)" end="(486, 8)">
          <OtherNode start="(486, 1)" end="(486, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(486, 1)" end="(486, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(486, 3)" end="(486, 7)">
              <OtherNode start="(486, 3)" end="(486, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(486, 3)" end="(486, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(486, 3)" end="(486, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(486, 7)" end="(486, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(486, 9)" end="(493, 33)" name="mapM_subtype" full_name="List.mapM_subtype" _is_private_decl="False">
        <AtomNode start="(486, 9)" end="(486, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(486, 17)" end="(486, 29)">
          <IdentNode start="(486, 17)" end="(486, 29)" leading="" trailing=" " raw_val="mapM_subtype" val="mapM_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(486, 30)" end="(488, 33)">
          <NullNode start="(486, 30)" end="(487, 72)">
            <OtherNode start="(486, 30)" end="(486, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(486, 30)" end="(486, 31)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(486, 31)" end="(486, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(486, 31)" end="(486, 36)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(486, 37)" end="(486, 38)">
                  <IdentNode start="(486, 37)" end="(486, 38)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(486, 38)" end="(486, 39)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(486, 40)" end="(486, 55)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(486, 40)" end="(486, 41)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(486, 41)" end="(486, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(486, 41)" end="(486, 52)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(486, 53)" end="(486, 54)">
                  <IdentNode start="(486, 53)" end="(486, 54)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(486, 54)" end="(486, 55)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(486, 56)" end="(486, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(486, 56)" end="(486, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(486, 57)" end="(486, 58)">
                <IdentNode start="(486, 57)" end="(486, 58)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(486, 59)" end="(486, 69)">
                <AtomNode start="(486, 59)" end="(486, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(486, 61)" end="(486, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(486, 61)" end="(486, 62)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(486, 63)" end="(486, 64)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(486, 65)" end="(486, 69)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(486, 65)" end="(486, 69)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(486, 69)" end="(486, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(486, 71)" end="(486, 94)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(486, 71)" end="(486, 72)" leading="" trailing="" val="{"/>
              <NullNode start="(486, 72)" end="(486, 73)">
                <IdentNode start="(486, 72)" end="(486, 73)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(486, 74)" end="(486, 93)">
                <AtomNode start="(486, 74)" end="(486, 75)" leading="" trailing=" " val=":"/>
                <OtherNode start="(486, 76)" end="(486, 93)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(486, 76)" end="(486, 80)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(486, 81)" end="(486, 93)">
                    <OtherNode start="(486, 81)" end="(486, 93)" kind="«term{_:_//_}»">
                      <AtomNode start="(486, 81)" end="(486, 82)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(486, 83)" end="(486, 84)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(486, 85)" end="(486, 87)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(486, 88)" end="(486, 91)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(486, 88)" end="(486, 89)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(486, 90)" end="(486, 91)">
                          <IdentNode start="(486, 90)" end="(486, 91)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(486, 92)" end="(486, 93)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(486, 93)" end="(486, 94)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(487, 5)" end="(487, 29)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(487, 5)" end="(487, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(487, 6)" end="(487, 7)">
                <IdentNode start="(487, 6)" end="(487, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(487, 8)" end="(487, 28)">
                <AtomNode start="(487, 8)" end="(487, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(487, 10)" end="(487, 28)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(487, 10)" end="(487, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(487, 10)" end="(487, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(487, 12)" end="(487, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(487, 14)" end="(487, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(487, 17)" end="(487, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(487, 17)" end="(487, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(487, 19)" end="(487, 20)">
                        <IdentNode start="(487, 19)" end="(487, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(487, 21)" end="(487, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(487, 23)" end="(487, 24)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(487, 25)" end="(487, 28)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(487, 25)" end="(487, 26)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(487, 27)" end="(487, 28)">
                      <IdentNode start="(487, 27)" end="(487, 28)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(487, 28)" end="(487, 29)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(487, 30)" end="(487, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(487, 30)" end="(487, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(487, 31)" end="(487, 32)">
                <IdentNode start="(487, 31)" end="(487, 32)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(487, 33)" end="(487, 42)">
                <AtomNode start="(487, 33)" end="(487, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(487, 35)" end="(487, 42)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(487, 35)" end="(487, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(487, 37)" end="(487, 38)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(487, 39)" end="(487, 42)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(487, 39)" end="(487, 40)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(487, 41)" end="(487, 42)">
                      <IdentNode start="(487, 41)" end="(487, 42)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(487, 42)" end="(487, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(487, 44)" end="(487, 72)">
              <AtomNode start="(487, 44)" end="(487, 45)" leading="" trailing="" val="("/>
              <NullNode start="(487, 45)" end="(487, 47)">
                <IdentNode start="(487, 45)" end="(487, 47)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(487, 48)" end="(487, 71)">
                <AtomNode start="(487, 48)" end="(487, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(487, 50)" end="(487, 71)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(487, 50)" end="(487, 51)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(487, 52)" end="(487, 55)">
                    <IdentNode start="(487, 52)" end="(487, 53)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(487, 54)" end="(487, 55)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(487, 55)" end="(487, 56)" leading="" trailing=" " val=","/>
                  <OtherNode start="(487, 57)" end="(487, 71)" kind="«term_=_»">
                    <OtherNode start="(487, 57)" end="(487, 65)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(487, 57)" end="(487, 58)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(487, 59)" end="(487, 65)">
                        <OtherNode start="(487, 59)" end="(487, 65)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(487, 59)" end="(487, 60)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(487, 60)" end="(487, 64)">
                            <IdentNode start="(487, 60)" end="(487, 61)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(487, 61)" end="(487, 62)" leading="" trailing=" " val=","/>
                            <IdentNode start="(487, 63)" end="(487, 64)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(487, 64)" end="(487, 65)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(487, 66)" end="(487, 67)" leading="" trailing=" " val="="/>
                    <OtherNode start="(487, 68)" end="(487, 71)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(487, 68)" end="(487, 69)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(487, 70)" end="(487, 71)">
                        <IdentNode start="(487, 70)" end="(487, 71)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(487, 71)" end="(487, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(487, 73)" end="(488, 33)">
            <AtomNode start="(487, 73)" end="(487, 74)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(488, 5)" end="(488, 33)" kind="«term_=_»">
              <OtherNode start="(488, 5)" end="(488, 13)" kind="Lean.Parser.Term.app">
                <IdentNode start="(488, 5)" end="(488, 11)" leading="" trailing=" " raw_val="l.mapM" val="l.mapM"/>
                <NullNode start="(488, 12)" end="(488, 13)">
                  <IdentNode start="(488, 12)" end="(488, 13)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(488, 14)" end="(488, 15)" leading="" trailing=" " val="="/>
              <OtherNode start="(488, 16)" end="(488, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(488, 16)" end="(488, 31)" leading="" trailing=" " raw_val="l.unattach.mapM" val="l.unattach.mapM"/>
                <NullNode start="(488, 32)" end="(488, 33)">
                  <IdentNode start="(488, 32)" end="(488, 33)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(488, 34)" end="(493, 33)">
          <AtomNode start="(488, 34)" end="(488, 36)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(488, 37)" end="(493, 33)">
            <AtomNode start="(488, 37)" end="(488, 39)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(489, 3)" end="(493, 33)">
              <TacticTacticseq1IndentedNode start="(489, 3)" end="(493, 33)">
                <NullNode start="(489, 3)" end="(493, 33)">
                  <OtherNode start="(489, 3)" end="(489, 18)" kind="Lean.Parser.Tactic.unfold" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → m β&#10;g : α → m β&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ mapM f l = mapM g l.unattach" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → m β&#10;g : α → m β&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ mapM f l = mapM g (map (fun x =&amp;gt; x.val) l)" tactic="unfold unattach">
                    <AtomNode start="(489, 3)" end="(489, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(489, 10)" end="(489, 18)">
                      <IdentNode start="(489, 10)" end="(489, 18)" leading="" trailing="&#10;  " raw_val="unattach" val="unattach" full_name="List.unattach" mod_name="Init.Data.List.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Attach.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(490, 3)" end="(490, 30)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → m β&#10;g : α → m β&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ mapM f l = mapM g (map (fun x =&amp;gt; x.val) l)" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → m β&#10;g : α → m β&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ mapM' f l = mapM' g l.unattach" tactic="simp [← List.mapM'_eq_mapM]">
                    <AtomNode start="(490, 3)" end="(490, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(490, 8)" end="(490, 30)">
                      <AtomNode start="(490, 8)" end="(490, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(490, 9)" end="(490, 29)">
                        <OtherNode start="(490, 9)" end="(490, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(490, 9)" end="(490, 10)">
                            <OtherNode start="(490, 9)" end="(490, 10)" kind="patternIgnore">
                              <OtherNode start="(490, 9)" end="(490, 10)" kind="token.«← »">
                                <AtomNode start="(490, 9)" end="(490, 10)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(490, 11)" end="(490, 29)" leading="" trailing="" raw_val="List.mapM'_eq_mapM" val="List.mapM'_eq_mapM" full_name="List.mapM'_eq_mapM" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(53, 9)" def_end="(53, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(490, 29)" end="(490, 30)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(491, 3)" end="(493, 33)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → m β&#10;g : α → m β&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ mapM' f l = mapM' g l.unattach" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt; simp [ih, hf]">
                    <AtomNode start="(491, 3)" end="(491, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(491, 13)" end="(491, 14)">
                      <OtherNode start="(491, 13)" end="(491, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(491, 13)" end="(491, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(491, 15)" end="(493, 33)">
                      <OtherNode start="(491, 15)" end="(493, 33)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(491, 15)" end="(491, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(492, 3)" end="(493, 33)">
                          <OtherNode start="(492, 3)" end="(492, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(492, 3)" end="(492, 8)">
                              <OtherNode start="(492, 3)" end="(492, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(492, 3)" end="(492, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(492, 5)" end="(492, 8)">
                                  <NullNode/>
                                  <IdentNode start="(492, 5)" end="(492, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(492, 9)" end="(492, 16)">
                              <AtomNode start="(492, 9)" end="(492, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(492, 12)" end="(492, 16)">
                                <TacticTacticseq1IndentedNode start="(492, 12)" end="(492, 16)">
                                  <NullNode start="(492, 12)" end="(492, 16)">
                                    <OtherNode start="(492, 12)" end="(492, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m β&#10;g : α → m β&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ mapM' f [] = mapM' g [].unattach" state_after="no goals" tactic="simp">
                                      <AtomNode start="(492, 12)" end="(492, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(493, 3)" end="(493, 33)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(493, 3)" end="(493, 16)">
                              <OtherNode start="(493, 3)" end="(493, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(493, 3)" end="(493, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(493, 5)" end="(493, 9)">
                                  <NullNode/>
                                  <IdentNode start="(493, 5)" end="(493, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(493, 10)" end="(493, 16)">
                                  <IdentNode start="(493, 10)" end="(493, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(493, 12)" end="(493, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(493, 14)" end="(493, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(493, 17)" end="(493, 33)">
                              <AtomNode start="(493, 17)" end="(493, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(493, 20)" end="(493, 33)">
                                <TacticTacticseq1IndentedNode start="(493, 20)" end="(493, 33)">
                                  <NullNode start="(493, 20)" end="(493, 33)">
                                    <OtherNode start="(493, 20)" end="(493, 33)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m β&#10;g : α → m β&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : mapM' f l = mapM' g l.unattach&#10;⊢ mapM' f (a :: l) = mapM' g (a :: l).unattach" state_after="no goals" tactic="simp [ih, hf]">
                                      <AtomNode start="(493, 20)" end="(493, 24)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(493, 25)" end="(493, 33)">
                                        <AtomNode start="(493, 25)" end="(493, 26)" leading="" trailing="" val="["/>
                                        <NullNode start="(493, 26)" end="(493, 32)">
                                          <OtherNode start="(493, 26)" end="(493, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(493, 26)" end="(493, 28)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(493, 28)" end="(493, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(493, 30)" end="(493, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(493, 30)" end="(493, 32)" leading="" trailing="" raw_val="hf" val="hf"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(493, 32)" end="(493, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(495, 1)" end="(497, 17)" name="mapM_wfParam" full_name="List.mapM_wfParam">
      <CommandDeclmodifiersNode start="(495, 1)" end="(495, 17)">
        <NullNode/>
        <NullNode start="(495, 1)" end="(495, 17)">
          <OtherNode start="(495, 1)" end="(495, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(495, 1)" end="(495, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(495, 3)" end="(495, 16)">
              <OtherNode start="(495, 3)" end="(495, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(495, 3)" end="(495, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(495, 3)" end="(495, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(495, 16)" end="(495, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(495, 18)" end="(497, 17)" name="mapM_wfParam" full_name="List.mapM_wfParam" _is_private_decl="False">
        <AtomNode start="(495, 18)" end="(495, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(495, 26)" end="(495, 38)">
          <IdentNode start="(495, 26)" end="(495, 38)" leading="" trailing=" " raw_val="mapM_wfParam" val="mapM_wfParam"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(495, 39)" end="(496, 52)">
          <NullNode start="(495, 39)" end="(495, 92)">
            <OtherNode start="(495, 39)" end="(495, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(495, 39)" end="(495, 40)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(495, 40)" end="(495, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(495, 40)" end="(495, 45)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(495, 46)" end="(495, 47)">
                  <IdentNode start="(495, 46)" end="(495, 47)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(495, 47)" end="(495, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(495, 49)" end="(495, 64)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(495, 49)" end="(495, 50)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(495, 50)" end="(495, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(495, 50)" end="(495, 61)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(495, 62)" end="(495, 63)">
                  <IdentNode start="(495, 62)" end="(495, 63)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(495, 63)" end="(495, 64)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(495, 65)" end="(495, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(495, 65)" end="(495, 66)" leading="" trailing="" val="{"/>
              <NullNode start="(495, 66)" end="(495, 68)">
                <IdentNode start="(495, 66)" end="(495, 68)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(495, 69)" end="(495, 77)">
                <AtomNode start="(495, 69)" end="(495, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(495, 71)" end="(495, 77)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(495, 71)" end="(495, 75)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(495, 76)" end="(495, 77)">
                    <IdentNode start="(495, 76)" end="(495, 77)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(495, 77)" end="(495, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(495, 79)" end="(495, 92)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(495, 79)" end="(495, 80)" leading="" trailing="" val="{"/>
              <NullNode start="(495, 80)" end="(495, 81)">
                <IdentNode start="(495, 80)" end="(495, 81)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(495, 82)" end="(495, 91)">
                <AtomNode start="(495, 82)" end="(495, 83)" leading="" trailing=" " val=":"/>
                <OtherNode start="(495, 84)" end="(495, 91)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(495, 84)" end="(495, 85)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(495, 86)" end="(495, 87)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(495, 88)" end="(495, 91)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(495, 88)" end="(495, 89)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(495, 90)" end="(495, 91)">
                      <IdentNode start="(495, 90)" end="(495, 91)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(495, 91)" end="(495, 92)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(495, 93)" end="(496, 52)">
            <AtomNode start="(495, 93)" end="(495, 94)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(496, 5)" end="(496, 52)" kind="«term_=_»">
              <OtherNode start="(496, 5)" end="(496, 24)" kind="Lean.Parser.Term.app">
                <OtherNode start="(496, 5)" end="(496, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(496, 5)" end="(496, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(496, 5)" end="(496, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(496, 6)" end="(496, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(496, 6)" end="(496, 13)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                      <NullNode start="(496, 14)" end="(496, 16)">
                        <IdentNode start="(496, 14)" end="(496, 16)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(496, 16)" end="(496, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(496, 17)" end="(496, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(496, 18)" end="(496, 22)" leading="" trailing=" " raw_val="mapM" val="mapM" full_name="List.mapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(496, 23)" end="(496, 24)">
                  <IdentNode start="(496, 23)" end="(496, 24)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(496, 25)" end="(496, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(496, 27)" end="(496, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(496, 27)" end="(496, 50)" leading="" trailing=" " raw_val="xs.attach.unattach.mapM" val="xs.attach.unattach.mapM"/>
                <NullNode start="(496, 51)" end="(496, 52)">
                  <IdentNode start="(496, 51)" end="(496, 52)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(496, 53)" end="(497, 17)">
          <AtomNode start="(496, 53)" end="(496, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(496, 56)" end="(497, 17)">
            <AtomNode start="(496, 56)" end="(496, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(497, 3)" end="(497, 17)">
              <TacticTacticseq1IndentedNode start="(497, 3)" end="(497, 17)">
                <NullNode start="(497, 3)" end="(497, 17)">
                  <OtherNode start="(497, 3)" end="(497, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : List α&#10;f : α → m β&#10;⊢ mapM f (wfParam xs) = mapM f xs.attach.unattach" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(497, 3)" end="(497, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(497, 8)" end="(497, 17)">
                      <AtomNode start="(497, 8)" end="(497, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(497, 9)" end="(497, 16)">
                        <OtherNode start="(497, 9)" end="(497, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(497, 9)" end="(497, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(497, 16)" end="(497, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(499, 1)" end="(502, 17)" name="mapM_unattach" full_name="List.mapM_unattach">
      <CommandDeclmodifiersNode start="(499, 1)" end="(499, 17)">
        <NullNode/>
        <NullNode start="(499, 1)" end="(499, 17)">
          <OtherNode start="(499, 1)" end="(499, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(499, 1)" end="(499, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(499, 3)" end="(499, 16)">
              <OtherNode start="(499, 3)" end="(499, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(499, 3)" end="(499, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(499, 3)" end="(499, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(499, 16)" end="(499, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(499, 18)" end="(502, 17)" name="mapM_unattach" full_name="List.mapM_unattach" _is_private_decl="False">
        <AtomNode start="(499, 18)" end="(499, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(499, 26)" end="(499, 39)">
          <IdentNode start="(499, 26)" end="(499, 39)" leading="" trailing=" " raw_val="mapM_unattach" val="mapM_unattach"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(499, 40)" end="(501, 65)">
          <NullNode start="(499, 40)" end="(499, 118)">
            <OtherNode start="(499, 40)" end="(499, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(499, 40)" end="(499, 41)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(499, 41)" end="(499, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(499, 41)" end="(499, 46)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(499, 47)" end="(499, 48)">
                  <IdentNode start="(499, 47)" end="(499, 48)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(499, 48)" end="(499, 49)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(499, 50)" end="(499, 65)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(499, 50)" end="(499, 51)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(499, 51)" end="(499, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(499, 51)" end="(499, 62)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(499, 63)" end="(499, 64)">
                  <IdentNode start="(499, 63)" end="(499, 64)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(499, 64)" end="(499, 65)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(499, 66)" end="(499, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(499, 66)" end="(499, 67)" leading="" trailing="" val="{"/>
              <NullNode start="(499, 67)" end="(499, 68)">
                <IdentNode start="(499, 67)" end="(499, 68)" leading="" trailing=" " raw_val="P" val="P"/>
              </NullNode>
              <NullNode start="(499, 69)" end="(499, 79)">
                <AtomNode start="(499, 69)" end="(499, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(499, 71)" end="(499, 79)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(499, 71)" end="(499, 72)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(499, 73)" end="(499, 74)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(499, 75)" end="(499, 79)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(499, 75)" end="(499, 79)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(499, 79)" end="(499, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(499, 81)" end="(499, 104)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(499, 81)" end="(499, 82)" leading="" trailing="" val="{"/>
              <NullNode start="(499, 82)" end="(499, 84)">
                <IdentNode start="(499, 82)" end="(499, 84)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(499, 85)" end="(499, 103)">
                <AtomNode start="(499, 85)" end="(499, 86)" leading="" trailing=" " val=":"/>
                <OtherNode start="(499, 87)" end="(499, 103)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(499, 87)" end="(499, 91)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(499, 92)" end="(499, 103)">
                    <OtherNode start="(499, 92)" end="(499, 103)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(499, 92)" end="(499, 93)" leading="" trailing="" val="("/>
                      <OtherNode start="(499, 93)" end="(499, 102)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(499, 93)" end="(499, 100)" leading="" trailing=" " raw_val="Subtype" val="Subtype" full_name="Subtype" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(499, 101)" end="(499, 102)">
                          <IdentNode start="(499, 101)" end="(499, 102)" leading="" trailing="" raw_val="P" val="P"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(499, 102)" end="(499, 103)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(499, 103)" end="(499, 104)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(499, 105)" end="(499, 118)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(499, 105)" end="(499, 106)" leading="" trailing="" val="{"/>
              <NullNode start="(499, 106)" end="(499, 107)">
                <IdentNode start="(499, 106)" end="(499, 107)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(499, 108)" end="(499, 117)">
                <AtomNode start="(499, 108)" end="(499, 109)" leading="" trailing=" " val=":"/>
                <OtherNode start="(499, 110)" end="(499, 117)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(499, 110)" end="(499, 111)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(499, 112)" end="(499, 113)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(499, 114)" end="(499, 117)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(499, 114)" end="(499, 115)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(499, 116)" end="(499, 117)">
                      <IdentNode start="(499, 116)" end="(499, 117)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(499, 117)" end="(499, 118)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(499, 119)" end="(501, 65)">
            <AtomNode start="(499, 119)" end="(499, 120)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(500, 5)" end="(501, 65)" kind="«term_=_»">
              <OtherNode start="(500, 5)" end="(500, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(500, 5)" end="(500, 21)" leading="" trailing=" " raw_val="xs.unattach.mapM" val="xs.unattach.mapM"/>
                <NullNode start="(500, 22)" end="(500, 23)">
                  <IdentNode start="(500, 22)" end="(500, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(500, 24)" end="(500, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(500, 26)" end="(501, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(500, 26)" end="(500, 33)" leading="" trailing=" " raw_val="xs.mapM" val="xs.mapM"/>
                <NullNode start="(500, 34)" end="(501, 65)">
                  <OtherNode start="(500, 34)" end="(501, 65)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(500, 34)" end="(500, 37)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(500, 38)" end="(501, 65)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(500, 38)" end="(500, 44)">
                        <OtherNode start="(500, 38)" end="(500, 44)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(500, 38)" end="(500, 39)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(500, 39)" end="(500, 43)">
                            <IdentNode start="(500, 39)" end="(500, 40)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(500, 40)" end="(500, 41)" leading="" trailing=" " val=","/>
                            <IdentNode start="(500, 42)" end="(500, 43)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(500, 43)" end="(500, 44)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(500, 45)" end="(500, 47)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                      <OtherNode start="(501, 7)" end="(501, 65)" kind="«term_&amp;lt;|_»">
                        <OtherNode start="(501, 7)" end="(501, 25)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(501, 7)" end="(501, 21)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                          <NullNode start="(501, 22)" end="(501, 25)">
                            <IdentNode start="(501, 22)" end="(501, 23)" leading="" trailing=" " raw_val="x" val="x"/>
                            <IdentNode start="(501, 24)" end="(501, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(501, 26)" end="(501, 28)" leading="" trailing=" " val="&amp;lt;|"/>
                        <OtherNode start="(501, 29)" end="(501, 65)" kind="«term_&amp;lt;|_»">
                          <OtherNode start="(501, 29)" end="(501, 48)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(501, 29)" end="(501, 43)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                            <NullNode start="(501, 44)" end="(501, 48)">
                              <IdentNode start="(501, 44)" end="(501, 45)" leading="" trailing=" " raw_val="h" val="h"/>
                              <OtherNode start="(501, 46)" end="(501, 48)" kind="Lean.Parser.Term.tuple">
                                <AtomNode start="(501, 46)" end="(501, 47)" leading="" trailing="" val="("/>
                                <NullNode/>
                                <AtomNode start="(501, 47)" end="(501, 48)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(501, 49)" end="(501, 51)" leading="" trailing=" " val="&amp;lt;|"/>
                          <OtherNode start="(501, 52)" end="(501, 65)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(501, 52)" end="(501, 53)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(501, 54)" end="(501, 65)">
                              <OtherNode start="(501, 54)" end="(501, 65)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(501, 54)" end="(501, 55)" leading="" trailing="" val="("/>
                                <OtherNode start="(501, 55)" end="(501, 64)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(501, 55)" end="(501, 62)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                  <NullNode start="(501, 63)" end="(501, 64)">
                                    <IdentNode start="(501, 63)" end="(501, 64)" leading="" trailing="" raw_val="x" val="x"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(501, 64)" end="(501, 65)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(501, 66)" end="(502, 17)">
          <AtomNode start="(501, 66)" end="(501, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(501, 69)" end="(502, 17)">
            <AtomNode start="(501, 69)" end="(501, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(502, 3)" end="(502, 17)">
              <TacticTacticseq1IndentedNode start="(502, 3)" end="(502, 17)">
                <NullNode start="(502, 3)" end="(502, 17)">
                  <OtherNode start="(502, 3)" end="(502, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;P : α → Prop&#10;xs : List (Subtype P)&#10;f : α → m β&#10;⊢ mapM f xs.unattach =&#10;    mapM&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | ⟨x, h⟩ =&amp;gt; binderNameHint x f (binderNameHint h () (f (wfParam x))))&#10;      xs" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(502, 3)" end="(502, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(502, 8)" end="(502, 17)">
                      <AtomNode start="(502, 8)" end="(502, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(502, 9)" end="(502, 16)">
                        <OtherNode start="(502, 9)" end="(502, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(502, 9)" end="(502, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(502, 16)" end="(502, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(504, 1)" end="(510, 50)" name="filterMapM_subtype" full_name="List.filterMapM_subtype">
      <CommandDeclmodifiersNode start="(504, 1)" end="(504, 8)">
        <NullNode/>
        <NullNode start="(504, 1)" end="(504, 8)">
          <OtherNode start="(504, 1)" end="(504, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(504, 1)" end="(504, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(504, 3)" end="(504, 7)">
              <OtherNode start="(504, 3)" end="(504, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(504, 3)" end="(504, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(504, 3)" end="(504, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(504, 7)" end="(504, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(504, 9)" end="(510, 50)" name="filterMapM_subtype" full_name="List.filterMapM_subtype" _is_private_decl="False">
        <AtomNode start="(504, 9)" end="(504, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(504, 17)" end="(504, 35)">
          <IdentNode start="(504, 17)" end="(504, 35)" leading="" trailing=" " raw_val="filterMapM_subtype" val="filterMapM_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(504, 36)" end="(506, 45)">
          <NullNode start="(504, 36)" end="(505, 90)">
            <OtherNode start="(504, 36)" end="(504, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(504, 36)" end="(504, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(504, 37)" end="(504, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(504, 37)" end="(504, 42)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(504, 43)" end="(504, 44)">
                  <IdentNode start="(504, 43)" end="(504, 44)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(504, 44)" end="(504, 45)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(504, 46)" end="(504, 61)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(504, 46)" end="(504, 47)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(504, 47)" end="(504, 60)" kind="Lean.Parser.Term.app">
                <IdentNode start="(504, 47)" end="(504, 58)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(504, 59)" end="(504, 60)">
                  <IdentNode start="(504, 59)" end="(504, 60)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(504, 60)" end="(504, 61)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(504, 62)" end="(504, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(504, 62)" end="(504, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(504, 63)" end="(504, 64)">
                <IdentNode start="(504, 63)" end="(504, 64)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(504, 65)" end="(504, 75)">
                <AtomNode start="(504, 65)" end="(504, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(504, 67)" end="(504, 75)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(504, 67)" end="(504, 68)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(504, 69)" end="(504, 70)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(504, 71)" end="(504, 75)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(504, 71)" end="(504, 75)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(504, 75)" end="(504, 76)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(504, 77)" end="(504, 100)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(504, 77)" end="(504, 78)" leading="" trailing="" val="{"/>
              <NullNode start="(504, 78)" end="(504, 79)">
                <IdentNode start="(504, 78)" end="(504, 79)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(504, 80)" end="(504, 99)">
                <AtomNode start="(504, 80)" end="(504, 81)" leading="" trailing=" " val=":"/>
                <OtherNode start="(504, 82)" end="(504, 99)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(504, 82)" end="(504, 86)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(504, 87)" end="(504, 99)">
                    <OtherNode start="(504, 87)" end="(504, 99)" kind="«term{_:_//_}»">
                      <AtomNode start="(504, 87)" end="(504, 88)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(504, 89)" end="(504, 90)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(504, 91)" end="(504, 93)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(504, 94)" end="(504, 97)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(504, 94)" end="(504, 95)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(504, 96)" end="(504, 97)">
                          <IdentNode start="(504, 96)" end="(504, 97)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(504, 98)" end="(504, 99)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(504, 99)" end="(504, 100)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(505, 5)" end="(505, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(505, 5)" end="(505, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(505, 6)" end="(505, 7)">
                <IdentNode start="(505, 6)" end="(505, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(505, 8)" end="(505, 37)">
                <AtomNode start="(505, 8)" end="(505, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(505, 10)" end="(505, 37)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(505, 10)" end="(505, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(505, 10)" end="(505, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(505, 12)" end="(505, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(505, 14)" end="(505, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(505, 17)" end="(505, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(505, 17)" end="(505, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(505, 19)" end="(505, 20)">
                        <IdentNode start="(505, 19)" end="(505, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(505, 21)" end="(505, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(505, 23)" end="(505, 24)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(505, 25)" end="(505, 37)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(505, 25)" end="(505, 26)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(505, 27)" end="(505, 37)">
                      <OtherNode start="(505, 27)" end="(505, 37)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(505, 27)" end="(505, 28)" leading="" trailing="" val="("/>
                        <OtherNode start="(505, 28)" end="(505, 36)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(505, 28)" end="(505, 34)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(505, 35)" end="(505, 36)">
                            <IdentNode start="(505, 35)" end="(505, 36)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(505, 36)" end="(505, 37)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(505, 37)" end="(505, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(505, 39)" end="(505, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(505, 39)" end="(505, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(505, 40)" end="(505, 41)">
                <IdentNode start="(505, 40)" end="(505, 41)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(505, 42)" end="(505, 60)">
                <AtomNode start="(505, 42)" end="(505, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(505, 44)" end="(505, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(505, 44)" end="(505, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(505, 46)" end="(505, 47)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(505, 48)" end="(505, 60)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(505, 48)" end="(505, 49)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(505, 50)" end="(505, 60)">
                      <OtherNode start="(505, 50)" end="(505, 60)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(505, 50)" end="(505, 51)" leading="" trailing="" val="("/>
                        <OtherNode start="(505, 51)" end="(505, 59)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(505, 51)" end="(505, 57)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(505, 58)" end="(505, 59)">
                            <IdentNode start="(505, 58)" end="(505, 59)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(505, 59)" end="(505, 60)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(505, 60)" end="(505, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(505, 62)" end="(505, 90)">
              <AtomNode start="(505, 62)" end="(505, 63)" leading="" trailing="" val="("/>
              <NullNode start="(505, 63)" end="(505, 65)">
                <IdentNode start="(505, 63)" end="(505, 65)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(505, 66)" end="(505, 89)">
                <AtomNode start="(505, 66)" end="(505, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(505, 68)" end="(505, 89)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(505, 68)" end="(505, 69)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(505, 70)" end="(505, 73)">
                    <IdentNode start="(505, 70)" end="(505, 71)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(505, 72)" end="(505, 73)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(505, 73)" end="(505, 74)" leading="" trailing=" " val=","/>
                  <OtherNode start="(505, 75)" end="(505, 89)" kind="«term_=_»">
                    <OtherNode start="(505, 75)" end="(505, 83)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(505, 75)" end="(505, 76)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(505, 77)" end="(505, 83)">
                        <OtherNode start="(505, 77)" end="(505, 83)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(505, 77)" end="(505, 78)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(505, 78)" end="(505, 82)">
                            <IdentNode start="(505, 78)" end="(505, 79)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(505, 79)" end="(505, 80)" leading="" trailing=" " val=","/>
                            <IdentNode start="(505, 81)" end="(505, 82)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(505, 82)" end="(505, 83)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(505, 84)" end="(505, 85)" leading="" trailing=" " val="="/>
                    <OtherNode start="(505, 86)" end="(505, 89)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(505, 86)" end="(505, 87)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(505, 88)" end="(505, 89)">
                        <IdentNode start="(505, 88)" end="(505, 89)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(505, 89)" end="(505, 90)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(505, 91)" end="(506, 45)">
            <AtomNode start="(505, 91)" end="(505, 92)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(506, 5)" end="(506, 45)" kind="«term_=_»">
              <OtherNode start="(506, 5)" end="(506, 19)" kind="Lean.Parser.Term.app">
                <IdentNode start="(506, 5)" end="(506, 17)" leading="" trailing=" " raw_val="l.filterMapM" val="l.filterMapM"/>
                <NullNode start="(506, 18)" end="(506, 19)">
                  <IdentNode start="(506, 18)" end="(506, 19)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(506, 20)" end="(506, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(506, 22)" end="(506, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(506, 22)" end="(506, 43)" leading="" trailing=" " raw_val="l.unattach.filterMapM" val="l.unattach.filterMapM"/>
                <NullNode start="(506, 44)" end="(506, 45)">
                  <IdentNode start="(506, 44)" end="(506, 45)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(506, 46)" end="(510, 50)">
          <AtomNode start="(506, 46)" end="(506, 48)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(506, 49)" end="(510, 50)">
            <AtomNode start="(506, 49)" end="(506, 51)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(507, 3)" end="(510, 50)">
              <TacticTacticseq1IndentedNode start="(507, 3)" end="(510, 50)">
                <NullNode start="(507, 3)" end="(510, 50)">
                  <OtherNode start="(507, 3)" end="(507, 18)" kind="Lean.Parser.Tactic.unfold" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → m (Option β)&#10;g : α → m (Option β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ filterMapM f l = filterMapM g l.unattach" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → m (Option β)&#10;g : α → m (Option β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ filterMapM f l = filterMapM g (map (fun x =&amp;gt; x.val) l)" tactic="unfold unattach">
                    <AtomNode start="(507, 3)" end="(507, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(507, 10)" end="(507, 18)">
                      <IdentNode start="(507, 10)" end="(507, 18)" leading="" trailing="&#10;  " raw_val="unattach" val="unattach" full_name="List.unattach" mod_name="Init.Data.List.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Attach.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(508, 3)" end="(510, 50)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → m (Option β)&#10;g : α → m (Option β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ filterMapM f l = filterMapM g (map (fun x =&amp;gt; x.val) l)" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt; simp [ih, hf, filterMapM_cons]">
                    <AtomNode start="(508, 3)" end="(508, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(508, 13)" end="(508, 14)">
                      <OtherNode start="(508, 13)" end="(508, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(508, 13)" end="(508, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(508, 15)" end="(510, 50)">
                      <OtherNode start="(508, 15)" end="(510, 50)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(508, 15)" end="(508, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(509, 3)" end="(510, 50)">
                          <OtherNode start="(509, 3)" end="(509, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(509, 3)" end="(509, 8)">
                              <OtherNode start="(509, 3)" end="(509, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(509, 3)" end="(509, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(509, 5)" end="(509, 8)">
                                  <NullNode/>
                                  <IdentNode start="(509, 5)" end="(509, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(509, 9)" end="(509, 16)">
                              <AtomNode start="(509, 9)" end="(509, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(509, 12)" end="(509, 16)">
                                <TacticTacticseq1IndentedNode start="(509, 12)" end="(509, 16)">
                                  <NullNode start="(509, 12)" end="(509, 16)">
                                    <OtherNode start="(509, 12)" end="(509, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m (Option β)&#10;g : α → m (Option β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ filterMapM f [] = filterMapM g (map (fun x =&amp;gt; x.val) [])" state_after="no goals" tactic="simp">
                                      <AtomNode start="(509, 12)" end="(509, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(510, 3)" end="(510, 50)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(510, 3)" end="(510, 16)">
                              <OtherNode start="(510, 3)" end="(510, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(510, 3)" end="(510, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(510, 5)" end="(510, 9)">
                                  <NullNode/>
                                  <IdentNode start="(510, 5)" end="(510, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(510, 10)" end="(510, 16)">
                                  <IdentNode start="(510, 10)" end="(510, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(510, 12)" end="(510, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(510, 14)" end="(510, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(510, 17)" end="(510, 50)">
                              <AtomNode start="(510, 17)" end="(510, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(510, 20)" end="(510, 50)">
                                <TacticTacticseq1IndentedNode start="(510, 20)" end="(510, 50)">
                                  <NullNode start="(510, 20)" end="(510, 50)">
                                    <OtherNode start="(510, 20)" end="(510, 50)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m (Option β)&#10;g : α → m (Option β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : filterMapM f l = filterMapM g (map (fun x =&amp;gt; x.val) l)&#10;⊢ filterMapM f (a :: l) = filterMapM g (map (fun x =&amp;gt; x.val) (a :: l))" state_after="no goals" tactic="simp [ih, hf, filterMapM_cons]">
                                      <AtomNode start="(510, 20)" end="(510, 24)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(510, 25)" end="(510, 50)">
                                        <AtomNode start="(510, 25)" end="(510, 26)" leading="" trailing="" val="["/>
                                        <NullNode start="(510, 26)" end="(510, 49)">
                                          <OtherNode start="(510, 26)" end="(510, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(510, 26)" end="(510, 28)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(510, 28)" end="(510, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(510, 30)" end="(510, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(510, 30)" end="(510, 32)" leading="" trailing="" raw_val="hf" val="hf"/>
                                          </OtherNode>
                                          <AtomNode start="(510, 32)" end="(510, 33)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(510, 34)" end="(510, 49)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(510, 34)" end="(510, 49)" leading="" trailing="" raw_val="filterMapM_cons" val="filterMapM_cons" full_name="List.filterMapM_cons" mod_name="Init.Data.List.Monadic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Monadic.lean" def_start="(112, 17)" def_end="(112, 32)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(510, 49)" end="(510, 50)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(512, 1)" end="(515, 17)" name="filterMapM_wfParam" full_name="List.filterMapM_wfParam">
      <CommandDeclmodifiersNode start="(512, 1)" end="(512, 17)">
        <NullNode/>
        <NullNode start="(512, 1)" end="(512, 17)">
          <OtherNode start="(512, 1)" end="(512, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(512, 1)" end="(512, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(512, 3)" end="(512, 16)">
              <OtherNode start="(512, 3)" end="(512, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(512, 3)" end="(512, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(512, 3)" end="(512, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(512, 16)" end="(512, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(512, 18)" end="(515, 17)" name="filterMapM_wfParam" full_name="List.filterMapM_wfParam" _is_private_decl="False">
        <AtomNode start="(512, 18)" end="(512, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(512, 26)" end="(512, 44)">
          <IdentNode start="(512, 26)" end="(512, 44)" leading="" trailing=" " raw_val="filterMapM_wfParam" val="filterMapM_wfParam"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(512, 45)" end="(514, 64)">
          <NullNode start="(512, 45)" end="(513, 41)">
            <OtherNode start="(512, 45)" end="(512, 54)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(512, 45)" end="(512, 46)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(512, 46)" end="(512, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(512, 46)" end="(512, 51)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(512, 52)" end="(512, 53)">
                  <IdentNode start="(512, 52)" end="(512, 53)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(512, 53)" end="(512, 54)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(512, 55)" end="(512, 70)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(512, 55)" end="(512, 56)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(512, 56)" end="(512, 69)" kind="Lean.Parser.Term.app">
                <IdentNode start="(512, 56)" end="(512, 67)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(512, 68)" end="(512, 69)">
                  <IdentNode start="(512, 68)" end="(512, 69)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(512, 69)" end="(512, 70)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(513, 5)" end="(513, 18)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(513, 5)" end="(513, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(513, 6)" end="(513, 8)">
                <IdentNode start="(513, 6)" end="(513, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(513, 9)" end="(513, 17)">
                <AtomNode start="(513, 9)" end="(513, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(513, 11)" end="(513, 17)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(513, 11)" end="(513, 15)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(513, 16)" end="(513, 17)">
                    <IdentNode start="(513, 16)" end="(513, 17)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(513, 17)" end="(513, 18)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(513, 19)" end="(513, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(513, 19)" end="(513, 20)" leading="" trailing="" val="{"/>
              <NullNode start="(513, 20)" end="(513, 21)">
                <IdentNode start="(513, 20)" end="(513, 21)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(513, 22)" end="(513, 40)">
                <AtomNode start="(513, 22)" end="(513, 23)" leading="" trailing=" " val=":"/>
                <OtherNode start="(513, 24)" end="(513, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(513, 24)" end="(513, 25)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(513, 26)" end="(513, 27)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(513, 28)" end="(513, 40)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(513, 28)" end="(513, 29)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(513, 30)" end="(513, 40)">
                      <OtherNode start="(513, 30)" end="(513, 40)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(513, 30)" end="(513, 31)" leading="" trailing="" val="("/>
                        <OtherNode start="(513, 31)" end="(513, 39)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(513, 31)" end="(513, 37)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(513, 38)" end="(513, 39)">
                            <IdentNode start="(513, 38)" end="(513, 39)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(513, 39)" end="(513, 40)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(513, 40)" end="(513, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(513, 42)" end="(514, 64)">
            <AtomNode start="(513, 42)" end="(513, 43)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(514, 5)" end="(514, 64)" kind="«term_=_»">
              <OtherNode start="(514, 5)" end="(514, 30)" kind="Lean.Parser.Term.app">
                <OtherNode start="(514, 5)" end="(514, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(514, 5)" end="(514, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(514, 5)" end="(514, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(514, 6)" end="(514, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(514, 6)" end="(514, 13)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                      <NullNode start="(514, 14)" end="(514, 16)">
                        <IdentNode start="(514, 14)" end="(514, 16)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(514, 16)" end="(514, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(514, 17)" end="(514, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(514, 18)" end="(514, 28)" leading="" trailing=" " raw_val="filterMapM" val="filterMapM" full_name="List.filterMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(514, 29)" end="(514, 30)">
                  <IdentNode start="(514, 29)" end="(514, 30)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(514, 31)" end="(514, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(514, 33)" end="(514, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(514, 33)" end="(514, 62)" leading="" trailing=" " raw_val="xs.attach.unattach.filterMapM" val="xs.attach.unattach.filterMapM"/>
                <NullNode start="(514, 63)" end="(514, 64)">
                  <IdentNode start="(514, 63)" end="(514, 64)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(514, 65)" end="(515, 17)">
          <AtomNode start="(514, 65)" end="(514, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(514, 68)" end="(515, 17)">
            <AtomNode start="(514, 68)" end="(514, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(515, 3)" end="(515, 17)">
              <TacticTacticseq1IndentedNode start="(515, 3)" end="(515, 17)">
                <NullNode start="(515, 3)" end="(515, 17)">
                  <OtherNode start="(515, 3)" end="(515, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : List α&#10;f : α → m (Option β)&#10;⊢ filterMapM f (wfParam xs) = filterMapM f xs.attach.unattach" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(515, 3)" end="(515, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(515, 8)" end="(515, 17)">
                      <AtomNode start="(515, 8)" end="(515, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(515, 9)" end="(515, 16)">
                        <OtherNode start="(515, 9)" end="(515, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(515, 9)" end="(515, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(515, 16)" end="(515, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(517, 1)" end="(521, 17)" name="filterMapM_unattach" full_name="List.filterMapM_unattach">
      <CommandDeclmodifiersNode start="(517, 1)" end="(517, 17)">
        <NullNode/>
        <NullNode start="(517, 1)" end="(517, 17)">
          <OtherNode start="(517, 1)" end="(517, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(517, 1)" end="(517, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(517, 3)" end="(517, 16)">
              <OtherNode start="(517, 3)" end="(517, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(517, 3)" end="(517, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(517, 3)" end="(517, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(517, 16)" end="(517, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(517, 18)" end="(521, 17)" name="filterMapM_unattach" full_name="List.filterMapM_unattach" _is_private_decl="False">
        <AtomNode start="(517, 18)" end="(517, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(517, 26)" end="(517, 45)">
          <IdentNode start="(517, 26)" end="(517, 45)" leading="" trailing=" " raw_val="filterMapM_unattach" val="filterMapM_unattach"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(517, 46)" end="(520, 65)">
          <NullNode start="(517, 46)" end="(518, 66)">
            <OtherNode start="(517, 46)" end="(517, 55)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(517, 46)" end="(517, 47)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(517, 47)" end="(517, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(517, 47)" end="(517, 52)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(517, 53)" end="(517, 54)">
                  <IdentNode start="(517, 53)" end="(517, 54)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(517, 54)" end="(517, 55)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(517, 56)" end="(517, 71)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(517, 56)" end="(517, 57)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(517, 57)" end="(517, 70)" kind="Lean.Parser.Term.app">
                <IdentNode start="(517, 57)" end="(517, 68)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(517, 69)" end="(517, 70)">
                  <IdentNode start="(517, 69)" end="(517, 70)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(517, 70)" end="(517, 71)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(518, 5)" end="(518, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(518, 5)" end="(518, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(518, 6)" end="(518, 7)">
                <IdentNode start="(518, 6)" end="(518, 7)" leading="" trailing=" " raw_val="P" val="P"/>
              </NullNode>
              <NullNode start="(518, 8)" end="(518, 18)">
                <AtomNode start="(518, 8)" end="(518, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(518, 10)" end="(518, 18)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(518, 10)" end="(518, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(518, 12)" end="(518, 13)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(518, 14)" end="(518, 18)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(518, 14)" end="(518, 18)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(518, 18)" end="(518, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(518, 20)" end="(518, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(518, 20)" end="(518, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(518, 21)" end="(518, 23)">
                <IdentNode start="(518, 21)" end="(518, 23)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(518, 24)" end="(518, 42)">
                <AtomNode start="(518, 24)" end="(518, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(518, 26)" end="(518, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(518, 26)" end="(518, 30)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(518, 31)" end="(518, 42)">
                    <OtherNode start="(518, 31)" end="(518, 42)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(518, 31)" end="(518, 32)" leading="" trailing="" val="("/>
                      <OtherNode start="(518, 32)" end="(518, 41)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(518, 32)" end="(518, 39)" leading="" trailing=" " raw_val="Subtype" val="Subtype" full_name="Subtype" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(518, 40)" end="(518, 41)">
                          <IdentNode start="(518, 40)" end="(518, 41)" leading="" trailing="" raw_val="P" val="P"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(518, 41)" end="(518, 42)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(518, 42)" end="(518, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(518, 44)" end="(518, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(518, 44)" end="(518, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(518, 45)" end="(518, 46)">
                <IdentNode start="(518, 45)" end="(518, 46)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(518, 47)" end="(518, 65)">
                <AtomNode start="(518, 47)" end="(518, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(518, 49)" end="(518, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(518, 49)" end="(518, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(518, 51)" end="(518, 52)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(518, 53)" end="(518, 65)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(518, 53)" end="(518, 54)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(518, 55)" end="(518, 65)">
                      <OtherNode start="(518, 55)" end="(518, 65)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(518, 55)" end="(518, 56)" leading="" trailing="" val="("/>
                        <OtherNode start="(518, 56)" end="(518, 64)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(518, 56)" end="(518, 62)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(518, 63)" end="(518, 64)">
                            <IdentNode start="(518, 63)" end="(518, 64)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(518, 64)" end="(518, 65)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(518, 65)" end="(518, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(518, 67)" end="(520, 65)">
            <AtomNode start="(518, 67)" end="(518, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(519, 5)" end="(520, 65)" kind="«term_=_»">
              <OtherNode start="(519, 5)" end="(519, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(519, 5)" end="(519, 27)" leading="" trailing=" " raw_val="xs.unattach.filterMapM" val="xs.unattach.filterMapM"/>
                <NullNode start="(519, 28)" end="(519, 29)">
                  <IdentNode start="(519, 28)" end="(519, 29)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(519, 30)" end="(519, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(519, 32)" end="(520, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(519, 32)" end="(519, 45)" leading="" trailing=" " raw_val="xs.filterMapM" val="xs.filterMapM"/>
                <NullNode start="(519, 46)" end="(520, 65)">
                  <OtherNode start="(519, 46)" end="(520, 65)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(519, 46)" end="(519, 49)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(519, 50)" end="(520, 65)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(519, 50)" end="(519, 56)">
                        <OtherNode start="(519, 50)" end="(519, 56)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(519, 50)" end="(519, 51)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(519, 51)" end="(519, 55)">
                            <IdentNode start="(519, 51)" end="(519, 52)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(519, 52)" end="(519, 53)" leading="" trailing=" " val=","/>
                            <IdentNode start="(519, 54)" end="(519, 55)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(519, 55)" end="(519, 56)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(519, 57)" end="(519, 59)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                      <OtherNode start="(520, 7)" end="(520, 65)" kind="«term_&amp;lt;|_»">
                        <OtherNode start="(520, 7)" end="(520, 25)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(520, 7)" end="(520, 21)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                          <NullNode start="(520, 22)" end="(520, 25)">
                            <IdentNode start="(520, 22)" end="(520, 23)" leading="" trailing=" " raw_val="x" val="x"/>
                            <IdentNode start="(520, 24)" end="(520, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(520, 26)" end="(520, 28)" leading="" trailing=" " val="&amp;lt;|"/>
                        <OtherNode start="(520, 29)" end="(520, 65)" kind="«term_&amp;lt;|_»">
                          <OtherNode start="(520, 29)" end="(520, 48)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(520, 29)" end="(520, 43)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                            <NullNode start="(520, 44)" end="(520, 48)">
                              <IdentNode start="(520, 44)" end="(520, 45)" leading="" trailing=" " raw_val="h" val="h"/>
                              <OtherNode start="(520, 46)" end="(520, 48)" kind="Lean.Parser.Term.tuple">
                                <AtomNode start="(520, 46)" end="(520, 47)" leading="" trailing="" val="("/>
                                <NullNode/>
                                <AtomNode start="(520, 47)" end="(520, 48)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(520, 49)" end="(520, 51)" leading="" trailing=" " val="&amp;lt;|"/>
                          <OtherNode start="(520, 52)" end="(520, 65)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(520, 52)" end="(520, 53)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(520, 54)" end="(520, 65)">
                              <OtherNode start="(520, 54)" end="(520, 65)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(520, 54)" end="(520, 55)" leading="" trailing="" val="("/>
                                <OtherNode start="(520, 55)" end="(520, 64)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(520, 55)" end="(520, 62)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                  <NullNode start="(520, 63)" end="(520, 64)">
                                    <IdentNode start="(520, 63)" end="(520, 64)" leading="" trailing="" raw_val="x" val="x"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(520, 64)" end="(520, 65)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(520, 66)" end="(521, 17)">
          <AtomNode start="(520, 66)" end="(520, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(520, 69)" end="(521, 17)">
            <AtomNode start="(520, 69)" end="(520, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(521, 3)" end="(521, 17)">
              <TacticTacticseq1IndentedNode start="(521, 3)" end="(521, 17)">
                <NullNode start="(521, 3)" end="(521, 17)">
                  <OtherNode start="(521, 3)" end="(521, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;P : α → Prop&#10;xs : List (Subtype P)&#10;f : α → m (Option β)&#10;⊢ filterMapM f xs.unattach =&#10;    filterMapM&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | ⟨x, h⟩ =&amp;gt; binderNameHint x f (binderNameHint h () (f (wfParam x))))&#10;      xs" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(521, 3)" end="(521, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(521, 8)" end="(521, 17)">
                      <AtomNode start="(521, 8)" end="(521, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(521, 9)" end="(521, 16)">
                        <OtherNode start="(521, 9)" end="(521, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(521, 9)" end="(521, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(521, 16)" end="(521, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(523, 1)" end="(529, 33)" name="flatMapM_subtype" full_name="List.flatMapM_subtype">
      <CommandDeclmodifiersNode start="(523, 1)" end="(523, 8)">
        <NullNode/>
        <NullNode start="(523, 1)" end="(523, 8)">
          <OtherNode start="(523, 1)" end="(523, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(523, 1)" end="(523, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(523, 3)" end="(523, 7)">
              <OtherNode start="(523, 3)" end="(523, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(523, 3)" end="(523, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(523, 3)" end="(523, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(523, 7)" end="(523, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(523, 9)" end="(529, 33)" name="flatMapM_subtype" full_name="List.flatMapM_subtype" _is_private_decl="False">
        <AtomNode start="(523, 9)" end="(523, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(523, 17)" end="(523, 33)">
          <IdentNode start="(523, 17)" end="(523, 33)" leading="" trailing=" " raw_val="flatMapM_subtype" val="flatMapM_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(523, 34)" end="(525, 43)">
          <NullNode start="(523, 34)" end="(524, 86)">
            <OtherNode start="(523, 34)" end="(523, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(523, 34)" end="(523, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(523, 35)" end="(523, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(523, 35)" end="(523, 40)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(523, 41)" end="(523, 42)">
                  <IdentNode start="(523, 41)" end="(523, 42)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(523, 42)" end="(523, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(523, 44)" end="(523, 59)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(523, 44)" end="(523, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(523, 45)" end="(523, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(523, 45)" end="(523, 56)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(523, 57)" end="(523, 58)">
                  <IdentNode start="(523, 57)" end="(523, 58)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(523, 58)" end="(523, 59)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(523, 60)" end="(523, 74)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(523, 60)" end="(523, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(523, 61)" end="(523, 62)">
                <IdentNode start="(523, 61)" end="(523, 62)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(523, 63)" end="(523, 73)">
                <AtomNode start="(523, 63)" end="(523, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(523, 65)" end="(523, 73)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(523, 65)" end="(523, 66)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(523, 67)" end="(523, 68)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(523, 69)" end="(523, 73)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(523, 69)" end="(523, 73)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(523, 73)" end="(523, 74)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(523, 75)" end="(523, 98)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(523, 75)" end="(523, 76)" leading="" trailing="" val="{"/>
              <NullNode start="(523, 76)" end="(523, 77)">
                <IdentNode start="(523, 76)" end="(523, 77)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(523, 78)" end="(523, 97)">
                <AtomNode start="(523, 78)" end="(523, 79)" leading="" trailing=" " val=":"/>
                <OtherNode start="(523, 80)" end="(523, 97)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(523, 80)" end="(523, 84)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(523, 85)" end="(523, 97)">
                    <OtherNode start="(523, 85)" end="(523, 97)" kind="«term{_:_//_}»">
                      <AtomNode start="(523, 85)" end="(523, 86)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(523, 87)" end="(523, 88)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(523, 89)" end="(523, 91)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(523, 92)" end="(523, 95)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(523, 92)" end="(523, 93)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(523, 94)" end="(523, 95)">
                          <IdentNode start="(523, 94)" end="(523, 95)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(523, 96)" end="(523, 97)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(523, 97)" end="(523, 98)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(524, 5)" end="(524, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(524, 5)" end="(524, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(524, 6)" end="(524, 7)">
                <IdentNode start="(524, 6)" end="(524, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(524, 8)" end="(524, 35)">
                <AtomNode start="(524, 8)" end="(524, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(524, 10)" end="(524, 35)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(524, 10)" end="(524, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(524, 10)" end="(524, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(524, 12)" end="(524, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(524, 14)" end="(524, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(524, 17)" end="(524, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(524, 17)" end="(524, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(524, 19)" end="(524, 20)">
                        <IdentNode start="(524, 19)" end="(524, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(524, 21)" end="(524, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(524, 23)" end="(524, 24)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(524, 25)" end="(524, 35)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(524, 25)" end="(524, 26)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(524, 27)" end="(524, 35)">
                      <OtherNode start="(524, 27)" end="(524, 35)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(524, 27)" end="(524, 28)" leading="" trailing="" val="("/>
                        <OtherNode start="(524, 28)" end="(524, 34)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(524, 28)" end="(524, 32)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(524, 33)" end="(524, 34)">
                            <IdentNode start="(524, 33)" end="(524, 34)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(524, 34)" end="(524, 35)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(524, 35)" end="(524, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(524, 37)" end="(524, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(524, 37)" end="(524, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(524, 38)" end="(524, 39)">
                <IdentNode start="(524, 38)" end="(524, 39)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(524, 40)" end="(524, 56)">
                <AtomNode start="(524, 40)" end="(524, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(524, 42)" end="(524, 56)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(524, 42)" end="(524, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(524, 44)" end="(524, 45)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(524, 46)" end="(524, 56)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(524, 46)" end="(524, 47)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(524, 48)" end="(524, 56)">
                      <OtherNode start="(524, 48)" end="(524, 56)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(524, 48)" end="(524, 49)" leading="" trailing="" val="("/>
                        <OtherNode start="(524, 49)" end="(524, 55)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(524, 49)" end="(524, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(524, 54)" end="(524, 55)">
                            <IdentNode start="(524, 54)" end="(524, 55)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(524, 55)" end="(524, 56)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(524, 56)" end="(524, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(524, 58)" end="(524, 86)">
              <AtomNode start="(524, 58)" end="(524, 59)" leading="" trailing="" val="("/>
              <NullNode start="(524, 59)" end="(524, 61)">
                <IdentNode start="(524, 59)" end="(524, 61)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(524, 62)" end="(524, 85)">
                <AtomNode start="(524, 62)" end="(524, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(524, 64)" end="(524, 85)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(524, 64)" end="(524, 65)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(524, 66)" end="(524, 69)">
                    <IdentNode start="(524, 66)" end="(524, 67)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(524, 68)" end="(524, 69)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(524, 69)" end="(524, 70)" leading="" trailing=" " val=","/>
                  <OtherNode start="(524, 71)" end="(524, 85)" kind="«term_=_»">
                    <OtherNode start="(524, 71)" end="(524, 79)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(524, 71)" end="(524, 72)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(524, 73)" end="(524, 79)">
                        <OtherNode start="(524, 73)" end="(524, 79)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(524, 73)" end="(524, 74)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(524, 74)" end="(524, 78)">
                            <IdentNode start="(524, 74)" end="(524, 75)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(524, 75)" end="(524, 76)" leading="" trailing=" " val=","/>
                            <IdentNode start="(524, 77)" end="(524, 78)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(524, 78)" end="(524, 79)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(524, 80)" end="(524, 81)" leading="" trailing=" " val="="/>
                    <OtherNode start="(524, 82)" end="(524, 85)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(524, 82)" end="(524, 83)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(524, 84)" end="(524, 85)">
                        <IdentNode start="(524, 84)" end="(524, 85)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(524, 85)" end="(524, 86)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(524, 87)" end="(525, 43)">
            <AtomNode start="(524, 87)" end="(524, 88)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(525, 5)" end="(525, 43)" kind="«term_=_»">
              <OtherNode start="(525, 5)" end="(525, 19)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(525, 5)" end="(525, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(525, 6)" end="(525, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(525, 6)" end="(525, 16)" leading="" trailing=" " raw_val="l.flatMapM" val="l.flatMapM"/>
                  <NullNode start="(525, 17)" end="(525, 18)">
                    <IdentNode start="(525, 17)" end="(525, 18)" leading="" trailing="" raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(525, 18)" end="(525, 19)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(525, 20)" end="(525, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(525, 22)" end="(525, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(525, 22)" end="(525, 41)" leading="" trailing=" " raw_val="l.unattach.flatMapM" val="l.unattach.flatMapM"/>
                <NullNode start="(525, 42)" end="(525, 43)">
                  <IdentNode start="(525, 42)" end="(525, 43)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(525, 44)" end="(529, 33)">
          <AtomNode start="(525, 44)" end="(525, 46)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(525, 47)" end="(529, 33)">
            <AtomNode start="(525, 47)" end="(525, 49)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(526, 3)" end="(529, 33)">
              <TacticTacticseq1IndentedNode start="(526, 3)" end="(529, 33)">
                <NullNode start="(526, 3)" end="(529, 33)">
                  <OtherNode start="(526, 3)" end="(526, 18)" kind="Lean.Parser.Tactic.unfold" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → m (List β)&#10;g : α → m (List β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ flatMapM f l = flatMapM g l.unattach" state_after="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → m (List β)&#10;g : α → m (List β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ flatMapM f l = flatMapM g (map (fun x =&amp;gt; x.val) l)" tactic="unfold unattach">
                    <AtomNode start="(526, 3)" end="(526, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(526, 10)" end="(526, 18)">
                      <IdentNode start="(526, 10)" end="(526, 18)" leading="" trailing="&#10;  " raw_val="unattach" val="unattach" full_name="List.unattach" mod_name="Init.Data.List.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Attach.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(527, 3)" end="(529, 33)" kind="Lean.Parser.Tactic.induction" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → m (List β)&#10;g : α → m (List β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ flatMapM f l = flatMapM g (map (fun x =&amp;gt; x.val) l)" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt; simp [ih, hf]">
                    <AtomNode start="(527, 3)" end="(527, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(527, 13)" end="(527, 14)">
                      <OtherNode start="(527, 13)" end="(527, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(527, 13)" end="(527, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(527, 15)" end="(529, 33)">
                      <OtherNode start="(527, 15)" end="(529, 33)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(527, 15)" end="(527, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(528, 3)" end="(529, 33)">
                          <OtherNode start="(528, 3)" end="(528, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(528, 3)" end="(528, 8)">
                              <OtherNode start="(528, 3)" end="(528, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(528, 3)" end="(528, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(528, 5)" end="(528, 8)">
                                  <NullNode/>
                                  <IdentNode start="(528, 5)" end="(528, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(528, 9)" end="(528, 16)">
                              <AtomNode start="(528, 9)" end="(528, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(528, 12)" end="(528, 16)">
                                <TacticTacticseq1IndentedNode start="(528, 12)" end="(528, 16)">
                                  <NullNode start="(528, 12)" end="(528, 16)">
                                    <OtherNode start="(528, 12)" end="(528, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m (List β)&#10;g : α → m (List β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ flatMapM f [] = flatMapM g (map (fun x =&amp;gt; x.val) [])" state_after="no goals" tactic="simp">
                                      <AtomNode start="(528, 12)" end="(528, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(529, 3)" end="(529, 33)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(529, 3)" end="(529, 16)">
                              <OtherNode start="(529, 3)" end="(529, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(529, 3)" end="(529, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(529, 5)" end="(529, 9)">
                                  <NullNode/>
                                  <IdentNode start="(529, 5)" end="(529, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(529, 10)" end="(529, 16)">
                                  <IdentNode start="(529, 10)" end="(529, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(529, 12)" end="(529, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(529, 14)" end="(529, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(529, 17)" end="(529, 33)">
                              <AtomNode start="(529, 17)" end="(529, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(529, 20)" end="(529, 33)">
                                <TacticTacticseq1IndentedNode start="(529, 20)" end="(529, 33)">
                                  <NullNode start="(529, 20)" end="(529, 33)">
                                    <OtherNode start="(529, 20)" end="(529, 33)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;p : α → Prop&#10;f : { x // p x } → m (List β)&#10;g : α → m (List β)&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : flatMapM f l = flatMapM g (map (fun x =&amp;gt; x.val) l)&#10;⊢ flatMapM f (a :: l) = flatMapM g (map (fun x =&amp;gt; x.val) (a :: l))" state_after="no goals" tactic="simp [ih, hf]">
                                      <AtomNode start="(529, 20)" end="(529, 24)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(529, 25)" end="(529, 33)">
                                        <AtomNode start="(529, 25)" end="(529, 26)" leading="" trailing="" val="["/>
                                        <NullNode start="(529, 26)" end="(529, 32)">
                                          <OtherNode start="(529, 26)" end="(529, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(529, 26)" end="(529, 28)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(529, 28)" end="(529, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(529, 30)" end="(529, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(529, 30)" end="(529, 32)" leading="" trailing="" raw_val="hf" val="hf"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(529, 32)" end="(529, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(531, 1)" end="(534, 17)" name="flatMapM_wfParam" full_name="List.flatMapM_wfParam">
      <CommandDeclmodifiersNode start="(531, 1)" end="(531, 17)">
        <NullNode/>
        <NullNode start="(531, 1)" end="(531, 17)">
          <OtherNode start="(531, 1)" end="(531, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(531, 1)" end="(531, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(531, 3)" end="(531, 16)">
              <OtherNode start="(531, 3)" end="(531, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(531, 3)" end="(531, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(531, 3)" end="(531, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(531, 16)" end="(531, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(531, 18)" end="(534, 17)" name="flatMapM_wfParam" full_name="List.flatMapM_wfParam" _is_private_decl="False">
        <AtomNode start="(531, 18)" end="(531, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(531, 26)" end="(531, 42)">
          <IdentNode start="(531, 26)" end="(531, 42)" leading="" trailing=" " raw_val="flatMapM_wfParam" val="flatMapM_wfParam"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(531, 43)" end="(533, 60)">
          <NullNode start="(531, 43)" end="(532, 39)">
            <OtherNode start="(531, 43)" end="(531, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(531, 43)" end="(531, 44)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(531, 44)" end="(531, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(531, 44)" end="(531, 49)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(531, 50)" end="(531, 51)">
                  <IdentNode start="(531, 50)" end="(531, 51)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(531, 51)" end="(531, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(531, 53)" end="(531, 68)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(531, 53)" end="(531, 54)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(531, 54)" end="(531, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(531, 54)" end="(531, 65)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(531, 66)" end="(531, 67)">
                  <IdentNode start="(531, 66)" end="(531, 67)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(531, 67)" end="(531, 68)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(532, 5)" end="(532, 18)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(532, 5)" end="(532, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(532, 6)" end="(532, 8)">
                <IdentNode start="(532, 6)" end="(532, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(532, 9)" end="(532, 17)">
                <AtomNode start="(532, 9)" end="(532, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(532, 11)" end="(532, 17)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(532, 11)" end="(532, 15)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(532, 16)" end="(532, 17)">
                    <IdentNode start="(532, 16)" end="(532, 17)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(532, 17)" end="(532, 18)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(532, 19)" end="(532, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(532, 19)" end="(532, 20)" leading="" trailing="" val="{"/>
              <NullNode start="(532, 20)" end="(532, 21)">
                <IdentNode start="(532, 20)" end="(532, 21)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(532, 22)" end="(532, 38)">
                <AtomNode start="(532, 22)" end="(532, 23)" leading="" trailing=" " val=":"/>
                <OtherNode start="(532, 24)" end="(532, 38)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(532, 24)" end="(532, 25)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(532, 26)" end="(532, 27)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(532, 28)" end="(532, 38)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(532, 28)" end="(532, 29)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(532, 30)" end="(532, 38)">
                      <OtherNode start="(532, 30)" end="(532, 38)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(532, 30)" end="(532, 31)" leading="" trailing="" val="("/>
                        <OtherNode start="(532, 31)" end="(532, 37)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(532, 31)" end="(532, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(532, 36)" end="(532, 37)">
                            <IdentNode start="(532, 36)" end="(532, 37)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(532, 37)" end="(532, 38)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(532, 38)" end="(532, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(532, 40)" end="(533, 60)">
            <AtomNode start="(532, 40)" end="(532, 41)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(533, 5)" end="(533, 60)" kind="«term_=_»">
              <OtherNode start="(533, 5)" end="(533, 28)" kind="Lean.Parser.Term.app">
                <OtherNode start="(533, 5)" end="(533, 26)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(533, 5)" end="(533, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(533, 5)" end="(533, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(533, 6)" end="(533, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(533, 6)" end="(533, 13)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                      <NullNode start="(533, 14)" end="(533, 16)">
                        <IdentNode start="(533, 14)" end="(533, 16)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(533, 16)" end="(533, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(533, 17)" end="(533, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(533, 18)" end="(533, 26)" leading="" trailing=" " raw_val="flatMapM" val="flatMapM" full_name="List.flatMapM" mod_name="Init.Data.List.Control" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Control.lean"/>
                </OtherNode>
                <NullNode start="(533, 27)" end="(533, 28)">
                  <IdentNode start="(533, 27)" end="(533, 28)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(533, 29)" end="(533, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(533, 31)" end="(533, 60)" kind="Lean.Parser.Term.app">
                <IdentNode start="(533, 31)" end="(533, 58)" leading="" trailing=" " raw_val="xs.attach.unattach.flatMapM" val="xs.attach.unattach.flatMapM"/>
                <NullNode start="(533, 59)" end="(533, 60)">
                  <IdentNode start="(533, 59)" end="(533, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(533, 61)" end="(534, 17)">
          <AtomNode start="(533, 61)" end="(533, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(533, 64)" end="(534, 17)">
            <AtomNode start="(533, 64)" end="(533, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(534, 3)" end="(534, 17)">
              <TacticTacticseq1IndentedNode start="(534, 3)" end="(534, 17)">
                <NullNode start="(534, 3)" end="(534, 17)">
                  <OtherNode start="(534, 3)" end="(534, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;xs : List α&#10;f : α → m (List β)&#10;⊢ flatMapM f (wfParam xs) = flatMapM f xs.attach.unattach" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(534, 3)" end="(534, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(534, 8)" end="(534, 17)">
                      <AtomNode start="(534, 8)" end="(534, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(534, 9)" end="(534, 16)">
                        <OtherNode start="(534, 9)" end="(534, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(534, 9)" end="(534, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(534, 16)" end="(534, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(536, 1)" end="(540, 17)" name="flatMapM_unattach" full_name="List.flatMapM_unattach">
      <CommandDeclmodifiersNode start="(536, 1)" end="(536, 17)">
        <NullNode/>
        <NullNode start="(536, 1)" end="(536, 17)">
          <OtherNode start="(536, 1)" end="(536, 17)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(536, 1)" end="(536, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(536, 3)" end="(536, 16)">
              <OtherNode start="(536, 3)" end="(536, 16)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(536, 3)" end="(536, 16)" kind="Lean.Parser.Attr.wf_preprocess">
                  <AtomNode start="(536, 3)" end="(536, 16)" leading="" trailing="" val="wf_preprocess"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(536, 16)" end="(536, 17)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(536, 18)" end="(540, 17)" name="flatMapM_unattach" full_name="List.flatMapM_unattach" _is_private_decl="False">
        <AtomNode start="(536, 18)" end="(536, 25)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(536, 26)" end="(536, 43)">
          <IdentNode start="(536, 26)" end="(536, 43)" leading="" trailing=" " raw_val="flatMapM_unattach" val="flatMapM_unattach"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(536, 44)" end="(539, 65)">
          <NullNode start="(536, 44)" end="(537, 64)">
            <OtherNode start="(536, 44)" end="(536, 53)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(536, 44)" end="(536, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(536, 45)" end="(536, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(536, 45)" end="(536, 50)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(536, 51)" end="(536, 52)">
                  <IdentNode start="(536, 51)" end="(536, 52)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(536, 52)" end="(536, 53)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(536, 54)" end="(536, 69)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(536, 54)" end="(536, 55)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(536, 55)" end="(536, 68)" kind="Lean.Parser.Term.app">
                <IdentNode start="(536, 55)" end="(536, 66)" leading="" trailing=" " raw_val="LawfulMonad" val="LawfulMonad" full_name="LawfulMonad" mod_name="Init.Control.Lawful.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Lawful/Basic.lean"/>
                <NullNode start="(536, 67)" end="(536, 68)">
                  <IdentNode start="(536, 67)" end="(536, 68)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(536, 68)" end="(536, 69)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(537, 5)" end="(537, 19)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(537, 5)" end="(537, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(537, 6)" end="(537, 7)">
                <IdentNode start="(537, 6)" end="(537, 7)" leading="" trailing=" " raw_val="P" val="P"/>
              </NullNode>
              <NullNode start="(537, 8)" end="(537, 18)">
                <AtomNode start="(537, 8)" end="(537, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(537, 10)" end="(537, 18)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(537, 10)" end="(537, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(537, 12)" end="(537, 13)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(537, 14)" end="(537, 18)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(537, 14)" end="(537, 18)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(537, 18)" end="(537, 19)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(537, 20)" end="(537, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(537, 20)" end="(537, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(537, 21)" end="(537, 23)">
                <IdentNode start="(537, 21)" end="(537, 23)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(537, 24)" end="(537, 42)">
                <AtomNode start="(537, 24)" end="(537, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(537, 26)" end="(537, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(537, 26)" end="(537, 30)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(537, 31)" end="(537, 42)">
                    <OtherNode start="(537, 31)" end="(537, 42)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(537, 31)" end="(537, 32)" leading="" trailing="" val="("/>
                      <OtherNode start="(537, 32)" end="(537, 41)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(537, 32)" end="(537, 39)" leading="" trailing=" " raw_val="Subtype" val="Subtype" full_name="Subtype" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(537, 40)" end="(537, 41)">
                          <IdentNode start="(537, 40)" end="(537, 41)" leading="" trailing="" raw_val="P" val="P"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(537, 41)" end="(537, 42)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(537, 42)" end="(537, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(537, 44)" end="(537, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(537, 44)" end="(537, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(537, 45)" end="(537, 46)">
                <IdentNode start="(537, 45)" end="(537, 46)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(537, 47)" end="(537, 63)">
                <AtomNode start="(537, 47)" end="(537, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(537, 49)" end="(537, 63)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(537, 49)" end="(537, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(537, 51)" end="(537, 52)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(537, 53)" end="(537, 63)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(537, 53)" end="(537, 54)" leading="" trailing=" " raw_val="m" val="m"/>
                    <NullNode start="(537, 55)" end="(537, 63)">
                      <OtherNode start="(537, 55)" end="(537, 63)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(537, 55)" end="(537, 56)" leading="" trailing="" val="("/>
                        <OtherNode start="(537, 56)" end="(537, 62)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(537, 56)" end="(537, 60)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(537, 61)" end="(537, 62)">
                            <IdentNode start="(537, 61)" end="(537, 62)" leading="" trailing="" raw_val="β" val="β"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(537, 62)" end="(537, 63)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(537, 63)" end="(537, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(537, 65)" end="(539, 65)">
            <AtomNode start="(537, 65)" end="(537, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(538, 5)" end="(539, 65)" kind="«term_=_»">
              <OtherNode start="(538, 5)" end="(538, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(538, 5)" end="(538, 25)" leading="" trailing=" " raw_val="xs.unattach.flatMapM" val="xs.unattach.flatMapM"/>
                <NullNode start="(538, 26)" end="(538, 27)">
                  <IdentNode start="(538, 26)" end="(538, 27)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(538, 28)" end="(538, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(538, 30)" end="(539, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(538, 30)" end="(538, 41)" leading="" trailing=" " raw_val="xs.flatMapM" val="xs.flatMapM"/>
                <NullNode start="(538, 42)" end="(539, 65)">
                  <OtherNode start="(538, 42)" end="(539, 65)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(538, 42)" end="(538, 45)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(538, 46)" end="(539, 65)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(538, 46)" end="(538, 52)">
                        <OtherNode start="(538, 46)" end="(538, 52)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(538, 46)" end="(538, 47)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(538, 47)" end="(538, 51)">
                            <IdentNode start="(538, 47)" end="(538, 48)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(538, 48)" end="(538, 49)" leading="" trailing=" " val=","/>
                            <IdentNode start="(538, 50)" end="(538, 51)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(538, 51)" end="(538, 52)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(538, 53)" end="(538, 55)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                      <OtherNode start="(539, 7)" end="(539, 65)" kind="«term_&amp;lt;|_»">
                        <OtherNode start="(539, 7)" end="(539, 25)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(539, 7)" end="(539, 21)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                          <NullNode start="(539, 22)" end="(539, 25)">
                            <IdentNode start="(539, 22)" end="(539, 23)" leading="" trailing=" " raw_val="x" val="x"/>
                            <IdentNode start="(539, 24)" end="(539, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(539, 26)" end="(539, 28)" leading="" trailing=" " val="&amp;lt;|"/>
                        <OtherNode start="(539, 29)" end="(539, 65)" kind="«term_&amp;lt;|_»">
                          <OtherNode start="(539, 29)" end="(539, 48)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(539, 29)" end="(539, 43)" leading="" trailing=" " raw_val="binderNameHint" val="binderNameHint" full_name="binderNameHint" mod_name="Init.BinderNameHint" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/BinderNameHint.lean"/>
                            <NullNode start="(539, 44)" end="(539, 48)">
                              <IdentNode start="(539, 44)" end="(539, 45)" leading="" trailing=" " raw_val="h" val="h"/>
                              <OtherNode start="(539, 46)" end="(539, 48)" kind="Lean.Parser.Term.tuple">
                                <AtomNode start="(539, 46)" end="(539, 47)" leading="" trailing="" val="("/>
                                <NullNode/>
                                <AtomNode start="(539, 47)" end="(539, 48)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(539, 49)" end="(539, 51)" leading="" trailing=" " val="&amp;lt;|"/>
                          <OtherNode start="(539, 52)" end="(539, 65)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(539, 52)" end="(539, 53)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(539, 54)" end="(539, 65)">
                              <OtherNode start="(539, 54)" end="(539, 65)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(539, 54)" end="(539, 55)" leading="" trailing="" val="("/>
                                <OtherNode start="(539, 55)" end="(539, 64)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(539, 55)" end="(539, 62)" leading="" trailing=" " raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                  <NullNode start="(539, 63)" end="(539, 64)">
                                    <IdentNode start="(539, 63)" end="(539, 64)" leading="" trailing="" raw_val="x" val="x"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(539, 64)" end="(539, 65)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(539, 66)" end="(540, 17)">
          <AtomNode start="(539, 66)" end="(539, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(539, 69)" end="(540, 17)">
            <AtomNode start="(539, 69)" end="(539, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(540, 3)" end="(540, 17)">
              <TacticTacticseq1IndentedNode start="(540, 3)" end="(540, 17)">
                <NullNode start="(540, 3)" end="(540, 17)">
                  <OtherNode start="(540, 3)" end="(540, 17)" kind="Lean.Parser.Tactic.simp" state_before="m : Type u_1 → Type u_2&#10;α : Type u_3&#10;β : Type u_1&#10;inst✝¹ : Monad m&#10;inst✝ : LawfulMonad m&#10;P : α → Prop&#10;xs : List (Subtype P)&#10;f : α → m (List β)&#10;⊢ flatMapM f xs.unattach =&#10;    flatMapM&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | ⟨x, h⟩ =&amp;gt; binderNameHint x f (binderNameHint h () (f (wfParam x))))&#10;      xs" state_after="no goals" tactic="simp [wfParam]">
                    <AtomNode start="(540, 3)" end="(540, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(540, 8)" end="(540, 17)">
                      <AtomNode start="(540, 8)" end="(540, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(540, 9)" end="(540, 16)">
                        <OtherNode start="(540, 9)" end="(540, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(540, 9)" end="(540, 16)" leading="" trailing="" raw_val="wfParam" val="wfParam" full_name="wfParam" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(540, 16)" end="(540, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(542, 1)" end="(542, 9)" name="List">
      <AtomNode start="(542, 1)" end="(542, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(542, 5)" end="(542, 9)">
        <IdentNode start="(542, 5)" end="(542, 9)" leading="" trailing="&#10;" raw_val="List" val="List"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(12, 1)" end="(14, 3)" text="# Lemmas about `List.mapM` and `List.forM`.&#10;-/"/>
    <Comment start="(16, 38)" end="(17, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(17, 39)" end="(19, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(23, 1)" end="(23, 29)" text="## Monadic operations -/"/>
    <Comment start="(25, 1)" end="(27, 1)" text="-- We may want to replace these `simp` attributes with explicit equational lemmas,&#10;-- as we already have for all the non-monadic functions.&#10;"/>
    <Comment start="(29, 1)" end="(34, 1)" text="-- Previously `mapM.loop`, `filterMapM.loop`, `forIn.loop`, `forIn'.loop`&#10;-- had attribute `@[simp]`.&#10;-- We don't currently provide simp lemmas,&#10;-- as this is an internal implementation and they don't seem to be needed.&#10;&#10;"/>
    <Comment start="(34, 1)" end="(34, 16)" text="### mapM -/"/>
    <Comment start="(36, 1)" end="(43, 3)" text="Applies the monadic action `f` on every element in the list, left-to-right, and returns the list of&#10;results.&#10;&#10;This is a non-tail-recursive variant of `List.mapM` that's easier to reason about. It cannot be used&#10;as the main definition and replaced by the tail-recursive version because they can only be proved&#10;equal when `m` is a `LawfulMonad`.&#10;-/"/>
    <Comment start="(74, 1)" end="(74, 58)" text="Auxiliary lemma for `mapM_eq_reverse_foldlM_cons`. -/"/>
    <Comment start="(95, 1)" end="(95, 22)" text="### filterMapM -/"/>
    <Comment start="(126, 1)" end="(126, 20)" text="### flatMapM -/"/>
    <Comment start="(151, 1)" end="(151, 29)" text="### foldlM and foldrM -/"/>
    <Comment start="(211, 1)" end="(211, 16)" text="### forM -/"/>
    <Comment start="(229, 1)" end="(229, 18)" text="### forIn' -/"/>
    <Comment start="(293, 1)" end="(296, 3)" text="We can express a for loop over a list as a fold,&#10;in which whenever we reach `.done b` we keep that value through the rest of the fold.&#10;-/"/>
    <Comment start="(326, 1)" end="(326, 76)" text="We can express a for loop over a list which always yields as a fold. -/"/>
    <Comment start="(353, 1)" end="(356, 3)" text="We can express a for loop over a list as a fold,&#10;in which whenever we reach `.done b` we keep that value through the rest of the fold.&#10;-/"/>
    <Comment start="(379, 1)" end="(379, 76)" text="We can express a for loop over a list which always yields as a fold. -/"/>
    <Comment start="(406, 1)" end="(406, 25)" text="### allM and anyM -/"/>
    <Comment start="(430, 1)" end="(430, 95)" text="### Recognizing higher order functions using a function that only depends on the value. -/"/>
    <Comment start="(432, 1)" end="(435, 3)" text="This lemma identifies monadic folds over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/"/>
    <Comment start="(455, 1)" end="(458, 3)" text="This lemma identifies monadic folds over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/"/>
    <Comment start="(482, 1)" end="(485, 3)" text="This lemma identifies monadic maps over lists of subtypes, where the function only depends on the value, not the proposition,&#10;and simplifies these to the function directly taking the value.&#10;-/"/>
  </Comments>
</TracedFile>
