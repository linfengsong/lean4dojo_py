<TracedFile path="src/lean/Init/Data/List/Nat/Count.lean" md5="a9fd70de4d00689f529128bef076e5fc">
  <FileNode start="(1, 1)" end="(118, 9)">
    <ModuleHeaderNode start="(6, 1)" end="(10, 28)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(10, 28)">
        <ModuleImportNode start="(9, 1)" end="(9, 28)" module="Init.Data.List.Count" path="src/lean/Init/Data/List/Count.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 28)" leading="" trailing="&#10;" raw_val="Init.Data.List.Count" val="Init.Data.List.Count"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 28)" module="Init.Data.Nat.Lemmas" path="src/lean/Init/Data/Nat/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 28)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.Nat.Lemmas" val="Init.Data.Nat.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <OtherNode start="(12, 1)" end="(12, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(12, 1)" end="(12, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(12, 12)" end="(12, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(12, 33)" end="(12, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(13, 1)" end="(13, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(13, 1)" end="(13, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(13, 12)" end="(13, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(13, 34)" end="(13, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(15, 1)" end="(15, 15)" name="List">
      <AtomNode start="(15, 1)" end="(15, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(15, 11)" end="(15, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandOpenNode start="(17, 1)" end="(17, 9)">
      <AtomNode start="(17, 1)" end="(17, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(17, 6)" end="(17, 9)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(17, 6)" end="(17, 9)">
          <IdentNode start="(17, 6)" end="(17, 9)" leading="" trailing="&#10;&#10;" raw_val="Nat" val="Nat"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandDeclarationNode start="(19, 1)" end="(30, 12)" name="countP_set" full_name="List.countP_set">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(19, 1)" end="(30, 12)" name="countP_set" full_name="List.countP_set" _is_private_decl="False">
        <AtomNode start="(19, 1)" end="(19, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(19, 9)" end="(19, 19)">
          <IdentNode start="(19, 9)" end="(19, 19)" leading="" trailing=" " raw_val="countP_set" val="countP_set"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(19, 20)" end="(20, 91)">
          <NullNode start="(19, 20)" end="(19, 84)">
            <OtherNode start="(19, 20)" end="(19, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(19, 20)" end="(19, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(19, 21)" end="(19, 22)">
                <IdentNode start="(19, 21)" end="(19, 22)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(19, 23)" end="(19, 33)">
                <AtomNode start="(19, 23)" end="(19, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(19, 25)" end="(19, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(19, 25)" end="(19, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(19, 27)" end="(19, 28)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(19, 29)" end="(19, 33)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(19, 33)" end="(19, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(19, 35)" end="(19, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(19, 35)" end="(19, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(19, 36)" end="(19, 37)">
                <IdentNode start="(19, 36)" end="(19, 37)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(19, 38)" end="(19, 46)">
                <AtomNode start="(19, 38)" end="(19, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(19, 40)" end="(19, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(19, 40)" end="(19, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(19, 45)" end="(19, 46)">
                    <IdentNode start="(19, 45)" end="(19, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(19, 46)" end="(19, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(19, 48)" end="(19, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(19, 48)" end="(19, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(19, 49)" end="(19, 50)">
                <IdentNode start="(19, 49)" end="(19, 50)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(19, 51)" end="(19, 56)">
                <AtomNode start="(19, 51)" end="(19, 52)" leading="" trailing=" " val=":"/>
                <IdentNode start="(19, 53)" end="(19, 56)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(19, 56)" end="(19, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(19, 58)" end="(19, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(19, 58)" end="(19, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(19, 59)" end="(19, 60)">
                <IdentNode start="(19, 59)" end="(19, 60)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(19, 61)" end="(19, 64)">
                <AtomNode start="(19, 61)" end="(19, 62)" leading="" trailing=" " val=":"/>
                <IdentNode start="(19, 63)" end="(19, 64)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(19, 64)" end="(19, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(19, 66)" end="(19, 84)">
              <AtomNode start="(19, 66)" end="(19, 67)" leading="" trailing="" val="("/>
              <NullNode start="(19, 67)" end="(19, 68)">
                <IdentNode start="(19, 67)" end="(19, 68)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(19, 69)" end="(19, 83)">
                <AtomNode start="(19, 69)" end="(19, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(19, 71)" end="(19, 83)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(19, 71)" end="(19, 72)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(19, 73)" end="(19, 74)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(19, 75)" end="(19, 83)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(19, 83)" end="(19, 84)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(19, 85)" end="(20, 91)">
            <AtomNode start="(19, 85)" end="(19, 86)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(20, 5)" end="(20, 91)" kind="«term_=_»">
              <OtherNode start="(20, 5)" end="(20, 25)" kind="Lean.Parser.Term.app">
                <OtherNode start="(20, 5)" end="(20, 23)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(20, 5)" end="(20, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(20, 5)" end="(20, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(20, 6)" end="(20, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(20, 6)" end="(20, 11)" leading="" trailing=" " raw_val="l.set" val="l.set"/>
                      <NullNode start="(20, 12)" end="(20, 15)">
                        <IdentNode start="(20, 12)" end="(20, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(20, 14)" end="(20, 15)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(20, 15)" end="(20, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(20, 16)" end="(20, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(20, 17)" end="(20, 23)" leading="" trailing=" " raw_val="countP" val="countP" full_name="List.countP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(20, 24)" end="(20, 25)">
                  <IdentNode start="(20, 24)" end="(20, 25)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(20, 26)" end="(20, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(20, 28)" end="(20, 91)" kind="«term_+_»">
                <OtherNode start="(20, 28)" end="(20, 66)" kind="«term_-_»">
                  <OtherNode start="(20, 28)" end="(20, 38)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(20, 28)" end="(20, 36)" leading="" trailing=" " raw_val="l.countP" val="l.countP"/>
                    <NullNode start="(20, 37)" end="(20, 38)">
                      <IdentNode start="(20, 37)" end="(20, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(20, 39)" end="(20, 40)" leading="" trailing=" " val="-"/>
                  <OtherNode start="(20, 41)" end="(20, 66)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(20, 41)" end="(20, 42)" leading="" trailing="" val="("/>
                    <OtherNode start="(20, 42)" end="(20, 65)" kind="termIfThenElse">
                      <AtomNode start="(20, 42)" end="(20, 44)" leading="" trailing=" " val="if"/>
                      <OtherNode start="(20, 45)" end="(20, 51)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(20, 45)" end="(20, 46)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(20, 47)" end="(20, 51)">
                          <OtherNode start="(20, 47)" end="(20, 51)" kind="«term__[_]»">
                            <IdentNode start="(20, 47)" end="(20, 48)" leading="" trailing="" raw_val="l" val="l"/>
                            <AtomNode start="(20, 48)" end="(20, 49)" leading="" trailing="" val="["/>
                            <IdentNode start="(20, 49)" end="(20, 50)" leading="" trailing="" raw_val="i" val="i"/>
                            <AtomNode start="(20, 50)" end="(20, 51)" leading="" trailing=" " val="]"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(20, 52)" end="(20, 56)" leading="" trailing=" " val="then"/>
                      <OtherNode start="(20, 57)" end="(20, 58)" kind="num">
                        <AtomNode start="(20, 57)" end="(20, 58)" leading="" trailing=" " val="1"/>
                      </OtherNode>
                      <AtomNode start="(20, 59)" end="(20, 63)" leading="" trailing=" " val="else"/>
                      <OtherNode start="(20, 64)" end="(20, 65)" kind="num">
                        <AtomNode start="(20, 64)" end="(20, 65)" leading="" trailing="" val="0"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(20, 65)" end="(20, 66)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(20, 67)" end="(20, 68)" leading="" trailing=" " val="+"/>
                <OtherNode start="(20, 69)" end="(20, 91)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(20, 69)" end="(20, 70)" leading="" trailing="" val="("/>
                  <OtherNode start="(20, 70)" end="(20, 90)" kind="termIfThenElse">
                    <AtomNode start="(20, 70)" end="(20, 72)" leading="" trailing=" " val="if"/>
                    <OtherNode start="(20, 73)" end="(20, 76)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(20, 73)" end="(20, 74)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(20, 75)" end="(20, 76)">
                        <IdentNode start="(20, 75)" end="(20, 76)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(20, 77)" end="(20, 81)" leading="" trailing=" " val="then"/>
                    <OtherNode start="(20, 82)" end="(20, 83)" kind="num">
                      <AtomNode start="(20, 82)" end="(20, 83)" leading="" trailing=" " val="1"/>
                    </OtherNode>
                    <AtomNode start="(20, 84)" end="(20, 88)" leading="" trailing=" " val="else"/>
                    <OtherNode start="(20, 89)" end="(20, 90)" kind="num">
                      <AtomNode start="(20, 89)" end="(20, 90)" leading="" trailing="" val="0"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(20, 90)" end="(20, 91)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(20, 92)" end="(30, 12)">
          <AtomNode start="(20, 92)" end="(20, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(20, 95)" end="(30, 12)">
            <AtomNode start="(20, 95)" end="(20, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(21, 3)" end="(30, 12)">
              <TacticTacticseq1IndentedNode start="(21, 3)" end="(30, 12)">
                <NullNode start="(21, 3)" end="(30, 12)">
                  <OtherNode start="(21, 3)" end="(30, 12)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l.length&#10;⊢ countP p (l.set i a) = (countP p l - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0" state_after="no goals" tactic="induction l generalizing i with&#10;| nil =&amp;gt; simp at h&#10;| cons x l ih =&amp;gt;&#10;  cases i with&#10;  | zero =&amp;gt; simp [countP_cons]&#10;  | succ i =&amp;gt;&#10;    simp [add_one_lt_add_one_iff] at h&#10;    simp [countP_cons, ih h]&#10;    have : (if p l[i] = true then 1 else 0) ≤ l.countP p := boole_getElem_le_countP (p := p) h&#10;    omega">
                    <AtomNode start="(21, 3)" end="(21, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(21, 13)" end="(21, 14)">
                      <OtherNode start="(21, 13)" end="(21, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(21, 13)" end="(21, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(21, 15)" end="(21, 29)">
                      <AtomNode start="(21, 15)" end="(21, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(21, 28)" end="(21, 29)">
                        <IdentNode start="(21, 28)" end="(21, 29)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(21, 30)" end="(30, 12)">
                      <OtherNode start="(21, 30)" end="(30, 12)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(21, 30)" end="(21, 34)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(22, 3)" end="(30, 12)">
                          <OtherNode start="(22, 3)" end="(22, 21)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(22, 3)" end="(22, 8)">
                              <OtherNode start="(22, 3)" end="(22, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(22, 3)" end="(22, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(22, 5)" end="(22, 8)">
                                  <NullNode/>
                                  <IdentNode start="(22, 5)" end="(22, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(22, 9)" end="(22, 21)">
                              <AtomNode start="(22, 9)" end="(22, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(22, 12)" end="(22, 21)">
                                <TacticTacticseq1IndentedNode start="(22, 12)" end="(22, 21)">
                                  <NullNode start="(22, 12)" end="(22, 21)">
                                    <OtherNode start="(22, 12)" end="(22, 21)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;i : Nat&#10;h : i &amp;lt; [].length&#10;⊢ countP p ([].set i a) = (countP p [] - if p [][i] = true then 1 else 0) + if p a = true then 1 else 0" state_after="no goals" tactic="simp at h">
                                      <AtomNode start="(22, 12)" end="(22, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(22, 17)" end="(22, 21)">
                                        <OtherNode start="(22, 17)" end="(22, 21)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(22, 17)" end="(22, 19)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(22, 20)" end="(22, 21)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(22, 20)" end="(22, 21)">
                                              <IdentNode start="(22, 20)" end="(22, 21)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(23, 3)" end="(30, 12)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(23, 3)" end="(23, 16)">
                              <OtherNode start="(23, 3)" end="(23, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(23, 3)" end="(23, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(23, 5)" end="(23, 9)">
                                  <NullNode/>
                                  <IdentNode start="(23, 5)" end="(23, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(23, 10)" end="(23, 16)">
                                  <IdentNode start="(23, 10)" end="(23, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(23, 12)" end="(23, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(23, 14)" end="(23, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(23, 17)" end="(30, 12)">
                              <AtomNode start="(23, 17)" end="(23, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(24, 5)" end="(30, 12)">
                                <TacticTacticseq1IndentedNode start="(24, 5)" end="(30, 12)">
                                  <NullNode start="(24, 5)" end="(30, 12)">
                                    <OtherNode start="(24, 5)" end="(30, 12)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;a x : α&#10;l : List α&#10;ih :&#10;  ∀ {i : Nat} (h : i &amp;lt; l.length),&#10;    countP p (l.set i a) = (countP p l - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0&#10;i : Nat&#10;h : i &amp;lt; (x :: l).length&#10;⊢ countP p ((x :: l).set i a) =&#10;    (countP p (x :: l) - if p (x :: l)[i] = true then 1 else 0) + if p a = true then 1 else 0" state_after="no goals" tactic="cases i with&#10;| zero =&amp;gt; simp [countP_cons]&#10;| succ i =&amp;gt;&#10;  simp [add_one_lt_add_one_iff] at h&#10;  simp [countP_cons, ih h]&#10;  have : (if p l[i] = true then 1 else 0) ≤ l.countP p := boole_getElem_le_countP (p := p) h&#10;  omega">
                                      <AtomNode start="(24, 5)" end="(24, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(24, 11)" end="(24, 12)">
                                        <OtherNode start="(24, 11)" end="(24, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(24, 11)" end="(24, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(24, 13)" end="(30, 12)">
                                        <OtherNode start="(24, 13)" end="(30, 12)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(24, 13)" end="(24, 17)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(25, 5)" end="(30, 12)">
                                            <OtherNode start="(25, 5)" end="(25, 33)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(25, 5)" end="(25, 11)">
                                                <OtherNode start="(25, 5)" end="(25, 11)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(25, 5)" end="(25, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(25, 7)" end="(25, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(25, 7)" end="(25, 11)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(25, 12)" end="(25, 33)">
                                                <AtomNode start="(25, 12)" end="(25, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(25, 15)" end="(25, 33)">
                                                  <TacticTacticseq1IndentedNode start="(25, 15)" end="(25, 33)">
                                                    <NullNode start="(25, 15)" end="(25, 33)">
                                                      <OtherNode start="(25, 15)" end="(25, 33)" kind="Lean.Parser.Tactic.simp" state_before="case cons.zero&#10;α : Type u_1&#10;p : α → Bool&#10;a x : α&#10;l : List α&#10;ih :&#10;  ∀ {i : Nat} (h : i &amp;lt; l.length),&#10;    countP p (l.set i a) = (countP p l - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0&#10;h : 0 &amp;lt; (x :: l).length&#10;⊢ countP p ((x :: l).set 0 a) =&#10;    (countP p (x :: l) - if p (x :: l)[0] = true then 1 else 0) + if p a = true then 1 else 0" state_after="no goals" tactic="simp [countP_cons]">
                                                        <AtomNode start="(25, 15)" end="(25, 19)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(25, 20)" end="(25, 33)">
                                                          <AtomNode start="(25, 20)" end="(25, 21)" leading="" trailing="" val="["/>
                                                          <NullNode start="(25, 21)" end="(25, 32)">
                                                            <OtherNode start="(25, 21)" end="(25, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(25, 21)" end="(25, 32)" leading="" trailing="" raw_val="countP_cons" val="countP_cons" full_name="List.countP_cons" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(25, 32)" end="(25, 33)" leading="" trailing="&#10;    " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(26, 5)" end="(30, 12)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(26, 5)" end="(26, 13)">
                                                <OtherNode start="(26, 5)" end="(26, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(26, 5)" end="(26, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(26, 7)" end="(26, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(26, 7)" end="(26, 11)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                  </GroupNode>
                                                  <NullNode start="(26, 12)" end="(26, 13)">
                                                    <IdentNode start="(26, 12)" end="(26, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(26, 14)" end="(30, 12)">
                                                <AtomNode start="(26, 14)" end="(26, 16)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(27, 7)" end="(30, 12)">
                                                  <TacticTacticseq1IndentedNode start="(27, 7)" end="(30, 12)">
                                                    <NullNode start="(27, 7)" end="(30, 12)">
                                                      <OtherNode start="(27, 7)" end="(27, 41)" kind="Lean.Parser.Tactic.simp" state_before="case cons.succ&#10;α : Type u_1&#10;p : α → Bool&#10;a x : α&#10;l : List α&#10;ih :&#10;  ∀ {i : Nat} (h : i &amp;lt; l.length),&#10;    countP p (l.set i a) = (countP p l - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0&#10;i : Nat&#10;h : i + 1 &amp;lt; (x :: l).length&#10;⊢ countP p ((x :: l).set (i + 1) a) =&#10;    (countP p (x :: l) - if p (x :: l)[i + 1] = true then 1 else 0) + if p a = true then 1 else 0" state_after="case cons.succ&#10;α : Type u_1&#10;p : α → Bool&#10;a x : α&#10;l : List α&#10;ih :&#10;  ∀ {i : Nat} (h : i &amp;lt; l.length),&#10;    countP p (l.set i a) = (countP p l - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0&#10;i : Nat&#10;h✝ : i + 1 &amp;lt; (x :: l).length&#10;h : i &amp;lt; l.length&#10;⊢ countP p ((x :: l).set (i + 1) a) =&#10;    (countP p (x :: l) - if p (x :: l)[i + 1] = true then 1 else 0) + if p a = true then 1 else 0" tactic="simp [add_one_lt_add_one_iff] at h">
                                                        <AtomNode start="(27, 7)" end="(27, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(27, 12)" end="(27, 36)">
                                                          <AtomNode start="(27, 12)" end="(27, 13)" leading="" trailing="" val="["/>
                                                          <NullNode start="(27, 13)" end="(27, 35)">
                                                            <OtherNode start="(27, 13)" end="(27, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(27, 13)" end="(27, 35)" leading="" trailing="" raw_val="add_one_lt_add_one_iff" val="add_one_lt_add_one_iff" full_name="Nat.add_one_lt_add_one_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(27, 35)" end="(27, 36)" leading="" trailing=" " val="]"/>
                                                        </NullNode>
                                                        <NullNode start="(27, 37)" end="(27, 41)">
                                                          <OtherNode start="(27, 37)" end="(27, 41)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(27, 37)" end="(27, 39)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(27, 40)" end="(27, 41)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(27, 40)" end="(27, 41)">
                                                            <IdentNode start="(27, 40)" end="(27, 41)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(28, 7)" end="(28, 31)" kind="Lean.Parser.Tactic.simp" state_before="case cons.succ&#10;α : Type u_1&#10;p : α → Bool&#10;a x : α&#10;l : List α&#10;ih :&#10;  ∀ {i : Nat} (h : i &amp;lt; l.length),&#10;    countP p (l.set i a) = (countP p l - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0&#10;i : Nat&#10;h✝ : i + 1 &amp;lt; (x :: l).length&#10;h : i &amp;lt; l.length&#10;⊢ countP p ((x :: l).set (i + 1) a) =&#10;    (countP p (x :: l) - if p (x :: l)[i + 1] = true then 1 else 0) + if p a = true then 1 else 0" state_after="case cons.succ&#10;α : Type u_1&#10;p : α → Bool&#10;a x : α&#10;l : List α&#10;ih :&#10;  ∀ {i : Nat} (h : i &amp;lt; l.length),&#10;    countP p (l.set i a) = (countP p l - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0&#10;i : Nat&#10;h✝ : i + 1 &amp;lt; (x :: l).length&#10;h : i &amp;lt; l.length&#10;⊢ (((countP p l - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0" tactic="simp [countP_cons, ih h]">
                                                        <AtomNode start="(28, 7)" end="(28, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(28, 12)" end="(28, 31)">
                                                          <AtomNode start="(28, 12)" end="(28, 13)" leading="" trailing="" val="["/>
                                                          <NullNode start="(28, 13)" end="(28, 30)">
                                                            <OtherNode start="(28, 13)" end="(28, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(28, 13)" end="(28, 24)" leading="" trailing="" raw_val="countP_cons" val="countP_cons" full_name="List.countP_cons" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(28, 24)" end="(28, 25)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(28, 26)" end="(28, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(28, 26)" end="(28, 30)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(28, 26)" end="(28, 28)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(28, 29)" end="(28, 30)">
                                                            <IdentNode start="(28, 29)" end="(28, 30)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(28, 30)" end="(28, 31)" leading="" trailing="&#10;      " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(29, 7)" end="(29, 97)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case cons.succ&#10;α : Type u_1&#10;p : α → Bool&#10;a x : α&#10;l : List α&#10;ih :&#10;  ∀ {i : Nat} (h : i &amp;lt; l.length),&#10;    countP p (l.set i a) = (countP p l - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0&#10;i : Nat&#10;h✝ : i + 1 &amp;lt; (x :: l).length&#10;h : i &amp;lt; l.length&#10;⊢ (((countP p l - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0" state_after="case cons.succ&#10;α : Type u_1&#10;p : α → Bool&#10;a x : α&#10;l : List α&#10;ih :&#10;  ∀ {i : Nat} (h : i &amp;lt; l.length),&#10;    countP p (l.set i a) = (countP p l - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0&#10;i : Nat&#10;h✝ : i + 1 &amp;lt; (x :: l).length&#10;h : i &amp;lt; l.length&#10;this : (if p l[i] = true then 1 else 0) ≤ countP p l&#10;⊢ (((countP p l - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0" tactic="have : (if p l[i] = true then 1 else 0) ≤ l.countP p := boole_getElem_le_countP (p := p) h">
                                                        <AtomNode start="(29, 7)" end="(29, 11)" leading="" trailing=" " val="have"/>
                                                        <OtherNode start="(29, 12)" end="(29, 97)" kind="Lean.Parser.Term.haveDecl">
                                                          <OtherNode start="(29, 12)" end="(29, 97)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(29, 12)" end="(29, 12)" kind="Lean.Parser.Term.haveId">
                                                            <OtherNode start="(29, 12)" end="(29, 12)" kind="hygieneInfo">
                                                            <IdentNode start="(29, 12)" end="(29, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(29, 12)" end="(29, 59)">
                                                            <TermTypespecNode start="(29, 12)" end="(29, 59)">
                                                            <AtomNode start="(29, 12)" end="(29, 13)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(29, 14)" end="(29, 59)" kind="«term_≤_»">
                                                            <OtherNode start="(29, 14)" end="(29, 46)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(29, 14)" end="(29, 15)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(29, 15)" end="(29, 45)" kind="termIfThenElse">
                                                            <AtomNode start="(29, 15)" end="(29, 17)" leading="" trailing=" " val="if"/>
                                                            <OtherNode start="(29, 18)" end="(29, 31)" kind="«term_=_»">
                                                            <OtherNode start="(29, 18)" end="(29, 24)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(29, 18)" end="(29, 19)" leading="" trailing=" " raw_val="p" val="p"/>
                                                            <NullNode start="(29, 20)" end="(29, 24)">
                                                            <OtherNode start="(29, 20)" end="(29, 24)" kind="«term__[_]»">
                                                            <IdentNode start="(29, 20)" end="(29, 21)" leading="" trailing="" raw_val="l" val="l"/>
                                                            <AtomNode start="(29, 21)" end="(29, 22)" leading="" trailing="" val="["/>
                                                            <IdentNode start="(29, 22)" end="(29, 23)" leading="" trailing="" raw_val="i" val="i"/>
                                                            <AtomNode start="(29, 23)" end="(29, 24)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(29, 25)" end="(29, 26)" leading="" trailing=" " val="="/>
                                                            <IdentNode start="(29, 27)" end="(29, 31)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(29, 32)" end="(29, 36)" leading="" trailing=" " val="then"/>
                                                            <OtherNode start="(29, 37)" end="(29, 38)" kind="num">
                                                            <AtomNode start="(29, 37)" end="(29, 38)" leading="" trailing=" " val="1"/>
                                                            </OtherNode>
                                                            <AtomNode start="(29, 39)" end="(29, 43)" leading="" trailing=" " val="else"/>
                                                            <OtherNode start="(29, 44)" end="(29, 45)" kind="num">
                                                            <AtomNode start="(29, 44)" end="(29, 45)" leading="" trailing="" val="0"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(29, 45)" end="(29, 46)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <AtomNode start="(29, 47)" end="(29, 48)" leading="" trailing=" " val="≤"/>
                                                            <OtherNode start="(29, 49)" end="(29, 59)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(29, 49)" end="(29, 57)" leading="" trailing=" " raw_val="l.countP" val="l.countP"/>
                                                            <NullNode start="(29, 58)" end="(29, 59)">
                                                            <IdentNode start="(29, 58)" end="(29, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(29, 60)" end="(29, 62)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(29, 63)" end="(29, 97)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(29, 63)" end="(29, 86)" leading="" trailing=" " raw_val="boole_getElem_le_countP" val="boole_getElem_le_countP" full_name="List.boole_getElem_le_countP" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                                                            <NullNode start="(29, 87)" end="(29, 97)">
                                                            <OtherNode start="(29, 87)" end="(29, 95)" kind="Lean.Parser.Term.namedArgument">
                                                            <AtomNode start="(29, 87)" end="(29, 88)" leading="" trailing="" val="("/>
                                                            <IdentNode start="(29, 88)" end="(29, 89)" leading="" trailing=" " raw_val="p" val="p"/>
                                                            <AtomNode start="(29, 90)" end="(29, 92)" leading="" trailing=" " val=":="/>
                                                            <IdentNode start="(29, 93)" end="(29, 94)" leading="" trailing="" raw_val="p" val="p"/>
                                                            <AtomNode start="(29, 94)" end="(29, 95)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <IdentNode start="(29, 96)" end="(29, 97)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(30, 7)" end="(30, 12)" kind="Lean.Parser.Tactic.omega" state_before="case cons.succ&#10;α : Type u_1&#10;p : α → Bool&#10;a x : α&#10;l : List α&#10;ih :&#10;  ∀ {i : Nat} (h : i &amp;lt; l.length),&#10;    countP p (l.set i a) = (countP p l - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0&#10;i : Nat&#10;h✝ : i + 1 &amp;lt; (x :: l).length&#10;h : i &amp;lt; l.length&#10;this : (if p l[i] = true then 1 else 0) ≤ countP p l&#10;⊢ (((countP p l - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) - if p l[i] = true then 1 else 0) + if p a = true then 1 else 0" state_after="no goals" tactic="omega">
                                                        <AtomNode start="(30, 7)" end="(30, 12)" leading="" trailing="&#10;&#10;" val="omega"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(32, 1)" end="(34, 40)" name="count_set" full_name="List.count_set">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(32, 1)" end="(34, 40)" name="count_set" full_name="List.count_set" _is_private_decl="False">
        <AtomNode start="(32, 1)" end="(32, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(32, 9)" end="(32, 18)">
          <IdentNode start="(32, 9)" end="(32, 18)" leading="" trailing=" " raw_val="count_set" val="count_set"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(32, 19)" end="(33, 95)">
          <NullNode start="(32, 19)" end="(32, 78)">
            <OtherNode start="(32, 19)" end="(32, 26)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(32, 19)" end="(32, 20)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(32, 20)" end="(32, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(32, 20)" end="(32, 23)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(32, 24)" end="(32, 25)">
                  <IdentNode start="(32, 24)" end="(32, 25)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(32, 25)" end="(32, 26)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(32, 27)" end="(32, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(32, 27)" end="(32, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(32, 28)" end="(32, 31)">
                <IdentNode start="(32, 28)" end="(32, 29)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(32, 30)" end="(32, 31)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(32, 32)" end="(32, 35)">
                <AtomNode start="(32, 32)" end="(32, 33)" leading="" trailing=" " val=":"/>
                <IdentNode start="(32, 34)" end="(32, 35)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(32, 35)" end="(32, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(32, 37)" end="(32, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(32, 37)" end="(32, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(32, 38)" end="(32, 39)">
                <IdentNode start="(32, 38)" end="(32, 39)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(32, 40)" end="(32, 48)">
                <AtomNode start="(32, 40)" end="(32, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(32, 42)" end="(32, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(32, 42)" end="(32, 46)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(32, 47)" end="(32, 48)">
                    <IdentNode start="(32, 47)" end="(32, 48)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(32, 48)" end="(32, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(32, 50)" end="(32, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(32, 50)" end="(32, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(32, 51)" end="(32, 52)">
                <IdentNode start="(32, 51)" end="(32, 52)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(32, 53)" end="(32, 58)">
                <AtomNode start="(32, 53)" end="(32, 54)" leading="" trailing=" " val=":"/>
                <IdentNode start="(32, 55)" end="(32, 58)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(32, 58)" end="(32, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(32, 60)" end="(32, 78)">
              <AtomNode start="(32, 60)" end="(32, 61)" leading="" trailing="" val="("/>
              <NullNode start="(32, 61)" end="(32, 62)">
                <IdentNode start="(32, 61)" end="(32, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(32, 63)" end="(32, 77)">
                <AtomNode start="(32, 63)" end="(32, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(32, 65)" end="(32, 77)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(32, 65)" end="(32, 66)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(32, 67)" end="(32, 68)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(32, 69)" end="(32, 77)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(32, 77)" end="(32, 78)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(32, 79)" end="(33, 95)">
            <AtomNode start="(32, 79)" end="(32, 80)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(33, 5)" end="(33, 95)" kind="«term_=_»">
              <OtherNode start="(33, 5)" end="(33, 24)" kind="Lean.Parser.Term.app">
                <OtherNode start="(33, 5)" end="(33, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(33, 5)" end="(33, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(33, 5)" end="(33, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(33, 6)" end="(33, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(33, 6)" end="(33, 11)" leading="" trailing=" " raw_val="l.set" val="l.set"/>
                      <NullNode start="(33, 12)" end="(33, 15)">
                        <IdentNode start="(33, 12)" end="(33, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(33, 14)" end="(33, 15)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(33, 15)" end="(33, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(33, 16)" end="(33, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(33, 17)" end="(33, 22)" leading="" trailing=" " raw_val="count" val="count" full_name="List.count" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(33, 23)" end="(33, 24)">
                  <IdentNode start="(33, 23)" end="(33, 24)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(33, 25)" end="(33, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(33, 27)" end="(33, 95)" kind="«term_+_»">
                <OtherNode start="(33, 27)" end="(33, 67)" kind="«term_-_»">
                  <OtherNode start="(33, 27)" end="(33, 36)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(33, 27)" end="(33, 34)" leading="" trailing=" " raw_val="l.count" val="l.count"/>
                    <NullNode start="(33, 35)" end="(33, 36)">
                      <IdentNode start="(33, 35)" end="(33, 36)" leading="" trailing=" " raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(33, 37)" end="(33, 38)" leading="" trailing=" " val="-"/>
                  <OtherNode start="(33, 39)" end="(33, 67)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(33, 39)" end="(33, 40)" leading="" trailing="" val="("/>
                    <OtherNode start="(33, 40)" end="(33, 66)" kind="termIfThenElse">
                      <AtomNode start="(33, 40)" end="(33, 42)" leading="" trailing=" " val="if"/>
                      <OtherNode start="(33, 43)" end="(33, 52)" kind="«term_==_»">
                        <OtherNode start="(33, 43)" end="(33, 47)" kind="«term__[_]»">
                          <IdentNode start="(33, 43)" end="(33, 44)" leading="" trailing="" raw_val="l" val="l"/>
                          <AtomNode start="(33, 44)" end="(33, 45)" leading="" trailing="" val="["/>
                          <IdentNode start="(33, 45)" end="(33, 46)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(33, 46)" end="(33, 47)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                        <AtomNode start="(33, 48)" end="(33, 50)" leading="" trailing=" " val="=="/>
                        <IdentNode start="(33, 51)" end="(33, 52)" leading="" trailing=" " raw_val="b" val="b"/>
                      </OtherNode>
                      <AtomNode start="(33, 53)" end="(33, 57)" leading="" trailing=" " val="then"/>
                      <OtherNode start="(33, 58)" end="(33, 59)" kind="num">
                        <AtomNode start="(33, 58)" end="(33, 59)" leading="" trailing=" " val="1"/>
                      </OtherNode>
                      <AtomNode start="(33, 60)" end="(33, 64)" leading="" trailing=" " val="else"/>
                      <OtherNode start="(33, 65)" end="(33, 66)" kind="num">
                        <AtomNode start="(33, 65)" end="(33, 66)" leading="" trailing="" val="0"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(33, 66)" end="(33, 67)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(33, 68)" end="(33, 69)" leading="" trailing=" " val="+"/>
                <OtherNode start="(33, 70)" end="(33, 95)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(33, 70)" end="(33, 71)" leading="" trailing="" val="("/>
                  <OtherNode start="(33, 71)" end="(33, 94)" kind="termIfThenElse">
                    <AtomNode start="(33, 71)" end="(33, 73)" leading="" trailing=" " val="if"/>
                    <OtherNode start="(33, 74)" end="(33, 80)" kind="«term_==_»">
                      <IdentNode start="(33, 74)" end="(33, 75)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(33, 76)" end="(33, 78)" leading="" trailing=" " val="=="/>
                      <IdentNode start="(33, 79)" end="(33, 80)" leading="" trailing=" " raw_val="b" val="b"/>
                    </OtherNode>
                    <AtomNode start="(33, 81)" end="(33, 85)" leading="" trailing=" " val="then"/>
                    <OtherNode start="(33, 86)" end="(33, 87)" kind="num">
                      <AtomNode start="(33, 86)" end="(33, 87)" leading="" trailing=" " val="1"/>
                    </OtherNode>
                    <AtomNode start="(33, 88)" end="(33, 92)" leading="" trailing=" " val="else"/>
                    <OtherNode start="(33, 93)" end="(33, 94)" kind="num">
                      <AtomNode start="(33, 93)" end="(33, 94)" leading="" trailing="" val="0"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(33, 94)" end="(33, 95)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(33, 96)" end="(34, 40)">
          <AtomNode start="(33, 96)" end="(33, 98)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(33, 99)" end="(34, 40)">
            <AtomNode start="(33, 99)" end="(33, 101)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(34, 3)" end="(34, 40)">
              <TacticTacticseq1IndentedNode start="(34, 3)" end="(34, 40)">
                <NullNode start="(34, 3)" end="(34, 40)">
                  <OtherNode start="(34, 3)" end="(34, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a b : α&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ count b (l.set i a) = (count b l - if (l[i] == b) = true then 1 else 0) + if (a == b) = true then 1 else 0" state_after="no goals" tactic="simp [count_eq_countP, countP_set, h]">
                    <AtomNode start="(34, 3)" end="(34, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(34, 8)" end="(34, 40)">
                      <AtomNode start="(34, 8)" end="(34, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(34, 9)" end="(34, 39)">
                        <OtherNode start="(34, 9)" end="(34, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(34, 9)" end="(34, 24)" leading="" trailing="" raw_val="count_eq_countP" val="count_eq_countP" full_name="List.count_eq_countP" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                        </OtherNode>
                        <AtomNode start="(34, 24)" end="(34, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(34, 26)" end="(34, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(34, 26)" end="(34, 36)" leading="" trailing="" raw_val="countP_set" val="countP_set" full_name="List.countP_set" mod_name="Init.Data.List.Nat.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Count.lean" def_start="(19, 9)" def_end="(19, 19)"/>
                        </OtherNode>
                        <AtomNode start="(34, 36)" end="(34, 37)" leading="" trailing=" " val=","/>
                        <OtherNode start="(34, 38)" end="(34, 39)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(34, 38)" end="(34, 39)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(34, 39)" end="(34, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(36, 1)" end="(56, 14)" name="countP_replace" full_name="List.countP_replace">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(36, 1)" end="(56, 14)" name="countP_replace" full_name="List.countP_replace" _is_private_decl="False">
        <AtomNode start="(36, 1)" end="(36, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(36, 9)" end="(36, 23)">
          <IdentNode start="(36, 9)" end="(36, 23)" leading="" trailing=" " raw_val="countP_replace" val="countP_replace"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(36, 24)" end="(38, 104)">
          <NullNode start="(36, 24)" end="(36, 83)">
            <OtherNode start="(36, 24)" end="(36, 31)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(36, 24)" end="(36, 25)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(36, 25)" end="(36, 30)" kind="Lean.Parser.Term.app">
                <IdentNode start="(36, 25)" end="(36, 28)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(36, 29)" end="(36, 30)">
                  <IdentNode start="(36, 29)" end="(36, 30)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(36, 30)" end="(36, 31)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(36, 32)" end="(36, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(36, 32)" end="(36, 33)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(36, 33)" end="(36, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(36, 33)" end="(36, 42)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(36, 43)" end="(36, 44)">
                  <IdentNode start="(36, 43)" end="(36, 44)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(36, 44)" end="(36, 45)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(36, 46)" end="(36, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(36, 46)" end="(36, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(36, 47)" end="(36, 50)">
                <IdentNode start="(36, 47)" end="(36, 48)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(36, 49)" end="(36, 50)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(36, 51)" end="(36, 54)">
                <AtomNode start="(36, 51)" end="(36, 52)" leading="" trailing=" " val=":"/>
                <IdentNode start="(36, 53)" end="(36, 54)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(36, 54)" end="(36, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(36, 56)" end="(36, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(36, 56)" end="(36, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(36, 57)" end="(36, 58)">
                <IdentNode start="(36, 57)" end="(36, 58)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(36, 59)" end="(36, 67)">
                <AtomNode start="(36, 59)" end="(36, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(36, 61)" end="(36, 67)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(36, 61)" end="(36, 65)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(36, 66)" end="(36, 67)">
                    <IdentNode start="(36, 66)" end="(36, 67)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(36, 67)" end="(36, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(36, 69)" end="(36, 83)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(36, 69)" end="(36, 70)" leading="" trailing="" val="{"/>
              <NullNode start="(36, 70)" end="(36, 71)">
                <IdentNode start="(36, 70)" end="(36, 71)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(36, 72)" end="(36, 82)">
                <AtomNode start="(36, 72)" end="(36, 73)" leading="" trailing=" " val=":"/>
                <OtherNode start="(36, 74)" end="(36, 82)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(36, 74)" end="(36, 75)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(36, 76)" end="(36, 77)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(36, 78)" end="(36, 82)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(36, 82)" end="(36, 83)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(36, 84)" end="(38, 104)">
            <AtomNode start="(36, 84)" end="(36, 85)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(37, 5)" end="(38, 104)" kind="«term_=_»">
              <OtherNode start="(37, 5)" end="(37, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(37, 5)" end="(37, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(37, 5)" end="(37, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(37, 5)" end="(37, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(37, 6)" end="(37, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(37, 6)" end="(37, 15)" leading="" trailing=" " raw_val="l.replace" val="l.replace"/>
                      <NullNode start="(37, 16)" end="(37, 19)">
                        <IdentNode start="(37, 16)" end="(37, 17)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(37, 18)" end="(37, 19)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(37, 19)" end="(37, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(37, 20)" end="(37, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(37, 21)" end="(37, 27)" leading="" trailing=" " raw_val="countP" val="countP" full_name="List.countP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(37, 28)" end="(37, 29)">
                  <IdentNode start="(37, 28)" end="(37, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(37, 30)" end="(37, 31)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(38, 7)" end="(38, 104)" kind="termIfThenElse">
                <AtomNode start="(38, 7)" end="(38, 9)" leading="" trailing=" " val="if"/>
                <OtherNode start="(38, 10)" end="(38, 22)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(38, 10)" end="(38, 20)" leading="" trailing=" " raw_val="l.contains" val="l.contains"/>
                  <NullNode start="(38, 21)" end="(38, 22)">
                    <IdentNode start="(38, 21)" end="(38, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(38, 23)" end="(38, 27)" leading="" trailing=" " val="then"/>
                <OtherNode start="(38, 28)" end="(38, 88)" kind="«term_-_»">
                  <OtherNode start="(38, 28)" end="(38, 63)" kind="«term_+_»">
                    <OtherNode start="(38, 28)" end="(38, 38)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(38, 28)" end="(38, 36)" leading="" trailing=" " raw_val="l.countP" val="l.countP"/>
                      <NullNode start="(38, 37)" end="(38, 38)">
                        <IdentNode start="(38, 37)" end="(38, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(38, 39)" end="(38, 40)" leading="" trailing=" " val="+"/>
                    <OtherNode start="(38, 41)" end="(38, 63)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(38, 41)" end="(38, 42)" leading="" trailing="" val="("/>
                      <OtherNode start="(38, 42)" end="(38, 62)" kind="termIfThenElse">
                        <AtomNode start="(38, 42)" end="(38, 44)" leading="" trailing=" " val="if"/>
                        <OtherNode start="(38, 45)" end="(38, 48)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(38, 45)" end="(38, 46)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(38, 47)" end="(38, 48)">
                            <IdentNode start="(38, 47)" end="(38, 48)" leading="" trailing=" " raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(38, 49)" end="(38, 53)" leading="" trailing=" " val="then"/>
                        <OtherNode start="(38, 54)" end="(38, 55)" kind="num">
                          <AtomNode start="(38, 54)" end="(38, 55)" leading="" trailing=" " val="1"/>
                        </OtherNode>
                        <AtomNode start="(38, 56)" end="(38, 60)" leading="" trailing=" " val="else"/>
                        <OtherNode start="(38, 61)" end="(38, 62)" kind="num">
                          <AtomNode start="(38, 61)" end="(38, 62)" leading="" trailing="" val="0"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(38, 62)" end="(38, 63)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(38, 64)" end="(38, 65)" leading="" trailing=" " val="-"/>
                  <OtherNode start="(38, 66)" end="(38, 88)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(38, 66)" end="(38, 67)" leading="" trailing="" val="("/>
                    <OtherNode start="(38, 67)" end="(38, 87)" kind="termIfThenElse">
                      <AtomNode start="(38, 67)" end="(38, 69)" leading="" trailing=" " val="if"/>
                      <OtherNode start="(38, 70)" end="(38, 73)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(38, 70)" end="(38, 71)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(38, 72)" end="(38, 73)">
                          <IdentNode start="(38, 72)" end="(38, 73)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(38, 74)" end="(38, 78)" leading="" trailing=" " val="then"/>
                      <OtherNode start="(38, 79)" end="(38, 80)" kind="num">
                        <AtomNode start="(38, 79)" end="(38, 80)" leading="" trailing=" " val="1"/>
                      </OtherNode>
                      <AtomNode start="(38, 81)" end="(38, 85)" leading="" trailing=" " val="else"/>
                      <OtherNode start="(38, 86)" end="(38, 87)" kind="num">
                        <AtomNode start="(38, 86)" end="(38, 87)" leading="" trailing="" val="0"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(38, 87)" end="(38, 88)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(38, 89)" end="(38, 93)" leading="" trailing=" " val="else"/>
                <OtherNode start="(38, 94)" end="(38, 104)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(38, 94)" end="(38, 102)" leading="" trailing=" " raw_val="l.countP" val="l.countP"/>
                  <NullNode start="(38, 103)" end="(38, 104)">
                    <IdentNode start="(38, 103)" end="(38, 104)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(38, 105)" end="(56, 14)">
          <AtomNode start="(38, 105)" end="(38, 107)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(38, 108)" end="(56, 14)">
            <AtomNode start="(38, 108)" end="(38, 110)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(39, 3)" end="(56, 14)">
              <TacticTacticseq1IndentedNode start="(39, 3)" end="(56, 14)">
                <NullNode start="(39, 3)" end="(56, 14)">
                  <OtherNode start="(39, 3)" end="(56, 14)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;p : α → Bool&#10;⊢ countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x l ih =&amp;gt;&#10;  simp [replace_cons]&#10;  split &amp;lt;;&amp;gt; rename_i h&#10;  · simp at h&#10;    simp [h, ih, countP_cons]&#10;    omega&#10;  · simp only [beq_eq_false_iff_ne, ne_eq] at h&#10;    simp only [countP_cons, ih, contains_eq_mem, decide_eq_true_eq, mem_cons, h, false_or]&#10;    split &amp;lt;;&amp;gt; rename_i h'&#10;    · by_cases h'' : p a&#10;      · have : countP p l &amp;gt; 0 := countP_pos_iff.mpr ⟨a, h', h''⟩&#10;        simp [h'']&#10;        omega&#10;      · simp [h'']&#10;        omega&#10;    · omega">
                    <AtomNode start="(39, 3)" end="(39, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(39, 13)" end="(39, 14)">
                      <OtherNode start="(39, 13)" end="(39, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(39, 13)" end="(39, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(39, 15)" end="(56, 14)">
                      <OtherNode start="(39, 15)" end="(56, 14)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(39, 15)" end="(39, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(40, 3)" end="(56, 14)">
                          <OtherNode start="(40, 3)" end="(40, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(40, 3)" end="(40, 8)">
                              <OtherNode start="(40, 3)" end="(40, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(40, 3)" end="(40, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(40, 5)" end="(40, 8)">
                                  <NullNode/>
                                  <IdentNode start="(40, 5)" end="(40, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(40, 9)" end="(40, 16)">
                              <AtomNode start="(40, 9)" end="(40, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(40, 12)" end="(40, 16)">
                                <TacticTacticseq1IndentedNode start="(40, 12)" end="(40, 16)">
                                  <NullNode start="(40, 12)" end="(40, 16)">
                                    <OtherNode start="(40, 12)" end="(40, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;⊢ countP p ([].replace a b) =&#10;    if [].contains a = true then (countP p [] + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(40, 12)" end="(40, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(41, 3)" end="(56, 14)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(41, 3)" end="(41, 16)">
                              <OtherNode start="(41, 3)" end="(41, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(41, 3)" end="(41, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(41, 5)" end="(41, 9)">
                                  <NullNode/>
                                  <IdentNode start="(41, 5)" end="(41, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(41, 10)" end="(41, 16)">
                                  <IdentNode start="(41, 10)" end="(41, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(41, 12)" end="(41, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(41, 14)" end="(41, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(41, 17)" end="(56, 14)">
                              <AtomNode start="(41, 17)" end="(41, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(42, 5)" end="(56, 14)">
                                <TacticTacticseq1IndentedNode start="(42, 5)" end="(56, 14)">
                                  <NullNode start="(42, 5)" end="(56, 14)">
                                    <OtherNode start="(42, 5)" end="(42, 24)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;⊢ countP p ((x :: l).replace a b) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)" state_after="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;⊢ countP p&#10;      (match a == x with&#10;      | true =&amp;gt; b :: l&#10;      | false =&amp;gt; x :: l.replace a b) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)" tactic="simp [replace_cons]">
                                      <AtomNode start="(42, 5)" end="(42, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(42, 10)" end="(42, 24)">
                                        <AtomNode start="(42, 10)" end="(42, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(42, 11)" end="(42, 23)">
                                          <OtherNode start="(42, 11)" end="(42, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(42, 11)" end="(42, 23)" leading="" trailing="" raw_val="replace_cons" val="replace_cons" full_name="List.replace_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(42, 23)" end="(42, 24)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(43, 5)" end="(43, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;⊢ countP p&#10;      (match a == x with&#10;      | true =&amp;gt; b :: l&#10;      | false =&amp;gt; x :: l.replace a b) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)" state_after="case cons.h_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : (a == x) = true&#10;⊢ countP p (b :: l) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)&#10;&#10;case cons.h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : (a == x) = false&#10;⊢ countP p (x :: l.replace a b) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)" tactic="split &amp;lt;;&amp;gt; rename_i h">
                                      <OtherNode start="(43, 5)" end="(43, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(43, 5)" end="(43, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(43, 11)" end="(43, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(43, 15)" end="(43, 25)" kind="Lean.Parser.Tactic.renameI">
                                        <AtomNode start="(43, 15)" end="(43, 23)" leading="" trailing=" " val="rename_i"/>
                                        <NullNode start="(43, 24)" end="(43, 25)">
                                          <LeanBinderidentNode start="(43, 24)" end="(43, 25)">
                                            <IdentNode start="(43, 24)" end="(43, 25)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                          </LeanBinderidentNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(44, 5)" end="(46, 12)" kind="Lean.cdot" state_before="case cons.h_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : (a == x) = true&#10;⊢ countP p (b :: l) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)&#10;&#10;case cons.h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : (a == x) = false&#10;⊢ countP p (x :: l.replace a b) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)" state_after="case cons.h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : (a == x) = false&#10;⊢ countP p (x :: l.replace a b) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)" tactic="· simp at h&#10;  simp [h, ih, countP_cons]&#10;  omega">
                                      <OtherNode start="(44, 5)" end="(44, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(44, 5)" end="(44, 6)" kind="patternIgnore">
                                          <OtherNode start="(44, 5)" end="(44, 6)" kind="token.«· »">
                                            <AtomNode start="(44, 5)" end="(44, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(44, 7)" end="(46, 12)">
                                        <TacticTacticseq1IndentedNode start="(44, 7)" end="(46, 12)">
                                          <NullNode start="(44, 7)" end="(46, 12)">
                                            <OtherNode start="(44, 7)" end="(44, 16)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : (a == x) = true&#10;⊢ countP p (b :: l) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)" state_after="case cons.h_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : a = x&#10;⊢ countP p (b :: l) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)" tactic="simp at h">
                                              <AtomNode start="(44, 7)" end="(44, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(44, 12)" end="(44, 16)">
                                                <OtherNode start="(44, 12)" end="(44, 16)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(44, 12)" end="(44, 14)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(44, 15)" end="(44, 16)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(44, 15)" end="(44, 16)">
                                                      <IdentNode start="(44, 15)" end="(44, 16)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(45, 7)" end="(45, 32)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : a = x&#10;⊢ countP p (b :: l) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)" state_after="case cons.h_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : a = x&#10;⊢ (countP p l + if p b = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p x = true then 1 else 0" tactic="simp [h, ih, countP_cons]">
                                              <AtomNode start="(45, 7)" end="(45, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(45, 12)" end="(45, 32)">
                                                <AtomNode start="(45, 12)" end="(45, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(45, 13)" end="(45, 31)">
                                                  <OtherNode start="(45, 13)" end="(45, 14)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(45, 13)" end="(45, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                  <AtomNode start="(45, 14)" end="(45, 15)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(45, 16)" end="(45, 18)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(45, 16)" end="(45, 18)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                  <AtomNode start="(45, 18)" end="(45, 19)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(45, 20)" end="(45, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(45, 20)" end="(45, 31)" leading="" trailing="" raw_val="countP_cons" val="countP_cons" full_name="List.countP_cons" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(45, 31)" end="(45, 32)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(46, 7)" end="(46, 12)" kind="Lean.Parser.Tactic.omega" state_before="case cons.h_1&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : a = x&#10;⊢ (countP p l + if p b = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p x = true then 1 else 0" state_after="no goals" tactic="omega">
                                              <AtomNode start="(46, 7)" end="(46, 12)" leading="" trailing="&#10;    " val="omega"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(47, 5)" end="(56, 14)" kind="Lean.cdot" state_before="case cons.h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : (a == x) = false&#10;⊢ countP p (x :: l.replace a b) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)" state_after="no goals" tactic="· simp only [beq_eq_false_iff_ne, ne_eq] at h&#10;  simp only [countP_cons, ih, contains_eq_mem, decide_eq_true_eq, mem_cons, h, false_or]&#10;  split &amp;lt;;&amp;gt; rename_i h'&#10;  · by_cases h'' : p a&#10;    · have : countP p l &amp;gt; 0 := countP_pos_iff.mpr ⟨a, h', h''⟩&#10;      simp [h'']&#10;      omega&#10;    · simp [h'']&#10;      omega&#10;  · omega">
                                      <OtherNode start="(47, 5)" end="(47, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(47, 5)" end="(47, 6)" kind="patternIgnore">
                                          <OtherNode start="(47, 5)" end="(47, 6)" kind="token.«· »">
                                            <AtomNode start="(47, 5)" end="(47, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(47, 7)" end="(56, 14)">
                                        <TacticTacticseq1IndentedNode start="(47, 7)" end="(56, 14)">
                                          <NullNode start="(47, 7)" end="(56, 14)">
                                            <OtherNode start="(47, 7)" end="(47, 50)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : (a == x) = false&#10;⊢ countP p (x :: l.replace a b) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)" state_after="case cons.h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;⊢ countP p (x :: l.replace a b) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)" tactic="simp only [beq_eq_false_iff_ne, ne_eq] at h">
                                              <AtomNode start="(47, 7)" end="(47, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(47, 12)" end="(47, 16)">
                                                <AtomNode start="(47, 12)" end="(47, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(47, 17)" end="(47, 45)">
                                                <AtomNode start="(47, 17)" end="(47, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(47, 18)" end="(47, 44)">
                                                  <OtherNode start="(47, 18)" end="(47, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(47, 18)" end="(47, 37)" leading="" trailing="" raw_val="beq_eq_false_iff_ne" val="beq_eq_false_iff_ne" full_name="beq_eq_false_iff_ne" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(47, 37)" end="(47, 38)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(47, 39)" end="(47, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(47, 39)" end="(47, 44)" leading="" trailing="" raw_val="ne_eq" val="ne_eq" full_name="ne_eq" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(47, 44)" end="(47, 45)" leading="" trailing=" " val="]"/>
                                              </NullNode>
                                              <NullNode start="(47, 46)" end="(47, 50)">
                                                <OtherNode start="(47, 46)" end="(47, 50)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(47, 46)" end="(47, 48)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(47, 49)" end="(47, 50)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(47, 49)" end="(47, 50)">
                                                      <IdentNode start="(47, 49)" end="(47, 50)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(48, 7)" end="(48, 93)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;⊢ countP p (x :: l.replace a b) =&#10;    if (x :: l).contains a = true then (countP p (x :: l) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p (x :: l)" state_after="case cons.h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;⊢ ((if a ∈ l then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l) +&#10;      if p x = true then 1 else 0) =&#10;    if a ∈ l then&#10;      ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p l + if p x = true then 1 else 0" tactic="simp only [countP_cons, ih, contains_eq_mem, decide_eq_true_eq, mem_cons, h, false_or]">
                                              <AtomNode start="(48, 7)" end="(48, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(48, 12)" end="(48, 16)">
                                                <AtomNode start="(48, 12)" end="(48, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(48, 17)" end="(48, 93)">
                                                <AtomNode start="(48, 17)" end="(48, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(48, 18)" end="(48, 92)">
                                                  <OtherNode start="(48, 18)" end="(48, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(48, 18)" end="(48, 29)" leading="" trailing="" raw_val="countP_cons" val="countP_cons" full_name="List.countP_cons" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(48, 29)" end="(48, 30)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(48, 31)" end="(48, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(48, 31)" end="(48, 33)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                  <AtomNode start="(48, 33)" end="(48, 34)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(48, 35)" end="(48, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(48, 35)" end="(48, 50)" leading="" trailing="" raw_val="contains_eq_mem" val="contains_eq_mem" full_name="List.contains_eq_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(48, 50)" end="(48, 51)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(48, 52)" end="(48, 69)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(48, 52)" end="(48, 69)" leading="" trailing="" raw_val="decide_eq_true_eq" val="decide_eq_true_eq" full_name="decide_eq_true_eq" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(48, 69)" end="(48, 70)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(48, 71)" end="(48, 79)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(48, 71)" end="(48, 79)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(48, 79)" end="(48, 80)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(48, 81)" end="(48, 82)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(48, 81)" end="(48, 82)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                  <AtomNode start="(48, 82)" end="(48, 83)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(48, 84)" end="(48, 92)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(48, 84)" end="(48, 92)" leading="" trailing="" raw_val="false_or" val="false_or" full_name="false_or" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(48, 92)" end="(48, 93)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(49, 7)" end="(49, 28)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.h_2&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;⊢ ((if a ∈ l then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l) +&#10;      if p x = true then 1 else 0) =&#10;    if a ∈ l then&#10;      ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;    else countP p l + if p x = true then 1 else 0" state_after="case cons.h_2.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;⊢ (((countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;&#10;case cons.h_2.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : ¬a ∈ l&#10;⊢ (countP p l + if p x = true then 1 else 0) = countP p l + if p x = true then 1 else 0" tactic="split &amp;lt;;&amp;gt; rename_i h'">
                                              <OtherNode start="(49, 7)" end="(49, 12)" kind="Lean.Parser.Tactic.split">
                                                <AtomNode start="(49, 7)" end="(49, 12)" leading="" trailing=" " val="split"/>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(49, 13)" end="(49, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                              <OtherNode start="(49, 17)" end="(49, 28)" kind="Lean.Parser.Tactic.renameI">
                                                <AtomNode start="(49, 17)" end="(49, 25)" leading="" trailing=" " val="rename_i"/>
                                                <NullNode start="(49, 26)" end="(49, 28)">
                                                  <LeanBinderidentNode start="(49, 26)" end="(49, 28)">
                                                    <IdentNode start="(49, 26)" end="(49, 28)" leading="" trailing="&#10;      " raw_val="h'" val="h'"/>
                                                  </LeanBinderidentNode>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(50, 7)" end="(55, 16)" kind="Lean.cdot" state_before="case cons.h_2.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;⊢ (((countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;&#10;case cons.h_2.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : ¬a ∈ l&#10;⊢ (countP p l + if p x = true then 1 else 0) = countP p l + if p x = true then 1 else 0" state_after="case cons.h_2.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : ¬a ∈ l&#10;⊢ (countP p l + if p x = true then 1 else 0) = countP p l + if p x = true then 1 else 0" tactic="· by_cases h'' : p a&#10;  · have : countP p l &amp;gt; 0 := countP_pos_iff.mpr ⟨a, h', h''⟩&#10;    simp [h'']&#10;    omega&#10;  · simp [h'']&#10;    omega">
                                              <OtherNode start="(50, 7)" end="(50, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(50, 7)" end="(50, 8)" kind="patternIgnore">
                                                  <OtherNode start="(50, 7)" end="(50, 8)" kind="token.«· »">
                                                    <AtomNode start="(50, 7)" end="(50, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(50, 9)" end="(55, 16)">
                                                <TacticTacticseq1IndentedNode start="(50, 9)" end="(55, 16)">
                                                  <NullNode start="(50, 9)" end="(55, 16)">
                                                    <OtherNode start="(50, 9)" end="(50, 27)" kind="«tacticBy_cases_:_»" state_before="case cons.h_2.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;⊢ (((countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0" state_after="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;h'' : p a = true&#10;⊢ (((countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;h'' : ¬p a = true&#10;⊢ (((countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0" tactic="by_cases h'' : p a">
                                                      <AtomNode start="(50, 9)" end="(50, 17)" leading="" trailing=" " val="by_cases"/>
                                                      <NullNode start="(50, 18)" end="(50, 23)">
                                                        <IdentNode start="(50, 18)" end="(50, 21)" leading="" trailing=" " raw_val="h''" val="h''"/>
                                                        <AtomNode start="(50, 22)" end="(50, 23)" leading="" trailing=" " val=":"/>
                                                      </NullNode>
                                                      <OtherNode start="(50, 24)" end="(50, 27)" kind="Lean.Parser.Term.app">
                                                        <IdentNode start="(50, 24)" end="(50, 25)" leading="" trailing=" " raw_val="p" val="p"/>
                                                        <NullNode start="(50, 26)" end="(50, 27)">
                                                          <IdentNode start="(50, 26)" end="(50, 27)" leading="" trailing="&#10;        " raw_val="a" val="a"/>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(51, 9)" end="(53, 16)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;h'' : p a = true&#10;⊢ (((countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;h'' : ¬p a = true&#10;⊢ (((countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0" state_after="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;h'' : ¬p a = true&#10;⊢ (((countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0" tactic="· have : countP p l &amp;gt; 0 := countP_pos_iff.mpr ⟨a, h', h''⟩&#10;  simp [h'']&#10;  omega">
                                                      <OtherNode start="(51, 9)" end="(51, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(51, 9)" end="(51, 10)" kind="patternIgnore">
                                                          <OtherNode start="(51, 9)" end="(51, 10)" kind="token.«· »">
                                                            <AtomNode start="(51, 9)" end="(51, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(51, 11)" end="(53, 16)">
                                                        <TacticTacticseq1IndentedNode start="(51, 11)" end="(53, 16)">
                                                          <NullNode start="(51, 11)" end="(53, 16)">
                                                            <OtherNode start="(51, 11)" end="(51, 67)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;h'' : p a = true&#10;⊢ (((countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0" state_after="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;h'' : p a = true&#10;this : countP p l &amp;gt; 0&#10;⊢ (((countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0" tactic="have : countP p l &amp;gt; 0 := countP_pos_iff.mpr ⟨a, h', h''⟩">
                                                            <AtomNode start="(51, 11)" end="(51, 15)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(51, 16)" end="(51, 67)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(51, 16)" end="(51, 67)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(51, 16)" end="(51, 16)" kind="Lean.Parser.Term.haveId">
                                                            <OtherNode start="(51, 16)" end="(51, 16)" kind="hygieneInfo">
                                                            <IdentNode start="(51, 16)" end="(51, 16)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(51, 16)" end="(51, 32)">
                                                            <TermTypespecNode start="(51, 16)" end="(51, 32)">
                                                            <AtomNode start="(51, 16)" end="(51, 17)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(51, 18)" end="(51, 32)" kind="«term_&amp;gt;_»">
                                                            <OtherNode start="(51, 18)" end="(51, 28)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(51, 18)" end="(51, 24)" leading="" trailing=" " raw_val="countP" val="countP" full_name="List.countP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            <NullNode start="(51, 25)" end="(51, 28)">
                                                            <IdentNode start="(51, 25)" end="(51, 26)" leading="" trailing=" " raw_val="p" val="p"/>
                                                            <IdentNode start="(51, 27)" end="(51, 28)" leading="" trailing=" " raw_val="l" val="l"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(51, 29)" end="(51, 30)" leading="" trailing=" " val="&amp;gt;"/>
                                                            <OtherNode start="(51, 31)" end="(51, 32)" kind="num">
                                                            <AtomNode start="(51, 31)" end="(51, 32)" leading="" trailing=" " val="0"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(51, 33)" end="(51, 35)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(51, 36)" end="(51, 67)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(51, 36)" end="(51, 54)" leading="" trailing=" " raw_val="countP_pos_iff.mpr" val="countP_pos_iff.mpr"/>
                                                            <NullNode start="(51, 55)" end="(51, 67)">
                                                            <OtherNode start="(51, 55)" end="(51, 67)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(51, 55)" end="(51, 56)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(51, 56)" end="(51, 66)">
                                                            <IdentNode start="(51, 56)" end="(51, 57)" leading="" trailing="" raw_val="a" val="a"/>
                                                            <AtomNode start="(51, 57)" end="(51, 58)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(51, 59)" end="(51, 61)" leading="" trailing="" raw_val="h'" val="h'"/>
                                                            <AtomNode start="(51, 61)" end="(51, 62)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(51, 63)" end="(51, 66)" leading="" trailing="" raw_val="h''" val="h''"/>
                                                            </NullNode>
                                                            <AtomNode start="(51, 66)" end="(51, 67)" leading="" trailing="&#10;          " val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(52, 11)" end="(52, 21)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;h'' : p a = true&#10;this : countP p l &amp;gt; 0&#10;⊢ (((countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0" state_after="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;h'' : p a = true&#10;this : countP p l &amp;gt; 0&#10;⊢ ((countP p l + if p b = true then 1 else 0) - 1 + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - 1" tactic="simp [h'']">
                                                            <AtomNode start="(52, 11)" end="(52, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(52, 16)" end="(52, 21)">
                                                            <AtomNode start="(52, 16)" end="(52, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(52, 17)" end="(52, 20)">
                                                            <OtherNode start="(52, 17)" end="(52, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(52, 17)" end="(52, 20)" leading="" trailing="" raw_val="h''" val="h''"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(52, 20)" end="(52, 21)" leading="" trailing="&#10;          " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(53, 11)" end="(53, 16)" kind="Lean.Parser.Tactic.omega" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;h'' : p a = true&#10;this : countP p l &amp;gt; 0&#10;⊢ ((countP p l + if p b = true then 1 else 0) - 1 + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - 1" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(53, 11)" end="(53, 16)" leading="" trailing="&#10;        " val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(54, 9)" end="(55, 16)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;h'' : ¬p a = true&#10;⊢ (((countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0" state_after="no goals" tactic="· simp [h'']&#10;  omega">
                                                      <OtherNode start="(54, 9)" end="(54, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(54, 9)" end="(54, 10)" kind="patternIgnore">
                                                          <OtherNode start="(54, 9)" end="(54, 10)" kind="token.«· »">
                                                            <AtomNode start="(54, 9)" end="(54, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(54, 11)" end="(55, 16)">
                                                        <TacticTacticseq1IndentedNode start="(54, 11)" end="(55, 16)">
                                                          <NullNode start="(54, 11)" end="(55, 16)">
                                                            <OtherNode start="(54, 11)" end="(54, 21)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;h'' : ¬p a = true&#10;⊢ (((countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    ((countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0) - if p a = true then 1 else 0" state_after="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;h'' : ¬p a = true&#10;⊢ ((countP p l + if p b = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    (countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0" tactic="simp [h'']">
                                                            <AtomNode start="(54, 11)" end="(54, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(54, 16)" end="(54, 21)">
                                                            <AtomNode start="(54, 16)" end="(54, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(54, 17)" end="(54, 20)">
                                                            <OtherNode start="(54, 17)" end="(54, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(54, 17)" end="(54, 20)" leading="" trailing="" raw_val="h''" val="h''"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(54, 20)" end="(54, 21)" leading="" trailing="&#10;          " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(55, 11)" end="(55, 16)" kind="Lean.Parser.Tactic.omega" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : a ∈ l&#10;h'' : ¬p a = true&#10;⊢ ((countP p l + if p b = true then 1 else 0) + if p x = true then 1 else 0) =&#10;    (countP p l + if p x = true then 1 else 0) + if p b = true then 1 else 0" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(55, 11)" end="(55, 16)" leading="" trailing="&#10;      " val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(56, 7)" end="(56, 14)" kind="Lean.cdot" state_before="case cons.h_2.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : ¬a ∈ l&#10;⊢ (countP p l + if p x = true then 1 else 0) = countP p l + if p x = true then 1 else 0" state_after="no goals" tactic="· omega">
                                              <OtherNode start="(56, 7)" end="(56, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(56, 7)" end="(56, 8)" kind="patternIgnore">
                                                  <OtherNode start="(56, 7)" end="(56, 8)" kind="token.«· »">
                                                    <AtomNode start="(56, 7)" end="(56, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(56, 9)" end="(56, 14)">
                                                <TacticTacticseq1IndentedNode start="(56, 9)" end="(56, 14)">
                                                  <NullNode start="(56, 9)" end="(56, 14)">
                                                    <OtherNode start="(56, 9)" end="(56, 14)" kind="Lean.Parser.Tactic.omega" state_before="case cons.h_2.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih :&#10;  countP p (l.replace a b) =&#10;    if l.contains a = true then (countP p l + if p b = true then 1 else 0) - if p a = true then 1 else 0 else countP p l&#10;x✝ : Bool&#10;h : ¬a = x&#10;h' : ¬a ∈ l&#10;⊢ (countP p l + if p x = true then 1 else 0) = countP p l + if p x = true then 1 else 0" state_after="no goals" tactic="omega">
                                                      <AtomNode start="(56, 9)" end="(56, 14)" leading="" trailing="&#10;&#10;" val="omega"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(58, 1)" end="(61, 41)" name="count_replace" full_name="List.count_replace">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(58, 1)" end="(61, 41)" name="count_replace" full_name="List.count_replace" _is_private_decl="False">
        <AtomNode start="(58, 1)" end="(58, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(58, 9)" end="(58, 22)">
          <IdentNode start="(58, 9)" end="(58, 22)" leading="" trailing=" " raw_val="count_replace" val="count_replace"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(58, 23)" end="(60, 108)">
          <NullNode start="(58, 23)" end="(58, 69)">
            <OtherNode start="(58, 23)" end="(58, 30)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(58, 23)" end="(58, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(58, 24)" end="(58, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(58, 24)" end="(58, 27)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(58, 28)" end="(58, 29)">
                  <IdentNode start="(58, 28)" end="(58, 29)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(58, 29)" end="(58, 30)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(58, 31)" end="(58, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(58, 31)" end="(58, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(58, 32)" end="(58, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(58, 32)" end="(58, 41)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(58, 42)" end="(58, 43)">
                  <IdentNode start="(58, 42)" end="(58, 43)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(58, 43)" end="(58, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(58, 45)" end="(58, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(58, 45)" end="(58, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(58, 46)" end="(58, 51)">
                <IdentNode start="(58, 46)" end="(58, 47)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(58, 48)" end="(58, 49)" leading="" trailing=" " raw_val="b" val="b"/>
                <IdentNode start="(58, 50)" end="(58, 51)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(58, 52)" end="(58, 55)">
                <AtomNode start="(58, 52)" end="(58, 53)" leading="" trailing=" " val=":"/>
                <IdentNode start="(58, 54)" end="(58, 55)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(58, 55)" end="(58, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(58, 57)" end="(58, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(58, 57)" end="(58, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(58, 58)" end="(58, 59)">
                <IdentNode start="(58, 58)" end="(58, 59)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(58, 60)" end="(58, 68)">
                <AtomNode start="(58, 60)" end="(58, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(58, 62)" end="(58, 68)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(58, 62)" end="(58, 66)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(58, 67)" end="(58, 68)">
                    <IdentNode start="(58, 67)" end="(58, 68)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(58, 68)" end="(58, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(58, 70)" end="(60, 108)">
            <AtomNode start="(58, 70)" end="(58, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(59, 5)" end="(60, 108)" kind="«term_=_»">
              <OtherNode start="(59, 5)" end="(59, 28)" kind="Lean.Parser.Term.app">
                <OtherNode start="(59, 5)" end="(59, 26)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(59, 5)" end="(59, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(59, 5)" end="(59, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(59, 6)" end="(59, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(59, 6)" end="(59, 15)" leading="" trailing=" " raw_val="l.replace" val="l.replace"/>
                      <NullNode start="(59, 16)" end="(59, 19)">
                        <IdentNode start="(59, 16)" end="(59, 17)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(59, 18)" end="(59, 19)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(59, 19)" end="(59, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(59, 20)" end="(59, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(59, 21)" end="(59, 26)" leading="" trailing=" " raw_val="count" val="count" full_name="List.count" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(59, 27)" end="(59, 28)">
                  <IdentNode start="(59, 27)" end="(59, 28)" leading="" trailing=" " raw_val="c" val="c"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(59, 29)" end="(59, 30)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(60, 7)" end="(60, 108)" kind="termIfThenElse">
                <AtomNode start="(60, 7)" end="(60, 9)" leading="" trailing=" " val="if"/>
                <OtherNode start="(60, 10)" end="(60, 22)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(60, 10)" end="(60, 20)" leading="" trailing=" " raw_val="l.contains" val="l.contains"/>
                  <NullNode start="(60, 21)" end="(60, 22)">
                    <IdentNode start="(60, 21)" end="(60, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(60, 23)" end="(60, 27)" leading="" trailing=" " val="then"/>
                <OtherNode start="(60, 28)" end="(60, 93)" kind="«term_-_»">
                  <OtherNode start="(60, 28)" end="(60, 65)" kind="«term_+_»">
                    <OtherNode start="(60, 28)" end="(60, 37)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(60, 28)" end="(60, 35)" leading="" trailing=" " raw_val="l.count" val="l.count"/>
                      <NullNode start="(60, 36)" end="(60, 37)">
                        <IdentNode start="(60, 36)" end="(60, 37)" leading="" trailing=" " raw_val="c" val="c"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(60, 38)" end="(60, 39)" leading="" trailing=" " val="+"/>
                    <OtherNode start="(60, 40)" end="(60, 65)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(60, 40)" end="(60, 41)" leading="" trailing="" val="("/>
                      <OtherNode start="(60, 41)" end="(60, 64)" kind="termIfThenElse">
                        <AtomNode start="(60, 41)" end="(60, 43)" leading="" trailing=" " val="if"/>
                        <OtherNode start="(60, 44)" end="(60, 50)" kind="«term_==_»">
                          <IdentNode start="(60, 44)" end="(60, 45)" leading="" trailing=" " raw_val="b" val="b"/>
                          <AtomNode start="(60, 46)" end="(60, 48)" leading="" trailing=" " val="=="/>
                          <IdentNode start="(60, 49)" end="(60, 50)" leading="" trailing=" " raw_val="c" val="c"/>
                        </OtherNode>
                        <AtomNode start="(60, 51)" end="(60, 55)" leading="" trailing=" " val="then"/>
                        <OtherNode start="(60, 56)" end="(60, 57)" kind="num">
                          <AtomNode start="(60, 56)" end="(60, 57)" leading="" trailing=" " val="1"/>
                        </OtherNode>
                        <AtomNode start="(60, 58)" end="(60, 62)" leading="" trailing=" " val="else"/>
                        <OtherNode start="(60, 63)" end="(60, 64)" kind="num">
                          <AtomNode start="(60, 63)" end="(60, 64)" leading="" trailing="" val="0"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(60, 64)" end="(60, 65)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(60, 66)" end="(60, 67)" leading="" trailing=" " val="-"/>
                  <OtherNode start="(60, 68)" end="(60, 93)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(60, 68)" end="(60, 69)" leading="" trailing="" val="("/>
                    <OtherNode start="(60, 69)" end="(60, 92)" kind="termIfThenElse">
                      <AtomNode start="(60, 69)" end="(60, 71)" leading="" trailing=" " val="if"/>
                      <OtherNode start="(60, 72)" end="(60, 78)" kind="«term_==_»">
                        <IdentNode start="(60, 72)" end="(60, 73)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(60, 74)" end="(60, 76)" leading="" trailing=" " val="=="/>
                        <IdentNode start="(60, 77)" end="(60, 78)" leading="" trailing=" " raw_val="c" val="c"/>
                      </OtherNode>
                      <AtomNode start="(60, 79)" end="(60, 83)" leading="" trailing=" " val="then"/>
                      <OtherNode start="(60, 84)" end="(60, 85)" kind="num">
                        <AtomNode start="(60, 84)" end="(60, 85)" leading="" trailing=" " val="1"/>
                      </OtherNode>
                      <AtomNode start="(60, 86)" end="(60, 90)" leading="" trailing=" " val="else"/>
                      <OtherNode start="(60, 91)" end="(60, 92)" kind="num">
                        <AtomNode start="(60, 91)" end="(60, 92)" leading="" trailing="" val="0"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(60, 92)" end="(60, 93)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(60, 94)" end="(60, 98)" leading="" trailing=" " val="else"/>
                <OtherNode start="(60, 99)" end="(60, 108)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(60, 99)" end="(60, 106)" leading="" trailing=" " raw_val="l.count" val="l.count"/>
                  <NullNode start="(60, 107)" end="(60, 108)">
                    <IdentNode start="(60, 107)" end="(60, 108)" leading="" trailing=" " raw_val="c" val="c"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(60, 109)" end="(61, 41)">
          <AtomNode start="(60, 109)" end="(60, 111)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(60, 112)" end="(61, 41)">
            <AtomNode start="(60, 112)" end="(60, 114)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(61, 3)" end="(61, 41)">
              <TacticTacticseq1IndentedNode start="(61, 3)" end="(61, 41)">
                <NullNode start="(61, 3)" end="(61, 41)">
                  <OtherNode start="(61, 3)" end="(61, 41)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b c : α&#10;l : List α&#10;⊢ count c (l.replace a b) =&#10;    if l.contains a = true then (count c l + if (b == c) = true then 1 else 0) - if (a == c) = true then 1 else 0&#10;    else count c l" state_after="no goals" tactic="simp [count_eq_countP, countP_replace]">
                    <AtomNode start="(61, 3)" end="(61, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(61, 8)" end="(61, 41)">
                      <AtomNode start="(61, 8)" end="(61, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(61, 9)" end="(61, 40)">
                        <OtherNode start="(61, 9)" end="(61, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(61, 9)" end="(61, 24)" leading="" trailing="" raw_val="count_eq_countP" val="count_eq_countP" full_name="List.count_eq_countP" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                        </OtherNode>
                        <AtomNode start="(61, 24)" end="(61, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(61, 26)" end="(61, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(61, 26)" end="(61, 40)" leading="" trailing="" raw_val="countP_replace" val="countP_replace" full_name="List.countP_replace" mod_name="Init.Data.List.Nat.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Count.lean" def_start="(36, 9)" def_end="(36, 23)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(61, 40)" end="(61, 41)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(63, 1)" end="(81, 20)" name="Sublist.le_countP" full_name="List.Sublist.le_countP">
      <CommandDeclmodifiersNode start="(63, 1)" end="(66, 3)">
        <NullNode start="(63, 1)" end="(66, 3)">
          <CommandDoccommentNode start="(63, 1)" end="(66, 3)" comment="The number of elements satisfying a predicate in a sublist is at least the number of elements satisfying the predicate in the list,&#10;minus the difference in the lengths.&#10;-/">
            <AtomNode start="(63, 1)" end="(63, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(64, 1)" end="(66, 3)" leading="" trailing="&#10;" val="The number of elements satisfying a predicate in a sublist is at least the number of elements satisfying the predicate in the list,&#10;minus the difference in the lengths.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(67, 1)" end="(81, 20)" name="Sublist.le_countP" full_name="List.Sublist.le_countP" _is_private_decl="False">
        <AtomNode start="(67, 1)" end="(67, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(67, 9)" end="(67, 26)">
          <IdentNode start="(67, 9)" end="(67, 26)" leading="" trailing=" " raw_val="Sublist.le_countP" val="Sublist.le_countP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(67, 27)" end="(67, 99)">
          <NullNode start="(67, 27)" end="(67, 45)">
            <TermExplicitbinderNode start="(67, 27)" end="(67, 41)">
              <AtomNode start="(67, 27)" end="(67, 28)" leading="" trailing="" val="("/>
              <NullNode start="(67, 28)" end="(67, 29)">
                <IdentNode start="(67, 28)" end="(67, 29)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(67, 30)" end="(67, 40)">
                <AtomNode start="(67, 30)" end="(67, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(67, 32)" end="(67, 40)" kind="List.«term_&amp;lt;+_»">
                  <IdentNode start="(67, 32)" end="(67, 34)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(67, 35)" end="(67, 37)" leading="" trailing=" " val="&amp;lt;+"/>
                  <IdentNode start="(67, 38)" end="(67, 40)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(67, 40)" end="(67, 41)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(67, 42)" end="(67, 45)">
              <AtomNode start="(67, 42)" end="(67, 43)" leading="" trailing="" val="("/>
              <NullNode start="(67, 43)" end="(67, 44)">
                <IdentNode start="(67, 43)" end="(67, 44)" leading="" trailing="" raw_val="p" val="p"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(67, 44)" end="(67, 45)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(67, 46)" end="(67, 99)">
            <AtomNode start="(67, 46)" end="(67, 47)" leading="" trailing=" " val=":"/>
            <OtherNode start="(67, 48)" end="(67, 99)" kind="«term_≤_»">
              <OtherNode start="(67, 48)" end="(67, 85)" kind="«term_-_»">
                <OtherNode start="(67, 48)" end="(67, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(67, 48)" end="(67, 54)" leading="" trailing=" " raw_val="countP" val="countP" full_name="List.countP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(67, 55)" end="(67, 59)">
                    <IdentNode start="(67, 55)" end="(67, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(67, 57)" end="(67, 59)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(67, 60)" end="(67, 61)" leading="" trailing=" " val="-"/>
                <OtherNode start="(67, 62)" end="(67, 85)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(67, 62)" end="(67, 63)" leading="" trailing="" val="("/>
                  <OtherNode start="(67, 63)" end="(67, 84)" kind="«term_-_»">
                    <IdentNode start="(67, 63)" end="(67, 72)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                    <AtomNode start="(67, 73)" end="(67, 74)" leading="" trailing=" " val="-"/>
                    <IdentNode start="(67, 75)" end="(67, 84)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                  </OtherNode>
                  <AtomNode start="(67, 84)" end="(67, 85)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(67, 86)" end="(67, 87)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(67, 88)" end="(67, 99)" kind="Lean.Parser.Term.app">
                <IdentNode start="(67, 88)" end="(67, 94)" leading="" trailing=" " raw_val="countP" val="countP" full_name="List.countP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(67, 95)" end="(67, 99)">
                  <IdentNode start="(67, 95)" end="(67, 96)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(67, 97)" end="(67, 99)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(67, 100)" end="(81, 20)">
          <AtomNode start="(67, 100)" end="(67, 102)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(67, 103)" end="(81, 20)">
            <AtomNode start="(67, 103)" end="(67, 105)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(68, 3)" end="(81, 20)">
              <TacticTacticseq1IndentedNode start="(68, 3)" end="(81, 20)">
                <NullNode start="(68, 3)" end="(81, 20)">
                  <OtherNode start="(68, 3)" end="(81, 20)" kind="Lean.Parser.Tactic.match" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;s : l₁ &amp;lt;+ l₂&#10;p : α✝ → Bool&#10;⊢ countP p l₂ - (l₂.length - l₁.length) ≤ countP p l₁" state_after="no goals" tactic="match s with&#10;| .slnil =&amp;gt; simp&#10;| .cons a s =&amp;gt;&#10;  rename_i l&#10;  simp only [countP_cons, length_cons]&#10;  have := s.le_countP p&#10;  have := s.length_le&#10;  split &amp;lt;;&amp;gt; omega&#10;| .cons₂ a s =&amp;gt;&#10;  rename_i l₁ l₂&#10;  simp only [countP_cons, length_cons]&#10;  have := s.le_countP p&#10;  have := s.length_le&#10;  split &amp;lt;;&amp;gt; omega">
                    <AtomNode start="(68, 3)" end="(68, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(68, 9)" end="(68, 10)">
                      <OtherNode start="(68, 9)" end="(68, 10)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(68, 9)" end="(68, 10)" leading="" trailing=" " raw_val="s" val="s"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(68, 11)" end="(68, 15)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(69, 3)" end="(81, 20)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(69, 3)" end="(81, 20)">
                        <OtherNode start="(69, 3)" end="(69, 19)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(69, 3)" end="(69, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(69, 5)" end="(69, 11)">
                            <NullNode start="(69, 5)" end="(69, 11)">
                              <OtherNode start="(69, 5)" end="(69, 11)" kind="Lean.Parser.Term.dotIdent">
                                <AtomNode start="(69, 5)" end="(69, 6)" leading="" trailing="" val="."/>
                                <IdentNode start="(69, 6)" end="(69, 11)" leading="" trailing=" " raw_val="slnil" val="slnil"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(69, 12)" end="(69, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(69, 15)" end="(69, 19)">
                            <TacticTacticseq1IndentedNode start="(69, 15)" end="(69, 19)">
                              <NullNode start="(69, 15)" end="(69, 19)">
                                <OtherNode start="(69, 15)" end="(69, 19)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;s : l₁ &amp;lt;+ l₂&#10;p : α✝ → Bool&#10;⊢ countP p [] - ([].length - [].length) ≤ countP p []" state_after="no goals" tactic="simp">
                                  <AtomNode start="(69, 15)" end="(69, 19)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(70, 3)" end="(75, 20)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(70, 3)" end="(70, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(70, 5)" end="(70, 14)">
                            <NullNode start="(70, 5)" end="(70, 14)">
                              <OtherNode start="(70, 5)" end="(70, 14)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(70, 5)" end="(70, 10)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(70, 5)" end="(70, 6)" leading="" trailing="" val="."/>
                                  <IdentNode start="(70, 6)" end="(70, 10)" leading="" trailing=" " raw_val="cons" val="cons"/>
                                </OtherNode>
                                <NullNode start="(70, 11)" end="(70, 14)">
                                  <IdentNode start="(70, 11)" end="(70, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(70, 13)" end="(70, 14)" leading="" trailing=" " raw_val="s" val="s"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(70, 15)" end="(70, 17)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(71, 5)" end="(75, 20)">
                            <TacticTacticseq1IndentedNode start="(71, 5)" end="(75, 20)">
                              <NullNode start="(71, 5)" end="(75, 20)">
                                <OtherNode start="(71, 5)" end="(71, 15)" kind="Lean.Parser.Tactic.renameI" state_before="α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂&#10;p : α✝ → Bool&#10;l₁ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂✝&#10;⊢ countP p (a :: l₂✝) - ((a :: l₂✝).length - l₁.length) ≤ countP p l₁" state_after="α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂&#10;p : α✝ → Bool&#10;l₁ l : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l&#10;⊢ countP p (a :: l) - ((a :: l).length - l₁.length) ≤ countP p l₁" tactic="rename_i l">
                                  <AtomNode start="(71, 5)" end="(71, 13)" leading="" trailing=" " val="rename_i"/>
                                  <NullNode start="(71, 14)" end="(71, 15)">
                                    <LeanBinderidentNode start="(71, 14)" end="(71, 15)">
                                      <IdentNode start="(71, 14)" end="(71, 15)" leading="" trailing="&#10;    " raw_val="l" val="l"/>
                                    </LeanBinderidentNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(72, 5)" end="(72, 41)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂&#10;p : α✝ → Bool&#10;l₁ l : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l&#10;⊢ countP p (a :: l) - ((a :: l).length - l₁.length) ≤ countP p l₁" state_after="α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂&#10;p : α✝ → Bool&#10;l₁ l : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l&#10;⊢ (countP p l + if p a = true then 1 else 0) - (l.length + 1 - l₁.length) ≤ countP p l₁" tactic="simp only [countP_cons, length_cons]">
                                  <AtomNode start="(72, 5)" end="(72, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode start="(72, 10)" end="(72, 14)">
                                    <AtomNode start="(72, 10)" end="(72, 14)" leading="" trailing=" " val="only"/>
                                  </NullNode>
                                  <NullNode start="(72, 15)" end="(72, 41)">
                                    <AtomNode start="(72, 15)" end="(72, 16)" leading="" trailing="" val="["/>
                                    <NullNode start="(72, 16)" end="(72, 40)">
                                      <OtherNode start="(72, 16)" end="(72, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(72, 16)" end="(72, 27)" leading="" trailing="" raw_val="countP_cons" val="countP_cons" full_name="List.countP_cons" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                                      </OtherNode>
                                      <AtomNode start="(72, 27)" end="(72, 28)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(72, 29)" end="(72, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(72, 29)" end="(72, 40)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(72, 40)" end="(72, 41)" leading="" trailing="&#10;    " val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(73, 5)" end="(73, 26)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂&#10;p : α✝ → Bool&#10;l₁ l : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l&#10;⊢ (countP p l + if p a = true then 1 else 0) - (l.length + 1 - l₁.length) ≤ countP p l₁" state_after="α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂&#10;p : α✝ → Bool&#10;l₁ l : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l&#10;this : countP p l - (l.length - l₁.length) ≤ countP p l₁&#10;⊢ (countP p l + if p a = true then 1 else 0) - (l.length + 1 - l₁.length) ≤ countP p l₁" tactic="have := s.le_countP p">
                                  <AtomNode start="(73, 5)" end="(73, 9)" leading="" trailing=" " val="have"/>
                                  <OtherNode start="(73, 10)" end="(73, 26)" kind="Lean.Parser.Term.haveDecl">
                                    <OtherNode start="(73, 10)" end="(73, 26)" kind="Lean.Parser.Term.haveIdDecl">
                                      <OtherNode start="(73, 10)" end="(73, 10)" kind="Lean.Parser.Term.haveId">
                                        <OtherNode start="(73, 10)" end="(73, 10)" kind="hygieneInfo">
                                          <IdentNode start="(73, 10)" end="(73, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <AtomNode start="(73, 10)" end="(73, 12)" leading="" trailing=" " val=":="/>
                                      <OtherNode start="(73, 13)" end="(73, 26)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(73, 13)" end="(73, 24)" leading="" trailing=" " raw_val="s.le_countP" val="s.le_countP"/>
                                        <NullNode start="(73, 25)" end="(73, 26)">
                                          <IdentNode start="(73, 25)" end="(73, 26)" leading="" trailing="&#10;    " raw_val="p" val="p"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(74, 5)" end="(74, 24)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂&#10;p : α✝ → Bool&#10;l₁ l : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l&#10;this : countP p l - (l.length - l₁.length) ≤ countP p l₁&#10;⊢ (countP p l + if p a = true then 1 else 0) - (l.length + 1 - l₁.length) ≤ countP p l₁" state_after="α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂&#10;p : α✝ → Bool&#10;l₁ l : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l&#10;this✝ : countP p l - (l.length - l₁.length) ≤ countP p l₁&#10;this : l₁.length ≤ l.length&#10;⊢ (countP p l + if p a = true then 1 else 0) - (l.length + 1 - l₁.length) ≤ countP p l₁" tactic="have := s.length_le">
                                  <AtomNode start="(74, 5)" end="(74, 9)" leading="" trailing=" " val="have"/>
                                  <OtherNode start="(74, 10)" end="(74, 24)" kind="Lean.Parser.Term.haveDecl">
                                    <OtherNode start="(74, 10)" end="(74, 24)" kind="Lean.Parser.Term.haveIdDecl">
                                      <OtherNode start="(74, 10)" end="(74, 10)" kind="Lean.Parser.Term.haveId">
                                        <OtherNode start="(74, 10)" end="(74, 10)" kind="hygieneInfo">
                                          <IdentNode start="(74, 10)" end="(74, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <AtomNode start="(74, 10)" end="(74, 12)" leading="" trailing=" " val=":="/>
                                      <IdentNode start="(74, 13)" end="(74, 24)" leading="" trailing="&#10;    " raw_val="s.length_le" val="s.length_le"/>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(75, 5)" end="(75, 20)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂&#10;p : α✝ → Bool&#10;l₁ l : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l&#10;this✝ : countP p l - (l.length - l₁.length) ≤ countP p l₁&#10;this : l₁.length ≤ l.length&#10;⊢ (countP p l + if p a = true then 1 else 0) - (l.length + 1 - l₁.length) ≤ countP p l₁" state_after="no goals" tactic="split &amp;lt;;&amp;gt; omega">
                                  <OtherNode start="(75, 5)" end="(75, 10)" kind="Lean.Parser.Tactic.split">
                                    <AtomNode start="(75, 5)" end="(75, 10)" leading="" trailing=" " val="split"/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(75, 11)" end="(75, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                  <OtherNode start="(75, 15)" end="(75, 20)" kind="Lean.Parser.Tactic.omega">
                                    <AtomNode start="(75, 15)" end="(75, 20)" leading="" trailing="&#10;  " val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(76, 3)" end="(81, 20)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(76, 3)" end="(76, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(76, 5)" end="(76, 15)">
                            <NullNode start="(76, 5)" end="(76, 15)">
                              <OtherNode start="(76, 5)" end="(76, 15)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(76, 5)" end="(76, 11)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(76, 5)" end="(76, 6)" leading="" trailing="" val="."/>
                                  <IdentNode start="(76, 6)" end="(76, 11)" leading="" trailing=" " raw_val="cons₂" val="cons₂"/>
                                </OtherNode>
                                <NullNode start="(76, 12)" end="(76, 15)">
                                  <IdentNode start="(76, 12)" end="(76, 13)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(76, 14)" end="(76, 15)" leading="" trailing=" " raw_val="s" val="s"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(76, 16)" end="(76, 18)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(77, 5)" end="(81, 20)">
                            <TacticTacticseq1IndentedNode start="(77, 5)" end="(81, 20)">
                              <NullNode start="(77, 5)" end="(81, 20)">
                                <OtherNode start="(77, 5)" end="(77, 19)" kind="Lean.Parser.Tactic.renameI" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;s✝ : l₁ &amp;lt;+ l₂&#10;p : α✝ → Bool&#10;l₁✝ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁✝ &amp;lt;+ l₂✝&#10;⊢ countP p (a :: l₂✝) - ((a :: l₂✝).length - (a :: l₁✝).length) ≤ countP p (a :: l₁✝)" state_after="α✝ : Type u_1&#10;l₁✝ l₂✝ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂✝&#10;p : α✝ → Bool&#10;l₁ l₂ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂&#10;⊢ countP p (a :: l₂) - ((a :: l₂).length - (a :: l₁).length) ≤ countP p (a :: l₁)" tactic="rename_i l₁ l₂">
                                  <AtomNode start="(77, 5)" end="(77, 13)" leading="" trailing=" " val="rename_i"/>
                                  <NullNode start="(77, 14)" end="(77, 19)">
                                    <LeanBinderidentNode start="(77, 14)" end="(77, 16)">
                                      <IdentNode start="(77, 14)" end="(77, 16)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                    </LeanBinderidentNode>
                                    <LeanBinderidentNode start="(77, 17)" end="(77, 19)">
                                      <IdentNode start="(77, 17)" end="(77, 19)" leading="" trailing="&#10;    " raw_val="l₂" val="l₂"/>
                                    </LeanBinderidentNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(78, 5)" end="(78, 41)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;l₁✝ l₂✝ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂✝&#10;p : α✝ → Bool&#10;l₁ l₂ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂&#10;⊢ countP p (a :: l₂) - ((a :: l₂).length - (a :: l₁).length) ≤ countP p (a :: l₁)" state_after="α✝ : Type u_1&#10;l₁✝ l₂✝ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂✝&#10;p : α✝ → Bool&#10;l₁ l₂ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂&#10;⊢ (countP p l₂ + if p a = true then 1 else 0) - (l₂.length + 1 - (l₁.length + 1)) ≤&#10;    countP p l₁ + if p a = true then 1 else 0" tactic="simp only [countP_cons, length_cons]">
                                  <AtomNode start="(78, 5)" end="(78, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode start="(78, 10)" end="(78, 14)">
                                    <AtomNode start="(78, 10)" end="(78, 14)" leading="" trailing=" " val="only"/>
                                  </NullNode>
                                  <NullNode start="(78, 15)" end="(78, 41)">
                                    <AtomNode start="(78, 15)" end="(78, 16)" leading="" trailing="" val="["/>
                                    <NullNode start="(78, 16)" end="(78, 40)">
                                      <OtherNode start="(78, 16)" end="(78, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(78, 16)" end="(78, 27)" leading="" trailing="" raw_val="countP_cons" val="countP_cons" full_name="List.countP_cons" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                                      </OtherNode>
                                      <AtomNode start="(78, 27)" end="(78, 28)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(78, 29)" end="(78, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(78, 29)" end="(78, 40)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(78, 40)" end="(78, 41)" leading="" trailing="&#10;    " val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(79, 5)" end="(79, 26)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α✝ : Type u_1&#10;l₁✝ l₂✝ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂✝&#10;p : α✝ → Bool&#10;l₁ l₂ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂&#10;⊢ (countP p l₂ + if p a = true then 1 else 0) - (l₂.length + 1 - (l₁.length + 1)) ≤&#10;    countP p l₁ + if p a = true then 1 else 0" state_after="α✝ : Type u_1&#10;l₁✝ l₂✝ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂✝&#10;p : α✝ → Bool&#10;l₁ l₂ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂&#10;this : countP p l₂ - (l₂.length - l₁.length) ≤ countP p l₁&#10;⊢ (countP p l₂ + if p a = true then 1 else 0) - (l₂.length + 1 - (l₁.length + 1)) ≤&#10;    countP p l₁ + if p a = true then 1 else 0" tactic="have := s.le_countP p">
                                  <AtomNode start="(79, 5)" end="(79, 9)" leading="" trailing=" " val="have"/>
                                  <OtherNode start="(79, 10)" end="(79, 26)" kind="Lean.Parser.Term.haveDecl">
                                    <OtherNode start="(79, 10)" end="(79, 26)" kind="Lean.Parser.Term.haveIdDecl">
                                      <OtherNode start="(79, 10)" end="(79, 10)" kind="Lean.Parser.Term.haveId">
                                        <OtherNode start="(79, 10)" end="(79, 10)" kind="hygieneInfo">
                                          <IdentNode start="(79, 10)" end="(79, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <AtomNode start="(79, 10)" end="(79, 12)" leading="" trailing=" " val=":="/>
                                      <OtherNode start="(79, 13)" end="(79, 26)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(79, 13)" end="(79, 24)" leading="" trailing=" " raw_val="s.le_countP" val="s.le_countP"/>
                                        <NullNode start="(79, 25)" end="(79, 26)">
                                          <IdentNode start="(79, 25)" end="(79, 26)" leading="" trailing="&#10;    " raw_val="p" val="p"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(80, 5)" end="(80, 24)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α✝ : Type u_1&#10;l₁✝ l₂✝ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂✝&#10;p : α✝ → Bool&#10;l₁ l₂ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂&#10;this : countP p l₂ - (l₂.length - l₁.length) ≤ countP p l₁&#10;⊢ (countP p l₂ + if p a = true then 1 else 0) - (l₂.length + 1 - (l₁.length + 1)) ≤&#10;    countP p l₁ + if p a = true then 1 else 0" state_after="α✝ : Type u_1&#10;l₁✝ l₂✝ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂✝&#10;p : α✝ → Bool&#10;l₁ l₂ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂&#10;this✝ : countP p l₂ - (l₂.length - l₁.length) ≤ countP p l₁&#10;this : l₁.length ≤ l₂.length&#10;⊢ (countP p l₂ + if p a = true then 1 else 0) - (l₂.length + 1 - (l₁.length + 1)) ≤&#10;    countP p l₁ + if p a = true then 1 else 0" tactic="have := s.length_le">
                                  <AtomNode start="(80, 5)" end="(80, 9)" leading="" trailing=" " val="have"/>
                                  <OtherNode start="(80, 10)" end="(80, 24)" kind="Lean.Parser.Term.haveDecl">
                                    <OtherNode start="(80, 10)" end="(80, 24)" kind="Lean.Parser.Term.haveIdDecl">
                                      <OtherNode start="(80, 10)" end="(80, 10)" kind="Lean.Parser.Term.haveId">
                                        <OtherNode start="(80, 10)" end="(80, 10)" kind="hygieneInfo">
                                          <IdentNode start="(80, 10)" end="(80, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <AtomNode start="(80, 10)" end="(80, 12)" leading="" trailing=" " val=":="/>
                                      <IdentNode start="(80, 13)" end="(80, 24)" leading="" trailing="&#10;    " raw_val="s.length_le" val="s.length_le"/>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(81, 5)" end="(81, 20)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α✝ : Type u_1&#10;l₁✝ l₂✝ : List α✝&#10;s✝ : l₁✝ &amp;lt;+ l₂✝&#10;p : α✝ → Bool&#10;l₁ l₂ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂&#10;this✝ : countP p l₂ - (l₂.length - l₁.length) ≤ countP p l₁&#10;this : l₁.length ≤ l₂.length&#10;⊢ (countP p l₂ + if p a = true then 1 else 0) - (l₂.length + 1 - (l₁.length + 1)) ≤&#10;    countP p l₁ + if p a = true then 1 else 0" state_after="no goals" tactic="split &amp;lt;;&amp;gt; omega">
                                  <OtherNode start="(81, 5)" end="(81, 10)" kind="Lean.Parser.Tactic.split">
                                    <AtomNode start="(81, 5)" end="(81, 10)" leading="" trailing=" " val="split"/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(81, 11)" end="(81, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                  <OtherNode start="(81, 15)" end="(81, 20)" kind="Lean.Parser.Tactic.omega">
                                    <AtomNode start="(81, 15)" end="(81, 20)" leading="" trailing="&#10;&#10;" val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(83, 1)" end="(84, 24)" name="IsPrefix.le_countP" full_name="List.IsPrefix.le_countP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(83, 1)" end="(84, 24)" name="IsPrefix.le_countP" full_name="List.IsPrefix.le_countP" _is_private_decl="False">
        <AtomNode start="(83, 1)" end="(83, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(83, 9)" end="(83, 27)">
          <IdentNode start="(83, 9)" end="(83, 27)" leading="" trailing=" " raw_val="IsPrefix.le_countP" val="IsPrefix.le_countP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(83, 28)" end="(83, 97)">
          <NullNode start="(83, 28)" end="(83, 43)">
            <TermExplicitbinderNode start="(83, 28)" end="(83, 43)">
              <AtomNode start="(83, 28)" end="(83, 29)" leading="" trailing="" val="("/>
              <NullNode start="(83, 29)" end="(83, 30)">
                <IdentNode start="(83, 29)" end="(83, 30)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(83, 31)" end="(83, 42)">
                <AtomNode start="(83, 31)" end="(83, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(83, 33)" end="(83, 42)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(83, 33)" end="(83, 35)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(83, 36)" end="(83, 39)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(83, 40)" end="(83, 42)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(83, 42)" end="(83, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(83, 44)" end="(83, 97)">
            <AtomNode start="(83, 44)" end="(83, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(83, 46)" end="(83, 97)" kind="«term_≤_»">
              <OtherNode start="(83, 46)" end="(83, 83)" kind="«term_-_»">
                <OtherNode start="(83, 46)" end="(83, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(83, 46)" end="(83, 52)" leading="" trailing=" " raw_val="countP" val="countP" full_name="List.countP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(83, 53)" end="(83, 57)">
                    <IdentNode start="(83, 53)" end="(83, 54)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(83, 55)" end="(83, 57)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(83, 58)" end="(83, 59)" leading="" trailing=" " val="-"/>
                <OtherNode start="(83, 60)" end="(83, 83)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(83, 60)" end="(83, 61)" leading="" trailing="" val="("/>
                  <OtherNode start="(83, 61)" end="(83, 82)" kind="«term_-_»">
                    <IdentNode start="(83, 61)" end="(83, 70)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                    <AtomNode start="(83, 71)" end="(83, 72)" leading="" trailing=" " val="-"/>
                    <IdentNode start="(83, 73)" end="(83, 82)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                  </OtherNode>
                  <AtomNode start="(83, 82)" end="(83, 83)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(83, 84)" end="(83, 85)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(83, 86)" end="(83, 97)" kind="Lean.Parser.Term.app">
                <IdentNode start="(83, 86)" end="(83, 92)" leading="" trailing=" " raw_val="countP" val="countP" full_name="List.countP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(83, 93)" end="(83, 97)">
                  <IdentNode start="(83, 93)" end="(83, 94)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(83, 95)" end="(83, 97)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(83, 98)" end="(84, 24)">
          <AtomNode start="(83, 98)" end="(83, 100)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(84, 3)" end="(84, 24)" kind="Lean.Parser.Term.app">
            <IdentNode start="(84, 3)" end="(84, 22)" leading="" trailing=" " raw_val="s.sublist.le_countP" val="s.sublist.le_countP"/>
            <NullNode start="(84, 23)" end="(84, 24)">
              <TermHoleNode start="(84, 23)" end="(84, 24)">
                <AtomNode start="(84, 23)" end="(84, 24)" leading="" trailing="&#10;&#10;" val="_"/>
              </TermHoleNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(86, 1)" end="(87, 24)" name="IsSuffix.le_countP" full_name="List.IsSuffix.le_countP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(86, 1)" end="(87, 24)" name="IsSuffix.le_countP" full_name="List.IsSuffix.le_countP" _is_private_decl="False">
        <AtomNode start="(86, 1)" end="(86, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(86, 9)" end="(86, 27)">
          <IdentNode start="(86, 9)" end="(86, 27)" leading="" trailing=" " raw_val="IsSuffix.le_countP" val="IsSuffix.le_countP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(86, 28)" end="(86, 97)">
          <NullNode start="(86, 28)" end="(86, 43)">
            <TermExplicitbinderNode start="(86, 28)" end="(86, 43)">
              <AtomNode start="(86, 28)" end="(86, 29)" leading="" trailing="" val="("/>
              <NullNode start="(86, 29)" end="(86, 30)">
                <IdentNode start="(86, 29)" end="(86, 30)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(86, 31)" end="(86, 42)">
                <AtomNode start="(86, 31)" end="(86, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(86, 33)" end="(86, 42)" kind="List.«term_&amp;lt;:+_»">
                  <IdentNode start="(86, 33)" end="(86, 35)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(86, 36)" end="(86, 39)" leading="" trailing=" " val="&amp;lt;:+"/>
                  <IdentNode start="(86, 40)" end="(86, 42)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(86, 42)" end="(86, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(86, 44)" end="(86, 97)">
            <AtomNode start="(86, 44)" end="(86, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(86, 46)" end="(86, 97)" kind="«term_≤_»">
              <OtherNode start="(86, 46)" end="(86, 83)" kind="«term_-_»">
                <OtherNode start="(86, 46)" end="(86, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(86, 46)" end="(86, 52)" leading="" trailing=" " raw_val="countP" val="countP" full_name="List.countP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(86, 53)" end="(86, 57)">
                    <IdentNode start="(86, 53)" end="(86, 54)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(86, 55)" end="(86, 57)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(86, 58)" end="(86, 59)" leading="" trailing=" " val="-"/>
                <OtherNode start="(86, 60)" end="(86, 83)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(86, 60)" end="(86, 61)" leading="" trailing="" val="("/>
                  <OtherNode start="(86, 61)" end="(86, 82)" kind="«term_-_»">
                    <IdentNode start="(86, 61)" end="(86, 70)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                    <AtomNode start="(86, 71)" end="(86, 72)" leading="" trailing=" " val="-"/>
                    <IdentNode start="(86, 73)" end="(86, 82)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                  </OtherNode>
                  <AtomNode start="(86, 82)" end="(86, 83)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(86, 84)" end="(86, 85)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(86, 86)" end="(86, 97)" kind="Lean.Parser.Term.app">
                <IdentNode start="(86, 86)" end="(86, 92)" leading="" trailing=" " raw_val="countP" val="countP" full_name="List.countP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(86, 93)" end="(86, 97)">
                  <IdentNode start="(86, 93)" end="(86, 94)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(86, 95)" end="(86, 97)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(86, 98)" end="(87, 24)">
          <AtomNode start="(86, 98)" end="(86, 100)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(87, 3)" end="(87, 24)" kind="Lean.Parser.Term.app">
            <IdentNode start="(87, 3)" end="(87, 22)" leading="" trailing=" " raw_val="s.sublist.le_countP" val="s.sublist.le_countP"/>
            <NullNode start="(87, 23)" end="(87, 24)">
              <TermHoleNode start="(87, 23)" end="(87, 24)">
                <AtomNode start="(87, 23)" end="(87, 24)" leading="" trailing="&#10;&#10;" val="_"/>
              </TermHoleNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(89, 1)" end="(90, 24)" name="IsInfix.le_countP" full_name="List.IsInfix.le_countP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(89, 1)" end="(90, 24)" name="IsInfix.le_countP" full_name="List.IsInfix.le_countP" _is_private_decl="False">
        <AtomNode start="(89, 1)" end="(89, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(89, 9)" end="(89, 26)">
          <IdentNode start="(89, 9)" end="(89, 26)" leading="" trailing=" " raw_val="IsInfix.le_countP" val="IsInfix.le_countP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(89, 27)" end="(89, 97)">
          <NullNode start="(89, 27)" end="(89, 43)">
            <TermExplicitbinderNode start="(89, 27)" end="(89, 43)">
              <AtomNode start="(89, 27)" end="(89, 28)" leading="" trailing="" val="("/>
              <NullNode start="(89, 28)" end="(89, 29)">
                <IdentNode start="(89, 28)" end="(89, 29)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(89, 30)" end="(89, 42)">
                <AtomNode start="(89, 30)" end="(89, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(89, 32)" end="(89, 42)" kind="List.«term_&amp;lt;:+:_»">
                  <IdentNode start="(89, 32)" end="(89, 34)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(89, 35)" end="(89, 39)" leading="" trailing=" " val="&amp;lt;:+:"/>
                  <IdentNode start="(89, 40)" end="(89, 42)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(89, 42)" end="(89, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(89, 44)" end="(89, 97)">
            <AtomNode start="(89, 44)" end="(89, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(89, 46)" end="(89, 97)" kind="«term_≤_»">
              <OtherNode start="(89, 46)" end="(89, 83)" kind="«term_-_»">
                <OtherNode start="(89, 46)" end="(89, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(89, 46)" end="(89, 52)" leading="" trailing=" " raw_val="countP" val="countP" full_name="List.countP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(89, 53)" end="(89, 57)">
                    <IdentNode start="(89, 53)" end="(89, 54)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(89, 55)" end="(89, 57)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(89, 58)" end="(89, 59)" leading="" trailing=" " val="-"/>
                <OtherNode start="(89, 60)" end="(89, 83)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(89, 60)" end="(89, 61)" leading="" trailing="" val="("/>
                  <OtherNode start="(89, 61)" end="(89, 82)" kind="«term_-_»">
                    <IdentNode start="(89, 61)" end="(89, 70)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                    <AtomNode start="(89, 71)" end="(89, 72)" leading="" trailing=" " val="-"/>
                    <IdentNode start="(89, 73)" end="(89, 82)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                  </OtherNode>
                  <AtomNode start="(89, 82)" end="(89, 83)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(89, 84)" end="(89, 85)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(89, 86)" end="(89, 97)" kind="Lean.Parser.Term.app">
                <IdentNode start="(89, 86)" end="(89, 92)" leading="" trailing=" " raw_val="countP" val="countP" full_name="List.countP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(89, 93)" end="(89, 97)">
                  <IdentNode start="(89, 93)" end="(89, 94)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(89, 95)" end="(89, 97)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(89, 98)" end="(90, 24)">
          <AtomNode start="(89, 98)" end="(89, 100)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(90, 3)" end="(90, 24)" kind="Lean.Parser.Term.app">
            <IdentNode start="(90, 3)" end="(90, 22)" leading="" trailing=" " raw_val="s.sublist.le_countP" val="s.sublist.le_countP"/>
            <NullNode start="(90, 23)" end="(90, 24)">
              <TermHoleNode start="(90, 23)" end="(90, 24)">
                <AtomNode start="(90, 23)" end="(90, 24)" leading="" trailing="&#10;&#10;" val="_"/>
              </TermHoleNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(92, 1)" end="(99, 8)" name="le_countP_tail" full_name="List.le_countP_tail">
      <CommandDeclmodifiersNode start="(92, 1)" end="(95, 3)">
        <NullNode start="(92, 1)" end="(95, 3)">
          <CommandDoccommentNode start="(92, 1)" end="(95, 3)" comment="The number of elements satisfying a predicate in the tail of a list is&#10;at least one less than the number of elements satisfying the predicate in the list.&#10;-/">
            <AtomNode start="(92, 1)" end="(92, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(93, 1)" end="(95, 3)" leading="" trailing="&#10;" val="The number of elements satisfying a predicate in the tail of a list is&#10;at least one less than the number of elements satisfying the predicate in the list.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(96, 1)" end="(99, 8)" name="le_countP_tail" full_name="List.le_countP_tail" _is_private_decl="False">
        <AtomNode start="(96, 1)" end="(96, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(96, 9)" end="(96, 23)">
          <IdentNode start="(96, 9)" end="(96, 23)" leading="" trailing=" " raw_val="le_countP_tail" val="le_countP_tail"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(96, 24)" end="(96, 62)">
          <NullNode start="(96, 24)" end="(96, 27)">
            <OtherNode start="(96, 24)" end="(96, 27)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(96, 24)" end="(96, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(96, 25)" end="(96, 26)">
                <IdentNode start="(96, 25)" end="(96, 26)" leading="" trailing="" raw_val="l" val="l"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(96, 26)" end="(96, 27)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(96, 28)" end="(96, 62)">
            <AtomNode start="(96, 28)" end="(96, 29)" leading="" trailing=" " val=":"/>
            <OtherNode start="(96, 30)" end="(96, 62)" kind="«term_≤_»">
              <OtherNode start="(96, 30)" end="(96, 44)" kind="«term_-_»">
                <OtherNode start="(96, 30)" end="(96, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(96, 30)" end="(96, 36)" leading="" trailing=" " raw_val="countP" val="countP" full_name="List.countP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(96, 37)" end="(96, 40)">
                    <IdentNode start="(96, 37)" end="(96, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(96, 39)" end="(96, 40)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(96, 41)" end="(96, 42)" leading="" trailing=" " val="-"/>
                <OtherNode start="(96, 43)" end="(96, 44)" kind="num">
                  <AtomNode start="(96, 43)" end="(96, 44)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(96, 45)" end="(96, 46)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(96, 47)" end="(96, 62)" kind="Lean.Parser.Term.app">
                <IdentNode start="(96, 47)" end="(96, 53)" leading="" trailing=" " raw_val="countP" val="countP" full_name="List.countP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(96, 54)" end="(96, 62)">
                  <IdentNode start="(96, 54)" end="(96, 55)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(96, 56)" end="(96, 62)" leading="" trailing=" " raw_val="l.tail" val="l.tail"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(96, 63)" end="(99, 8)">
          <AtomNode start="(96, 63)" end="(96, 65)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(96, 66)" end="(99, 8)">
            <AtomNode start="(96, 66)" end="(96, 68)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(97, 3)" end="(99, 8)">
              <TacticTacticseq1IndentedNode start="(97, 3)" end="(99, 8)">
                <NullNode start="(97, 3)" end="(99, 8)">
                  <OtherNode start="(97, 3)" end="(97, 39)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;l : List α✝&#10;⊢ countP p l - 1 ≤ countP p l.tail" state_after="α✝ : Type u_1&#10;p : α✝ → Bool&#10;l : List α✝&#10;this : countP p l - (l.length - l.tail.length) ≤ countP p l.tail&#10;⊢ countP p l - 1 ≤ countP p l.tail" tactic="have := (tail_sublist l).le_countP p">
                    <AtomNode start="(97, 3)" end="(97, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(97, 8)" end="(97, 39)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(97, 8)" end="(97, 39)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(97, 8)" end="(97, 8)" kind="Lean.Parser.Term.haveId">
                          <OtherNode start="(97, 8)" end="(97, 8)" kind="hygieneInfo">
                            <IdentNode start="(97, 8)" end="(97, 8)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                          </OtherNode>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(97, 8)" end="(97, 10)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(97, 11)" end="(97, 39)" kind="Lean.Parser.Term.app">
                          <OtherNode start="(97, 11)" end="(97, 37)" kind="Lean.Parser.Term.proj">
                            <OtherNode start="(97, 11)" end="(97, 27)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(97, 11)" end="(97, 12)" leading="" trailing="" val="("/>
                              <OtherNode start="(97, 12)" end="(97, 26)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(97, 12)" end="(97, 24)" leading="" trailing=" " raw_val="tail_sublist" val="tail_sublist" full_name="List.tail_sublist" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                <NullNode start="(97, 25)" end="(97, 26)">
                                  <IdentNode start="(97, 25)" end="(97, 26)" leading="" trailing="" raw_val="l" val="l"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(97, 26)" end="(97, 27)" leading="" trailing="" val=")"/>
                            </OtherNode>
                            <AtomNode start="(97, 27)" end="(97, 28)" leading="" trailing="" val="."/>
                            <IdentNode start="(97, 28)" end="(97, 37)" leading="" trailing=" " raw_val="le_countP" val="le_countP" full_name="List.Sublist.le_countP" mod_name="Init.Data.List.Nat.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Count.lean" def_start="(67, 9)" def_end="(67, 26)"/>
                          </OtherNode>
                          <NullNode start="(97, 38)" end="(97, 39)">
                            <IdentNode start="(97, 38)" end="(97, 39)" leading="" trailing="&#10;  " raw_val="p" val="p"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(98, 3)" end="(98, 34)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;l : List α✝&#10;this : countP p l - (l.length - l.tail.length) ≤ countP p l.tail&#10;⊢ countP p l - 1 ≤ countP p l.tail" state_after="α✝ : Type u_1&#10;p : α✝ → Bool&#10;l : List α✝&#10;this : countP p l - (l.length - (l.length - 1)) ≤ countP p l.tail&#10;⊢ countP p l - 1 ≤ countP p l.tail" tactic="simp only [length_tail] at this">
                    <AtomNode start="(98, 3)" end="(98, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(98, 8)" end="(98, 12)">
                      <AtomNode start="(98, 8)" end="(98, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(98, 13)" end="(98, 26)">
                      <AtomNode start="(98, 13)" end="(98, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(98, 14)" end="(98, 25)">
                        <OtherNode start="(98, 14)" end="(98, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(98, 14)" end="(98, 25)" leading="" trailing="" raw_val="length_tail" val="length_tail" full_name="List.length_tail" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(98, 25)" end="(98, 26)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(98, 27)" end="(98, 34)">
                      <OtherNode start="(98, 27)" end="(98, 34)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(98, 27)" end="(98, 29)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(98, 30)" end="(98, 34)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(98, 30)" end="(98, 34)">
                            <IdentNode start="(98, 30)" end="(98, 34)" leading="" trailing="&#10;  " raw_val="this" val="this"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(99, 3)" end="(99, 8)" kind="Lean.Parser.Tactic.omega" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;l : List α✝&#10;this : countP p l - (l.length - (l.length - 1)) ≤ countP p l.tail&#10;⊢ countP p l - 1 ≤ countP p l.tail" state_after="no goals" tactic="omega">
                    <AtomNode start="(99, 3)" end="(99, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(101, 1)" end="(101, 17)" kind="Lean.Parser.Command.variable">
      <AtomNode start="(101, 1)" end="(101, 9)" leading="" trailing=" " val="variable"/>
      <NullNode start="(101, 10)" end="(101, 17)">
        <OtherNode start="(101, 10)" end="(101, 17)" kind="Lean.Parser.Term.instBinder">
          <AtomNode start="(101, 10)" end="(101, 11)" leading="" trailing="" val="["/>
          <NullNode/>
          <OtherNode start="(101, 11)" end="(101, 16)" kind="Lean.Parser.Term.app">
            <IdentNode start="(101, 11)" end="(101, 14)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode start="(101, 15)" end="(101, 16)">
              <IdentNode start="(101, 15)" end="(101, 16)" leading="" trailing="" raw_val="α" val="α"/>
            </NullNode>
          </OtherNode>
          <AtomNode start="(101, 16)" end="(101, 17)" leading="" trailing="&#10;&#10;" val="]"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(103, 1)" end="(104, 16)" name="Sublist.le_count" full_name="List.Sublist.le_count">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(103, 1)" end="(104, 16)" name="Sublist.le_count" full_name="List.Sublist.le_count" _is_private_decl="False">
        <AtomNode start="(103, 1)" end="(103, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(103, 9)" end="(103, 25)">
          <IdentNode start="(103, 9)" end="(103, 25)" leading="" trailing=" " raw_val="Sublist.le_count" val="Sublist.le_count"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(103, 26)" end="(103, 100)">
          <NullNode start="(103, 26)" end="(103, 48)">
            <TermExplicitbinderNode start="(103, 26)" end="(103, 40)">
              <AtomNode start="(103, 26)" end="(103, 27)" leading="" trailing="" val="("/>
              <NullNode start="(103, 27)" end="(103, 28)">
                <IdentNode start="(103, 27)" end="(103, 28)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(103, 29)" end="(103, 39)">
                <AtomNode start="(103, 29)" end="(103, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(103, 31)" end="(103, 39)" kind="List.«term_&amp;lt;+_»">
                  <IdentNode start="(103, 31)" end="(103, 33)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(103, 34)" end="(103, 36)" leading="" trailing=" " val="&amp;lt;+"/>
                  <IdentNode start="(103, 37)" end="(103, 39)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(103, 39)" end="(103, 40)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(103, 41)" end="(103, 48)">
              <AtomNode start="(103, 41)" end="(103, 42)" leading="" trailing="" val="("/>
              <NullNode start="(103, 42)" end="(103, 43)">
                <IdentNode start="(103, 42)" end="(103, 43)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(103, 44)" end="(103, 47)">
                <AtomNode start="(103, 44)" end="(103, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(103, 46)" end="(103, 47)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(103, 47)" end="(103, 48)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(103, 49)" end="(103, 100)">
            <AtomNode start="(103, 49)" end="(103, 50)" leading="" trailing=" " val=":"/>
            <OtherNode start="(103, 51)" end="(103, 100)" kind="«term_≤_»">
              <OtherNode start="(103, 51)" end="(103, 87)" kind="«term_-_»">
                <OtherNode start="(103, 51)" end="(103, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(103, 51)" end="(103, 56)" leading="" trailing=" " raw_val="count" val="count" full_name="List.count" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(103, 57)" end="(103, 61)">
                    <IdentNode start="(103, 57)" end="(103, 58)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(103, 59)" end="(103, 61)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(103, 62)" end="(103, 63)" leading="" trailing=" " val="-"/>
                <OtherNode start="(103, 64)" end="(103, 87)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(103, 64)" end="(103, 65)" leading="" trailing="" val="("/>
                  <OtherNode start="(103, 65)" end="(103, 86)" kind="«term_-_»">
                    <IdentNode start="(103, 65)" end="(103, 74)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                    <AtomNode start="(103, 75)" end="(103, 76)" leading="" trailing=" " val="-"/>
                    <IdentNode start="(103, 77)" end="(103, 86)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                  </OtherNode>
                  <AtomNode start="(103, 86)" end="(103, 87)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(103, 88)" end="(103, 89)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(103, 90)" end="(103, 100)" kind="Lean.Parser.Term.app">
                <IdentNode start="(103, 90)" end="(103, 95)" leading="" trailing=" " raw_val="count" val="count" full_name="List.count" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(103, 96)" end="(103, 100)">
                  <IdentNode start="(103, 96)" end="(103, 97)" leading="" trailing=" " raw_val="a" val="a"/>
                  <IdentNode start="(103, 98)" end="(103, 100)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(103, 101)" end="(104, 16)">
          <AtomNode start="(103, 101)" end="(103, 103)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(104, 3)" end="(104, 16)" kind="Lean.Parser.Term.app">
            <IdentNode start="(104, 3)" end="(104, 14)" leading="" trailing=" " raw_val="s.le_countP" val="s.le_countP"/>
            <NullNode start="(104, 15)" end="(104, 16)">
              <TermHoleNode start="(104, 15)" end="(104, 16)">
                <AtomNode start="(104, 15)" end="(104, 16)" leading="" trailing="&#10;&#10;" val="_"/>
              </TermHoleNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(106, 1)" end="(107, 23)" name="IsPrefix.le_count" full_name="List.IsPrefix.le_count">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(106, 1)" end="(107, 23)" name="IsPrefix.le_count" full_name="List.IsPrefix.le_count" _is_private_decl="False">
        <AtomNode start="(106, 1)" end="(106, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(106, 9)" end="(106, 26)">
          <IdentNode start="(106, 9)" end="(106, 26)" leading="" trailing=" " raw_val="IsPrefix.le_count" val="IsPrefix.le_count"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(106, 27)" end="(106, 102)">
          <NullNode start="(106, 27)" end="(106, 50)">
            <TermExplicitbinderNode start="(106, 27)" end="(106, 42)">
              <AtomNode start="(106, 27)" end="(106, 28)" leading="" trailing="" val="("/>
              <NullNode start="(106, 28)" end="(106, 29)">
                <IdentNode start="(106, 28)" end="(106, 29)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(106, 30)" end="(106, 41)">
                <AtomNode start="(106, 30)" end="(106, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(106, 32)" end="(106, 41)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(106, 32)" end="(106, 34)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(106, 35)" end="(106, 38)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(106, 39)" end="(106, 41)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(106, 41)" end="(106, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(106, 43)" end="(106, 50)">
              <AtomNode start="(106, 43)" end="(106, 44)" leading="" trailing="" val="("/>
              <NullNode start="(106, 44)" end="(106, 45)">
                <IdentNode start="(106, 44)" end="(106, 45)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(106, 46)" end="(106, 49)">
                <AtomNode start="(106, 46)" end="(106, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(106, 48)" end="(106, 49)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(106, 49)" end="(106, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(106, 51)" end="(106, 102)">
            <AtomNode start="(106, 51)" end="(106, 52)" leading="" trailing=" " val=":"/>
            <OtherNode start="(106, 53)" end="(106, 102)" kind="«term_≤_»">
              <OtherNode start="(106, 53)" end="(106, 89)" kind="«term_-_»">
                <OtherNode start="(106, 53)" end="(106, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(106, 53)" end="(106, 58)" leading="" trailing=" " raw_val="count" val="count" full_name="List.count" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(106, 59)" end="(106, 63)">
                    <IdentNode start="(106, 59)" end="(106, 60)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(106, 61)" end="(106, 63)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(106, 64)" end="(106, 65)" leading="" trailing=" " val="-"/>
                <OtherNode start="(106, 66)" end="(106, 89)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(106, 66)" end="(106, 67)" leading="" trailing="" val="("/>
                  <OtherNode start="(106, 67)" end="(106, 88)" kind="«term_-_»">
                    <IdentNode start="(106, 67)" end="(106, 76)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                    <AtomNode start="(106, 77)" end="(106, 78)" leading="" trailing=" " val="-"/>
                    <IdentNode start="(106, 79)" end="(106, 88)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                  </OtherNode>
                  <AtomNode start="(106, 88)" end="(106, 89)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(106, 90)" end="(106, 91)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(106, 92)" end="(106, 102)" kind="Lean.Parser.Term.app">
                <IdentNode start="(106, 92)" end="(106, 97)" leading="" trailing=" " raw_val="count" val="count" full_name="List.count" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(106, 98)" end="(106, 102)">
                  <IdentNode start="(106, 98)" end="(106, 99)" leading="" trailing=" " raw_val="a" val="a"/>
                  <IdentNode start="(106, 100)" end="(106, 102)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(106, 103)" end="(107, 23)">
          <AtomNode start="(106, 103)" end="(106, 105)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(107, 3)" end="(107, 23)" kind="Lean.Parser.Term.app">
            <IdentNode start="(107, 3)" end="(107, 21)" leading="" trailing=" " raw_val="s.sublist.le_count" val="s.sublist.le_count"/>
            <NullNode start="(107, 22)" end="(107, 23)">
              <TermHoleNode start="(107, 22)" end="(107, 23)">
                <AtomNode start="(107, 22)" end="(107, 23)" leading="" trailing="&#10;&#10;" val="_"/>
              </TermHoleNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(109, 1)" end="(110, 23)" name="IsSuffix.le_count" full_name="List.IsSuffix.le_count">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(109, 1)" end="(110, 23)" name="IsSuffix.le_count" full_name="List.IsSuffix.le_count" _is_private_decl="False">
        <AtomNode start="(109, 1)" end="(109, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(109, 9)" end="(109, 26)">
          <IdentNode start="(109, 9)" end="(109, 26)" leading="" trailing=" " raw_val="IsSuffix.le_count" val="IsSuffix.le_count"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(109, 27)" end="(109, 102)">
          <NullNode start="(109, 27)" end="(109, 50)">
            <TermExplicitbinderNode start="(109, 27)" end="(109, 42)">
              <AtomNode start="(109, 27)" end="(109, 28)" leading="" trailing="" val="("/>
              <NullNode start="(109, 28)" end="(109, 29)">
                <IdentNode start="(109, 28)" end="(109, 29)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(109, 30)" end="(109, 41)">
                <AtomNode start="(109, 30)" end="(109, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(109, 32)" end="(109, 41)" kind="List.«term_&amp;lt;:+_»">
                  <IdentNode start="(109, 32)" end="(109, 34)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(109, 35)" end="(109, 38)" leading="" trailing=" " val="&amp;lt;:+"/>
                  <IdentNode start="(109, 39)" end="(109, 41)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(109, 41)" end="(109, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(109, 43)" end="(109, 50)">
              <AtomNode start="(109, 43)" end="(109, 44)" leading="" trailing="" val="("/>
              <NullNode start="(109, 44)" end="(109, 45)">
                <IdentNode start="(109, 44)" end="(109, 45)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(109, 46)" end="(109, 49)">
                <AtomNode start="(109, 46)" end="(109, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(109, 48)" end="(109, 49)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(109, 49)" end="(109, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(109, 51)" end="(109, 102)">
            <AtomNode start="(109, 51)" end="(109, 52)" leading="" trailing=" " val=":"/>
            <OtherNode start="(109, 53)" end="(109, 102)" kind="«term_≤_»">
              <OtherNode start="(109, 53)" end="(109, 89)" kind="«term_-_»">
                <OtherNode start="(109, 53)" end="(109, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(109, 53)" end="(109, 58)" leading="" trailing=" " raw_val="count" val="count" full_name="List.count" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(109, 59)" end="(109, 63)">
                    <IdentNode start="(109, 59)" end="(109, 60)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(109, 61)" end="(109, 63)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(109, 64)" end="(109, 65)" leading="" trailing=" " val="-"/>
                <OtherNode start="(109, 66)" end="(109, 89)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(109, 66)" end="(109, 67)" leading="" trailing="" val="("/>
                  <OtherNode start="(109, 67)" end="(109, 88)" kind="«term_-_»">
                    <IdentNode start="(109, 67)" end="(109, 76)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                    <AtomNode start="(109, 77)" end="(109, 78)" leading="" trailing=" " val="-"/>
                    <IdentNode start="(109, 79)" end="(109, 88)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                  </OtherNode>
                  <AtomNode start="(109, 88)" end="(109, 89)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(109, 90)" end="(109, 91)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(109, 92)" end="(109, 102)" kind="Lean.Parser.Term.app">
                <IdentNode start="(109, 92)" end="(109, 97)" leading="" trailing=" " raw_val="count" val="count" full_name="List.count" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(109, 98)" end="(109, 102)">
                  <IdentNode start="(109, 98)" end="(109, 99)" leading="" trailing=" " raw_val="a" val="a"/>
                  <IdentNode start="(109, 100)" end="(109, 102)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(109, 103)" end="(110, 23)">
          <AtomNode start="(109, 103)" end="(109, 105)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(110, 3)" end="(110, 23)" kind="Lean.Parser.Term.app">
            <IdentNode start="(110, 3)" end="(110, 21)" leading="" trailing=" " raw_val="s.sublist.le_count" val="s.sublist.le_count"/>
            <NullNode start="(110, 22)" end="(110, 23)">
              <TermHoleNode start="(110, 22)" end="(110, 23)">
                <AtomNode start="(110, 22)" end="(110, 23)" leading="" trailing="&#10;&#10;" val="_"/>
              </TermHoleNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(112, 1)" end="(113, 23)" name="IsInfix.le_count" full_name="List.IsInfix.le_count">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(112, 1)" end="(113, 23)" name="IsInfix.le_count" full_name="List.IsInfix.le_count" _is_private_decl="False">
        <AtomNode start="(112, 1)" end="(112, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(112, 9)" end="(112, 25)">
          <IdentNode start="(112, 9)" end="(112, 25)" leading="" trailing=" " raw_val="IsInfix.le_count" val="IsInfix.le_count"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(112, 26)" end="(112, 102)">
          <NullNode start="(112, 26)" end="(112, 50)">
            <TermExplicitbinderNode start="(112, 26)" end="(112, 42)">
              <AtomNode start="(112, 26)" end="(112, 27)" leading="" trailing="" val="("/>
              <NullNode start="(112, 27)" end="(112, 28)">
                <IdentNode start="(112, 27)" end="(112, 28)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(112, 29)" end="(112, 41)">
                <AtomNode start="(112, 29)" end="(112, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(112, 31)" end="(112, 41)" kind="List.«term_&amp;lt;:+:_»">
                  <IdentNode start="(112, 31)" end="(112, 33)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(112, 34)" end="(112, 38)" leading="" trailing=" " val="&amp;lt;:+:"/>
                  <IdentNode start="(112, 39)" end="(112, 41)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(112, 41)" end="(112, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(112, 43)" end="(112, 50)">
              <AtomNode start="(112, 43)" end="(112, 44)" leading="" trailing="" val="("/>
              <NullNode start="(112, 44)" end="(112, 45)">
                <IdentNode start="(112, 44)" end="(112, 45)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(112, 46)" end="(112, 49)">
                <AtomNode start="(112, 46)" end="(112, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(112, 48)" end="(112, 49)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(112, 49)" end="(112, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(112, 51)" end="(112, 102)">
            <AtomNode start="(112, 51)" end="(112, 52)" leading="" trailing=" " val=":"/>
            <OtherNode start="(112, 53)" end="(112, 102)" kind="«term_≤_»">
              <OtherNode start="(112, 53)" end="(112, 89)" kind="«term_-_»">
                <OtherNode start="(112, 53)" end="(112, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(112, 53)" end="(112, 58)" leading="" trailing=" " raw_val="count" val="count" full_name="List.count" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(112, 59)" end="(112, 63)">
                    <IdentNode start="(112, 59)" end="(112, 60)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(112, 61)" end="(112, 63)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(112, 64)" end="(112, 65)" leading="" trailing=" " val="-"/>
                <OtherNode start="(112, 66)" end="(112, 89)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(112, 66)" end="(112, 67)" leading="" trailing="" val="("/>
                  <OtherNode start="(112, 67)" end="(112, 88)" kind="«term_-_»">
                    <IdentNode start="(112, 67)" end="(112, 76)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                    <AtomNode start="(112, 77)" end="(112, 78)" leading="" trailing=" " val="-"/>
                    <IdentNode start="(112, 79)" end="(112, 88)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                  </OtherNode>
                  <AtomNode start="(112, 88)" end="(112, 89)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(112, 90)" end="(112, 91)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(112, 92)" end="(112, 102)" kind="Lean.Parser.Term.app">
                <IdentNode start="(112, 92)" end="(112, 97)" leading="" trailing=" " raw_val="count" val="count" full_name="List.count" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(112, 98)" end="(112, 102)">
                  <IdentNode start="(112, 98)" end="(112, 99)" leading="" trailing=" " raw_val="a" val="a"/>
                  <IdentNode start="(112, 100)" end="(112, 102)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(112, 103)" end="(113, 23)">
          <AtomNode start="(112, 103)" end="(112, 105)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(113, 3)" end="(113, 23)" kind="Lean.Parser.Term.app">
            <IdentNode start="(113, 3)" end="(113, 21)" leading="" trailing=" " raw_val="s.sublist.le_count" val="s.sublist.le_count"/>
            <NullNode start="(113, 22)" end="(113, 23)">
              <TermHoleNode start="(113, 22)" end="(113, 23)">
                <AtomNode start="(113, 22)" end="(113, 23)" leading="" trailing="&#10;&#10;" val="_"/>
              </TermHoleNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(115, 1)" end="(116, 17)" name="le_count_tail" full_name="List.le_count_tail">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(115, 1)" end="(116, 17)" name="le_count_tail" full_name="List.le_count_tail" _is_private_decl="False">
        <AtomNode start="(115, 1)" end="(115, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(115, 9)" end="(115, 22)">
          <IdentNode start="(115, 9)" end="(115, 22)" leading="" trailing=" " raw_val="le_count_tail" val="le_count_tail"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(115, 23)" end="(115, 76)">
          <NullNode start="(115, 23)" end="(115, 43)">
            <OtherNode start="(115, 23)" end="(115, 30)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(115, 23)" end="(115, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(115, 24)" end="(115, 25)">
                <IdentNode start="(115, 24)" end="(115, 25)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(115, 26)" end="(115, 29)">
                <AtomNode start="(115, 26)" end="(115, 27)" leading="" trailing=" " val=":"/>
                <IdentNode start="(115, 28)" end="(115, 29)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(115, 29)" end="(115, 30)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(115, 31)" end="(115, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(115, 31)" end="(115, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(115, 32)" end="(115, 33)">
                <IdentNode start="(115, 32)" end="(115, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(115, 34)" end="(115, 42)">
                <AtomNode start="(115, 34)" end="(115, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(115, 36)" end="(115, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(115, 36)" end="(115, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(115, 41)" end="(115, 42)">
                    <IdentNode start="(115, 41)" end="(115, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(115, 42)" end="(115, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(115, 44)" end="(115, 76)">
            <AtomNode start="(115, 44)" end="(115, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(115, 46)" end="(115, 76)" kind="«term_≤_»">
              <OtherNode start="(115, 46)" end="(115, 59)" kind="«term_-_»">
                <OtherNode start="(115, 46)" end="(115, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(115, 46)" end="(115, 51)" leading="" trailing=" " raw_val="count" val="count" full_name="List.count" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(115, 52)" end="(115, 55)">
                    <IdentNode start="(115, 52)" end="(115, 53)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(115, 54)" end="(115, 55)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(115, 56)" end="(115, 57)" leading="" trailing=" " val="-"/>
                <OtherNode start="(115, 58)" end="(115, 59)" kind="num">
                  <AtomNode start="(115, 58)" end="(115, 59)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(115, 60)" end="(115, 61)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(115, 62)" end="(115, 76)" kind="Lean.Parser.Term.app">
                <IdentNode start="(115, 62)" end="(115, 67)" leading="" trailing=" " raw_val="count" val="count" full_name="List.count" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(115, 68)" end="(115, 76)">
                  <IdentNode start="(115, 68)" end="(115, 69)" leading="" trailing=" " raw_val="a" val="a"/>
                  <IdentNode start="(115, 70)" end="(115, 76)" leading="" trailing=" " raw_val="l.tail" val="l.tail"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(115, 77)" end="(116, 17)">
          <AtomNode start="(115, 77)" end="(115, 79)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(116, 3)" end="(116, 17)" leading="" trailing="&#10;&#10;" raw_val="le_countP_tail" val="le_countP_tail" full_name="List.le_countP_tail" mod_name="Init.Data.List.Nat.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Count.lean" def_start="(96, 9)" def_end="(96, 23)"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(118, 1)" end="(118, 9)" name="List">
      <AtomNode start="(118, 1)" end="(118, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(118, 5)" end="(118, 9)">
        <IdentNode start="(118, 5)" end="(118, 9)" leading="" trailing="&#10;" raw_val="List" val="List"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(12, 38)" end="(13, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(13, 39)" end="(15, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(63, 1)" end="(66, 3)" text="The number of elements satisfying a predicate in a sublist is at least the number of elements satisfying the predicate in the list,&#10;minus the difference in the lengths.&#10;-/"/>
    <Comment start="(92, 1)" end="(95, 3)" text="The number of elements satisfying a predicate in the tail of a list is&#10;at least one less than the number of elements satisfying the predicate in the list.&#10;-/"/>
  </Comments>
</TracedFile>
