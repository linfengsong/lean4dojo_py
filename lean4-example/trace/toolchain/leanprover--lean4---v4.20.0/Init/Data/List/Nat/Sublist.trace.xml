<TracedFile path="src/lean/Init/Data/List/Nat/Sublist.lean" md5="19e800705f683b5873908cdca4fc59dc">
  <FileNode start="(1, 1)" end="(179, 9)">
    <ModuleHeaderNode start="(6, 1)" end="(12, 28)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(12, 28)">
        <ModuleImportNode start="(9, 1)" end="(9, 30)" module="Init.Data.List.Sublist" path="src/lean/Init/Data/List/Sublist.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 30)" leading="" trailing="&#10;" raw_val="Init.Data.List.Sublist" val="Init.Data.List.Sublist"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 32)" module="Init.Data.List.Nat.Basic" path="src/lean/Init/Data/List/Nat/Basic.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 32)" leading="" trailing="&#10;" raw_val="Init.Data.List.Nat.Basic" val="Init.Data.List.Nat.Basic"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 35)" module="Init.Data.List.Nat.TakeDrop" path="src/lean/Init/Data/List/Nat/TakeDrop.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 35)" leading="" trailing="&#10;" raw_val="Init.Data.List.Nat.TakeDrop" val="Init.Data.List.Nat.TakeDrop"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(12, 1)" end="(12, 28)" module="Init.Data.Nat.Lemmas" path="src/lean/Init/Data/Nat/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(12, 1)" end="(12, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(12, 8)" end="(12, 28)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.Nat.Lemmas" val="Init.Data.Nat.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(14, 1)" end="(19, 3)" comment="# Further lemmas about `List.IsSuffix` / `List.IsPrefix` / `List.IsInfix`.&#10;&#10;These are in a separate file from most of the lemmas about `List.IsSuffix`&#10;as they required importing more lemmas about natural numbers, and use `omega`.&#10;-/">
      <AtomNode start="(14, 1)" end="(14, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(15, 1)" end="(19, 3)" leading="" trailing="&#10;&#10;" val="# Further lemmas about `List.IsSuffix` / `List.IsPrefix` / `List.IsInfix`.&#10;&#10;These are in a separate file from most of the lemmas about `List.IsSuffix`&#10;as they required importing more lemmas about natural numbers, and use `omega`.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(21, 1)" end="(21, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(21, 1)" end="(21, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(21, 12)" end="(21, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(21, 33)" end="(21, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(22, 1)" end="(22, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(22, 1)" end="(22, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(22, 12)" end="(22, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(22, 34)" end="(22, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(24, 1)" end="(24, 15)" name="List">
      <AtomNode start="(24, 1)" end="(24, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(24, 11)" end="(24, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandDeclarationNode start="(26, 1)" end="(31, 8)" name="IsSuffix.getElem" full_name="List.IsSuffix.getElem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(26, 1)" end="(31, 8)" name="IsSuffix.getElem" full_name="List.IsSuffix.getElem" _is_private_decl="False">
        <AtomNode start="(26, 1)" end="(26, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(26, 9)" end="(26, 25)">
          <IdentNode start="(26, 9)" end="(26, 25)" leading="" trailing=" " raw_val="IsSuffix.getElem" val="IsSuffix.getElem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(26, 26)" end="(27, 74)">
          <NullNode start="(26, 26)" end="(26, 83)">
            <OtherNode start="(26, 26)" end="(26, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(26, 26)" end="(26, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(26, 27)" end="(26, 32)">
                <IdentNode start="(26, 27)" end="(26, 29)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(26, 30)" end="(26, 32)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(26, 33)" end="(26, 41)">
                <AtomNode start="(26, 33)" end="(26, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(26, 35)" end="(26, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(26, 35)" end="(26, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(26, 40)" end="(26, 41)">
                    <IdentNode start="(26, 40)" end="(26, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(26, 41)" end="(26, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(26, 43)" end="(26, 58)">
              <AtomNode start="(26, 43)" end="(26, 44)" leading="" trailing="" val="("/>
              <NullNode start="(26, 44)" end="(26, 45)">
                <IdentNode start="(26, 44)" end="(26, 45)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(26, 46)" end="(26, 57)">
                <AtomNode start="(26, 46)" end="(26, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(26, 48)" end="(26, 57)" kind="List.«term_&amp;lt;:+_»">
                  <IdentNode start="(26, 48)" end="(26, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(26, 51)" end="(26, 54)" leading="" trailing=" " val="&amp;lt;:+"/>
                  <IdentNode start="(26, 55)" end="(26, 57)" leading="" trailing="" raw_val="ys" val="ys"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(26, 57)" end="(26, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(26, 59)" end="(26, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(26, 59)" end="(26, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(26, 60)" end="(26, 61)">
                <IdentNode start="(26, 60)" end="(26, 61)" leading="" trailing="" raw_val="i" val="i"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(26, 61)" end="(26, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(26, 63)" end="(26, 83)">
              <AtomNode start="(26, 63)" end="(26, 64)" leading="" trailing="" val="("/>
              <NullNode start="(26, 64)" end="(26, 66)">
                <IdentNode start="(26, 64)" end="(26, 66)" leading="" trailing=" " raw_val="hn" val="hn"/>
              </NullNode>
              <NullNode start="(26, 67)" end="(26, 82)">
                <AtomNode start="(26, 67)" end="(26, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(26, 69)" end="(26, 82)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(26, 69)" end="(26, 70)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(26, 71)" end="(26, 72)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(26, 73)" end="(26, 82)" leading="" trailing="" raw_val="xs.length" val="xs.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(26, 82)" end="(26, 83)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(26, 84)" end="(27, 74)">
            <AtomNode start="(26, 84)" end="(26, 85)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(27, 5)" end="(27, 74)" kind="«term_=_»">
              <OtherNode start="(27, 5)" end="(27, 10)" kind="«term__[_]»">
                <IdentNode start="(27, 5)" end="(27, 7)" leading="" trailing="" raw_val="xs" val="xs"/>
                <AtomNode start="(27, 7)" end="(27, 8)" leading="" trailing="" val="["/>
                <IdentNode start="(27, 8)" end="(27, 9)" leading="" trailing="" raw_val="i" val="i"/>
                <AtomNode start="(27, 9)" end="(27, 10)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(27, 11)" end="(27, 12)" leading="" trailing=" " val="="/>
              <OtherNode start="(27, 13)" end="(27, 74)" kind="«term__[_]'_»">
                <IdentNode start="(27, 13)" end="(27, 15)" leading="" trailing="" raw_val="ys" val="ys"/>
                <AtomNode start="(27, 15)" end="(27, 16)" leading="" trailing="" val="["/>
                <OtherNode start="(27, 16)" end="(27, 41)" kind="«term_+_»">
                  <OtherNode start="(27, 16)" end="(27, 37)" kind="«term_-_»">
                    <IdentNode start="(27, 16)" end="(27, 25)" leading="" trailing=" " raw_val="ys.length" val="ys.length"/>
                    <AtomNode start="(27, 26)" end="(27, 27)" leading="" trailing=" " val="-"/>
                    <IdentNode start="(27, 28)" end="(27, 37)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
                  </OtherNode>
                  <AtomNode start="(27, 38)" end="(27, 39)" leading="" trailing=" " val="+"/>
                  <IdentNode start="(27, 40)" end="(27, 41)" leading="" trailing="" raw_val="i" val="i"/>
                </OtherNode>
                <AtomNode start="(27, 41)" end="(27, 43)" leading="" trailing="" val="]'"/>
                <OtherNode start="(27, 43)" end="(27, 74)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(27, 43)" end="(27, 44)" leading="" trailing="" val="("/>
                  <TermBytacticNode start="(27, 44)" end="(27, 73)">
                    <AtomNode start="(27, 44)" end="(27, 46)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(27, 47)" end="(27, 73)">
                      <TacticTacticseq1IndentedNode start="(27, 47)" end="(27, 73)">
                        <NullNode start="(27, 47)" end="(27, 73)">
                          <OtherNode start="(27, 47)" end="(27, 66)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type ?u.7&#10;xs ys : List α&#10;h : xs &amp;lt;:+ ys&#10;i : Nat&#10;hn : i &amp;lt; xs.length&#10;⊢ ys.length - xs.length + i &amp;lt; ys.length" state_after="α : Type ?u.7&#10;xs ys : List α&#10;h : xs &amp;lt;:+ ys&#10;i : Nat&#10;hn : i &amp;lt; xs.length&#10;this : xs.length ≤ ys.length&#10;⊢ ys.length - xs.length + i &amp;lt; ys.length" tactic="have := h.length_le">
                            <AtomNode start="(27, 47)" end="(27, 51)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(27, 52)" end="(27, 66)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(27, 52)" end="(27, 66)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(27, 52)" end="(27, 52)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(27, 52)" end="(27, 52)" kind="hygieneInfo">
                                    <IdentNode start="(27, 52)" end="(27, 52)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(27, 52)" end="(27, 54)" leading="" trailing=" " val=":="/>
                                <IdentNode start="(27, 55)" end="(27, 66)" leading="" trailing="" raw_val="h.length_le" val="h.length_le"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(27, 66)" end="(27, 67)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(27, 68)" end="(27, 73)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.7&#10;xs ys : List α&#10;h : xs &amp;lt;:+ ys&#10;i : Nat&#10;hn : i &amp;lt; xs.length&#10;this : xs.length ≤ ys.length&#10;⊢ ys.length - xs.length + i &amp;lt; ys.length" state_after="no goals" tactic="omega">
                            <AtomNode start="(27, 68)" end="(27, 73)" leading="" trailing="" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                  <AtomNode start="(27, 73)" end="(27, 74)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(27, 75)" end="(31, 8)">
          <AtomNode start="(27, 75)" end="(27, 77)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(27, 78)" end="(31, 8)">
            <AtomNode start="(27, 78)" end="(27, 80)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(28, 3)" end="(31, 8)">
              <TacticTacticseq1IndentedNode start="(28, 3)" end="(31, 8)">
                <NullNode start="(28, 3)" end="(31, 8)">
                  <OtherNode start="(28, 3)" end="(28, 70)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;xs ys : List α&#10;h : xs &amp;lt;:+ ys&#10;i : Nat&#10;hn : i &amp;lt; xs.length&#10;⊢ xs[i] = ys[ys.length - xs.length + i]" state_after="α : Type u_1&#10;xs ys : List α&#10;h : xs &amp;lt;:+ ys&#10;i : Nat&#10;hn : i &amp;lt; xs.length&#10;⊢ ys[ys.length - 1 - (xs.length - 1 - i)] = ys[ys.length - xs.length + i]" tactic="rw [getElem_eq_getElem_reverse, h.reverse.getElem, getElem_reverse]">
                    <AtomNode start="(28, 3)" end="(28, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(28, 6)" end="(28, 70)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(28, 6)" end="(28, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(28, 7)" end="(28, 69)">
                        <OtherNode start="(28, 7)" end="(28, 33)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(28, 7)" end="(28, 33)" leading="" trailing="" raw_val="getElem_eq_getElem_reverse" val="getElem_eq_getElem_reverse" full_name="List.getElem_eq_getElem_reverse" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(28, 33)" end="(28, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(28, 35)" end="(28, 52)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(28, 35)" end="(28, 52)" leading="" trailing="" raw_val="h.reverse.getElem" val="h.reverse.getElem"/>
                        </OtherNode>
                        <AtomNode start="(28, 52)" end="(28, 53)" leading="" trailing=" " val=","/>
                        <OtherNode start="(28, 54)" end="(28, 69)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(28, 54)" end="(28, 69)" leading="" trailing="" raw_val="getElem_reverse" val="getElem_reverse" full_name="List.getElem_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(28, 69)" end="(28, 70)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(29, 3)" end="(29, 8)" kind="Lean.Parser.Tactic.congr" state_before="α : Type u_1&#10;xs ys : List α&#10;h : xs &amp;lt;:+ ys&#10;i : Nat&#10;hn : i &amp;lt; xs.length&#10;⊢ ys[ys.length - 1 - (xs.length - 1 - i)] = ys[ys.length - xs.length + i]" state_after="case e_i&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs &amp;lt;:+ ys&#10;i : Nat&#10;hn : i &amp;lt; xs.length&#10;⊢ ys.length - 1 - (xs.length - 1 - i) = ys.length - xs.length + i" tactic="congr">
                    <AtomNode start="(29, 3)" end="(29, 8)" leading="" trailing="&#10;  " val="congr"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(30, 3)" end="(30, 22)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case e_i&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs &amp;lt;:+ ys&#10;i : Nat&#10;hn : i &amp;lt; xs.length&#10;⊢ ys.length - 1 - (xs.length - 1 - i) = ys.length - xs.length + i" state_after="case e_i&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs &amp;lt;:+ ys&#10;i : Nat&#10;hn : i &amp;lt; xs.length&#10;this : xs.length ≤ ys.length&#10;⊢ ys.length - 1 - (xs.length - 1 - i) = ys.length - xs.length + i" tactic="have := h.length_le">
                    <AtomNode start="(30, 3)" end="(30, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(30, 8)" end="(30, 22)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(30, 8)" end="(30, 22)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(30, 8)" end="(30, 8)" kind="Lean.Parser.Term.haveId">
                          <OtherNode start="(30, 8)" end="(30, 8)" kind="hygieneInfo">
                            <IdentNode start="(30, 8)" end="(30, 8)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                          </OtherNode>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(30, 8)" end="(30, 10)" leading="" trailing=" " val=":="/>
                        <IdentNode start="(30, 11)" end="(30, 22)" leading="" trailing="&#10;  " raw_val="h.length_le" val="h.length_le"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(31, 3)" end="(31, 8)" kind="Lean.Parser.Tactic.omega" state_before="case e_i&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs &amp;lt;:+ ys&#10;i : Nat&#10;hn : i &amp;lt; xs.length&#10;this : xs.length ≤ ys.length&#10;⊢ ys.length - 1 - (xs.length - 1 - i) = ys.length - xs.length + i" state_after="no goals" tactic="omega">
                    <AtomNode start="(31, 3)" end="(31, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(33, 1)" end="(61, 34)" name="isSuffix_iff" full_name="List.isSuffix_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(33, 1)" end="(61, 34)" name="isSuffix_iff" full_name="List.isSuffix_iff" _is_private_decl="False">
        <AtomNode start="(33, 1)" end="(33, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(33, 9)" end="(33, 21)">
          <IdentNode start="(33, 9)" end="(33, 21)" leading="" trailing=" " raw_val="isSuffix_iff" val="isSuffix_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(33, 22)" end="(34, 97)">
          <NullNode/>
          <TermTypespecNode start="(33, 22)" end="(34, 97)">
            <AtomNode start="(33, 22)" end="(33, 23)" leading="" trailing=" " val=":"/>
            <OtherNode start="(33, 24)" end="(34, 97)" kind="«term_↔_»">
              <OtherNode start="(33, 24)" end="(33, 33)" kind="List.«term_&amp;lt;:+_»">
                <IdentNode start="(33, 24)" end="(33, 26)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(33, 27)" end="(33, 30)" leading="" trailing=" " val="&amp;lt;:+"/>
                <IdentNode start="(33, 31)" end="(33, 33)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
              <AtomNode start="(33, 34)" end="(33, 35)" leading="" trailing="&#10;    " val="↔"/>
              <OtherNode start="(34, 5)" end="(34, 97)" kind="«term_∧_»">
                <OtherNode start="(34, 5)" end="(34, 26)" kind="«term_≤_»">
                  <IdentNode start="(34, 5)" end="(34, 14)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                  <AtomNode start="(34, 15)" end="(34, 16)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(34, 17)" end="(34, 26)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                </OtherNode>
                <AtomNode start="(34, 27)" end="(34, 28)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(34, 29)" end="(34, 97)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(34, 29)" end="(34, 30)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(34, 31)" end="(34, 52)">
                    <IdentNode start="(34, 31)" end="(34, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                    <TermExplicitbinderNode start="(34, 33)" end="(34, 52)">
                      <AtomNode start="(34, 33)" end="(34, 34)" leading="" trailing="" val="("/>
                      <NullNode start="(34, 34)" end="(34, 35)">
                        <IdentNode start="(34, 34)" end="(34, 35)" leading="" trailing=" " raw_val="h" val="h"/>
                      </NullNode>
                      <NullNode start="(34, 36)" end="(34, 51)">
                        <AtomNode start="(34, 36)" end="(34, 37)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(34, 38)" end="(34, 51)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(34, 38)" end="(34, 39)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(34, 40)" end="(34, 41)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(34, 42)" end="(34, 51)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(34, 51)" end="(34, 52)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(34, 52)" end="(34, 53)" leading="" trailing=" " val=","/>
                  <OtherNode start="(34, 54)" end="(34, 97)" kind="«term_=_»">
                    <OtherNode start="(34, 54)" end="(34, 84)" kind="«term__[_]_?»">
                      <IdentNode start="(34, 54)" end="(34, 56)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      <GroupNode/>
                      <AtomNode start="(34, 56)" end="(34, 57)" leading="" trailing="" val="["/>
                      <OtherNode start="(34, 57)" end="(34, 82)" kind="«term_-_»">
                        <OtherNode start="(34, 57)" end="(34, 70)" kind="«term_+_»">
                          <IdentNode start="(34, 57)" end="(34, 58)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(34, 59)" end="(34, 60)" leading="" trailing=" " val="+"/>
                          <IdentNode start="(34, 61)" end="(34, 70)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                        </OtherNode>
                        <AtomNode start="(34, 71)" end="(34, 72)" leading="" trailing=" " val="-"/>
                        <IdentNode start="(34, 73)" end="(34, 82)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                      </OtherNode>
                      <AtomNode start="(34, 82)" end="(34, 83)" leading="" trailing="" val="]"/>
                      <GroupNode/>
                      <AtomNode start="(34, 83)" end="(34, 84)" leading="" trailing=" " val="?"/>
                    </OtherNode>
                    <AtomNode start="(34, 85)" end="(34, 86)" leading="" trailing=" " val="="/>
                    <OtherNode start="(34, 87)" end="(34, 97)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(34, 87)" end="(34, 91)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(34, 92)" end="(34, 97)">
                        <OtherNode start="(34, 92)" end="(34, 97)" kind="«term__[_]»">
                          <IdentNode start="(34, 92)" end="(34, 94)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                          <AtomNode start="(34, 94)" end="(34, 95)" leading="" trailing="" val="["/>
                          <IdentNode start="(34, 95)" end="(34, 96)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(34, 96)" end="(34, 97)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(34, 98)" end="(61, 34)">
          <AtomNode start="(34, 98)" end="(34, 100)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(34, 101)" end="(61, 34)">
            <AtomNode start="(34, 101)" end="(34, 103)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(35, 3)" end="(61, 34)">
              <TacticTacticseq1IndentedNode start="(35, 3)" end="(61, 34)">
                <NullNode start="(35, 3)" end="(61, 34)">
                  <OtherNode start="(35, 3)" end="(41, 27)" kind="Lean.Parser.Tactic.tacticSuffices_" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ l₁ &amp;lt;:+ l₂ ↔ l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]" state_after="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]" tactic="suffices l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ i (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i] by&#10;  constructor&#10;  · intro h&#10;    exact this.mp ⟨h.length_le, h⟩&#10;  · intro h&#10;    exact (this.mpr h).2">
                    <AtomNode start="(35, 3)" end="(35, 11)" leading="" trailing=" " val="suffices"/>
                    <OtherNode start="(35, 12)" end="(41, 27)" kind="Lean.Parser.Term.sufficesDecl">
                      <OtherNode start="(35, 12)" end="(35, 12)" kind="hygieneInfo">
                        <IdentNode start="(35, 12)" end="(35, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                      </OtherNode>
                      <OtherNode start="(35, 12)" end="(36, 99)" kind="«term_↔_»">
                        <OtherNode start="(35, 12)" end="(35, 45)" kind="«term_∧_»">
                          <OtherNode start="(35, 12)" end="(35, 33)" kind="«term_≤_»">
                            <IdentNode start="(35, 12)" end="(35, 21)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                            <AtomNode start="(35, 22)" end="(35, 23)" leading="" trailing=" " val="≤"/>
                            <IdentNode start="(35, 24)" end="(35, 33)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                          </OtherNode>
                          <AtomNode start="(35, 34)" end="(35, 35)" leading="" trailing=" " val="∧"/>
                          <OtherNode start="(35, 36)" end="(35, 45)" kind="List.«term_&amp;lt;:+_»">
                            <IdentNode start="(35, 36)" end="(35, 38)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                            <AtomNode start="(35, 39)" end="(35, 42)" leading="" trailing=" " val="&amp;lt;:+"/>
                            <IdentNode start="(35, 43)" end="(35, 45)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(35, 46)" end="(35, 47)" leading="" trailing="&#10;      " val="↔"/>
                        <OtherNode start="(36, 7)" end="(36, 99)" kind="«term_∧_»">
                          <OtherNode start="(36, 7)" end="(36, 28)" kind="«term_≤_»">
                            <IdentNode start="(36, 7)" end="(36, 16)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                            <AtomNode start="(36, 17)" end="(36, 18)" leading="" trailing=" " val="≤"/>
                            <IdentNode start="(36, 19)" end="(36, 28)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                          </OtherNode>
                          <AtomNode start="(36, 29)" end="(36, 30)" leading="" trailing=" " val="∧"/>
                          <OtherNode start="(36, 31)" end="(36, 99)" kind="Lean.Parser.Term.forall">
                            <AtomNode start="(36, 31)" end="(36, 32)" leading="" trailing=" " val="∀"/>
                            <NullNode start="(36, 33)" end="(36, 54)">
                              <IdentNode start="(36, 33)" end="(36, 34)" leading="" trailing=" " raw_val="i" val="i"/>
                              <TermExplicitbinderNode start="(36, 35)" end="(36, 54)">
                                <AtomNode start="(36, 35)" end="(36, 36)" leading="" trailing="" val="("/>
                                <NullNode start="(36, 36)" end="(36, 37)">
                                  <IdentNode start="(36, 36)" end="(36, 37)" leading="" trailing=" " raw_val="h" val="h"/>
                                </NullNode>
                                <NullNode start="(36, 38)" end="(36, 53)">
                                  <AtomNode start="(36, 38)" end="(36, 39)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(36, 40)" end="(36, 53)" kind="«term_&amp;lt;_»">
                                    <IdentNode start="(36, 40)" end="(36, 41)" leading="" trailing=" " raw_val="i" val="i"/>
                                    <AtomNode start="(36, 42)" end="(36, 43)" leading="" trailing=" " val="&amp;lt;"/>
                                    <IdentNode start="(36, 44)" end="(36, 53)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                                  </OtherNode>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(36, 53)" end="(36, 54)" leading="" trailing="" val=")"/>
                              </TermExplicitbinderNode>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(36, 54)" end="(36, 55)" leading="" trailing=" " val=","/>
                            <OtherNode start="(36, 56)" end="(36, 99)" kind="«term_=_»">
                              <OtherNode start="(36, 56)" end="(36, 86)" kind="«term__[_]_?»">
                                <IdentNode start="(36, 56)" end="(36, 58)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                <GroupNode/>
                                <AtomNode start="(36, 58)" end="(36, 59)" leading="" trailing="" val="["/>
                                <OtherNode start="(36, 59)" end="(36, 84)" kind="«term_-_»">
                                  <OtherNode start="(36, 59)" end="(36, 72)" kind="«term_+_»">
                                    <IdentNode start="(36, 59)" end="(36, 60)" leading="" trailing=" " raw_val="i" val="i"/>
                                    <AtomNode start="(36, 61)" end="(36, 62)" leading="" trailing=" " val="+"/>
                                    <IdentNode start="(36, 63)" end="(36, 72)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                                  </OtherNode>
                                  <AtomNode start="(36, 73)" end="(36, 74)" leading="" trailing=" " val="-"/>
                                  <IdentNode start="(36, 75)" end="(36, 84)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                                </OtherNode>
                                <AtomNode start="(36, 84)" end="(36, 85)" leading="" trailing="" val="]"/>
                                <GroupNode/>
                                <AtomNode start="(36, 85)" end="(36, 86)" leading="" trailing=" " val="?"/>
                              </OtherNode>
                              <AtomNode start="(36, 87)" end="(36, 88)" leading="" trailing=" " val="="/>
                              <OtherNode start="(36, 89)" end="(36, 99)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(36, 89)" end="(36, 93)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(36, 94)" end="(36, 99)">
                                  <OtherNode start="(36, 94)" end="(36, 99)" kind="«term__[_]»">
                                    <IdentNode start="(36, 94)" end="(36, 96)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                    <AtomNode start="(36, 96)" end="(36, 97)" leading="" trailing="" val="["/>
                                    <IdentNode start="(36, 97)" end="(36, 98)" leading="" trailing="" raw_val="i" val="i"/>
                                    <AtomNode start="(36, 98)" end="(36, 99)" leading="" trailing=" " val="]"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(36, 100)" end="(41, 27)" kind="Lean.Parser.Term.byTactic'">
                        <AtomNode start="(36, 100)" end="(36, 102)" leading="" trailing="&#10;    " val="by"/>
                        <TacticTacticseqNode start="(37, 5)" end="(41, 27)">
                          <TacticTacticseq1IndentedNode start="(37, 5)" end="(41, 27)">
                            <NullNode start="(37, 5)" end="(41, 27)">
                              <OtherNode start="(37, 5)" end="(37, 16)" kind="Lean.Parser.Tactic.constructor" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;this :&#10;  l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;⊢ l₁ &amp;lt;:+ l₂ ↔ l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]" state_after="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;this :&#10;  l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;⊢ l₁ &amp;lt;:+ l₂ → l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;this :&#10;  l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;⊢ (l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]) → l₁ &amp;lt;:+ l₂" tactic="constructor">
                                <AtomNode start="(37, 5)" end="(37, 16)" leading="" trailing="&#10;    " val="constructor"/>
                              </OtherNode>
                              <NullNode/>
                              <OtherNode start="(38, 5)" end="(39, 37)" kind="Lean.cdot" state_before="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;this :&#10;  l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;⊢ l₁ &amp;lt;:+ l₂ → l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;this :&#10;  l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;⊢ (l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]) → l₁ &amp;lt;:+ l₂" state_after="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;this :&#10;  l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;⊢ (l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]) → l₁ &amp;lt;:+ l₂" tactic="· intro h&#10;  exact this.mp ⟨h.length_le, h⟩">
                                <OtherNode start="(38, 5)" end="(38, 6)" kind="Lean.cdotTk">
                                  <OtherNode start="(38, 5)" end="(38, 6)" kind="patternIgnore">
                                    <OtherNode start="(38, 5)" end="(38, 6)" kind="token.«· »">
                                      <AtomNode start="(38, 5)" end="(38, 6)" leading="" trailing=" " val="·"/>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                                <TacticTacticseqNode start="(38, 7)" end="(39, 37)">
                                  <TacticTacticseq1IndentedNode start="(38, 7)" end="(39, 37)">
                                    <NullNode start="(38, 7)" end="(39, 37)">
                                      <OtherNode start="(38, 7)" end="(38, 14)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;this :&#10;  l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;⊢ l₁ &amp;lt;:+ l₂ → l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]" state_after="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;this :&#10;  l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;h : l₁ &amp;lt;:+ l₂&#10;⊢ l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]" tactic="intro h">
                                        <AtomNode start="(38, 7)" end="(38, 12)" leading="" trailing=" " val="intro"/>
                                        <NullNode start="(38, 13)" end="(38, 14)">
                                          <IdentNode start="(38, 13)" end="(38, 14)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                      <OtherNode start="(39, 7)" end="(39, 37)" kind="Lean.Parser.Tactic.exact" state_before="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;this :&#10;  l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;h : l₁ &amp;lt;:+ l₂&#10;⊢ l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]" state_after="no goals" tactic="exact this.mp ⟨h.length_le, h⟩">
                                        <AtomNode start="(39, 7)" end="(39, 12)" leading="" trailing=" " val="exact"/>
                                        <OtherNode start="(39, 13)" end="(39, 37)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(39, 13)" end="(39, 20)" leading="" trailing=" " raw_val="this.mp" val="this.mp"/>
                                          <NullNode start="(39, 21)" end="(39, 37)">
                                            <OtherNode start="(39, 21)" end="(39, 37)" kind="Lean.Parser.Term.anonymousCtor">
                                              <AtomNode start="(39, 21)" end="(39, 22)" leading="" trailing="" val="⟨"/>
                                              <NullNode start="(39, 22)" end="(39, 36)">
                                                <IdentNode start="(39, 22)" end="(39, 33)" leading="" trailing="" raw_val="h.length_le" val="h.length_le"/>
                                                <AtomNode start="(39, 33)" end="(39, 34)" leading="" trailing=" " val=","/>
                                                <IdentNode start="(39, 35)" end="(39, 36)" leading="" trailing="" raw_val="h" val="h"/>
                                              </NullNode>
                                              <AtomNode start="(39, 36)" end="(39, 37)" leading="" trailing="&#10;    " val="⟩"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </OtherNode>
                              <NullNode/>
                              <OtherNode start="(40, 5)" end="(41, 27)" kind="Lean.cdot" state_before="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;this :&#10;  l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;⊢ (l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]) → l₁ &amp;lt;:+ l₂" state_after="no goals" tactic="· intro h&#10;  exact (this.mpr h).2">
                                <OtherNode start="(40, 5)" end="(40, 6)" kind="Lean.cdotTk">
                                  <OtherNode start="(40, 5)" end="(40, 6)" kind="patternIgnore">
                                    <OtherNode start="(40, 5)" end="(40, 6)" kind="token.«· »">
                                      <AtomNode start="(40, 5)" end="(40, 6)" leading="" trailing=" " val="·"/>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                                <TacticTacticseqNode start="(40, 7)" end="(41, 27)">
                                  <TacticTacticseq1IndentedNode start="(40, 7)" end="(41, 27)">
                                    <NullNode start="(40, 7)" end="(41, 27)">
                                      <OtherNode start="(40, 7)" end="(40, 14)" kind="Lean.Parser.Tactic.intro" state_before="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;this :&#10;  l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;⊢ (l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]) → l₁ &amp;lt;:+ l₂" state_after="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;this :&#10;  l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;h : l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;⊢ l₁ &amp;lt;:+ l₂" tactic="intro h">
                                        <AtomNode start="(40, 7)" end="(40, 12)" leading="" trailing=" " val="intro"/>
                                        <NullNode start="(40, 13)" end="(40, 14)">
                                          <IdentNode start="(40, 13)" end="(40, 14)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                      <OtherNode start="(41, 7)" end="(41, 27)" kind="Lean.Parser.Tactic.exact" state_before="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;this :&#10;  l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;h : l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;⊢ l₁ &amp;lt;:+ l₂" state_after="no goals" tactic="exact (this.mpr h).2">
                                        <AtomNode start="(41, 7)" end="(41, 12)" leading="" trailing=" " val="exact"/>
                                        <OtherNode start="(41, 13)" end="(41, 27)" kind="Lean.Parser.Term.proj">
                                          <OtherNode start="(41, 13)" end="(41, 25)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(41, 13)" end="(41, 14)" leading="" trailing="" val="("/>
                                            <OtherNode start="(41, 14)" end="(41, 24)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(41, 14)" end="(41, 22)" leading="" trailing=" " raw_val="this.mpr" val="this.mpr"/>
                                              <NullNode start="(41, 23)" end="(41, 24)">
                                                <IdentNode start="(41, 23)" end="(41, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(41, 24)" end="(41, 25)" leading="" trailing="" val=")"/>
                                          </OtherNode>
                                          <AtomNode start="(41, 25)" end="(41, 26)" leading="" trailing="" val="."/>
                                          <OtherNode start="(41, 26)" end="(41, 27)" kind="fieldIdx">
                                            <AtomNode start="(41, 26)" end="(41, 27)" leading="" trailing="&#10;  " val="2"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </OtherNode>
                            </NullNode>
                          </TacticTacticseq1IndentedNode>
                        </TacticTacticseqNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(42, 3)" end="(42, 34)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ l₁.length ≤ l₂.length ∧ l₁ &amp;lt;:+ l₂ ↔&#10;    l₁.length ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]" state_after="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ l₁.length ≤ l₂.length → (l₁ &amp;lt;:+ l₂ ↔ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i])" tactic="simp only [and_congr_right_iff]">
                    <AtomNode start="(42, 3)" end="(42, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(42, 8)" end="(42, 12)">
                      <AtomNode start="(42, 8)" end="(42, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(42, 13)" end="(42, 34)">
                      <AtomNode start="(42, 13)" end="(42, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(42, 14)" end="(42, 33)">
                        <OtherNode start="(42, 14)" end="(42, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(42, 14)" end="(42, 33)" leading="" trailing="" raw_val="and_congr_right_iff" val="and_congr_right_iff" full_name="and_congr_right_iff" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(42, 33)" end="(42, 34)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(43, 3)" end="(43, 11)" kind="Lean.Parser.Tactic.intro" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ l₁.length ≤ l₂.length → (l₁ &amp;lt;:+ l₂ ↔ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i])" state_after="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;⊢ l₁ &amp;lt;:+ l₂ ↔ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]" tactic="intro le">
                    <AtomNode start="(43, 3)" end="(43, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(43, 9)" end="(43, 11)">
                      <IdentNode start="(43, 9)" end="(43, 11)" leading="" trailing="&#10;  " raw_val="le" val="le"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(44, 3)" end="(44, 38)" kind="Lean.Parser.Tactic.rwSeq" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;⊢ l₁ &amp;lt;:+ l₂ ↔ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]" state_after="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l₁.reverse.length), l₂.reverse[i]? = some l₁.reverse[i]) ↔&#10;    ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]" tactic="rw [← reverse_prefix, isPrefix_iff]">
                    <AtomNode start="(44, 3)" end="(44, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(44, 6)" end="(44, 38)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(44, 6)" end="(44, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(44, 7)" end="(44, 37)">
                        <OtherNode start="(44, 7)" end="(44, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(44, 7)" end="(44, 8)">
                            <OtherNode start="(44, 7)" end="(44, 8)" kind="patternIgnore">
                              <OtherNode start="(44, 7)" end="(44, 8)" kind="token.«← »">
                                <AtomNode start="(44, 7)" end="(44, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(44, 9)" end="(44, 23)" leading="" trailing="" raw_val="reverse_prefix" val="reverse_prefix" full_name="List.reverse_prefix" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                        </OtherNode>
                        <AtomNode start="(44, 23)" end="(44, 24)" leading="" trailing=" " val=","/>
                        <OtherNode start="(44, 25)" end="(44, 37)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(44, 25)" end="(44, 37)" leading="" trailing="" raw_val="isPrefix_iff" val="isPrefix_iff" full_name="List.isPrefix_iff" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(44, 37)" end="(44, 38)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(45, 3)" end="(45, 29)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l₁.reverse.length), l₂.reverse[i]? = some l₁.reverse[i]) ↔&#10;    ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]" state_after="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂.reverse[i]? = some l₁.reverse[i]) ↔&#10;    ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]" tactic="simp only [length_reverse]">
                    <AtomNode start="(45, 3)" end="(45, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(45, 8)" end="(45, 12)">
                      <AtomNode start="(45, 8)" end="(45, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(45, 13)" end="(45, 29)">
                      <AtomNode start="(45, 13)" end="(45, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(45, 14)" end="(45, 28)">
                        <OtherNode start="(45, 14)" end="(45, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(45, 14)" end="(45, 28)" leading="" trailing="" raw_val="length_reverse" val="length_reverse" full_name="List.length_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(45, 28)" end="(45, 29)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(46, 3)" end="(46, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂.reverse[i]? = some l₁.reverse[i]) ↔&#10;    ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]" state_after="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂.reverse[i]? = some l₁.reverse[i]) →&#10;    ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]) →&#10;    ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂.reverse[i]? = some l₁.reverse[i]" tactic="constructor">
                    <AtomNode start="(46, 3)" end="(46, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(47, 3)" end="(54, 10)" kind="Lean.cdot" state_before="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂.reverse[i]? = some l₁.reverse[i]) →&#10;    ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]) →&#10;    ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂.reverse[i]? = some l₁.reverse[i]" state_after="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]) →&#10;    ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂.reverse[i]? = some l₁.reverse[i]" tactic="· intro w i h&#10;  specialize w (l₁.length - 1 - i) (by omega)&#10;  rw [getElem?_reverse (by omega)] at w&#10;  have p : l₂.length - 1 - (l₁.length - 1 - i) = i + l₂.length - l₁.length := by omega&#10;  rw [p] at w&#10;  rw [w, getElem_reverse]&#10;  congr&#10;  omega">
                    <OtherNode start="(47, 3)" end="(47, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(47, 3)" end="(47, 4)" kind="patternIgnore">
                        <OtherNode start="(47, 3)" end="(47, 4)" kind="token.«· »">
                          <AtomNode start="(47, 3)" end="(47, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(47, 5)" end="(54, 10)">
                      <TacticTacticseq1IndentedNode start="(47, 5)" end="(54, 10)">
                        <NullNode start="(47, 5)" end="(54, 10)">
                          <OtherNode start="(47, 5)" end="(47, 16)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂.reverse[i]? = some l₁.reverse[i]) →&#10;    ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]" state_after="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂.reverse[i]? = some l₁.reverse[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ l₂[i + l₂.length - l₁.length]? = some l₁[i]" tactic="intro w i h">
                            <AtomNode start="(47, 5)" end="(47, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(47, 11)" end="(47, 16)">
                              <IdentNode start="(47, 11)" end="(47, 12)" leading="" trailing=" " raw_val="w" val="w"/>
                              <IdentNode start="(47, 13)" end="(47, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                              <IdentNode start="(47, 15)" end="(47, 16)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(48, 5)" end="(48, 48)" kind="Lean.Parser.Tactic.specialize" state_before="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂.reverse[i]? = some l₁.reverse[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ l₂[i + l₂.length - l₁.length]? = some l₁[i]" state_after="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂.reverse[l₁.length - 1 - i]? = some l₁.reverse[l₁.length - 1 - i]&#10;⊢ l₂[i + l₂.length - l₁.length]? = some l₁[i]" tactic="specialize w (l₁.length - 1 - i) (by omega)">
                            <AtomNode start="(48, 5)" end="(48, 15)" leading="" trailing=" " val="specialize"/>
                            <OtherNode start="(48, 16)" end="(48, 48)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(48, 16)" end="(48, 17)" leading="" trailing=" " raw_val="w" val="w"/>
                              <NullNode start="(48, 18)" end="(48, 48)">
                                <OtherNode start="(48, 18)" end="(48, 37)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(48, 18)" end="(48, 19)" leading="" trailing="" val="("/>
                                  <OtherNode start="(48, 19)" end="(48, 36)" kind="«term_-_»">
                                    <OtherNode start="(48, 19)" end="(48, 32)" kind="«term_-_»">
                                      <IdentNode start="(48, 19)" end="(48, 28)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                                      <AtomNode start="(48, 29)" end="(48, 30)" leading="" trailing=" " val="-"/>
                                      <OtherNode start="(48, 31)" end="(48, 32)" kind="num">
                                        <AtomNode start="(48, 31)" end="(48, 32)" leading="" trailing=" " val="1"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <AtomNode start="(48, 33)" end="(48, 34)" leading="" trailing=" " val="-"/>
                                    <IdentNode start="(48, 35)" end="(48, 36)" leading="" trailing="" raw_val="i" val="i"/>
                                  </OtherNode>
                                  <AtomNode start="(48, 36)" end="(48, 37)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <OtherNode start="(48, 38)" end="(48, 48)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(48, 38)" end="(48, 39)" leading="" trailing="" val="("/>
                                  <TermBytacticNode start="(48, 39)" end="(48, 47)">
                                    <AtomNode start="(48, 39)" end="(48, 41)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(48, 42)" end="(48, 47)">
                                      <TacticTacticseq1IndentedNode start="(48, 42)" end="(48, 47)">
                                        <NullNode start="(48, 42)" end="(48, 47)">
                                          <OtherNode start="(48, 42)" end="(48, 47)" kind="Lean.Parser.Tactic.omega" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂.reverse[i]? = some l₁.reverse[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ l₁.length - 1 - i &amp;lt; l₁.length" state_after="no goals" tactic="omega">
                                            <AtomNode start="(48, 42)" end="(48, 47)" leading="" trailing="" val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                  <AtomNode start="(48, 47)" end="(48, 48)" leading="" trailing="&#10;    " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(49, 5)" end="(49, 42)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂.reverse[l₁.length - 1 - i]? = some l₁.reverse[l₁.length - 1 - i]&#10;⊢ l₂[i + l₂.length - l₁.length]? = some l₁[i]" state_after="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[l₂.length - 1 - (l₁.length - 1 - i)]? = some l₁.reverse[l₁.length - 1 - i]&#10;⊢ l₂[i + l₂.length - l₁.length]? = some l₁[i]" tactic="rw [getElem?_reverse (by omega)] at w">
                            <AtomNode start="(49, 5)" end="(49, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(49, 8)" end="(49, 37)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(49, 8)" end="(49, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(49, 9)" end="(49, 36)">
                                <OtherNode start="(49, 9)" end="(49, 36)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(49, 9)" end="(49, 36)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(49, 9)" end="(49, 25)" leading="" trailing=" " raw_val="getElem?_reverse" val="getElem?_reverse" full_name="List.getElem?_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                    <NullNode start="(49, 26)" end="(49, 36)">
                                      <OtherNode start="(49, 26)" end="(49, 36)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(49, 26)" end="(49, 27)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(49, 27)" end="(49, 35)">
                                          <AtomNode start="(49, 27)" end="(49, 29)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(49, 30)" end="(49, 35)">
                                            <TacticTacticseq1IndentedNode start="(49, 30)" end="(49, 35)">
                                              <NullNode start="(49, 30)" end="(49, 35)">
                                                <OtherNode start="(49, 30)" end="(49, 35)" kind="Lean.Parser.Tactic.omega" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂.reverse[l₁.length - 1 - i]? = some l₁.reverse[l₁.length - 1 - i]&#10;⊢ l₁.length - 1 - i &amp;lt; l₂.length" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(49, 30)" end="(49, 35)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(49, 35)" end="(49, 36)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(49, 36)" end="(49, 37)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(49, 38)" end="(49, 42)">
                              <OtherNode start="(49, 38)" end="(49, 42)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(49, 38)" end="(49, 40)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(49, 41)" end="(49, 42)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(49, 41)" end="(49, 42)">
                                    <IdentNode start="(49, 41)" end="(49, 42)" leading="" trailing="&#10;    " raw_val="w" val="w"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(50, 5)" end="(50, 89)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[l₂.length - 1 - (l₁.length - 1 - i)]? = some l₁.reverse[l₁.length - 1 - i]&#10;⊢ l₂[i + l₂.length - l₁.length]? = some l₁[i]" state_after="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[l₂.length - 1 - (l₁.length - 1 - i)]? = some l₁.reverse[l₁.length - 1 - i]&#10;p : l₂.length - 1 - (l₁.length - 1 - i) = i + l₂.length - l₁.length&#10;⊢ l₂[i + l₂.length - l₁.length]? = some l₁[i]" tactic="have p : l₂.length - 1 - (l₁.length - 1 - i) = i + l₂.length - l₁.length := by omega">
                            <AtomNode start="(50, 5)" end="(50, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(50, 10)" end="(50, 89)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(50, 10)" end="(50, 89)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(50, 10)" end="(50, 11)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(50, 10)" end="(50, 11)" leading="" trailing=" " raw_val="p" val="p"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(50, 12)" end="(50, 77)">
                                  <TermTypespecNode start="(50, 12)" end="(50, 77)">
                                    <AtomNode start="(50, 12)" end="(50, 13)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(50, 14)" end="(50, 77)" kind="«term_=_»">
                                      <OtherNode start="(50, 14)" end="(50, 49)" kind="«term_-_»">
                                        <OtherNode start="(50, 14)" end="(50, 27)" kind="«term_-_»">
                                          <IdentNode start="(50, 14)" end="(50, 23)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                                          <AtomNode start="(50, 24)" end="(50, 25)" leading="" trailing=" " val="-"/>
                                          <OtherNode start="(50, 26)" end="(50, 27)" kind="num">
                                            <AtomNode start="(50, 26)" end="(50, 27)" leading="" trailing=" " val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(50, 28)" end="(50, 29)" leading="" trailing=" " val="-"/>
                                        <OtherNode start="(50, 30)" end="(50, 49)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(50, 30)" end="(50, 31)" leading="" trailing="" val="("/>
                                          <OtherNode start="(50, 31)" end="(50, 48)" kind="«term_-_»">
                                            <OtherNode start="(50, 31)" end="(50, 44)" kind="«term_-_»">
                                              <IdentNode start="(50, 31)" end="(50, 40)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                                              <AtomNode start="(50, 41)" end="(50, 42)" leading="" trailing=" " val="-"/>
                                              <OtherNode start="(50, 43)" end="(50, 44)" kind="num">
                                                <AtomNode start="(50, 43)" end="(50, 44)" leading="" trailing=" " val="1"/>
                                              </OtherNode>
                                            </OtherNode>
                                            <AtomNode start="(50, 45)" end="(50, 46)" leading="" trailing=" " val="-"/>
                                            <IdentNode start="(50, 47)" end="(50, 48)" leading="" trailing="" raw_val="i" val="i"/>
                                          </OtherNode>
                                          <AtomNode start="(50, 48)" end="(50, 49)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(50, 50)" end="(50, 51)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(50, 52)" end="(50, 77)" kind="«term_-_»">
                                        <OtherNode start="(50, 52)" end="(50, 65)" kind="«term_+_»">
                                          <IdentNode start="(50, 52)" end="(50, 53)" leading="" trailing=" " raw_val="i" val="i"/>
                                          <AtomNode start="(50, 54)" end="(50, 55)" leading="" trailing=" " val="+"/>
                                          <IdentNode start="(50, 56)" end="(50, 65)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                                        </OtherNode>
                                        <AtomNode start="(50, 66)" end="(50, 67)" leading="" trailing=" " val="-"/>
                                        <IdentNode start="(50, 68)" end="(50, 77)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(50, 78)" end="(50, 80)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(50, 81)" end="(50, 89)">
                                  <AtomNode start="(50, 81)" end="(50, 83)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(50, 84)" end="(50, 89)">
                                    <TacticTacticseq1IndentedNode start="(50, 84)" end="(50, 89)">
                                      <NullNode start="(50, 84)" end="(50, 89)">
                                        <OtherNode start="(50, 84)" end="(50, 89)" kind="Lean.Parser.Tactic.omega" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[l₂.length - 1 - (l₁.length - 1 - i)]? = some l₁.reverse[l₁.length - 1 - i]&#10;⊢ l₂.length - 1 - (l₁.length - 1 - i) = i + l₂.length - l₁.length" state_after="no goals" tactic="omega">
                                          <AtomNode start="(50, 84)" end="(50, 89)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(51, 5)" end="(51, 16)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[l₂.length - 1 - (l₁.length - 1 - i)]? = some l₁.reverse[l₁.length - 1 - i]&#10;p : l₂.length - 1 - (l₁.length - 1 - i) = i + l₂.length - l₁.length&#10;⊢ l₂[i + l₂.length - l₁.length]? = some l₁[i]" state_after="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[i + l₂.length - l₁.length]? = some l₁.reverse[l₁.length - 1 - i]&#10;p : l₂.length - 1 - (l₁.length - 1 - i) = i + l₂.length - l₁.length&#10;⊢ l₂[i + l₂.length - l₁.length]? = some l₁[i]" tactic="rw [p] at w">
                            <AtomNode start="(51, 5)" end="(51, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(51, 8)" end="(51, 11)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(51, 8)" end="(51, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(51, 9)" end="(51, 10)">
                                <OtherNode start="(51, 9)" end="(51, 10)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(51, 9)" end="(51, 10)" leading="" trailing="" raw_val="p" val="p"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(51, 10)" end="(51, 11)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(51, 12)" end="(51, 16)">
                              <OtherNode start="(51, 12)" end="(51, 16)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(51, 12)" end="(51, 14)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(51, 15)" end="(51, 16)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(51, 15)" end="(51, 16)">
                                    <IdentNode start="(51, 15)" end="(51, 16)" leading="" trailing="&#10;    " raw_val="w" val="w"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(52, 5)" end="(52, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[i + l₂.length - l₁.length]? = some l₁.reverse[l₁.length - 1 - i]&#10;p : l₂.length - 1 - (l₁.length - 1 - i) = i + l₂.length - l₁.length&#10;⊢ l₂[i + l₂.length - l₁.length]? = some l₁[i]" state_after="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[i + l₂.length - l₁.length]? = some l₁.reverse[l₁.length - 1 - i]&#10;p : l₂.length - 1 - (l₁.length - 1 - i) = i + l₂.length - l₁.length&#10;⊢ some l₁[l₁.length - 1 - (l₁.length - 1 - i)] = some l₁[i]" tactic="rw [w, getElem_reverse]">
                            <AtomNode start="(52, 5)" end="(52, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(52, 8)" end="(52, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(52, 8)" end="(52, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(52, 9)" end="(52, 27)">
                                <OtherNode start="(52, 9)" end="(52, 10)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(52, 9)" end="(52, 10)" leading="" trailing="" raw_val="w" val="w"/>
                                </OtherNode>
                                <AtomNode start="(52, 10)" end="(52, 11)" leading="" trailing=" " val=","/>
                                <OtherNode start="(52, 12)" end="(52, 27)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(52, 12)" end="(52, 27)" leading="" trailing="" raw_val="getElem_reverse" val="getElem_reverse" full_name="List.getElem_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(52, 27)" end="(52, 28)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(53, 5)" end="(53, 10)" kind="Lean.Parser.Tactic.congr" state_before="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[i + l₂.length - l₁.length]? = some l₁.reverse[l₁.length - 1 - i]&#10;p : l₂.length - 1 - (l₁.length - 1 - i) = i + l₂.length - l₁.length&#10;⊢ some l₁[l₁.length - 1 - (l₁.length - 1 - i)] = some l₁[i]" state_after="case mp.e_val.e_i&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[i + l₂.length - l₁.length]? = some l₁.reverse[l₁.length - 1 - i]&#10;p : l₂.length - 1 - (l₁.length - 1 - i) = i + l₂.length - l₁.length&#10;⊢ l₁.length - 1 - (l₁.length - 1 - i) = i" tactic="congr">
                            <AtomNode start="(53, 5)" end="(53, 10)" leading="" trailing="&#10;    " val="congr"/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(54, 5)" end="(54, 10)" kind="Lean.Parser.Tactic.omega" state_before="case mp.e_val.e_i&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[i + l₂.length - l₁.length]? = some l₁.reverse[l₁.length - 1 - i]&#10;p : l₂.length - 1 - (l₁.length - 1 - i) = i + l₂.length - l₁.length&#10;⊢ l₁.length - 1 - (l₁.length - 1 - i) = i" state_after="no goals" tactic="omega">
                            <AtomNode start="(54, 5)" end="(54, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(55, 3)" end="(61, 34)" kind="Lean.cdot" state_before="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]) →&#10;    ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂.reverse[i]? = some l₁.reverse[i]" state_after="no goals" tactic="· intro w i h&#10;  rw [getElem?_reverse]&#10;  specialize w (l₁.length - 1 - i) (by omega)&#10;  have p : l₁.length - 1 - i + l₂.length - l₁.length = l₂.length - 1 - i := by omega&#10;  rw [p] at w&#10;  rw [w, getElem_reverse]&#10;  exact Nat.lt_of_lt_of_le h le">
                    <OtherNode start="(55, 3)" end="(55, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(55, 3)" end="(55, 4)" kind="patternIgnore">
                        <OtherNode start="(55, 3)" end="(55, 4)" kind="token.«· »">
                          <AtomNode start="(55, 3)" end="(55, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(55, 5)" end="(61, 34)">
                      <TacticTacticseq1IndentedNode start="(55, 5)" end="(61, 34)">
                        <NullNode start="(55, 5)" end="(61, 34)">
                          <OtherNode start="(55, 5)" end="(55, 16)" kind="Lean.Parser.Tactic.intro" state_before="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]) →&#10;    ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂.reverse[i]? = some l₁.reverse[i]" state_after="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ l₂.reverse[i]? = some l₁.reverse[i]" tactic="intro w i h">
                            <AtomNode start="(55, 5)" end="(55, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(55, 11)" end="(55, 16)">
                              <IdentNode start="(55, 11)" end="(55, 12)" leading="" trailing=" " raw_val="w" val="w"/>
                              <IdentNode start="(55, 13)" end="(55, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                              <IdentNode start="(55, 15)" end="(55, 16)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(56, 5)" end="(56, 26)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ l₂.reverse[i]? = some l₁.reverse[i]" state_after="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ l₂[l₂.length - 1 - i]? = some l₁.reverse[i]&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ i &amp;lt; l₂.length" tactic="rw [getElem?_reverse]">
                            <AtomNode start="(56, 5)" end="(56, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(56, 8)" end="(56, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(56, 8)" end="(56, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(56, 9)" end="(56, 25)">
                                <OtherNode start="(56, 9)" end="(56, 25)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(56, 9)" end="(56, 25)" leading="" trailing="" raw_val="getElem?_reverse" val="getElem?_reverse" full_name="List.getElem?_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(56, 25)" end="(56, 26)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(57, 5)" end="(57, 48)" kind="Lean.Parser.Tactic.specialize" state_before="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ l₂[l₂.length - 1 - i]? = some l₁.reverse[i]&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ i &amp;lt; l₂.length" state_after="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[l₁.length - 1 - i + l₂.length - l₁.length]? = some l₁[l₁.length - 1 - i]&#10;⊢ l₂[l₂.length - 1 - i]? = some l₁.reverse[i]&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ i &amp;lt; l₂.length" tactic="specialize w (l₁.length - 1 - i) (by omega)">
                            <AtomNode start="(57, 5)" end="(57, 15)" leading="" trailing=" " val="specialize"/>
                            <OtherNode start="(57, 16)" end="(57, 48)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(57, 16)" end="(57, 17)" leading="" trailing=" " raw_val="w" val="w"/>
                              <NullNode start="(57, 18)" end="(57, 48)">
                                <OtherNode start="(57, 18)" end="(57, 37)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(57, 18)" end="(57, 19)" leading="" trailing="" val="("/>
                                  <OtherNode start="(57, 19)" end="(57, 36)" kind="«term_-_»">
                                    <OtherNode start="(57, 19)" end="(57, 32)" kind="«term_-_»">
                                      <IdentNode start="(57, 19)" end="(57, 28)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                                      <AtomNode start="(57, 29)" end="(57, 30)" leading="" trailing=" " val="-"/>
                                      <OtherNode start="(57, 31)" end="(57, 32)" kind="num">
                                        <AtomNode start="(57, 31)" end="(57, 32)" leading="" trailing=" " val="1"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <AtomNode start="(57, 33)" end="(57, 34)" leading="" trailing=" " val="-"/>
                                    <IdentNode start="(57, 35)" end="(57, 36)" leading="" trailing="" raw_val="i" val="i"/>
                                  </OtherNode>
                                  <AtomNode start="(57, 36)" end="(57, 37)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <OtherNode start="(57, 38)" end="(57, 48)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(57, 38)" end="(57, 39)" leading="" trailing="" val="("/>
                                  <TermBytacticNode start="(57, 39)" end="(57, 47)">
                                    <AtomNode start="(57, 39)" end="(57, 41)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(57, 42)" end="(57, 47)">
                                      <TacticTacticseq1IndentedNode start="(57, 42)" end="(57, 47)">
                                        <NullNode start="(57, 42)" end="(57, 47)">
                                          <OtherNode start="(57, 42)" end="(57, 47)" kind="Lean.Parser.Tactic.omega" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ l₁.length - 1 - i &amp;lt; l₁.length" state_after="no goals" tactic="omega">
                                            <AtomNode start="(57, 42)" end="(57, 47)" leading="" trailing="" val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                  <AtomNode start="(57, 47)" end="(57, 48)" leading="" trailing="&#10;    " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(58, 5)" end="(58, 87)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[l₁.length - 1 - i + l₂.length - l₁.length]? = some l₁[l₁.length - 1 - i]&#10;⊢ l₂[l₂.length - 1 - i]? = some l₁.reverse[i]&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ i &amp;lt; l₂.length" state_after="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[l₁.length - 1 - i + l₂.length - l₁.length]? = some l₁[l₁.length - 1 - i]&#10;p : l₁.length - 1 - i + l₂.length - l₁.length = l₂.length - 1 - i&#10;⊢ l₂[l₂.length - 1 - i]? = some l₁.reverse[i]&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ i &amp;lt; l₂.length" tactic="have p : l₁.length - 1 - i + l₂.length - l₁.length = l₂.length - 1 - i := by omega">
                            <AtomNode start="(58, 5)" end="(58, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(58, 10)" end="(58, 87)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(58, 10)" end="(58, 87)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(58, 10)" end="(58, 11)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(58, 10)" end="(58, 11)" leading="" trailing=" " raw_val="p" val="p"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(58, 12)" end="(58, 75)">
                                  <TermTypespecNode start="(58, 12)" end="(58, 75)">
                                    <AtomNode start="(58, 12)" end="(58, 13)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(58, 14)" end="(58, 75)" kind="«term_=_»">
                                      <OtherNode start="(58, 14)" end="(58, 55)" kind="«term_-_»">
                                        <OtherNode start="(58, 14)" end="(58, 43)" kind="«term_+_»">
                                          <OtherNode start="(58, 14)" end="(58, 31)" kind="«term_-_»">
                                            <OtherNode start="(58, 14)" end="(58, 27)" kind="«term_-_»">
                                              <IdentNode start="(58, 14)" end="(58, 23)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                                              <AtomNode start="(58, 24)" end="(58, 25)" leading="" trailing=" " val="-"/>
                                              <OtherNode start="(58, 26)" end="(58, 27)" kind="num">
                                                <AtomNode start="(58, 26)" end="(58, 27)" leading="" trailing=" " val="1"/>
                                              </OtherNode>
                                            </OtherNode>
                                            <AtomNode start="(58, 28)" end="(58, 29)" leading="" trailing=" " val="-"/>
                                            <IdentNode start="(58, 30)" end="(58, 31)" leading="" trailing=" " raw_val="i" val="i"/>
                                          </OtherNode>
                                          <AtomNode start="(58, 32)" end="(58, 33)" leading="" trailing=" " val="+"/>
                                          <IdentNode start="(58, 34)" end="(58, 43)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                                        </OtherNode>
                                        <AtomNode start="(58, 44)" end="(58, 45)" leading="" trailing=" " val="-"/>
                                        <IdentNode start="(58, 46)" end="(58, 55)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                                      </OtherNode>
                                      <AtomNode start="(58, 56)" end="(58, 57)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(58, 58)" end="(58, 75)" kind="«term_-_»">
                                        <OtherNode start="(58, 58)" end="(58, 71)" kind="«term_-_»">
                                          <IdentNode start="(58, 58)" end="(58, 67)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                                          <AtomNode start="(58, 68)" end="(58, 69)" leading="" trailing=" " val="-"/>
                                          <OtherNode start="(58, 70)" end="(58, 71)" kind="num">
                                            <AtomNode start="(58, 70)" end="(58, 71)" leading="" trailing=" " val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(58, 72)" end="(58, 73)" leading="" trailing=" " val="-"/>
                                        <IdentNode start="(58, 74)" end="(58, 75)" leading="" trailing=" " raw_val="i" val="i"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(58, 76)" end="(58, 78)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(58, 79)" end="(58, 87)">
                                  <AtomNode start="(58, 79)" end="(58, 81)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(58, 82)" end="(58, 87)">
                                    <TacticTacticseq1IndentedNode start="(58, 82)" end="(58, 87)">
                                      <NullNode start="(58, 82)" end="(58, 87)">
                                        <OtherNode start="(58, 82)" end="(58, 87)" kind="Lean.Parser.Tactic.omega" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[l₁.length - 1 - i + l₂.length - l₁.length]? = some l₁[l₁.length - 1 - i]&#10;⊢ l₁.length - 1 - i + l₂.length - l₁.length = l₂.length - 1 - i" state_after="no goals" tactic="omega">
                                          <AtomNode start="(58, 82)" end="(58, 87)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(59, 5)" end="(59, 16)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[l₁.length - 1 - i + l₂.length - l₁.length]? = some l₁[l₁.length - 1 - i]&#10;p : l₁.length - 1 - i + l₂.length - l₁.length = l₂.length - 1 - i&#10;⊢ l₂[l₂.length - 1 - i]? = some l₁.reverse[i]&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ i &amp;lt; l₂.length" state_after="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[l₂.length - 1 - i]? = some l₁[l₁.length - 1 - i]&#10;p : l₁.length - 1 - i + l₂.length - l₁.length = l₂.length - 1 - i&#10;⊢ l₂[l₂.length - 1 - i]? = some l₁.reverse[i]&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ i &amp;lt; l₂.length" tactic="rw [p] at w">
                            <AtomNode start="(59, 5)" end="(59, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(59, 8)" end="(59, 11)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(59, 8)" end="(59, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(59, 9)" end="(59, 10)">
                                <OtherNode start="(59, 9)" end="(59, 10)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(59, 9)" end="(59, 10)" leading="" trailing="" raw_val="p" val="p"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(59, 10)" end="(59, 11)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(59, 12)" end="(59, 16)">
                              <OtherNode start="(59, 12)" end="(59, 16)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(59, 12)" end="(59, 14)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(59, 15)" end="(59, 16)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(59, 15)" end="(59, 16)">
                                    <IdentNode start="(59, 15)" end="(59, 16)" leading="" trailing="&#10;    " raw_val="w" val="w"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(60, 5)" end="(60, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;w : l₂[l₂.length - 1 - i]? = some l₁[l₁.length - 1 - i]&#10;p : l₁.length - 1 - i + l₂.length - l₁.length = l₂.length - 1 - i&#10;⊢ l₂[l₂.length - 1 - i]? = some l₁.reverse[i]&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ i &amp;lt; l₂.length" state_after="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ i &amp;lt; l₂.length" tactic="rw [w, getElem_reverse]">
                            <AtomNode start="(60, 5)" end="(60, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(60, 8)" end="(60, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(60, 8)" end="(60, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(60, 9)" end="(60, 27)">
                                <OtherNode start="(60, 9)" end="(60, 10)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(60, 9)" end="(60, 10)" leading="" trailing="" raw_val="w" val="w"/>
                                </OtherNode>
                                <AtomNode start="(60, 10)" end="(60, 11)" leading="" trailing=" " val=","/>
                                <OtherNode start="(60, 12)" end="(60, 27)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(60, 12)" end="(60, 27)" leading="" trailing="" raw_val="getElem_reverse" val="getElem_reverse" full_name="List.getElem_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(60, 27)" end="(60, 28)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(61, 5)" end="(61, 34)" kind="Lean.Parser.Tactic.exact" state_before="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;le : l₁.length ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + l₂.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ i &amp;lt; l₂.length" state_after="no goals" tactic="exact Nat.lt_of_lt_of_le h le">
                            <AtomNode start="(61, 5)" end="(61, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(61, 11)" end="(61, 34)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(61, 11)" end="(61, 29)" leading="" trailing=" " raw_val="Nat.lt_of_lt_of_le" val="Nat.lt_of_lt_of_le" full_name="Nat.lt_of_lt_of_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                              <NullNode start="(61, 30)" end="(61, 34)">
                                <IdentNode start="(61, 30)" end="(61, 31)" leading="" trailing=" " raw_val="h" val="h"/>
                                <IdentNode start="(61, 32)" end="(61, 34)" leading="" trailing="&#10;&#10;" raw_val="le" val="le"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(63, 1)" end="(94, 12)" name="isInfix_iff" full_name="List.isInfix_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(63, 1)" end="(94, 12)" name="isInfix_iff" full_name="List.isInfix_iff" _is_private_decl="False">
        <AtomNode start="(63, 1)" end="(63, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(63, 9)" end="(63, 20)">
          <IdentNode start="(63, 9)" end="(63, 20)" leading="" trailing=" " raw_val="isInfix_iff" val="isInfix_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(63, 21)" end="(64, 86)">
          <NullNode/>
          <TermTypespecNode start="(63, 21)" end="(64, 86)">
            <AtomNode start="(63, 21)" end="(63, 22)" leading="" trailing=" " val=":"/>
            <OtherNode start="(63, 23)" end="(64, 86)" kind="«term_↔_»">
              <OtherNode start="(63, 23)" end="(63, 33)" kind="List.«term_&amp;lt;:+:_»">
                <IdentNode start="(63, 23)" end="(63, 25)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(63, 26)" end="(63, 30)" leading="" trailing=" " val="&amp;lt;:+:"/>
                <IdentNode start="(63, 31)" end="(63, 33)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
              <AtomNode start="(63, 34)" end="(63, 35)" leading="" trailing="&#10;    " val="↔"/>
              <OtherNode start="(64, 5)" end="(64, 86)" kind="«term∃_,_»">
                <AtomNode start="(64, 5)" end="(64, 6)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(64, 7)" end="(64, 8)" kind="Lean.explicitBinders">
                  <OtherNode start="(64, 7)" end="(64, 8)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(64, 7)" end="(64, 8)">
                      <LeanBinderidentNode start="(64, 7)" end="(64, 8)">
                        <IdentNode start="(64, 7)" end="(64, 8)" leading="" trailing="" raw_val="k" val="k"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(64, 8)" end="(64, 9)" leading="" trailing=" " val=","/>
                <OtherNode start="(64, 10)" end="(64, 86)" kind="«term_∧_»">
                  <OtherNode start="(64, 10)" end="(64, 35)" kind="«term_≤_»">
                    <OtherNode start="(64, 10)" end="(64, 23)" kind="«term_+_»">
                      <IdentNode start="(64, 10)" end="(64, 19)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                      <AtomNode start="(64, 20)" end="(64, 21)" leading="" trailing=" " val="+"/>
                      <IdentNode start="(64, 22)" end="(64, 23)" leading="" trailing=" " raw_val="k" val="k"/>
                    </OtherNode>
                    <AtomNode start="(64, 24)" end="(64, 25)" leading="" trailing=" " val="≤"/>
                    <IdentNode start="(64, 26)" end="(64, 35)" leading="" trailing=" " raw_val="l₂.length" val="l₂.length"/>
                  </OtherNode>
                  <AtomNode start="(64, 36)" end="(64, 37)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(64, 38)" end="(64, 86)" kind="Lean.Parser.Term.forall">
                    <AtomNode start="(64, 38)" end="(64, 39)" leading="" trailing=" " val="∀"/>
                    <NullNode start="(64, 40)" end="(64, 61)">
                      <IdentNode start="(64, 40)" end="(64, 41)" leading="" trailing=" " raw_val="i" val="i"/>
                      <TermExplicitbinderNode start="(64, 42)" end="(64, 61)">
                        <AtomNode start="(64, 42)" end="(64, 43)" leading="" trailing="" val="("/>
                        <NullNode start="(64, 43)" end="(64, 44)">
                          <IdentNode start="(64, 43)" end="(64, 44)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(64, 45)" end="(64, 60)">
                          <AtomNode start="(64, 45)" end="(64, 46)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(64, 47)" end="(64, 60)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(64, 47)" end="(64, 48)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(64, 49)" end="(64, 50)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(64, 51)" end="(64, 60)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(64, 60)" end="(64, 61)" leading="" trailing="" val=")"/>
                      </TermExplicitbinderNode>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(64, 61)" end="(64, 62)" leading="" trailing=" " val=","/>
                    <OtherNode start="(64, 63)" end="(64, 86)" kind="«term_=_»">
                      <OtherNode start="(64, 63)" end="(64, 73)" kind="«term__[_]_?»">
                        <IdentNode start="(64, 63)" end="(64, 65)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                        <GroupNode/>
                        <AtomNode start="(64, 65)" end="(64, 66)" leading="" trailing="" val="["/>
                        <OtherNode start="(64, 66)" end="(64, 71)" kind="«term_+_»">
                          <IdentNode start="(64, 66)" end="(64, 67)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(64, 68)" end="(64, 69)" leading="" trailing=" " val="+"/>
                          <IdentNode start="(64, 70)" end="(64, 71)" leading="" trailing="" raw_val="k" val="k"/>
                        </OtherNode>
                        <AtomNode start="(64, 71)" end="(64, 72)" leading="" trailing="" val="]"/>
                        <GroupNode/>
                        <AtomNode start="(64, 72)" end="(64, 73)" leading="" trailing=" " val="?"/>
                      </OtherNode>
                      <AtomNode start="(64, 74)" end="(64, 75)" leading="" trailing=" " val="="/>
                      <OtherNode start="(64, 76)" end="(64, 86)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(64, 76)" end="(64, 80)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(64, 81)" end="(64, 86)">
                          <OtherNode start="(64, 81)" end="(64, 86)" kind="«term__[_]»">
                            <IdentNode start="(64, 81)" end="(64, 83)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                            <AtomNode start="(64, 83)" end="(64, 84)" leading="" trailing="" val="["/>
                            <IdentNode start="(64, 84)" end="(64, 85)" leading="" trailing="" raw_val="i" val="i"/>
                            <AtomNode start="(64, 85)" end="(64, 86)" leading="" trailing=" " val="]"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(64, 87)" end="(94, 12)">
          <AtomNode start="(64, 87)" end="(64, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(64, 90)" end="(94, 12)">
            <AtomNode start="(64, 90)" end="(64, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(65, 3)" end="(94, 12)">
              <TacticTacticseq1IndentedNode start="(65, 3)" end="(94, 12)">
                <NullNode start="(65, 3)" end="(94, 12)">
                  <OtherNode start="(65, 3)" end="(65, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ l₁ &amp;lt;:+: l₂ ↔ ∃ k, l₁.length + k ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]" state_after="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ l₁ &amp;lt;:+: l₂ → ∃ k, l₁.length + k ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ (∃ k, l₁.length + k ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]) → l₁ &amp;lt;:+: l₂" tactic="constructor">
                    <AtomNode start="(65, 3)" end="(65, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(66, 3)" end="(76, 34)" kind="Lean.cdot" state_before="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ l₁ &amp;lt;:+: l₂ → ∃ k, l₁.length + k ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;&#10;case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ (∃ k, l₁.length + k ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]) → l₁ &amp;lt;:+: l₂" state_after="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ (∃ k, l₁.length + k ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]) → l₁ &amp;lt;:+: l₂" tactic="· intro h&#10;  obtain ⟨t, p, s⟩ := infix_iff_suffix_prefix.mp h&#10;  refine ⟨t.length - l₁.length, by have := p.length_le; have := s.length_le; omega, ?_⟩&#10;  rw [isSuffix_iff] at p&#10;  obtain ⟨p', p⟩ := p&#10;  rw [isPrefix_iff] at s&#10;  intro i h&#10;  rw [s _ (by omega)]&#10;  specialize p i (by omega)&#10;  rw [Nat.add_sub_assoc (by omega)] at p&#10;  rw [← getElem?_eq_getElem, p]">
                    <OtherNode start="(66, 3)" end="(66, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(66, 3)" end="(66, 4)" kind="patternIgnore">
                        <OtherNode start="(66, 3)" end="(66, 4)" kind="token.«· »">
                          <AtomNode start="(66, 3)" end="(66, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(66, 5)" end="(76, 34)">
                      <TacticTacticseq1IndentedNode start="(66, 5)" end="(76, 34)">
                        <NullNode start="(66, 5)" end="(76, 34)">
                          <OtherNode start="(66, 5)" end="(66, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ l₁ &amp;lt;:+: l₂ → ∃ k, l₁.length + k ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]" state_after="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;⊢ ∃ k, l₁.length + k ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]" tactic="intro h">
                            <AtomNode start="(66, 5)" end="(66, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(66, 11)" end="(66, 12)">
                              <IdentNode start="(66, 11)" end="(66, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(67, 5)" end="(67, 53)" kind="Lean.Parser.Tactic.obtain" state_before="case mp&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;⊢ ∃ k, l₁.length + k ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]" state_after="case mp.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;p : l₁ &amp;lt;:+ t&#10;s : t &amp;lt;+: l₂&#10;⊢ ∃ k, l₁.length + k ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]" tactic="obtain ⟨t, p, s⟩ := infix_iff_suffix_prefix.mp h">
                            <AtomNode start="(67, 5)" end="(67, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(67, 12)" end="(67, 21)">
                              <OtherNode start="(67, 12)" end="(67, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(67, 12)" end="(67, 21)">
                                  <OtherNode start="(67, 12)" end="(67, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(67, 12)" end="(67, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(67, 13)" end="(67, 20)">
                                      <OtherNode start="(67, 13)" end="(67, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(67, 13)" end="(67, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(67, 13)" end="(67, 14)">
                                            <OtherNode start="(67, 13)" end="(67, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(67, 13)" end="(67, 14)" leading="" trailing="" raw_val="t" val="t"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(67, 14)" end="(67, 15)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(67, 16)" end="(67, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(67, 16)" end="(67, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(67, 16)" end="(67, 17)">
                                            <OtherNode start="(67, 16)" end="(67, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(67, 16)" end="(67, 17)" leading="" trailing="" raw_val="p" val="p"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(67, 17)" end="(67, 18)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(67, 19)" end="(67, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(67, 19)" end="(67, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(67, 19)" end="(67, 20)">
                                            <OtherNode start="(67, 19)" end="(67, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(67, 19)" end="(67, 20)" leading="" trailing="" raw_val="s" val="s"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(67, 20)" end="(67, 21)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(67, 22)" end="(67, 53)">
                              <AtomNode start="(67, 22)" end="(67, 24)" leading="" trailing=" " val=":="/>
                              <NullNode start="(67, 25)" end="(67, 53)">
                                <OtherNode start="(67, 25)" end="(67, 53)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(67, 25)" end="(67, 51)" leading="" trailing=" " raw_val="infix_iff_suffix_prefix.mp" val="infix_iff_suffix_prefix.mp"/>
                                  <NullNode start="(67, 52)" end="(67, 53)">
                                    <IdentNode start="(67, 52)" end="(67, 53)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(68, 5)" end="(68, 90)" kind="Lean.Parser.Tactic.refine" state_before="case mp.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;p : l₁ &amp;lt;:+ t&#10;s : t &amp;lt;+: l₂&#10;⊢ ∃ k, l₁.length + k ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]" state_after="case mp.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;p : l₁ &amp;lt;:+ t&#10;s : t &amp;lt;+: l₂&#10;⊢ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + (t.length - l₁.length)]? = some l₁[i]" tactic="refine ⟨t.length - l₁.length, by have := p.length_le; have := s.length_le; omega, ?_⟩">
                            <AtomNode start="(68, 5)" end="(68, 11)" leading="" trailing=" " val="refine"/>
                            <OtherNode start="(68, 12)" end="(68, 90)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(68, 12)" end="(68, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(68, 13)" end="(68, 89)">
                                <OtherNode start="(68, 13)" end="(68, 33)" kind="«term_-_»">
                                  <IdentNode start="(68, 13)" end="(68, 21)" leading="" trailing=" " raw_val="t.length" val="t.length"/>
                                  <AtomNode start="(68, 22)" end="(68, 23)" leading="" trailing=" " val="-"/>
                                  <IdentNode start="(68, 24)" end="(68, 33)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                                </OtherNode>
                                <AtomNode start="(68, 33)" end="(68, 34)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(68, 35)" end="(68, 85)">
                                  <AtomNode start="(68, 35)" end="(68, 37)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(68, 38)" end="(68, 85)">
                                    <TacticTacticseq1IndentedNode start="(68, 38)" end="(68, 85)">
                                      <NullNode start="(68, 38)" end="(68, 85)">
                                        <OtherNode start="(68, 38)" end="(68, 57)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;p : l₁ &amp;lt;:+ t&#10;s : t &amp;lt;+: l₂&#10;⊢ l₁.length + (t.length - l₁.length) ≤ l₂.length" state_after="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;p : l₁ &amp;lt;:+ t&#10;s : t &amp;lt;+: l₂&#10;this : l₁.length ≤ t.length&#10;⊢ l₁.length + (t.length - l₁.length) ≤ l₂.length" tactic="have := p.length_le">
                                          <AtomNode start="(68, 38)" end="(68, 42)" leading="" trailing=" " val="have"/>
                                          <OtherNode start="(68, 43)" end="(68, 57)" kind="Lean.Parser.Term.haveDecl">
                                            <OtherNode start="(68, 43)" end="(68, 57)" kind="Lean.Parser.Term.haveIdDecl">
                                              <OtherNode start="(68, 43)" end="(68, 43)" kind="Lean.Parser.Term.haveId">
                                                <OtherNode start="(68, 43)" end="(68, 43)" kind="hygieneInfo">
                                                  <IdentNode start="(68, 43)" end="(68, 43)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                </OtherNode>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <AtomNode start="(68, 43)" end="(68, 45)" leading="" trailing=" " val=":="/>
                                              <IdentNode start="(68, 46)" end="(68, 57)" leading="" trailing="" raw_val="p.length_le" val="p.length_le"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(68, 57)" end="(68, 58)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(68, 59)" end="(68, 78)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;p : l₁ &amp;lt;:+ t&#10;s : t &amp;lt;+: l₂&#10;this : l₁.length ≤ t.length&#10;⊢ l₁.length + (t.length - l₁.length) ≤ l₂.length" state_after="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;p : l₁ &amp;lt;:+ t&#10;s : t &amp;lt;+: l₂&#10;this✝ : l₁.length ≤ t.length&#10;this : t.length ≤ l₂.length&#10;⊢ l₁.length + (t.length - l₁.length) ≤ l₂.length" tactic="have := s.length_le">
                                          <AtomNode start="(68, 59)" end="(68, 63)" leading="" trailing=" " val="have"/>
                                          <OtherNode start="(68, 64)" end="(68, 78)" kind="Lean.Parser.Term.haveDecl">
                                            <OtherNode start="(68, 64)" end="(68, 78)" kind="Lean.Parser.Term.haveIdDecl">
                                              <OtherNode start="(68, 64)" end="(68, 64)" kind="Lean.Parser.Term.haveId">
                                                <OtherNode start="(68, 64)" end="(68, 64)" kind="hygieneInfo">
                                                  <IdentNode start="(68, 64)" end="(68, 64)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                </OtherNode>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <AtomNode start="(68, 64)" end="(68, 66)" leading="" trailing=" " val=":="/>
                                              <IdentNode start="(68, 67)" end="(68, 78)" leading="" trailing="" raw_val="s.length_le" val="s.length_le"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(68, 78)" end="(68, 79)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(68, 80)" end="(68, 85)" kind="Lean.Parser.Tactic.omega" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;p : l₁ &amp;lt;:+ t&#10;s : t &amp;lt;+: l₂&#10;this✝ : l₁.length ≤ t.length&#10;this : t.length ≤ l₂.length&#10;⊢ l₁.length + (t.length - l₁.length) ≤ l₂.length" state_after="no goals" tactic="omega">
                                          <AtomNode start="(68, 80)" end="(68, 85)" leading="" trailing="" val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(68, 85)" end="(68, 86)" leading="" trailing=" " val=","/>
                                <OtherNode start="(68, 87)" end="(68, 89)" kind="Lean.Parser.Term.syntheticHole">
                                  <AtomNode start="(68, 87)" end="(68, 88)" leading="" trailing="" val="?"/>
                                  <AtomNode start="(68, 88)" end="(68, 89)" leading="" trailing="" val="_"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(68, 89)" end="(68, 90)" leading="" trailing="&#10;    " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(69, 5)" end="(69, 27)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mp.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;p : l₁ &amp;lt;:+ t&#10;s : t &amp;lt;+: l₂&#10;⊢ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + (t.length - l₁.length)]? = some l₁[i]" state_after="case mp.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;p : l₁.length ≤ t.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), t[i + t.length - l₁.length]? = some l₁[i]&#10;s : t &amp;lt;+: l₂&#10;⊢ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + (t.length - l₁.length)]? = some l₁[i]" tactic="rw [isSuffix_iff] at p">
                            <AtomNode start="(69, 5)" end="(69, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(69, 8)" end="(69, 22)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(69, 8)" end="(69, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(69, 9)" end="(69, 21)">
                                <OtherNode start="(69, 9)" end="(69, 21)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(69, 9)" end="(69, 21)" leading="" trailing="" raw_val="isSuffix_iff" val="isSuffix_iff" full_name="List.isSuffix_iff" mod_name="Init.Data.List.Nat.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Sublist.lean" def_start="(33, 9)" def_end="(33, 21)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(69, 21)" end="(69, 22)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(69, 23)" end="(69, 27)">
                              <OtherNode start="(69, 23)" end="(69, 27)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(69, 23)" end="(69, 25)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(69, 26)" end="(69, 27)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(69, 26)" end="(69, 27)">
                                    <IdentNode start="(69, 26)" end="(69, 27)" leading="" trailing="&#10;    " raw_val="p" val="p"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(70, 5)" end="(70, 24)" kind="Lean.Parser.Tactic.obtain" state_before="case mp.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;p : l₁.length ≤ t.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), t[i + t.length - l₁.length]? = some l₁[i]&#10;s : t &amp;lt;+: l₂&#10;⊢ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + (t.length - l₁.length)]? = some l₁[i]" state_after="case mp.intro.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : t &amp;lt;+: l₂&#10;p' : l₁.length ≤ t.length&#10;p : ∀ (i : Nat) (h : i &amp;lt; l₁.length), t[i + t.length - l₁.length]? = some l₁[i]&#10;⊢ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + (t.length - l₁.length)]? = some l₁[i]" tactic="obtain ⟨p', p⟩ := p">
                            <AtomNode start="(70, 5)" end="(70, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(70, 12)" end="(70, 19)">
                              <OtherNode start="(70, 12)" end="(70, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(70, 12)" end="(70, 19)">
                                  <OtherNode start="(70, 12)" end="(70, 19)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(70, 12)" end="(70, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(70, 13)" end="(70, 18)">
                                      <OtherNode start="(70, 13)" end="(70, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(70, 13)" end="(70, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(70, 13)" end="(70, 15)">
                                            <OtherNode start="(70, 13)" end="(70, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(70, 13)" end="(70, 15)" leading="" trailing="" raw_val="p'" val="p'"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(70, 15)" end="(70, 16)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(70, 17)" end="(70, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(70, 17)" end="(70, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(70, 17)" end="(70, 18)">
                                            <OtherNode start="(70, 17)" end="(70, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(70, 17)" end="(70, 18)" leading="" trailing="" raw_val="p" val="p"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(70, 18)" end="(70, 19)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(70, 20)" end="(70, 24)">
                              <AtomNode start="(70, 20)" end="(70, 22)" leading="" trailing=" " val=":="/>
                              <NullNode start="(70, 23)" end="(70, 24)">
                                <IdentNode start="(70, 23)" end="(70, 24)" leading="" trailing="&#10;    " raw_val="p" val="p"/>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(71, 5)" end="(71, 27)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mp.intro.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : t &amp;lt;+: l₂&#10;p' : l₁.length ≤ t.length&#10;p : ∀ (i : Nat) (h : i &amp;lt; l₁.length), t[i + t.length - l₁.length]? = some l₁[i]&#10;⊢ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + (t.length - l₁.length)]? = some l₁[i]" state_after="case mp.intro.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : ∀ (i : Nat) (h : i &amp;lt; t.length), l₂[i]? = some t[i]&#10;p' : l₁.length ≤ t.length&#10;p : ∀ (i : Nat) (h : i &amp;lt; l₁.length), t[i + t.length - l₁.length]? = some l₁[i]&#10;⊢ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + (t.length - l₁.length)]? = some l₁[i]" tactic="rw [isPrefix_iff] at s">
                            <AtomNode start="(71, 5)" end="(71, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(71, 8)" end="(71, 22)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(71, 8)" end="(71, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(71, 9)" end="(71, 21)">
                                <OtherNode start="(71, 9)" end="(71, 21)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(71, 9)" end="(71, 21)" leading="" trailing="" raw_val="isPrefix_iff" val="isPrefix_iff" full_name="List.isPrefix_iff" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(71, 21)" end="(71, 22)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(71, 23)" end="(71, 27)">
                              <OtherNode start="(71, 23)" end="(71, 27)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(71, 23)" end="(71, 25)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(71, 26)" end="(71, 27)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(71, 26)" end="(71, 27)">
                                    <IdentNode start="(71, 26)" end="(71, 27)" leading="" trailing="&#10;    " raw_val="s" val="s"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(72, 5)" end="(72, 14)" kind="Lean.Parser.Tactic.intro" state_before="case mp.intro.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : ∀ (i : Nat) (h : i &amp;lt; t.length), l₂[i]? = some t[i]&#10;p' : l₁.length ≤ t.length&#10;p : ∀ (i : Nat) (h : i &amp;lt; l₁.length), t[i + t.length - l₁.length]? = some l₁[i]&#10;⊢ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + (t.length - l₁.length)]? = some l₁[i]" state_after="case mp.intro.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h✝ : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : ∀ (i : Nat) (h : i &amp;lt; t.length), l₂[i]? = some t[i]&#10;p' : l₁.length ≤ t.length&#10;p : ∀ (i : Nat) (h : i &amp;lt; l₁.length), t[i + t.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ l₂[i + (t.length - l₁.length)]? = some l₁[i]" tactic="intro i h">
                            <AtomNode start="(72, 5)" end="(72, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(72, 11)" end="(72, 14)">
                              <IdentNode start="(72, 11)" end="(72, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                              <IdentNode start="(72, 13)" end="(72, 14)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(73, 5)" end="(73, 24)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mp.intro.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h✝ : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : ∀ (i : Nat) (h : i &amp;lt; t.length), l₂[i]? = some t[i]&#10;p' : l₁.length ≤ t.length&#10;p : ∀ (i : Nat) (h : i &amp;lt; l₁.length), t[i + t.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ l₂[i + (t.length - l₁.length)]? = some l₁[i]" state_after="case mp.intro.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h✝ : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : ∀ (i : Nat) (h : i &amp;lt; t.length), l₂[i]? = some t[i]&#10;p' : l₁.length ≤ t.length&#10;p : ∀ (i : Nat) (h : i &amp;lt; l₁.length), t[i + t.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ some t[i + (t.length - l₁.length)] = some l₁[i]" tactic="rw [s _ (by omega)]">
                            <AtomNode start="(73, 5)" end="(73, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(73, 8)" end="(73, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(73, 8)" end="(73, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(73, 9)" end="(73, 23)">
                                <OtherNode start="(73, 9)" end="(73, 23)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(73, 9)" end="(73, 23)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(73, 9)" end="(73, 10)" leading="" trailing=" " raw_val="s" val="s"/>
                                    <NullNode start="(73, 11)" end="(73, 23)">
                                      <TermHoleNode start="(73, 11)" end="(73, 12)">
                                        <AtomNode start="(73, 11)" end="(73, 12)" leading="" trailing=" " val="_"/>
                                      </TermHoleNode>
                                      <OtherNode start="(73, 13)" end="(73, 23)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(73, 13)" end="(73, 14)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(73, 14)" end="(73, 22)">
                                          <AtomNode start="(73, 14)" end="(73, 16)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(73, 17)" end="(73, 22)">
                                            <TacticTacticseq1IndentedNode start="(73, 17)" end="(73, 22)">
                                              <NullNode start="(73, 17)" end="(73, 22)">
                                                <OtherNode start="(73, 17)" end="(73, 22)" kind="Lean.Parser.Tactic.omega" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h✝ : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : ∀ (i : Nat) (h : i &amp;lt; t.length), l₂[i]? = some t[i]&#10;p' : l₁.length ≤ t.length&#10;p : ∀ (i : Nat) (h : i &amp;lt; l₁.length), t[i + t.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ i + (t.length - l₁.length) &amp;lt; t.length" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(73, 17)" end="(73, 22)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(73, 22)" end="(73, 23)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(73, 23)" end="(73, 24)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(74, 5)" end="(74, 30)" kind="Lean.Parser.Tactic.specialize" state_before="case mp.intro.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h✝ : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : ∀ (i : Nat) (h : i &amp;lt; t.length), l₂[i]? = some t[i]&#10;p' : l₁.length ≤ t.length&#10;p : ∀ (i : Nat) (h : i &amp;lt; l₁.length), t[i + t.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ some t[i + (t.length - l₁.length)] = some l₁[i]" state_after="case mp.intro.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h✝ : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : ∀ (i : Nat) (h : i &amp;lt; t.length), l₂[i]? = some t[i]&#10;p' : l₁.length ≤ t.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;p : t[i + t.length - l₁.length]? = some l₁[i]&#10;⊢ some t[i + (t.length - l₁.length)] = some l₁[i]" tactic="specialize p i (by omega)">
                            <AtomNode start="(74, 5)" end="(74, 15)" leading="" trailing=" " val="specialize"/>
                            <OtherNode start="(74, 16)" end="(74, 30)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(74, 16)" end="(74, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                              <NullNode start="(74, 18)" end="(74, 30)">
                                <IdentNode start="(74, 18)" end="(74, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                                <OtherNode start="(74, 20)" end="(74, 30)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(74, 20)" end="(74, 21)" leading="" trailing="" val="("/>
                                  <TermBytacticNode start="(74, 21)" end="(74, 29)">
                                    <AtomNode start="(74, 21)" end="(74, 23)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(74, 24)" end="(74, 29)">
                                      <TacticTacticseq1IndentedNode start="(74, 24)" end="(74, 29)">
                                        <NullNode start="(74, 24)" end="(74, 29)">
                                          <OtherNode start="(74, 24)" end="(74, 29)" kind="Lean.Parser.Tactic.omega" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h✝ : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : ∀ (i : Nat) (h : i &amp;lt; t.length), l₂[i]? = some t[i]&#10;p' : l₁.length ≤ t.length&#10;p : ∀ (i : Nat) (h : i &amp;lt; l₁.length), t[i + t.length - l₁.length]? = some l₁[i]&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;⊢ i &amp;lt; l₁.length" state_after="no goals" tactic="omega">
                                            <AtomNode start="(74, 24)" end="(74, 29)" leading="" trailing="" val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                  <AtomNode start="(74, 29)" end="(74, 30)" leading="" trailing="&#10;    " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(75, 5)" end="(75, 43)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mp.intro.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h✝ : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : ∀ (i : Nat) (h : i &amp;lt; t.length), l₂[i]? = some t[i]&#10;p' : l₁.length ≤ t.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;p : t[i + t.length - l₁.length]? = some l₁[i]&#10;⊢ some t[i + (t.length - l₁.length)] = some l₁[i]" state_after="case mp.intro.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h✝ : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : ∀ (i : Nat) (h : i &amp;lt; t.length), l₂[i]? = some t[i]&#10;p' : l₁.length ≤ t.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;p : t[i + (t.length - l₁.length)]? = some l₁[i]&#10;⊢ some t[i + (t.length - l₁.length)] = some l₁[i]" tactic="rw [Nat.add_sub_assoc (by omega)] at p">
                            <AtomNode start="(75, 5)" end="(75, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(75, 8)" end="(75, 38)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(75, 8)" end="(75, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(75, 9)" end="(75, 37)">
                                <OtherNode start="(75, 9)" end="(75, 37)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(75, 9)" end="(75, 37)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(75, 9)" end="(75, 26)" leading="" trailing=" " raw_val="Nat.add_sub_assoc" val="Nat.add_sub_assoc" full_name="Nat.add_sub_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                    <NullNode start="(75, 27)" end="(75, 37)">
                                      <OtherNode start="(75, 27)" end="(75, 37)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(75, 27)" end="(75, 28)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(75, 28)" end="(75, 36)">
                                          <AtomNode start="(75, 28)" end="(75, 30)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(75, 31)" end="(75, 36)">
                                            <TacticTacticseq1IndentedNode start="(75, 31)" end="(75, 36)">
                                              <NullNode start="(75, 31)" end="(75, 36)">
                                                <OtherNode start="(75, 31)" end="(75, 36)" kind="Lean.Parser.Tactic.omega" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h✝ : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : ∀ (i : Nat) (h : i &amp;lt; t.length), l₂[i]? = some t[i]&#10;p' : l₁.length ≤ t.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;p : t[i + t.length - l₁.length]? = some l₁[i]&#10;⊢ l₁.length ≤ t.length" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(75, 31)" end="(75, 36)" leading="" trailing="" val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(75, 36)" end="(75, 37)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(75, 37)" end="(75, 38)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(75, 39)" end="(75, 43)">
                              <OtherNode start="(75, 39)" end="(75, 43)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(75, 39)" end="(75, 41)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(75, 42)" end="(75, 43)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(75, 42)" end="(75, 43)">
                                    <IdentNode start="(75, 42)" end="(75, 43)" leading="" trailing="&#10;    " raw_val="p" val="p"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(76, 5)" end="(76, 34)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mp.intro.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;h✝ : l₁ &amp;lt;:+: l₂&#10;t : List α✝&#10;s : ∀ (i : Nat) (h : i &amp;lt; t.length), l₂[i]? = some t[i]&#10;p' : l₁.length ≤ t.length&#10;i : Nat&#10;h : i &amp;lt; l₁.length&#10;p : t[i + (t.length - l₁.length)]? = some l₁[i]&#10;⊢ some t[i + (t.length - l₁.length)] = some l₁[i]" state_after="no goals" tactic="rw [← getElem?_eq_getElem, p]">
                            <AtomNode start="(76, 5)" end="(76, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(76, 8)" end="(76, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(76, 8)" end="(76, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(76, 9)" end="(76, 33)">
                                <OtherNode start="(76, 9)" end="(76, 30)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode start="(76, 9)" end="(76, 10)">
                                    <OtherNode start="(76, 9)" end="(76, 10)" kind="patternIgnore">
                                      <OtherNode start="(76, 9)" end="(76, 10)" kind="token.«← »">
                                        <AtomNode start="(76, 9)" end="(76, 10)" leading="" trailing=" " val="←"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <IdentNode start="(76, 11)" end="(76, 30)" leading="" trailing="" raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="List.getElem?_eq_getElem" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                </OtherNode>
                                <AtomNode start="(76, 30)" end="(76, 31)" leading="" trailing=" " val=","/>
                                <OtherNode start="(76, 32)" end="(76, 33)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(76, 32)" end="(76, 33)" leading="" trailing="" raw_val="p" val="p"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(76, 33)" end="(76, 34)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(77, 3)" end="(94, 12)" kind="Lean.cdot" state_before="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ (∃ k, l₁.length + k ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]) → l₁ &amp;lt;:+: l₂" state_after="no goals" tactic="· rintro ⟨k, le, w⟩&#10;  refine ⟨l₂.take k, l₂.drop (k + l₁.length), ?_⟩&#10;  ext1 i&#10;  rw [getElem?_append]&#10;  split&#10;  · rw [getElem?_append]&#10;    split&#10;    · rw [getElem?_take]; simp_all; omega&#10;    · simp_all&#10;      have p : i = (i - k) + k := by omega&#10;      rw [p, w _ (by omega), getElem?_eq_getElem]&#10;      · congr 2&#10;        omega&#10;      · omega&#10;  · rw [getElem?_drop]&#10;    congr&#10;    simp_all&#10;    omega">
                    <OtherNode start="(77, 3)" end="(77, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(77, 3)" end="(77, 4)" kind="patternIgnore">
                        <OtherNode start="(77, 3)" end="(77, 4)" kind="token.«· »">
                          <AtomNode start="(77, 3)" end="(77, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(77, 5)" end="(94, 12)">
                      <TacticTacticseq1IndentedNode start="(77, 5)" end="(94, 12)">
                        <NullNode start="(77, 5)" end="(94, 12)">
                          <OtherNode start="(77, 5)" end="(77, 22)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ (∃ k, l₁.length + k ≤ l₂.length ∧ ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]) → l₁ &amp;lt;:+: l₂" state_after="case mpr.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;⊢ l₁ &amp;lt;:+: l₂" tactic="rintro ⟨k, le, w⟩">
                            <AtomNode start="(77, 5)" end="(77, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(77, 12)" end="(77, 22)">
                              <OtherNode start="(77, 12)" end="(77, 22)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(77, 12)" end="(77, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(77, 12)" end="(77, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(77, 13)" end="(77, 21)">
                                    <OtherNode start="(77, 13)" end="(77, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(77, 13)" end="(77, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(77, 13)" end="(77, 14)">
                                          <OtherNode start="(77, 13)" end="(77, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(77, 13)" end="(77, 14)" leading="" trailing="" raw_val="k" val="k"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(77, 14)" end="(77, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(77, 16)" end="(77, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(77, 16)" end="(77, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(77, 16)" end="(77, 18)">
                                          <OtherNode start="(77, 16)" end="(77, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(77, 16)" end="(77, 18)" leading="" trailing="" raw_val="le" val="le"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(77, 18)" end="(77, 19)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(77, 20)" end="(77, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(77, 20)" end="(77, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(77, 20)" end="(77, 21)">
                                          <OtherNode start="(77, 20)" end="(77, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(77, 20)" end="(77, 21)" leading="" trailing="" raw_val="w" val="w"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(77, 21)" end="(77, 22)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(78, 5)" end="(78, 52)" kind="Lean.Parser.Tactic.refine" state_before="case mpr.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;⊢ l₁ &amp;lt;:+: l₂" state_after="case mpr.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;⊢ take k l₂ ++ l₁ ++ drop (k + l₁.length) l₂ = l₂" tactic="refine ⟨l₂.take k, l₂.drop (k + l₁.length), ?_⟩">
                            <AtomNode start="(78, 5)" end="(78, 11)" leading="" trailing=" " val="refine"/>
                            <OtherNode start="(78, 12)" end="(78, 52)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(78, 12)" end="(78, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(78, 13)" end="(78, 51)">
                                <OtherNode start="(78, 13)" end="(78, 22)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(78, 13)" end="(78, 20)" leading="" trailing=" " raw_val="l₂.take" val="l₂.take"/>
                                  <NullNode start="(78, 21)" end="(78, 22)">
                                    <IdentNode start="(78, 21)" end="(78, 22)" leading="" trailing="" raw_val="k" val="k"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(78, 22)" end="(78, 23)" leading="" trailing=" " val=","/>
                                <OtherNode start="(78, 24)" end="(78, 47)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(78, 24)" end="(78, 31)" leading="" trailing=" " raw_val="l₂.drop" val="l₂.drop"/>
                                  <NullNode start="(78, 32)" end="(78, 47)">
                                    <OtherNode start="(78, 32)" end="(78, 47)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(78, 32)" end="(78, 33)" leading="" trailing="" val="("/>
                                      <OtherNode start="(78, 33)" end="(78, 46)" kind="«term_+_»">
                                        <IdentNode start="(78, 33)" end="(78, 34)" leading="" trailing=" " raw_val="k" val="k"/>
                                        <AtomNode start="(78, 35)" end="(78, 36)" leading="" trailing=" " val="+"/>
                                        <IdentNode start="(78, 37)" end="(78, 46)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                                      </OtherNode>
                                      <AtomNode start="(78, 46)" end="(78, 47)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(78, 47)" end="(78, 48)" leading="" trailing=" " val=","/>
                                <OtherNode start="(78, 49)" end="(78, 51)" kind="Lean.Parser.Term.syntheticHole">
                                  <AtomNode start="(78, 49)" end="(78, 50)" leading="" trailing="" val="?"/>
                                  <AtomNode start="(78, 50)" end="(78, 51)" leading="" trailing="" val="_"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(78, 51)" end="(78, 52)" leading="" trailing="&#10;    " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(79, 5)" end="(79, 11)" kind="Lean.Elab.Tactic.Ext.tacticExt1___" state_before="case mpr.intro.intro&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;⊢ take k l₂ ++ l₁ ++ drop (k + l₁.length) l₂ = l₂" state_after="case mpr.intro.intro.h&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;⊢ (take k l₂ ++ l₁ ++ drop (k + l₁.length) l₂)[i]? = l₂[i]?" tactic="ext1 i">
                            <AtomNode start="(79, 5)" end="(79, 9)" leading="" trailing=" " val="ext1"/>
                            <NullNode start="(79, 10)" end="(79, 11)">
                              <OtherNode start="(79, 10)" end="(79, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(79, 10)" end="(79, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(79, 10)" end="(79, 11)" leading="" trailing="&#10;    " raw_val="i" val="i"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(80, 5)" end="(80, 25)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr.intro.intro.h&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;⊢ (take k l₂ ++ l₁ ++ drop (k + l₁.length) l₂)[i]? = l₂[i]?" state_after="case mpr.intro.intro.h&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;⊢ (if i &amp;lt; (take k l₂ ++ l₁).length then (take k l₂ ++ l₁)[i]?&#10;    else (drop (k + l₁.length) l₂)[i - (take k l₂ ++ l₁).length]?) =&#10;    l₂[i]?" tactic="rw [getElem?_append]">
                            <AtomNode start="(80, 5)" end="(80, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(80, 8)" end="(80, 25)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(80, 8)" end="(80, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(80, 9)" end="(80, 24)">
                                <OtherNode start="(80, 9)" end="(80, 24)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(80, 9)" end="(80, 24)" leading="" trailing="" raw_val="getElem?_append" val="getElem?_append" full_name="List.getElem?_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(80, 24)" end="(80, 25)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(81, 5)" end="(81, 10)" kind="Lean.Parser.Tactic.split" state_before="case mpr.intro.intro.h&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;⊢ (if i &amp;lt; (take k l₂ ++ l₁).length then (take k l₂ ++ l₁)[i]?&#10;    else (drop (k + l₁.length) l₂)[i - (take k l₂ ++ l₁).length]?) =&#10;    l₂[i]?" state_after="case mpr.intro.intro.h.isTrue&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : i &amp;lt; (take k l₂ ++ l₁).length&#10;⊢ (take k l₂ ++ l₁)[i]? = l₂[i]?&#10;&#10;case mpr.intro.intro.h.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : ¬i &amp;lt; (take k l₂ ++ l₁).length&#10;⊢ (drop (k + l₁.length) l₂)[i - (take k l₂ ++ l₁).length]? = l₂[i]?" tactic="split">
                            <AtomNode start="(81, 5)" end="(81, 10)" leading="" trailing="&#10;    " val="split"/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(82, 5)" end="(90, 16)" kind="Lean.cdot" state_before="case mpr.intro.intro.h.isTrue&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : i &amp;lt; (take k l₂ ++ l₁).length&#10;⊢ (take k l₂ ++ l₁)[i]? = l₂[i]?&#10;&#10;case mpr.intro.intro.h.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : ¬i &amp;lt; (take k l₂ ++ l₁).length&#10;⊢ (drop (k + l₁.length) l₂)[i - (take k l₂ ++ l₁).length]? = l₂[i]?" state_after="case mpr.intro.intro.h.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : ¬i &amp;lt; (take k l₂ ++ l₁).length&#10;⊢ (drop (k + l₁.length) l₂)[i - (take k l₂ ++ l₁).length]? = l₂[i]?" tactic="· rw [getElem?_append]&#10;  split&#10;  · rw [getElem?_take]; simp_all; omega&#10;  · simp_all&#10;    have p : i = (i - k) + k := by omega&#10;    rw [p, w _ (by omega), getElem?_eq_getElem]&#10;    · congr 2&#10;      omega&#10;    · omega">
                            <OtherNode start="(82, 5)" end="(82, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(82, 5)" end="(82, 6)" kind="patternIgnore">
                                <OtherNode start="(82, 5)" end="(82, 6)" kind="token.«· »">
                                  <AtomNode start="(82, 5)" end="(82, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(82, 7)" end="(90, 16)">
                              <TacticTacticseq1IndentedNode start="(82, 7)" end="(90, 16)">
                                <NullNode start="(82, 7)" end="(90, 16)">
                                  <OtherNode start="(82, 7)" end="(82, 27)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr.intro.intro.h.isTrue&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : i &amp;lt; (take k l₂ ++ l₁).length&#10;⊢ (take k l₂ ++ l₁)[i]? = l₂[i]?" state_after="case mpr.intro.intro.h.isTrue&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : i &amp;lt; (take k l₂ ++ l₁).length&#10;⊢ (if i &amp;lt; (take k l₂).length then (take k l₂)[i]? else l₁[i - (take k l₂).length]?) = l₂[i]?" tactic="rw [getElem?_append]">
                                    <AtomNode start="(82, 7)" end="(82, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(82, 10)" end="(82, 27)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(82, 10)" end="(82, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(82, 11)" end="(82, 26)">
                                        <OtherNode start="(82, 11)" end="(82, 26)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(82, 11)" end="(82, 26)" leading="" trailing="" raw_val="getElem?_append" val="getElem?_append" full_name="List.getElem?_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(82, 26)" end="(82, 27)" leading="" trailing="&#10;      " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(83, 7)" end="(83, 12)" kind="Lean.Parser.Tactic.split" state_before="case mpr.intro.intro.h.isTrue&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : i &amp;lt; (take k l₂ ++ l₁).length&#10;⊢ (if i &amp;lt; (take k l₂).length then (take k l₂)[i]? else l₁[i - (take k l₂).length]?) = l₂[i]?" state_after="case mpr.intro.intro.h.isTrue.isTrue&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; (take k l₂ ++ l₁).length&#10;h✝ : i &amp;lt; (take k l₂).length&#10;⊢ (take k l₂)[i]? = l₂[i]?&#10;&#10;case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; (take k l₂ ++ l₁).length&#10;h✝ : ¬i &amp;lt; (take k l₂).length&#10;⊢ l₁[i - (take k l₂).length]? = l₂[i]?" tactic="split">
                                    <AtomNode start="(83, 7)" end="(83, 12)" leading="" trailing="&#10;      " val="split"/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(84, 7)" end="(84, 44)" kind="Lean.cdot" state_before="case mpr.intro.intro.h.isTrue.isTrue&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; (take k l₂ ++ l₁).length&#10;h✝ : i &amp;lt; (take k l₂).length&#10;⊢ (take k l₂)[i]? = l₂[i]?&#10;&#10;case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; (take k l₂ ++ l₁).length&#10;h✝ : ¬i &amp;lt; (take k l₂).length&#10;⊢ l₁[i - (take k l₂).length]? = l₂[i]?" state_after="case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; (take k l₂ ++ l₁).length&#10;h✝ : ¬i &amp;lt; (take k l₂).length&#10;⊢ l₁[i - (take k l₂).length]? = l₂[i]?" tactic="· rw [getElem?_take]; simp_all; omega">
                                    <OtherNode start="(84, 7)" end="(84, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(84, 7)" end="(84, 8)" kind="patternIgnore">
                                        <OtherNode start="(84, 7)" end="(84, 8)" kind="token.«· »">
                                          <AtomNode start="(84, 7)" end="(84, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(84, 9)" end="(84, 44)">
                                      <TacticTacticseq1IndentedNode start="(84, 9)" end="(84, 44)">
                                        <NullNode start="(84, 9)" end="(84, 44)">
                                          <OtherNode start="(84, 9)" end="(84, 27)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr.intro.intro.h.isTrue.isTrue&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; (take k l₂ ++ l₁).length&#10;h✝ : i &amp;lt; (take k l₂).length&#10;⊢ (take k l₂)[i]? = l₂[i]?" state_after="case mpr.intro.intro.h.isTrue.isTrue&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; (take k l₂ ++ l₁).length&#10;h✝ : i &amp;lt; (take k l₂).length&#10;⊢ (if i &amp;lt; k then l₂[i]? else none) = l₂[i]?" tactic="rw [getElem?_take]">
                                            <AtomNode start="(84, 9)" end="(84, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(84, 12)" end="(84, 27)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(84, 12)" end="(84, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(84, 13)" end="(84, 26)">
                                                <OtherNode start="(84, 13)" end="(84, 26)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <IdentNode start="(84, 13)" end="(84, 26)" leading="" trailing="" raw_val="getElem?_take" val="getElem?_take" full_name="List.getElem?_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(84, 26)" end="(84, 27)" leading="" trailing="" val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <AtomNode start="(84, 27)" end="(84, 28)" leading="" trailing=" " val=";"/>
                                          <OtherNode start="(84, 29)" end="(84, 37)" kind="Lean.Parser.Tactic.simpAll" state_before="case mpr.intro.intro.h.isTrue.isTrue&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; (take k l₂ ++ l₁).length&#10;h✝ : i &amp;lt; (take k l₂).length&#10;⊢ (if i &amp;lt; k then l₂[i]? else none) = l₂[i]?" state_after="case mpr.intro.intro.h.isTrue.isTrue&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : i &amp;lt; min k l₂.length&#10;⊢ k ≤ i → l₂.length ≤ i" tactic="simp_all">
                                            <AtomNode start="(84, 29)" end="(84, 37)" leading="" trailing="" val="simp_all"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                          <AtomNode start="(84, 37)" end="(84, 38)" leading="" trailing=" " val=";"/>
                                          <OtherNode start="(84, 39)" end="(84, 44)" kind="Lean.Parser.Tactic.omega" state_before="case mpr.intro.intro.h.isTrue.isTrue&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : i &amp;lt; min k l₂.length&#10;⊢ k ≤ i → l₂.length ≤ i" state_after="no goals" tactic="omega">
                                            <AtomNode start="(84, 39)" end="(84, 44)" leading="" trailing="&#10;      " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(85, 7)" end="(90, 16)" kind="Lean.cdot" state_before="case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; (take k l₂ ++ l₁).length&#10;h✝ : ¬i &amp;lt; (take k l₂).length&#10;⊢ l₁[i - (take k l₂).length]? = l₂[i]?" state_after="no goals" tactic="· simp_all&#10;  have p : i = (i - k) + k := by omega&#10;  rw [p, w _ (by omega), getElem?_eq_getElem]&#10;  · congr 2&#10;    omega&#10;  · omega">
                                    <OtherNode start="(85, 7)" end="(85, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(85, 7)" end="(85, 8)" kind="patternIgnore">
                                        <OtherNode start="(85, 7)" end="(85, 8)" kind="token.«· »">
                                          <AtomNode start="(85, 7)" end="(85, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(85, 9)" end="(90, 16)">
                                      <TacticTacticseq1IndentedNode start="(85, 9)" end="(90, 16)">
                                        <NullNode start="(85, 9)" end="(90, 16)">
                                          <OtherNode start="(85, 9)" end="(85, 17)" kind="Lean.Parser.Tactic.simpAll" state_before="case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; (take k l₂ ++ l₁).length&#10;h✝ : ¬i &amp;lt; (take k l₂).length&#10;⊢ l₁[i - (take k l₂).length]? = l₂[i]?" state_after="case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;⊢ l₁[i - min k l₂.length]? = l₂[i]?" tactic="simp_all">
                                            <AtomNode start="(85, 9)" end="(85, 17)" leading="" trailing="&#10;        " val="simp_all"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(86, 9)" end="(86, 45)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;⊢ l₁[i - min k l₂.length]? = l₂[i]?" state_after="case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;p : i = i - k + k&#10;⊢ l₁[i - min k l₂.length]? = l₂[i]?" tactic="have p : i = (i - k) + k := by omega">
                                            <AtomNode start="(86, 9)" end="(86, 13)" leading="" trailing=" " val="have"/>
                                            <OtherNode start="(86, 14)" end="(86, 45)" kind="Lean.Parser.Term.haveDecl">
                                              <OtherNode start="(86, 14)" end="(86, 45)" kind="Lean.Parser.Term.haveIdDecl">
                                                <OtherNode start="(86, 14)" end="(86, 15)" kind="Lean.Parser.Term.haveId">
                                                  <IdentNode start="(86, 14)" end="(86, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode start="(86, 16)" end="(86, 33)">
                                                  <TermTypespecNode start="(86, 16)" end="(86, 33)">
                                                    <AtomNode start="(86, 16)" end="(86, 17)" leading="" trailing=" " val=":"/>
                                                    <OtherNode start="(86, 18)" end="(86, 33)" kind="«term_=_»">
                                                      <IdentNode start="(86, 18)" end="(86, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                                                      <AtomNode start="(86, 20)" end="(86, 21)" leading="" trailing=" " val="="/>
                                                      <OtherNode start="(86, 22)" end="(86, 33)" kind="«term_+_»">
                                                        <OtherNode start="(86, 22)" end="(86, 29)" kind="Lean.Parser.Term.paren">
                                                          <AtomNode start="(86, 22)" end="(86, 23)" leading="" trailing="" val="("/>
                                                          <OtherNode start="(86, 23)" end="(86, 28)" kind="«term_-_»">
                                                            <IdentNode start="(86, 23)" end="(86, 24)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            <AtomNode start="(86, 25)" end="(86, 26)" leading="" trailing=" " val="-"/>
                                                            <IdentNode start="(86, 27)" end="(86, 28)" leading="" trailing="" raw_val="k" val="k"/>
                                                          </OtherNode>
                                                          <AtomNode start="(86, 28)" end="(86, 29)" leading="" trailing=" " val=")"/>
                                                        </OtherNode>
                                                        <AtomNode start="(86, 30)" end="(86, 31)" leading="" trailing=" " val="+"/>
                                                        <IdentNode start="(86, 32)" end="(86, 33)" leading="" trailing=" " raw_val="k" val="k"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </TermTypespecNode>
                                                </NullNode>
                                                <AtomNode start="(86, 34)" end="(86, 36)" leading="" trailing=" " val=":="/>
                                                <TermBytacticNode start="(86, 37)" end="(86, 45)">
                                                  <AtomNode start="(86, 37)" end="(86, 39)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(86, 40)" end="(86, 45)">
                                                    <TacticTacticseq1IndentedNode start="(86, 40)" end="(86, 45)">
                                                      <NullNode start="(86, 40)" end="(86, 45)">
                                                        <OtherNode start="(86, 40)" end="(86, 45)" kind="Lean.Parser.Tactic.omega" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;⊢ i = i - k + k" state_after="no goals" tactic="omega">
                                                          <AtomNode start="(86, 40)" end="(86, 45)" leading="" trailing="&#10;        " val="omega"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(87, 9)" end="(87, 52)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;p : i = i - k + k&#10;⊢ l₁[i - min k l₂.length]? = l₂[i]?" state_after="case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;p : i = i - k + k&#10;⊢ some l₁[i - k + k - min k l₂.length] = some l₁[i - k]&#10;&#10;case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;p : i = i - k + k&#10;⊢ i - k + k - min k l₂.length &amp;lt; l₁.length" tactic="rw [p, w _ (by omega), getElem?_eq_getElem]">
                                            <AtomNode start="(87, 9)" end="(87, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(87, 12)" end="(87, 52)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(87, 12)" end="(87, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(87, 13)" end="(87, 51)">
                                                <OtherNode start="(87, 13)" end="(87, 14)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <IdentNode start="(87, 13)" end="(87, 14)" leading="" trailing="" raw_val="p" val="p"/>
                                                </OtherNode>
                                                <AtomNode start="(87, 14)" end="(87, 15)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(87, 16)" end="(87, 30)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(87, 16)" end="(87, 30)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(87, 16)" end="(87, 17)" leading="" trailing=" " raw_val="w" val="w"/>
                                                    <NullNode start="(87, 18)" end="(87, 30)">
                                                      <TermHoleNode start="(87, 18)" end="(87, 19)">
                                                        <AtomNode start="(87, 18)" end="(87, 19)" leading="" trailing=" " val="_"/>
                                                      </TermHoleNode>
                                                      <OtherNode start="(87, 20)" end="(87, 30)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(87, 20)" end="(87, 21)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(87, 21)" end="(87, 29)">
                                                          <AtomNode start="(87, 21)" end="(87, 23)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(87, 24)" end="(87, 29)">
                                                            <TacticTacticseq1IndentedNode start="(87, 24)" end="(87, 29)">
                                                            <NullNode start="(87, 24)" end="(87, 29)">
                                                            <OtherNode start="(87, 24)" end="(87, 29)" kind="Lean.Parser.Tactic.omega" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;p : i = i - k + k&#10;⊢ i - k &amp;lt; l₁.length" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(87, 24)" end="(87, 29)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(87, 29)" end="(87, 30)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(87, 30)" end="(87, 31)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(87, 32)" end="(87, 51)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <IdentNode start="(87, 32)" end="(87, 51)" leading="" trailing="" raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="List.getElem?_eq_getElem" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(87, 51)" end="(87, 52)" leading="" trailing="&#10;        " val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(88, 9)" end="(89, 16)" kind="Lean.cdot" state_before="case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;p : i = i - k + k&#10;⊢ some l₁[i - k + k - min k l₂.length] = some l₁[i - k]&#10;&#10;case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;p : i = i - k + k&#10;⊢ i - k + k - min k l₂.length &amp;lt; l₁.length" state_after="case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;p : i = i - k + k&#10;⊢ i - k + k - min k l₂.length &amp;lt; l₁.length" tactic="· congr 2&#10;  omega">
                                            <OtherNode start="(88, 9)" end="(88, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(88, 9)" end="(88, 10)" kind="patternIgnore">
                                                <OtherNode start="(88, 9)" end="(88, 10)" kind="token.«· »">
                                                  <AtomNode start="(88, 9)" end="(88, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(88, 11)" end="(89, 16)">
                                              <TacticTacticseq1IndentedNode start="(88, 11)" end="(89, 16)">
                                                <NullNode start="(88, 11)" end="(89, 16)">
                                                  <OtherNode start="(88, 11)" end="(88, 18)" kind="Lean.Parser.Tactic.congr" state_before="case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;p : i = i - k + k&#10;⊢ some l₁[i - k + k - min k l₂.length] = some l₁[i - k]" state_after="case mpr.intro.intro.h.isTrue.isFalse.e_val.e_i&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;p : i = i - k + k&#10;⊢ i - k + k - min k l₂.length = i - k" tactic="congr 2">
                                                    <AtomNode start="(88, 11)" end="(88, 16)" leading="" trailing=" " val="congr"/>
                                                    <NullNode start="(88, 17)" end="(88, 18)">
                                                      <OtherNode start="(88, 17)" end="(88, 18)" kind="num">
                                                        <AtomNode start="(88, 17)" end="(88, 18)" leading="" trailing="&#10;          " val="2"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(89, 11)" end="(89, 16)" kind="Lean.Parser.Tactic.omega" state_before="case mpr.intro.intro.h.isTrue.isFalse.e_val.e_i&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;p : i = i - k + k&#10;⊢ i - k + k - min k l₂.length = i - k" state_after="no goals" tactic="omega">
                                                    <AtomNode start="(89, 11)" end="(89, 16)" leading="" trailing="&#10;        " val="omega"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(90, 9)" end="(90, 16)" kind="Lean.cdot" state_before="case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;p : i = i - k + k&#10;⊢ i - k + k - min k l₂.length &amp;lt; l₁.length" state_after="no goals" tactic="· omega">
                                            <OtherNode start="(90, 9)" end="(90, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(90, 9)" end="(90, 10)" kind="patternIgnore">
                                                <OtherNode start="(90, 9)" end="(90, 10)" kind="token.«· »">
                                                  <AtomNode start="(90, 9)" end="(90, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(90, 11)" end="(90, 16)">
                                              <TacticTacticseq1IndentedNode start="(90, 11)" end="(90, 16)">
                                                <NullNode start="(90, 11)" end="(90, 16)">
                                                  <OtherNode start="(90, 11)" end="(90, 16)" kind="Lean.Parser.Tactic.omega" state_before="case mpr.intro.intro.h.isTrue.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝¹ : i &amp;lt; min k l₂.length + l₁.length&#10;h✝ : min k l₂.length ≤ i&#10;p : i = i - k + k&#10;⊢ i - k + k - min k l₂.length &amp;lt; l₁.length" state_after="no goals" tactic="omega">
                                                    <AtomNode start="(90, 11)" end="(90, 16)" leading="" trailing="&#10;    " val="omega"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(91, 5)" end="(94, 12)" kind="Lean.cdot" state_before="case mpr.intro.intro.h.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : ¬i &amp;lt; (take k l₂ ++ l₁).length&#10;⊢ (drop (k + l₁.length) l₂)[i - (take k l₂ ++ l₁).length]? = l₂[i]?" state_after="no goals" tactic="· rw [getElem?_drop]&#10;  congr&#10;  simp_all&#10;  omega">
                            <OtherNode start="(91, 5)" end="(91, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(91, 5)" end="(91, 6)" kind="patternIgnore">
                                <OtherNode start="(91, 5)" end="(91, 6)" kind="token.«· »">
                                  <AtomNode start="(91, 5)" end="(91, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(91, 7)" end="(94, 12)">
                              <TacticTacticseq1IndentedNode start="(91, 7)" end="(94, 12)">
                                <NullNode start="(91, 7)" end="(94, 12)">
                                  <OtherNode start="(91, 7)" end="(91, 25)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr.intro.intro.h.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : ¬i &amp;lt; (take k l₂ ++ l₁).length&#10;⊢ (drop (k + l₁.length) l₂)[i - (take k l₂ ++ l₁).length]? = l₂[i]?" state_after="case mpr.intro.intro.h.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : ¬i &amp;lt; (take k l₂ ++ l₁).length&#10;⊢ l₂[k + l₁.length + (i - (take k l₂ ++ l₁).length)]? = l₂[i]?" tactic="rw [getElem?_drop]">
                                    <AtomNode start="(91, 7)" end="(91, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(91, 10)" end="(91, 25)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(91, 10)" end="(91, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(91, 11)" end="(91, 24)">
                                        <OtherNode start="(91, 11)" end="(91, 24)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(91, 11)" end="(91, 24)" leading="" trailing="" raw_val="getElem?_drop" val="getElem?_drop" full_name="List.getElem?_drop" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(91, 24)" end="(91, 25)" leading="" trailing="&#10;      " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(92, 7)" end="(92, 12)" kind="Lean.Parser.Tactic.congr" state_before="case mpr.intro.intro.h.isFalse&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : ¬i &amp;lt; (take k l₂ ++ l₁).length&#10;⊢ l₂[k + l₁.length + (i - (take k l₂ ++ l₁).length)]? = l₂[i]?" state_after="case mpr.intro.intro.h.isFalse.e_a&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : ¬i &amp;lt; (take k l₂ ++ l₁).length&#10;⊢ k + l₁.length + (i - (take k l₂ ++ l₁).length) = i" tactic="congr">
                                    <AtomNode start="(92, 7)" end="(92, 12)" leading="" trailing="&#10;      " val="congr"/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(93, 7)" end="(93, 15)" kind="Lean.Parser.Tactic.simpAll" state_before="case mpr.intro.intro.h.isFalse.e_a&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : ¬i &amp;lt; (take k l₂ ++ l₁).length&#10;⊢ k + l₁.length + (i - (take k l₂ ++ l₁).length) = i" state_after="case mpr.intro.intro.h.isFalse.e_a&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : min k l₂.length + l₁.length ≤ i&#10;⊢ k + l₁.length + (i - (min k l₂.length + l₁.length)) = i" tactic="simp_all">
                                    <AtomNode start="(93, 7)" end="(93, 15)" leading="" trailing="&#10;      " val="simp_all"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(94, 7)" end="(94, 12)" kind="Lean.Parser.Tactic.omega" state_before="case mpr.intro.intro.h.isFalse.e_a&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;k : Nat&#10;le : l₁.length + k ≤ l₂.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l₁.length), l₂[i + k]? = some l₁[i]&#10;i : Nat&#10;h✝ : min k l₂.length + l₁.length ≤ i&#10;⊢ k + l₁.length + (i - (min k l₂.length + l₁.length)) = i" state_after="no goals" tactic="omega">
                                    <AtomNode start="(94, 7)" end="(94, 12)" leading="" trailing="&#10;&#10;" val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(96, 1)" end="(98, 12)" name="suffix_iff_eq_append" full_name="List.suffix_iff_eq_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(96, 1)" end="(98, 12)" name="suffix_iff_eq_append" full_name="List.suffix_iff_eq_append" _is_private_decl="False">
        <AtomNode start="(96, 1)" end="(96, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(96, 9)" end="(96, 29)">
          <IdentNode start="(96, 9)" end="(96, 29)" leading="" trailing=" " raw_val="suffix_iff_eq_append" val="suffix_iff_eq_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(96, 30)" end="(96, 86)">
          <NullNode/>
          <TermTypespecNode start="(96, 30)" end="(96, 86)">
            <AtomNode start="(96, 30)" end="(96, 31)" leading="" trailing=" " val=":"/>
            <OtherNode start="(96, 32)" end="(96, 86)" kind="«term_↔_»">
              <OtherNode start="(96, 32)" end="(96, 41)" kind="List.«term_&amp;lt;:+_»">
                <IdentNode start="(96, 32)" end="(96, 34)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(96, 35)" end="(96, 38)" leading="" trailing=" " val="&amp;lt;:+"/>
                <IdentNode start="(96, 39)" end="(96, 41)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
              <AtomNode start="(96, 42)" end="(96, 43)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(96, 44)" end="(96, 86)" kind="«term_=_»">
                <OtherNode start="(96, 44)" end="(96, 81)" kind="«term_++_»">
                  <OtherNode start="(96, 44)" end="(96, 75)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(96, 44)" end="(96, 48)" leading="" trailing=" " raw_val="take" val="take" full_name="List.take" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(96, 49)" end="(96, 75)">
                      <OtherNode start="(96, 49)" end="(96, 72)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(96, 49)" end="(96, 50)" leading="" trailing="" val="("/>
                        <OtherNode start="(96, 50)" end="(96, 71)" kind="«term_-_»">
                          <OtherNode start="(96, 50)" end="(96, 59)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(96, 50)" end="(96, 56)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(96, 57)" end="(96, 59)">
                              <IdentNode start="(96, 57)" end="(96, 59)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(96, 60)" end="(96, 61)" leading="" trailing=" " val="-"/>
                          <OtherNode start="(96, 62)" end="(96, 71)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(96, 62)" end="(96, 68)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(96, 69)" end="(96, 71)">
                              <IdentNode start="(96, 69)" end="(96, 71)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(96, 71)" end="(96, 72)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <IdentNode start="(96, 73)" end="(96, 75)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(96, 76)" end="(96, 78)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(96, 79)" end="(96, 81)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </OtherNode>
                <AtomNode start="(96, 82)" end="(96, 83)" leading="" trailing=" " val="="/>
                <IdentNode start="(96, 84)" end="(96, 86)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(96, 87)" end="(98, 12)">
          <AtomNode start="(96, 87)" end="(96, 89)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(97, 3)" end="(98, 12)" kind="Lean.Parser.Term.anonymousCtor">
            <AtomNode start="(97, 3)" end="(97, 4)" leading="" trailing="" val="⟨"/>
            <NullNode start="(97, 4)" end="(98, 11)">
              <TermBytacticNode start="(97, 4)" end="(97, 86)">
                <AtomNode start="(97, 4)" end="(97, 6)" leading="" trailing=" " val="by"/>
                <TacticTacticseqNode start="(97, 7)" end="(97, 86)">
                  <TacticTacticseq1IndentedNode start="(97, 7)" end="(97, 86)">
                    <NullNode start="(97, 7)" end="(97, 86)">
                      <OtherNode start="(97, 7)" end="(97, 22)" kind="Lean.Parser.Tactic.rintro" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;⊢ l₁ &amp;lt;:+ l₂ → take (l₂.length - l₁.length) l₂ ++ l₁ = l₂" state_after="case intro&#10;α✝ : Type u_1&#10;l₁ r : List α✝&#10;⊢ take ((r ++ l₁).length - l₁.length) (r ++ l₁) ++ l₁ = r ++ l₁" tactic="rintro ⟨r, rfl⟩">
                        <AtomNode start="(97, 7)" end="(97, 13)" leading="" trailing=" " val="rintro"/>
                        <NullNode start="(97, 14)" end="(97, 22)">
                          <OtherNode start="(97, 14)" end="(97, 22)" kind="Lean.Parser.Tactic.rintroPat.one">
                            <OtherNode start="(97, 14)" end="(97, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(97, 14)" end="(97, 15)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(97, 15)" end="(97, 21)">
                                <OtherNode start="(97, 15)" end="(97, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(97, 15)" end="(97, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(97, 15)" end="(97, 16)">
                                      <OtherNode start="(97, 15)" end="(97, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(97, 15)" end="(97, 16)" leading="" trailing="" raw_val="r" val="r"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(97, 16)" end="(97, 17)" leading="" trailing=" " val=","/>
                                <OtherNode start="(97, 18)" end="(97, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(97, 18)" end="(97, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(97, 18)" end="(97, 21)">
                                      <OtherNode start="(97, 18)" end="(97, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(97, 18)" end="(97, 21)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(97, 21)" end="(97, 22)" leading="" trailing="" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(97, 22)" end="(97, 23)" leading="" trailing=" " val=";"/>
                      <OtherNode start="(97, 24)" end="(97, 86)" kind="Lean.Parser.Tactic.simp" state_before="case intro&#10;α✝ : Type u_1&#10;l₁ r : List α✝&#10;⊢ take ((r ++ l₁).length - l₁.length) (r ++ l₁) ++ l₁ = r ++ l₁" state_after="no goals" tactic="simp only [length_append, Nat.add_sub_cancel_right, take_left]">
                        <AtomNode start="(97, 24)" end="(97, 28)" leading="" trailing=" " val="simp"/>
                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                          <NullNode/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode start="(97, 29)" end="(97, 33)">
                          <AtomNode start="(97, 29)" end="(97, 33)" leading="" trailing=" " val="only"/>
                        </NullNode>
                        <NullNode start="(97, 34)" end="(97, 86)">
                          <AtomNode start="(97, 34)" end="(97, 35)" leading="" trailing="" val="["/>
                          <NullNode start="(97, 35)" end="(97, 85)">
                            <OtherNode start="(97, 35)" end="(97, 48)" kind="Lean.Parser.Tactic.simpLemma">
                              <NullNode/>
                              <NullNode/>
                              <IdentNode start="(97, 35)" end="(97, 48)" leading="" trailing="" raw_val="length_append" val="length_append" full_name="List.length_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                            </OtherNode>
                            <AtomNode start="(97, 48)" end="(97, 49)" leading="" trailing=" " val=","/>
                            <OtherNode start="(97, 50)" end="(97, 74)" kind="Lean.Parser.Tactic.simpLemma">
                              <NullNode/>
                              <NullNode/>
                              <IdentNode start="(97, 50)" end="(97, 74)" leading="" trailing="" raw_val="Nat.add_sub_cancel_right" val="Nat.add_sub_cancel_right" full_name="Nat.add_sub_cancel_right" mod_name="Init.Data.Nat.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Lemmas.lean"/>
                            </OtherNode>
                            <AtomNode start="(97, 74)" end="(97, 75)" leading="" trailing=" " val=","/>
                            <OtherNode start="(97, 76)" end="(97, 85)" kind="Lean.Parser.Tactic.simpLemma">
                              <NullNode/>
                              <NullNode/>
                              <IdentNode start="(97, 76)" end="(97, 85)" leading="" trailing="" raw_val="take_left" val="take_left" full_name="List.take_left" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                            </OtherNode>
                          </NullNode>
                          <AtomNode start="(97, 85)" end="(97, 86)" leading="" trailing="" val="]"/>
                        </NullNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </TacticTacticseq1IndentedNode>
                </TacticTacticseqNode>
              </TermBytacticNode>
              <AtomNode start="(97, 86)" end="(97, 87)" leading="" trailing=" " val=","/>
              <OtherNode start="(97, 88)" end="(98, 11)" kind="Lean.Parser.Term.fun">
                <AtomNode start="(97, 88)" end="(97, 91)" leading="" trailing=" " val="fun"/>
                <OtherNode start="(97, 92)" end="(98, 11)" kind="Lean.Parser.Term.basicFun">
                  <NullNode start="(97, 92)" end="(97, 93)">
                    <IdentNode start="(97, 92)" end="(97, 93)" leading="" trailing=" " raw_val="e" val="e"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(97, 94)" end="(97, 96)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                  <OtherNode start="(98, 5)" end="(98, 11)" kind="Lean.Parser.Term.anonymousCtor">
                    <AtomNode start="(98, 5)" end="(98, 6)" leading="" trailing="" val="⟨"/>
                    <NullNode start="(98, 6)" end="(98, 10)">
                      <TermHoleNode start="(98, 6)" end="(98, 7)">
                        <AtomNode start="(98, 6)" end="(98, 7)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(98, 7)" end="(98, 8)" leading="" trailing=" " val=","/>
                      <IdentNode start="(98, 9)" end="(98, 10)" leading="" trailing="" raw_val="e" val="e"/>
                    </NullNode>
                    <AtomNode start="(98, 10)" end="(98, 11)" leading="" trailing="" val="⟩"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(98, 11)" end="(98, 12)" leading="" trailing="&#10;&#10;" val="⟩"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(100, 1)" end="(112, 36)" name="prefix_take_iff" full_name="List.prefix_take_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(100, 1)" end="(112, 36)" name="prefix_take_iff" full_name="List.prefix_take_iff" _is_private_decl="False">
        <AtomNode start="(100, 1)" end="(100, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(100, 9)" end="(100, 24)">
          <IdentNode start="(100, 9)" end="(100, 24)" leading="" trailing=" " raw_val="prefix_take_iff" val="prefix_take_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(100, 25)" end="(100, 98)">
          <NullNode start="(100, 25)" end="(100, 51)">
            <OtherNode start="(100, 25)" end="(100, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(100, 25)" end="(100, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(100, 26)" end="(100, 31)">
                <IdentNode start="(100, 26)" end="(100, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(100, 29)" end="(100, 31)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(100, 32)" end="(100, 40)">
                <AtomNode start="(100, 32)" end="(100, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(100, 34)" end="(100, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(100, 34)" end="(100, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(100, 39)" end="(100, 40)">
                    <IdentNode start="(100, 39)" end="(100, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(100, 40)" end="(100, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(100, 42)" end="(100, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(100, 42)" end="(100, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(100, 43)" end="(100, 44)">
                <IdentNode start="(100, 43)" end="(100, 44)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(100, 45)" end="(100, 50)">
                <AtomNode start="(100, 45)" end="(100, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(100, 47)" end="(100, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(100, 50)" end="(100, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(100, 52)" end="(100, 98)">
            <AtomNode start="(100, 52)" end="(100, 53)" leading="" trailing=" " val=":"/>
            <OtherNode start="(100, 54)" end="(100, 98)" kind="«term_↔_»">
              <OtherNode start="(100, 54)" end="(100, 70)" kind="List.«term_&amp;lt;+:_»">
                <IdentNode start="(100, 54)" end="(100, 56)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <AtomNode start="(100, 57)" end="(100, 60)" leading="" trailing=" " val="&amp;lt;+:"/>
                <OtherNode start="(100, 61)" end="(100, 70)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(100, 61)" end="(100, 68)" leading="" trailing=" " raw_val="ys.take" val="ys.take"/>
                  <NullNode start="(100, 69)" end="(100, 70)">
                    <IdentNode start="(100, 69)" end="(100, 70)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(100, 71)" end="(100, 72)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(100, 73)" end="(100, 98)" kind="«term_∧_»">
                <OtherNode start="(100, 73)" end="(100, 82)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(100, 73)" end="(100, 75)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(100, 76)" end="(100, 79)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(100, 80)" end="(100, 82)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </OtherNode>
                <AtomNode start="(100, 83)" end="(100, 84)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(100, 85)" end="(100, 98)" kind="«term_≤_»">
                  <IdentNode start="(100, 85)" end="(100, 94)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
                  <AtomNode start="(100, 95)" end="(100, 96)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(100, 97)" end="(100, 98)" leading="" trailing=" " raw_val="i" val="i"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(100, 99)" end="(112, 36)">
          <AtomNode start="(100, 99)" end="(100, 101)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(100, 102)" end="(112, 36)">
            <AtomNode start="(100, 102)" end="(100, 104)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(101, 3)" end="(112, 36)">
              <TacticTacticseq1IndentedNode start="(101, 3)" end="(112, 36)">
                <NullNode start="(101, 3)" end="(112, 36)">
                  <OtherNode start="(101, 3)" end="(101, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;⊢ xs &amp;lt;+: take i ys ↔ xs &amp;lt;+: ys ∧ xs.length ≤ i" state_after="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;⊢ xs &amp;lt;+: take i ys → xs &amp;lt;+: ys ∧ xs.length ≤ i&#10;&#10;case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;⊢ xs &amp;lt;+: ys ∧ xs.length ≤ i → xs &amp;lt;+: take i ys" tactic="constructor">
                    <AtomNode start="(101, 3)" end="(101, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(102, 3)" end="(107, 19)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;⊢ xs &amp;lt;+: take i ys → xs &amp;lt;+: ys ∧ xs.length ≤ i&#10;&#10;case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;⊢ xs &amp;lt;+: ys ∧ xs.length ≤ i → xs &amp;lt;+: take i ys" state_after="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;⊢ xs &amp;lt;+: ys ∧ xs.length ≤ i → xs &amp;lt;+: take i ys" tactic="· intro h&#10;  constructor&#10;  · exact List.IsPrefix.trans h &amp;lt;| List.take_prefix i ys&#10;  · replace h := h.length_le&#10;    rw [length_take, Nat.le_min] at h&#10;    exact h.left">
                    <OtherNode start="(102, 3)" end="(102, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(102, 3)" end="(102, 4)" kind="patternIgnore">
                        <OtherNode start="(102, 3)" end="(102, 4)" kind="token.«· »">
                          <AtomNode start="(102, 3)" end="(102, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(102, 5)" end="(107, 19)">
                      <TacticTacticseq1IndentedNode start="(102, 5)" end="(107, 19)">
                        <NullNode start="(102, 5)" end="(107, 19)">
                          <OtherNode start="(102, 5)" end="(102, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;⊢ xs &amp;lt;+: take i ys → xs &amp;lt;+: ys ∧ xs.length ≤ i" state_after="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;h : xs &amp;lt;+: take i ys&#10;⊢ xs &amp;lt;+: ys ∧ xs.length ≤ i" tactic="intro h">
                            <AtomNode start="(102, 5)" end="(102, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(102, 11)" end="(102, 12)">
                              <IdentNode start="(102, 11)" end="(102, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(103, 5)" end="(103, 16)" kind="Lean.Parser.Tactic.constructor" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;h : xs &amp;lt;+: take i ys&#10;⊢ xs &amp;lt;+: ys ∧ xs.length ≤ i" state_after="case mp.left&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;h : xs &amp;lt;+: take i ys&#10;⊢ xs &amp;lt;+: ys&#10;&#10;case mp.right&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;h : xs &amp;lt;+: take i ys&#10;⊢ xs.length ≤ i" tactic="constructor">
                            <AtomNode start="(103, 5)" end="(103, 16)" leading="" trailing="&#10;    " val="constructor"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(104, 5)" end="(104, 59)" kind="Lean.cdot" state_before="case mp.left&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;h : xs &amp;lt;+: take i ys&#10;⊢ xs &amp;lt;+: ys&#10;&#10;case mp.right&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;h : xs &amp;lt;+: take i ys&#10;⊢ xs.length ≤ i" state_after="case mp.right&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;h : xs &amp;lt;+: take i ys&#10;⊢ xs.length ≤ i" tactic="· exact List.IsPrefix.trans h &amp;lt;| List.take_prefix i ys">
                            <OtherNode start="(104, 5)" end="(104, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(104, 5)" end="(104, 6)" kind="patternIgnore">
                                <OtherNode start="(104, 5)" end="(104, 6)" kind="token.«· »">
                                  <AtomNode start="(104, 5)" end="(104, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(104, 7)" end="(104, 59)">
                              <TacticTacticseq1IndentedNode start="(104, 7)" end="(104, 59)">
                                <NullNode start="(104, 7)" end="(104, 59)">
                                  <OtherNode start="(104, 7)" end="(104, 59)" kind="Lean.Parser.Tactic.exact" state_before="case mp.left&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;h : xs &amp;lt;+: take i ys&#10;⊢ xs &amp;lt;+: ys" state_after="no goals" tactic="exact List.IsPrefix.trans h &amp;lt;| List.take_prefix i ys">
                                    <AtomNode start="(104, 7)" end="(104, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(104, 13)" end="(104, 59)" kind="«term_&amp;lt;|_»">
                                      <OtherNode start="(104, 13)" end="(104, 34)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(104, 13)" end="(104, 32)" leading="" trailing=" " raw_val="List.IsPrefix.trans" val="List.IsPrefix.trans" full_name="List.IsPrefix.trans" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                        <NullNode start="(104, 33)" end="(104, 34)">
                                          <IdentNode start="(104, 33)" end="(104, 34)" leading="" trailing=" " raw_val="h" val="h"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(104, 35)" end="(104, 37)" leading="" trailing=" " val="&amp;lt;|"/>
                                      <OtherNode start="(104, 38)" end="(104, 59)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(104, 38)" end="(104, 54)" leading="" trailing=" " raw_val="List.take_prefix" val="List.take_prefix" full_name="List.take_prefix" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                        <NullNode start="(104, 55)" end="(104, 59)">
                                          <IdentNode start="(104, 55)" end="(104, 56)" leading="" trailing=" " raw_val="i" val="i"/>
                                          <IdentNode start="(104, 57)" end="(104, 59)" leading="" trailing="&#10;    " raw_val="ys" val="ys"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(105, 5)" end="(107, 19)" kind="Lean.cdot" state_before="case mp.right&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;h : xs &amp;lt;+: take i ys&#10;⊢ xs.length ≤ i" state_after="no goals" tactic="· replace h := h.length_le&#10;  rw [length_take, Nat.le_min] at h&#10;  exact h.left">
                            <OtherNode start="(105, 5)" end="(105, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(105, 5)" end="(105, 6)" kind="patternIgnore">
                                <OtherNode start="(105, 5)" end="(105, 6)" kind="token.«· »">
                                  <AtomNode start="(105, 5)" end="(105, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(105, 7)" end="(107, 19)">
                              <TacticTacticseq1IndentedNode start="(105, 7)" end="(107, 19)">
                                <NullNode start="(105, 7)" end="(107, 19)">
                                  <OtherNode start="(105, 7)" end="(105, 31)" kind="Lean.Parser.Tactic.replace" state_before="case mp.right&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;h : xs &amp;lt;+: take i ys&#10;⊢ xs.length ≤ i" state_after="case mp.right&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;h : xs.length ≤ (take i ys).length&#10;⊢ xs.length ≤ i" tactic="replace h := h.length_le">
                                    <AtomNode start="(105, 7)" end="(105, 14)" leading="" trailing=" " val="replace"/>
                                    <OtherNode start="(105, 15)" end="(105, 31)" kind="Lean.Parser.Term.haveDecl">
                                      <OtherNode start="(105, 15)" end="(105, 31)" kind="Lean.Parser.Term.haveIdDecl">
                                        <OtherNode start="(105, 15)" end="(105, 16)" kind="Lean.Parser.Term.haveId">
                                          <IdentNode start="(105, 15)" end="(105, 16)" leading="" trailing=" " raw_val="h" val="h"/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <AtomNode start="(105, 17)" end="(105, 19)" leading="" trailing=" " val=":="/>
                                        <IdentNode start="(105, 20)" end="(105, 31)" leading="" trailing="&#10;      " raw_val="h.length_le" val="h.length_le"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(106, 7)" end="(106, 40)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mp.right&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;h : xs.length ≤ (take i ys).length&#10;⊢ xs.length ≤ i" state_after="case mp.right&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;h : xs.length ≤ i ∧ xs.length ≤ ys.length&#10;⊢ xs.length ≤ i" tactic="rw [length_take, Nat.le_min] at h">
                                    <AtomNode start="(106, 7)" end="(106, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(106, 10)" end="(106, 35)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(106, 10)" end="(106, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(106, 11)" end="(106, 34)">
                                        <OtherNode start="(106, 11)" end="(106, 22)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(106, 11)" end="(106, 22)" leading="" trailing="" raw_val="length_take" val="length_take" full_name="List.length_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(106, 22)" end="(106, 23)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(106, 24)" end="(106, 34)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(106, 24)" end="(106, 34)" leading="" trailing="" raw_val="Nat.le_min" val="Nat.le_min" full_name="Nat.le_min" mod_name="Init.Data.Nat.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/MinMax.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(106, 34)" end="(106, 35)" leading="" trailing=" " val="]"/>
                                    </OtherNode>
                                    <NullNode start="(106, 36)" end="(106, 40)">
                                      <OtherNode start="(106, 36)" end="(106, 40)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(106, 36)" end="(106, 38)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(106, 39)" end="(106, 40)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(106, 39)" end="(106, 40)">
                                            <IdentNode start="(106, 39)" end="(106, 40)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(107, 7)" end="(107, 19)" kind="Lean.Parser.Tactic.exact" state_before="case mp.right&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;h : xs.length ≤ i ∧ xs.length ≤ ys.length&#10;⊢ xs.length ≤ i" state_after="no goals" tactic="exact h.left">
                                    <AtomNode start="(107, 7)" end="(107, 12)" leading="" trailing=" " val="exact"/>
                                    <IdentNode start="(107, 13)" end="(107, 19)" leading="" trailing="&#10;  " raw_val="h.left" val="h.left"/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(108, 3)" end="(112, 36)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;⊢ xs &amp;lt;+: ys ∧ xs.length ≤ i → xs &amp;lt;+: take i ys" state_after="no goals" tactic="· intro ⟨hp, hl⟩&#10;  have hl' := hp.length_le&#10;  rw [List.prefix_iff_eq_take] at *&#10;  rw [hp, List.take_take]&#10;  simp [Nat.min_eq_left, hl, hl']">
                    <OtherNode start="(108, 3)" end="(108, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(108, 3)" end="(108, 4)" kind="patternIgnore">
                        <OtherNode start="(108, 3)" end="(108, 4)" kind="token.«· »">
                          <AtomNode start="(108, 3)" end="(108, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(108, 5)" end="(112, 36)">
                      <TacticTacticseq1IndentedNode start="(108, 5)" end="(112, 36)">
                        <NullNode start="(108, 5)" end="(112, 36)">
                          <OtherNode start="(108, 5)" end="(108, 19)" kind="Lean.Parser.Tactic.intro" state_before="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;⊢ xs &amp;lt;+: ys ∧ xs.length ≤ i → xs &amp;lt;+: take i ys" state_after="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;hp : xs &amp;lt;+: ys&#10;hl : xs.length ≤ i&#10;⊢ xs &amp;lt;+: take i ys" tactic="intro ⟨hp, hl⟩">
                            <AtomNode start="(108, 5)" end="(108, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(108, 11)" end="(108, 19)">
                              <OtherNode start="(108, 11)" end="(108, 19)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(108, 11)" end="(108, 12)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(108, 12)" end="(108, 18)">
                                  <IdentNode start="(108, 12)" end="(108, 14)" leading="" trailing="" raw_val="hp" val="hp"/>
                                  <AtomNode start="(108, 14)" end="(108, 15)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(108, 16)" end="(108, 18)" leading="" trailing="" raw_val="hl" val="hl"/>
                                </NullNode>
                                <AtomNode start="(108, 18)" end="(108, 19)" leading="" trailing="&#10;    " val="⟩"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(109, 5)" end="(109, 29)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;hp : xs &amp;lt;+: ys&#10;hl : xs.length ≤ i&#10;⊢ xs &amp;lt;+: take i ys" state_after="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;hp : xs &amp;lt;+: ys&#10;hl : xs.length ≤ i&#10;hl' : xs.length ≤ ys.length&#10;⊢ xs &amp;lt;+: take i ys" tactic="have hl' := hp.length_le">
                            <AtomNode start="(109, 5)" end="(109, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(109, 10)" end="(109, 29)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(109, 10)" end="(109, 29)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(109, 10)" end="(109, 13)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(109, 10)" end="(109, 13)" leading="" trailing=" " raw_val="hl'" val="hl'"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(109, 14)" end="(109, 16)" leading="" trailing=" " val=":="/>
                                <IdentNode start="(109, 17)" end="(109, 29)" leading="" trailing="&#10;    " raw_val="hp.length_le" val="hp.length_le"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(110, 5)" end="(110, 38)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;hp : xs &amp;lt;+: ys&#10;hl : xs.length ≤ i&#10;hl' : xs.length ≤ ys.length&#10;⊢ xs &amp;lt;+: take i ys" state_after="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;hp : xs = take xs.length ys&#10;hl : xs.length ≤ i&#10;hl' : xs.length ≤ ys.length&#10;⊢ xs = take xs.length (take i ys)" tactic="rw [List.prefix_iff_eq_take] at *">
                            <AtomNode start="(110, 5)" end="(110, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(110, 8)" end="(110, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(110, 8)" end="(110, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(110, 9)" end="(110, 32)">
                                <OtherNode start="(110, 9)" end="(110, 32)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(110, 9)" end="(110, 32)" leading="" trailing="" raw_val="List.prefix_iff_eq_take" val="List.prefix_iff_eq_take" full_name="List.prefix_iff_eq_take" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(110, 32)" end="(110, 33)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(110, 34)" end="(110, 38)">
                              <OtherNode start="(110, 34)" end="(110, 38)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(110, 34)" end="(110, 36)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(110, 37)" end="(110, 38)" kind="Lean.Parser.Tactic.locationWildcard">
                                  <AtomNode start="(110, 37)" end="(110, 38)" leading="" trailing="&#10;    " val="*"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(111, 5)" end="(111, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;hp : xs = take xs.length ys&#10;hl : xs.length ≤ i&#10;hl' : xs.length ≤ ys.length&#10;⊢ xs = take xs.length (take i ys)" state_after="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;hp : xs = take xs.length ys&#10;hl : xs.length ≤ i&#10;hl' : xs.length ≤ ys.length&#10;⊢ take xs.length ys = take (min (take xs.length ys).length i) ys" tactic="rw [hp, List.take_take]">
                            <AtomNode start="(111, 5)" end="(111, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(111, 8)" end="(111, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(111, 8)" end="(111, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(111, 9)" end="(111, 27)">
                                <OtherNode start="(111, 9)" end="(111, 11)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(111, 9)" end="(111, 11)" leading="" trailing="" raw_val="hp" val="hp"/>
                                </OtherNode>
                                <AtomNode start="(111, 11)" end="(111, 12)" leading="" trailing=" " val=","/>
                                <OtherNode start="(111, 13)" end="(111, 27)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(111, 13)" end="(111, 27)" leading="" trailing="" raw_val="List.take_take" val="List.take_take" full_name="List.take_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(111, 27)" end="(111, 28)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(112, 5)" end="(112, 36)" kind="Lean.Parser.Tactic.simp" state_before="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;i : Nat&#10;hp : xs = take xs.length ys&#10;hl : xs.length ≤ i&#10;hl' : xs.length ≤ ys.length&#10;⊢ take xs.length ys = take (min (take xs.length ys).length i) ys" state_after="no goals" tactic="simp [Nat.min_eq_left, hl, hl']">
                            <AtomNode start="(112, 5)" end="(112, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(112, 10)" end="(112, 36)">
                              <AtomNode start="(112, 10)" end="(112, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(112, 11)" end="(112, 35)">
                                <OtherNode start="(112, 11)" end="(112, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(112, 11)" end="(112, 26)" leading="" trailing="" raw_val="Nat.min_eq_left" val="Nat.min_eq_left" full_name="Nat.min_eq_left" mod_name="Init.Data.Nat.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/MinMax.lean"/>
                                </OtherNode>
                                <AtomNode start="(112, 26)" end="(112, 27)" leading="" trailing=" " val=","/>
                                <OtherNode start="(112, 28)" end="(112, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(112, 28)" end="(112, 30)" leading="" trailing="" raw_val="hl" val="hl"/>
                                </OtherNode>
                                <AtomNode start="(112, 30)" end="(112, 31)" leading="" trailing=" " val=","/>
                                <OtherNode start="(112, 32)" end="(112, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(112, 32)" end="(112, 35)" leading="" trailing="" raw_val="hl'" val="hl'"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(112, 35)" end="(112, 36)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(114, 1)" end="(116, 39)" name="suffix_iff_eq_drop" full_name="List.suffix_iff_eq_drop">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(114, 1)" end="(116, 39)" name="suffix_iff_eq_drop" full_name="List.suffix_iff_eq_drop" _is_private_decl="False">
        <AtomNode start="(114, 1)" end="(114, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(114, 9)" end="(114, 27)">
          <IdentNode start="(114, 9)" end="(114, 27)" leading="" trailing=" " raw_val="suffix_iff_eq_drop" val="suffix_iff_eq_drop"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(114, 28)" end="(114, 78)">
          <NullNode/>
          <TermTypespecNode start="(114, 28)" end="(114, 78)">
            <AtomNode start="(114, 28)" end="(114, 29)" leading="" trailing=" " val=":"/>
            <OtherNode start="(114, 30)" end="(114, 78)" kind="«term_↔_»">
              <OtherNode start="(114, 30)" end="(114, 39)" kind="List.«term_&amp;lt;:+_»">
                <IdentNode start="(114, 30)" end="(114, 32)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(114, 33)" end="(114, 36)" leading="" trailing=" " val="&amp;lt;:+"/>
                <IdentNode start="(114, 37)" end="(114, 39)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
              <AtomNode start="(114, 40)" end="(114, 41)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(114, 42)" end="(114, 78)" kind="«term_=_»">
                <IdentNode start="(114, 42)" end="(114, 44)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(114, 45)" end="(114, 46)" leading="" trailing=" " val="="/>
                <OtherNode start="(114, 47)" end="(114, 78)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(114, 47)" end="(114, 51)" leading="" trailing=" " raw_val="drop" val="drop" full_name="List.drop" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(114, 52)" end="(114, 78)">
                    <OtherNode start="(114, 52)" end="(114, 75)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(114, 52)" end="(114, 53)" leading="" trailing="" val="("/>
                      <OtherNode start="(114, 53)" end="(114, 74)" kind="«term_-_»">
                        <OtherNode start="(114, 53)" end="(114, 62)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(114, 53)" end="(114, 59)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(114, 60)" end="(114, 62)">
                            <IdentNode start="(114, 60)" end="(114, 62)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(114, 63)" end="(114, 64)" leading="" trailing=" " val="-"/>
                        <OtherNode start="(114, 65)" end="(114, 74)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(114, 65)" end="(114, 71)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(114, 72)" end="(114, 74)">
                            <IdentNode start="(114, 72)" end="(114, 74)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(114, 74)" end="(114, 75)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(114, 76)" end="(114, 78)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(114, 79)" end="(116, 39)">
          <AtomNode start="(114, 79)" end="(114, 81)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(115, 3)" end="(116, 39)" kind="Lean.Parser.Term.anonymousCtor">
            <AtomNode start="(115, 3)" end="(115, 4)" leading="" trailing="" val="⟨"/>
            <NullNode start="(115, 4)" end="(116, 38)">
              <OtherNode start="(115, 4)" end="(115, 95)" kind="Lean.Parser.Term.fun">
                <AtomNode start="(115, 4)" end="(115, 7)" leading="" trailing=" " val="fun"/>
                <OtherNode start="(115, 8)" end="(115, 95)" kind="Lean.Parser.Term.basicFun">
                  <NullNode start="(115, 8)" end="(115, 9)">
                    <IdentNode start="(115, 8)" end="(115, 9)" leading="" trailing=" " raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(115, 10)" end="(115, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(115, 13)" end="(115, 95)" kind="«term_&amp;lt;|_»">
                    <IdentNode start="(115, 13)" end="(115, 31)" leading="" trailing=" " raw_val="append_cancel_left" val="append_cancel_left" full_name="List.append_cancel_left" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                    <AtomNode start="(115, 32)" end="(115, 34)" leading="" trailing=" " val="&amp;lt;|"/>
                    <OtherNode start="(115, 35)" end="(115, 95)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(115, 35)" end="(115, 67)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(115, 35)" end="(115, 61)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(115, 35)" end="(115, 36)" leading="" trailing="" val="("/>
                          <OtherNode start="(115, 36)" end="(115, 60)" kind="Lean.Parser.Term.app">
                            <OtherNode start="(115, 36)" end="(115, 58)" kind="Lean.Parser.Term.proj">
                              <IdentNode start="(115, 36)" end="(115, 56)" leading="" trailing="" raw_val="suffix_iff_eq_append" val="suffix_iff_eq_append" full_name="List.suffix_iff_eq_append" mod_name="Init.Data.List.Nat.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Sublist.lean" def_start="(96, 9)" def_end="(96, 29)"/>
                              <AtomNode start="(115, 56)" end="(115, 57)" leading="" trailing="" val="."/>
                              <OtherNode start="(115, 57)" end="(115, 58)" kind="fieldIdx">
                                <AtomNode start="(115, 57)" end="(115, 58)" leading="" trailing=" " val="1"/>
                              </OtherNode>
                            </OtherNode>
                            <NullNode start="(115, 59)" end="(115, 60)">
                              <IdentNode start="(115, 59)" end="(115, 60)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(115, 60)" end="(115, 61)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(115, 61)" end="(115, 62)" leading="" trailing="" val="."/>
                        <IdentNode start="(115, 62)" end="(115, 67)" leading="" trailing=" " raw_val="trans" val="trans" full_name="Eq.trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                      <NullNode start="(115, 68)" end="(115, 95)">
                        <OtherNode start="(115, 68)" end="(115, 95)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(115, 68)" end="(115, 90)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(115, 68)" end="(115, 69)" leading="" trailing="" val="("/>
                            <OtherNode start="(115, 69)" end="(115, 89)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(115, 69)" end="(115, 85)" leading="" trailing=" " raw_val="take_append_drop" val="take_append_drop" full_name="List.take_append_drop" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                              <NullNode start="(115, 86)" end="(115, 89)">
                                <TermHoleNode start="(115, 86)" end="(115, 87)">
                                  <AtomNode start="(115, 86)" end="(115, 87)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <TermHoleNode start="(115, 88)" end="(115, 89)">
                                  <AtomNode start="(115, 88)" end="(115, 89)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(115, 89)" end="(115, 90)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(115, 90)" end="(115, 91)" leading="" trailing="" val="."/>
                          <IdentNode start="(115, 91)" end="(115, 95)" leading="" trailing="" raw_val="symm" val="symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(115, 95)" end="(115, 96)" leading="" trailing="&#10;    " val=","/>
              <OtherNode start="(116, 5)" end="(116, 38)" kind="Lean.Parser.Term.fun">
                <AtomNode start="(116, 5)" end="(116, 8)" leading="" trailing=" " val="fun"/>
                <OtherNode start="(116, 9)" end="(116, 38)" kind="Lean.Parser.Term.basicFun">
                  <NullNode start="(116, 9)" end="(116, 10)">
                    <IdentNode start="(116, 9)" end="(116, 10)" leading="" trailing=" " raw_val="e" val="e"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(116, 11)" end="(116, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(116, 14)" end="(116, 38)" kind="Lean.Parser.Term.subst">
                    <IdentNode start="(116, 14)" end="(116, 20)" leading="" trailing=" " raw_val="e.symm" val="e.symm"/>
                    <AtomNode start="(116, 21)" end="(116, 22)" leading="" trailing=" " val="▸"/>
                    <NullNode start="(116, 23)" end="(116, 38)">
                      <OtherNode start="(116, 23)" end="(116, 38)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(116, 23)" end="(116, 34)" leading="" trailing=" " raw_val="drop_suffix" val="drop_suffix" full_name="List.drop_suffix" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                        <NullNode start="(116, 35)" end="(116, 38)">
                          <TermHoleNode start="(116, 35)" end="(116, 36)">
                            <AtomNode start="(116, 35)" end="(116, 36)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                          <TermHoleNode start="(116, 37)" end="(116, 38)">
                            <AtomNode start="(116, 37)" end="(116, 38)" leading="" trailing="" val="_"/>
                          </TermHoleNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(116, 38)" end="(116, 39)" leading="" trailing="&#10;&#10;" val="⟩"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(118, 1)" end="(132, 63)" name="prefix_take_le_iff" full_name="List.prefix_take_le_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(118, 1)" end="(132, 63)" name="prefix_take_le_iff" full_name="List.prefix_take_le_iff" _is_private_decl="False">
        <AtomNode start="(118, 1)" end="(118, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(118, 9)" end="(118, 27)">
          <IdentNode start="(118, 9)" end="(118, 27)" leading="" trailing=" " raw_val="prefix_take_le_iff" val="prefix_take_le_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(118, 28)" end="(119, 36)">
          <NullNode start="(118, 28)" end="(118, 62)">
            <OtherNode start="(118, 28)" end="(118, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(118, 28)" end="(118, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(118, 29)" end="(118, 31)">
                <IdentNode start="(118, 29)" end="(118, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(118, 32)" end="(118, 40)">
                <AtomNode start="(118, 32)" end="(118, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(118, 34)" end="(118, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(118, 34)" end="(118, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(118, 39)" end="(118, 40)">
                    <IdentNode start="(118, 39)" end="(118, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(118, 40)" end="(118, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(118, 42)" end="(118, 62)">
              <AtomNode start="(118, 42)" end="(118, 43)" leading="" trailing="" val="("/>
              <NullNode start="(118, 43)" end="(118, 45)">
                <IdentNode start="(118, 43)" end="(118, 45)" leading="" trailing=" " raw_val="hm" val="hm"/>
              </NullNode>
              <NullNode start="(118, 46)" end="(118, 61)">
                <AtomNode start="(118, 46)" end="(118, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(118, 48)" end="(118, 61)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(118, 48)" end="(118, 49)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(118, 50)" end="(118, 51)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(118, 52)" end="(118, 61)" leading="" trailing="" raw_val="xs.length" val="xs.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(118, 61)" end="(118, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(118, 63)" end="(119, 36)">
            <AtomNode start="(118, 63)" end="(118, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(119, 5)" end="(119, 36)" kind="«term_↔_»">
              <OtherNode start="(119, 5)" end="(119, 28)" kind="List.«term_&amp;lt;+:_»">
                <OtherNode start="(119, 5)" end="(119, 14)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(119, 5)" end="(119, 12)" leading="" trailing=" " raw_val="xs.take" val="xs.take"/>
                  <NullNode start="(119, 13)" end="(119, 14)">
                    <IdentNode start="(119, 13)" end="(119, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(119, 15)" end="(119, 18)" leading="" trailing=" " val="&amp;lt;+:"/>
                <OtherNode start="(119, 19)" end="(119, 28)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(119, 19)" end="(119, 26)" leading="" trailing=" " raw_val="xs.take" val="xs.take"/>
                  <NullNode start="(119, 27)" end="(119, 28)">
                    <IdentNode start="(119, 27)" end="(119, 28)" leading="" trailing=" " raw_val="j" val="j"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(119, 29)" end="(119, 30)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(119, 31)" end="(119, 36)" kind="«term_≤_»">
                <IdentNode start="(119, 31)" end="(119, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                <AtomNode start="(119, 33)" end="(119, 34)" leading="" trailing=" " val="≤"/>
                <IdentNode start="(119, 35)" end="(119, 36)" leading="" trailing=" " raw_val="j" val="j"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(119, 37)" end="(132, 63)">
          <AtomNode start="(119, 37)" end="(119, 39)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(119, 40)" end="(132, 63)">
            <AtomNode start="(119, 40)" end="(119, 42)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(120, 3)" end="(132, 63)">
              <TacticTacticseq1IndentedNode start="(120, 3)" end="(132, 63)">
                <NullNode start="(120, 3)" end="(132, 63)">
                  <OtherNode start="(120, 3)" end="(120, 46)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;i j : Nat&#10;xs : List α&#10;hm : i &amp;lt; xs.length&#10;⊢ take i xs &amp;lt;+: take j xs ↔ i ≤ j" state_after="α : Type u_1&#10;i j : Nat&#10;xs : List α&#10;hm : i &amp;lt; xs.length&#10;⊢ take i xs = take (min i xs.length) (take j xs) ↔ i ≤ j" tactic="simp only [prefix_iff_eq_take, length_take]">
                    <AtomNode start="(120, 3)" end="(120, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(120, 8)" end="(120, 12)">
                      <AtomNode start="(120, 8)" end="(120, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(120, 13)" end="(120, 46)">
                      <AtomNode start="(120, 13)" end="(120, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(120, 14)" end="(120, 45)">
                        <OtherNode start="(120, 14)" end="(120, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(120, 14)" end="(120, 32)" leading="" trailing="" raw_val="prefix_iff_eq_take" val="prefix_iff_eq_take" full_name="List.prefix_iff_eq_take" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                        </OtherNode>
                        <AtomNode start="(120, 32)" end="(120, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(120, 34)" end="(120, 45)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(120, 34)" end="(120, 45)" leading="" trailing="" raw_val="length_take" val="length_take" full_name="List.length_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(120, 45)" end="(120, 46)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(121, 3)" end="(132, 63)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;i j : Nat&#10;xs : List α&#10;hm : i &amp;lt; xs.length&#10;⊢ take i xs = take (min i xs.length) (take j xs) ↔ i ≤ j" state_after="no goals" tactic="induction i generalizing xs j with&#10;| zero =&amp;gt; simp [Nat.min_eq_left, eq_self_iff_true, Nat.zero_le, take]&#10;| succ i IH =&amp;gt;&#10;  cases xs with&#10;  | nil =&amp;gt; simp_all&#10;  | cons x xs =&amp;gt;&#10;    cases j with&#10;    | zero =&amp;gt;&#10;      simp&#10;    | succ j =&amp;gt;&#10;      simp only [length_cons, Nat.succ_eq_add_one, Nat.add_lt_add_iff_right] at hm&#10;      simp [← @IH j xs hm, Nat.min_eq_left, Nat.le_of_lt hm]">
                    <AtomNode start="(121, 3)" end="(121, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(121, 13)" end="(121, 14)">
                      <OtherNode start="(121, 13)" end="(121, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(121, 13)" end="(121, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(121, 15)" end="(121, 32)">
                      <AtomNode start="(121, 15)" end="(121, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(121, 28)" end="(121, 32)">
                        <IdentNode start="(121, 28)" end="(121, 30)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        <IdentNode start="(121, 31)" end="(121, 32)" leading="" trailing=" " raw_val="j" val="j"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(121, 33)" end="(132, 63)">
                      <OtherNode start="(121, 33)" end="(132, 63)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(121, 33)" end="(121, 37)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(122, 3)" end="(132, 63)">
                          <OtherNode start="(122, 3)" end="(122, 72)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(122, 3)" end="(122, 9)">
                              <OtherNode start="(122, 3)" end="(122, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(122, 3)" end="(122, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(122, 5)" end="(122, 9)">
                                  <NullNode/>
                                  <IdentNode start="(122, 5)" end="(122, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(122, 10)" end="(122, 72)">
                              <AtomNode start="(122, 10)" end="(122, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(122, 13)" end="(122, 72)">
                                <TacticTacticseq1IndentedNode start="(122, 13)" end="(122, 72)">
                                  <NullNode start="(122, 13)" end="(122, 72)">
                                    <OtherNode start="(122, 13)" end="(122, 72)" kind="Lean.Parser.Tactic.simp" state_before="case zero&#10;α : Type u_1&#10;j : Nat&#10;xs : List α&#10;hm : 0 &amp;lt; xs.length&#10;⊢ take 0 xs = take (min 0 xs.length) (take j xs) ↔ 0 ≤ j" state_after="no goals" tactic="simp [Nat.min_eq_left, eq_self_iff_true, Nat.zero_le, take]">
                                      <AtomNode start="(122, 13)" end="(122, 17)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(122, 18)" end="(122, 72)">
                                        <AtomNode start="(122, 18)" end="(122, 19)" leading="" trailing="" val="["/>
                                        <NullNode start="(122, 19)" end="(122, 71)">
                                          <OtherNode start="(122, 19)" end="(122, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(122, 19)" end="(122, 34)" leading="" trailing="" raw_val="Nat.min_eq_left" val="Nat.min_eq_left" full_name="Nat.min_eq_left" mod_name="Init.Data.Nat.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/MinMax.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(122, 34)" end="(122, 35)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(122, 36)" end="(122, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(122, 36)" end="(122, 52)" leading="" trailing="" raw_val="eq_self_iff_true" val="eq_self_iff_true" full_name="eq_self_iff_true" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(122, 52)" end="(122, 53)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(122, 54)" end="(122, 65)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(122, 54)" end="(122, 65)" leading="" trailing="" raw_val="Nat.zero_le" val="Nat.zero_le" full_name="Nat.zero_le" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(122, 65)" end="(122, 66)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(122, 67)" end="(122, 71)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(122, 67)" end="(122, 71)" leading="" trailing="" raw_val="take" val="take" full_name="List.take" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(122, 71)" end="(122, 72)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(123, 3)" end="(132, 63)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(123, 3)" end="(123, 14)">
                              <OtherNode start="(123, 3)" end="(123, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(123, 3)" end="(123, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(123, 5)" end="(123, 9)">
                                  <NullNode/>
                                  <IdentNode start="(123, 5)" end="(123, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(123, 10)" end="(123, 14)">
                                  <IdentNode start="(123, 10)" end="(123, 11)" leading="" trailing=" " raw_val="i" val="i"/>
                                  <IdentNode start="(123, 12)" end="(123, 14)" leading="" trailing=" " raw_val="IH" val="IH"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(123, 15)" end="(132, 63)">
                              <AtomNode start="(123, 15)" end="(123, 17)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(124, 5)" end="(132, 63)">
                                <TacticTacticseq1IndentedNode start="(124, 5)" end="(132, 63)">
                                  <NullNode start="(124, 5)" end="(132, 63)">
                                    <OtherNode start="(124, 5)" end="(132, 63)" kind="Lean.Parser.Tactic.cases" state_before="case succ&#10;α : Type u_1&#10;i : Nat&#10;IH : ∀ {j : Nat} {xs : List α}, i &amp;lt; xs.length → (take i xs = take (min i xs.length) (take j xs) ↔ i ≤ j)&#10;j : Nat&#10;xs : List α&#10;hm : i + 1 &amp;lt; xs.length&#10;⊢ take (i + 1) xs = take (min (i + 1) xs.length) (take j xs) ↔ i + 1 ≤ j" state_after="no goals" tactic="cases xs with&#10;| nil =&amp;gt; simp_all&#10;| cons x xs =&amp;gt;&#10;  cases j with&#10;  | zero =&amp;gt;&#10;    simp&#10;  | succ j =&amp;gt;&#10;    simp only [length_cons, Nat.succ_eq_add_one, Nat.add_lt_add_iff_right] at hm&#10;    simp [← @IH j xs hm, Nat.min_eq_left, Nat.le_of_lt hm]">
                                      <AtomNode start="(124, 5)" end="(124, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(124, 11)" end="(124, 13)">
                                        <OtherNode start="(124, 11)" end="(124, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(124, 11)" end="(124, 13)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(124, 14)" end="(132, 63)">
                                        <OtherNode start="(124, 14)" end="(132, 63)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(124, 14)" end="(124, 18)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(125, 5)" end="(132, 63)">
                                            <OtherNode start="(125, 5)" end="(125, 22)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(125, 5)" end="(125, 10)">
                                                <OtherNode start="(125, 5)" end="(125, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(125, 5)" end="(125, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(125, 7)" end="(125, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(125, 7)" end="(125, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(125, 11)" end="(125, 22)">
                                                <AtomNode start="(125, 11)" end="(125, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(125, 14)" end="(125, 22)">
                                                  <TacticTacticseq1IndentedNode start="(125, 14)" end="(125, 22)">
                                                    <NullNode start="(125, 14)" end="(125, 22)">
                                                      <OtherNode start="(125, 14)" end="(125, 22)" kind="Lean.Parser.Tactic.simpAll" state_before="case succ.nil&#10;α : Type u_1&#10;i : Nat&#10;IH : ∀ {j : Nat} {xs : List α}, i &amp;lt; xs.length → (take i xs = take (min i xs.length) (take j xs) ↔ i ≤ j)&#10;j : Nat&#10;hm : i + 1 &amp;lt; [].length&#10;⊢ take (i + 1) [] = take (min (i + 1) [].length) (take j []) ↔ i + 1 ≤ j" state_after="no goals" tactic="simp_all">
                                                        <AtomNode start="(125, 14)" end="(125, 22)" leading="" trailing="&#10;    " val="simp_all"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(126, 5)" end="(132, 63)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(126, 5)" end="(126, 16)">
                                                <OtherNode start="(126, 5)" end="(126, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(126, 5)" end="(126, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(126, 7)" end="(126, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(126, 7)" end="(126, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(126, 12)" end="(126, 16)">
                                                    <IdentNode start="(126, 12)" end="(126, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                                                    <IdentNode start="(126, 14)" end="(126, 16)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(126, 17)" end="(132, 63)">
                                                <AtomNode start="(126, 17)" end="(126, 19)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(127, 7)" end="(132, 63)">
                                                  <TacticTacticseq1IndentedNode start="(127, 7)" end="(132, 63)">
                                                    <NullNode start="(127, 7)" end="(132, 63)">
                                                      <OtherNode start="(127, 7)" end="(132, 63)" kind="Lean.Parser.Tactic.cases" state_before="case succ.cons&#10;α : Type u_1&#10;i : Nat&#10;IH : ∀ {j : Nat} {xs : List α}, i &amp;lt; xs.length → (take i xs = take (min i xs.length) (take j xs) ↔ i ≤ j)&#10;j : Nat&#10;x : α&#10;xs : List α&#10;hm : i + 1 &amp;lt; (x :: xs).length&#10;⊢ take (i + 1) (x :: xs) = take (min (i + 1) (x :: xs).length) (take j (x :: xs)) ↔ i + 1 ≤ j" state_after="no goals" tactic="cases j with&#10;| zero =&amp;gt;&#10;  simp&#10;| succ j =&amp;gt;&#10;  simp only [length_cons, Nat.succ_eq_add_one, Nat.add_lt_add_iff_right] at hm&#10;  simp [← @IH j xs hm, Nat.min_eq_left, Nat.le_of_lt hm]">
                                                        <AtomNode start="(127, 7)" end="(127, 12)" leading="" trailing=" " val="cases"/>
                                                        <NullNode start="(127, 13)" end="(127, 14)">
                                                          <OtherNode start="(127, 13)" end="(127, 14)" kind="Lean.Parser.Tactic.elimTarget">
                                                            <NullNode/>
                                                            <IdentNode start="(127, 13)" end="(127, 14)" leading="" trailing=" " raw_val="j" val="j"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <NullNode/>
                                                        <NullNode start="(127, 15)" end="(132, 63)">
                                                          <OtherNode start="(127, 15)" end="(132, 63)" kind="Lean.Parser.Tactic.inductionAlts">
                                                            <AtomNode start="(127, 15)" end="(127, 19)" leading="" trailing="&#10;      " val="with"/>
                                                            <NullNode/>
                                                            <NullNode start="(128, 7)" end="(132, 63)">
                                                            <OtherNode start="(128, 7)" end="(129, 13)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(128, 7)" end="(128, 13)">
                                                            <OtherNode start="(128, 7)" end="(128, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(128, 7)" end="(128, 8)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(128, 9)" end="(128, 13)">
                                                            <NullNode/>
                                                            <IdentNode start="(128, 9)" end="(128, 13)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                            </GroupNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(128, 14)" end="(129, 13)">
                                                            <AtomNode start="(128, 14)" end="(128, 16)" leading="" trailing="&#10;        " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(129, 9)" end="(129, 13)">
                                                            <TacticTacticseq1IndentedNode start="(129, 9)" end="(129, 13)">
                                                            <NullNode start="(129, 9)" end="(129, 13)">
                                                            <OtherNode start="(129, 9)" end="(129, 13)" kind="Lean.Parser.Tactic.simp" state_before="case succ.cons.zero&#10;α : Type u_1&#10;i : Nat&#10;IH : ∀ {j : Nat} {xs : List α}, i &amp;lt; xs.length → (take i xs = take (min i xs.length) (take j xs) ↔ i ≤ j)&#10;x : α&#10;xs : List α&#10;hm : i + 1 &amp;lt; (x :: xs).length&#10;⊢ take (i + 1) (x :: xs) = take (min (i + 1) (x :: xs).length) (take 0 (x :: xs)) ↔ i + 1 ≤ 0" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(129, 9)" end="(129, 13)" leading="" trailing="&#10;      " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <OtherNode start="(130, 7)" end="(132, 63)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(130, 7)" end="(130, 15)">
                                                            <OtherNode start="(130, 7)" end="(130, 15)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(130, 7)" end="(130, 8)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(130, 9)" end="(130, 13)">
                                                            <NullNode/>
                                                            <IdentNode start="(130, 9)" end="(130, 13)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                            </GroupNode>
                                                            <NullNode start="(130, 14)" end="(130, 15)">
                                                            <IdentNode start="(130, 14)" end="(130, 15)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(130, 16)" end="(132, 63)">
                                                            <AtomNode start="(130, 16)" end="(130, 18)" leading="" trailing="&#10;        " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(131, 9)" end="(132, 63)">
                                                            <TacticTacticseq1IndentedNode start="(131, 9)" end="(132, 63)">
                                                            <NullNode start="(131, 9)" end="(132, 63)">
                                                            <OtherNode start="(131, 9)" end="(131, 85)" kind="Lean.Parser.Tactic.simp" state_before="case succ.cons.succ&#10;α : Type u_1&#10;i : Nat&#10;IH : ∀ {j : Nat} {xs : List α}, i &amp;lt; xs.length → (take i xs = take (min i xs.length) (take j xs) ↔ i ≤ j)&#10;x : α&#10;xs : List α&#10;hm : i + 1 &amp;lt; (x :: xs).length&#10;j : Nat&#10;⊢ take (i + 1) (x :: xs) = take (min (i + 1) (x :: xs).length) (take (j + 1) (x :: xs)) ↔ i + 1 ≤ j + 1" state_after="case succ.cons.succ&#10;α : Type u_1&#10;i : Nat&#10;IH : ∀ {j : Nat} {xs : List α}, i &amp;lt; xs.length → (take i xs = take (min i xs.length) (take j xs) ↔ i ≤ j)&#10;x : α&#10;xs : List α&#10;j : Nat&#10;hm : i &amp;lt; xs.length&#10;⊢ take (i + 1) (x :: xs) = take (min (i + 1) (x :: xs).length) (take (j + 1) (x :: xs)) ↔ i + 1 ≤ j + 1" tactic="simp only [length_cons, Nat.succ_eq_add_one, Nat.add_lt_add_iff_right] at hm">
                                                            <AtomNode start="(131, 9)" end="(131, 13)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(131, 14)" end="(131, 18)">
                                                            <AtomNode start="(131, 14)" end="(131, 18)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(131, 19)" end="(131, 79)">
                                                            <AtomNode start="(131, 19)" end="(131, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(131, 20)" end="(131, 78)">
                                                            <OtherNode start="(131, 20)" end="(131, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(131, 20)" end="(131, 31)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(131, 31)" end="(131, 32)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(131, 33)" end="(131, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(131, 33)" end="(131, 52)" leading="" trailing="" raw_val="Nat.succ_eq_add_one" val="Nat.succ_eq_add_one" full_name="Nat.succ_eq_add_one" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(131, 52)" end="(131, 53)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(131, 54)" end="(131, 78)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(131, 54)" end="(131, 78)" leading="" trailing="" raw_val="Nat.add_lt_add_iff_right" val="Nat.add_lt_add_iff_right" full_name="Nat.add_lt_add_iff_right" mod_name="Init.Data.Nat.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Lemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(131, 78)" end="(131, 79)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(131, 80)" end="(131, 85)">
                                                            <OtherNode start="(131, 80)" end="(131, 85)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(131, 80)" end="(131, 82)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(131, 83)" end="(131, 85)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(131, 83)" end="(131, 85)">
                                                            <IdentNode start="(131, 83)" end="(131, 85)" leading="" trailing="&#10;        " raw_val="hm" val="hm"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(132, 9)" end="(132, 63)" kind="Lean.Parser.Tactic.simp" state_before="case succ.cons.succ&#10;α : Type u_1&#10;i : Nat&#10;IH : ∀ {j : Nat} {xs : List α}, i &amp;lt; xs.length → (take i xs = take (min i xs.length) (take j xs) ↔ i ≤ j)&#10;x : α&#10;xs : List α&#10;j : Nat&#10;hm : i &amp;lt; xs.length&#10;⊢ take (i + 1) (x :: xs) = take (min (i + 1) (x :: xs).length) (take (j + 1) (x :: xs)) ↔ i + 1 ≤ j + 1" state_after="no goals" tactic="simp [← @IH j xs hm, Nat.min_eq_left, Nat.le_of_lt hm]">
                                                            <AtomNode start="(132, 9)" end="(132, 13)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(132, 14)" end="(132, 63)">
                                                            <AtomNode start="(132, 14)" end="(132, 15)" leading="" trailing="" val="["/>
                                                            <NullNode start="(132, 15)" end="(132, 62)">
                                                            <OtherNode start="(132, 15)" end="(132, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode start="(132, 15)" end="(132, 16)">
                                                            <OtherNode start="(132, 15)" end="(132, 16)" kind="patternIgnore">
                                                            <OtherNode start="(132, 15)" end="(132, 16)" kind="token.«← »">
                                                            <AtomNode start="(132, 15)" end="(132, 16)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <OtherNode start="(132, 17)" end="(132, 28)" kind="Lean.Parser.Term.app">
                                                            <OtherNode start="(132, 17)" end="(132, 20)" kind="Lean.Parser.Term.explicit">
                                                            <AtomNode start="(132, 17)" end="(132, 18)" leading="" trailing="" val="@"/>
                                                            <IdentNode start="(132, 18)" end="(132, 20)" leading="" trailing=" " raw_val="IH" val="IH"/>
                                                            </OtherNode>
                                                            <NullNode start="(132, 21)" end="(132, 28)">
                                                            <IdentNode start="(132, 21)" end="(132, 22)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            <IdentNode start="(132, 23)" end="(132, 25)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                                            <IdentNode start="(132, 26)" end="(132, 28)" leading="" trailing="" raw_val="hm" val="hm"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(132, 28)" end="(132, 29)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(132, 30)" end="(132, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(132, 30)" end="(132, 45)" leading="" trailing="" raw_val="Nat.min_eq_left" val="Nat.min_eq_left" full_name="Nat.min_eq_left" mod_name="Init.Data.Nat.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/MinMax.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(132, 45)" end="(132, 46)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(132, 47)" end="(132, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(132, 47)" end="(132, 62)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(132, 47)" end="(132, 59)" leading="" trailing=" " raw_val="Nat.le_of_lt" val="Nat.le_of_lt" full_name="Nat.le_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(132, 60)" end="(132, 62)">
                                                            <IdentNode start="(132, 60)" end="(132, 62)" leading="" trailing="" raw_val="hm" val="hm"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(132, 62)" end="(132, 63)" leading="" trailing="&#10;&#10;" val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(134, 1)" end="(142, 9)" name="append_left_sublist_self" full_name="List.append_left_sublist_self">
      <CommandDeclmodifiersNode start="(134, 1)" end="(134, 8)">
        <NullNode/>
        <NullNode start="(134, 1)" end="(134, 8)">
          <OtherNode start="(134, 1)" end="(134, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(134, 1)" end="(134, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(134, 3)" end="(134, 7)">
              <OtherNode start="(134, 3)" end="(134, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(134, 3)" end="(134, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(134, 3)" end="(134, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(134, 7)" end="(134, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(134, 9)" end="(142, 9)" name="append_left_sublist_self" full_name="List.append_left_sublist_self" _is_private_decl="False">
        <AtomNode start="(134, 9)" end="(134, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(134, 17)" end="(134, 41)">
          <IdentNode start="(134, 17)" end="(134, 41)" leading="" trailing=" " raw_val="append_left_sublist_self" val="append_left_sublist_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(134, 42)" end="(134, 96)">
          <NullNode start="(134, 42)" end="(134, 69)">
            <OtherNode start="(134, 42)" end="(134, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(134, 42)" end="(134, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(134, 43)" end="(134, 45)">
                <IdentNode start="(134, 43)" end="(134, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(134, 46)" end="(134, 54)">
                <AtomNode start="(134, 46)" end="(134, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(134, 48)" end="(134, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(134, 48)" end="(134, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(134, 53)" end="(134, 54)">
                    <IdentNode start="(134, 53)" end="(134, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(134, 54)" end="(134, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(134, 56)" end="(134, 69)">
              <AtomNode start="(134, 56)" end="(134, 57)" leading="" trailing="" val="("/>
              <NullNode start="(134, 57)" end="(134, 59)">
                <IdentNode start="(134, 57)" end="(134, 59)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(134, 60)" end="(134, 68)">
                <AtomNode start="(134, 60)" end="(134, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(134, 62)" end="(134, 68)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(134, 62)" end="(134, 66)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(134, 67)" end="(134, 68)">
                    <IdentNode start="(134, 67)" end="(134, 68)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(134, 68)" end="(134, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(134, 70)" end="(134, 96)">
            <AtomNode start="(134, 70)" end="(134, 71)" leading="" trailing=" " val=":"/>
            <OtherNode start="(134, 72)" end="(134, 96)" kind="«term_↔_»">
              <OtherNode start="(134, 72)" end="(134, 86)" kind="List.«term_&amp;lt;+_»">
                <OtherNode start="(134, 72)" end="(134, 80)" kind="«term_++_»">
                  <IdentNode start="(134, 72)" end="(134, 74)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(134, 75)" end="(134, 77)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(134, 78)" end="(134, 80)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </OtherNode>
                <AtomNode start="(134, 81)" end="(134, 83)" leading="" trailing=" " val="&amp;lt;+"/>
                <IdentNode start="(134, 84)" end="(134, 86)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </OtherNode>
              <AtomNode start="(134, 87)" end="(134, 88)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(134, 89)" end="(134, 96)" kind="«term_=_»">
                <IdentNode start="(134, 89)" end="(134, 91)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <AtomNode start="(134, 92)" end="(134, 93)" leading="" trailing=" " val="="/>
                <OtherNode start="(134, 94)" end="(134, 96)" kind="«term[_]»">
                  <AtomNode start="(134, 94)" end="(134, 95)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(134, 95)" end="(134, 96)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(134, 97)" end="(142, 9)">
          <AtomNode start="(134, 97)" end="(134, 99)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(134, 100)" end="(142, 9)">
            <AtomNode start="(134, 100)" end="(134, 102)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(135, 3)" end="(142, 9)">
              <TacticTacticseq1IndentedNode start="(135, 3)" end="(142, 9)">
                <NullNode start="(135, 3)" end="(142, 9)">
                  <OtherNode start="(135, 3)" end="(135, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;xs ys : List α&#10;⊢ xs ++ ys &amp;lt;+ ys ↔ xs = []" state_after="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ xs ++ ys &amp;lt;+ ys → xs = []&#10;&#10;case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ xs = [] → xs ++ ys &amp;lt;+ ys" tactic="constructor">
                    <AtomNode start="(135, 3)" end="(135, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(136, 3)" end="(140, 13)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ xs ++ ys &amp;lt;+ ys → xs = []&#10;&#10;case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ xs = [] → xs ++ ys &amp;lt;+ ys" state_after="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ xs = [] → xs ++ ys &amp;lt;+ ys" tactic="· intro h&#10;  replace h := h.length_le&#10;  simp only [length_append] at h&#10;  have : xs.length = 0 := by omega&#10;  simp_all">
                    <OtherNode start="(136, 3)" end="(136, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(136, 3)" end="(136, 4)" kind="patternIgnore">
                        <OtherNode start="(136, 3)" end="(136, 4)" kind="token.«· »">
                          <AtomNode start="(136, 3)" end="(136, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(136, 5)" end="(140, 13)">
                      <TacticTacticseq1IndentedNode start="(136, 5)" end="(140, 13)">
                        <NullNode start="(136, 5)" end="(140, 13)">
                          <OtherNode start="(136, 5)" end="(136, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ xs ++ ys &amp;lt;+ ys → xs = []" state_after="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs ++ ys &amp;lt;+ ys&#10;⊢ xs = []" tactic="intro h">
                            <AtomNode start="(136, 5)" end="(136, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(136, 11)" end="(136, 12)">
                              <IdentNode start="(136, 11)" end="(136, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(137, 5)" end="(137, 29)" kind="Lean.Parser.Tactic.replace" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs ++ ys &amp;lt;+ ys&#10;⊢ xs = []" state_after="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : (xs ++ ys).length ≤ ys.length&#10;⊢ xs = []" tactic="replace h := h.length_le">
                            <AtomNode start="(137, 5)" end="(137, 12)" leading="" trailing=" " val="replace"/>
                            <OtherNode start="(137, 13)" end="(137, 29)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(137, 13)" end="(137, 29)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(137, 13)" end="(137, 14)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(137, 13)" end="(137, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(137, 15)" end="(137, 17)" leading="" trailing=" " val=":="/>
                                <IdentNode start="(137, 18)" end="(137, 29)" leading="" trailing="&#10;    " raw_val="h.length_le" val="h.length_le"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(138, 5)" end="(138, 35)" kind="Lean.Parser.Tactic.simp" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : (xs ++ ys).length ≤ ys.length&#10;⊢ xs = []" state_after="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs.length + ys.length ≤ ys.length&#10;⊢ xs = []" tactic="simp only [length_append] at h">
                            <AtomNode start="(138, 5)" end="(138, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(138, 10)" end="(138, 14)">
                              <AtomNode start="(138, 10)" end="(138, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(138, 15)" end="(138, 30)">
                              <AtomNode start="(138, 15)" end="(138, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(138, 16)" end="(138, 29)">
                                <OtherNode start="(138, 16)" end="(138, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(138, 16)" end="(138, 29)" leading="" trailing="" raw_val="length_append" val="length_append" full_name="List.length_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(138, 29)" end="(138, 30)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(138, 31)" end="(138, 35)">
                              <OtherNode start="(138, 31)" end="(138, 35)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(138, 31)" end="(138, 33)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(138, 34)" end="(138, 35)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(138, 34)" end="(138, 35)">
                                    <IdentNode start="(138, 34)" end="(138, 35)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(139, 5)" end="(139, 37)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs.length + ys.length ≤ ys.length&#10;⊢ xs = []" state_after="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs.length + ys.length ≤ ys.length&#10;this : xs.length = 0&#10;⊢ xs = []" tactic="have : xs.length = 0 := by omega">
                            <AtomNode start="(139, 5)" end="(139, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(139, 10)" end="(139, 37)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(139, 10)" end="(139, 37)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(139, 10)" end="(139, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(139, 10)" end="(139, 10)" kind="hygieneInfo">
                                    <IdentNode start="(139, 10)" end="(139, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(139, 10)" end="(139, 25)">
                                  <TermTypespecNode start="(139, 10)" end="(139, 25)">
                                    <AtomNode start="(139, 10)" end="(139, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(139, 12)" end="(139, 25)" kind="«term_=_»">
                                      <IdentNode start="(139, 12)" end="(139, 21)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
                                      <AtomNode start="(139, 22)" end="(139, 23)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(139, 24)" end="(139, 25)" kind="num">
                                        <AtomNode start="(139, 24)" end="(139, 25)" leading="" trailing=" " val="0"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(139, 26)" end="(139, 28)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(139, 29)" end="(139, 37)">
                                  <AtomNode start="(139, 29)" end="(139, 31)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(139, 32)" end="(139, 37)">
                                    <TacticTacticseq1IndentedNode start="(139, 32)" end="(139, 37)">
                                      <NullNode start="(139, 32)" end="(139, 37)">
                                        <OtherNode start="(139, 32)" end="(139, 37)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;xs ys : List α&#10;h : xs.length + ys.length ≤ ys.length&#10;⊢ xs.length = 0" state_after="no goals" tactic="omega">
                                          <AtomNode start="(139, 32)" end="(139, 37)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(140, 5)" end="(140, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs.length + ys.length ≤ ys.length&#10;this : xs.length = 0&#10;⊢ xs = []" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(140, 5)" end="(140, 13)" leading="" trailing="&#10;  " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(141, 3)" end="(142, 9)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ xs = [] → xs ++ ys &amp;lt;+ ys" state_after="no goals" tactic="· rintro rfl&#10;  simp">
                    <OtherNode start="(141, 3)" end="(141, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(141, 3)" end="(141, 4)" kind="patternIgnore">
                        <OtherNode start="(141, 3)" end="(141, 4)" kind="token.«· »">
                          <AtomNode start="(141, 3)" end="(141, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(141, 5)" end="(142, 9)">
                      <TacticTacticseq1IndentedNode start="(141, 5)" end="(142, 9)">
                        <NullNode start="(141, 5)" end="(142, 9)">
                          <OtherNode start="(141, 5)" end="(141, 15)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ xs = [] → xs ++ ys &amp;lt;+ ys" state_after="case mpr&#10;α : Type u_1&#10;ys : List α&#10;⊢ [] ++ ys &amp;lt;+ ys" tactic="rintro rfl">
                            <AtomNode start="(141, 5)" end="(141, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(141, 12)" end="(141, 15)">
                              <OtherNode start="(141, 12)" end="(141, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(141, 12)" end="(141, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(141, 12)" end="(141, 15)" leading="" trailing="&#10;    " raw_val="rfl" val="rfl"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(142, 5)" end="(142, 9)" kind="Lean.Parser.Tactic.simp" state_before="case mpr&#10;α : Type u_1&#10;ys : List α&#10;⊢ [] ++ ys &amp;lt;+ ys" state_after="no goals" tactic="simp">
                            <AtomNode start="(142, 5)" end="(142, 9)" leading="" trailing="&#10;" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(143, 1)" end="(151, 9)" name="append_right_sublist_self" full_name="List.append_right_sublist_self">
      <CommandDeclmodifiersNode start="(143, 1)" end="(143, 8)">
        <NullNode/>
        <NullNode start="(143, 1)" end="(143, 8)">
          <OtherNode start="(143, 1)" end="(143, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(143, 1)" end="(143, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(143, 3)" end="(143, 7)">
              <OtherNode start="(143, 3)" end="(143, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(143, 3)" end="(143, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(143, 3)" end="(143, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(143, 7)" end="(143, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(143, 9)" end="(151, 9)" name="append_right_sublist_self" full_name="List.append_right_sublist_self" _is_private_decl="False">
        <AtomNode start="(143, 9)" end="(143, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(143, 17)" end="(143, 42)">
          <IdentNode start="(143, 17)" end="(143, 42)" leading="" trailing=" " raw_val="append_right_sublist_self" val="append_right_sublist_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(143, 43)" end="(143, 97)">
          <NullNode start="(143, 43)" end="(143, 70)">
            <TermExplicitbinderNode start="(143, 43)" end="(143, 56)">
              <AtomNode start="(143, 43)" end="(143, 44)" leading="" trailing="" val="("/>
              <NullNode start="(143, 44)" end="(143, 46)">
                <IdentNode start="(143, 44)" end="(143, 46)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(143, 47)" end="(143, 55)">
                <AtomNode start="(143, 47)" end="(143, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(143, 49)" end="(143, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(143, 49)" end="(143, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(143, 54)" end="(143, 55)">
                    <IdentNode start="(143, 54)" end="(143, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(143, 55)" end="(143, 56)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(143, 57)" end="(143, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(143, 57)" end="(143, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(143, 58)" end="(143, 60)">
                <IdentNode start="(143, 58)" end="(143, 60)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(143, 61)" end="(143, 69)">
                <AtomNode start="(143, 61)" end="(143, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(143, 63)" end="(143, 69)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(143, 63)" end="(143, 67)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(143, 68)" end="(143, 69)">
                    <IdentNode start="(143, 68)" end="(143, 69)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(143, 69)" end="(143, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(143, 71)" end="(143, 97)">
            <AtomNode start="(143, 71)" end="(143, 72)" leading="" trailing=" " val=":"/>
            <OtherNode start="(143, 73)" end="(143, 97)" kind="«term_↔_»">
              <OtherNode start="(143, 73)" end="(143, 87)" kind="List.«term_&amp;lt;+_»">
                <OtherNode start="(143, 73)" end="(143, 81)" kind="«term_++_»">
                  <IdentNode start="(143, 73)" end="(143, 75)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(143, 76)" end="(143, 78)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(143, 79)" end="(143, 81)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </OtherNode>
                <AtomNode start="(143, 82)" end="(143, 84)" leading="" trailing=" " val="&amp;lt;+"/>
                <IdentNode start="(143, 85)" end="(143, 87)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </OtherNode>
              <AtomNode start="(143, 88)" end="(143, 89)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(143, 90)" end="(143, 97)" kind="«term_=_»">
                <IdentNode start="(143, 90)" end="(143, 92)" leading="" trailing=" " raw_val="ys" val="ys"/>
                <AtomNode start="(143, 93)" end="(143, 94)" leading="" trailing=" " val="="/>
                <OtherNode start="(143, 95)" end="(143, 97)" kind="«term[_]»">
                  <AtomNode start="(143, 95)" end="(143, 96)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(143, 96)" end="(143, 97)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(143, 98)" end="(151, 9)">
          <AtomNode start="(143, 98)" end="(143, 100)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(143, 101)" end="(151, 9)">
            <AtomNode start="(143, 101)" end="(143, 103)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(144, 3)" end="(151, 9)">
              <TacticTacticseq1IndentedNode start="(144, 3)" end="(151, 9)">
                <NullNode start="(144, 3)" end="(151, 9)">
                  <OtherNode start="(144, 3)" end="(144, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;xs ys : List α&#10;⊢ xs ++ ys &amp;lt;+ xs ↔ ys = []" state_after="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ xs ++ ys &amp;lt;+ xs → ys = []&#10;&#10;case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ ys = [] → xs ++ ys &amp;lt;+ xs" tactic="constructor">
                    <AtomNode start="(144, 3)" end="(144, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(145, 3)" end="(149, 13)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ xs ++ ys &amp;lt;+ xs → ys = []&#10;&#10;case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ ys = [] → xs ++ ys &amp;lt;+ xs" state_after="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ ys = [] → xs ++ ys &amp;lt;+ xs" tactic="· intro h&#10;  replace h := h.length_le&#10;  simp only [length_append] at h&#10;  have : ys.length = 0 := by omega&#10;  simp_all">
                    <OtherNode start="(145, 3)" end="(145, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(145, 3)" end="(145, 4)" kind="patternIgnore">
                        <OtherNode start="(145, 3)" end="(145, 4)" kind="token.«· »">
                          <AtomNode start="(145, 3)" end="(145, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(145, 5)" end="(149, 13)">
                      <TacticTacticseq1IndentedNode start="(145, 5)" end="(149, 13)">
                        <NullNode start="(145, 5)" end="(149, 13)">
                          <OtherNode start="(145, 5)" end="(145, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ xs ++ ys &amp;lt;+ xs → ys = []" state_after="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs ++ ys &amp;lt;+ xs&#10;⊢ ys = []" tactic="intro h">
                            <AtomNode start="(145, 5)" end="(145, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(145, 11)" end="(145, 12)">
                              <IdentNode start="(145, 11)" end="(145, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(146, 5)" end="(146, 29)" kind="Lean.Parser.Tactic.replace" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs ++ ys &amp;lt;+ xs&#10;⊢ ys = []" state_after="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : (xs ++ ys).length ≤ xs.length&#10;⊢ ys = []" tactic="replace h := h.length_le">
                            <AtomNode start="(146, 5)" end="(146, 12)" leading="" trailing=" " val="replace"/>
                            <OtherNode start="(146, 13)" end="(146, 29)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(146, 13)" end="(146, 29)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(146, 13)" end="(146, 14)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(146, 13)" end="(146, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(146, 15)" end="(146, 17)" leading="" trailing=" " val=":="/>
                                <IdentNode start="(146, 18)" end="(146, 29)" leading="" trailing="&#10;    " raw_val="h.length_le" val="h.length_le"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(147, 5)" end="(147, 35)" kind="Lean.Parser.Tactic.simp" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : (xs ++ ys).length ≤ xs.length&#10;⊢ ys = []" state_after="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs.length + ys.length ≤ xs.length&#10;⊢ ys = []" tactic="simp only [length_append] at h">
                            <AtomNode start="(147, 5)" end="(147, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(147, 10)" end="(147, 14)">
                              <AtomNode start="(147, 10)" end="(147, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(147, 15)" end="(147, 30)">
                              <AtomNode start="(147, 15)" end="(147, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(147, 16)" end="(147, 29)">
                                <OtherNode start="(147, 16)" end="(147, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(147, 16)" end="(147, 29)" leading="" trailing="" raw_val="length_append" val="length_append" full_name="List.length_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(147, 29)" end="(147, 30)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(147, 31)" end="(147, 35)">
                              <OtherNode start="(147, 31)" end="(147, 35)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(147, 31)" end="(147, 33)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(147, 34)" end="(147, 35)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(147, 34)" end="(147, 35)">
                                    <IdentNode start="(147, 34)" end="(147, 35)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(148, 5)" end="(148, 37)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs.length + ys.length ≤ xs.length&#10;⊢ ys = []" state_after="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs.length + ys.length ≤ xs.length&#10;this : ys.length = 0&#10;⊢ ys = []" tactic="have : ys.length = 0 := by omega">
                            <AtomNode start="(148, 5)" end="(148, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(148, 10)" end="(148, 37)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(148, 10)" end="(148, 37)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(148, 10)" end="(148, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(148, 10)" end="(148, 10)" kind="hygieneInfo">
                                    <IdentNode start="(148, 10)" end="(148, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(148, 10)" end="(148, 25)">
                                  <TermTypespecNode start="(148, 10)" end="(148, 25)">
                                    <AtomNode start="(148, 10)" end="(148, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(148, 12)" end="(148, 25)" kind="«term_=_»">
                                      <IdentNode start="(148, 12)" end="(148, 21)" leading="" trailing=" " raw_val="ys.length" val="ys.length"/>
                                      <AtomNode start="(148, 22)" end="(148, 23)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(148, 24)" end="(148, 25)" kind="num">
                                        <AtomNode start="(148, 24)" end="(148, 25)" leading="" trailing=" " val="0"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(148, 26)" end="(148, 28)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(148, 29)" end="(148, 37)">
                                  <AtomNode start="(148, 29)" end="(148, 31)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(148, 32)" end="(148, 37)">
                                    <TacticTacticseq1IndentedNode start="(148, 32)" end="(148, 37)">
                                      <NullNode start="(148, 32)" end="(148, 37)">
                                        <OtherNode start="(148, 32)" end="(148, 37)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;xs ys : List α&#10;h : xs.length + ys.length ≤ xs.length&#10;⊢ ys.length = 0" state_after="no goals" tactic="omega">
                                          <AtomNode start="(148, 32)" end="(148, 37)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(149, 5)" end="(149, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case mp&#10;α : Type u_1&#10;xs ys : List α&#10;h : xs.length + ys.length ≤ xs.length&#10;this : ys.length = 0&#10;⊢ ys = []" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(149, 5)" end="(149, 13)" leading="" trailing="&#10;  " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(150, 3)" end="(151, 9)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ ys = [] → xs ++ ys &amp;lt;+ xs" state_after="no goals" tactic="· rintro rfl&#10;  simp">
                    <OtherNode start="(150, 3)" end="(150, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(150, 3)" end="(150, 4)" kind="patternIgnore">
                        <OtherNode start="(150, 3)" end="(150, 4)" kind="token.«· »">
                          <AtomNode start="(150, 3)" end="(150, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(150, 5)" end="(151, 9)">
                      <TacticTacticseq1IndentedNode start="(150, 5)" end="(151, 9)">
                        <NullNode start="(150, 5)" end="(151, 9)">
                          <OtherNode start="(150, 5)" end="(150, 15)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;xs ys : List α&#10;⊢ ys = [] → xs ++ ys &amp;lt;+ xs" state_after="case mpr&#10;α : Type u_1&#10;xs : List α&#10;⊢ xs ++ [] &amp;lt;+ xs" tactic="rintro rfl">
                            <AtomNode start="(150, 5)" end="(150, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(150, 12)" end="(150, 15)">
                              <OtherNode start="(150, 12)" end="(150, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(150, 12)" end="(150, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(150, 12)" end="(150, 15)" leading="" trailing="&#10;    " raw_val="rfl" val="rfl"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(151, 5)" end="(151, 9)" kind="Lean.Parser.Tactic.simp" state_before="case mpr&#10;α : Type u_1&#10;xs : List α&#10;⊢ xs ++ [] &amp;lt;+ xs" state_after="no goals" tactic="simp">
                            <AtomNode start="(151, 5)" end="(151, 9)" leading="" trailing="&#10;&#10;" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(153, 1)" end="(164, 9)" name="append_sublist_of_sublist_left" full_name="List.append_sublist_of_sublist_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(153, 1)" end="(164, 9)" name="append_sublist_of_sublist_left" full_name="List.append_sublist_of_sublist_left" _is_private_decl="False">
        <AtomNode start="(153, 1)" end="(153, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(153, 9)" end="(153, 39)">
          <IdentNode start="(153, 9)" end="(153, 39)" leading="" trailing=" " raw_val="append_sublist_of_sublist_left" val="append_sublist_of_sublist_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(153, 40)" end="(154, 39)">
          <NullNode start="(153, 40)" end="(153, 74)">
            <OtherNode start="(153, 40)" end="(153, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(153, 40)" end="(153, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(153, 41)" end="(153, 49)">
                <IdentNode start="(153, 41)" end="(153, 43)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(153, 44)" end="(153, 46)" leading="" trailing=" " raw_val="ys" val="ys"/>
                <IdentNode start="(153, 47)" end="(153, 49)" leading="" trailing=" " raw_val="zs" val="zs"/>
              </NullNode>
              <NullNode start="(153, 50)" end="(153, 58)">
                <AtomNode start="(153, 50)" end="(153, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(153, 52)" end="(153, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(153, 52)" end="(153, 56)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(153, 57)" end="(153, 58)">
                    <IdentNode start="(153, 57)" end="(153, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(153, 58)" end="(153, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(153, 60)" end="(153, 74)">
              <AtomNode start="(153, 60)" end="(153, 61)" leading="" trailing="" val="("/>
              <NullNode start="(153, 61)" end="(153, 62)">
                <IdentNode start="(153, 61)" end="(153, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(153, 63)" end="(153, 73)">
                <AtomNode start="(153, 63)" end="(153, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(153, 65)" end="(153, 73)" kind="List.«term_&amp;lt;+_»">
                  <IdentNode start="(153, 65)" end="(153, 67)" leading="" trailing=" " raw_val="zs" val="zs"/>
                  <AtomNode start="(153, 68)" end="(153, 70)" leading="" trailing=" " val="&amp;lt;+"/>
                  <IdentNode start="(153, 71)" end="(153, 73)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(153, 73)" end="(153, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(153, 75)" end="(154, 39)">
            <AtomNode start="(153, 75)" end="(153, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(154, 5)" end="(154, 39)" kind="«term_↔_»">
              <OtherNode start="(154, 5)" end="(154, 19)" kind="List.«term_&amp;lt;+_»">
                <OtherNode start="(154, 5)" end="(154, 13)" kind="«term_++_»">
                  <IdentNode start="(154, 5)" end="(154, 7)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(154, 8)" end="(154, 10)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(154, 11)" end="(154, 13)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </OtherNode>
                <AtomNode start="(154, 14)" end="(154, 16)" leading="" trailing=" " val="&amp;lt;+"/>
                <IdentNode start="(154, 17)" end="(154, 19)" leading="" trailing=" " raw_val="zs" val="zs"/>
              </OtherNode>
              <AtomNode start="(154, 20)" end="(154, 21)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(154, 22)" end="(154, 39)" kind="«term_∧_»">
                <OtherNode start="(154, 22)" end="(154, 29)" kind="«term_=_»">
                  <IdentNode start="(154, 22)" end="(154, 24)" leading="" trailing=" " raw_val="ys" val="ys"/>
                  <AtomNode start="(154, 25)" end="(154, 26)" leading="" trailing=" " val="="/>
                  <OtherNode start="(154, 27)" end="(154, 29)" kind="«term[_]»">
                    <AtomNode start="(154, 27)" end="(154, 28)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(154, 28)" end="(154, 29)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(154, 30)" end="(154, 31)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(154, 32)" end="(154, 39)" kind="«term_=_»">
                  <IdentNode start="(154, 32)" end="(154, 34)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(154, 35)" end="(154, 36)" leading="" trailing=" " val="="/>
                  <IdentNode start="(154, 37)" end="(154, 39)" leading="" trailing=" " raw_val="zs" val="zs"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(154, 40)" end="(164, 9)">
          <AtomNode start="(154, 40)" end="(154, 42)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(154, 43)" end="(164, 9)">
            <AtomNode start="(154, 43)" end="(154, 45)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(155, 3)" end="(164, 9)">
              <TacticTacticseq1IndentedNode start="(155, 3)" end="(164, 9)">
                <NullNode start="(155, 3)" end="(164, 9)">
                  <OtherNode start="(155, 3)" end="(155, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;⊢ xs ++ ys &amp;lt;+ zs ↔ ys = [] ∧ xs = zs" state_after="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;⊢ xs ++ ys &amp;lt;+ zs → ys = [] ∧ xs = zs&#10;&#10;case mpr&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;⊢ ys = [] ∧ xs = zs → xs ++ ys &amp;lt;+ zs" tactic="constructor">
                    <AtomNode start="(155, 3)" end="(155, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(156, 3)" end="(162, 40)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;⊢ xs ++ ys &amp;lt;+ zs → ys = [] ∧ xs = zs&#10;&#10;case mpr&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;⊢ ys = [] ∧ xs = zs → xs ++ ys &amp;lt;+ zs" state_after="case mpr&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;⊢ ys = [] ∧ xs = zs → xs ++ ys &amp;lt;+ zs" tactic="· intro h'&#10;  have hl := h.length_le&#10;  have hl' := h'.length_le&#10;  simp only [length_append] at hl'&#10;  have : ys.length = 0 := by omega&#10;  simp_all only [Nat.add_zero, length_eq_zero_iff, true_and, append_nil]&#10;  exact Sublist.eq_of_length_le h' hl">
                    <OtherNode start="(156, 3)" end="(156, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(156, 3)" end="(156, 4)" kind="patternIgnore">
                        <OtherNode start="(156, 3)" end="(156, 4)" kind="token.«· »">
                          <AtomNode start="(156, 3)" end="(156, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(156, 5)" end="(162, 40)">
                      <TacticTacticseq1IndentedNode start="(156, 5)" end="(162, 40)">
                        <NullNode start="(156, 5)" end="(162, 40)">
                          <OtherNode start="(156, 5)" end="(156, 13)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;⊢ xs ++ ys &amp;lt;+ zs → ys = [] ∧ xs = zs" state_after="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;h' : xs ++ ys &amp;lt;+ zs&#10;⊢ ys = [] ∧ xs = zs" tactic="intro h'">
                            <AtomNode start="(156, 5)" end="(156, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(156, 11)" end="(156, 13)">
                              <IdentNode start="(156, 11)" end="(156, 13)" leading="" trailing="&#10;    " raw_val="h'" val="h'"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(157, 5)" end="(157, 27)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;h' : xs ++ ys &amp;lt;+ zs&#10;⊢ ys = [] ∧ xs = zs" state_after="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ xs.length&#10;⊢ ys = [] ∧ xs = zs" tactic="have hl := h.length_le">
                            <AtomNode start="(157, 5)" end="(157, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(157, 10)" end="(157, 27)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(157, 10)" end="(157, 27)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(157, 10)" end="(157, 12)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(157, 10)" end="(157, 12)" leading="" trailing=" " raw_val="hl" val="hl"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(157, 13)" end="(157, 15)" leading="" trailing=" " val=":="/>
                                <IdentNode start="(157, 16)" end="(157, 27)" leading="" trailing="&#10;    " raw_val="h.length_le" val="h.length_le"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(158, 5)" end="(158, 29)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ xs.length&#10;⊢ ys = [] ∧ xs = zs" state_after="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ xs.length&#10;hl' : (xs ++ ys).length ≤ zs.length&#10;⊢ ys = [] ∧ xs = zs" tactic="have hl' := h'.length_le">
                            <AtomNode start="(158, 5)" end="(158, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(158, 10)" end="(158, 29)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(158, 10)" end="(158, 29)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(158, 10)" end="(158, 13)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(158, 10)" end="(158, 13)" leading="" trailing=" " raw_val="hl'" val="hl'"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(158, 14)" end="(158, 16)" leading="" trailing=" " val=":="/>
                                <IdentNode start="(158, 17)" end="(158, 29)" leading="" trailing="&#10;    " raw_val="h'.length_le" val="h'.length_le"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(159, 5)" end="(159, 37)" kind="Lean.Parser.Tactic.simp" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ xs.length&#10;hl' : (xs ++ ys).length ≤ zs.length&#10;⊢ ys = [] ∧ xs = zs" state_after="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ xs.length&#10;hl' : xs.length + ys.length ≤ zs.length&#10;⊢ ys = [] ∧ xs = zs" tactic="simp only [length_append] at hl'">
                            <AtomNode start="(159, 5)" end="(159, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(159, 10)" end="(159, 14)">
                              <AtomNode start="(159, 10)" end="(159, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(159, 15)" end="(159, 30)">
                              <AtomNode start="(159, 15)" end="(159, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(159, 16)" end="(159, 29)">
                                <OtherNode start="(159, 16)" end="(159, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(159, 16)" end="(159, 29)" leading="" trailing="" raw_val="length_append" val="length_append" full_name="List.length_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(159, 29)" end="(159, 30)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(159, 31)" end="(159, 37)">
                              <OtherNode start="(159, 31)" end="(159, 37)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(159, 31)" end="(159, 33)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(159, 34)" end="(159, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(159, 34)" end="(159, 37)">
                                    <IdentNode start="(159, 34)" end="(159, 37)" leading="" trailing="&#10;    " raw_val="hl'" val="hl'"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(160, 5)" end="(160, 37)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ xs.length&#10;hl' : xs.length + ys.length ≤ zs.length&#10;⊢ ys = [] ∧ xs = zs" state_after="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ xs.length&#10;hl' : xs.length + ys.length ≤ zs.length&#10;this : ys.length = 0&#10;⊢ ys = [] ∧ xs = zs" tactic="have : ys.length = 0 := by omega">
                            <AtomNode start="(160, 5)" end="(160, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(160, 10)" end="(160, 37)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(160, 10)" end="(160, 37)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(160, 10)" end="(160, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(160, 10)" end="(160, 10)" kind="hygieneInfo">
                                    <IdentNode start="(160, 10)" end="(160, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(160, 10)" end="(160, 25)">
                                  <TermTypespecNode start="(160, 10)" end="(160, 25)">
                                    <AtomNode start="(160, 10)" end="(160, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(160, 12)" end="(160, 25)" kind="«term_=_»">
                                      <IdentNode start="(160, 12)" end="(160, 21)" leading="" trailing=" " raw_val="ys.length" val="ys.length"/>
                                      <AtomNode start="(160, 22)" end="(160, 23)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(160, 24)" end="(160, 25)" kind="num">
                                        <AtomNode start="(160, 24)" end="(160, 25)" leading="" trailing=" " val="0"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(160, 26)" end="(160, 28)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(160, 29)" end="(160, 37)">
                                  <AtomNode start="(160, 29)" end="(160, 31)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(160, 32)" end="(160, 37)">
                                    <TacticTacticseq1IndentedNode start="(160, 32)" end="(160, 37)">
                                      <NullNode start="(160, 32)" end="(160, 37)">
                                        <OtherNode start="(160, 32)" end="(160, 37)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ xs.length&#10;hl' : xs.length + ys.length ≤ zs.length&#10;⊢ ys.length = 0" state_after="no goals" tactic="omega">
                                          <AtomNode start="(160, 32)" end="(160, 37)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(161, 5)" end="(161, 75)" kind="Lean.Parser.Tactic.simpAll" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ xs.length&#10;hl' : xs.length + ys.length ≤ zs.length&#10;this : ys.length = 0&#10;⊢ ys = [] ∧ xs = zs" state_after="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;h' : xs &amp;lt;+ zs&#10;hl : zs.length ≤ xs.length&#10;hl' : xs.length ≤ zs.length&#10;this : ys = []&#10;⊢ xs = zs" tactic="simp_all only [Nat.add_zero, length_eq_zero_iff, true_and, append_nil]">
                            <AtomNode start="(161, 5)" end="(161, 13)" leading="" trailing=" " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(161, 14)" end="(161, 18)">
                              <AtomNode start="(161, 14)" end="(161, 18)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(161, 19)" end="(161, 75)">
                              <AtomNode start="(161, 19)" end="(161, 20)" leading="" trailing="" val="["/>
                              <NullNode start="(161, 20)" end="(161, 74)">
                                <OtherNode start="(161, 20)" end="(161, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(161, 20)" end="(161, 32)" leading="" trailing="" raw_val="Nat.add_zero" val="Nat.add_zero" full_name="Nat.add_zero" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                                <AtomNode start="(161, 32)" end="(161, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(161, 34)" end="(161, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(161, 34)" end="(161, 52)" leading="" trailing="" raw_val="length_eq_zero_iff" val="length_eq_zero_iff" full_name="List.length_eq_zero_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(161, 52)" end="(161, 53)" leading="" trailing=" " val=","/>
                                <OtherNode start="(161, 54)" end="(161, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(161, 54)" end="(161, 62)" leading="" trailing="" raw_val="true_and" val="true_and" full_name="true_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(161, 62)" end="(161, 63)" leading="" trailing=" " val=","/>
                                <OtherNode start="(161, 64)" end="(161, 74)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(161, 64)" end="(161, 74)" leading="" trailing="" raw_val="append_nil" val="append_nil" full_name="List.append_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(161, 74)" end="(161, 75)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(162, 5)" end="(162, 40)" kind="Lean.Parser.Tactic.exact" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;h' : xs &amp;lt;+ zs&#10;hl : zs.length ≤ xs.length&#10;hl' : xs.length ≤ zs.length&#10;this : ys = []&#10;⊢ xs = zs" state_after="no goals" tactic="exact Sublist.eq_of_length_le h' hl">
                            <AtomNode start="(162, 5)" end="(162, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(162, 11)" end="(162, 40)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(162, 11)" end="(162, 34)" leading="" trailing=" " raw_val="Sublist.eq_of_length_le" val="Sublist.eq_of_length_le" full_name="List.Sublist.eq_of_length_le" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                              <NullNode start="(162, 35)" end="(162, 40)">
                                <IdentNode start="(162, 35)" end="(162, 37)" leading="" trailing=" " raw_val="h'" val="h'"/>
                                <IdentNode start="(162, 38)" end="(162, 40)" leading="" trailing="&#10;  " raw_val="hl" val="hl"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(163, 3)" end="(164, 9)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;⊢ ys = [] ∧ xs = zs → xs ++ ys &amp;lt;+ zs" state_after="no goals" tactic="· rintro ⟨rfl, rfl⟩&#10;  simp">
                    <OtherNode start="(163, 3)" end="(163, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(163, 3)" end="(163, 4)" kind="patternIgnore">
                        <OtherNode start="(163, 3)" end="(163, 4)" kind="token.«· »">
                          <AtomNode start="(163, 3)" end="(163, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(163, 5)" end="(164, 9)">
                      <TacticTacticseq1IndentedNode start="(163, 5)" end="(164, 9)">
                        <NullNode start="(163, 5)" end="(164, 9)">
                          <OtherNode start="(163, 5)" end="(163, 22)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ xs&#10;⊢ ys = [] ∧ xs = zs → xs ++ ys &amp;lt;+ zs" state_after="case mpr.intro&#10;α : Type u_1&#10;xs : List α&#10;h : xs &amp;lt;+ xs&#10;⊢ xs ++ [] &amp;lt;+ xs" tactic="rintro ⟨rfl, rfl⟩">
                            <AtomNode start="(163, 5)" end="(163, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(163, 12)" end="(163, 22)">
                              <OtherNode start="(163, 12)" end="(163, 22)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(163, 12)" end="(163, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(163, 12)" end="(163, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(163, 13)" end="(163, 21)">
                                    <OtherNode start="(163, 13)" end="(163, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(163, 13)" end="(163, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(163, 13)" end="(163, 16)">
                                          <OtherNode start="(163, 13)" end="(163, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(163, 13)" end="(163, 16)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(163, 16)" end="(163, 17)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(163, 18)" end="(163, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(163, 18)" end="(163, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(163, 18)" end="(163, 21)">
                                          <OtherNode start="(163, 18)" end="(163, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(163, 18)" end="(163, 21)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(163, 21)" end="(163, 22)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(164, 5)" end="(164, 9)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.intro&#10;α : Type u_1&#10;xs : List α&#10;h : xs &amp;lt;+ xs&#10;⊢ xs ++ [] &amp;lt;+ xs" state_after="no goals" tactic="simp">
                            <AtomNode start="(164, 5)" end="(164, 9)" leading="" trailing="&#10;&#10;" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(166, 1)" end="(177, 9)" name="append_sublist_of_sublist_right" full_name="List.append_sublist_of_sublist_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(166, 1)" end="(177, 9)" name="append_sublist_of_sublist_right" full_name="List.append_sublist_of_sublist_right" _is_private_decl="False">
        <AtomNode start="(166, 1)" end="(166, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(166, 9)" end="(166, 40)">
          <IdentNode start="(166, 9)" end="(166, 40)" leading="" trailing=" " raw_val="append_sublist_of_sublist_right" val="append_sublist_of_sublist_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(166, 41)" end="(167, 39)">
          <NullNode start="(166, 41)" end="(166, 75)">
            <OtherNode start="(166, 41)" end="(166, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(166, 41)" end="(166, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(166, 42)" end="(166, 50)">
                <IdentNode start="(166, 42)" end="(166, 44)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(166, 45)" end="(166, 47)" leading="" trailing=" " raw_val="ys" val="ys"/>
                <IdentNode start="(166, 48)" end="(166, 50)" leading="" trailing=" " raw_val="zs" val="zs"/>
              </NullNode>
              <NullNode start="(166, 51)" end="(166, 59)">
                <AtomNode start="(166, 51)" end="(166, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(166, 53)" end="(166, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(166, 53)" end="(166, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(166, 58)" end="(166, 59)">
                    <IdentNode start="(166, 58)" end="(166, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(166, 59)" end="(166, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(166, 61)" end="(166, 75)">
              <AtomNode start="(166, 61)" end="(166, 62)" leading="" trailing="" val="("/>
              <NullNode start="(166, 62)" end="(166, 63)">
                <IdentNode start="(166, 62)" end="(166, 63)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(166, 64)" end="(166, 74)">
                <AtomNode start="(166, 64)" end="(166, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(166, 66)" end="(166, 74)" kind="List.«term_&amp;lt;+_»">
                  <IdentNode start="(166, 66)" end="(166, 68)" leading="" trailing=" " raw_val="zs" val="zs"/>
                  <AtomNode start="(166, 69)" end="(166, 71)" leading="" trailing=" " val="&amp;lt;+"/>
                  <IdentNode start="(166, 72)" end="(166, 74)" leading="" trailing="" raw_val="ys" val="ys"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(166, 74)" end="(166, 75)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(166, 76)" end="(167, 39)">
            <AtomNode start="(166, 76)" end="(166, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(167, 5)" end="(167, 39)" kind="«term_↔_»">
              <OtherNode start="(167, 5)" end="(167, 19)" kind="List.«term_&amp;lt;+_»">
                <OtherNode start="(167, 5)" end="(167, 13)" kind="«term_++_»">
                  <IdentNode start="(167, 5)" end="(167, 7)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(167, 8)" end="(167, 10)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(167, 11)" end="(167, 13)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </OtherNode>
                <AtomNode start="(167, 14)" end="(167, 16)" leading="" trailing=" " val="&amp;lt;+"/>
                <IdentNode start="(167, 17)" end="(167, 19)" leading="" trailing=" " raw_val="zs" val="zs"/>
              </OtherNode>
              <AtomNode start="(167, 20)" end="(167, 21)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(167, 22)" end="(167, 39)" kind="«term_∧_»">
                <OtherNode start="(167, 22)" end="(167, 29)" kind="«term_=_»">
                  <IdentNode start="(167, 22)" end="(167, 24)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(167, 25)" end="(167, 26)" leading="" trailing=" " val="="/>
                  <OtherNode start="(167, 27)" end="(167, 29)" kind="«term[_]»">
                    <AtomNode start="(167, 27)" end="(167, 28)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(167, 28)" end="(167, 29)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(167, 30)" end="(167, 31)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(167, 32)" end="(167, 39)" kind="«term_=_»">
                  <IdentNode start="(167, 32)" end="(167, 34)" leading="" trailing=" " raw_val="ys" val="ys"/>
                  <AtomNode start="(167, 35)" end="(167, 36)" leading="" trailing=" " val="="/>
                  <IdentNode start="(167, 37)" end="(167, 39)" leading="" trailing=" " raw_val="zs" val="zs"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(167, 40)" end="(177, 9)">
          <AtomNode start="(167, 40)" end="(167, 42)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(167, 43)" end="(177, 9)">
            <AtomNode start="(167, 43)" end="(167, 45)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(168, 3)" end="(177, 9)">
              <TacticTacticseq1IndentedNode start="(168, 3)" end="(177, 9)">
                <NullNode start="(168, 3)" end="(177, 9)">
                  <OtherNode start="(168, 3)" end="(168, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;⊢ xs ++ ys &amp;lt;+ zs ↔ xs = [] ∧ ys = zs" state_after="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;⊢ xs ++ ys &amp;lt;+ zs → xs = [] ∧ ys = zs&#10;&#10;case mpr&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;⊢ xs = [] ∧ ys = zs → xs ++ ys &amp;lt;+ zs" tactic="constructor">
                    <AtomNode start="(168, 3)" end="(168, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(169, 3)" end="(175, 40)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;⊢ xs ++ ys &amp;lt;+ zs → xs = [] ∧ ys = zs&#10;&#10;case mpr&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;⊢ xs = [] ∧ ys = zs → xs ++ ys &amp;lt;+ zs" state_after="case mpr&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;⊢ xs = [] ∧ ys = zs → xs ++ ys &amp;lt;+ zs" tactic="· intro h'&#10;  have hl := h.length_le&#10;  have hl' := h'.length_le&#10;  simp only [length_append] at hl'&#10;  have : xs.length = 0 := by omega&#10;  simp_all only [Nat.zero_add, length_eq_zero_iff, true_and, append_nil]&#10;  exact Sublist.eq_of_length_le h' hl">
                    <OtherNode start="(169, 3)" end="(169, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(169, 3)" end="(169, 4)" kind="patternIgnore">
                        <OtherNode start="(169, 3)" end="(169, 4)" kind="token.«· »">
                          <AtomNode start="(169, 3)" end="(169, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(169, 5)" end="(175, 40)">
                      <TacticTacticseq1IndentedNode start="(169, 5)" end="(175, 40)">
                        <NullNode start="(169, 5)" end="(175, 40)">
                          <OtherNode start="(169, 5)" end="(169, 13)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;⊢ xs ++ ys &amp;lt;+ zs → xs = [] ∧ ys = zs" state_after="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;h' : xs ++ ys &amp;lt;+ zs&#10;⊢ xs = [] ∧ ys = zs" tactic="intro h'">
                            <AtomNode start="(169, 5)" end="(169, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(169, 11)" end="(169, 13)">
                              <IdentNode start="(169, 11)" end="(169, 13)" leading="" trailing="&#10;    " raw_val="h'" val="h'"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(170, 5)" end="(170, 27)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;h' : xs ++ ys &amp;lt;+ zs&#10;⊢ xs = [] ∧ ys = zs" state_after="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ ys.length&#10;⊢ xs = [] ∧ ys = zs" tactic="have hl := h.length_le">
                            <AtomNode start="(170, 5)" end="(170, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(170, 10)" end="(170, 27)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(170, 10)" end="(170, 27)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(170, 10)" end="(170, 12)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(170, 10)" end="(170, 12)" leading="" trailing=" " raw_val="hl" val="hl"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(170, 13)" end="(170, 15)" leading="" trailing=" " val=":="/>
                                <IdentNode start="(170, 16)" end="(170, 27)" leading="" trailing="&#10;    " raw_val="h.length_le" val="h.length_le"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(171, 5)" end="(171, 29)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ ys.length&#10;⊢ xs = [] ∧ ys = zs" state_after="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ ys.length&#10;hl' : (xs ++ ys).length ≤ zs.length&#10;⊢ xs = [] ∧ ys = zs" tactic="have hl' := h'.length_le">
                            <AtomNode start="(171, 5)" end="(171, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(171, 10)" end="(171, 29)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(171, 10)" end="(171, 29)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(171, 10)" end="(171, 13)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(171, 10)" end="(171, 13)" leading="" trailing=" " raw_val="hl'" val="hl'"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(171, 14)" end="(171, 16)" leading="" trailing=" " val=":="/>
                                <IdentNode start="(171, 17)" end="(171, 29)" leading="" trailing="&#10;    " raw_val="h'.length_le" val="h'.length_le"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(172, 5)" end="(172, 37)" kind="Lean.Parser.Tactic.simp" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ ys.length&#10;hl' : (xs ++ ys).length ≤ zs.length&#10;⊢ xs = [] ∧ ys = zs" state_after="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ ys.length&#10;hl' : xs.length + ys.length ≤ zs.length&#10;⊢ xs = [] ∧ ys = zs" tactic="simp only [length_append] at hl'">
                            <AtomNode start="(172, 5)" end="(172, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(172, 10)" end="(172, 14)">
                              <AtomNode start="(172, 10)" end="(172, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(172, 15)" end="(172, 30)">
                              <AtomNode start="(172, 15)" end="(172, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(172, 16)" end="(172, 29)">
                                <OtherNode start="(172, 16)" end="(172, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(172, 16)" end="(172, 29)" leading="" trailing="" raw_val="length_append" val="length_append" full_name="List.length_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(172, 29)" end="(172, 30)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(172, 31)" end="(172, 37)">
                              <OtherNode start="(172, 31)" end="(172, 37)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(172, 31)" end="(172, 33)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(172, 34)" end="(172, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(172, 34)" end="(172, 37)">
                                    <IdentNode start="(172, 34)" end="(172, 37)" leading="" trailing="&#10;    " raw_val="hl'" val="hl'"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(173, 5)" end="(173, 37)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ ys.length&#10;hl' : xs.length + ys.length ≤ zs.length&#10;⊢ xs = [] ∧ ys = zs" state_after="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ ys.length&#10;hl' : xs.length + ys.length ≤ zs.length&#10;this : xs.length = 0&#10;⊢ xs = [] ∧ ys = zs" tactic="have : xs.length = 0 := by omega">
                            <AtomNode start="(173, 5)" end="(173, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(173, 10)" end="(173, 37)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(173, 10)" end="(173, 37)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(173, 10)" end="(173, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(173, 10)" end="(173, 10)" kind="hygieneInfo">
                                    <IdentNode start="(173, 10)" end="(173, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(173, 10)" end="(173, 25)">
                                  <TermTypespecNode start="(173, 10)" end="(173, 25)">
                                    <AtomNode start="(173, 10)" end="(173, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(173, 12)" end="(173, 25)" kind="«term_=_»">
                                      <IdentNode start="(173, 12)" end="(173, 21)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
                                      <AtomNode start="(173, 22)" end="(173, 23)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(173, 24)" end="(173, 25)" kind="num">
                                        <AtomNode start="(173, 24)" end="(173, 25)" leading="" trailing=" " val="0"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(173, 26)" end="(173, 28)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(173, 29)" end="(173, 37)">
                                  <AtomNode start="(173, 29)" end="(173, 31)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(173, 32)" end="(173, 37)">
                                    <TacticTacticseq1IndentedNode start="(173, 32)" end="(173, 37)">
                                      <NullNode start="(173, 32)" end="(173, 37)">
                                        <OtherNode start="(173, 32)" end="(173, 37)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ ys.length&#10;hl' : xs.length + ys.length ≤ zs.length&#10;⊢ xs.length = 0" state_after="no goals" tactic="omega">
                                          <AtomNode start="(173, 32)" end="(173, 37)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(174, 5)" end="(174, 75)" kind="Lean.Parser.Tactic.simpAll" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;h' : xs ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ ys.length&#10;hl' : xs.length + ys.length ≤ zs.length&#10;this : xs.length = 0&#10;⊢ xs = [] ∧ ys = zs" state_after="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;h' : [] ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ ys.length&#10;hl' : ys.length ≤ zs.length&#10;this : xs = []&#10;⊢ ys = zs" tactic="simp_all only [Nat.zero_add, length_eq_zero_iff, true_and, append_nil]">
                            <AtomNode start="(174, 5)" end="(174, 13)" leading="" trailing=" " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(174, 14)" end="(174, 18)">
                              <AtomNode start="(174, 14)" end="(174, 18)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(174, 19)" end="(174, 75)">
                              <AtomNode start="(174, 19)" end="(174, 20)" leading="" trailing="" val="["/>
                              <NullNode start="(174, 20)" end="(174, 74)">
                                <OtherNode start="(174, 20)" end="(174, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(174, 20)" end="(174, 32)" leading="" trailing="" raw_val="Nat.zero_add" val="Nat.zero_add" full_name="Nat.zero_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(174, 32)" end="(174, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(174, 34)" end="(174, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(174, 34)" end="(174, 52)" leading="" trailing="" raw_val="length_eq_zero_iff" val="length_eq_zero_iff" full_name="List.length_eq_zero_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(174, 52)" end="(174, 53)" leading="" trailing=" " val=","/>
                                <OtherNode start="(174, 54)" end="(174, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(174, 54)" end="(174, 62)" leading="" trailing="" raw_val="true_and" val="true_and" full_name="true_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(174, 62)" end="(174, 63)" leading="" trailing=" " val=","/>
                                <OtherNode start="(174, 64)" end="(174, 74)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(174, 64)" end="(174, 74)" leading="" trailing="" raw_val="append_nil" val="append_nil" full_name="List.append_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(174, 74)" end="(174, 75)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(175, 5)" end="(175, 40)" kind="Lean.Parser.Tactic.exact" state_before="case mp&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;h' : [] ++ ys &amp;lt;+ zs&#10;hl : zs.length ≤ ys.length&#10;hl' : ys.length ≤ zs.length&#10;this : xs = []&#10;⊢ ys = zs" state_after="no goals" tactic="exact Sublist.eq_of_length_le h' hl">
                            <AtomNode start="(175, 5)" end="(175, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(175, 11)" end="(175, 40)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(175, 11)" end="(175, 34)" leading="" trailing=" " raw_val="Sublist.eq_of_length_le" val="Sublist.eq_of_length_le" full_name="List.Sublist.eq_of_length_le" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                              <NullNode start="(175, 35)" end="(175, 40)">
                                <IdentNode start="(175, 35)" end="(175, 37)" leading="" trailing=" " raw_val="h'" val="h'"/>
                                <IdentNode start="(175, 38)" end="(175, 40)" leading="" trailing="&#10;  " raw_val="hl" val="hl"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(176, 3)" end="(177, 9)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;⊢ xs = [] ∧ ys = zs → xs ++ ys &amp;lt;+ zs" state_after="no goals" tactic="· rintro ⟨rfl, rfl⟩&#10;  simp">
                    <OtherNode start="(176, 3)" end="(176, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(176, 3)" end="(176, 4)" kind="patternIgnore">
                        <OtherNode start="(176, 3)" end="(176, 4)" kind="token.«· »">
                          <AtomNode start="(176, 3)" end="(176, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(176, 5)" end="(177, 9)">
                      <TacticTacticseq1IndentedNode start="(176, 5)" end="(177, 9)">
                        <NullNode start="(176, 5)" end="(177, 9)">
                          <OtherNode start="(176, 5)" end="(176, 22)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;xs ys zs : List α&#10;h : zs &amp;lt;+ ys&#10;⊢ xs = [] ∧ ys = zs → xs ++ ys &amp;lt;+ zs" state_after="case mpr.intro&#10;α : Type u_1&#10;ys : List α&#10;h : ys &amp;lt;+ ys&#10;⊢ [] ++ ys &amp;lt;+ ys" tactic="rintro ⟨rfl, rfl⟩">
                            <AtomNode start="(176, 5)" end="(176, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(176, 12)" end="(176, 22)">
                              <OtherNode start="(176, 12)" end="(176, 22)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(176, 12)" end="(176, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(176, 12)" end="(176, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(176, 13)" end="(176, 21)">
                                    <OtherNode start="(176, 13)" end="(176, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(176, 13)" end="(176, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(176, 13)" end="(176, 16)">
                                          <OtherNode start="(176, 13)" end="(176, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(176, 13)" end="(176, 16)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(176, 16)" end="(176, 17)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(176, 18)" end="(176, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(176, 18)" end="(176, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(176, 18)" end="(176, 21)">
                                          <OtherNode start="(176, 18)" end="(176, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(176, 18)" end="(176, 21)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(176, 21)" end="(176, 22)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(177, 5)" end="(177, 9)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.intro&#10;α : Type u_1&#10;ys : List α&#10;h : ys &amp;lt;+ ys&#10;⊢ [] ++ ys &amp;lt;+ ys" state_after="no goals" tactic="simp">
                            <AtomNode start="(177, 5)" end="(177, 9)" leading="" trailing="&#10;&#10;" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(179, 1)" end="(179, 9)" name="List">
      <AtomNode start="(179, 1)" end="(179, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(179, 5)" end="(179, 9)">
        <IdentNode start="(179, 5)" end="(179, 9)" leading="" trailing="&#10;" raw_val="List" val="List"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(14, 1)" end="(19, 3)" text="# Further lemmas about `List.IsSuffix` / `List.IsPrefix` / `List.IsInfix`.&#10;&#10;These are in a separate file from most of the lemmas about `List.IsSuffix`&#10;as they required importing more lemmas about natural numbers, and use `omega`.&#10;-/"/>
    <Comment start="(21, 38)" end="(22, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(22, 39)" end="(24, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
  </Comments>
</TracedFile>
