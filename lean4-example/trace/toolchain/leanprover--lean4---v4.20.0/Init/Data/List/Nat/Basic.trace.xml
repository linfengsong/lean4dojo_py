<TracedFile path="src/lean/Init/Data/List/Nat/Basic.lean" md5="e2160b57666dfc4b22a3319cf886a9aa">
  <FileNode start="(1, 1)" end="(196, 9)">
    <ModuleHeaderNode start="(6, 1)" end="(12, 28)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(12, 28)">
        <ModuleImportNode start="(9, 1)" end="(9, 28)" module="Init.Data.List.Count" path="src/lean/Init/Data/List/Count.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 28)" leading="" trailing="&#10;" raw_val="Init.Data.List.Count" val="Init.Data.List.Count"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 27)" module="Init.Data.List.Find" path="src/lean/Init/Data/List/Find.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 27)" leading="" trailing="&#10;" raw_val="Init.Data.List.Find" val="Init.Data.List.Find"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 29)" module="Init.Data.List.MinMax" path="src/lean/Init/Data/List/MinMax.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 29)" leading="" trailing="&#10;" raw_val="Init.Data.List.MinMax" val="Init.Data.List.MinMax"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(12, 1)" end="(12, 28)" module="Init.Data.Nat.Lemmas" path="src/lean/Init/Data/Nat/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(12, 1)" end="(12, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(12, 8)" end="(12, 28)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.Nat.Lemmas" val="Init.Data.Nat.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(14, 1)" end="(18, 3)" comment="# Miscellaneous `List` lemmas, that require more `Nat` lemmas than are available in `Init.Data.List.Lemmas`.&#10;&#10;In particular, `omega` is available here.&#10;-/">
      <AtomNode start="(14, 1)" end="(14, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(15, 1)" end="(18, 3)" leading="" trailing="&#10;&#10;" val="# Miscellaneous `List` lemmas, that require more `Nat` lemmas than are available in `Init.Data.List.Lemmas`.&#10;&#10;In particular, `omega` is available here.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(20, 1)" end="(20, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(20, 1)" end="(20, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(20, 12)" end="(20, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(20, 33)" end="(20, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(21, 1)" end="(21, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(21, 1)" end="(21, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(21, 12)" end="(21, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(21, 34)" end="(21, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandOpenNode start="(23, 1)" end="(23, 9)">
      <AtomNode start="(23, 1)" end="(23, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(23, 6)" end="(23, 9)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(23, 6)" end="(23, 9)">
          <IdentNode start="(23, 6)" end="(23, 9)" leading="" trailing="&#10;&#10;" raw_val="Nat" val="Nat"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandNamespaceNode start="(25, 1)" end="(25, 15)" name="List">
      <AtomNode start="(25, 1)" end="(25, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(25, 11)" end="(25, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandModuledocNode start="(27, 1)" end="(27, 20)" comment="### dropLast -/">
      <AtomNode start="(27, 1)" end="(27, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(27, 5)" end="(27, 20)" leading="" trailing="&#10;&#10;" val="### dropLast -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(29, 1)" end="(36, 8)" name="tail_dropLast" full_name="List.tail_dropLast">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(29, 1)" end="(36, 8)" name="tail_dropLast" full_name="List.tail_dropLast" _is_private_decl="False">
        <AtomNode start="(29, 1)" end="(29, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(29, 9)" end="(29, 22)">
          <IdentNode start="(29, 9)" end="(29, 22)" leading="" trailing=" " raw_val="tail_dropLast" val="tail_dropLast"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(29, 23)" end="(29, 75)">
          <NullNode start="(29, 23)" end="(29, 35)">
            <OtherNode start="(29, 23)" end="(29, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(29, 23)" end="(29, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(29, 24)" end="(29, 25)">
                <IdentNode start="(29, 24)" end="(29, 25)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(29, 26)" end="(29, 34)">
                <AtomNode start="(29, 26)" end="(29, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(29, 28)" end="(29, 34)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(29, 28)" end="(29, 32)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(29, 33)" end="(29, 34)">
                    <IdentNode start="(29, 33)" end="(29, 34)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(29, 34)" end="(29, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(29, 36)" end="(29, 75)">
            <AtomNode start="(29, 36)" end="(29, 37)" leading="" trailing=" " val=":"/>
            <OtherNode start="(29, 38)" end="(29, 75)" kind="«term_=_»">
              <OtherNode start="(29, 38)" end="(29, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(29, 38)" end="(29, 42)" leading="" trailing=" " raw_val="tail" val="tail" full_name="List.tail" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(29, 43)" end="(29, 55)">
                  <OtherNode start="(29, 43)" end="(29, 55)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(29, 43)" end="(29, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(29, 44)" end="(29, 54)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(29, 44)" end="(29, 52)" leading="" trailing=" " raw_val="dropLast" val="dropLast" full_name="List.dropLast" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(29, 53)" end="(29, 54)">
                        <IdentNode start="(29, 53)" end="(29, 54)" leading="" trailing="" raw_val="l" val="l"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(29, 54)" end="(29, 55)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(29, 56)" end="(29, 57)" leading="" trailing=" " val="="/>
              <OtherNode start="(29, 58)" end="(29, 75)" kind="Lean.Parser.Term.app">
                <IdentNode start="(29, 58)" end="(29, 66)" leading="" trailing=" " raw_val="dropLast" val="dropLast" full_name="List.dropLast" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(29, 67)" end="(29, 75)">
                  <OtherNode start="(29, 67)" end="(29, 75)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(29, 67)" end="(29, 68)" leading="" trailing="" val="("/>
                    <OtherNode start="(29, 68)" end="(29, 74)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(29, 68)" end="(29, 72)" leading="" trailing=" " raw_val="tail" val="tail" full_name="List.tail" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(29, 73)" end="(29, 74)">
                        <IdentNode start="(29, 73)" end="(29, 74)" leading="" trailing="" raw_val="l" val="l"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(29, 74)" end="(29, 75)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(29, 76)" end="(36, 8)">
          <AtomNode start="(29, 76)" end="(29, 78)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(29, 79)" end="(36, 8)">
            <AtomNode start="(29, 79)" end="(29, 81)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(30, 3)" end="(36, 8)">
              <TacticTacticseq1IndentedNode start="(30, 3)" end="(36, 8)">
                <NullNode start="(30, 3)" end="(36, 8)">
                  <OtherNode start="(30, 3)" end="(30, 7)" kind="Lean.Elab.Tactic.Ext.tacticExt1___" state_before="α : Type u_1&#10;l : List α&#10;⊢ l.dropLast.tail = l.tail.dropLast" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;⊢ l.dropLast.tail[i✝]? = l.tail.dropLast[i✝]?" tactic="ext1">
                    <AtomNode start="(30, 3)" end="(30, 7)" leading="" trailing="&#10;  " val="ext1"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(31, 3)" end="(31, 60)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;⊢ l.dropLast.tail[i✝]? = l.tail.dropLast[i✝]?" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;⊢ (if i✝ + 1 &amp;lt; l.length - 1 then l[i✝ + 1]? else none) = if i✝ &amp;lt; l.length - 1 - 1 then l[i✝ + 1]? else none" tactic="simp only [getElem?_tail, getElem?_dropLast, length_tail]">
                    <AtomNode start="(31, 3)" end="(31, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(31, 8)" end="(31, 12)">
                      <AtomNode start="(31, 8)" end="(31, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(31, 13)" end="(31, 60)">
                      <AtomNode start="(31, 13)" end="(31, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(31, 14)" end="(31, 59)">
                        <OtherNode start="(31, 14)" end="(31, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(31, 14)" end="(31, 27)" leading="" trailing="" raw_val="getElem?_tail" val="getElem?_tail" full_name="List.getElem?_tail" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(31, 27)" end="(31, 28)" leading="" trailing=" " val=","/>
                        <OtherNode start="(31, 29)" end="(31, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(31, 29)" end="(31, 46)" leading="" trailing="" raw_val="getElem?_dropLast" val="getElem?_dropLast" full_name="List.getElem?_dropLast" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(31, 46)" end="(31, 47)" leading="" trailing=" " val=","/>
                        <OtherNode start="(31, 48)" end="(31, 59)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(31, 48)" end="(31, 59)" leading="" trailing="" raw_val="length_tail" val="length_tail" full_name="List.length_tail" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(31, 59)" end="(31, 60)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(32, 3)" end="(32, 18)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;⊢ (if i✝ + 1 &amp;lt; l.length - 1 then l[i✝ + 1]? else none) = if i✝ &amp;lt; l.length - 1 - 1 then l[i✝ + 1]? else none" state_after="case h.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : i✝ &amp;lt; l.length - 1 - 1&#10;⊢ l[i✝ + 1]? = l[i✝ + 1]?&#10;&#10;case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : ¬i✝ &amp;lt; l.length - 1 - 1&#10;⊢ l[i✝ + 1]? = none&#10;&#10;case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = l[i✝ + 1]?&#10;&#10;case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : ¬i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = none" tactic="split &amp;lt;;&amp;gt; split">
                    <OtherNode start="(32, 3)" end="(32, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(32, 3)" end="(32, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(32, 9)" end="(32, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(32, 13)" end="(32, 18)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(32, 13)" end="(32, 18)" leading="" trailing="&#10;  " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(33, 3)" end="(33, 8)" kind="Lean.cdot" state_before="case h.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : i✝ &amp;lt; l.length - 1 - 1&#10;⊢ l[i✝ + 1]? = l[i✝ + 1]?&#10;&#10;case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : ¬i✝ &amp;lt; l.length - 1 - 1&#10;⊢ l[i✝ + 1]? = none&#10;&#10;case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = l[i✝ + 1]?&#10;&#10;case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : ¬i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = none" state_after="case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : ¬i✝ &amp;lt; l.length - 1 - 1&#10;⊢ l[i✝ + 1]? = none&#10;&#10;case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = l[i✝ + 1]?&#10;&#10;case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : ¬i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = none" tactic="· rfl">
                    <OtherNode start="(33, 3)" end="(33, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(33, 3)" end="(33, 4)" kind="patternIgnore">
                        <OtherNode start="(33, 3)" end="(33, 4)" kind="token.«· »">
                          <AtomNode start="(33, 3)" end="(33, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(33, 5)" end="(33, 8)">
                      <TacticTacticseq1IndentedNode start="(33, 5)" end="(33, 8)">
                        <NullNode start="(33, 5)" end="(33, 8)">
                          <OtherNode start="(33, 5)" end="(33, 8)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case h.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : i✝ &amp;lt; l.length - 1 - 1&#10;⊢ l[i✝ + 1]? = l[i✝ + 1]?" state_after="no goals" tactic="rfl">
                            <AtomNode start="(33, 5)" end="(33, 8)" leading="" trailing="&#10;  " val="rfl"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(34, 3)" end="(34, 10)" kind="Lean.cdot" state_before="case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : ¬i✝ &amp;lt; l.length - 1 - 1&#10;⊢ l[i✝ + 1]? = none&#10;&#10;case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = l[i✝ + 1]?&#10;&#10;case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : ¬i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = none" state_after="case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = l[i✝ + 1]?&#10;&#10;case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : ¬i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = none" tactic="· omega">
                    <OtherNode start="(34, 3)" end="(34, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(34, 3)" end="(34, 4)" kind="patternIgnore">
                        <OtherNode start="(34, 3)" end="(34, 4)" kind="token.«· »">
                          <AtomNode start="(34, 3)" end="(34, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(34, 5)" end="(34, 10)">
                      <TacticTacticseq1IndentedNode start="(34, 5)" end="(34, 10)">
                        <NullNode start="(34, 5)" end="(34, 10)">
                          <OtherNode start="(34, 5)" end="(34, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : ¬i✝ &amp;lt; l.length - 1 - 1&#10;⊢ l[i✝ + 1]? = none" state_after="no goals" tactic="omega">
                            <AtomNode start="(34, 5)" end="(34, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(35, 3)" end="(35, 10)" kind="Lean.cdot" state_before="case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = l[i✝ + 1]?&#10;&#10;case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : ¬i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = none" state_after="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : ¬i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = none" tactic="· omega">
                    <OtherNode start="(35, 3)" end="(35, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(35, 3)" end="(35, 4)" kind="patternIgnore">
                        <OtherNode start="(35, 3)" end="(35, 4)" kind="token.«· »">
                          <AtomNode start="(35, 3)" end="(35, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(35, 5)" end="(35, 10)">
                      <TacticTacticseq1IndentedNode start="(35, 5)" end="(35, 10)">
                        <NullNode start="(35, 5)" end="(35, 10)">
                          <OtherNode start="(35, 5)" end="(35, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = l[i✝ + 1]?" state_after="no goals" tactic="omega">
                            <AtomNode start="(35, 5)" end="(35, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(36, 3)" end="(36, 8)" kind="Lean.cdot" state_before="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : ¬i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = none" state_after="no goals" tactic="· rfl">
                    <OtherNode start="(36, 3)" end="(36, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(36, 3)" end="(36, 4)" kind="patternIgnore">
                        <OtherNode start="(36, 3)" end="(36, 4)" kind="token.«· »">
                          <AtomNode start="(36, 3)" end="(36, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(36, 5)" end="(36, 8)">
                      <TacticTacticseq1IndentedNode start="(36, 5)" end="(36, 8)">
                        <NullNode start="(36, 5)" end="(36, 8)">
                          <OtherNode start="(36, 5)" end="(36, 8)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i✝ : Nat&#10;h✝¹ : ¬i✝ + 1 &amp;lt; l.length - 1&#10;h✝ : ¬i✝ &amp;lt; l.length - 1 - 1&#10;⊢ none = none" state_after="no goals" tactic="rfl">
                            <AtomNode start="(36, 5)" end="(36, 8)" leading="" trailing="&#10;&#10;" val="rfl"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(38, 1)" end="(45, 10)" name="dropLast_reverse" full_name="List.dropLast_reverse">
      <CommandDeclmodifiersNode start="(38, 1)" end="(38, 8)">
        <NullNode/>
        <NullNode start="(38, 1)" end="(38, 8)">
          <OtherNode start="(38, 1)" end="(38, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(38, 1)" end="(38, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(38, 3)" end="(38, 7)">
              <OtherNode start="(38, 3)" end="(38, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(38, 3)" end="(38, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(38, 3)" end="(38, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(38, 7)" end="(38, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(38, 9)" end="(45, 10)" name="dropLast_reverse" full_name="List.dropLast_reverse" _is_private_decl="False">
        <AtomNode start="(38, 9)" end="(38, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(38, 17)" end="(38, 33)">
          <IdentNode start="(38, 17)" end="(38, 33)" leading="" trailing=" " raw_val="dropLast_reverse" val="dropLast_reverse"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(38, 34)" end="(38, 84)">
          <NullNode start="(38, 34)" end="(38, 46)">
            <OtherNode start="(38, 34)" end="(38, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(38, 34)" end="(38, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(38, 35)" end="(38, 36)">
                <IdentNode start="(38, 35)" end="(38, 36)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(38, 37)" end="(38, 45)">
                <AtomNode start="(38, 37)" end="(38, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(38, 39)" end="(38, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(38, 39)" end="(38, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(38, 44)" end="(38, 45)">
                    <IdentNode start="(38, 44)" end="(38, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(38, 45)" end="(38, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(38, 47)" end="(38, 84)">
            <AtomNode start="(38, 47)" end="(38, 48)" leading="" trailing=" " val=":"/>
            <OtherNode start="(38, 49)" end="(38, 84)" kind="«term_=_»">
              <IdentNode start="(38, 49)" end="(38, 67)" leading="" trailing=" " raw_val="l.reverse.dropLast" val="l.reverse.dropLast"/>
              <AtomNode start="(38, 68)" end="(38, 69)" leading="" trailing=" " val="="/>
              <IdentNode start="(38, 70)" end="(38, 84)" leading="" trailing=" " raw_val="l.tail.reverse" val="l.tail.reverse"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(38, 85)" end="(45, 10)">
          <AtomNode start="(38, 85)" end="(38, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(38, 88)" end="(45, 10)">
            <AtomNode start="(38, 88)" end="(38, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(39, 3)" end="(45, 10)">
              <TacticTacticseq1IndentedNode start="(39, 3)" end="(45, 10)">
                <NullNode start="(39, 3)" end="(45, 10)">
                  <OtherNode start="(39, 3)" end="(39, 20)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;l : List α&#10;⊢ l.reverse.dropLast = l.tail.reverse" state_after="case hl&#10;α : Type u_1&#10;l : List α&#10;⊢ l.reverse.dropLast.length = l.tail.reverse.length&#10;&#10;case h&#10;α : Type u_1&#10;l : List α&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; l.reverse.dropLast.length) (h₂ : i &amp;lt; l.tail.reverse.length),&#10;    l.reverse.dropLast[i] = l.tail.reverse[i]" tactic="apply ext_getElem">
                    <AtomNode start="(39, 3)" end="(39, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(39, 9)" end="(39, 20)" leading="" trailing="&#10;  " raw_val="ext_getElem" val="ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(40, 3)" end="(40, 9)" kind="Lean.cdot" state_before="case hl&#10;α : Type u_1&#10;l : List α&#10;⊢ l.reverse.dropLast.length = l.tail.reverse.length&#10;&#10;case h&#10;α : Type u_1&#10;l : List α&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; l.reverse.dropLast.length) (h₂ : i &amp;lt; l.tail.reverse.length),&#10;    l.reverse.dropLast[i] = l.tail.reverse[i]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; l.reverse.dropLast.length) (h₂ : i &amp;lt; l.tail.reverse.length),&#10;    l.reverse.dropLast[i] = l.tail.reverse[i]" tactic="· simp">
                    <OtherNode start="(40, 3)" end="(40, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(40, 3)" end="(40, 4)" kind="patternIgnore">
                        <OtherNode start="(40, 3)" end="(40, 4)" kind="token.«· »">
                          <AtomNode start="(40, 3)" end="(40, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(40, 5)" end="(40, 9)">
                      <TacticTacticseq1IndentedNode start="(40, 5)" end="(40, 9)">
                        <NullNode start="(40, 5)" end="(40, 9)">
                          <OtherNode start="(40, 5)" end="(40, 9)" kind="Lean.Parser.Tactic.simp" state_before="case hl&#10;α : Type u_1&#10;l : List α&#10;⊢ l.reverse.dropLast.length = l.tail.reverse.length" state_after="no goals" tactic="simp">
                            <AtomNode start="(40, 5)" end="(40, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(41, 3)" end="(45, 10)" kind="Lean.cdot" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; l.reverse.dropLast.length) (h₂ : i &amp;lt; l.tail.reverse.length),&#10;    l.reverse.dropLast[i] = l.tail.reverse[i]" state_after="no goals" tactic="· intro i h₁ h₂&#10;  simp only [getElem_dropLast, getElem_reverse, length_tail, getElem_tail]&#10;  congr&#10;  simp only [length_dropLast, length_reverse, length_tail] at h₁ h₂&#10;  omega">
                    <OtherNode start="(41, 3)" end="(41, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(41, 3)" end="(41, 4)" kind="patternIgnore">
                        <OtherNode start="(41, 3)" end="(41, 4)" kind="token.«· »">
                          <AtomNode start="(41, 3)" end="(41, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(41, 5)" end="(45, 10)">
                      <TacticTacticseq1IndentedNode start="(41, 5)" end="(45, 10)">
                        <NullNode start="(41, 5)" end="(45, 10)">
                          <OtherNode start="(41, 5)" end="(41, 18)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; l.reverse.dropLast.length) (h₂ : i &amp;lt; l.tail.reverse.length),&#10;    l.reverse.dropLast[i] = l.tail.reverse[i]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l.reverse.dropLast.length&#10;h₂ : i &amp;lt; l.tail.reverse.length&#10;⊢ l.reverse.dropLast[i] = l.tail.reverse[i]" tactic="intro i h₁ h₂">
                            <AtomNode start="(41, 5)" end="(41, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(41, 11)" end="(41, 18)">
                              <IdentNode start="(41, 11)" end="(41, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                              <IdentNode start="(41, 13)" end="(41, 15)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                              <IdentNode start="(41, 16)" end="(41, 18)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(42, 5)" end="(42, 77)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l.reverse.dropLast.length&#10;h₂ : i &amp;lt; l.tail.reverse.length&#10;⊢ l.reverse.dropLast[i] = l.tail.reverse[i]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l.reverse.dropLast.length&#10;h₂ : i &amp;lt; l.tail.reverse.length&#10;⊢ l[l.length - 1 - i] = l[l.length - 1 - 1 - i + 1]" tactic="simp only [getElem_dropLast, getElem_reverse, length_tail, getElem_tail]">
                            <AtomNode start="(42, 5)" end="(42, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(42, 10)" end="(42, 14)">
                              <AtomNode start="(42, 10)" end="(42, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(42, 15)" end="(42, 77)">
                              <AtomNode start="(42, 15)" end="(42, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(42, 16)" end="(42, 76)">
                                <OtherNode start="(42, 16)" end="(42, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(42, 16)" end="(42, 32)" leading="" trailing="" raw_val="getElem_dropLast" val="getElem_dropLast" full_name="List.getElem_dropLast" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(42, 32)" end="(42, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(42, 34)" end="(42, 49)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(42, 34)" end="(42, 49)" leading="" trailing="" raw_val="getElem_reverse" val="getElem_reverse" full_name="List.getElem_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(42, 49)" end="(42, 50)" leading="" trailing=" " val=","/>
                                <OtherNode start="(42, 51)" end="(42, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(42, 51)" end="(42, 62)" leading="" trailing="" raw_val="length_tail" val="length_tail" full_name="List.length_tail" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(42, 62)" end="(42, 63)" leading="" trailing=" " val=","/>
                                <OtherNode start="(42, 64)" end="(42, 76)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(42, 64)" end="(42, 76)" leading="" trailing="" raw_val="getElem_tail" val="getElem_tail" full_name="List.getElem_tail" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(42, 76)" end="(42, 77)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(43, 5)" end="(43, 10)" kind="Lean.Parser.Tactic.congr" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l.reverse.dropLast.length&#10;h₂ : i &amp;lt; l.tail.reverse.length&#10;⊢ l[l.length - 1 - i] = l[l.length - 1 - 1 - i + 1]" state_after="case h.e_i&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l.reverse.dropLast.length&#10;h₂ : i &amp;lt; l.tail.reverse.length&#10;⊢ l.length - 1 - i = l.length - 1 - 1 - i + 1" tactic="congr">
                            <AtomNode start="(43, 5)" end="(43, 10)" leading="" trailing="&#10;    " val="congr"/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(44, 5)" end="(44, 70)" kind="Lean.Parser.Tactic.simp" state_before="case h.e_i&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h₁ : i &amp;lt; l.reverse.dropLast.length&#10;h₂ : i &amp;lt; l.tail.reverse.length&#10;⊢ l.length - 1 - i = l.length - 1 - 1 - i + 1" state_after="case h.e_i&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h₁ h₂ : i &amp;lt; l.length - 1&#10;⊢ l.length - 1 - i = l.length - 1 - 1 - i + 1" tactic="simp only [length_dropLast, length_reverse, length_tail] at h₁ h₂">
                            <AtomNode start="(44, 5)" end="(44, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(44, 10)" end="(44, 14)">
                              <AtomNode start="(44, 10)" end="(44, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(44, 15)" end="(44, 61)">
                              <AtomNode start="(44, 15)" end="(44, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(44, 16)" end="(44, 60)">
                                <OtherNode start="(44, 16)" end="(44, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(44, 16)" end="(44, 31)" leading="" trailing="" raw_val="length_dropLast" val="length_dropLast" full_name="List.length_dropLast" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(44, 31)" end="(44, 32)" leading="" trailing=" " val=","/>
                                <OtherNode start="(44, 33)" end="(44, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(44, 33)" end="(44, 47)" leading="" trailing="" raw_val="length_reverse" val="length_reverse" full_name="List.length_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(44, 47)" end="(44, 48)" leading="" trailing=" " val=","/>
                                <OtherNode start="(44, 49)" end="(44, 60)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(44, 49)" end="(44, 60)" leading="" trailing="" raw_val="length_tail" val="length_tail" full_name="List.length_tail" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(44, 60)" end="(44, 61)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(44, 62)" end="(44, 70)">
                              <OtherNode start="(44, 62)" end="(44, 70)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(44, 62)" end="(44, 64)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(44, 65)" end="(44, 70)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(44, 65)" end="(44, 70)">
                                    <IdentNode start="(44, 65)" end="(44, 67)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(44, 68)" end="(44, 70)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(45, 5)" end="(45, 10)" kind="Lean.Parser.Tactic.omega" state_before="case h.e_i&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h₁ h₂ : i &amp;lt; l.length - 1&#10;⊢ l.length - 1 - i = l.length - 1 - 1 - i + 1" state_after="no goals" tactic="omega">
                            <AtomNode start="(45, 5)" end="(45, 10)" leading="" trailing="&#10;&#10;" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(47, 1)" end="(47, 18)" comment="### filter -/">
      <AtomNode start="(47, 1)" end="(47, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(47, 5)" end="(47, 18)" leading="" trailing="&#10;&#10;" val="### filter -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(49, 1)" end="(53, 28)" name="length_filter_pos_iff" full_name="List.length_filter_pos_iff">
      <CommandDeclmodifiersNode start="(49, 1)" end="(49, 8)">
        <NullNode/>
        <NullNode start="(49, 1)" end="(49, 8)">
          <OtherNode start="(49, 1)" end="(49, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(49, 1)" end="(49, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(49, 3)" end="(49, 7)">
              <OtherNode start="(49, 3)" end="(49, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(49, 3)" end="(49, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(49, 3)" end="(49, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(49, 7)" end="(49, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(50, 1)" end="(53, 28)" name="length_filter_pos_iff" full_name="List.length_filter_pos_iff" _is_private_decl="False">
        <AtomNode start="(50, 1)" end="(50, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(50, 9)" end="(50, 30)">
          <IdentNode start="(50, 9)" end="(50, 30)" leading="" trailing=" " raw_val="length_filter_pos_iff" val="length_filter_pos_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(50, 31)" end="(51, 43)">
          <NullNode start="(50, 31)" end="(50, 58)">
            <OtherNode start="(50, 31)" end="(50, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(50, 31)" end="(50, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(50, 32)" end="(50, 33)">
                <IdentNode start="(50, 32)" end="(50, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(50, 34)" end="(50, 42)">
                <AtomNode start="(50, 34)" end="(50, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(50, 36)" end="(50, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(50, 36)" end="(50, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(50, 41)" end="(50, 42)">
                    <IdentNode start="(50, 41)" end="(50, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(50, 42)" end="(50, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(50, 44)" end="(50, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(50, 44)" end="(50, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(50, 45)" end="(50, 46)">
                <IdentNode start="(50, 45)" end="(50, 46)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(50, 47)" end="(50, 57)">
                <AtomNode start="(50, 47)" end="(50, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(50, 49)" end="(50, 57)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(50, 49)" end="(50, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(50, 51)" end="(50, 52)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(50, 53)" end="(50, 57)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(50, 57)" end="(50, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(50, 59)" end="(51, 43)">
            <AtomNode start="(50, 59)" end="(50, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(51, 5)" end="(51, 43)" kind="«term_↔_»">
              <OtherNode start="(51, 5)" end="(51, 28)" kind="«term_&amp;lt;_»">
                <OtherNode start="(51, 5)" end="(51, 6)" kind="num">
                  <AtomNode start="(51, 5)" end="(51, 6)" leading="" trailing=" " val="0"/>
                </OtherNode>
                <AtomNode start="(51, 7)" end="(51, 8)" leading="" trailing=" " val="&amp;lt;"/>
                <OtherNode start="(51, 9)" end="(51, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(51, 9)" end="(51, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(51, 9)" end="(51, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(51, 10)" end="(51, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(51, 10)" end="(51, 16)" leading="" trailing=" " raw_val="filter" val="filter" full_name="List.filter" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(51, 17)" end="(51, 20)">
                        <IdentNode start="(51, 17)" end="(51, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                        <IdentNode start="(51, 19)" end="(51, 20)" leading="" trailing="" raw_val="l" val="l"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(51, 20)" end="(51, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(51, 21)" end="(51, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(51, 22)" end="(51, 28)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(51, 29)" end="(51, 30)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(51, 31)" end="(51, 43)" kind="Lean.«term∃__,_»">
                <AtomNode start="(51, 31)" end="(51, 32)" leading="" trailing=" " val="∃"/>
                <LeanBinderidentNode start="(51, 33)" end="(51, 34)">
                  <IdentNode start="(51, 33)" end="(51, 34)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(51, 35)" end="(51, 38)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(51, 35)" end="(51, 36)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(51, 37)" end="(51, 38)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
                <AtomNode start="(51, 38)" end="(51, 39)" leading="" trailing=" " val=","/>
                <OtherNode start="(51, 40)" end="(51, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(51, 40)" end="(51, 41)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(51, 42)" end="(51, 43)">
                    <IdentNode start="(51, 42)" end="(51, 43)" leading="" trailing=" " raw_val="x" val="x"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(51, 44)" end="(53, 28)">
          <AtomNode start="(51, 44)" end="(51, 46)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(51, 47)" end="(53, 28)">
            <AtomNode start="(51, 47)" end="(51, 49)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(52, 3)" end="(53, 28)">
              <TacticTacticseq1IndentedNode start="(52, 3)" end="(53, 28)">
                <NullNode start="(52, 3)" end="(53, 28)">
                  <OtherNode start="(52, 3)" end="(53, 28)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;⊢ 0 &amp;lt; (filter p l).length ↔ ∃ x, x ∈ l ∧ p x = true" state_after="no goals" tactic="simpa [length_eq_countP_add_countP, countP_eq_length_filter] using&#10;  countP_pos_iff (p := p)">
                    <AtomNode start="(52, 3)" end="(52, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(52, 9)" end="(53, 28)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(52, 9)" end="(52, 63)">
                        <OtherNode start="(52, 9)" end="(52, 63)" kind="Lean.Parser.Tactic.simpArgs">
                          <AtomNode start="(52, 9)" end="(52, 10)" leading="" trailing="" val="["/>
                          <NullNode start="(52, 10)" end="(52, 62)">
                            <OtherNode start="(52, 10)" end="(52, 37)" kind="Lean.Parser.Tactic.simpLemma">
                              <NullNode/>
                              <NullNode/>
                              <IdentNode start="(52, 10)" end="(52, 37)" leading="" trailing="" raw_val="length_eq_countP_add_countP" val="length_eq_countP_add_countP" full_name="List.length_eq_countP_add_countP" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                            </OtherNode>
                            <AtomNode start="(52, 37)" end="(52, 38)" leading="" trailing=" " val=","/>
                            <OtherNode start="(52, 39)" end="(52, 62)" kind="Lean.Parser.Tactic.simpLemma">
                              <NullNode/>
                              <NullNode/>
                              <IdentNode start="(52, 39)" end="(52, 62)" leading="" trailing="" raw_val="countP_eq_length_filter" val="countP_eq_length_filter" full_name="List.countP_eq_length_filter" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                            </OtherNode>
                          </NullNode>
                          <AtomNode start="(52, 62)" end="(52, 63)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode start="(52, 64)" end="(53, 28)">
                        <AtomNode start="(52, 64)" end="(52, 69)" leading="" trailing="&#10;    " val="using"/>
                        <OtherNode start="(53, 5)" end="(53, 28)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(53, 5)" end="(53, 19)" leading="" trailing=" " raw_val="countP_pos_iff" val="countP_pos_iff" full_name="List.countP_pos_iff" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                          <NullNode start="(53, 20)" end="(53, 28)">
                            <OtherNode start="(53, 20)" end="(53, 28)" kind="Lean.Parser.Term.namedArgument">
                              <AtomNode start="(53, 20)" end="(53, 21)" leading="" trailing="" val="("/>
                              <IdentNode start="(53, 21)" end="(53, 22)" leading="" trailing=" " raw_val="p" val="p"/>
                              <AtomNode start="(53, 23)" end="(53, 25)" leading="" trailing=" " val=":="/>
                              <IdentNode start="(53, 26)" end="(53, 27)" leading="" trailing="" raw_val="p" val="p"/>
                              <AtomNode start="(53, 27)" end="(53, 28)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(55, 1)" end="(58, 73)" name="length_filter_lt_length_iff_exists" full_name="List.length_filter_lt_length_iff_exists">
      <CommandDeclmodifiersNode start="(55, 1)" end="(55, 8)">
        <NullNode/>
        <NullNode start="(55, 1)" end="(55, 8)">
          <OtherNode start="(55, 1)" end="(55, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(55, 1)" end="(55, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(55, 3)" end="(55, 7)">
              <OtherNode start="(55, 3)" end="(55, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(55, 3)" end="(55, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(55, 3)" end="(55, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(55, 7)" end="(55, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(56, 1)" end="(58, 73)" name="length_filter_lt_length_iff_exists" full_name="List.length_filter_lt_length_iff_exists" _is_private_decl="False">
        <AtomNode start="(56, 1)" end="(56, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(56, 9)" end="(56, 43)">
          <IdentNode start="(56, 9)" end="(56, 43)" leading="" trailing=" " raw_val="length_filter_lt_length_iff_exists" val="length_filter_lt_length_iff_exists"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(56, 44)" end="(57, 51)">
          <NullNode start="(56, 44)" end="(56, 47)">
            <OtherNode start="(56, 44)" end="(56, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(56, 44)" end="(56, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(56, 45)" end="(56, 46)">
                <IdentNode start="(56, 45)" end="(56, 46)" leading="" trailing="" raw_val="l" val="l"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(56, 46)" end="(56, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(56, 48)" end="(57, 51)">
            <AtomNode start="(56, 48)" end="(56, 49)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(57, 5)" end="(57, 51)" kind="«term_↔_»">
              <OtherNode start="(57, 5)" end="(57, 35)" kind="«term_&amp;lt;_»">
                <OtherNode start="(57, 5)" end="(57, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(57, 5)" end="(57, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(57, 5)" end="(57, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(57, 6)" end="(57, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(57, 6)" end="(57, 12)" leading="" trailing=" " raw_val="filter" val="filter" full_name="List.filter" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(57, 13)" end="(57, 16)">
                        <IdentNode start="(57, 13)" end="(57, 14)" leading="" trailing=" " raw_val="p" val="p"/>
                        <IdentNode start="(57, 15)" end="(57, 16)" leading="" trailing="" raw_val="l" val="l"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(57, 16)" end="(57, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(57, 17)" end="(57, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(57, 18)" end="(57, 24)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <AtomNode start="(57, 25)" end="(57, 26)" leading="" trailing=" " val="&amp;lt;"/>
                <IdentNode start="(57, 27)" end="(57, 35)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
              </OtherNode>
              <AtomNode start="(57, 36)" end="(57, 37)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(57, 38)" end="(57, 51)" kind="Lean.«term∃__,_»">
                <AtomNode start="(57, 38)" end="(57, 39)" leading="" trailing=" " val="∃"/>
                <LeanBinderidentNode start="(57, 40)" end="(57, 41)">
                  <IdentNode start="(57, 40)" end="(57, 41)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(57, 42)" end="(57, 45)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(57, 42)" end="(57, 43)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(57, 44)" end="(57, 45)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
                <AtomNode start="(57, 45)" end="(57, 46)" leading="" trailing=" " val=","/>
                <OtherNode start="(57, 47)" end="(57, 51)" kind="«term¬_»">
                  <AtomNode start="(57, 47)" end="(57, 48)" leading="" trailing="" val="¬"/>
                  <OtherNode start="(57, 48)" end="(57, 51)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(57, 48)" end="(57, 49)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(57, 50)" end="(57, 51)">
                      <IdentNode start="(57, 50)" end="(57, 51)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(57, 52)" end="(58, 73)">
          <AtomNode start="(57, 52)" end="(57, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(57, 55)" end="(58, 73)">
            <AtomNode start="(57, 55)" end="(57, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(58, 3)" end="(58, 73)">
              <TacticTacticseq1IndentedNode start="(58, 3)" end="(58, 73)">
                <NullNode start="(58, 3)" end="(58, 73)">
                  <OtherNode start="(58, 3)" end="(58, 73)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;l : List α✝&#10;⊢ (filter p l).length &amp;lt; l.length ↔ ∃ x, x ∈ l ∧ ¬p x = true" state_after="no goals" tactic="simp [length_eq_countP_add_countP p (l := l), countP_eq_length_filter]">
                    <AtomNode start="(58, 3)" end="(58, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(58, 8)" end="(58, 73)">
                      <AtomNode start="(58, 8)" end="(58, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(58, 9)" end="(58, 72)">
                        <OtherNode start="(58, 9)" end="(58, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(58, 9)" end="(58, 47)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(58, 9)" end="(58, 36)" leading="" trailing=" " raw_val="length_eq_countP_add_countP" val="length_eq_countP_add_countP" full_name="List.length_eq_countP_add_countP" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                            <NullNode start="(58, 37)" end="(58, 47)">
                              <IdentNode start="(58, 37)" end="(58, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                              <OtherNode start="(58, 39)" end="(58, 47)" kind="Lean.Parser.Term.namedArgument">
                                <AtomNode start="(58, 39)" end="(58, 40)" leading="" trailing="" val="("/>
                                <IdentNode start="(58, 40)" end="(58, 41)" leading="" trailing=" " raw_val="l" val="l"/>
                                <AtomNode start="(58, 42)" end="(58, 44)" leading="" trailing=" " val=":="/>
                                <IdentNode start="(58, 45)" end="(58, 46)" leading="" trailing="" raw_val="l" val="l"/>
                                <AtomNode start="(58, 46)" end="(58, 47)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(58, 47)" end="(58, 48)" leading="" trailing=" " val=","/>
                        <OtherNode start="(58, 49)" end="(58, 72)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(58, 49)" end="(58, 72)" leading="" trailing="" raw_val="countP_eq_length_filter" val="countP_eq_length_filter" full_name="List.countP_eq_length_filter" mod_name="Init.Data.List.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Count.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(58, 72)" end="(58, 73)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(60, 1)" end="(60, 21)" comment="### filterMap -/">
      <AtomNode start="(60, 1)" end="(60, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(60, 5)" end="(60, 21)" leading="" trailing="&#10;&#10;" val="### filterMap -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(62, 1)" end="(71, 15)" name="length_filterMap_pos_iff" full_name="List.length_filterMap_pos_iff">
      <CommandDeclmodifiersNode start="(62, 1)" end="(62, 8)">
        <NullNode/>
        <NullNode start="(62, 1)" end="(62, 8)">
          <OtherNode start="(62, 1)" end="(62, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(62, 1)" end="(62, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(62, 3)" end="(62, 7)">
              <OtherNode start="(62, 3)" end="(62, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(62, 3)" end="(62, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(62, 3)" end="(62, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(62, 7)" end="(62, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(63, 1)" end="(71, 15)" name="length_filterMap_pos_iff" full_name="List.length_filterMap_pos_iff" _is_private_decl="False">
        <AtomNode start="(63, 1)" end="(63, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(63, 9)" end="(63, 33)">
          <IdentNode start="(63, 9)" end="(63, 33)" leading="" trailing=" " raw_val="length_filterMap_pos_iff" val="length_filterMap_pos_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(63, 34)" end="(64, 79)">
          <NullNode start="(63, 34)" end="(63, 66)">
            <OtherNode start="(63, 34)" end="(63, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(63, 34)" end="(63, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(63, 35)" end="(63, 37)">
                <IdentNode start="(63, 35)" end="(63, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(63, 38)" end="(63, 46)">
                <AtomNode start="(63, 38)" end="(63, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(63, 40)" end="(63, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(63, 40)" end="(63, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(63, 45)" end="(63, 46)">
                    <IdentNode start="(63, 45)" end="(63, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(63, 46)" end="(63, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(63, 48)" end="(63, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(63, 48)" end="(63, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(63, 49)" end="(63, 50)">
                <IdentNode start="(63, 49)" end="(63, 50)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(63, 51)" end="(63, 65)">
                <AtomNode start="(63, 51)" end="(63, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(63, 53)" end="(63, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(63, 53)" end="(63, 54)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(63, 55)" end="(63, 56)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(63, 57)" end="(63, 65)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(63, 57)" end="(63, 63)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(63, 64)" end="(63, 65)">
                      <IdentNode start="(63, 64)" end="(63, 65)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(63, 65)" end="(63, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(63, 67)" end="(64, 79)">
            <AtomNode start="(63, 67)" end="(63, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(64, 5)" end="(64, 79)" kind="«term_↔_»">
              <OtherNode start="(64, 5)" end="(64, 32)" kind="«term_&amp;lt;_»">
                <OtherNode start="(64, 5)" end="(64, 6)" kind="num">
                  <AtomNode start="(64, 5)" end="(64, 6)" leading="" trailing=" " val="0"/>
                </OtherNode>
                <AtomNode start="(64, 7)" end="(64, 8)" leading="" trailing=" " val="&amp;lt;"/>
                <OtherNode start="(64, 9)" end="(64, 32)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(64, 9)" end="(64, 25)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(64, 9)" end="(64, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(64, 10)" end="(64, 24)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(64, 10)" end="(64, 19)" leading="" trailing=" " raw_val="filterMap" val="filterMap" full_name="List.filterMap" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(64, 20)" end="(64, 24)">
                        <IdentNode start="(64, 20)" end="(64, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(64, 22)" end="(64, 24)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(64, 24)" end="(64, 25)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(64, 25)" end="(64, 26)" leading="" trailing="" val="."/>
                  <IdentNode start="(64, 26)" end="(64, 32)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(64, 33)" end="(64, 34)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(64, 35)" end="(64, 79)" kind="«term∃_,_»">
                <AtomNode start="(64, 35)" end="(64, 36)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(64, 37)" end="(64, 65)" kind="Lean.explicitBinders">
                  <NullNode start="(64, 37)" end="(64, 65)">
                    <OtherNode start="(64, 37)" end="(64, 44)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(64, 37)" end="(64, 38)" leading="" trailing="" val="("/>
                      <NullNode start="(64, 38)" end="(64, 39)">
                        <LeanBinderidentNode start="(64, 38)" end="(64, 39)">
                          <IdentNode start="(64, 38)" end="(64, 39)" leading="" trailing=" " raw_val="x" val="x"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(64, 40)" end="(64, 41)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(64, 42)" end="(64, 43)" leading="" trailing="" raw_val="α" val="α"/>
                      <AtomNode start="(64, 43)" end="(64, 44)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(64, 45)" end="(64, 57)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(64, 45)" end="(64, 46)" leading="" trailing="" val="("/>
                      <NullNode start="(64, 46)" end="(64, 47)">
                        <LeanBinderidentNode start="(64, 46)" end="(64, 47)">
                          <TermHoleNode start="(64, 46)" end="(64, 47)">
                            <AtomNode start="(64, 46)" end="(64, 47)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(64, 48)" end="(64, 49)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(64, 50)" end="(64, 56)" kind="«term_∈_»">
                        <IdentNode start="(64, 50)" end="(64, 51)" leading="" trailing=" " raw_val="x" val="x"/>
                        <AtomNode start="(64, 52)" end="(64, 53)" leading="" trailing=" " val="∈"/>
                        <IdentNode start="(64, 54)" end="(64, 56)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                      <AtomNode start="(64, 56)" end="(64, 57)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(64, 58)" end="(64, 65)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(64, 58)" end="(64, 59)" leading="" trailing="" val="("/>
                      <NullNode start="(64, 59)" end="(64, 60)">
                        <LeanBinderidentNode start="(64, 59)" end="(64, 60)">
                          <IdentNode start="(64, 59)" end="(64, 60)" leading="" trailing=" " raw_val="b" val="b"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(64, 61)" end="(64, 62)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(64, 63)" end="(64, 64)" leading="" trailing="" raw_val="β" val="β"/>
                      <AtomNode start="(64, 64)" end="(64, 65)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(64, 65)" end="(64, 66)" leading="" trailing=" " val=","/>
                <OtherNode start="(64, 67)" end="(64, 79)" kind="«term_=_»">
                  <OtherNode start="(64, 67)" end="(64, 70)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(64, 67)" end="(64, 68)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(64, 69)" end="(64, 70)">
                      <IdentNode start="(64, 69)" end="(64, 70)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(64, 71)" end="(64, 72)" leading="" trailing=" " val="="/>
                  <OtherNode start="(64, 73)" end="(64, 79)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(64, 73)" end="(64, 77)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(64, 78)" end="(64, 79)">
                      <IdentNode start="(64, 78)" end="(64, 79)" leading="" trailing=" " raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(64, 80)" end="(71, 15)">
          <AtomNode start="(64, 80)" end="(64, 82)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(64, 83)" end="(71, 15)">
            <AtomNode start="(64, 83)" end="(64, 85)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(65, 3)" end="(71, 15)">
              <TacticTacticseq1IndentedNode start="(65, 3)" end="(71, 15)">
                <NullNode start="(65, 3)" end="(71, 15)">
                  <OtherNode start="(65, 3)" end="(71, 15)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;xs : List α&#10;f : α → Option β&#10;⊢ 0 &amp;lt; (filterMap f xs).length ↔ ∃ x x_1 b, f x = some b" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [filterMap, mem_cons, exists_prop, exists_eq_or_imp]&#10;  split&#10;  · simp_all [ih]&#10;  · simp_all">
                    <AtomNode start="(65, 3)" end="(65, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(65, 13)" end="(65, 15)">
                      <OtherNode start="(65, 13)" end="(65, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(65, 13)" end="(65, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(65, 16)" end="(71, 15)">
                      <OtherNode start="(65, 16)" end="(71, 15)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(65, 16)" end="(65, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(66, 3)" end="(71, 15)">
                          <OtherNode start="(66, 3)" end="(66, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(66, 3)" end="(66, 8)">
                              <OtherNode start="(66, 3)" end="(66, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(66, 3)" end="(66, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(66, 5)" end="(66, 8)">
                                  <NullNode/>
                                  <IdentNode start="(66, 5)" end="(66, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(66, 9)" end="(66, 16)">
                              <AtomNode start="(66, 9)" end="(66, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(66, 12)" end="(66, 16)">
                                <TacticTacticseq1IndentedNode start="(66, 12)" end="(66, 16)">
                                  <NullNode start="(66, 12)" end="(66, 16)">
                                    <OtherNode start="(66, 12)" end="(66, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;⊢ 0 &amp;lt; (filterMap f []).length ↔ ∃ x x_1 b, f x = some b" state_after="no goals" tactic="simp">
                                      <AtomNode start="(66, 12)" end="(66, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(67, 3)" end="(71, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(67, 3)" end="(67, 17)">
                              <OtherNode start="(67, 3)" end="(67, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(67, 3)" end="(67, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(67, 5)" end="(67, 9)">
                                  <NullNode/>
                                  <IdentNode start="(67, 5)" end="(67, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(67, 10)" end="(67, 17)">
                                  <IdentNode start="(67, 10)" end="(67, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(67, 12)" end="(67, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(67, 15)" end="(67, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(67, 18)" end="(71, 15)">
                              <AtomNode start="(67, 18)" end="(67, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(68, 5)" end="(71, 15)">
                                <TacticTacticseq1IndentedNode start="(68, 5)" end="(71, 15)">
                                  <NullNode start="(68, 5)" end="(71, 15)">
                                    <OtherNode start="(68, 5)" end="(68, 67)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : 0 &amp;lt; (filterMap f xs).length ↔ ∃ x x_1 b, f x = some b&#10;⊢ 0 &amp;lt; (filterMap f (x :: xs)).length ↔ ∃ x_1 x b, f x_1 = some b" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : 0 &amp;lt; (filterMap f xs).length ↔ ∃ x x_1 b, f x = some b&#10;⊢ 0 &amp;lt;&#10;      (match f x with&#10;        | none =&amp;gt; filterMap f xs&#10;        | some b =&amp;gt; b :: filterMap f xs).length ↔&#10;    (∃ b, f x = some b) ∨ ∃ a, a ∈ xs ∧ ∃ b, f a = some b" tactic="simp only [filterMap, mem_cons, exists_prop, exists_eq_or_imp]">
                                      <AtomNode start="(68, 5)" end="(68, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(68, 10)" end="(68, 14)">
                                        <AtomNode start="(68, 10)" end="(68, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(68, 15)" end="(68, 67)">
                                        <AtomNode start="(68, 15)" end="(68, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(68, 16)" end="(68, 66)">
                                          <OtherNode start="(68, 16)" end="(68, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(68, 16)" end="(68, 25)" leading="" trailing="" raw_val="filterMap" val="filterMap" full_name="List.filterMap" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(68, 25)" end="(68, 26)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(68, 27)" end="(68, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(68, 27)" end="(68, 35)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(68, 35)" end="(68, 36)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(68, 37)" end="(68, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(68, 37)" end="(68, 48)" leading="" trailing="" raw_val="exists_prop" val="exists_prop" full_name="exists_prop" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(68, 48)" end="(68, 49)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(68, 50)" end="(68, 66)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(68, 50)" end="(68, 66)" leading="" trailing="" raw_val="exists_eq_or_imp" val="exists_eq_or_imp" full_name="exists_eq_or_imp" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(68, 66)" end="(68, 67)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(69, 5)" end="(69, 10)" kind="Lean.Parser.Tactic.split" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : 0 &amp;lt; (filterMap f xs).length ↔ ∃ x x_1 b, f x = some b&#10;⊢ 0 &amp;lt;&#10;      (match f x with&#10;        | none =&amp;gt; filterMap f xs&#10;        | some b =&amp;gt; b :: filterMap f xs).length ↔&#10;    (∃ b, f x = some b) ∨ ∃ a, a ∈ xs ∧ ∃ b, f a = some b" state_after="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : 0 &amp;lt; (filterMap f xs).length ↔ ∃ x x_1 b, f x = some b&#10;x✝ : Option β&#10;heq✝ : f x = none&#10;⊢ 0 &amp;lt; (filterMap f xs).length ↔ (∃ b, f x = some b) ∨ ∃ a, a ∈ xs ∧ ∃ b, f a = some b&#10;&#10;case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : 0 &amp;lt; (filterMap f xs).length ↔ ∃ x x_1 b, f x = some b&#10;x✝ : Option β&#10;b✝ : β&#10;heq✝ : f x = some b✝&#10;⊢ 0 &amp;lt; (b✝ :: filterMap f xs).length ↔ (∃ b, f x = some b) ∨ ∃ a, a ∈ xs ∧ ∃ b, f a = some b" tactic="split">
                                      <AtomNode start="(69, 5)" end="(69, 10)" leading="" trailing="&#10;    " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(70, 5)" end="(70, 20)" kind="Lean.cdot" state_before="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : 0 &amp;lt; (filterMap f xs).length ↔ ∃ x x_1 b, f x = some b&#10;x✝ : Option β&#10;heq✝ : f x = none&#10;⊢ 0 &amp;lt; (filterMap f xs).length ↔ (∃ b, f x = some b) ∨ ∃ a, a ∈ xs ∧ ∃ b, f a = some b&#10;&#10;case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : 0 &amp;lt; (filterMap f xs).length ↔ ∃ x x_1 b, f x = some b&#10;x✝ : Option β&#10;b✝ : β&#10;heq✝ : f x = some b✝&#10;⊢ 0 &amp;lt; (b✝ :: filterMap f xs).length ↔ (∃ b, f x = some b) ∨ ∃ a, a ∈ xs ∧ ∃ b, f a = some b" state_after="case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : 0 &amp;lt; (filterMap f xs).length ↔ ∃ x x_1 b, f x = some b&#10;x✝ : Option β&#10;b✝ : β&#10;heq✝ : f x = some b✝&#10;⊢ 0 &amp;lt; (b✝ :: filterMap f xs).length ↔ (∃ b, f x = some b) ∨ ∃ a, a ∈ xs ∧ ∃ b, f a = some b" tactic="· simp_all [ih]">
                                      <OtherNode start="(70, 5)" end="(70, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(70, 5)" end="(70, 6)" kind="patternIgnore">
                                          <OtherNode start="(70, 5)" end="(70, 6)" kind="token.«· »">
                                            <AtomNode start="(70, 5)" end="(70, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(70, 7)" end="(70, 20)">
                                        <TacticTacticseq1IndentedNode start="(70, 7)" end="(70, 20)">
                                          <NullNode start="(70, 7)" end="(70, 20)">
                                            <OtherNode start="(70, 7)" end="(70, 20)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : 0 &amp;lt; (filterMap f xs).length ↔ ∃ x x_1 b, f x = some b&#10;x✝ : Option β&#10;heq✝ : f x = none&#10;⊢ 0 &amp;lt; (filterMap f xs).length ↔ (∃ b, f x = some b) ∨ ∃ a, a ∈ xs ∧ ∃ b, f a = some b" state_after="no goals" tactic="simp_all [ih]">
                                              <AtomNode start="(70, 7)" end="(70, 15)" leading="" trailing=" " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(70, 16)" end="(70, 20)">
                                                <AtomNode start="(70, 16)" end="(70, 17)" leading="" trailing="" val="["/>
                                                <NullNode start="(70, 17)" end="(70, 19)">
                                                  <OtherNode start="(70, 17)" end="(70, 19)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(70, 17)" end="(70, 19)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(70, 19)" end="(70, 20)" leading="" trailing="&#10;    " val="]"/>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(71, 5)" end="(71, 15)" kind="Lean.cdot" state_before="case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : 0 &amp;lt; (filterMap f xs).length ↔ ∃ x x_1 b, f x = some b&#10;x✝ : Option β&#10;b✝ : β&#10;heq✝ : f x = some b✝&#10;⊢ 0 &amp;lt; (b✝ :: filterMap f xs).length ↔ (∃ b, f x = some b) ∨ ∃ a, a ∈ xs ∧ ∃ b, f a = some b" state_after="no goals" tactic="· simp_all">
                                      <OtherNode start="(71, 5)" end="(71, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(71, 5)" end="(71, 6)" kind="patternIgnore">
                                          <OtherNode start="(71, 5)" end="(71, 6)" kind="token.«· »">
                                            <AtomNode start="(71, 5)" end="(71, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(71, 7)" end="(71, 15)">
                                        <TacticTacticseq1IndentedNode start="(71, 7)" end="(71, 15)">
                                          <NullNode start="(71, 7)" end="(71, 15)">
                                            <OtherNode start="(71, 7)" end="(71, 15)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : 0 &amp;lt; (filterMap f xs).length ↔ ∃ x x_1 b, f x = some b&#10;x✝ : Option β&#10;b✝ : β&#10;heq✝ : f x = some b✝&#10;⊢ 0 &amp;lt; (b✝ :: filterMap f xs).length ↔ (∃ b, f x = some b) ∨ ∃ a, a ∈ xs ∧ ∃ b, f a = some b" state_after="no goals" tactic="simp_all">
                                              <AtomNode start="(71, 7)" end="(71, 15)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(73, 1)" end="(84, 15)" name="length_filterMap_lt_length_iff_exists" full_name="List.length_filterMap_lt_length_iff_exists">
      <CommandDeclmodifiersNode start="(73, 1)" end="(73, 8)">
        <NullNode/>
        <NullNode start="(73, 1)" end="(73, 8)">
          <OtherNode start="(73, 1)" end="(73, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(73, 1)" end="(73, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(73, 3)" end="(73, 7)">
              <OtherNode start="(73, 3)" end="(73, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(73, 3)" end="(73, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(73, 3)" end="(73, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(73, 7)" end="(73, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(74, 1)" end="(84, 15)" name="length_filterMap_lt_length_iff_exists" full_name="List.length_filterMap_lt_length_iff_exists" _is_private_decl="False">
        <AtomNode start="(74, 1)" end="(74, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(74, 9)" end="(74, 46)">
          <IdentNode start="(74, 9)" end="(74, 46)" leading="" trailing=" " raw_val="length_filterMap_lt_length_iff_exists" val="length_filterMap_lt_length_iff_exists"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(74, 47)" end="(75, 77)">
          <NullNode start="(74, 47)" end="(74, 79)">
            <OtherNode start="(74, 47)" end="(74, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(74, 47)" end="(74, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(74, 48)" end="(74, 50)">
                <IdentNode start="(74, 48)" end="(74, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(74, 51)" end="(74, 59)">
                <AtomNode start="(74, 51)" end="(74, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(74, 53)" end="(74, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(74, 53)" end="(74, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(74, 58)" end="(74, 59)">
                    <IdentNode start="(74, 58)" end="(74, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(74, 59)" end="(74, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(74, 61)" end="(74, 79)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(74, 61)" end="(74, 62)" leading="" trailing="" val="{"/>
              <NullNode start="(74, 62)" end="(74, 63)">
                <IdentNode start="(74, 62)" end="(74, 63)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(74, 64)" end="(74, 78)">
                <AtomNode start="(74, 64)" end="(74, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(74, 66)" end="(74, 78)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(74, 66)" end="(74, 67)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(74, 68)" end="(74, 69)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(74, 70)" end="(74, 78)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(74, 70)" end="(74, 76)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(74, 77)" end="(74, 78)">
                      <IdentNode start="(74, 77)" end="(74, 78)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(74, 78)" end="(74, 79)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(74, 80)" end="(75, 77)">
            <AtomNode start="(74, 80)" end="(74, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(75, 5)" end="(75, 77)" kind="«term_↔_»">
              <OtherNode start="(75, 5)" end="(75, 40)" kind="«term_&amp;lt;_»">
                <OtherNode start="(75, 5)" end="(75, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(75, 5)" end="(75, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(75, 5)" end="(75, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(75, 6)" end="(75, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(75, 6)" end="(75, 15)" leading="" trailing=" " raw_val="filterMap" val="filterMap" full_name="List.filterMap" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(75, 16)" end="(75, 20)">
                        <IdentNode start="(75, 16)" end="(75, 17)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(75, 18)" end="(75, 20)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(75, 20)" end="(75, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(75, 21)" end="(75, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(75, 22)" end="(75, 28)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <AtomNode start="(75, 29)" end="(75, 30)" leading="" trailing=" " val="&amp;lt;"/>
                <IdentNode start="(75, 31)" end="(75, 40)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
              </OtherNode>
              <AtomNode start="(75, 41)" end="(75, 42)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(75, 43)" end="(75, 77)" kind="«term∃_,_»">
                <AtomNode start="(75, 43)" end="(75, 44)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(75, 45)" end="(75, 65)" kind="Lean.explicitBinders">
                  <NullNode start="(75, 45)" end="(75, 65)">
                    <OtherNode start="(75, 45)" end="(75, 52)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(75, 45)" end="(75, 46)" leading="" trailing="" val="("/>
                      <NullNode start="(75, 46)" end="(75, 47)">
                        <LeanBinderidentNode start="(75, 46)" end="(75, 47)">
                          <IdentNode start="(75, 46)" end="(75, 47)" leading="" trailing=" " raw_val="x" val="x"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(75, 48)" end="(75, 49)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(75, 50)" end="(75, 51)" leading="" trailing="" raw_val="α" val="α"/>
                      <AtomNode start="(75, 51)" end="(75, 52)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(75, 53)" end="(75, 65)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(75, 53)" end="(75, 54)" leading="" trailing="" val="("/>
                      <NullNode start="(75, 54)" end="(75, 55)">
                        <LeanBinderidentNode start="(75, 54)" end="(75, 55)">
                          <TermHoleNode start="(75, 54)" end="(75, 55)">
                            <AtomNode start="(75, 54)" end="(75, 55)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(75, 56)" end="(75, 57)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(75, 58)" end="(75, 64)" kind="«term_∈_»">
                        <IdentNode start="(75, 58)" end="(75, 59)" leading="" trailing=" " raw_val="x" val="x"/>
                        <AtomNode start="(75, 60)" end="(75, 61)" leading="" trailing=" " val="∈"/>
                        <IdentNode start="(75, 62)" end="(75, 64)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                      <AtomNode start="(75, 64)" end="(75, 65)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(75, 65)" end="(75, 66)" leading="" trailing=" " val=","/>
                <OtherNode start="(75, 67)" end="(75, 77)" kind="«term_=_»">
                  <OtherNode start="(75, 67)" end="(75, 70)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(75, 67)" end="(75, 68)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(75, 69)" end="(75, 70)">
                      <IdentNode start="(75, 69)" end="(75, 70)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(75, 71)" end="(75, 72)" leading="" trailing=" " val="="/>
                  <IdentNode start="(75, 73)" end="(75, 77)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(75, 78)" end="(84, 15)">
          <AtomNode start="(75, 78)" end="(75, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(75, 81)" end="(84, 15)">
            <AtomNode start="(75, 81)" end="(75, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(76, 3)" end="(84, 15)">
              <TacticTacticseq1IndentedNode start="(76, 3)" end="(84, 15)">
                <NullNode start="(76, 3)" end="(84, 15)">
                  <OtherNode start="(76, 3)" end="(84, 15)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;xs : List α&#10;f : α → Option β&#10;⊢ (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x x_1, f x = none" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [filterMap, mem_cons, exists_prop, exists_eq_or_imp]&#10;  split&#10;  · simp_all only [exists_prop, length_cons, true_or, iff_true]&#10;    have := length_filterMap_le f xs&#10;    omega&#10;  · simp_all">
                    <AtomNode start="(76, 3)" end="(76, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(76, 13)" end="(76, 15)">
                      <OtherNode start="(76, 13)" end="(76, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(76, 13)" end="(76, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(76, 16)" end="(84, 15)">
                      <OtherNode start="(76, 16)" end="(84, 15)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(76, 16)" end="(76, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(77, 3)" end="(84, 15)">
                          <OtherNode start="(77, 3)" end="(77, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(77, 3)" end="(77, 8)">
                              <OtherNode start="(77, 3)" end="(77, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(77, 3)" end="(77, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(77, 5)" end="(77, 8)">
                                  <NullNode/>
                                  <IdentNode start="(77, 5)" end="(77, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(77, 9)" end="(77, 16)">
                              <AtomNode start="(77, 9)" end="(77, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(77, 12)" end="(77, 16)">
                                <TacticTacticseq1IndentedNode start="(77, 12)" end="(77, 16)">
                                  <NullNode start="(77, 12)" end="(77, 16)">
                                    <OtherNode start="(77, 12)" end="(77, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;⊢ (filterMap f []).length &amp;lt; [].length ↔ ∃ x x_1, f x = none" state_after="no goals" tactic="simp">
                                      <AtomNode start="(77, 12)" end="(77, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(78, 3)" end="(84, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(78, 3)" end="(78, 17)">
                              <OtherNode start="(78, 3)" end="(78, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(78, 3)" end="(78, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(78, 5)" end="(78, 9)">
                                  <NullNode/>
                                  <IdentNode start="(78, 5)" end="(78, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(78, 10)" end="(78, 17)">
                                  <IdentNode start="(78, 10)" end="(78, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(78, 12)" end="(78, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(78, 15)" end="(78, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(78, 18)" end="(84, 15)">
                              <AtomNode start="(78, 18)" end="(78, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(79, 5)" end="(84, 15)">
                                <TacticTacticseq1IndentedNode start="(79, 5)" end="(84, 15)">
                                  <NullNode start="(79, 5)" end="(84, 15)">
                                    <OtherNode start="(79, 5)" end="(79, 67)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x x_1, f x = none&#10;⊢ (filterMap f (x :: xs)).length &amp;lt; (x :: xs).length ↔ ∃ x_1 x, f x_1 = none" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x x_1, f x = none&#10;⊢ (match f x with&#10;        | none =&amp;gt; filterMap f xs&#10;        | some b =&amp;gt; b :: filterMap f xs).length &amp;lt;&#10;      (x :: xs).length ↔&#10;    f x = none ∨ ∃ a, a ∈ xs ∧ f a = none" tactic="simp only [filterMap, mem_cons, exists_prop, exists_eq_or_imp]">
                                      <AtomNode start="(79, 5)" end="(79, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(79, 10)" end="(79, 14)">
                                        <AtomNode start="(79, 10)" end="(79, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(79, 15)" end="(79, 67)">
                                        <AtomNode start="(79, 15)" end="(79, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(79, 16)" end="(79, 66)">
                                          <OtherNode start="(79, 16)" end="(79, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(79, 16)" end="(79, 25)" leading="" trailing="" raw_val="filterMap" val="filterMap" full_name="List.filterMap" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(79, 25)" end="(79, 26)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(79, 27)" end="(79, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(79, 27)" end="(79, 35)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(79, 35)" end="(79, 36)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(79, 37)" end="(79, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(79, 37)" end="(79, 48)" leading="" trailing="" raw_val="exists_prop" val="exists_prop" full_name="exists_prop" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(79, 48)" end="(79, 49)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(79, 50)" end="(79, 66)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(79, 50)" end="(79, 66)" leading="" trailing="" raw_val="exists_eq_or_imp" val="exists_eq_or_imp" full_name="exists_eq_or_imp" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(79, 66)" end="(79, 67)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(80, 5)" end="(80, 10)" kind="Lean.Parser.Tactic.split" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x x_1, f x = none&#10;⊢ (match f x with&#10;        | none =&amp;gt; filterMap f xs&#10;        | some b =&amp;gt; b :: filterMap f xs).length &amp;lt;&#10;      (x :: xs).length ↔&#10;    f x = none ∨ ∃ a, a ∈ xs ∧ f a = none" state_after="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x x_1, f x = none&#10;x✝ : Option β&#10;heq✝ : f x = none&#10;⊢ (filterMap f xs).length &amp;lt; (x :: xs).length ↔ f x = none ∨ ∃ a, a ∈ xs ∧ f a = none&#10;&#10;case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x x_1, f x = none&#10;x✝ : Option β&#10;b✝ : β&#10;heq✝ : f x = some b✝&#10;⊢ (b✝ :: filterMap f xs).length &amp;lt; (x :: xs).length ↔ f x = none ∨ ∃ a, a ∈ xs ∧ f a = none" tactic="split">
                                      <AtomNode start="(80, 5)" end="(80, 10)" leading="" trailing="&#10;    " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(81, 5)" end="(83, 12)" kind="Lean.cdot" state_before="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x x_1, f x = none&#10;x✝ : Option β&#10;heq✝ : f x = none&#10;⊢ (filterMap f xs).length &amp;lt; (x :: xs).length ↔ f x = none ∨ ∃ a, a ∈ xs ∧ f a = none&#10;&#10;case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x x_1, f x = none&#10;x✝ : Option β&#10;b✝ : β&#10;heq✝ : f x = some b✝&#10;⊢ (b✝ :: filterMap f xs).length &amp;lt; (x :: xs).length ↔ f x = none ∨ ∃ a, a ∈ xs ∧ f a = none" state_after="case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x x_1, f x = none&#10;x✝ : Option β&#10;b✝ : β&#10;heq✝ : f x = some b✝&#10;⊢ (b✝ :: filterMap f xs).length &amp;lt; (x :: xs).length ↔ f x = none ∨ ∃ a, a ∈ xs ∧ f a = none" tactic="· simp_all only [exists_prop, length_cons, true_or, iff_true]&#10;  have := length_filterMap_le f xs&#10;  omega">
                                      <OtherNode start="(81, 5)" end="(81, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(81, 5)" end="(81, 6)" kind="patternIgnore">
                                          <OtherNode start="(81, 5)" end="(81, 6)" kind="token.«· »">
                                            <AtomNode start="(81, 5)" end="(81, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(81, 7)" end="(83, 12)">
                                        <TacticTacticseq1IndentedNode start="(81, 7)" end="(83, 12)">
                                          <NullNode start="(81, 7)" end="(83, 12)">
                                            <OtherNode start="(81, 7)" end="(81, 66)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x x_1, f x = none&#10;x✝ : Option β&#10;heq✝ : f x = none&#10;⊢ (filterMap f xs).length &amp;lt; (x :: xs).length ↔ f x = none ∨ ∃ a, a ∈ xs ∧ f a = none" state_after="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;x✝ : Option β&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x, x ∈ xs ∧ f x = none&#10;heq✝ : f x = none&#10;⊢ (filterMap f xs).length &amp;lt; xs.length + 1" tactic="simp_all only [exists_prop, length_cons, true_or, iff_true]">
                                              <AtomNode start="(81, 7)" end="(81, 15)" leading="" trailing=" " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(81, 16)" end="(81, 20)">
                                                <AtomNode start="(81, 16)" end="(81, 20)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(81, 21)" end="(81, 66)">
                                                <AtomNode start="(81, 21)" end="(81, 22)" leading="" trailing="" val="["/>
                                                <NullNode start="(81, 22)" end="(81, 65)">
                                                  <OtherNode start="(81, 22)" end="(81, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(81, 22)" end="(81, 33)" leading="" trailing="" raw_val="exists_prop" val="exists_prop" full_name="exists_prop" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(81, 33)" end="(81, 34)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(81, 35)" end="(81, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(81, 35)" end="(81, 46)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(81, 46)" end="(81, 47)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(81, 48)" end="(81, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(81, 48)" end="(81, 55)" leading="" trailing="" raw_val="true_or" val="true_or" full_name="true_or" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(81, 55)" end="(81, 56)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(81, 57)" end="(81, 65)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(81, 57)" end="(81, 65)" leading="" trailing="" raw_val="iff_true" val="iff_true" full_name="iff_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(81, 65)" end="(81, 66)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(82, 7)" end="(82, 39)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;x✝ : Option β&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x, x ∈ xs ∧ f x = none&#10;heq✝ : f x = none&#10;⊢ (filterMap f xs).length &amp;lt; xs.length + 1" state_after="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;x✝ : Option β&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x, x ∈ xs ∧ f x = none&#10;heq✝ : f x = none&#10;this : (filterMap f xs).length ≤ xs.length&#10;⊢ (filterMap f xs).length &amp;lt; xs.length + 1" tactic="have := length_filterMap_le f xs">
                                              <AtomNode start="(82, 7)" end="(82, 11)" leading="" trailing=" " val="have"/>
                                              <OtherNode start="(82, 12)" end="(82, 39)" kind="Lean.Parser.Term.haveDecl">
                                                <OtherNode start="(82, 12)" end="(82, 39)" kind="Lean.Parser.Term.haveIdDecl">
                                                  <OtherNode start="(82, 12)" end="(82, 12)" kind="Lean.Parser.Term.haveId">
                                                    <OtherNode start="(82, 12)" end="(82, 12)" kind="hygieneInfo">
                                                      <IdentNode start="(82, 12)" end="(82, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <AtomNode start="(82, 12)" end="(82, 14)" leading="" trailing=" " val=":="/>
                                                  <OtherNode start="(82, 15)" end="(82, 39)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(82, 15)" end="(82, 34)" leading="" trailing=" " raw_val="length_filterMap_le" val="length_filterMap_le" full_name="List.length_filterMap_le" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                    <NullNode start="(82, 35)" end="(82, 39)">
                                                      <IdentNode start="(82, 35)" end="(82, 36)" leading="" trailing=" " raw_val="f" val="f"/>
                                                      <IdentNode start="(82, 37)" end="(82, 39)" leading="" trailing="&#10;      " raw_val="xs" val="xs"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(83, 7)" end="(83, 12)" kind="Lean.Parser.Tactic.omega" state_before="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;x✝ : Option β&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x, x ∈ xs ∧ f x = none&#10;heq✝ : f x = none&#10;this : (filterMap f xs).length ≤ xs.length&#10;⊢ (filterMap f xs).length &amp;lt; xs.length + 1" state_after="no goals" tactic="omega">
                                              <AtomNode start="(83, 7)" end="(83, 12)" leading="" trailing="&#10;    " val="omega"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(84, 5)" end="(84, 15)" kind="Lean.cdot" state_before="case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x x_1, f x = none&#10;x✝ : Option β&#10;b✝ : β&#10;heq✝ : f x = some b✝&#10;⊢ (b✝ :: filterMap f xs).length &amp;lt; (x :: xs).length ↔ f x = none ∨ ∃ a, a ∈ xs ∧ f a = none" state_after="no goals" tactic="· simp_all">
                                      <OtherNode start="(84, 5)" end="(84, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(84, 5)" end="(84, 6)" kind="patternIgnore">
                                          <OtherNode start="(84, 5)" end="(84, 6)" kind="token.«· »">
                                            <AtomNode start="(84, 5)" end="(84, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(84, 7)" end="(84, 15)">
                                        <TacticTacticseq1IndentedNode start="(84, 7)" end="(84, 15)">
                                          <NullNode start="(84, 7)" end="(84, 15)">
                                            <OtherNode start="(84, 7)" end="(84, 15)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (filterMap f xs).length &amp;lt; xs.length ↔ ∃ x x_1, f x = none&#10;x✝ : Option β&#10;b✝ : β&#10;heq✝ : f x = some b✝&#10;⊢ (b✝ :: filterMap f xs).length &amp;lt; (x :: xs).length ↔ f x = none ∨ ∃ a, a ∈ xs ∧ f a = none" state_after="no goals" tactic="simp_all">
                                              <AtomNode start="(84, 7)" end="(84, 15)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(86, 1)" end="(86, 19)" comment="### reverse -/">
      <AtomNode start="(86, 1)" end="(86, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(86, 5)" end="(86, 19)" leading="" trailing="&#10;&#10;" val="### reverse -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(88, 1)" end="(92, 8)" name="getElem_eq_getElem_reverse" full_name="List.getElem_eq_getElem_reverse">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(88, 1)" end="(92, 8)" name="getElem_eq_getElem_reverse" full_name="List.getElem_eq_getElem_reverse" _is_private_decl="False">
        <AtomNode start="(88, 1)" end="(88, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(88, 9)" end="(88, 35)">
          <IdentNode start="(88, 9)" end="(88, 35)" leading="" trailing=" " raw_val="getElem_eq_getElem_reverse" val="getElem_eq_getElem_reverse"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(88, 36)" end="(89, 83)">
          <NullNode start="(88, 36)" end="(88, 71)">
            <OtherNode start="(88, 36)" end="(88, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(88, 36)" end="(88, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(88, 37)" end="(88, 38)">
                <IdentNode start="(88, 37)" end="(88, 38)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(88, 39)" end="(88, 47)">
                <AtomNode start="(88, 39)" end="(88, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 41)" end="(88, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(88, 41)" end="(88, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(88, 46)" end="(88, 47)">
                    <IdentNode start="(88, 46)" end="(88, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(88, 47)" end="(88, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(88, 49)" end="(88, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(88, 49)" end="(88, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(88, 50)" end="(88, 51)">
                <IdentNode start="(88, 50)" end="(88, 51)" leading="" trailing="" raw_val="i" val="i"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(88, 51)" end="(88, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(88, 53)" end="(88, 71)">
              <AtomNode start="(88, 53)" end="(88, 54)" leading="" trailing="" val="("/>
              <NullNode start="(88, 54)" end="(88, 55)">
                <IdentNode start="(88, 54)" end="(88, 55)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(88, 56)" end="(88, 70)">
                <AtomNode start="(88, 56)" end="(88, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 58)" end="(88, 70)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(88, 58)" end="(88, 59)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(88, 60)" end="(88, 61)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(88, 62)" end="(88, 70)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(88, 70)" end="(88, 71)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(88, 72)" end="(89, 83)">
            <AtomNode start="(88, 72)" end="(88, 73)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(89, 5)" end="(89, 83)" kind="«term_=_»">
              <OtherNode start="(89, 5)" end="(89, 9)" kind="«term__[_]»">
                <IdentNode start="(89, 5)" end="(89, 6)" leading="" trailing="" raw_val="l" val="l"/>
                <AtomNode start="(89, 6)" end="(89, 7)" leading="" trailing="" val="["/>
                <IdentNode start="(89, 7)" end="(89, 8)" leading="" trailing="" raw_val="i" val="i"/>
                <AtomNode start="(89, 8)" end="(89, 9)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(89, 10)" end="(89, 11)" leading="" trailing=" " val="="/>
              <OtherNode start="(89, 12)" end="(89, 83)" kind="«term__[_]'_»">
                <IdentNode start="(89, 12)" end="(89, 21)" leading="" trailing="" raw_val="l.reverse" val="l.reverse"/>
                <AtomNode start="(89, 21)" end="(89, 22)" leading="" trailing="" val="["/>
                <OtherNode start="(89, 22)" end="(89, 38)" kind="«term_-_»">
                  <OtherNode start="(89, 22)" end="(89, 34)" kind="«term_-_»">
                    <IdentNode start="(89, 22)" end="(89, 30)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(89, 31)" end="(89, 32)" leading="" trailing=" " val="-"/>
                    <OtherNode start="(89, 33)" end="(89, 34)" kind="num">
                      <AtomNode start="(89, 33)" end="(89, 34)" leading="" trailing=" " val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(89, 35)" end="(89, 36)" leading="" trailing=" " val="-"/>
                  <IdentNode start="(89, 37)" end="(89, 38)" leading="" trailing="" raw_val="i" val="i"/>
                </OtherNode>
                <AtomNode start="(89, 38)" end="(89, 40)" leading="" trailing="" val="]'"/>
                <OtherNode start="(89, 40)" end="(89, 83)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(89, 40)" end="(89, 41)" leading="" trailing="" val="("/>
                  <TermBytacticNode start="(89, 41)" end="(89, 82)">
                    <AtomNode start="(89, 41)" end="(89, 43)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(89, 44)" end="(89, 82)">
                      <TacticTacticseq1IndentedNode start="(89, 44)" end="(89, 82)">
                        <NullNode start="(89, 44)" end="(89, 82)">
                          <OtherNode start="(89, 44)" end="(89, 82)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type ?u.15779&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ l.length - 1 - i &amp;lt; l.reverse.length" state_after="no goals" tactic="simpa using Nat.sub_one_sub_lt_of_lt h">
                            <AtomNode start="(89, 44)" end="(89, 49)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(89, 50)" end="(89, 82)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(89, 50)" end="(89, 82)">
                                <AtomNode start="(89, 50)" end="(89, 55)" leading="" trailing=" " val="using"/>
                                <OtherNode start="(89, 56)" end="(89, 82)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(89, 56)" end="(89, 80)" leading="" trailing=" " raw_val="Nat.sub_one_sub_lt_of_lt" val="Nat.sub_one_sub_lt_of_lt" full_name="Nat.sub_one_sub_lt_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                  <NullNode start="(89, 81)" end="(89, 82)">
                                    <IdentNode start="(89, 81)" end="(89, 82)" leading="" trailing="" raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                  <AtomNode start="(89, 82)" end="(89, 83)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(89, 84)" end="(92, 8)">
          <AtomNode start="(89, 84)" end="(89, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(89, 87)" end="(92, 8)">
            <AtomNode start="(89, 87)" end="(89, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(90, 3)" end="(92, 8)">
              <TacticTacticseq1IndentedNode start="(90, 3)" end="(92, 8)">
                <NullNode start="(90, 3)" end="(92, 8)">
                  <OtherNode start="(90, 3)" end="(90, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ l[i] = l.reverse[l.length - 1 - i]" state_after="α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ l[i] = l[l.length - 1 - (l.length - 1 - i)]" tactic="rw [getElem_reverse]">
                    <AtomNode start="(90, 3)" end="(90, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(90, 6)" end="(90, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(90, 6)" end="(90, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(90, 7)" end="(90, 22)">
                        <OtherNode start="(90, 7)" end="(90, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(90, 7)" end="(90, 22)" leading="" trailing="" raw_val="getElem_reverse" val="getElem_reverse" full_name="List.getElem_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(90, 22)" end="(90, 23)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(91, 3)" end="(91, 8)" kind="Lean.Parser.Tactic.congr" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ l[i] = l[l.length - 1 - (l.length - 1 - i)]" state_after="case e_i&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ i = l.length - 1 - (l.length - 1 - i)" tactic="congr">
                    <AtomNode start="(91, 3)" end="(91, 8)" leading="" trailing="&#10;  " val="congr"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(92, 3)" end="(92, 8)" kind="Lean.Parser.Tactic.omega" state_before="case e_i&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ i = l.length - 1 - (l.length - 1 - i)" state_after="no goals" tactic="omega">
                    <AtomNode start="(92, 3)" end="(92, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(94, 1)" end="(94, 19)" comment="### leftpad -/">
      <AtomNode start="(94, 1)" end="(94, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(94, 5)" end="(94, 19)" leading="" trailing="&#10;&#10;" val="### leftpad -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(96, 1)" end="(102, 75)" name="length_leftpad" full_name="List.length_leftpad">
      <CommandDeclmodifiersNode start="(96, 1)" end="(97, 41)">
        <NullNode start="(96, 1)" end="(97, 41)">
          <CommandDoccommentNode start="(96, 1)" end="(97, 41)" comment="The length of the List returned by `List.leftpad n a l` is equal&#10;  to the larger of `n` and `l.length` -/">
            <AtomNode start="(96, 1)" end="(96, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(96, 5)" end="(97, 41)" leading="" trailing="&#10;-- We don't mark this as a `@[simp]` lemma since we allow `simp` to unfold `leftpad`,&#10;-- so the left hand side simplifies directly to `n - l.length + l.length`.&#10;" val="The length of the List returned by `List.leftpad n a l` is equal&#10;  to the larger of `n` and `l.length` -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(100, 1)" end="(102, 75)" name="length_leftpad" full_name="List.length_leftpad" _is_private_decl="False">
        <AtomNode start="(100, 1)" end="(100, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(100, 9)" end="(100, 23)">
          <IdentNode start="(100, 9)" end="(100, 23)" leading="" trailing=" " raw_val="length_leftpad" val="length_leftpad"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(100, 24)" end="(101, 44)">
          <NullNode start="(100, 24)" end="(100, 54)">
            <OtherNode start="(100, 24)" end="(100, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(100, 24)" end="(100, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(100, 25)" end="(100, 26)">
                <IdentNode start="(100, 25)" end="(100, 26)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(100, 27)" end="(100, 32)">
                <AtomNode start="(100, 27)" end="(100, 28)" leading="" trailing=" " val=":"/>
                <IdentNode start="(100, 29)" end="(100, 32)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(100, 32)" end="(100, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(100, 34)" end="(100, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(100, 34)" end="(100, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(100, 35)" end="(100, 36)">
                <IdentNode start="(100, 35)" end="(100, 36)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(100, 37)" end="(100, 40)">
                <AtomNode start="(100, 37)" end="(100, 38)" leading="" trailing=" " val=":"/>
                <IdentNode start="(100, 39)" end="(100, 40)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(100, 40)" end="(100, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(100, 42)" end="(100, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(100, 42)" end="(100, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(100, 43)" end="(100, 44)">
                <IdentNode start="(100, 43)" end="(100, 44)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(100, 45)" end="(100, 53)">
                <AtomNode start="(100, 45)" end="(100, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(100, 47)" end="(100, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(100, 47)" end="(100, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(100, 52)" end="(100, 53)">
                    <IdentNode start="(100, 52)" end="(100, 53)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(100, 53)" end="(100, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(100, 55)" end="(101, 44)">
            <AtomNode start="(100, 55)" end="(100, 56)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(101, 5)" end="(101, 44)" kind="«term_=_»">
              <OtherNode start="(101, 5)" end="(101, 27)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(101, 5)" end="(101, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(101, 5)" end="(101, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(101, 6)" end="(101, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(101, 6)" end="(101, 13)" leading="" trailing=" " raw_val="leftpad" val="leftpad" full_name="List.leftpad" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(101, 14)" end="(101, 19)">
                      <IdentNode start="(101, 14)" end="(101, 15)" leading="" trailing=" " raw_val="n" val="n"/>
                      <IdentNode start="(101, 16)" end="(101, 17)" leading="" trailing=" " raw_val="a" val="a"/>
                      <IdentNode start="(101, 18)" end="(101, 19)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(101, 19)" end="(101, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(101, 20)" end="(101, 21)" leading="" trailing="" val="."/>
                <IdentNode start="(101, 21)" end="(101, 27)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(101, 28)" end="(101, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(101, 30)" end="(101, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(101, 30)" end="(101, 33)" leading="" trailing=" " raw_val="max" val="max" full_name="Max.max" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(101, 34)" end="(101, 44)">
                  <IdentNode start="(101, 34)" end="(101, 35)" leading="" trailing=" " raw_val="n" val="n"/>
                  <IdentNode start="(101, 36)" end="(101, 44)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(101, 45)" end="(102, 75)">
          <AtomNode start="(101, 45)" end="(101, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(101, 48)" end="(102, 75)">
            <AtomNode start="(101, 48)" end="(101, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(102, 3)" end="(102, 75)">
              <TacticTacticseq1IndentedNode start="(102, 3)" end="(102, 75)">
                <NullNode start="(102, 3)" end="(102, 75)">
                  <OtherNode start="(102, 3)" end="(102, 75)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;l : List α&#10;⊢ (leftpad n a l).length = max n l.length" state_after="no goals" tactic="simp only [leftpad, length_append, length_replicate, Nat.sub_add_eq_max]">
                    <AtomNode start="(102, 3)" end="(102, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(102, 8)" end="(102, 12)">
                      <AtomNode start="(102, 8)" end="(102, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(102, 13)" end="(102, 75)">
                      <AtomNode start="(102, 13)" end="(102, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(102, 14)" end="(102, 74)">
                        <OtherNode start="(102, 14)" end="(102, 21)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(102, 14)" end="(102, 21)" leading="" trailing="" raw_val="leftpad" val="leftpad" full_name="List.leftpad" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(102, 21)" end="(102, 22)" leading="" trailing=" " val=","/>
                        <OtherNode start="(102, 23)" end="(102, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(102, 23)" end="(102, 36)" leading="" trailing="" raw_val="length_append" val="length_append" full_name="List.length_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(102, 36)" end="(102, 37)" leading="" trailing=" " val=","/>
                        <OtherNode start="(102, 38)" end="(102, 54)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(102, 38)" end="(102, 54)" leading="" trailing="" raw_val="length_replicate" val="length_replicate" full_name="List.length_replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(102, 54)" end="(102, 55)" leading="" trailing=" " val=","/>
                        <OtherNode start="(102, 56)" end="(102, 74)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(102, 56)" end="(102, 74)" leading="" trailing="" raw_val="Nat.sub_add_eq_max" val="Nat.sub_add_eq_max" full_name="Nat.sub_add_eq_max" mod_name="Init.Data.Nat.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(102, 74)" end="(102, 75)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(104, 1)" end="(105, 41)" name="leftpad_length" full_name="List.leftpad_length">
      <CommandDeclmodifiersNode start="(104, 1)" end="(104, 53)">
        <NullNode/>
        <NullNode start="(104, 1)" end="(104, 53)">
          <OtherNode start="(104, 1)" end="(104, 53)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(104, 1)" end="(104, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(104, 3)" end="(104, 52)">
              <OtherNode start="(104, 3)" end="(104, 52)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(104, 3)" end="(104, 52)" kind="Lean.deprecated">
                  <AtomNode start="(104, 3)" end="(104, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(104, 14)" end="(104, 28)">
                    <IdentNode start="(104, 14)" end="(104, 28)" leading="" trailing=" " raw_val="length_leftpad" val="length_leftpad" full_name="List.length_leftpad" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean" def_start="(100, 9)" def_end="(100, 23)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(104, 29)" end="(104, 52)">
                    <AtomNode start="(104, 29)" end="(104, 30)" leading="" trailing="" val="("/>
                    <AtomNode start="(104, 30)" end="(104, 35)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(104, 36)" end="(104, 38)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(104, 39)" end="(104, 51)" kind="str">
                      <AtomNode start="(104, 39)" end="(104, 51)" leading="" trailing="" val="&amp;quot;2025-02-24&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(104, 51)" end="(104, 52)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(104, 52)" end="(104, 53)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(105, 1)" end="(105, 41)" name="leftpad_length">
        <AtomNode start="(105, 1)" end="(105, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(105, 8)" end="(105, 22)">
          <IdentNode start="(105, 8)" end="(105, 22)" leading="" trailing=" " raw_val="leftpad_length" val="leftpad_length"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(105, 23)" end="(105, 41)">
          <AtomNode start="(105, 23)" end="(105, 25)" leading="" trailing=" " val=":="/>
          <OtherNode start="(105, 26)" end="(105, 41)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(105, 26)" end="(105, 27)" leading="" trailing="" val="@"/>
            <IdentNode start="(105, 27)" end="(105, 41)" leading="" trailing="&#10;&#10;" raw_val="length_leftpad" val="length_leftpad" full_name="List.length_leftpad" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean" def_start="(100, 9)" def_end="(100, 23)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(107, 1)" end="(110, 8)" name="length_rightpad" full_name="List.length_rightpad">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(107, 1)" end="(110, 8)" name="length_rightpad" full_name="List.length_rightpad" _is_private_decl="False">
        <AtomNode start="(107, 1)" end="(107, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(107, 9)" end="(107, 24)">
          <IdentNode start="(107, 9)" end="(107, 24)" leading="" trailing=" " raw_val="length_rightpad" val="length_rightpad"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(107, 25)" end="(108, 45)">
          <NullNode start="(107, 25)" end="(107, 55)">
            <OtherNode start="(107, 25)" end="(107, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(107, 25)" end="(107, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(107, 26)" end="(107, 27)">
                <IdentNode start="(107, 26)" end="(107, 27)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(107, 28)" end="(107, 33)">
                <AtomNode start="(107, 28)" end="(107, 29)" leading="" trailing=" " val=":"/>
                <IdentNode start="(107, 30)" end="(107, 33)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(107, 33)" end="(107, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(107, 35)" end="(107, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(107, 35)" end="(107, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(107, 36)" end="(107, 37)">
                <IdentNode start="(107, 36)" end="(107, 37)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(107, 38)" end="(107, 41)">
                <AtomNode start="(107, 38)" end="(107, 39)" leading="" trailing=" " val=":"/>
                <IdentNode start="(107, 40)" end="(107, 41)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(107, 41)" end="(107, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(107, 43)" end="(107, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(107, 43)" end="(107, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(107, 44)" end="(107, 45)">
                <IdentNode start="(107, 44)" end="(107, 45)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(107, 46)" end="(107, 54)">
                <AtomNode start="(107, 46)" end="(107, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(107, 48)" end="(107, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(107, 48)" end="(107, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(107, 53)" end="(107, 54)">
                    <IdentNode start="(107, 53)" end="(107, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(107, 54)" end="(107, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(107, 56)" end="(108, 45)">
            <AtomNode start="(107, 56)" end="(107, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(108, 5)" end="(108, 45)" kind="«term_=_»">
              <OtherNode start="(108, 5)" end="(108, 28)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(108, 5)" end="(108, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(108, 5)" end="(108, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(108, 6)" end="(108, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(108, 6)" end="(108, 14)" leading="" trailing=" " raw_val="rightpad" val="rightpad" full_name="List.rightpad" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(108, 15)" end="(108, 20)">
                      <IdentNode start="(108, 15)" end="(108, 16)" leading="" trailing=" " raw_val="n" val="n"/>
                      <IdentNode start="(108, 17)" end="(108, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                      <IdentNode start="(108, 19)" end="(108, 20)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(108, 20)" end="(108, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(108, 21)" end="(108, 22)" leading="" trailing="" val="."/>
                <IdentNode start="(108, 22)" end="(108, 28)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(108, 29)" end="(108, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(108, 31)" end="(108, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(108, 31)" end="(108, 34)" leading="" trailing=" " raw_val="max" val="max" full_name="Max.max" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(108, 35)" end="(108, 45)">
                  <IdentNode start="(108, 35)" end="(108, 36)" leading="" trailing=" " raw_val="n" val="n"/>
                  <IdentNode start="(108, 37)" end="(108, 45)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(108, 46)" end="(110, 8)">
          <AtomNode start="(108, 46)" end="(108, 48)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(108, 49)" end="(110, 8)">
            <AtomNode start="(108, 49)" end="(108, 51)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(109, 3)" end="(110, 8)">
              <TacticTacticseq1IndentedNode start="(109, 3)" end="(110, 8)">
                <NullNode start="(109, 3)" end="(110, 8)">
                  <OtherNode start="(109, 3)" end="(109, 18)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;l : List α&#10;⊢ (rightpad n a l).length = max n l.length" state_after="α : Type u_1&#10;n : Nat&#10;a : α&#10;l : List α&#10;⊢ l.length + (n - l.length) = max n l.length" tactic="simp [rightpad]">
                    <AtomNode start="(109, 3)" end="(109, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(109, 8)" end="(109, 18)">
                      <AtomNode start="(109, 8)" end="(109, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(109, 9)" end="(109, 17)">
                        <OtherNode start="(109, 9)" end="(109, 17)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(109, 9)" end="(109, 17)" leading="" trailing="" raw_val="rightpad" val="rightpad" full_name="List.rightpad" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(109, 17)" end="(109, 18)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(110, 3)" end="(110, 8)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;l : List α&#10;⊢ l.length + (n - l.length) = max n l.length" state_after="no goals" tactic="omega">
                    <AtomNode start="(110, 3)" end="(110, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(112, 1)" end="(112, 20)" comment="### eraseIdx -/">
      <AtomNode start="(112, 1)" end="(112, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(112, 5)" end="(112, 20)" leading="" trailing="&#10;&#10;" val="### eraseIdx -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(114, 1)" end="(123, 82)" name="mem_eraseIdx_iff_getElem" full_name="List.mem_eraseIdx_iff_getElem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(114, 1)" end="(123, 82)" name="mem_eraseIdx_iff_getElem" full_name="List.mem_eraseIdx_iff_getElem" _is_private_decl="False">
        <AtomNode start="(114, 1)" end="(114, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(114, 9)" end="(114, 33)">
          <IdentNode start="(114, 9)" end="(114, 33)" leading="" trailing=" " raw_val="mem_eraseIdx_iff_getElem" val="mem_eraseIdx_iff_getElem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(114, 34)" end="(115, 60)">
          <NullNode start="(114, 34)" end="(114, 41)">
            <OtherNode start="(114, 34)" end="(114, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(114, 34)" end="(114, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(114, 35)" end="(114, 36)">
                <IdentNode start="(114, 35)" end="(114, 36)" leading="" trailing=" " raw_val="x" val="x"/>
              </NullNode>
              <NullNode start="(114, 37)" end="(114, 40)">
                <AtomNode start="(114, 37)" end="(114, 38)" leading="" trailing=" " val=":"/>
                <IdentNode start="(114, 39)" end="(114, 40)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(114, 40)" end="(114, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(114, 42)" end="(115, 60)">
            <AtomNode start="(114, 42)" end="(114, 43)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(115, 5)" end="(115, 60)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(115, 5)" end="(115, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(115, 7)" end="(115, 14)">
                <OtherNode start="(115, 7)" end="(115, 10)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(115, 7)" end="(115, 8)" leading="" trailing="" val="{"/>
                  <NullNode start="(115, 8)" end="(115, 9)">
                    <IdentNode start="(115, 8)" end="(115, 9)" leading="" trailing="" raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(115, 9)" end="(115, 10)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(115, 11)" end="(115, 14)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(115, 11)" end="(115, 12)" leading="" trailing="" val="{"/>
                  <NullNode start="(115, 12)" end="(115, 13)">
                    <IdentNode start="(115, 12)" end="(115, 13)" leading="" trailing="" raw_val="k" val="k"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(115, 13)" end="(115, 14)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(115, 14)" end="(115, 15)" leading="" trailing=" " val=","/>
              <OtherNode start="(115, 16)" end="(115, 60)" kind="«term_↔_»">
                <OtherNode start="(115, 16)" end="(115, 32)" kind="«term_∈_»">
                  <IdentNode start="(115, 16)" end="(115, 17)" leading="" trailing=" " raw_val="x" val="x"/>
                  <AtomNode start="(115, 18)" end="(115, 19)" leading="" trailing=" " val="∈"/>
                  <OtherNode start="(115, 20)" end="(115, 32)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(115, 20)" end="(115, 28)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(115, 29)" end="(115, 32)">
                      <IdentNode start="(115, 29)" end="(115, 30)" leading="" trailing=" " raw_val="l" val="l"/>
                      <IdentNode start="(115, 31)" end="(115, 32)" leading="" trailing=" " raw_val="k" val="k"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(115, 33)" end="(115, 34)" leading="" trailing=" " val="↔"/>
                <OtherNode start="(115, 35)" end="(115, 60)" kind="«term∃_,_»">
                  <AtomNode start="(115, 35)" end="(115, 36)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(115, 37)" end="(115, 40)" kind="Lean.explicitBinders">
                    <OtherNode start="(115, 37)" end="(115, 40)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(115, 37)" end="(115, 40)">
                        <LeanBinderidentNode start="(115, 37)" end="(115, 38)">
                          <IdentNode start="(115, 37)" end="(115, 38)" leading="" trailing=" " raw_val="i" val="i"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(115, 39)" end="(115, 40)">
                          <IdentNode start="(115, 39)" end="(115, 40)" leading="" trailing="" raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(115, 40)" end="(115, 41)" leading="" trailing=" " val=","/>
                  <OtherNode start="(115, 42)" end="(115, 60)" kind="«term_∧_»">
                    <OtherNode start="(115, 42)" end="(115, 47)" kind="«term_≠_»">
                      <IdentNode start="(115, 42)" end="(115, 43)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(115, 44)" end="(115, 45)" leading="" trailing=" " val="≠"/>
                      <IdentNode start="(115, 46)" end="(115, 47)" leading="" trailing=" " raw_val="k" val="k"/>
                    </OtherNode>
                    <AtomNode start="(115, 48)" end="(115, 49)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(115, 50)" end="(115, 60)" kind="«term_=_»">
                      <OtherNode start="(115, 50)" end="(115, 56)" kind="«term__[_]'_»">
                        <IdentNode start="(115, 50)" end="(115, 51)" leading="" trailing="" raw_val="l" val="l"/>
                        <AtomNode start="(115, 51)" end="(115, 52)" leading="" trailing="" val="["/>
                        <IdentNode start="(115, 52)" end="(115, 53)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(115, 53)" end="(115, 55)" leading="" trailing="" val="]'"/>
                        <IdentNode start="(115, 55)" end="(115, 56)" leading="" trailing=" " raw_val="h" val="h"/>
                      </OtherNode>
                      <AtomNode start="(115, 57)" end="(115, 58)" leading="" trailing=" " val="="/>
                      <IdentNode start="(115, 59)" end="(115, 60)" leading="" trailing="&#10;  " raw_val="x" val="x"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(116, 3)" end="(123, 82)">
          <OtherNode start="(116, 3)" end="(123, 82)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(116, 3)" end="(123, 82)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(116, 3)" end="(123, 82)">
                <OtherNode start="(116, 3)" end="(119, 30)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(116, 3)" end="(116, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(116, 5)" end="(116, 10)">
                    <NullNode start="(116, 5)" end="(116, 10)">
                      <OtherNode start="(116, 5)" end="(116, 7)" kind="«term[_]»">
                        <AtomNode start="(116, 5)" end="(116, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(116, 6)" end="(116, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(116, 7)" end="(116, 8)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(116, 9)" end="(116, 10)">
                        <AtomNode start="(116, 9)" end="(116, 10)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(116, 11)" end="(116, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(116, 14)" end="(119, 30)">
                    <AtomNode start="(116, 14)" end="(116, 16)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(117, 5)" end="(119, 30)">
                      <TacticTacticseq1IndentedNode start="(117, 5)" end="(119, 30)">
                        <NullNode start="(117, 5)" end="(119, 30)">
                          <OtherNode start="(117, 5)" end="(117, 49)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;x : α&#10;x✝ : Nat&#10;⊢ x ∈ [].eraseIdx x✝ ↔ ∃ i h, i ≠ x✝ ∧ [][i] = x" state_after="α : Type u_1&#10;x : α&#10;x✝ : Nat&#10;⊢ ¬∃ i h, i ≠ x✝ ∧ [][i] = x" tactic="simp only [eraseIdx, not_mem_nil, false_iff]">
                            <AtomNode start="(117, 5)" end="(117, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(117, 10)" end="(117, 14)">
                              <AtomNode start="(117, 10)" end="(117, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(117, 15)" end="(117, 49)">
                              <AtomNode start="(117, 15)" end="(117, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(117, 16)" end="(117, 48)">
                                <OtherNode start="(117, 16)" end="(117, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(117, 16)" end="(117, 24)" leading="" trailing="" raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(117, 24)" end="(117, 25)" leading="" trailing=" " val=","/>
                                <OtherNode start="(117, 26)" end="(117, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(117, 26)" end="(117, 37)" leading="" trailing="" raw_val="not_mem_nil" val="not_mem_nil" full_name="List.not_mem_nil" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(117, 37)" end="(117, 38)" leading="" trailing=" " val=","/>
                                <OtherNode start="(117, 39)" end="(117, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(117, 39)" end="(117, 48)" leading="" trailing="" raw_val="false_iff" val="false_iff" full_name="false_iff" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(117, 48)" end="(117, 49)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(118, 5)" end="(118, 21)" kind="Lean.Parser.Tactic.rintro" state_before="α : Type u_1&#10;x : α&#10;x✝ : Nat&#10;⊢ ¬∃ i h, i ≠ x✝ ∧ [][i] = x" state_after="case intro.intro&#10;α : Type u_1&#10;x : α&#10;x✝ i : Nat&#10;h : i &amp;lt; [].length&#10;⊢ False" tactic="rintro ⟨i, h, -⟩">
                            <AtomNode start="(118, 5)" end="(118, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(118, 12)" end="(118, 21)">
                              <OtherNode start="(118, 12)" end="(118, 21)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(118, 12)" end="(118, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(118, 12)" end="(118, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(118, 13)" end="(118, 20)">
                                    <OtherNode start="(118, 13)" end="(118, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(118, 13)" end="(118, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(118, 13)" end="(118, 14)">
                                          <OtherNode start="(118, 13)" end="(118, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(118, 13)" end="(118, 14)" leading="" trailing="" raw_val="i" val="i"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(118, 14)" end="(118, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(118, 16)" end="(118, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(118, 16)" end="(118, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(118, 16)" end="(118, 17)">
                                          <OtherNode start="(118, 16)" end="(118, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(118, 16)" end="(118, 17)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(118, 17)" end="(118, 18)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(118, 19)" end="(118, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(118, 19)" end="(118, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(118, 19)" end="(118, 20)">
                                          <OtherNode start="(118, 19)" end="(118, 20)" kind="Lean.Parser.Tactic.rcasesPat.clear">
                                            <AtomNode start="(118, 19)" end="(118, 20)" leading="" trailing="" val="-"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(118, 20)" end="(118, 21)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(119, 5)" end="(119, 30)" kind="Lean.Parser.Tactic.exact" state_before="case intro.intro&#10;α : Type u_1&#10;x : α&#10;x✝ i : Nat&#10;h : i &amp;lt; [].length&#10;⊢ False" state_after="no goals" tactic="exact Nat.not_lt_zero _ h">
                            <AtomNode start="(119, 5)" end="(119, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(119, 11)" end="(119, 30)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(119, 11)" end="(119, 26)" leading="" trailing=" " raw_val="Nat.not_lt_zero" val="Nat.not_lt_zero" full_name="Nat.not_lt_zero" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(119, 27)" end="(119, 30)">
                                <TermHoleNode start="(119, 27)" end="(119, 28)">
                                  <AtomNode start="(119, 27)" end="(119, 28)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <IdentNode start="(119, 29)" end="(119, 30)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(120, 3)" end="(120, 63)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(120, 3)" end="(120, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(120, 5)" end="(120, 12)">
                    <NullNode start="(120, 5)" end="(120, 12)">
                      <OtherNode start="(120, 5)" end="(120, 9)" kind="«term_::_»">
                        <IdentNode start="(120, 5)" end="(120, 6)" leading="" trailing="" raw_val="a" val="a"/>
                        <AtomNode start="(120, 6)" end="(120, 8)" leading="" trailing="" val="::"/>
                        <IdentNode start="(120, 8)" end="(120, 9)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(120, 9)" end="(120, 10)" leading="" trailing=" " val=","/>
                      <OtherNode start="(120, 11)" end="(120, 12)" kind="num">
                        <AtomNode start="(120, 11)" end="(120, 12)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(120, 13)" end="(120, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(120, 16)" end="(120, 63)">
                    <AtomNode start="(120, 16)" end="(120, 18)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(120, 19)" end="(120, 63)">
                      <TacticTacticseq1IndentedNode start="(120, 19)" end="(120, 63)">
                        <NullNode start="(120, 19)" end="(120, 63)">
                          <OtherNode start="(120, 19)" end="(120, 63)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;x a : α&#10;l : List α&#10;⊢ x ∈ (a :: l).eraseIdx 0 ↔ ∃ i h, i ≠ 0 ∧ (a :: l)[i] = x" state_after="no goals" tactic="simp [mem_iff_getElem, Nat.succ_lt_succ_iff]">
                            <AtomNode start="(120, 19)" end="(120, 23)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(120, 24)" end="(120, 63)">
                              <AtomNode start="(120, 24)" end="(120, 25)" leading="" trailing="" val="["/>
                              <NullNode start="(120, 25)" end="(120, 62)">
                                <OtherNode start="(120, 25)" end="(120, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(120, 25)" end="(120, 40)" leading="" trailing="" raw_val="mem_iff_getElem" val="mem_iff_getElem" full_name="List.mem_iff_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(120, 40)" end="(120, 41)" leading="" trailing=" " val=","/>
                                <OtherNode start="(120, 42)" end="(120, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(120, 42)" end="(120, 62)" leading="" trailing="" raw_val="Nat.succ_lt_succ_iff" val="Nat.succ_lt_succ_iff" full_name="Nat.succ_lt_succ_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(120, 62)" end="(120, 63)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(121, 3)" end="(123, 82)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(121, 3)" end="(121, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(121, 5)" end="(121, 14)">
                    <NullNode start="(121, 5)" end="(121, 14)">
                      <OtherNode start="(121, 5)" end="(121, 9)" kind="«term_::_»">
                        <IdentNode start="(121, 5)" end="(121, 6)" leading="" trailing="" raw_val="a" val="a"/>
                        <AtomNode start="(121, 6)" end="(121, 8)" leading="" trailing="" val="::"/>
                        <IdentNode start="(121, 8)" end="(121, 9)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(121, 9)" end="(121, 10)" leading="" trailing=" " val=","/>
                      <OtherNode start="(121, 11)" end="(121, 14)" kind="«term_+_»">
                        <IdentNode start="(121, 11)" end="(121, 12)" leading="" trailing="" raw_val="k" val="k"/>
                        <AtomNode start="(121, 12)" end="(121, 13)" leading="" trailing="" val="+"/>
                        <OtherNode start="(121, 13)" end="(121, 14)" kind="num">
                          <AtomNode start="(121, 13)" end="(121, 14)" leading="" trailing=" " val="1"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(121, 15)" end="(121, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(121, 18)" end="(123, 82)">
                    <AtomNode start="(121, 18)" end="(121, 20)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(122, 5)" end="(123, 82)">
                      <TacticTacticseq1IndentedNode start="(122, 5)" end="(123, 82)">
                        <NullNode start="(122, 5)" end="(123, 82)">
                          <OtherNode start="(122, 5)" end="(122, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;x a : α&#10;l : List α&#10;k : Nat&#10;⊢ x ∈ (a :: l).eraseIdx (k + 1) ↔ ∃ i h, i ≠ k + 1 ∧ (a :: l)[i] = x" state_after="α : Type u_1&#10;x a : α&#10;l : List α&#10;k : Nat&#10;⊢ x ∈ (a :: l).eraseIdx (k + 1) ↔ (∃ h, 0 ≠ k + 1 ∧ (a :: l)[0] = x) ∨ ∃ n h, n + 1 ≠ k + 1 ∧ (a :: l)[n + 1] = x" tactic="rw [← Nat.or_exists_add_one]">
                            <AtomNode start="(122, 5)" end="(122, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(122, 8)" end="(122, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(122, 8)" end="(122, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(122, 9)" end="(122, 32)">
                                <OtherNode start="(122, 9)" end="(122, 32)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode start="(122, 9)" end="(122, 10)">
                                    <OtherNode start="(122, 9)" end="(122, 10)" kind="patternIgnore">
                                      <OtherNode start="(122, 9)" end="(122, 10)" kind="token.«← »">
                                        <AtomNode start="(122, 9)" end="(122, 10)" leading="" trailing=" " val="←"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <IdentNode start="(122, 11)" end="(122, 32)" leading="" trailing="" raw_val="Nat.or_exists_add_one" val="Nat.or_exists_add_one" full_name="Nat.or_exists_add_one" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(122, 32)" end="(122, 33)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(123, 5)" end="(123, 82)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;x a : α&#10;l : List α&#10;k : Nat&#10;⊢ x ∈ (a :: l).eraseIdx (k + 1) ↔ (∃ h, 0 ≠ k + 1 ∧ (a :: l)[0] = x) ∨ ∃ n h, n + 1 ≠ k + 1 ∧ (a :: l)[n + 1] = x" state_after="no goals" tactic="simp [mem_eraseIdx_iff_getElem, @eq_comm _ a, succ_inj, Nat.succ_lt_succ_iff]">
                            <AtomNode start="(123, 5)" end="(123, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(123, 10)" end="(123, 82)">
                              <AtomNode start="(123, 10)" end="(123, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(123, 11)" end="(123, 81)">
                                <OtherNode start="(123, 11)" end="(123, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(123, 11)" end="(123, 35)" leading="" trailing="" raw_val="mem_eraseIdx_iff_getElem" val="mem_eraseIdx_iff_getElem"/>
                                </OtherNode>
                                <AtomNode start="(123, 35)" end="(123, 36)" leading="" trailing=" " val=","/>
                                <OtherNode start="(123, 37)" end="(123, 49)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(123, 37)" end="(123, 49)" kind="Lean.Parser.Term.app">
                                    <OtherNode start="(123, 37)" end="(123, 45)" kind="Lean.Parser.Term.explicit">
                                      <AtomNode start="(123, 37)" end="(123, 38)" leading="" trailing="" val="@"/>
                                      <IdentNode start="(123, 38)" end="(123, 45)" leading="" trailing=" " raw_val="eq_comm" val="eq_comm" full_name="eq_comm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                    </OtherNode>
                                    <NullNode start="(123, 46)" end="(123, 49)">
                                      <TermHoleNode start="(123, 46)" end="(123, 47)">
                                        <AtomNode start="(123, 46)" end="(123, 47)" leading="" trailing=" " val="_"/>
                                      </TermHoleNode>
                                      <IdentNode start="(123, 48)" end="(123, 49)" leading="" trailing="" raw_val="a" val="a"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(123, 49)" end="(123, 50)" leading="" trailing=" " val=","/>
                                <OtherNode start="(123, 51)" end="(123, 59)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(123, 51)" end="(123, 59)" leading="" trailing="" raw_val="succ_inj" val="succ_inj" full_name="Nat.succ_inj" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(123, 59)" end="(123, 60)" leading="" trailing=" " val=","/>
                                <OtherNode start="(123, 61)" end="(123, 81)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(123, 61)" end="(123, 81)" leading="" trailing="" raw_val="Nat.succ_lt_succ_iff" val="Nat.succ_lt_succ_iff" full_name="Nat.succ_lt_succ_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(123, 81)" end="(123, 82)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(125, 1)" end="(132, 18)" name="mem_eraseIdx_iff_getElem?" full_name="List.mem_eraseIdx_iff_getElem?">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(125, 1)" end="(132, 18)" name="mem_eraseIdx_iff_getElem?" full_name="List.mem_eraseIdx_iff_getElem?" _is_private_decl="False">
        <AtomNode start="(125, 1)" end="(125, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(125, 9)" end="(125, 34)">
          <IdentNode start="(125, 9)" end="(125, 34)" leading="" trailing=" " raw_val="mem_eraseIdx_iff_getElem?" val="mem_eraseIdx_iff_getElem?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(125, 35)" end="(125, 95)">
          <NullNode start="(125, 35)" end="(125, 50)">
            <OtherNode start="(125, 35)" end="(125, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(125, 35)" end="(125, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(125, 36)" end="(125, 37)">
                <IdentNode start="(125, 36)" end="(125, 37)" leading="" trailing=" " raw_val="x" val="x"/>
              </NullNode>
              <NullNode start="(125, 38)" end="(125, 41)">
                <AtomNode start="(125, 38)" end="(125, 39)" leading="" trailing=" " val=":"/>
                <IdentNode start="(125, 40)" end="(125, 41)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(125, 41)" end="(125, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(125, 43)" end="(125, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(125, 43)" end="(125, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(125, 44)" end="(125, 45)">
                <IdentNode start="(125, 44)" end="(125, 45)" leading="" trailing="" raw_val="l" val="l"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(125, 45)" end="(125, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(125, 47)" end="(125, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(125, 47)" end="(125, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(125, 48)" end="(125, 49)">
                <IdentNode start="(125, 48)" end="(125, 49)" leading="" trailing="" raw_val="k" val="k"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(125, 49)" end="(125, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(125, 51)" end="(125, 95)">
            <AtomNode start="(125, 51)" end="(125, 52)" leading="" trailing=" " val=":"/>
            <OtherNode start="(125, 53)" end="(125, 95)" kind="«term_↔_»">
              <OtherNode start="(125, 53)" end="(125, 69)" kind="«term_∈_»">
                <IdentNode start="(125, 53)" end="(125, 54)" leading="" trailing=" " raw_val="x" val="x"/>
                <AtomNode start="(125, 55)" end="(125, 56)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(125, 57)" end="(125, 69)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(125, 57)" end="(125, 65)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(125, 66)" end="(125, 69)">
                    <IdentNode start="(125, 66)" end="(125, 67)" leading="" trailing=" " raw_val="l" val="l"/>
                    <IdentNode start="(125, 68)" end="(125, 69)" leading="" trailing=" " raw_val="k" val="k"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(125, 70)" end="(125, 71)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(125, 72)" end="(125, 95)" kind="Lean.«term∃__,_»">
                <AtomNode start="(125, 72)" end="(125, 73)" leading="" trailing=" " val="∃"/>
                <LeanBinderidentNode start="(125, 74)" end="(125, 75)">
                  <IdentNode start="(125, 74)" end="(125, 75)" leading="" trailing=" " raw_val="i" val="i"/>
                </LeanBinderidentNode>
                <OtherNode start="(125, 76)" end="(125, 79)" kind="Lean.«binderTerm≠_»">
                  <AtomNode start="(125, 76)" end="(125, 77)" leading="" trailing=" " val="≠"/>
                  <IdentNode start="(125, 78)" end="(125, 79)" leading="" trailing="" raw_val="k" val="k"/>
                </OtherNode>
                <AtomNode start="(125, 79)" end="(125, 80)" leading="" trailing=" " val=","/>
                <OtherNode start="(125, 81)" end="(125, 95)" kind="«term_=_»">
                  <OtherNode start="(125, 81)" end="(125, 86)" kind="«term__[_]_?»">
                    <IdentNode start="(125, 81)" end="(125, 82)" leading="" trailing="" raw_val="l" val="l"/>
                    <GroupNode/>
                    <AtomNode start="(125, 82)" end="(125, 83)" leading="" trailing="" val="["/>
                    <IdentNode start="(125, 83)" end="(125, 84)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(125, 84)" end="(125, 85)" leading="" trailing="" val="]"/>
                    <GroupNode/>
                    <AtomNode start="(125, 85)" end="(125, 86)" leading="" trailing=" " val="?"/>
                  </OtherNode>
                  <AtomNode start="(125, 87)" end="(125, 88)" leading="" trailing=" " val="="/>
                  <OtherNode start="(125, 89)" end="(125, 95)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(125, 89)" end="(125, 93)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(125, 94)" end="(125, 95)">
                      <IdentNode start="(125, 94)" end="(125, 95)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(125, 96)" end="(132, 18)">
          <AtomNode start="(125, 96)" end="(125, 98)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(125, 99)" end="(132, 18)">
            <AtomNode start="(125, 99)" end="(125, 101)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(126, 3)" end="(132, 18)">
              <TacticTacticseq1IndentedNode start="(126, 3)" end="(132, 18)">
                <NullNode start="(126, 3)" end="(132, 18)">
                  <OtherNode start="(126, 3)" end="(126, 72)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;x : α&#10;l : List α&#10;k : Nat&#10;⊢ x ∈ l.eraseIdx k ↔ ∃ i, i ≠ k ∧ l[i]? = some x" state_after="α : Type u_1&#10;x : α&#10;l : List α&#10;k : Nat&#10;⊢ (∃ i, i ≠ k ∧ ∃ x_1, l[i]? = some x) ↔ ∃ i, i ≠ k ∧ l[i]? = some x" tactic="simp only [mem_eraseIdx_iff_getElem, getElem_eq_iff, exists_and_left]">
                    <AtomNode start="(126, 3)" end="(126, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(126, 8)" end="(126, 12)">
                      <AtomNode start="(126, 8)" end="(126, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(126, 13)" end="(126, 72)">
                      <AtomNode start="(126, 13)" end="(126, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(126, 14)" end="(126, 71)">
                        <OtherNode start="(126, 14)" end="(126, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(126, 14)" end="(126, 38)" leading="" trailing="" raw_val="mem_eraseIdx_iff_getElem" val="mem_eraseIdx_iff_getElem" full_name="List.mem_eraseIdx_iff_getElem" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean" def_start="(114, 9)" def_end="(114, 33)"/>
                        </OtherNode>
                        <AtomNode start="(126, 38)" end="(126, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(126, 40)" end="(126, 54)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(126, 40)" end="(126, 54)" leading="" trailing="" raw_val="getElem_eq_iff" val="getElem_eq_iff" full_name="List.getElem_eq_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(126, 54)" end="(126, 55)" leading="" trailing=" " val=","/>
                        <OtherNode start="(126, 56)" end="(126, 71)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(126, 56)" end="(126, 71)" leading="" trailing="" raw_val="exists_and_left" val="exists_and_left" full_name="exists_and_left" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(126, 71)" end="(126, 72)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(127, 3)" end="(127, 51)" kind="Lean.Parser.Tactic.refine" state_before="α : Type u_1&#10;x : α&#10;l : List α&#10;k : Nat&#10;⊢ (∃ i, i ≠ k ∧ ∃ x_1, l[i]? = some x) ↔ ∃ i, i ≠ k ∧ l[i]? = some x" state_after="α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;⊢ (∃ x_1, l[i]? = some x) ↔ l[i]? = some x" tactic="refine exists_congr fun i =&amp;gt; and_congr_right' ?_">
                    <AtomNode start="(127, 3)" end="(127, 9)" leading="" trailing=" " val="refine"/>
                    <OtherNode start="(127, 10)" end="(127, 51)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(127, 10)" end="(127, 22)" leading="" trailing=" " raw_val="exists_congr" val="exists_congr" full_name="exists_congr" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                      <NullNode start="(127, 23)" end="(127, 51)">
                        <OtherNode start="(127, 23)" end="(127, 51)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(127, 23)" end="(127, 26)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(127, 27)" end="(127, 51)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(127, 27)" end="(127, 28)">
                              <IdentNode start="(127, 27)" end="(127, 28)" leading="" trailing=" " raw_val="i" val="i"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(127, 29)" end="(127, 31)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(127, 32)" end="(127, 51)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(127, 32)" end="(127, 48)" leading="" trailing=" " raw_val="and_congr_right'" val="and_congr_right'" full_name="and_congr_right'" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                              <NullNode start="(127, 49)" end="(127, 51)">
                                <OtherNode start="(127, 49)" end="(127, 51)" kind="Lean.Parser.Term.syntheticHole">
                                  <AtomNode start="(127, 49)" end="(127, 50)" leading="" trailing="" val="?"/>
                                  <AtomNode start="(127, 50)" end="(127, 51)" leading="" trailing="&#10;  " val="_"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(128, 3)" end="(128, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;⊢ (∃ x_1, l[i]? = some x) ↔ l[i]? = some x" state_after="case mp&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;⊢ (∃ x_1, l[i]? = some x) → l[i]? = some x&#10;&#10;case mpr&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;⊢ l[i]? = some x → ∃ x_1, l[i]? = some x" tactic="constructor">
                    <AtomNode start="(128, 3)" end="(128, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(129, 3)" end="(129, 27)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;⊢ (∃ x_1, l[i]? = some x) → l[i]? = some x&#10;&#10;case mpr&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;⊢ l[i]? = some x → ∃ x_1, l[i]? = some x" state_after="case mpr&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;⊢ l[i]? = some x → ∃ x_1, l[i]? = some x" tactic="· rintro ⟨_, h⟩; exact h">
                    <OtherNode start="(129, 3)" end="(129, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(129, 3)" end="(129, 4)" kind="patternIgnore">
                        <OtherNode start="(129, 3)" end="(129, 4)" kind="token.«· »">
                          <AtomNode start="(129, 3)" end="(129, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(129, 5)" end="(129, 27)">
                      <TacticTacticseq1IndentedNode start="(129, 5)" end="(129, 27)">
                        <NullNode start="(129, 5)" end="(129, 27)">
                          <OtherNode start="(129, 5)" end="(129, 18)" kind="Lean.Parser.Tactic.rintro" state_before="case mp&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;⊢ (∃ x_1, l[i]? = some x) → l[i]? = some x" state_after="case mp.intro&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;w✝ : i &amp;lt; l.length&#10;h : l[i]? = some x&#10;⊢ l[i]? = some x" tactic="rintro ⟨_, h⟩">
                            <AtomNode start="(129, 5)" end="(129, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(129, 12)" end="(129, 18)">
                              <OtherNode start="(129, 12)" end="(129, 18)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(129, 12)" end="(129, 18)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(129, 12)" end="(129, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(129, 13)" end="(129, 17)">
                                    <OtherNode start="(129, 13)" end="(129, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(129, 13)" end="(129, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(129, 13)" end="(129, 14)">
                                          <OtherNode start="(129, 13)" end="(129, 14)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                            <AtomNode start="(129, 13)" end="(129, 14)" leading="" trailing="" val="_"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(129, 14)" end="(129, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(129, 16)" end="(129, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(129, 16)" end="(129, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(129, 16)" end="(129, 17)">
                                          <OtherNode start="(129, 16)" end="(129, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(129, 16)" end="(129, 17)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(129, 17)" end="(129, 18)" leading="" trailing="" val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(129, 18)" end="(129, 19)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(129, 20)" end="(129, 27)" kind="Lean.Parser.Tactic.exact" state_before="case mp.intro&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;w✝ : i &amp;lt; l.length&#10;h : l[i]? = some x&#10;⊢ l[i]? = some x" state_after="no goals" tactic="exact h">
                            <AtomNode start="(129, 20)" end="(129, 25)" leading="" trailing=" " val="exact"/>
                            <IdentNode start="(129, 26)" end="(129, 27)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(130, 3)" end="(132, 18)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;⊢ l[i]? = some x → ∃ x_1, l[i]? = some x" state_after="no goals" tactic="· rintro h;&#10;  obtain ⟨h', -⟩ := getElem?_eq_some_iff.1 h&#10;  exact ⟨h', h⟩">
                    <OtherNode start="(130, 3)" end="(130, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(130, 3)" end="(130, 4)" kind="patternIgnore">
                        <OtherNode start="(130, 3)" end="(130, 4)" kind="token.«· »">
                          <AtomNode start="(130, 3)" end="(130, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(130, 5)" end="(132, 18)">
                      <TacticTacticseq1IndentedNode start="(130, 5)" end="(132, 18)">
                        <NullNode start="(130, 5)" end="(132, 18)">
                          <OtherNode start="(130, 5)" end="(130, 13)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;⊢ l[i]? = some x → ∃ x_1, l[i]? = some x" state_after="case mpr&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;h : l[i]? = some x&#10;⊢ ∃ x_1, l[i]? = some x" tactic="rintro h">
                            <AtomNode start="(130, 5)" end="(130, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(130, 12)" end="(130, 13)">
                              <OtherNode start="(130, 12)" end="(130, 13)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(130, 12)" end="(130, 13)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(130, 12)" end="(130, 13)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(130, 13)" end="(130, 14)" leading="" trailing="&#10;    " val=";"/>
                          <OtherNode start="(131, 5)" end="(131, 47)" kind="Lean.Parser.Tactic.obtain" state_before="case mpr&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;h : l[i]? = some x&#10;⊢ ∃ x_1, l[i]? = some x" state_after="case mpr.intro&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;h : l[i]? = some x&#10;h' : i &amp;lt; l.length&#10;⊢ ∃ x_1, l[i]? = some x" tactic="obtain ⟨h', -⟩ := getElem?_eq_some_iff.1 h">
                            <AtomNode start="(131, 5)" end="(131, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(131, 12)" end="(131, 19)">
                              <OtherNode start="(131, 12)" end="(131, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(131, 12)" end="(131, 19)">
                                  <OtherNode start="(131, 12)" end="(131, 19)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(131, 12)" end="(131, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(131, 13)" end="(131, 18)">
                                      <OtherNode start="(131, 13)" end="(131, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(131, 13)" end="(131, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(131, 13)" end="(131, 15)">
                                            <OtherNode start="(131, 13)" end="(131, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(131, 13)" end="(131, 15)" leading="" trailing="" raw_val="h'" val="h'"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(131, 15)" end="(131, 16)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(131, 17)" end="(131, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(131, 17)" end="(131, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(131, 17)" end="(131, 18)">
                                            <OtherNode start="(131, 17)" end="(131, 18)" kind="Lean.Parser.Tactic.rcasesPat.clear">
                                              <AtomNode start="(131, 17)" end="(131, 18)" leading="" trailing="" val="-"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(131, 18)" end="(131, 19)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(131, 20)" end="(131, 47)">
                              <AtomNode start="(131, 20)" end="(131, 22)" leading="" trailing=" " val=":="/>
                              <NullNode start="(131, 23)" end="(131, 47)">
                                <OtherNode start="(131, 23)" end="(131, 47)" kind="Lean.Parser.Term.app">
                                  <OtherNode start="(131, 23)" end="(131, 45)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(131, 23)" end="(131, 43)" leading="" trailing="" raw_val="getElem?_eq_some_iff" val="getElem?_eq_some_iff" full_name="List.getElem?_eq_some_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                    <AtomNode start="(131, 43)" end="(131, 44)" leading="" trailing="" val="."/>
                                    <OtherNode start="(131, 44)" end="(131, 45)" kind="fieldIdx">
                                      <AtomNode start="(131, 44)" end="(131, 45)" leading="" trailing=" " val="1"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode start="(131, 46)" end="(131, 47)">
                                    <IdentNode start="(131, 46)" end="(131, 47)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(132, 5)" end="(132, 18)" kind="Lean.Parser.Tactic.exact" state_before="case mpr.intro&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;k i : Nat&#10;h : l[i]? = some x&#10;h' : i &amp;lt; l.length&#10;⊢ ∃ x_1, l[i]? = some x" state_after="no goals" tactic="exact ⟨h', h⟩">
                            <AtomNode start="(132, 5)" end="(132, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(132, 11)" end="(132, 18)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(132, 11)" end="(132, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(132, 12)" end="(132, 17)">
                                <IdentNode start="(132, 12)" end="(132, 14)" leading="" trailing="" raw_val="h'" val="h'"/>
                                <AtomNode start="(132, 14)" end="(132, 15)" leading="" trailing=" " val=","/>
                                <IdentNode start="(132, 16)" end="(132, 17)" leading="" trailing="" raw_val="h" val="h"/>
                              </NullNode>
                              <AtomNode start="(132, 17)" end="(132, 18)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(134, 1)" end="(134, 16)" comment="### min? -/">
      <AtomNode start="(134, 1)" end="(134, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(134, 5)" end="(134, 16)" leading="" trailing="&#10;&#10;-- A specialization of `min?_eq_some_iff` to Nat.&#10;" val="### min? -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(137, 1)" end="(142, 44)" name="min?_eq_some_iff'" full_name="List.min?_eq_some_iff'">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(137, 1)" end="(142, 44)" name="min?_eq_some_iff'" full_name="List.min?_eq_some_iff'" _is_private_decl="False">
        <AtomNode start="(137, 1)" end="(137, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(137, 9)" end="(137, 26)">
          <IdentNode start="(137, 9)" end="(137, 26)" leading="" trailing=" " raw_val="min?_eq_some_iff'" val="min?_eq_some_iff'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(137, 27)" end="(138, 50)">
          <NullNode start="(137, 27)" end="(137, 42)">
            <OtherNode start="(137, 27)" end="(137, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(137, 27)" end="(137, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(137, 28)" end="(137, 30)">
                <IdentNode start="(137, 28)" end="(137, 30)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(137, 31)" end="(137, 41)">
                <AtomNode start="(137, 31)" end="(137, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(137, 33)" end="(137, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(137, 33)" end="(137, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(137, 38)" end="(137, 41)">
                    <IdentNode start="(137, 38)" end="(137, 41)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(137, 41)" end="(137, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(137, 43)" end="(138, 50)">
            <AtomNode start="(137, 43)" end="(137, 44)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(138, 5)" end="(138, 50)" kind="«term_↔_»">
              <OtherNode start="(138, 5)" end="(138, 21)" kind="«term_=_»">
                <IdentNode start="(138, 5)" end="(138, 12)" leading="" trailing=" " raw_val="xs.min?" val="xs.min?"/>
                <AtomNode start="(138, 13)" end="(138, 14)" leading="" trailing=" " val="="/>
                <OtherNode start="(138, 15)" end="(138, 21)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(138, 15)" end="(138, 19)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(138, 20)" end="(138, 21)">
                    <IdentNode start="(138, 20)" end="(138, 21)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(138, 22)" end="(138, 23)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(138, 24)" end="(138, 50)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(138, 24)" end="(138, 25)" leading="" trailing="" val="("/>
                <OtherNode start="(138, 25)" end="(138, 49)" kind="«term_∧_»">
                  <OtherNode start="(138, 25)" end="(138, 31)" kind="«term_∈_»">
                    <IdentNode start="(138, 25)" end="(138, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(138, 27)" end="(138, 28)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(138, 29)" end="(138, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(138, 32)" end="(138, 33)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(138, 34)" end="(138, 49)" kind="Lean.«term∀__,_»">
                    <AtomNode start="(138, 34)" end="(138, 35)" leading="" trailing=" " val="∀"/>
                    <LeanBinderidentNode start="(138, 36)" end="(138, 37)">
                      <IdentNode start="(138, 36)" end="(138, 37)" leading="" trailing=" " raw_val="b" val="b"/>
                    </LeanBinderidentNode>
                    <OtherNode start="(138, 38)" end="(138, 42)" kind="Lean.«binderTerm∈_»">
                      <AtomNode start="(138, 38)" end="(138, 39)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(138, 40)" end="(138, 42)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(138, 42)" end="(138, 43)" leading="" trailing=" " val=","/>
                    <OtherNode start="(138, 44)" end="(138, 49)" kind="«term_≤_»">
                      <IdentNode start="(138, 44)" end="(138, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(138, 46)" end="(138, 47)" leading="" trailing=" " val="≤"/>
                      <IdentNode start="(138, 48)" end="(138, 49)" leading="" trailing="" raw_val="b" val="b"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(138, 49)" end="(138, 50)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(138, 51)" end="(142, 44)">
          <AtomNode start="(138, 51)" end="(138, 53)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(139, 3)" end="(142, 44)" kind="Lean.Parser.Term.app">
            <IdentNode start="(139, 3)" end="(139, 19)" leading="" trailing="&#10;    " raw_val="min?_eq_some_iff" val="min?_eq_some_iff" full_name="Std.Antisymm.antisymm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
            <NullNode start="(140, 5)" end="(142, 44)">
              <OtherNode start="(140, 5)" end="(140, 29)" kind="Lean.Parser.Term.namedArgument">
                <AtomNode start="(140, 5)" end="(140, 6)" leading="" trailing="" val="("/>
                <IdentNode start="(140, 6)" end="(140, 13)" leading="" trailing=" " raw_val="le_refl" val="le_refl"/>
                <AtomNode start="(140, 14)" end="(140, 16)" leading="" trailing=" " val=":="/>
                <IdentNode start="(140, 17)" end="(140, 28)" leading="" trailing="" raw_val="Nat.le_refl" val="Nat.le_refl" full_name="Nat.le_refl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(140, 28)" end="(140, 29)" leading="" trailing="&#10;    " val=")"/>
              </OtherNode>
              <OtherNode start="(141, 5)" end="(141, 65)" kind="Lean.Parser.Term.namedArgument">
                <AtomNode start="(141, 5)" end="(141, 6)" leading="" trailing="" val="("/>
                <IdentNode start="(141, 6)" end="(141, 15)" leading="" trailing=" " raw_val="min_eq_or" val="min_eq_or"/>
                <AtomNode start="(141, 16)" end="(141, 18)" leading="" trailing=" " val=":="/>
                <OtherNode start="(141, 19)" end="(141, 64)" kind="Lean.Parser.Term.fun">
                  <AtomNode start="(141, 19)" end="(141, 22)" leading="" trailing=" " val="fun"/>
                  <OtherNode start="(141, 23)" end="(141, 64)" kind="Lean.Parser.Term.basicFun">
                    <NullNode start="(141, 23)" end="(141, 26)">
                      <TermHoleNode start="(141, 23)" end="(141, 24)">
                        <AtomNode start="(141, 23)" end="(141, 24)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                      <TermHoleNode start="(141, 25)" end="(141, 26)">
                        <AtomNode start="(141, 25)" end="(141, 26)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(141, 27)" end="(141, 29)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(141, 30)" end="(141, 64)" kind="Lean.Parser.Term.subst">
                      <OtherNode start="(141, 30)" end="(141, 44)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(141, 30)" end="(141, 41)" leading="" trailing=" " raw_val="Nat.min_def" val="Nat.min_def" full_name="Nat.min_def" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        <NullNode start="(141, 42)" end="(141, 44)">
                          <OtherNode start="(141, 42)" end="(141, 44)" kind="Lean.Parser.Term.ellipsis">
                            <AtomNode start="(141, 42)" end="(141, 44)" leading="" trailing=" " val=".."/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(141, 45)" end="(141, 46)" leading="" trailing=" " val="▸"/>
                      <NullNode start="(141, 47)" end="(141, 64)">
                        <TermBytacticNode start="(141, 47)" end="(141, 64)">
                          <AtomNode start="(141, 47)" end="(141, 49)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(141, 50)" end="(141, 64)">
                            <TacticTacticseq1IndentedNode start="(141, 50)" end="(141, 64)">
                              <NullNode start="(141, 50)" end="(141, 64)">
                                <OtherNode start="(141, 50)" end="(141, 64)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="a : Nat&#10;xs : List Nat&#10;x✝¹ x✝ : Nat&#10;⊢ (if x✝¹ ≤ x✝ then x✝¹ else x✝) = x✝¹ ∨ (if x✝¹ ≤ x✝ then x✝¹ else x✝) = x✝" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                                  <OtherNode start="(141, 50)" end="(141, 55)" kind="Lean.Parser.Tactic.split">
                                    <AtomNode start="(141, 50)" end="(141, 55)" leading="" trailing=" " val="split"/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(141, 56)" end="(141, 59)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                  <OtherNode start="(141, 60)" end="(141, 64)" kind="Lean.Parser.Tactic.simp">
                                    <AtomNode start="(141, 60)" end="(141, 64)" leading="" trailing="" val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(141, 64)" end="(141, 65)" leading="" trailing="&#10;    " val=")"/>
              </OtherNode>
              <OtherNode start="(142, 5)" end="(142, 44)" kind="Lean.Parser.Term.namedArgument">
                <AtomNode start="(142, 5)" end="(142, 6)" leading="" trailing="" val="("/>
                <IdentNode start="(142, 6)" end="(142, 16)" leading="" trailing=" " raw_val="le_min_iff" val="le_min_iff"/>
                <AtomNode start="(142, 17)" end="(142, 19)" leading="" trailing=" " val=":="/>
                <OtherNode start="(142, 20)" end="(142, 43)" kind="Lean.Parser.Term.fun">
                  <AtomNode start="(142, 20)" end="(142, 23)" leading="" trailing=" " val="fun"/>
                  <OtherNode start="(142, 24)" end="(142, 43)" kind="Lean.Parser.Term.basicFun">
                    <NullNode start="(142, 24)" end="(142, 29)">
                      <TermHoleNode start="(142, 24)" end="(142, 25)">
                        <AtomNode start="(142, 24)" end="(142, 25)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                      <TermHoleNode start="(142, 26)" end="(142, 27)">
                        <AtomNode start="(142, 26)" end="(142, 27)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                      <TermHoleNode start="(142, 28)" end="(142, 29)">
                        <AtomNode start="(142, 28)" end="(142, 29)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(142, 30)" end="(142, 32)" leading="" trailing=" " val="=&amp;gt;"/>
                    <IdentNode start="(142, 33)" end="(142, 43)" leading="" trailing="" raw_val="Nat.le_min" val="Nat.le_min" full_name="Nat.le_min" mod_name="Init.Data.Nat.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/MinMax.lean"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(142, 43)" end="(142, 44)" leading="" trailing="&#10;&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(144, 1)" end="(156, 55)" name="min?_get_le_of_mem" full_name="List.min?_get_le_of_mem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(144, 1)" end="(156, 55)" name="min?_get_le_of_mem" full_name="List.min?_get_le_of_mem" _is_private_decl="False">
        <AtomNode start="(144, 1)" end="(144, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(144, 9)" end="(144, 27)">
          <IdentNode start="(144, 9)" end="(144, 27)" leading="" trailing=" " raw_val="min?_get_le_of_mem" val="min?_get_le_of_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(144, 28)" end="(145, 42)">
          <NullNode start="(144, 28)" end="(144, 64)">
            <OtherNode start="(144, 28)" end="(144, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(144, 28)" end="(144, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(144, 29)" end="(144, 30)">
                <IdentNode start="(144, 29)" end="(144, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(144, 31)" end="(144, 41)">
                <AtomNode start="(144, 31)" end="(144, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(144, 33)" end="(144, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(144, 33)" end="(144, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(144, 38)" end="(144, 41)">
                    <IdentNode start="(144, 38)" end="(144, 41)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(144, 41)" end="(144, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(144, 43)" end="(144, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(144, 43)" end="(144, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(144, 44)" end="(144, 45)">
                <IdentNode start="(144, 44)" end="(144, 45)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(144, 46)" end="(144, 51)">
                <AtomNode start="(144, 46)" end="(144, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(144, 48)" end="(144, 51)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(144, 51)" end="(144, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(144, 53)" end="(144, 64)">
              <AtomNode start="(144, 53)" end="(144, 54)" leading="" trailing="" val="("/>
              <NullNode start="(144, 54)" end="(144, 55)">
                <IdentNode start="(144, 54)" end="(144, 55)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(144, 56)" end="(144, 63)">
                <AtomNode start="(144, 56)" end="(144, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(144, 58)" end="(144, 63)" kind="«term_∈_»">
                  <IdentNode start="(144, 58)" end="(144, 59)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(144, 60)" end="(144, 61)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(144, 62)" end="(144, 63)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(144, 63)" end="(144, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(144, 65)" end="(145, 42)">
            <AtomNode start="(144, 65)" end="(144, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(145, 5)" end="(145, 42)" kind="«term_≤_»">
              <OtherNode start="(145, 5)" end="(145, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(145, 5)" end="(145, 15)" leading="" trailing=" " raw_val="l.min?.get" val="l.min?.get"/>
                <NullNode start="(145, 16)" end="(145, 38)">
                  <OtherNode start="(145, 16)" end="(145, 38)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(145, 16)" end="(145, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(145, 17)" end="(145, 37)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(145, 17)" end="(145, 35)" leading="" trailing=" " raw_val="isSome_min?_of_mem" val="isSome_min?_of_mem" full_name="List.isSome_min?_of_mem" mod_name="Init.Data.List.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MinMax.lean"/>
                      <NullNode start="(145, 36)" end="(145, 37)">
                        <IdentNode start="(145, 36)" end="(145, 37)" leading="" trailing="" raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(145, 37)" end="(145, 38)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(145, 39)" end="(145, 40)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(145, 41)" end="(145, 42)" leading="" trailing=" " raw_val="a" val="a"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(145, 43)" end="(156, 55)">
          <AtomNode start="(145, 43)" end="(145, 45)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(145, 46)" end="(156, 55)">
            <AtomNode start="(145, 46)" end="(145, 48)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(146, 3)" end="(156, 55)">
              <TacticTacticseq1IndentedNode start="(146, 3)" end="(156, 55)">
                <NullNode start="(146, 3)" end="(156, 55)">
                  <OtherNode start="(146, 3)" end="(156, 55)" kind="Lean.Parser.Tactic.induction" state_before="l : List Nat&#10;a : Nat&#10;h : a ∈ l&#10;⊢ l.min?.get ⋯ ≤ a" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp at h&#10;| cons b t ih =&amp;gt;&#10;  simp only [min?_cons, Option.get_some] at ih ⊢&#10;  rcases mem_cons.1 h with (rfl|h)&#10;  · cases t.min? with&#10;    | none =&amp;gt; simp&#10;    | some b =&amp;gt; simpa using Nat.min_le_left _ _&#10;  · obtain ⟨q, hq⟩ := Option.isSome_iff_exists.1 (isSome_min?_of_mem h)&#10;    simp only [hq, Option.elim_some] at ih ⊢&#10;    exact Nat.le_trans (Nat.min_le_right _ _) (ih h)">
                    <AtomNode start="(146, 3)" end="(146, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(146, 13)" end="(146, 14)">
                      <OtherNode start="(146, 13)" end="(146, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(146, 13)" end="(146, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(146, 15)" end="(156, 55)">
                      <OtherNode start="(146, 15)" end="(156, 55)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(146, 15)" end="(146, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(147, 3)" end="(156, 55)">
                          <OtherNode start="(147, 3)" end="(147, 21)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(147, 3)" end="(147, 8)">
                              <OtherNode start="(147, 3)" end="(147, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(147, 3)" end="(147, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(147, 5)" end="(147, 8)">
                                  <NullNode/>
                                  <IdentNode start="(147, 5)" end="(147, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(147, 9)" end="(147, 21)">
                              <AtomNode start="(147, 9)" end="(147, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(147, 12)" end="(147, 21)">
                                <TacticTacticseq1IndentedNode start="(147, 12)" end="(147, 21)">
                                  <NullNode start="(147, 12)" end="(147, 21)">
                                    <OtherNode start="(147, 12)" end="(147, 21)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;a : Nat&#10;h : a ∈ []&#10;⊢ [].min?.get ⋯ ≤ a" state_after="no goals" tactic="simp at h">
                                      <AtomNode start="(147, 12)" end="(147, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(147, 17)" end="(147, 21)">
                                        <OtherNode start="(147, 17)" end="(147, 21)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(147, 17)" end="(147, 19)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(147, 20)" end="(147, 21)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(147, 20)" end="(147, 21)">
                                              <IdentNode start="(147, 20)" end="(147, 21)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(148, 3)" end="(156, 55)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(148, 3)" end="(148, 16)">
                              <OtherNode start="(148, 3)" end="(148, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(148, 3)" end="(148, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(148, 5)" end="(148, 9)">
                                  <NullNode/>
                                  <IdentNode start="(148, 5)" end="(148, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(148, 10)" end="(148, 16)">
                                  <IdentNode start="(148, 10)" end="(148, 11)" leading="" trailing=" " raw_val="b" val="b"/>
                                  <IdentNode start="(148, 12)" end="(148, 13)" leading="" trailing=" " raw_val="t" val="t"/>
                                  <IdentNode start="(148, 14)" end="(148, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(148, 17)" end="(156, 55)">
                              <AtomNode start="(148, 17)" end="(148, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(149, 5)" end="(156, 55)">
                                <TacticTacticseq1IndentedNode start="(149, 5)" end="(156, 55)">
                                  <NullNode start="(149, 5)" end="(156, 55)">
                                    <OtherNode start="(149, 5)" end="(149, 51)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h : a ∈ b :: t&#10;⊢ (b :: t).min?.get ⋯ ≤ a" state_after="case cons&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h : a ∈ b :: t&#10;⊢ t.min?.elim b (min b) ≤ a" tactic="simp only [min?_cons, Option.get_some] at ih ⊢">
                                      <AtomNode start="(149, 5)" end="(149, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(149, 10)" end="(149, 14)">
                                        <AtomNode start="(149, 10)" end="(149, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(149, 15)" end="(149, 43)">
                                        <AtomNode start="(149, 15)" end="(149, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(149, 16)" end="(149, 42)">
                                          <OtherNode start="(149, 16)" end="(149, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(149, 16)" end="(149, 25)" leading="" trailing="" raw_val="min?_cons" val="min?_cons" full_name="List.min?_cons" mod_name="Init.Data.List.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MinMax.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(149, 25)" end="(149, 26)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(149, 27)" end="(149, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(149, 27)" end="(149, 42)" leading="" trailing="" raw_val="Option.get_some" val="Option.get_some" full_name="Option.get_some" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(149, 42)" end="(149, 43)" leading="" trailing=" " val="]"/>
                                      </NullNode>
                                      <NullNode start="(149, 44)" end="(149, 51)">
                                        <OtherNode start="(149, 44)" end="(149, 51)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(149, 44)" end="(149, 46)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(149, 47)" end="(149, 51)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(149, 47)" end="(149, 51)">
                                              <IdentNode start="(149, 47)" end="(149, 49)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                              <OtherNode start="(149, 50)" end="(149, 51)" kind="Lean.Parser.Tactic.locationType">
                                                <OtherNode start="(149, 50)" end="(149, 51)" kind="patternIgnore">
                                                  <OtherNode start="(149, 50)" end="(149, 51)" kind="token.«⊢»">
                                                    <AtomNode start="(149, 50)" end="(149, 51)" leading="" trailing="&#10;    " val="⊢"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(150, 5)" end="(150, 37)" kind="Lean.Parser.Tactic.rcases" state_before="case cons&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h : a ∈ b :: t&#10;⊢ t.min?.elim b (min b) ≤ a" state_after="case cons.inl&#10;a : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h : a ∈ a :: t&#10;⊢ t.min?.elim a (min a) ≤ a&#10;&#10;case cons.inr&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;⊢ t.min?.elim b (min b) ≤ a" tactic="rcases mem_cons.1 h with (rfl|h)">
                                      <AtomNode start="(150, 5)" end="(150, 11)" leading="" trailing=" " val="rcases"/>
                                      <NullNode start="(150, 12)" end="(150, 24)">
                                        <OtherNode start="(150, 12)" end="(150, 24)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <OtherNode start="(150, 12)" end="(150, 24)" kind="Lean.Parser.Term.app">
                                            <OtherNode start="(150, 12)" end="(150, 22)" kind="Lean.Parser.Term.proj">
                                              <IdentNode start="(150, 12)" end="(150, 20)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                              <AtomNode start="(150, 20)" end="(150, 21)" leading="" trailing="" val="."/>
                                              <OtherNode start="(150, 21)" end="(150, 22)" kind="fieldIdx">
                                                <AtomNode start="(150, 21)" end="(150, 22)" leading="" trailing=" " val="1"/>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode start="(150, 23)" end="(150, 24)">
                                              <IdentNode start="(150, 23)" end="(150, 24)" leading="" trailing=" " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode start="(150, 25)" end="(150, 37)">
                                        <AtomNode start="(150, 25)" end="(150, 29)" leading="" trailing=" " val="with"/>
                                        <OtherNode start="(150, 30)" end="(150, 37)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                          <OtherNode start="(150, 30)" end="(150, 37)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                            <NullNode start="(150, 30)" end="(150, 37)">
                                              <OtherNode start="(150, 30)" end="(150, 37)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                <AtomNode start="(150, 30)" end="(150, 31)" leading="" trailing="" val="("/>
                                                <OtherNode start="(150, 31)" end="(150, 36)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                  <OtherNode start="(150, 31)" end="(150, 36)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                    <NullNode start="(150, 31)" end="(150, 36)">
                                                      <OtherNode start="(150, 31)" end="(150, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                        <IdentNode start="(150, 31)" end="(150, 34)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                      </OtherNode>
                                                      <AtomNode start="(150, 34)" end="(150, 35)" leading="" trailing="" val="|"/>
                                                      <OtherNode start="(150, 35)" end="(150, 36)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                        <IdentNode start="(150, 35)" end="(150, 36)" leading="" trailing="" raw_val="h" val="h"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                </OtherNode>
                                                <AtomNode start="(150, 36)" end="(150, 37)" leading="" trailing="&#10;    " val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(151, 5)" end="(153, 50)" kind="Lean.cdot" state_before="case cons.inl&#10;a : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h : a ∈ a :: t&#10;⊢ t.min?.elim a (min a) ≤ a&#10;&#10;case cons.inr&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;⊢ t.min?.elim b (min b) ≤ a" state_after="case cons.inr&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;⊢ t.min?.elim b (min b) ≤ a" tactic="· cases t.min? with&#10;  | none =&amp;gt; simp&#10;  | some b =&amp;gt; simpa using Nat.min_le_left _ _">
                                      <OtherNode start="(151, 5)" end="(151, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(151, 5)" end="(151, 6)" kind="patternIgnore">
                                          <OtherNode start="(151, 5)" end="(151, 6)" kind="token.«· »">
                                            <AtomNode start="(151, 5)" end="(151, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(151, 7)" end="(153, 50)">
                                        <TacticTacticseq1IndentedNode start="(151, 7)" end="(153, 50)">
                                          <NullNode start="(151, 7)" end="(153, 50)">
                                            <OtherNode start="(151, 7)" end="(153, 50)" kind="Lean.Parser.Tactic.cases" state_before="case cons.inl&#10;a : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h : a ∈ a :: t&#10;⊢ t.min?.elim a (min a) ≤ a" state_after="no goals" tactic="cases t.min? with&#10;| none =&amp;gt; simp&#10;| some b =&amp;gt; simpa using Nat.min_le_left _ _">
                                              <AtomNode start="(151, 7)" end="(151, 12)" leading="" trailing=" " val="cases"/>
                                              <NullNode start="(151, 13)" end="(151, 19)">
                                                <OtherNode start="(151, 13)" end="(151, 19)" kind="Lean.Parser.Tactic.elimTarget">
                                                  <NullNode/>
                                                  <IdentNode start="(151, 13)" end="(151, 19)" leading="" trailing=" " raw_val="t.min?" val="t.min?"/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                              <NullNode start="(151, 20)" end="(153, 50)">
                                                <OtherNode start="(151, 20)" end="(153, 50)" kind="Lean.Parser.Tactic.inductionAlts">
                                                  <AtomNode start="(151, 20)" end="(151, 24)" leading="" trailing="&#10;      " val="with"/>
                                                  <NullNode/>
                                                  <NullNode start="(152, 7)" end="(153, 50)">
                                                    <OtherNode start="(152, 7)" end="(152, 21)" kind="Lean.Parser.Tactic.inductionAlt">
                                                      <NullNode start="(152, 7)" end="(152, 13)">
                                                        <OtherNode start="(152, 7)" end="(152, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                          <AtomNode start="(152, 7)" end="(152, 8)" leading="" trailing=" " val="|"/>
                                                          <GroupNode start="(152, 9)" end="(152, 13)">
                                                            <NullNode/>
                                                            <IdentNode start="(152, 9)" end="(152, 13)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                          </GroupNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode start="(152, 14)" end="(152, 21)">
                                                        <AtomNode start="(152, 14)" end="(152, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                                                        <TacticTacticseqNode start="(152, 17)" end="(152, 21)">
                                                          <TacticTacticseq1IndentedNode start="(152, 17)" end="(152, 21)">
                                                            <NullNode start="(152, 17)" end="(152, 21)">
                                                            <OtherNode start="(152, 17)" end="(152, 21)" kind="Lean.Parser.Tactic.simp" state_before="case cons.inl.none&#10;a : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h : a ∈ a :: t&#10;⊢ none.elim a (min a) ≤ a" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(152, 17)" end="(152, 21)" leading="" trailing="&#10;      " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <OtherNode start="(153, 7)" end="(153, 50)" kind="Lean.Parser.Tactic.inductionAlt">
                                                      <NullNode start="(153, 7)" end="(153, 15)">
                                                        <OtherNode start="(153, 7)" end="(153, 15)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                          <AtomNode start="(153, 7)" end="(153, 8)" leading="" trailing=" " val="|"/>
                                                          <GroupNode start="(153, 9)" end="(153, 13)">
                                                            <NullNode/>
                                                            <IdentNode start="(153, 9)" end="(153, 13)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                          </GroupNode>
                                                          <NullNode start="(153, 14)" end="(153, 15)">
                                                            <IdentNode start="(153, 14)" end="(153, 15)" leading="" trailing=" " raw_val="b" val="b"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode start="(153, 16)" end="(153, 50)">
                                                        <AtomNode start="(153, 16)" end="(153, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                                                        <TacticTacticseqNode start="(153, 19)" end="(153, 50)">
                                                          <TacticTacticseq1IndentedNode start="(153, 19)" end="(153, 50)">
                                                            <NullNode start="(153, 19)" end="(153, 50)">
                                                            <OtherNode start="(153, 19)" end="(153, 50)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.inl.some&#10;a : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h : a ∈ a :: t&#10;b : Nat&#10;⊢ (some b).elim a (min a) ≤ a" state_after="no goals" tactic="simpa using Nat.min_le_left _ _">
                                                            <AtomNode start="(153, 19)" end="(153, 24)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(153, 25)" end="(153, 50)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(153, 25)" end="(153, 50)">
                                                            <AtomNode start="(153, 25)" end="(153, 30)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(153, 31)" end="(153, 50)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(153, 31)" end="(153, 46)" leading="" trailing=" " raw_val="Nat.min_le_left" val="Nat.min_le_left" full_name="Nat.min_le_left" mod_name="Init.Data.Nat.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/MinMax.lean"/>
                                                            <NullNode start="(153, 47)" end="(153, 50)">
                                                            <TermHoleNode start="(153, 47)" end="(153, 48)">
                                                            <AtomNode start="(153, 47)" end="(153, 48)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(153, 49)" end="(153, 50)">
                                                            <AtomNode start="(153, 49)" end="(153, 50)" leading="" trailing="&#10;    " val="_"/>
                                                            </TermHoleNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(154, 5)" end="(156, 55)" kind="Lean.cdot" state_before="case cons.inr&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;⊢ t.min?.elim b (min b) ≤ a" state_after="no goals" tactic="· obtain ⟨q, hq⟩ := Option.isSome_iff_exists.1 (isSome_min?_of_mem h)&#10;  simp only [hq, Option.elim_some] at ih ⊢&#10;  exact Nat.le_trans (Nat.min_le_right _ _) (ih h)">
                                      <OtherNode start="(154, 5)" end="(154, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(154, 5)" end="(154, 6)" kind="patternIgnore">
                                          <OtherNode start="(154, 5)" end="(154, 6)" kind="token.«· »">
                                            <AtomNode start="(154, 5)" end="(154, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(154, 7)" end="(156, 55)">
                                        <TacticTacticseq1IndentedNode start="(154, 7)" end="(156, 55)">
                                          <NullNode start="(154, 7)" end="(156, 55)">
                                            <OtherNode start="(154, 7)" end="(154, 74)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.inr&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;⊢ t.min?.elim b (min b) ≤ a" state_after="case cons.inr.intro&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;q : Nat&#10;hq : t.min? = some q&#10;⊢ t.min?.elim b (min b) ≤ a" tactic="obtain ⟨q, hq⟩ := Option.isSome_iff_exists.1 (isSome_min?_of_mem h)">
                                              <AtomNode start="(154, 7)" end="(154, 13)" leading="" trailing=" " val="obtain"/>
                                              <NullNode start="(154, 14)" end="(154, 21)">
                                                <OtherNode start="(154, 14)" end="(154, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(154, 14)" end="(154, 21)">
                                                    <OtherNode start="(154, 14)" end="(154, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                      <AtomNode start="(154, 14)" end="(154, 15)" leading="" trailing="" val="⟨"/>
                                                      <NullNode start="(154, 15)" end="(154, 20)">
                                                        <OtherNode start="(154, 15)" end="(154, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(154, 15)" end="(154, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(154, 15)" end="(154, 16)">
                                                            <OtherNode start="(154, 15)" end="(154, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(154, 15)" end="(154, 16)" leading="" trailing="" raw_val="q" val="q"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(154, 16)" end="(154, 17)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(154, 18)" end="(154, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(154, 18)" end="(154, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(154, 18)" end="(154, 20)">
                                                            <OtherNode start="(154, 18)" end="(154, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(154, 18)" end="(154, 20)" leading="" trailing="" raw_val="hq" val="hq"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(154, 20)" end="(154, 21)" leading="" trailing=" " val="⟩"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                              <NullNode start="(154, 22)" end="(154, 74)">
                                                <AtomNode start="(154, 22)" end="(154, 24)" leading="" trailing=" " val=":="/>
                                                <NullNode start="(154, 25)" end="(154, 74)">
                                                  <OtherNode start="(154, 25)" end="(154, 74)" kind="Lean.Parser.Term.app">
                                                    <OtherNode start="(154, 25)" end="(154, 51)" kind="Lean.Parser.Term.proj">
                                                      <IdentNode start="(154, 25)" end="(154, 49)" leading="" trailing="" raw_val="Option.isSome_iff_exists" val="Option.isSome_iff_exists" full_name="Option.isSome_iff_exists" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                                      <AtomNode start="(154, 49)" end="(154, 50)" leading="" trailing="" val="."/>
                                                      <OtherNode start="(154, 50)" end="(154, 51)" kind="fieldIdx">
                                                        <AtomNode start="(154, 50)" end="(154, 51)" leading="" trailing=" " val="1"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <NullNode start="(154, 52)" end="(154, 74)">
                                                      <OtherNode start="(154, 52)" end="(154, 74)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(154, 52)" end="(154, 53)" leading="" trailing="" val="("/>
                                                        <OtherNode start="(154, 53)" end="(154, 73)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(154, 53)" end="(154, 71)" leading="" trailing=" " raw_val="isSome_min?_of_mem" val="isSome_min?_of_mem" full_name="List.isSome_min?_of_mem" mod_name="Init.Data.List.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MinMax.lean"/>
                                                          <NullNode start="(154, 72)" end="(154, 73)">
                                                            <IdentNode start="(154, 72)" end="(154, 73)" leading="" trailing="" raw_val="h" val="h"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <AtomNode start="(154, 73)" end="(154, 74)" leading="" trailing="&#10;      " val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(155, 7)" end="(155, 47)" kind="Lean.Parser.Tactic.simp" state_before="case cons.inr.intro&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), t.min?.get ⋯ ≤ a&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;q : Nat&#10;hq : t.min? = some q&#10;⊢ t.min?.elim b (min b) ≤ a" state_after="case cons.inr.intro&#10;a b : Nat&#10;t : List Nat&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;q : Nat&#10;hq : t.min? = some q&#10;ih : ∀ (h : a ∈ t), (some q).get ⋯ ≤ a&#10;⊢ min b q ≤ a" tactic="simp only [hq, Option.elim_some] at ih ⊢">
                                              <AtomNode start="(155, 7)" end="(155, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(155, 12)" end="(155, 16)">
                                                <AtomNode start="(155, 12)" end="(155, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(155, 17)" end="(155, 39)">
                                                <AtomNode start="(155, 17)" end="(155, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(155, 18)" end="(155, 38)">
                                                  <OtherNode start="(155, 18)" end="(155, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(155, 18)" end="(155, 20)" leading="" trailing="" raw_val="hq" val="hq"/>
                                                  </OtherNode>
                                                  <AtomNode start="(155, 20)" end="(155, 21)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(155, 22)" end="(155, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(155, 22)" end="(155, 38)" leading="" trailing="" raw_val="Option.elim_some" val="Option.elim_some" full_name="Option.elim_some" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(155, 38)" end="(155, 39)" leading="" trailing=" " val="]"/>
                                              </NullNode>
                                              <NullNode start="(155, 40)" end="(155, 47)">
                                                <OtherNode start="(155, 40)" end="(155, 47)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(155, 40)" end="(155, 42)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(155, 43)" end="(155, 47)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(155, 43)" end="(155, 47)">
                                                      <IdentNode start="(155, 43)" end="(155, 45)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                      <OtherNode start="(155, 46)" end="(155, 47)" kind="Lean.Parser.Tactic.locationType">
                                                        <OtherNode start="(155, 46)" end="(155, 47)" kind="patternIgnore">
                                                          <OtherNode start="(155, 46)" end="(155, 47)" kind="token.«⊢»">
                                                            <AtomNode start="(155, 46)" end="(155, 47)" leading="" trailing="&#10;      " val="⊢"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(156, 7)" end="(156, 55)" kind="Lean.Parser.Tactic.exact" state_before="case cons.inr.intro&#10;a b : Nat&#10;t : List Nat&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;q : Nat&#10;hq : t.min? = some q&#10;ih : ∀ (h : a ∈ t), (some q).get ⋯ ≤ a&#10;⊢ min b q ≤ a" state_after="no goals" tactic="exact Nat.le_trans (Nat.min_le_right _ _) (ih h)">
                                              <AtomNode start="(156, 7)" end="(156, 12)" leading="" trailing=" " val="exact"/>
                                              <OtherNode start="(156, 13)" end="(156, 55)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(156, 13)" end="(156, 25)" leading="" trailing=" " raw_val="Nat.le_trans" val="Nat.le_trans" full_name="Nat.le_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                <NullNode start="(156, 26)" end="(156, 55)">
                                                  <OtherNode start="(156, 26)" end="(156, 48)" kind="Lean.Parser.Term.paren">
                                                    <AtomNode start="(156, 26)" end="(156, 27)" leading="" trailing="" val="("/>
                                                    <OtherNode start="(156, 27)" end="(156, 47)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(156, 27)" end="(156, 43)" leading="" trailing=" " raw_val="Nat.min_le_right" val="Nat.min_le_right" full_name="Nat.min_le_right" mod_name="Init.Data.Nat.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/MinMax.lean"/>
                                                      <NullNode start="(156, 44)" end="(156, 47)">
                                                        <TermHoleNode start="(156, 44)" end="(156, 45)">
                                                          <AtomNode start="(156, 44)" end="(156, 45)" leading="" trailing=" " val="_"/>
                                                        </TermHoleNode>
                                                        <TermHoleNode start="(156, 46)" end="(156, 47)">
                                                          <AtomNode start="(156, 46)" end="(156, 47)" leading="" trailing="" val="_"/>
                                                        </TermHoleNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <AtomNode start="(156, 47)" end="(156, 48)" leading="" trailing=" " val=")"/>
                                                  </OtherNode>
                                                  <OtherNode start="(156, 49)" end="(156, 55)" kind="Lean.Parser.Term.paren">
                                                    <AtomNode start="(156, 49)" end="(156, 50)" leading="" trailing="" val="("/>
                                                    <OtherNode start="(156, 50)" end="(156, 54)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(156, 50)" end="(156, 52)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                      <NullNode start="(156, 53)" end="(156, 54)">
                                                        <IdentNode start="(156, 53)" end="(156, 54)" leading="" trailing="" raw_val="h" val="h"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <AtomNode start="(156, 54)" end="(156, 55)" leading="" trailing="&#10;&#10;" val=")"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(158, 1)" end="(159, 46)" name="min?_getD_le_of_mem" full_name="List.min?_getD_le_of_mem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(158, 1)" end="(159, 46)" name="min?_getD_le_of_mem" full_name="List.min?_getD_le_of_mem" _is_private_decl="False">
        <AtomNode start="(158, 1)" end="(158, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(158, 9)" end="(158, 28)">
          <IdentNode start="(158, 9)" end="(158, 28)" leading="" trailing=" " raw_val="min?_getD_le_of_mem" val="min?_getD_le_of_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(158, 29)" end="(158, 87)">
          <NullNode start="(158, 29)" end="(158, 67)">
            <OtherNode start="(158, 29)" end="(158, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(158, 29)" end="(158, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(158, 30)" end="(158, 31)">
                <IdentNode start="(158, 30)" end="(158, 31)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(158, 32)" end="(158, 42)">
                <AtomNode start="(158, 32)" end="(158, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(158, 34)" end="(158, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(158, 34)" end="(158, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(158, 39)" end="(158, 42)">
                    <IdentNode start="(158, 39)" end="(158, 42)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(158, 42)" end="(158, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(158, 44)" end="(158, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(158, 44)" end="(158, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(158, 45)" end="(158, 48)">
                <IdentNode start="(158, 45)" end="(158, 46)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(158, 47)" end="(158, 48)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(158, 49)" end="(158, 54)">
                <AtomNode start="(158, 49)" end="(158, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(158, 51)" end="(158, 54)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(158, 54)" end="(158, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(158, 56)" end="(158, 67)">
              <AtomNode start="(158, 56)" end="(158, 57)" leading="" trailing="" val="("/>
              <NullNode start="(158, 57)" end="(158, 58)">
                <IdentNode start="(158, 57)" end="(158, 58)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(158, 59)" end="(158, 66)">
                <AtomNode start="(158, 59)" end="(158, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(158, 61)" end="(158, 66)" kind="«term_∈_»">
                  <IdentNode start="(158, 61)" end="(158, 62)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(158, 63)" end="(158, 64)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(158, 65)" end="(158, 66)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(158, 66)" end="(158, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(158, 68)" end="(158, 87)">
            <AtomNode start="(158, 68)" end="(158, 69)" leading="" trailing=" " val=":"/>
            <OtherNode start="(158, 70)" end="(158, 87)" kind="«term_≤_»">
              <OtherNode start="(158, 70)" end="(158, 83)" kind="Lean.Parser.Term.app">
                <IdentNode start="(158, 70)" end="(158, 81)" leading="" trailing=" " raw_val="l.min?.getD" val="l.min?.getD"/>
                <NullNode start="(158, 82)" end="(158, 83)">
                  <IdentNode start="(158, 82)" end="(158, 83)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(158, 84)" end="(158, 85)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(158, 86)" end="(158, 87)" leading="" trailing=" " raw_val="a" val="a"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(158, 88)" end="(159, 46)">
          <AtomNode start="(158, 88)" end="(158, 90)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(159, 3)" end="(159, 46)" kind="Lean.Parser.Term.subst">
            <OtherNode start="(159, 3)" end="(159, 23)" kind="Lean.Parser.Term.app">
              <IdentNode start="(159, 3)" end="(159, 21)" leading="" trailing=" " raw_val="Option.get_eq_getD" val="Option.get_eq_getD" full_name="Option.get_eq_getD" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
              <NullNode start="(159, 22)" end="(159, 23)">
                <TermHoleNode start="(159, 22)" end="(159, 23)">
                  <AtomNode start="(159, 22)" end="(159, 23)" leading="" trailing=" " val="_"/>
                </TermHoleNode>
              </NullNode>
            </OtherNode>
            <AtomNode start="(159, 24)" end="(159, 25)" leading="" trailing=" " val="▸"/>
            <NullNode start="(159, 26)" end="(159, 46)">
              <OtherNode start="(159, 26)" end="(159, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(159, 26)" end="(159, 44)" leading="" trailing=" " raw_val="min?_get_le_of_mem" val="min?_get_le_of_mem" full_name="List.min?_get_le_of_mem" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean" def_start="(144, 9)" def_end="(144, 27)"/>
                <NullNode start="(159, 45)" end="(159, 46)">
                  <IdentNode start="(159, 45)" end="(159, 46)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(161, 1)" end="(161, 16)" comment="### max? -/">
      <AtomNode start="(161, 1)" end="(161, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(161, 5)" end="(161, 16)" leading="" trailing="&#10;&#10;-- A specialization of `max?_eq_some_iff` to Nat.&#10;" val="### max? -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(164, 1)" end="(169, 44)" name="max?_eq_some_iff'" full_name="List.max?_eq_some_iff'">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(164, 1)" end="(169, 44)" name="max?_eq_some_iff'" full_name="List.max?_eq_some_iff'" _is_private_decl="False">
        <AtomNode start="(164, 1)" end="(164, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(164, 9)" end="(164, 26)">
          <IdentNode start="(164, 9)" end="(164, 26)" leading="" trailing=" " raw_val="max?_eq_some_iff'" val="max?_eq_some_iff'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(164, 27)" end="(165, 50)">
          <NullNode start="(164, 27)" end="(164, 42)">
            <OtherNode start="(164, 27)" end="(164, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(164, 27)" end="(164, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(164, 28)" end="(164, 30)">
                <IdentNode start="(164, 28)" end="(164, 30)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(164, 31)" end="(164, 41)">
                <AtomNode start="(164, 31)" end="(164, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(164, 33)" end="(164, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(164, 33)" end="(164, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(164, 38)" end="(164, 41)">
                    <IdentNode start="(164, 38)" end="(164, 41)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(164, 41)" end="(164, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(164, 43)" end="(165, 50)">
            <AtomNode start="(164, 43)" end="(164, 44)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(165, 5)" end="(165, 50)" kind="«term_↔_»">
              <OtherNode start="(165, 5)" end="(165, 21)" kind="«term_=_»">
                <IdentNode start="(165, 5)" end="(165, 12)" leading="" trailing=" " raw_val="xs.max?" val="xs.max?"/>
                <AtomNode start="(165, 13)" end="(165, 14)" leading="" trailing=" " val="="/>
                <OtherNode start="(165, 15)" end="(165, 21)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(165, 15)" end="(165, 19)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(165, 20)" end="(165, 21)">
                    <IdentNode start="(165, 20)" end="(165, 21)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(165, 22)" end="(165, 23)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(165, 24)" end="(165, 50)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(165, 24)" end="(165, 25)" leading="" trailing="" val="("/>
                <OtherNode start="(165, 25)" end="(165, 49)" kind="«term_∧_»">
                  <OtherNode start="(165, 25)" end="(165, 31)" kind="«term_∈_»">
                    <IdentNode start="(165, 25)" end="(165, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(165, 27)" end="(165, 28)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(165, 29)" end="(165, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(165, 32)" end="(165, 33)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(165, 34)" end="(165, 49)" kind="Lean.«term∀__,_»">
                    <AtomNode start="(165, 34)" end="(165, 35)" leading="" trailing=" " val="∀"/>
                    <LeanBinderidentNode start="(165, 36)" end="(165, 37)">
                      <IdentNode start="(165, 36)" end="(165, 37)" leading="" trailing=" " raw_val="b" val="b"/>
                    </LeanBinderidentNode>
                    <OtherNode start="(165, 38)" end="(165, 42)" kind="Lean.«binderTerm∈_»">
                      <AtomNode start="(165, 38)" end="(165, 39)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(165, 40)" end="(165, 42)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(165, 42)" end="(165, 43)" leading="" trailing=" " val=","/>
                    <OtherNode start="(165, 44)" end="(165, 49)" kind="«term_≤_»">
                      <IdentNode start="(165, 44)" end="(165, 45)" leading="" trailing=" " raw_val="b" val="b"/>
                      <AtomNode start="(165, 46)" end="(165, 47)" leading="" trailing=" " val="≤"/>
                      <IdentNode start="(165, 48)" end="(165, 49)" leading="" trailing="" raw_val="a" val="a"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(165, 49)" end="(165, 50)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(165, 51)" end="(169, 44)">
          <AtomNode start="(165, 51)" end="(165, 53)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(166, 3)" end="(169, 44)" kind="Lean.Parser.Term.app">
            <IdentNode start="(166, 3)" end="(166, 19)" leading="" trailing="&#10;    " raw_val="max?_eq_some_iff" val="max?_eq_some_iff" full_name="List.max?_eq_some_iff" mod_name="Init.Data.List.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MinMax.lean"/>
            <NullNode start="(167, 5)" end="(169, 44)">
              <OtherNode start="(167, 5)" end="(167, 29)" kind="Lean.Parser.Term.namedArgument">
                <AtomNode start="(167, 5)" end="(167, 6)" leading="" trailing="" val="("/>
                <IdentNode start="(167, 6)" end="(167, 13)" leading="" trailing=" " raw_val="le_refl" val="le_refl"/>
                <AtomNode start="(167, 14)" end="(167, 16)" leading="" trailing=" " val=":="/>
                <IdentNode start="(167, 17)" end="(167, 28)" leading="" trailing="" raw_val="Nat.le_refl" val="Nat.le_refl" full_name="Nat.le_refl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(167, 28)" end="(167, 29)" leading="" trailing="&#10;    " val=")"/>
              </OtherNode>
              <OtherNode start="(168, 5)" end="(168, 65)" kind="Lean.Parser.Term.namedArgument">
                <AtomNode start="(168, 5)" end="(168, 6)" leading="" trailing="" val="("/>
                <IdentNode start="(168, 6)" end="(168, 15)" leading="" trailing=" " raw_val="max_eq_or" val="max_eq_or"/>
                <AtomNode start="(168, 16)" end="(168, 18)" leading="" trailing=" " val=":="/>
                <OtherNode start="(168, 19)" end="(168, 64)" kind="Lean.Parser.Term.fun">
                  <AtomNode start="(168, 19)" end="(168, 22)" leading="" trailing=" " val="fun"/>
                  <OtherNode start="(168, 23)" end="(168, 64)" kind="Lean.Parser.Term.basicFun">
                    <NullNode start="(168, 23)" end="(168, 26)">
                      <TermHoleNode start="(168, 23)" end="(168, 24)">
                        <AtomNode start="(168, 23)" end="(168, 24)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                      <TermHoleNode start="(168, 25)" end="(168, 26)">
                        <AtomNode start="(168, 25)" end="(168, 26)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(168, 27)" end="(168, 29)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(168, 30)" end="(168, 64)" kind="Lean.Parser.Term.subst">
                      <OtherNode start="(168, 30)" end="(168, 44)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(168, 30)" end="(168, 41)" leading="" trailing=" " raw_val="Nat.max_def" val="Nat.max_def" full_name="Nat.max_def" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        <NullNode start="(168, 42)" end="(168, 44)">
                          <OtherNode start="(168, 42)" end="(168, 44)" kind="Lean.Parser.Term.ellipsis">
                            <AtomNode start="(168, 42)" end="(168, 44)" leading="" trailing=" " val=".."/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(168, 45)" end="(168, 46)" leading="" trailing=" " val="▸"/>
                      <NullNode start="(168, 47)" end="(168, 64)">
                        <TermBytacticNode start="(168, 47)" end="(168, 64)">
                          <AtomNode start="(168, 47)" end="(168, 49)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(168, 50)" end="(168, 64)">
                            <TacticTacticseq1IndentedNode start="(168, 50)" end="(168, 64)">
                              <NullNode start="(168, 50)" end="(168, 64)">
                                <OtherNode start="(168, 50)" end="(168, 64)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="a : Nat&#10;xs : List Nat&#10;x✝¹ x✝ : Nat&#10;⊢ (if x✝¹ ≤ x✝ then x✝ else x✝¹) = x✝¹ ∨ (if x✝¹ ≤ x✝ then x✝ else x✝¹) = x✝" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                                  <OtherNode start="(168, 50)" end="(168, 55)" kind="Lean.Parser.Tactic.split">
                                    <AtomNode start="(168, 50)" end="(168, 55)" leading="" trailing=" " val="split"/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(168, 56)" end="(168, 59)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                  <OtherNode start="(168, 60)" end="(168, 64)" kind="Lean.Parser.Tactic.simp">
                                    <AtomNode start="(168, 60)" end="(168, 64)" leading="" trailing="" val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(168, 64)" end="(168, 65)" leading="" trailing="&#10;    " val=")"/>
              </OtherNode>
              <OtherNode start="(169, 5)" end="(169, 44)" kind="Lean.Parser.Term.namedArgument">
                <AtomNode start="(169, 5)" end="(169, 6)" leading="" trailing="" val="("/>
                <IdentNode start="(169, 6)" end="(169, 16)" leading="" trailing=" " raw_val="max_le_iff" val="max_le_iff"/>
                <AtomNode start="(169, 17)" end="(169, 19)" leading="" trailing=" " val=":="/>
                <OtherNode start="(169, 20)" end="(169, 43)" kind="Lean.Parser.Term.fun">
                  <AtomNode start="(169, 20)" end="(169, 23)" leading="" trailing=" " val="fun"/>
                  <OtherNode start="(169, 24)" end="(169, 43)" kind="Lean.Parser.Term.basicFun">
                    <NullNode start="(169, 24)" end="(169, 29)">
                      <TermHoleNode start="(169, 24)" end="(169, 25)">
                        <AtomNode start="(169, 24)" end="(169, 25)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                      <TermHoleNode start="(169, 26)" end="(169, 27)">
                        <AtomNode start="(169, 26)" end="(169, 27)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                      <TermHoleNode start="(169, 28)" end="(169, 29)">
                        <AtomNode start="(169, 28)" end="(169, 29)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(169, 30)" end="(169, 32)" leading="" trailing=" " val="=&amp;gt;"/>
                    <IdentNode start="(169, 33)" end="(169, 43)" leading="" trailing="" raw_val="Nat.max_le" val="Nat.max_le" full_name="Nat.max_le" mod_name="Init.Data.Nat.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/MinMax.lean"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(169, 43)" end="(169, 44)" leading="" trailing="&#10;&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(171, 1)" end="(183, 55)" name="le_max?_get_of_mem" full_name="List.le_max?_get_of_mem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(171, 1)" end="(183, 55)" name="le_max?_get_of_mem" full_name="List.le_max?_get_of_mem" _is_private_decl="False">
        <AtomNode start="(171, 1)" end="(171, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(171, 9)" end="(171, 27)">
          <IdentNode start="(171, 9)" end="(171, 27)" leading="" trailing=" " raw_val="le_max?_get_of_mem" val="le_max?_get_of_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(171, 28)" end="(172, 42)">
          <NullNode start="(171, 28)" end="(171, 64)">
            <OtherNode start="(171, 28)" end="(171, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(171, 28)" end="(171, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(171, 29)" end="(171, 30)">
                <IdentNode start="(171, 29)" end="(171, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(171, 31)" end="(171, 41)">
                <AtomNode start="(171, 31)" end="(171, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(171, 33)" end="(171, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(171, 33)" end="(171, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(171, 38)" end="(171, 41)">
                    <IdentNode start="(171, 38)" end="(171, 41)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(171, 41)" end="(171, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(171, 43)" end="(171, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(171, 43)" end="(171, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(171, 44)" end="(171, 45)">
                <IdentNode start="(171, 44)" end="(171, 45)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(171, 46)" end="(171, 51)">
                <AtomNode start="(171, 46)" end="(171, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(171, 48)" end="(171, 51)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(171, 51)" end="(171, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(171, 53)" end="(171, 64)">
              <AtomNode start="(171, 53)" end="(171, 54)" leading="" trailing="" val="("/>
              <NullNode start="(171, 54)" end="(171, 55)">
                <IdentNode start="(171, 54)" end="(171, 55)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(171, 56)" end="(171, 63)">
                <AtomNode start="(171, 56)" end="(171, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(171, 58)" end="(171, 63)" kind="«term_∈_»">
                  <IdentNode start="(171, 58)" end="(171, 59)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(171, 60)" end="(171, 61)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(171, 62)" end="(171, 63)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(171, 63)" end="(171, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(171, 65)" end="(172, 42)">
            <AtomNode start="(171, 65)" end="(171, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(172, 5)" end="(172, 42)" kind="«term_≤_»">
              <IdentNode start="(172, 5)" end="(172, 6)" leading="" trailing=" " raw_val="a" val="a"/>
              <AtomNode start="(172, 7)" end="(172, 8)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(172, 9)" end="(172, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(172, 9)" end="(172, 19)" leading="" trailing=" " raw_val="l.max?.get" val="l.max?.get"/>
                <NullNode start="(172, 20)" end="(172, 42)">
                  <OtherNode start="(172, 20)" end="(172, 42)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(172, 20)" end="(172, 21)" leading="" trailing="" val="("/>
                    <OtherNode start="(172, 21)" end="(172, 41)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(172, 21)" end="(172, 39)" leading="" trailing=" " raw_val="isSome_max?_of_mem" val="isSome_max?_of_mem" full_name="List.isSome_max?_of_mem" mod_name="Init.Data.List.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MinMax.lean"/>
                      <NullNode start="(172, 40)" end="(172, 41)">
                        <IdentNode start="(172, 40)" end="(172, 41)" leading="" trailing="" raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(172, 41)" end="(172, 42)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(172, 43)" end="(183, 55)">
          <AtomNode start="(172, 43)" end="(172, 45)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(172, 46)" end="(183, 55)">
            <AtomNode start="(172, 46)" end="(172, 48)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(173, 3)" end="(183, 55)">
              <TacticTacticseq1IndentedNode start="(173, 3)" end="(183, 55)">
                <NullNode start="(173, 3)" end="(183, 55)">
                  <OtherNode start="(173, 3)" end="(183, 55)" kind="Lean.Parser.Tactic.induction" state_before="l : List Nat&#10;a : Nat&#10;h : a ∈ l&#10;⊢ a ≤ l.max?.get ⋯" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp at h&#10;| cons b t ih =&amp;gt;&#10;  simp only [max?_cons, Option.get_some] at ih ⊢&#10;  rcases mem_cons.1 h with (rfl|h)&#10;  · cases t.max? with&#10;    | none =&amp;gt; simp&#10;    | some b =&amp;gt; simpa using Nat.le_max_left _ _&#10;  · obtain ⟨q, hq⟩ := Option.isSome_iff_exists.1 (isSome_max?_of_mem h)&#10;    simp only [hq, Option.elim_some] at ih ⊢&#10;    exact Nat.le_trans (ih h) (Nat.le_max_right _ _)">
                    <AtomNode start="(173, 3)" end="(173, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(173, 13)" end="(173, 14)">
                      <OtherNode start="(173, 13)" end="(173, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(173, 13)" end="(173, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(173, 15)" end="(183, 55)">
                      <OtherNode start="(173, 15)" end="(183, 55)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(173, 15)" end="(173, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(174, 3)" end="(183, 55)">
                          <OtherNode start="(174, 3)" end="(174, 21)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(174, 3)" end="(174, 8)">
                              <OtherNode start="(174, 3)" end="(174, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(174, 3)" end="(174, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(174, 5)" end="(174, 8)">
                                  <NullNode/>
                                  <IdentNode start="(174, 5)" end="(174, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(174, 9)" end="(174, 21)">
                              <AtomNode start="(174, 9)" end="(174, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(174, 12)" end="(174, 21)">
                                <TacticTacticseq1IndentedNode start="(174, 12)" end="(174, 21)">
                                  <NullNode start="(174, 12)" end="(174, 21)">
                                    <OtherNode start="(174, 12)" end="(174, 21)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;a : Nat&#10;h : a ∈ []&#10;⊢ a ≤ [].max?.get ⋯" state_after="no goals" tactic="simp at h">
                                      <AtomNode start="(174, 12)" end="(174, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(174, 17)" end="(174, 21)">
                                        <OtherNode start="(174, 17)" end="(174, 21)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(174, 17)" end="(174, 19)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(174, 20)" end="(174, 21)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(174, 20)" end="(174, 21)">
                                              <IdentNode start="(174, 20)" end="(174, 21)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(175, 3)" end="(183, 55)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(175, 3)" end="(175, 16)">
                              <OtherNode start="(175, 3)" end="(175, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(175, 3)" end="(175, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(175, 5)" end="(175, 9)">
                                  <NullNode/>
                                  <IdentNode start="(175, 5)" end="(175, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(175, 10)" end="(175, 16)">
                                  <IdentNode start="(175, 10)" end="(175, 11)" leading="" trailing=" " raw_val="b" val="b"/>
                                  <IdentNode start="(175, 12)" end="(175, 13)" leading="" trailing=" " raw_val="t" val="t"/>
                                  <IdentNode start="(175, 14)" end="(175, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(175, 17)" end="(183, 55)">
                              <AtomNode start="(175, 17)" end="(175, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(176, 5)" end="(183, 55)">
                                <TacticTacticseq1IndentedNode start="(176, 5)" end="(183, 55)">
                                  <NullNode start="(176, 5)" end="(183, 55)">
                                    <OtherNode start="(176, 5)" end="(176, 51)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h : a ∈ b :: t&#10;⊢ a ≤ (b :: t).max?.get ⋯" state_after="case cons&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h : a ∈ b :: t&#10;⊢ a ≤ t.max?.elim b (max b)" tactic="simp only [max?_cons, Option.get_some] at ih ⊢">
                                      <AtomNode start="(176, 5)" end="(176, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(176, 10)" end="(176, 14)">
                                        <AtomNode start="(176, 10)" end="(176, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(176, 15)" end="(176, 43)">
                                        <AtomNode start="(176, 15)" end="(176, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(176, 16)" end="(176, 42)">
                                          <OtherNode start="(176, 16)" end="(176, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(176, 16)" end="(176, 25)" leading="" trailing="" raw_val="max?_cons" val="max?_cons" full_name="List.max?_cons" mod_name="Init.Data.List.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MinMax.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(176, 25)" end="(176, 26)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(176, 27)" end="(176, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(176, 27)" end="(176, 42)" leading="" trailing="" raw_val="Option.get_some" val="Option.get_some" full_name="Option.get_some" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(176, 42)" end="(176, 43)" leading="" trailing=" " val="]"/>
                                      </NullNode>
                                      <NullNode start="(176, 44)" end="(176, 51)">
                                        <OtherNode start="(176, 44)" end="(176, 51)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(176, 44)" end="(176, 46)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(176, 47)" end="(176, 51)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(176, 47)" end="(176, 51)">
                                              <IdentNode start="(176, 47)" end="(176, 49)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                              <OtherNode start="(176, 50)" end="(176, 51)" kind="Lean.Parser.Tactic.locationType">
                                                <OtherNode start="(176, 50)" end="(176, 51)" kind="patternIgnore">
                                                  <OtherNode start="(176, 50)" end="(176, 51)" kind="token.«⊢»">
                                                    <AtomNode start="(176, 50)" end="(176, 51)" leading="" trailing="&#10;    " val="⊢"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(177, 5)" end="(177, 37)" kind="Lean.Parser.Tactic.rcases" state_before="case cons&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h : a ∈ b :: t&#10;⊢ a ≤ t.max?.elim b (max b)" state_after="case cons.inl&#10;a : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h : a ∈ a :: t&#10;⊢ a ≤ t.max?.elim a (max a)&#10;&#10;case cons.inr&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;⊢ a ≤ t.max?.elim b (max b)" tactic="rcases mem_cons.1 h with (rfl|h)">
                                      <AtomNode start="(177, 5)" end="(177, 11)" leading="" trailing=" " val="rcases"/>
                                      <NullNode start="(177, 12)" end="(177, 24)">
                                        <OtherNode start="(177, 12)" end="(177, 24)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <OtherNode start="(177, 12)" end="(177, 24)" kind="Lean.Parser.Term.app">
                                            <OtherNode start="(177, 12)" end="(177, 22)" kind="Lean.Parser.Term.proj">
                                              <IdentNode start="(177, 12)" end="(177, 20)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                              <AtomNode start="(177, 20)" end="(177, 21)" leading="" trailing="" val="."/>
                                              <OtherNode start="(177, 21)" end="(177, 22)" kind="fieldIdx">
                                                <AtomNode start="(177, 21)" end="(177, 22)" leading="" trailing=" " val="1"/>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode start="(177, 23)" end="(177, 24)">
                                              <IdentNode start="(177, 23)" end="(177, 24)" leading="" trailing=" " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode start="(177, 25)" end="(177, 37)">
                                        <AtomNode start="(177, 25)" end="(177, 29)" leading="" trailing=" " val="with"/>
                                        <OtherNode start="(177, 30)" end="(177, 37)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                          <OtherNode start="(177, 30)" end="(177, 37)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                            <NullNode start="(177, 30)" end="(177, 37)">
                                              <OtherNode start="(177, 30)" end="(177, 37)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                <AtomNode start="(177, 30)" end="(177, 31)" leading="" trailing="" val="("/>
                                                <OtherNode start="(177, 31)" end="(177, 36)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                  <OtherNode start="(177, 31)" end="(177, 36)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                    <NullNode start="(177, 31)" end="(177, 36)">
                                                      <OtherNode start="(177, 31)" end="(177, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                        <IdentNode start="(177, 31)" end="(177, 34)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                      </OtherNode>
                                                      <AtomNode start="(177, 34)" end="(177, 35)" leading="" trailing="" val="|"/>
                                                      <OtherNode start="(177, 35)" end="(177, 36)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                        <IdentNode start="(177, 35)" end="(177, 36)" leading="" trailing="" raw_val="h" val="h"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                </OtherNode>
                                                <AtomNode start="(177, 36)" end="(177, 37)" leading="" trailing="&#10;    " val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(178, 5)" end="(180, 50)" kind="Lean.cdot" state_before="case cons.inl&#10;a : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h : a ∈ a :: t&#10;⊢ a ≤ t.max?.elim a (max a)&#10;&#10;case cons.inr&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;⊢ a ≤ t.max?.elim b (max b)" state_after="case cons.inr&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;⊢ a ≤ t.max?.elim b (max b)" tactic="· cases t.max? with&#10;  | none =&amp;gt; simp&#10;  | some b =&amp;gt; simpa using Nat.le_max_left _ _">
                                      <OtherNode start="(178, 5)" end="(178, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(178, 5)" end="(178, 6)" kind="patternIgnore">
                                          <OtherNode start="(178, 5)" end="(178, 6)" kind="token.«· »">
                                            <AtomNode start="(178, 5)" end="(178, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(178, 7)" end="(180, 50)">
                                        <TacticTacticseq1IndentedNode start="(178, 7)" end="(180, 50)">
                                          <NullNode start="(178, 7)" end="(180, 50)">
                                            <OtherNode start="(178, 7)" end="(180, 50)" kind="Lean.Parser.Tactic.cases" state_before="case cons.inl&#10;a : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h : a ∈ a :: t&#10;⊢ a ≤ t.max?.elim a (max a)" state_after="no goals" tactic="cases t.max? with&#10;| none =&amp;gt; simp&#10;| some b =&amp;gt; simpa using Nat.le_max_left _ _">
                                              <AtomNode start="(178, 7)" end="(178, 12)" leading="" trailing=" " val="cases"/>
                                              <NullNode start="(178, 13)" end="(178, 19)">
                                                <OtherNode start="(178, 13)" end="(178, 19)" kind="Lean.Parser.Tactic.elimTarget">
                                                  <NullNode/>
                                                  <IdentNode start="(178, 13)" end="(178, 19)" leading="" trailing=" " raw_val="t.max?" val="t.max?"/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                              <NullNode start="(178, 20)" end="(180, 50)">
                                                <OtherNode start="(178, 20)" end="(180, 50)" kind="Lean.Parser.Tactic.inductionAlts">
                                                  <AtomNode start="(178, 20)" end="(178, 24)" leading="" trailing="&#10;      " val="with"/>
                                                  <NullNode/>
                                                  <NullNode start="(179, 7)" end="(180, 50)">
                                                    <OtherNode start="(179, 7)" end="(179, 21)" kind="Lean.Parser.Tactic.inductionAlt">
                                                      <NullNode start="(179, 7)" end="(179, 13)">
                                                        <OtherNode start="(179, 7)" end="(179, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                          <AtomNode start="(179, 7)" end="(179, 8)" leading="" trailing=" " val="|"/>
                                                          <GroupNode start="(179, 9)" end="(179, 13)">
                                                            <NullNode/>
                                                            <IdentNode start="(179, 9)" end="(179, 13)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                          </GroupNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode start="(179, 14)" end="(179, 21)">
                                                        <AtomNode start="(179, 14)" end="(179, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                                                        <TacticTacticseqNode start="(179, 17)" end="(179, 21)">
                                                          <TacticTacticseq1IndentedNode start="(179, 17)" end="(179, 21)">
                                                            <NullNode start="(179, 17)" end="(179, 21)">
                                                            <OtherNode start="(179, 17)" end="(179, 21)" kind="Lean.Parser.Tactic.simp" state_before="case cons.inl.none&#10;a : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h : a ∈ a :: t&#10;⊢ a ≤ none.elim a (max a)" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(179, 17)" end="(179, 21)" leading="" trailing="&#10;      " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <OtherNode start="(180, 7)" end="(180, 50)" kind="Lean.Parser.Tactic.inductionAlt">
                                                      <NullNode start="(180, 7)" end="(180, 15)">
                                                        <OtherNode start="(180, 7)" end="(180, 15)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                          <AtomNode start="(180, 7)" end="(180, 8)" leading="" trailing=" " val="|"/>
                                                          <GroupNode start="(180, 9)" end="(180, 13)">
                                                            <NullNode/>
                                                            <IdentNode start="(180, 9)" end="(180, 13)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                          </GroupNode>
                                                          <NullNode start="(180, 14)" end="(180, 15)">
                                                            <IdentNode start="(180, 14)" end="(180, 15)" leading="" trailing=" " raw_val="b" val="b"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode start="(180, 16)" end="(180, 50)">
                                                        <AtomNode start="(180, 16)" end="(180, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                                                        <TacticTacticseqNode start="(180, 19)" end="(180, 50)">
                                                          <TacticTacticseq1IndentedNode start="(180, 19)" end="(180, 50)">
                                                            <NullNode start="(180, 19)" end="(180, 50)">
                                                            <OtherNode start="(180, 19)" end="(180, 50)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.inl.some&#10;a : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h : a ∈ a :: t&#10;b : Nat&#10;⊢ a ≤ (some b).elim a (max a)" state_after="no goals" tactic="simpa using Nat.le_max_left _ _">
                                                            <AtomNode start="(180, 19)" end="(180, 24)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(180, 25)" end="(180, 50)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(180, 25)" end="(180, 50)">
                                                            <AtomNode start="(180, 25)" end="(180, 30)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(180, 31)" end="(180, 50)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(180, 31)" end="(180, 46)" leading="" trailing=" " raw_val="Nat.le_max_left" val="Nat.le_max_left" full_name="Nat.le_max_left" mod_name="Init.Data.Nat.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/MinMax.lean"/>
                                                            <NullNode start="(180, 47)" end="(180, 50)">
                                                            <TermHoleNode start="(180, 47)" end="(180, 48)">
                                                            <AtomNode start="(180, 47)" end="(180, 48)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(180, 49)" end="(180, 50)">
                                                            <AtomNode start="(180, 49)" end="(180, 50)" leading="" trailing="&#10;    " val="_"/>
                                                            </TermHoleNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(181, 5)" end="(183, 55)" kind="Lean.cdot" state_before="case cons.inr&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;⊢ a ≤ t.max?.elim b (max b)" state_after="no goals" tactic="· obtain ⟨q, hq⟩ := Option.isSome_iff_exists.1 (isSome_max?_of_mem h)&#10;  simp only [hq, Option.elim_some] at ih ⊢&#10;  exact Nat.le_trans (ih h) (Nat.le_max_right _ _)">
                                      <OtherNode start="(181, 5)" end="(181, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(181, 5)" end="(181, 6)" kind="patternIgnore">
                                          <OtherNode start="(181, 5)" end="(181, 6)" kind="token.«· »">
                                            <AtomNode start="(181, 5)" end="(181, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(181, 7)" end="(183, 55)">
                                        <TacticTacticseq1IndentedNode start="(181, 7)" end="(183, 55)">
                                          <NullNode start="(181, 7)" end="(183, 55)">
                                            <OtherNode start="(181, 7)" end="(181, 74)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.inr&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;⊢ a ≤ t.max?.elim b (max b)" state_after="case cons.inr.intro&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;q : Nat&#10;hq : t.max? = some q&#10;⊢ a ≤ t.max?.elim b (max b)" tactic="obtain ⟨q, hq⟩ := Option.isSome_iff_exists.1 (isSome_max?_of_mem h)">
                                              <AtomNode start="(181, 7)" end="(181, 13)" leading="" trailing=" " val="obtain"/>
                                              <NullNode start="(181, 14)" end="(181, 21)">
                                                <OtherNode start="(181, 14)" end="(181, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(181, 14)" end="(181, 21)">
                                                    <OtherNode start="(181, 14)" end="(181, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                      <AtomNode start="(181, 14)" end="(181, 15)" leading="" trailing="" val="⟨"/>
                                                      <NullNode start="(181, 15)" end="(181, 20)">
                                                        <OtherNode start="(181, 15)" end="(181, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(181, 15)" end="(181, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(181, 15)" end="(181, 16)">
                                                            <OtherNode start="(181, 15)" end="(181, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(181, 15)" end="(181, 16)" leading="" trailing="" raw_val="q" val="q"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(181, 16)" end="(181, 17)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(181, 18)" end="(181, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(181, 18)" end="(181, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(181, 18)" end="(181, 20)">
                                                            <OtherNode start="(181, 18)" end="(181, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(181, 18)" end="(181, 20)" leading="" trailing="" raw_val="hq" val="hq"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(181, 20)" end="(181, 21)" leading="" trailing=" " val="⟩"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                              <NullNode start="(181, 22)" end="(181, 74)">
                                                <AtomNode start="(181, 22)" end="(181, 24)" leading="" trailing=" " val=":="/>
                                                <NullNode start="(181, 25)" end="(181, 74)">
                                                  <OtherNode start="(181, 25)" end="(181, 74)" kind="Lean.Parser.Term.app">
                                                    <OtherNode start="(181, 25)" end="(181, 51)" kind="Lean.Parser.Term.proj">
                                                      <IdentNode start="(181, 25)" end="(181, 49)" leading="" trailing="" raw_val="Option.isSome_iff_exists" val="Option.isSome_iff_exists" full_name="Option.isSome_iff_exists" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                                      <AtomNode start="(181, 49)" end="(181, 50)" leading="" trailing="" val="."/>
                                                      <OtherNode start="(181, 50)" end="(181, 51)" kind="fieldIdx">
                                                        <AtomNode start="(181, 50)" end="(181, 51)" leading="" trailing=" " val="1"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <NullNode start="(181, 52)" end="(181, 74)">
                                                      <OtherNode start="(181, 52)" end="(181, 74)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(181, 52)" end="(181, 53)" leading="" trailing="" val="("/>
                                                        <OtherNode start="(181, 53)" end="(181, 73)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(181, 53)" end="(181, 71)" leading="" trailing=" " raw_val="isSome_max?_of_mem" val="isSome_max?_of_mem" full_name="List.isSome_max?_of_mem" mod_name="Init.Data.List.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MinMax.lean"/>
                                                          <NullNode start="(181, 72)" end="(181, 73)">
                                                            <IdentNode start="(181, 72)" end="(181, 73)" leading="" trailing="" raw_val="h" val="h"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <AtomNode start="(181, 73)" end="(181, 74)" leading="" trailing="&#10;      " val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(182, 7)" end="(182, 47)" kind="Lean.Parser.Tactic.simp" state_before="case cons.inr.intro&#10;a b : Nat&#10;t : List Nat&#10;ih : ∀ (h : a ∈ t), a ≤ t.max?.get ⋯&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;q : Nat&#10;hq : t.max? = some q&#10;⊢ a ≤ t.max?.elim b (max b)" state_after="case cons.inr.intro&#10;a b : Nat&#10;t : List Nat&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;q : Nat&#10;hq : t.max? = some q&#10;ih : ∀ (h : a ∈ t), a ≤ (some q).get ⋯&#10;⊢ a ≤ max b q" tactic="simp only [hq, Option.elim_some] at ih ⊢">
                                              <AtomNode start="(182, 7)" end="(182, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(182, 12)" end="(182, 16)">
                                                <AtomNode start="(182, 12)" end="(182, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(182, 17)" end="(182, 39)">
                                                <AtomNode start="(182, 17)" end="(182, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(182, 18)" end="(182, 38)">
                                                  <OtherNode start="(182, 18)" end="(182, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(182, 18)" end="(182, 20)" leading="" trailing="" raw_val="hq" val="hq"/>
                                                  </OtherNode>
                                                  <AtomNode start="(182, 20)" end="(182, 21)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(182, 22)" end="(182, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(182, 22)" end="(182, 38)" leading="" trailing="" raw_val="Option.elim_some" val="Option.elim_some" full_name="Option.elim_some" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(182, 38)" end="(182, 39)" leading="" trailing=" " val="]"/>
                                              </NullNode>
                                              <NullNode start="(182, 40)" end="(182, 47)">
                                                <OtherNode start="(182, 40)" end="(182, 47)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(182, 40)" end="(182, 42)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(182, 43)" end="(182, 47)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(182, 43)" end="(182, 47)">
                                                      <IdentNode start="(182, 43)" end="(182, 45)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                      <OtherNode start="(182, 46)" end="(182, 47)" kind="Lean.Parser.Tactic.locationType">
                                                        <OtherNode start="(182, 46)" end="(182, 47)" kind="patternIgnore">
                                                          <OtherNode start="(182, 46)" end="(182, 47)" kind="token.«⊢»">
                                                            <AtomNode start="(182, 46)" end="(182, 47)" leading="" trailing="&#10;      " val="⊢"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(183, 7)" end="(183, 55)" kind="Lean.Parser.Tactic.exact" state_before="case cons.inr.intro&#10;a b : Nat&#10;t : List Nat&#10;h✝ : a ∈ b :: t&#10;h : a ∈ t&#10;q : Nat&#10;hq : t.max? = some q&#10;ih : ∀ (h : a ∈ t), a ≤ (some q).get ⋯&#10;⊢ a ≤ max b q" state_after="no goals" tactic="exact Nat.le_trans (ih h) (Nat.le_max_right _ _)">
                                              <AtomNode start="(183, 7)" end="(183, 12)" leading="" trailing=" " val="exact"/>
                                              <OtherNode start="(183, 13)" end="(183, 55)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(183, 13)" end="(183, 25)" leading="" trailing=" " raw_val="Nat.le_trans" val="Nat.le_trans" full_name="Nat.le_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                <NullNode start="(183, 26)" end="(183, 55)">
                                                  <OtherNode start="(183, 26)" end="(183, 32)" kind="Lean.Parser.Term.paren">
                                                    <AtomNode start="(183, 26)" end="(183, 27)" leading="" trailing="" val="("/>
                                                    <OtherNode start="(183, 27)" end="(183, 31)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(183, 27)" end="(183, 29)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                      <NullNode start="(183, 30)" end="(183, 31)">
                                                        <IdentNode start="(183, 30)" end="(183, 31)" leading="" trailing="" raw_val="h" val="h"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <AtomNode start="(183, 31)" end="(183, 32)" leading="" trailing=" " val=")"/>
                                                  </OtherNode>
                                                  <OtherNode start="(183, 33)" end="(183, 55)" kind="Lean.Parser.Term.paren">
                                                    <AtomNode start="(183, 33)" end="(183, 34)" leading="" trailing="" val="("/>
                                                    <OtherNode start="(183, 34)" end="(183, 54)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(183, 34)" end="(183, 50)" leading="" trailing=" " raw_val="Nat.le_max_right" val="Nat.le_max_right" full_name="Nat.le_max_right" mod_name="Init.Data.Nat.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/MinMax.lean"/>
                                                      <NullNode start="(183, 51)" end="(183, 54)">
                                                        <TermHoleNode start="(183, 51)" end="(183, 52)">
                                                          <AtomNode start="(183, 51)" end="(183, 52)" leading="" trailing=" " val="_"/>
                                                        </TermHoleNode>
                                                        <TermHoleNode start="(183, 53)" end="(183, 54)">
                                                          <AtomNode start="(183, 53)" end="(183, 54)" leading="" trailing="" val="_"/>
                                                        </TermHoleNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <AtomNode start="(183, 54)" end="(183, 55)" leading="" trailing="&#10;&#10;" val=")"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(185, 1)" end="(187, 46)" name="le_max?_getD_of_mem" full_name="List.le_max?_getD_of_mem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(185, 1)" end="(187, 46)" name="le_max?_getD_of_mem" full_name="List.le_max?_getD_of_mem" _is_private_decl="False">
        <AtomNode start="(185, 1)" end="(185, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(185, 9)" end="(185, 28)">
          <IdentNode start="(185, 9)" end="(185, 28)" leading="" trailing=" " raw_val="le_max?_getD_of_mem" val="le_max?_getD_of_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(185, 29)" end="(186, 22)">
          <NullNode start="(185, 29)" end="(185, 67)">
            <OtherNode start="(185, 29)" end="(185, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(185, 29)" end="(185, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(185, 30)" end="(185, 31)">
                <IdentNode start="(185, 30)" end="(185, 31)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(185, 32)" end="(185, 42)">
                <AtomNode start="(185, 32)" end="(185, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(185, 34)" end="(185, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(185, 34)" end="(185, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(185, 39)" end="(185, 42)">
                    <IdentNode start="(185, 39)" end="(185, 42)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(185, 42)" end="(185, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(185, 44)" end="(185, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(185, 44)" end="(185, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(185, 45)" end="(185, 48)">
                <IdentNode start="(185, 45)" end="(185, 46)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(185, 47)" end="(185, 48)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(185, 49)" end="(185, 54)">
                <AtomNode start="(185, 49)" end="(185, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(185, 51)" end="(185, 54)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(185, 54)" end="(185, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(185, 56)" end="(185, 67)">
              <AtomNode start="(185, 56)" end="(185, 57)" leading="" trailing="" val="("/>
              <NullNode start="(185, 57)" end="(185, 58)">
                <IdentNode start="(185, 57)" end="(185, 58)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(185, 59)" end="(185, 66)">
                <AtomNode start="(185, 59)" end="(185, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(185, 61)" end="(185, 66)" kind="«term_∈_»">
                  <IdentNode start="(185, 61)" end="(185, 62)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(185, 63)" end="(185, 64)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(185, 65)" end="(185, 66)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(185, 66)" end="(185, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(185, 68)" end="(186, 22)">
            <AtomNode start="(185, 68)" end="(185, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(186, 5)" end="(186, 22)" kind="«term_≤_»">
              <IdentNode start="(186, 5)" end="(186, 6)" leading="" trailing=" " raw_val="a" val="a"/>
              <AtomNode start="(186, 7)" end="(186, 8)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(186, 9)" end="(186, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(186, 9)" end="(186, 20)" leading="" trailing=" " raw_val="l.max?.getD" val="l.max?.getD"/>
                <NullNode start="(186, 21)" end="(186, 22)">
                  <IdentNode start="(186, 21)" end="(186, 22)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(186, 23)" end="(187, 46)">
          <AtomNode start="(186, 23)" end="(186, 25)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(187, 3)" end="(187, 46)" kind="Lean.Parser.Term.subst">
            <OtherNode start="(187, 3)" end="(187, 23)" kind="Lean.Parser.Term.app">
              <IdentNode start="(187, 3)" end="(187, 21)" leading="" trailing=" " raw_val="Option.get_eq_getD" val="Option.get_eq_getD" full_name="Option.get_eq_getD" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
              <NullNode start="(187, 22)" end="(187, 23)">
                <TermHoleNode start="(187, 22)" end="(187, 23)">
                  <AtomNode start="(187, 22)" end="(187, 23)" leading="" trailing=" " val="_"/>
                </TermHoleNode>
              </NullNode>
            </OtherNode>
            <AtomNode start="(187, 24)" end="(187, 25)" leading="" trailing=" " val="▸"/>
            <NullNode start="(187, 26)" end="(187, 46)">
              <OtherNode start="(187, 26)" end="(187, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(187, 26)" end="(187, 44)" leading="" trailing=" " raw_val="le_max?_get_of_mem" val="le_max?_get_of_mem" full_name="List.le_max?_get_of_mem" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean" def_start="(171, 9)" def_end="(171, 27)"/>
                <NullNode start="(187, 45)" end="(187, 46)">
                  <IdentNode start="(187, 45)" end="(187, 46)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(189, 1)" end="(189, 107)" name="minimum?_eq_some_iff'" full_name="List.minimum?_eq_some_iff'">
      <CommandDeclmodifiersNode start="(189, 1)" end="(189, 56)">
        <NullNode/>
        <NullNode start="(189, 1)" end="(189, 56)">
          <OtherNode start="(189, 1)" end="(189, 56)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(189, 1)" end="(189, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(189, 3)" end="(189, 55)">
              <OtherNode start="(189, 3)" end="(189, 55)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(189, 3)" end="(189, 55)" kind="Lean.deprecated">
                  <AtomNode start="(189, 3)" end="(189, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(189, 14)" end="(189, 31)">
                    <IdentNode start="(189, 14)" end="(189, 31)" leading="" trailing=" " raw_val="min?_eq_some_iff'" val="min?_eq_some_iff'" full_name="List.min?_eq_some_iff'" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean" def_start="(137, 9)" def_end="(137, 26)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(189, 32)" end="(189, 55)">
                    <AtomNode start="(189, 32)" end="(189, 33)" leading="" trailing="" val="("/>
                    <AtomNode start="(189, 33)" end="(189, 38)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(189, 39)" end="(189, 41)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(189, 42)" end="(189, 54)" kind="str">
                      <AtomNode start="(189, 42)" end="(189, 54)" leading="" trailing="" val="&amp;quot;2024-09-29&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(189, 54)" end="(189, 55)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(189, 55)" end="(189, 56)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(189, 57)" end="(189, 107)" name="minimum?_eq_some_iff'">
        <AtomNode start="(189, 57)" end="(189, 63)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(189, 64)" end="(189, 85)">
          <IdentNode start="(189, 64)" end="(189, 85)" leading="" trailing=" " raw_val="minimum?_eq_some_iff'" val="minimum?_eq_some_iff'"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(189, 86)" end="(189, 107)">
          <AtomNode start="(189, 86)" end="(189, 88)" leading="" trailing=" " val=":="/>
          <OtherNode start="(189, 89)" end="(189, 107)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(189, 89)" end="(189, 90)" leading="" trailing="" val="@"/>
            <IdentNode start="(189, 90)" end="(189, 107)" leading="" trailing="&#10;" raw_val="min?_eq_some_iff'" val="min?_eq_some_iff'" full_name="List.min?_eq_some_iff'" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean" def_start="(137, 9)" def_end="(137, 26)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(190, 1)" end="(190, 86)" name="minimum?_cons'" full_name="List.minimum?_cons'">
      <CommandDeclmodifiersNode start="(190, 1)" end="(190, 49)">
        <NullNode/>
        <NullNode start="(190, 1)" end="(190, 49)">
          <OtherNode start="(190, 1)" end="(190, 49)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(190, 1)" end="(190, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(190, 3)" end="(190, 48)">
              <OtherNode start="(190, 3)" end="(190, 48)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(190, 3)" end="(190, 48)" kind="Lean.deprecated">
                  <AtomNode start="(190, 3)" end="(190, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(190, 14)" end="(190, 24)">
                    <IdentNode start="(190, 14)" end="(190, 24)" leading="" trailing=" " raw_val="min?_cons'" val="min?_cons'" full_name="List.min?_cons'" mod_name="Init.Data.List.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MinMax.lean"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(190, 25)" end="(190, 48)">
                    <AtomNode start="(190, 25)" end="(190, 26)" leading="" trailing="" val="("/>
                    <AtomNode start="(190, 26)" end="(190, 31)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(190, 32)" end="(190, 34)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(190, 35)" end="(190, 47)" kind="str">
                      <AtomNode start="(190, 35)" end="(190, 47)" leading="" trailing="" val="&amp;quot;2024-09-29&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(190, 47)" end="(190, 48)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(190, 48)" end="(190, 49)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(190, 50)" end="(190, 86)" name="minimum?_cons'">
        <AtomNode start="(190, 50)" end="(190, 56)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(190, 57)" end="(190, 71)">
          <IdentNode start="(190, 57)" end="(190, 71)" leading="" trailing=" " raw_val="minimum?_cons'" val="minimum?_cons'"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(190, 72)" end="(190, 86)">
          <AtomNode start="(190, 72)" end="(190, 74)" leading="" trailing=" " val=":="/>
          <OtherNode start="(190, 75)" end="(190, 86)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(190, 75)" end="(190, 76)" leading="" trailing="" val="@"/>
            <IdentNode start="(190, 76)" end="(190, 86)" leading="" trailing="&#10;" raw_val="min?_cons'" val="min?_cons'" full_name="List.min?_cons'" mod_name="Init.Data.List.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MinMax.lean"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(191, 1)" end="(191, 113)" name="minimum?_getD_le_of_mem" full_name="List.minimum?_getD_le_of_mem">
      <CommandDeclmodifiersNode start="(191, 1)" end="(191, 58)">
        <NullNode/>
        <NullNode start="(191, 1)" end="(191, 58)">
          <OtherNode start="(191, 1)" end="(191, 58)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(191, 1)" end="(191, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(191, 3)" end="(191, 57)">
              <OtherNode start="(191, 3)" end="(191, 57)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(191, 3)" end="(191, 57)" kind="Lean.deprecated">
                  <AtomNode start="(191, 3)" end="(191, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(191, 14)" end="(191, 33)">
                    <IdentNode start="(191, 14)" end="(191, 33)" leading="" trailing=" " raw_val="min?_getD_le_of_mem" val="min?_getD_le_of_mem" full_name="List.min?_getD_le_of_mem" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean" def_start="(158, 9)" def_end="(158, 28)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(191, 34)" end="(191, 57)">
                    <AtomNode start="(191, 34)" end="(191, 35)" leading="" trailing="" val="("/>
                    <AtomNode start="(191, 35)" end="(191, 40)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(191, 41)" end="(191, 43)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(191, 44)" end="(191, 56)" kind="str">
                      <AtomNode start="(191, 44)" end="(191, 56)" leading="" trailing="" val="&amp;quot;2024-09-29&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(191, 56)" end="(191, 57)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(191, 57)" end="(191, 58)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(191, 59)" end="(191, 113)" name="minimum?_getD_le_of_mem">
        <AtomNode start="(191, 59)" end="(191, 65)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(191, 66)" end="(191, 89)">
          <IdentNode start="(191, 66)" end="(191, 89)" leading="" trailing=" " raw_val="minimum?_getD_le_of_mem" val="minimum?_getD_le_of_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(191, 90)" end="(191, 113)">
          <AtomNode start="(191, 90)" end="(191, 92)" leading="" trailing=" " val=":="/>
          <OtherNode start="(191, 93)" end="(191, 113)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(191, 93)" end="(191, 94)" leading="" trailing="" val="@"/>
            <IdentNode start="(191, 94)" end="(191, 113)" leading="" trailing="&#10;" raw_val="min?_getD_le_of_mem" val="min?_getD_le_of_mem" full_name="List.min?_getD_le_of_mem" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean" def_start="(158, 9)" def_end="(158, 28)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(192, 1)" end="(192, 107)" name="maximum?_eq_some_iff'" full_name="List.maximum?_eq_some_iff'">
      <CommandDeclmodifiersNode start="(192, 1)" end="(192, 56)">
        <NullNode/>
        <NullNode start="(192, 1)" end="(192, 56)">
          <OtherNode start="(192, 1)" end="(192, 56)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(192, 1)" end="(192, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(192, 3)" end="(192, 55)">
              <OtherNode start="(192, 3)" end="(192, 55)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(192, 3)" end="(192, 55)" kind="Lean.deprecated">
                  <AtomNode start="(192, 3)" end="(192, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(192, 14)" end="(192, 31)">
                    <IdentNode start="(192, 14)" end="(192, 31)" leading="" trailing=" " raw_val="max?_eq_some_iff'" val="max?_eq_some_iff'" full_name="List.max?_eq_some_iff'" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean" def_start="(164, 9)" def_end="(164, 26)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(192, 32)" end="(192, 55)">
                    <AtomNode start="(192, 32)" end="(192, 33)" leading="" trailing="" val="("/>
                    <AtomNode start="(192, 33)" end="(192, 38)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(192, 39)" end="(192, 41)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(192, 42)" end="(192, 54)" kind="str">
                      <AtomNode start="(192, 42)" end="(192, 54)" leading="" trailing="" val="&amp;quot;2024-09-29&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(192, 54)" end="(192, 55)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(192, 55)" end="(192, 56)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(192, 57)" end="(192, 107)" name="maximum?_eq_some_iff'">
        <AtomNode start="(192, 57)" end="(192, 63)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(192, 64)" end="(192, 85)">
          <IdentNode start="(192, 64)" end="(192, 85)" leading="" trailing=" " raw_val="maximum?_eq_some_iff'" val="maximum?_eq_some_iff'"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(192, 86)" end="(192, 107)">
          <AtomNode start="(192, 86)" end="(192, 88)" leading="" trailing=" " val=":="/>
          <OtherNode start="(192, 89)" end="(192, 107)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(192, 89)" end="(192, 90)" leading="" trailing="" val="@"/>
            <IdentNode start="(192, 90)" end="(192, 107)" leading="" trailing="&#10;" raw_val="max?_eq_some_iff'" val="max?_eq_some_iff'" full_name="List.max?_eq_some_iff'" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean" def_start="(164, 9)" def_end="(164, 26)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(193, 1)" end="(193, 86)" name="maximum?_cons'" full_name="List.maximum?_cons'">
      <CommandDeclmodifiersNode start="(193, 1)" end="(193, 49)">
        <NullNode/>
        <NullNode start="(193, 1)" end="(193, 49)">
          <OtherNode start="(193, 1)" end="(193, 49)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(193, 1)" end="(193, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(193, 3)" end="(193, 48)">
              <OtherNode start="(193, 3)" end="(193, 48)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(193, 3)" end="(193, 48)" kind="Lean.deprecated">
                  <AtomNode start="(193, 3)" end="(193, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(193, 14)" end="(193, 24)">
                    <IdentNode start="(193, 14)" end="(193, 24)" leading="" trailing=" " raw_val="max?_cons'" val="max?_cons'" full_name="List.max?_cons'" mod_name="Init.Data.List.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MinMax.lean"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(193, 25)" end="(193, 48)">
                    <AtomNode start="(193, 25)" end="(193, 26)" leading="" trailing="" val="("/>
                    <AtomNode start="(193, 26)" end="(193, 31)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(193, 32)" end="(193, 34)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(193, 35)" end="(193, 47)" kind="str">
                      <AtomNode start="(193, 35)" end="(193, 47)" leading="" trailing="" val="&amp;quot;2024-09-29&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(193, 47)" end="(193, 48)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(193, 48)" end="(193, 49)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(193, 50)" end="(193, 86)" name="maximum?_cons'">
        <AtomNode start="(193, 50)" end="(193, 56)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(193, 57)" end="(193, 71)">
          <IdentNode start="(193, 57)" end="(193, 71)" leading="" trailing=" " raw_val="maximum?_cons'" val="maximum?_cons'"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(193, 72)" end="(193, 86)">
          <AtomNode start="(193, 72)" end="(193, 74)" leading="" trailing=" " val=":="/>
          <OtherNode start="(193, 75)" end="(193, 86)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(193, 75)" end="(193, 76)" leading="" trailing="" val="@"/>
            <IdentNode start="(193, 76)" end="(193, 86)" leading="" trailing="&#10;" raw_val="max?_cons'" val="max?_cons'" full_name="List.max?_cons'" mod_name="Init.Data.List.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MinMax.lean"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(194, 1)" end="(194, 113)" name="le_maximum?_getD_of_mem" full_name="List.le_maximum?_getD_of_mem">
      <CommandDeclmodifiersNode start="(194, 1)" end="(194, 58)">
        <NullNode/>
        <NullNode start="(194, 1)" end="(194, 58)">
          <OtherNode start="(194, 1)" end="(194, 58)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(194, 1)" end="(194, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(194, 3)" end="(194, 57)">
              <OtherNode start="(194, 3)" end="(194, 57)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(194, 3)" end="(194, 57)" kind="Lean.deprecated">
                  <AtomNode start="(194, 3)" end="(194, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(194, 14)" end="(194, 33)">
                    <IdentNode start="(194, 14)" end="(194, 33)" leading="" trailing=" " raw_val="le_max?_getD_of_mem" val="le_max?_getD_of_mem" full_name="List.le_max?_getD_of_mem" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean" def_start="(185, 9)" def_end="(185, 28)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(194, 34)" end="(194, 57)">
                    <AtomNode start="(194, 34)" end="(194, 35)" leading="" trailing="" val="("/>
                    <AtomNode start="(194, 35)" end="(194, 40)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(194, 41)" end="(194, 43)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(194, 44)" end="(194, 56)" kind="str">
                      <AtomNode start="(194, 44)" end="(194, 56)" leading="" trailing="" val="&amp;quot;2024-09-29&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(194, 56)" end="(194, 57)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(194, 57)" end="(194, 58)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(194, 59)" end="(194, 113)" name="le_maximum?_getD_of_mem">
        <AtomNode start="(194, 59)" end="(194, 65)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(194, 66)" end="(194, 89)">
          <IdentNode start="(194, 66)" end="(194, 89)" leading="" trailing=" " raw_val="le_maximum?_getD_of_mem" val="le_maximum?_getD_of_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(194, 90)" end="(194, 113)">
          <AtomNode start="(194, 90)" end="(194, 92)" leading="" trailing=" " val=":="/>
          <OtherNode start="(194, 93)" end="(194, 113)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(194, 93)" end="(194, 94)" leading="" trailing="" val="@"/>
            <IdentNode start="(194, 94)" end="(194, 113)" leading="" trailing="&#10;&#10;" raw_val="le_max?_getD_of_mem" val="le_max?_getD_of_mem" full_name="List.le_max?_getD_of_mem" mod_name="Init.Data.List.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Basic.lean" def_start="(185, 9)" def_end="(185, 28)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(196, 1)" end="(196, 9)" name="List">
      <AtomNode start="(196, 1)" end="(196, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(196, 5)" end="(196, 9)">
        <IdentNode start="(196, 5)" end="(196, 9)" leading="" trailing="&#10;" raw_val="List" val="List"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(14, 1)" end="(18, 3)" text="# Miscellaneous `List` lemmas, that require more `Nat` lemmas than are available in `Init.Data.List.Lemmas`.&#10;&#10;In particular, `omega` is available here.&#10;-/"/>
    <Comment start="(20, 38)" end="(21, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(21, 39)" end="(23, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(27, 1)" end="(27, 20)" text="### dropLast -/"/>
    <Comment start="(47, 1)" end="(47, 18)" text="### filter -/"/>
    <Comment start="(60, 1)" end="(60, 21)" text="### filterMap -/"/>
    <Comment start="(86, 1)" end="(86, 19)" text="### reverse -/"/>
    <Comment start="(94, 1)" end="(94, 19)" text="### leftpad -/"/>
    <Comment start="(96, 1)" end="(97, 41)" text="The length of the List returned by `List.leftpad n a l` is equal&#10;  to the larger of `n` and `l.length` -/"/>
    <Comment start="(98, 1)" end="(100, 1)" text="-- We don't mark this as a `@[simp]` lemma since we allow `simp` to unfold `leftpad`,&#10;-- so the left hand side simplifies directly to `n - l.length + l.length`.&#10;"/>
    <Comment start="(112, 1)" end="(112, 20)" text="### eraseIdx -/"/>
    <Comment start="(134, 1)" end="(134, 16)" text="### min? -/"/>
    <Comment start="(136, 1)" end="(137, 1)" text="-- A specialization of `min?_eq_some_iff` to Nat.&#10;"/>
    <Comment start="(161, 1)" end="(161, 16)" text="### max? -/"/>
    <Comment start="(163, 1)" end="(164, 1)" text="-- A specialization of `max?_eq_some_iff` to Nat.&#10;"/>
  </Comments>
</TracedFile>
