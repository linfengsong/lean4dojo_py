<TracedFile path="src/lean/Init/Data/List/Nat/BEq.lean" md5="a2afedf42cb59588526b806254ca60d8">
  <FileNode start="(1, 1)" end="(52, 9)">
    <ModuleHeaderNode start="(6, 1)" end="(10, 28)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(10, 28)">
        <ModuleImportNode start="(9, 1)" end="(9, 28)" module="Init.Data.Nat.Lemmas" path="src/lean/Init/Data/Nat/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 28)" leading="" trailing="&#10;" raw_val="Init.Data.Nat.Lemmas" val="Init.Data.Nat.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 28)" module="Init.Data.List.Basic" path="src/lean/Init/Data/List/Basic.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 28)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.List.Basic" val="Init.Data.List.Basic"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <OtherNode start="(12, 1)" end="(12, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(12, 1)" end="(12, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(12, 12)" end="(12, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(12, 33)" end="(12, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(13, 1)" end="(13, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(13, 1)" end="(13, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(13, 12)" end="(13, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(13, 34)" end="(13, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(15, 1)" end="(15, 15)" name="List">
      <AtomNode start="(15, 1)" end="(15, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(15, 11)" end="(15, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandModuledocNode start="(17, 1)" end="(17, 17)" comment="### isEqv -/">
      <AtomNode start="(17, 1)" end="(17, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(17, 5)" end="(17, 17)" leading="" trailing="&#10;&#10;" val="### isEqv -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(19, 1)" end="(30, 48)" name="isEqv_eq_decide" full_name="List.isEqv_eq_decide">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(19, 1)" end="(30, 48)" name="isEqv_eq_decide" full_name="List.isEqv_eq_decide" _is_private_decl="False">
        <AtomNode start="(19, 1)" end="(19, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(19, 9)" end="(19, 24)">
          <IdentNode start="(19, 9)" end="(19, 24)" leading="" trailing=" " raw_val="isEqv_eq_decide" val="isEqv_eq_decide"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(19, 25)" end="(21, 96)">
          <NullNode start="(19, 25)" end="(19, 60)">
            <OtherNode start="(19, 25)" end="(19, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(19, 25)" end="(19, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(19, 26)" end="(19, 31)">
                <IdentNode start="(19, 26)" end="(19, 28)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(19, 29)" end="(19, 31)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(19, 32)" end="(19, 40)">
                <AtomNode start="(19, 32)" end="(19, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(19, 34)" end="(19, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(19, 34)" end="(19, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(19, 39)" end="(19, 40)">
                    <IdentNode start="(19, 39)" end="(19, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(19, 40)" end="(19, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(19, 42)" end="(19, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(19, 42)" end="(19, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(19, 43)" end="(19, 44)">
                <IdentNode start="(19, 43)" end="(19, 44)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(19, 45)" end="(19, 59)">
                <AtomNode start="(19, 45)" end="(19, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(19, 47)" end="(19, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(19, 47)" end="(19, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(19, 49)" end="(19, 50)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(19, 51)" end="(19, 59)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(19, 51)" end="(19, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(19, 53)" end="(19, 54)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(19, 55)" end="(19, 59)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(19, 59)" end="(19, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(19, 61)" end="(21, 96)">
            <AtomNode start="(19, 61)" end="(19, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(20, 5)" end="(21, 96)" kind="«term_=_»">
              <OtherNode start="(20, 5)" end="(20, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(20, 5)" end="(20, 10)" leading="" trailing=" " raw_val="isEqv" val="isEqv" full_name="List.isEqv" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(20, 11)" end="(20, 18)">
                  <IdentNode start="(20, 11)" end="(20, 13)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(20, 14)" end="(20, 16)" leading="" trailing=" " raw_val="bs" val="bs"/>
                  <IdentNode start="(20, 17)" end="(20, 18)" leading="" trailing=" " raw_val="r" val="r"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(20, 19)" end="(20, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(20, 21)" end="(21, 96)" kind="termDepIfThenElse">
                <AtomNode start="(20, 21)" end="(20, 23)" leading="" trailing=" " val="if"/>
                <LeanBinderidentNode start="(20, 24)" end="(20, 25)">
                  <IdentNode start="(20, 24)" end="(20, 25)" leading="" trailing=" " raw_val="h" val="h"/>
                </LeanBinderidentNode>
                <AtomNode start="(20, 26)" end="(20, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(20, 28)" end="(20, 49)" kind="«term_=_»">
                  <IdentNode start="(20, 28)" end="(20, 37)" leading="" trailing=" " raw_val="as.length" val="as.length"/>
                  <AtomNode start="(20, 38)" end="(20, 39)" leading="" trailing=" " val="="/>
                  <IdentNode start="(20, 40)" end="(20, 49)" leading="" trailing=" " raw_val="bs.length" val="bs.length"/>
                </OtherNode>
                <AtomNode start="(20, 50)" end="(20, 54)" leading="" trailing="&#10;      " val="then"/>
                <OtherNode start="(21, 7)" end="(21, 85)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(21, 7)" end="(21, 13)" leading="" trailing=" " raw_val="decide" val="decide" full_name="Decidable.decide" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(21, 14)" end="(21, 85)">
                    <OtherNode start="(21, 14)" end="(21, 85)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(21, 14)" end="(21, 15)" leading="" trailing="" val="("/>
                      <OtherNode start="(21, 15)" end="(21, 84)" kind="Lean.Parser.Term.forall">
                        <AtomNode start="(21, 15)" end="(21, 16)" leading="" trailing=" " val="∀"/>
                        <NullNode start="(21, 17)" end="(21, 47)">
                          <TermExplicitbinderNode start="(21, 17)" end="(21, 26)">
                            <AtomNode start="(21, 17)" end="(21, 18)" leading="" trailing="" val="("/>
                            <NullNode start="(21, 18)" end="(21, 19)">
                              <IdentNode start="(21, 18)" end="(21, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                            </NullNode>
                            <NullNode start="(21, 20)" end="(21, 25)">
                              <AtomNode start="(21, 20)" end="(21, 21)" leading="" trailing=" " val=":"/>
                              <IdentNode start="(21, 22)" end="(21, 25)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(21, 25)" end="(21, 26)" leading="" trailing=" " val=")"/>
                          </TermExplicitbinderNode>
                          <TermExplicitbinderNode start="(21, 27)" end="(21, 47)">
                            <AtomNode start="(21, 27)" end="(21, 28)" leading="" trailing="" val="("/>
                            <NullNode start="(21, 28)" end="(21, 30)">
                              <IdentNode start="(21, 28)" end="(21, 30)" leading="" trailing=" " raw_val="h'" val="h'"/>
                            </NullNode>
                            <NullNode start="(21, 31)" end="(21, 46)">
                              <AtomNode start="(21, 31)" end="(21, 32)" leading="" trailing=" " val=":"/>
                              <OtherNode start="(21, 33)" end="(21, 46)" kind="«term_&amp;lt;_»">
                                <IdentNode start="(21, 33)" end="(21, 34)" leading="" trailing=" " raw_val="i" val="i"/>
                                <AtomNode start="(21, 35)" end="(21, 36)" leading="" trailing=" " val="&amp;lt;"/>
                                <IdentNode start="(21, 37)" end="(21, 46)" leading="" trailing="" raw_val="as.length" val="as.length"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(21, 46)" end="(21, 47)" leading="" trailing="" val=")"/>
                          </TermExplicitbinderNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(21, 47)" end="(21, 48)" leading="" trailing=" " val=","/>
                        <OtherNode start="(21, 49)" end="(21, 84)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(21, 49)" end="(21, 50)" leading="" trailing=" " raw_val="r" val="r"/>
                          <NullNode start="(21, 51)" end="(21, 84)">
                            <OtherNode start="(21, 51)" end="(21, 67)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(21, 51)" end="(21, 52)" leading="" trailing="" val="("/>
                              <OtherNode start="(21, 52)" end="(21, 66)" kind="«term__[_]'_»">
                                <IdentNode start="(21, 52)" end="(21, 54)" leading="" trailing="" raw_val="as" val="as"/>
                                <AtomNode start="(21, 54)" end="(21, 55)" leading="" trailing="" val="["/>
                                <IdentNode start="(21, 55)" end="(21, 56)" leading="" trailing="" raw_val="i" val="i"/>
                                <AtomNode start="(21, 56)" end="(21, 58)" leading="" trailing="" val="]'"/>
                                <OtherNode start="(21, 58)" end="(21, 66)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(21, 58)" end="(21, 59)" leading="" trailing="" val="("/>
                                  <OtherNode start="(21, 59)" end="(21, 65)" kind="Lean.Parser.Term.subst">
                                    <IdentNode start="(21, 59)" end="(21, 60)" leading="" trailing=" " raw_val="h" val="h"/>
                                    <AtomNode start="(21, 61)" end="(21, 62)" leading="" trailing=" " val="▸"/>
                                    <NullNode start="(21, 63)" end="(21, 65)">
                                      <IdentNode start="(21, 63)" end="(21, 65)" leading="" trailing="" raw_val="h'" val="h'"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(21, 65)" end="(21, 66)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(21, 66)" end="(21, 67)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <OtherNode start="(21, 68)" end="(21, 84)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(21, 68)" end="(21, 69)" leading="" trailing="" val="("/>
                              <OtherNode start="(21, 69)" end="(21, 83)" kind="«term__[_]'_»">
                                <IdentNode start="(21, 69)" end="(21, 71)" leading="" trailing="" raw_val="bs" val="bs"/>
                                <AtomNode start="(21, 71)" end="(21, 72)" leading="" trailing="" val="["/>
                                <IdentNode start="(21, 72)" end="(21, 73)" leading="" trailing="" raw_val="i" val="i"/>
                                <AtomNode start="(21, 73)" end="(21, 75)" leading="" trailing="" val="]'"/>
                                <OtherNode start="(21, 75)" end="(21, 83)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(21, 75)" end="(21, 76)" leading="" trailing="" val="("/>
                                  <OtherNode start="(21, 76)" end="(21, 82)" kind="Lean.Parser.Term.subst">
                                    <IdentNode start="(21, 76)" end="(21, 77)" leading="" trailing=" " raw_val="h" val="h"/>
                                    <AtomNode start="(21, 78)" end="(21, 79)" leading="" trailing=" " val="▸"/>
                                    <NullNode start="(21, 80)" end="(21, 82)">
                                      <IdentNode start="(21, 80)" end="(21, 82)" leading="" trailing="" raw_val="h'" val="h'"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(21, 82)" end="(21, 83)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(21, 83)" end="(21, 84)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(21, 84)" end="(21, 85)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(21, 86)" end="(21, 90)" leading="" trailing=" " val="else"/>
                <IdentNode start="(21, 91)" end="(21, 96)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(21, 97)" end="(30, 48)">
          <AtomNode start="(21, 97)" end="(21, 99)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(21, 100)" end="(30, 48)">
            <AtomNode start="(21, 100)" end="(21, 102)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(22, 3)" end="(30, 48)">
              <TacticTacticseq1IndentedNode start="(22, 3)" end="(30, 48)">
                <NullNode start="(22, 3)" end="(30, 48)">
                  <OtherNode start="(22, 3)" end="(30, 48)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;as bs : List α&#10;r : α → α → Bool&#10;⊢ as.isEqv bs r =&#10;    if h : as.length = bs.length then decide (∀ (i : Nat) (h' : i &amp;lt; as.length), r as[i] bs[i] = true) else false" state_after="no goals" tactic="induction as generalizing bs with&#10;| nil =&amp;gt;&#10;  cases bs &amp;lt;;&amp;gt; simp&#10;| cons a as ih =&amp;gt;&#10;  cases bs with&#10;  | nil =&amp;gt; simp&#10;  | cons b bs =&amp;gt;&#10;    simp only [isEqv, ih, length_cons, Nat.add_right_cancel_iff]&#10;    split &amp;lt;;&amp;gt; simp [Nat.forall_lt_succ_left']">
                    <AtomNode start="(22, 3)" end="(22, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(22, 13)" end="(22, 15)">
                      <OtherNode start="(22, 13)" end="(22, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(22, 13)" end="(22, 15)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(22, 16)" end="(22, 31)">
                      <AtomNode start="(22, 16)" end="(22, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(22, 29)" end="(22, 31)">
                        <IdentNode start="(22, 29)" end="(22, 31)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(22, 32)" end="(30, 48)">
                      <OtherNode start="(22, 32)" end="(30, 48)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(22, 32)" end="(22, 36)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(23, 3)" end="(30, 48)">
                          <OtherNode start="(23, 3)" end="(24, 22)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(23, 3)" end="(23, 8)">
                              <OtherNode start="(23, 3)" end="(23, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(23, 3)" end="(23, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(23, 5)" end="(23, 8)">
                                  <NullNode/>
                                  <IdentNode start="(23, 5)" end="(23, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(23, 9)" end="(24, 22)">
                              <AtomNode start="(23, 9)" end="(23, 11)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(24, 5)" end="(24, 22)">
                                <TacticTacticseq1IndentedNode start="(24, 5)" end="(24, 22)">
                                  <NullNode start="(24, 5)" end="(24, 22)">
                                    <OtherNode start="(24, 5)" end="(24, 22)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case nil&#10;α : Type u_1&#10;r : α → α → Bool&#10;bs : List α&#10;⊢ [].isEqv bs r =&#10;    if h : [].length = bs.length then decide (∀ (i : Nat) (h' : i &amp;lt; [].length), r [][i] bs[i] = true) else false" state_after="no goals" tactic="cases bs &amp;lt;;&amp;gt; simp">
                                      <OtherNode start="(24, 5)" end="(24, 13)" kind="Lean.Parser.Tactic.cases">
                                        <AtomNode start="(24, 5)" end="(24, 10)" leading="" trailing=" " val="cases"/>
                                        <NullNode start="(24, 11)" end="(24, 13)">
                                          <OtherNode start="(24, 11)" end="(24, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                            <NullNode/>
                                            <IdentNode start="(24, 11)" end="(24, 13)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(24, 14)" end="(24, 17)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(24, 18)" end="(24, 22)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(24, 18)" end="(24, 22)" leading="" trailing="&#10;  " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(25, 3)" end="(30, 48)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(25, 3)" end="(25, 17)">
                              <OtherNode start="(25, 3)" end="(25, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(25, 3)" end="(25, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(25, 5)" end="(25, 9)">
                                  <NullNode/>
                                  <IdentNode start="(25, 5)" end="(25, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(25, 10)" end="(25, 17)">
                                  <IdentNode start="(25, 10)" end="(25, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(25, 12)" end="(25, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                                  <IdentNode start="(25, 15)" end="(25, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(25, 18)" end="(30, 48)">
                              <AtomNode start="(25, 18)" end="(25, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(26, 5)" end="(30, 48)">
                                <TacticTacticseq1IndentedNode start="(26, 5)" end="(30, 48)">
                                  <NullNode start="(26, 5)" end="(30, 48)">
                                    <OtherNode start="(26, 5)" end="(30, 48)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;r : α → α → Bool&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ {bs : List α},&#10;    as.isEqv bs r =&#10;      if h : as.length = bs.length then decide (∀ (i : Nat) (h' : i &amp;lt; as.length), r as[i] bs[i] = true) else false&#10;bs : List α&#10;⊢ (a :: as).isEqv bs r =&#10;    if h : (a :: as).length = bs.length then&#10;      decide (∀ (i : Nat) (h' : i &amp;lt; (a :: as).length), r (a :: as)[i] bs[i] = true)&#10;    else false" state_after="no goals" tactic="cases bs with&#10;| nil =&amp;gt; simp&#10;| cons b bs =&amp;gt;&#10;  simp only [isEqv, ih, length_cons, Nat.add_right_cancel_iff]&#10;  split &amp;lt;;&amp;gt; simp [Nat.forall_lt_succ_left']">
                                      <AtomNode start="(26, 5)" end="(26, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(26, 11)" end="(26, 13)">
                                        <OtherNode start="(26, 11)" end="(26, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(26, 11)" end="(26, 13)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(26, 14)" end="(30, 48)">
                                        <OtherNode start="(26, 14)" end="(30, 48)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(26, 14)" end="(26, 18)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(27, 5)" end="(30, 48)">
                                            <OtherNode start="(27, 5)" end="(27, 18)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(27, 5)" end="(27, 10)">
                                                <OtherNode start="(27, 5)" end="(27, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(27, 5)" end="(27, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(27, 7)" end="(27, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(27, 7)" end="(27, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(27, 11)" end="(27, 18)">
                                                <AtomNode start="(27, 11)" end="(27, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(27, 14)" end="(27, 18)">
                                                  <TacticTacticseq1IndentedNode start="(27, 14)" end="(27, 18)">
                                                    <NullNode start="(27, 14)" end="(27, 18)">
                                                      <OtherNode start="(27, 14)" end="(27, 18)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;α : Type u_1&#10;r : α → α → Bool&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ {bs : List α},&#10;    as.isEqv bs r =&#10;      if h : as.length = bs.length then decide (∀ (i : Nat) (h' : i &amp;lt; as.length), r as[i] bs[i] = true) else false&#10;⊢ (a :: as).isEqv [] r =&#10;    if h : (a :: as).length = [].length then&#10;      decide (∀ (i : Nat) (h' : i &amp;lt; (a :: as).length), r (a :: as)[i] [][i] = true)&#10;    else false" state_after="no goals" tactic="simp">
                                                        <AtomNode start="(27, 14)" end="(27, 18)" leading="" trailing="&#10;    " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(28, 5)" end="(30, 48)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(28, 5)" end="(28, 16)">
                                                <OtherNode start="(28, 5)" end="(28, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(28, 5)" end="(28, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(28, 7)" end="(28, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(28, 7)" end="(28, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(28, 12)" end="(28, 16)">
                                                    <IdentNode start="(28, 12)" end="(28, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                                    <IdentNode start="(28, 14)" end="(28, 16)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(28, 17)" end="(30, 48)">
                                                <AtomNode start="(28, 17)" end="(28, 19)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(29, 7)" end="(30, 48)">
                                                  <TacticTacticseq1IndentedNode start="(29, 7)" end="(30, 48)">
                                                    <NullNode start="(29, 7)" end="(30, 48)">
                                                      <OtherNode start="(29, 7)" end="(29, 67)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons&#10;α : Type u_1&#10;r : α → α → Bool&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ {bs : List α},&#10;    as.isEqv bs r =&#10;      if h : as.length = bs.length then decide (∀ (i : Nat) (h' : i &amp;lt; as.length), r as[i] bs[i] = true) else false&#10;b : α&#10;bs : List α&#10;⊢ (a :: as).isEqv (b :: bs) r =&#10;    if h : (a :: as).length = (b :: bs).length then&#10;      decide (∀ (i : Nat) (h' : i &amp;lt; (a :: as).length), r (a :: as)[i] (b :: bs)[i] = true)&#10;    else false" state_after="case cons.cons&#10;α : Type u_1&#10;r : α → α → Bool&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ {bs : List α},&#10;    as.isEqv bs r =&#10;      if h : as.length = bs.length then decide (∀ (i : Nat) (h' : i &amp;lt; as.length), r as[i] bs[i] = true) else false&#10;b : α&#10;bs : List α&#10;⊢ (r a b &amp;amp;&amp;amp;&#10;      if h : as.length = bs.length then decide (∀ (i : Nat) (h' : i &amp;lt; as.length), r as[i] bs[i] = true) else false) =&#10;    if h : as.length = bs.length then decide (∀ (i : Nat) (h' : i &amp;lt; as.length + 1), r (a :: as)[i] (b :: bs)[i] = true)&#10;    else false" tactic="simp only [isEqv, ih, length_cons, Nat.add_right_cancel_iff]">
                                                        <AtomNode start="(29, 7)" end="(29, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode start="(29, 12)" end="(29, 16)">
                                                          <AtomNode start="(29, 12)" end="(29, 16)" leading="" trailing=" " val="only"/>
                                                        </NullNode>
                                                        <NullNode start="(29, 17)" end="(29, 67)">
                                                          <AtomNode start="(29, 17)" end="(29, 18)" leading="" trailing="" val="["/>
                                                          <NullNode start="(29, 18)" end="(29, 66)">
                                                            <OtherNode start="(29, 18)" end="(29, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(29, 18)" end="(29, 23)" leading="" trailing="" raw_val="isEqv" val="isEqv" full_name="List.isEqv" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(29, 23)" end="(29, 24)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(29, 25)" end="(29, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(29, 25)" end="(29, 27)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <AtomNode start="(29, 27)" end="(29, 28)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(29, 29)" end="(29, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(29, 29)" end="(29, 40)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(29, 40)" end="(29, 41)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(29, 42)" end="(29, 66)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(29, 42)" end="(29, 66)" leading="" trailing="" raw_val="Nat.add_right_cancel_iff" val="Nat.add_right_cancel_iff" full_name="Nat.add_right_cancel_iff" mod_name="Init.Data.Nat.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Lemmas.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(29, 66)" end="(29, 67)" leading="" trailing="&#10;      " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(30, 7)" end="(30, 48)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.cons&#10;α : Type u_1&#10;r : α → α → Bool&#10;a : α&#10;as : List α&#10;ih :&#10;  ∀ {bs : List α},&#10;    as.isEqv bs r =&#10;      if h : as.length = bs.length then decide (∀ (i : Nat) (h' : i &amp;lt; as.length), r as[i] bs[i] = true) else false&#10;b : α&#10;bs : List α&#10;⊢ (r a b &amp;amp;&amp;amp;&#10;      if h : as.length = bs.length then decide (∀ (i : Nat) (h' : i &amp;lt; as.length), r as[i] bs[i] = true) else false) =&#10;    if h : as.length = bs.length then decide (∀ (i : Nat) (h' : i &amp;lt; as.length + 1), r (a :: as)[i] (b :: bs)[i] = true)&#10;    else false" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [Nat.forall_lt_succ_left']">
                                                        <OtherNode start="(30, 7)" end="(30, 12)" kind="Lean.Parser.Tactic.split">
                                                          <AtomNode start="(30, 7)" end="(30, 12)" leading="" trailing=" " val="split"/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(30, 13)" end="(30, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                        <OtherNode start="(30, 17)" end="(30, 48)" kind="Lean.Parser.Tactic.simp">
                                                          <AtomNode start="(30, 17)" end="(30, 21)" leading="" trailing=" " val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(30, 22)" end="(30, 48)">
                                                            <AtomNode start="(30, 22)" end="(30, 23)" leading="" trailing="" val="["/>
                                                            <NullNode start="(30, 23)" end="(30, 47)">
                                                            <OtherNode start="(30, 23)" end="(30, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(30, 23)" end="(30, 47)" leading="" trailing="" raw_val="Nat.forall_lt_succ_left'" val="Nat.forall_lt_succ_left'" full_name="Nat.forall_lt_succ_left'" mod_name="Init.Data.Nat.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Lemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(30, 47)" end="(30, 48)" leading="" trailing="&#10;&#10;" val="]"/>
                                                          </NullNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(32, 1)" end="(32, 15)" comment="### beq -/">
      <AtomNode start="(32, 1)" end="(32, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(32, 5)" end="(32, 15)" leading="" trailing="&#10;&#10;" val="### beq -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(34, 1)" end="(45, 21)" name="beq_eq_isEqv" full_name="List.beq_eq_isEqv">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(34, 1)" end="(45, 21)" name="beq_eq_isEqv" full_name="List.beq_eq_isEqv" _is_private_decl="False">
        <AtomNode start="(34, 1)" end="(34, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(34, 9)" end="(34, 21)">
          <IdentNode start="(34, 9)" end="(34, 21)" leading="" trailing=" " raw_val="beq_eq_isEqv" val="beq_eq_isEqv"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(34, 22)" end="(34, 81)">
          <NullNode start="(34, 22)" end="(34, 46)">
            <OtherNode start="(34, 22)" end="(34, 29)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(34, 22)" end="(34, 23)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(34, 23)" end="(34, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(34, 23)" end="(34, 26)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(34, 27)" end="(34, 28)">
                  <IdentNode start="(34, 27)" end="(34, 28)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(34, 28)" end="(34, 29)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(34, 30)" end="(34, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(34, 30)" end="(34, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(34, 31)" end="(34, 36)">
                <IdentNode start="(34, 31)" end="(34, 33)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(34, 34)" end="(34, 36)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(34, 37)" end="(34, 45)">
                <AtomNode start="(34, 37)" end="(34, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(34, 39)" end="(34, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(34, 39)" end="(34, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(34, 44)" end="(34, 45)">
                    <IdentNode start="(34, 44)" end="(34, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(34, 45)" end="(34, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(34, 47)" end="(34, 81)">
            <AtomNode start="(34, 47)" end="(34, 48)" leading="" trailing=" " val=":"/>
            <OtherNode start="(34, 49)" end="(34, 81)" kind="«term_=_»">
              <OtherNode start="(34, 49)" end="(34, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(34, 49)" end="(34, 55)" leading="" trailing=" " raw_val="as.beq" val="as.beq"/>
                <NullNode start="(34, 56)" end="(34, 58)">
                  <IdentNode start="(34, 56)" end="(34, 58)" leading="" trailing=" " raw_val="bs" val="bs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(34, 59)" end="(34, 60)" leading="" trailing=" " val="="/>
              <OtherNode start="(34, 61)" end="(34, 81)" kind="Lean.Parser.Term.app">
                <IdentNode start="(34, 61)" end="(34, 66)" leading="" trailing=" " raw_val="isEqv" val="isEqv" full_name="List.isEqv" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(34, 67)" end="(34, 81)">
                  <IdentNode start="(34, 67)" end="(34, 69)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(34, 70)" end="(34, 72)" leading="" trailing=" " raw_val="bs" val="bs"/>
                  <OtherNode start="(34, 73)" end="(34, 81)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(34, 73)" end="(34, 74)" leading="" trailing="" val="("/>
                    <OtherNode start="(34, 74)" end="(34, 80)" kind="«term_==_»">
                      <OtherNode start="(34, 74)" end="(34, 75)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(34, 74)" end="(34, 75)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(34, 76)" end="(34, 78)" leading="" trailing=" " val="=="/>
                      <OtherNode start="(34, 79)" end="(34, 80)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(34, 79)" end="(34, 80)" leading="" trailing="" val="·"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(34, 80)" end="(34, 81)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(34, 82)" end="(45, 21)">
          <AtomNode start="(34, 82)" end="(34, 84)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(34, 85)" end="(45, 21)">
            <AtomNode start="(34, 85)" end="(34, 87)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(35, 3)" end="(45, 21)">
              <TacticTacticseq1IndentedNode start="(35, 3)" end="(45, 21)">
                <NullNode start="(35, 3)" end="(45, 21)">
                  <OtherNode start="(35, 3)" end="(45, 21)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;as bs : List α&#10;⊢ as.beq bs = as.isEqv bs fun x1 x2 =&amp;gt; x1 == x2" state_after="no goals" tactic="induction as generalizing bs with&#10;| nil =&amp;gt;&#10;  cases bs &amp;lt;;&amp;gt; simp&#10;| cons a as ih =&amp;gt;&#10;  cases bs with&#10;  | nil =&amp;gt; simp&#10;  | cons b bs =&amp;gt;&#10;    simp only [beq_cons₂, ih, isEqv_eq_decide, length_cons, Nat.add_right_cancel_iff,&#10;      Nat.forall_lt_succ_left', getElem_cons_zero, getElem_cons_succ, Bool.decide_and,&#10;      Bool.decide_eq_true]&#10;    split &amp;lt;;&amp;gt; simp">
                    <AtomNode start="(35, 3)" end="(35, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(35, 13)" end="(35, 15)">
                      <OtherNode start="(35, 13)" end="(35, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(35, 13)" end="(35, 15)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(35, 16)" end="(35, 31)">
                      <AtomNode start="(35, 16)" end="(35, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(35, 29)" end="(35, 31)">
                        <IdentNode start="(35, 29)" end="(35, 31)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(35, 32)" end="(45, 21)">
                      <OtherNode start="(35, 32)" end="(45, 21)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(35, 32)" end="(35, 36)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(36, 3)" end="(45, 21)">
                          <OtherNode start="(36, 3)" end="(37, 22)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(36, 3)" end="(36, 8)">
                              <OtherNode start="(36, 3)" end="(36, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(36, 3)" end="(36, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(36, 5)" end="(36, 8)">
                                  <NullNode/>
                                  <IdentNode start="(36, 5)" end="(36, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(36, 9)" end="(37, 22)">
                              <AtomNode start="(36, 9)" end="(36, 11)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(37, 5)" end="(37, 22)">
                                <TacticTacticseq1IndentedNode start="(37, 5)" end="(37, 22)">
                                  <NullNode start="(37, 5)" end="(37, 22)">
                                    <OtherNode start="(37, 5)" end="(37, 22)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case nil&#10;α : Type u_1&#10;inst✝ : BEq α&#10;bs : List α&#10;⊢ [].beq bs = [].isEqv bs fun x1 x2 =&amp;gt; x1 == x2" state_after="no goals" tactic="cases bs &amp;lt;;&amp;gt; simp">
                                      <OtherNode start="(37, 5)" end="(37, 13)" kind="Lean.Parser.Tactic.cases">
                                        <AtomNode start="(37, 5)" end="(37, 10)" leading="" trailing=" " val="cases"/>
                                        <NullNode start="(37, 11)" end="(37, 13)">
                                          <OtherNode start="(37, 11)" end="(37, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                            <NullNode/>
                                            <IdentNode start="(37, 11)" end="(37, 13)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(37, 14)" end="(37, 17)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(37, 18)" end="(37, 22)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(37, 18)" end="(37, 22)" leading="" trailing="&#10;  " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(38, 3)" end="(45, 21)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(38, 3)" end="(38, 17)">
                              <OtherNode start="(38, 3)" end="(38, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(38, 3)" end="(38, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(38, 5)" end="(38, 9)">
                                  <NullNode/>
                                  <IdentNode start="(38, 5)" end="(38, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(38, 10)" end="(38, 17)">
                                  <IdentNode start="(38, 10)" end="(38, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(38, 12)" end="(38, 14)" leading="" trailing=" " raw_val="as" val="as"/>
                                  <IdentNode start="(38, 15)" end="(38, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(38, 18)" end="(45, 21)">
                              <AtomNode start="(38, 18)" end="(38, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(39, 5)" end="(45, 21)">
                                <TacticTacticseq1IndentedNode start="(39, 5)" end="(45, 21)">
                                  <NullNode start="(39, 5)" end="(45, 21)">
                                    <OtherNode start="(39, 5)" end="(45, 21)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;as : List α&#10;ih : ∀ {bs : List α}, as.beq bs = as.isEqv bs fun x1 x2 =&amp;gt; x1 == x2&#10;bs : List α&#10;⊢ (a :: as).beq bs = (a :: as).isEqv bs fun x1 x2 =&amp;gt; x1 == x2" state_after="no goals" tactic="cases bs with&#10;| nil =&amp;gt; simp&#10;| cons b bs =&amp;gt;&#10;  simp only [beq_cons₂, ih, isEqv_eq_decide, length_cons, Nat.add_right_cancel_iff,&#10;    Nat.forall_lt_succ_left', getElem_cons_zero, getElem_cons_succ, Bool.decide_and,&#10;    Bool.decide_eq_true]&#10;  split &amp;lt;;&amp;gt; simp">
                                      <AtomNode start="(39, 5)" end="(39, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(39, 11)" end="(39, 13)">
                                        <OtherNode start="(39, 11)" end="(39, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(39, 11)" end="(39, 13)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(39, 14)" end="(45, 21)">
                                        <OtherNode start="(39, 14)" end="(45, 21)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(39, 14)" end="(39, 18)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(40, 5)" end="(45, 21)">
                                            <OtherNode start="(40, 5)" end="(40, 18)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(40, 5)" end="(40, 10)">
                                                <OtherNode start="(40, 5)" end="(40, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(40, 5)" end="(40, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(40, 7)" end="(40, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(40, 7)" end="(40, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(40, 11)" end="(40, 18)">
                                                <AtomNode start="(40, 11)" end="(40, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(40, 14)" end="(40, 18)">
                                                  <TacticTacticseq1IndentedNode start="(40, 14)" end="(40, 18)">
                                                    <NullNode start="(40, 14)" end="(40, 18)">
                                                      <OtherNode start="(40, 14)" end="(40, 18)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;as : List α&#10;ih : ∀ {bs : List α}, as.beq bs = as.isEqv bs fun x1 x2 =&amp;gt; x1 == x2&#10;⊢ (a :: as).beq [] = (a :: as).isEqv [] fun x1 x2 =&amp;gt; x1 == x2" state_after="no goals" tactic="simp">
                                                        <AtomNode start="(40, 14)" end="(40, 18)" leading="" trailing="&#10;    " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(41, 5)" end="(45, 21)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(41, 5)" end="(41, 16)">
                                                <OtherNode start="(41, 5)" end="(41, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(41, 5)" end="(41, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(41, 7)" end="(41, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(41, 7)" end="(41, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(41, 12)" end="(41, 16)">
                                                    <IdentNode start="(41, 12)" end="(41, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                                    <IdentNode start="(41, 14)" end="(41, 16)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(41, 17)" end="(45, 21)">
                                                <AtomNode start="(41, 17)" end="(41, 19)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(42, 7)" end="(45, 21)">
                                                  <TacticTacticseq1IndentedNode start="(42, 7)" end="(45, 21)">
                                                    <NullNode start="(42, 7)" end="(45, 21)">
                                                      <OtherNode start="(42, 7)" end="(44, 29)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;as : List α&#10;ih : ∀ {bs : List α}, as.beq bs = as.isEqv bs fun x1 x2 =&amp;gt; x1 == x2&#10;b : α&#10;bs : List α&#10;⊢ (a :: as).beq (b :: bs) = (a :: as).isEqv (b :: bs) fun x1 x2 =&amp;gt; x1 == x2" state_after="case cons.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;as : List α&#10;ih : ∀ {bs : List α}, as.beq bs = as.isEqv bs fun x1 x2 =&amp;gt; x1 == x2&#10;b : α&#10;bs : List α&#10;⊢ (a == b &amp;amp;&amp;amp;&#10;      if h : as.length = bs.length then decide (∀ (i : Nat) (h' : i &amp;lt; as.length), (as[i] == bs[i]) = true) else false) =&#10;    if h : as.length = bs.length then a == b &amp;amp;&amp;amp; decide (∀ (m : Nat) (h_1 : m &amp;lt; as.length), (as[m] == bs[m]) = true)&#10;    else false" tactic="simp only [beq_cons₂, ih, isEqv_eq_decide, length_cons, Nat.add_right_cancel_iff,&#10;  Nat.forall_lt_succ_left', getElem_cons_zero, getElem_cons_succ, Bool.decide_and,&#10;  Bool.decide_eq_true]">
                                                        <AtomNode start="(42, 7)" end="(42, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode start="(42, 12)" end="(42, 16)">
                                                          <AtomNode start="(42, 12)" end="(42, 16)" leading="" trailing=" " val="only"/>
                                                        </NullNode>
                                                        <NullNode start="(42, 17)" end="(44, 29)">
                                                          <AtomNode start="(42, 17)" end="(42, 18)" leading="" trailing="" val="["/>
                                                          <NullNode start="(42, 18)" end="(44, 28)">
                                                            <OtherNode start="(42, 18)" end="(42, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(42, 18)" end="(42, 27)" leading="" trailing="" raw_val="beq_cons₂" val="beq_cons₂" full_name="List.beq_cons₂" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(42, 27)" end="(42, 28)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(42, 29)" end="(42, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(42, 29)" end="(42, 31)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <AtomNode start="(42, 31)" end="(42, 32)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(42, 33)" end="(42, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(42, 33)" end="(42, 48)" leading="" trailing="" raw_val="isEqv_eq_decide" val="isEqv_eq_decide" full_name="List.isEqv_eq_decide" mod_name="Init.Data.List.Nat.BEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/BEq.lean" def_start="(19, 9)" def_end="(19, 24)"/>
                                                            </OtherNode>
                                                            <AtomNode start="(42, 48)" end="(42, 49)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(42, 50)" end="(42, 61)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(42, 50)" end="(42, 61)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(42, 61)" end="(42, 62)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(42, 63)" end="(42, 87)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(42, 63)" end="(42, 87)" leading="" trailing="" raw_val="Nat.add_right_cancel_iff" val="Nat.add_right_cancel_iff" full_name="Nat.add_right_cancel_iff" mod_name="Init.Data.Nat.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Lemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(42, 87)" end="(42, 88)" leading="" trailing="&#10;        " val=","/>
                                                            <OtherNode start="(43, 9)" end="(43, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(43, 9)" end="(43, 33)" leading="" trailing="" raw_val="Nat.forall_lt_succ_left'" val="Nat.forall_lt_succ_left'" full_name="Nat.forall_lt_succ_left'" mod_name="Init.Data.Nat.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Lemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(43, 33)" end="(43, 34)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(43, 35)" end="(43, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(43, 35)" end="(43, 52)" leading="" trailing="" raw_val="getElem_cons_zero" val="getElem_cons_zero" full_name="List.getElem_cons_zero" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(43, 52)" end="(43, 53)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(43, 54)" end="(43, 71)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(43, 54)" end="(43, 71)" leading="" trailing="" raw_val="getElem_cons_succ" val="getElem_cons_succ" full_name="List.getElem_cons_succ" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(43, 71)" end="(43, 72)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(43, 73)" end="(43, 88)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(43, 73)" end="(43, 88)" leading="" trailing="" raw_val="Bool.decide_and" val="Bool.decide_and" full_name="Bool.decide_and" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(43, 88)" end="(43, 89)" leading="" trailing="&#10;        " val=","/>
                                                            <OtherNode start="(44, 9)" end="(44, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(44, 9)" end="(44, 28)" leading="" trailing="" raw_val="Bool.decide_eq_true" val="Bool.decide_eq_true" full_name="Bool.decide_eq_true" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(44, 28)" end="(44, 29)" leading="" trailing="&#10;      " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(45, 7)" end="(45, 21)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;as : List α&#10;ih : ∀ {bs : List α}, as.beq bs = as.isEqv bs fun x1 x2 =&amp;gt; x1 == x2&#10;b : α&#10;bs : List α&#10;⊢ (a == b &amp;amp;&amp;amp;&#10;      if h : as.length = bs.length then decide (∀ (i : Nat) (h' : i &amp;lt; as.length), (as[i] == bs[i]) = true) else false) =&#10;    if h : as.length = bs.length then a == b &amp;amp;&amp;amp; decide (∀ (m : Nat) (h_1 : m &amp;lt; as.length), (as[m] == bs[m]) = true)&#10;    else false" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                                                        <OtherNode start="(45, 7)" end="(45, 12)" kind="Lean.Parser.Tactic.split">
                                                          <AtomNode start="(45, 7)" end="(45, 12)" leading="" trailing=" " val="split"/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(45, 13)" end="(45, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                        <OtherNode start="(45, 17)" end="(45, 21)" kind="Lean.Parser.Tactic.simp">
                                                          <AtomNode start="(45, 17)" end="(45, 21)" leading="" trailing="&#10;&#10;" val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(47, 1)" end="(50, 48)" name="beq_eq_decide" full_name="List.beq_eq_decide">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(47, 1)" end="(50, 48)" name="beq_eq_decide" full_name="List.beq_eq_decide" _is_private_decl="False">
        <AtomNode start="(47, 1)" end="(47, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(47, 9)" end="(47, 22)">
          <IdentNode start="(47, 9)" end="(47, 22)" leading="" trailing=" " raw_val="beq_eq_decide" val="beq_eq_decide"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(47, 23)" end="(49, 84)">
          <NullNode start="(47, 23)" end="(47, 47)">
            <OtherNode start="(47, 23)" end="(47, 30)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(47, 23)" end="(47, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(47, 24)" end="(47, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(47, 24)" end="(47, 27)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(47, 28)" end="(47, 29)">
                  <IdentNode start="(47, 28)" end="(47, 29)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(47, 29)" end="(47, 30)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(47, 31)" end="(47, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(47, 31)" end="(47, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(47, 32)" end="(47, 37)">
                <IdentNode start="(47, 32)" end="(47, 34)" leading="" trailing=" " raw_val="as" val="as"/>
                <IdentNode start="(47, 35)" end="(47, 37)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(47, 38)" end="(47, 46)">
                <AtomNode start="(47, 38)" end="(47, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(47, 40)" end="(47, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(47, 40)" end="(47, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(47, 45)" end="(47, 46)">
                    <IdentNode start="(47, 45)" end="(47, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(47, 46)" end="(47, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(47, 48)" end="(49, 84)">
            <AtomNode start="(47, 48)" end="(47, 49)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(48, 5)" end="(49, 84)" kind="«term_=_»">
              <OtherNode start="(48, 5)" end="(48, 15)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(48, 5)" end="(48, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(48, 6)" end="(48, 14)" kind="«term_==_»">
                  <IdentNode start="(48, 6)" end="(48, 8)" leading="" trailing=" " raw_val="as" val="as"/>
                  <AtomNode start="(48, 9)" end="(48, 11)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(48, 12)" end="(48, 14)" leading="" trailing="" raw_val="bs" val="bs"/>
                </OtherNode>
                <AtomNode start="(48, 14)" end="(48, 15)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(48, 16)" end="(48, 17)" leading="" trailing=" " val="="/>
              <OtherNode start="(48, 18)" end="(49, 84)" kind="termDepIfThenElse">
                <AtomNode start="(48, 18)" end="(48, 20)" leading="" trailing=" " val="if"/>
                <LeanBinderidentNode start="(48, 21)" end="(48, 22)">
                  <IdentNode start="(48, 21)" end="(48, 22)" leading="" trailing=" " raw_val="h" val="h"/>
                </LeanBinderidentNode>
                <AtomNode start="(48, 23)" end="(48, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(48, 25)" end="(48, 46)" kind="«term_=_»">
                  <IdentNode start="(48, 25)" end="(48, 34)" leading="" trailing=" " raw_val="as.length" val="as.length"/>
                  <AtomNode start="(48, 35)" end="(48, 36)" leading="" trailing=" " val="="/>
                  <IdentNode start="(48, 37)" end="(48, 46)" leading="" trailing=" " raw_val="bs.length" val="bs.length"/>
                </OtherNode>
                <AtomNode start="(48, 47)" end="(48, 51)" leading="" trailing="&#10;      " val="then"/>
                <OtherNode start="(49, 7)" end="(49, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(49, 7)" end="(49, 13)" leading="" trailing=" " raw_val="decide" val="decide" full_name="Decidable.decide" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(49, 14)" end="(49, 73)">
                    <OtherNode start="(49, 14)" end="(49, 73)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(49, 14)" end="(49, 15)" leading="" trailing="" val="("/>
                      <OtherNode start="(49, 15)" end="(49, 72)" kind="Lean.Parser.Term.forall">
                        <AtomNode start="(49, 15)" end="(49, 16)" leading="" trailing=" " val="∀"/>
                        <NullNode start="(49, 17)" end="(49, 47)">
                          <TermExplicitbinderNode start="(49, 17)" end="(49, 26)">
                            <AtomNode start="(49, 17)" end="(49, 18)" leading="" trailing="" val="("/>
                            <NullNode start="(49, 18)" end="(49, 19)">
                              <IdentNode start="(49, 18)" end="(49, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                            </NullNode>
                            <NullNode start="(49, 20)" end="(49, 25)">
                              <AtomNode start="(49, 20)" end="(49, 21)" leading="" trailing=" " val=":"/>
                              <IdentNode start="(49, 22)" end="(49, 25)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(49, 25)" end="(49, 26)" leading="" trailing=" " val=")"/>
                          </TermExplicitbinderNode>
                          <TermExplicitbinderNode start="(49, 27)" end="(49, 47)">
                            <AtomNode start="(49, 27)" end="(49, 28)" leading="" trailing="" val="("/>
                            <NullNode start="(49, 28)" end="(49, 30)">
                              <IdentNode start="(49, 28)" end="(49, 30)" leading="" trailing=" " raw_val="h'" val="h'"/>
                            </NullNode>
                            <NullNode start="(49, 31)" end="(49, 46)">
                              <AtomNode start="(49, 31)" end="(49, 32)" leading="" trailing=" " val=":"/>
                              <OtherNode start="(49, 33)" end="(49, 46)" kind="«term_&amp;lt;_»">
                                <IdentNode start="(49, 33)" end="(49, 34)" leading="" trailing=" " raw_val="i" val="i"/>
                                <AtomNode start="(49, 35)" end="(49, 36)" leading="" trailing=" " val="&amp;lt;"/>
                                <IdentNode start="(49, 37)" end="(49, 46)" leading="" trailing="" raw_val="as.length" val="as.length"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(49, 46)" end="(49, 47)" leading="" trailing="" val=")"/>
                          </TermExplicitbinderNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(49, 47)" end="(49, 48)" leading="" trailing=" " val=","/>
                        <OtherNode start="(49, 49)" end="(49, 72)" kind="«term_==_»">
                          <OtherNode start="(49, 49)" end="(49, 54)" kind="«term__[_]»">
                            <IdentNode start="(49, 49)" end="(49, 51)" leading="" trailing="" raw_val="as" val="as"/>
                            <AtomNode start="(49, 51)" end="(49, 52)" leading="" trailing="" val="["/>
                            <IdentNode start="(49, 52)" end="(49, 53)" leading="" trailing="" raw_val="i" val="i"/>
                            <AtomNode start="(49, 53)" end="(49, 54)" leading="" trailing=" " val="]"/>
                          </OtherNode>
                          <AtomNode start="(49, 55)" end="(49, 57)" leading="" trailing=" " val="=="/>
                          <OtherNode start="(49, 58)" end="(49, 72)" kind="«term__[_]'_»">
                            <IdentNode start="(49, 58)" end="(49, 60)" leading="" trailing="" raw_val="bs" val="bs"/>
                            <AtomNode start="(49, 60)" end="(49, 61)" leading="" trailing="" val="["/>
                            <IdentNode start="(49, 61)" end="(49, 62)" leading="" trailing="" raw_val="i" val="i"/>
                            <AtomNode start="(49, 62)" end="(49, 64)" leading="" trailing="" val="]'"/>
                            <OtherNode start="(49, 64)" end="(49, 72)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(49, 64)" end="(49, 65)" leading="" trailing="" val="("/>
                              <OtherNode start="(49, 65)" end="(49, 71)" kind="Lean.Parser.Term.subst">
                                <IdentNode start="(49, 65)" end="(49, 66)" leading="" trailing=" " raw_val="h" val="h"/>
                                <AtomNode start="(49, 67)" end="(49, 68)" leading="" trailing=" " val="▸"/>
                                <NullNode start="(49, 69)" end="(49, 71)">
                                  <IdentNode start="(49, 69)" end="(49, 71)" leading="" trailing="" raw_val="h'" val="h'"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(49, 71)" end="(49, 72)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(49, 72)" end="(49, 73)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(49, 74)" end="(49, 78)" leading="" trailing=" " val="else"/>
                <IdentNode start="(49, 79)" end="(49, 84)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(49, 85)" end="(50, 48)">
          <AtomNode start="(49, 85)" end="(49, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(49, 88)" end="(50, 48)">
            <AtomNode start="(49, 88)" end="(49, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(50, 3)" end="(50, 48)">
              <TacticTacticseq1IndentedNode start="(50, 3)" end="(50, 48)">
                <NullNode start="(50, 3)" end="(50, 48)">
                  <OtherNode start="(50, 3)" end="(50, 48)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;as bs : List α&#10;⊢ (as == bs) =&#10;    if h : as.length = bs.length then decide (∀ (i : Nat) (h' : i &amp;lt; as.length), (as[i] == bs[i]) = true) else false" state_after="no goals" tactic="simp [BEq.beq, beq_eq_isEqv, isEqv_eq_decide]">
                    <AtomNode start="(50, 3)" end="(50, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(50, 8)" end="(50, 48)">
                      <AtomNode start="(50, 8)" end="(50, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(50, 9)" end="(50, 47)">
                        <OtherNode start="(50, 9)" end="(50, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(50, 9)" end="(50, 16)" leading="" trailing="" raw_val="BEq.beq" val="BEq.beq" full_name="BEq.beq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                        <AtomNode start="(50, 16)" end="(50, 17)" leading="" trailing=" " val=","/>
                        <OtherNode start="(50, 18)" end="(50, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(50, 18)" end="(50, 30)" leading="" trailing="" raw_val="beq_eq_isEqv" val="beq_eq_isEqv" full_name="List.beq_eq_isEqv" mod_name="Init.Data.List.Nat.BEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/BEq.lean" def_start="(34, 9)" def_end="(34, 21)"/>
                        </OtherNode>
                        <AtomNode start="(50, 30)" end="(50, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(50, 32)" end="(50, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(50, 32)" end="(50, 47)" leading="" trailing="" raw_val="isEqv_eq_decide" val="isEqv_eq_decide" full_name="List.isEqv_eq_decide" mod_name="Init.Data.List.Nat.BEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/BEq.lean" def_start="(19, 9)" def_end="(19, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(50, 47)" end="(50, 48)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(52, 1)" end="(52, 9)" name="List">
      <AtomNode start="(52, 1)" end="(52, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(52, 5)" end="(52, 9)">
        <IdentNode start="(52, 5)" end="(52, 9)" leading="" trailing="&#10;" raw_val="List" val="List"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(12, 38)" end="(13, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(13, 39)" end="(15, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(17, 1)" end="(17, 17)" text="### isEqv -/"/>
    <Comment start="(32, 1)" end="(32, 15)" text="### beq -/"/>
  </Comments>
</TracedFile>
