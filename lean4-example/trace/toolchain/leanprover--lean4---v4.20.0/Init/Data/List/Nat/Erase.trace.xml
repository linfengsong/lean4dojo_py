<TracedFile path="src/lean/Init/Data/List/Nat/Erase.lean" md5="94573b6e4ac8515476dbb67814730806">
  <FileNode start="(1, 1)" end="(155, 9)">
    <ModuleHeaderNode start="(6, 1)" end="(10, 28)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(10, 28)">
        <ModuleImportNode start="(9, 1)" end="(9, 35)" module="Init.Data.List.Nat.TakeDrop" path="src/lean/Init/Data/List/Nat/TakeDrop.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 35)" leading="" trailing="&#10;" raw_val="Init.Data.List.Nat.TakeDrop" val="Init.Data.List.Nat.TakeDrop"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 28)" module="Init.Data.List.Erase" path="src/lean/Init/Data/List/Erase.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 28)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.List.Erase" val="Init.Data.List.Erase"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <OtherNode start="(12, 1)" end="(12, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(12, 1)" end="(12, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(12, 12)" end="(12, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(12, 33)" end="(12, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(13, 1)" end="(13, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(13, 1)" end="(13, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(13, 12)" end="(13, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(13, 34)" end="(13, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(15, 1)" end="(15, 15)" name="List">
      <AtomNode start="(15, 1)" end="(15, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(15, 11)" end="(15, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandDeclarationNode start="(17, 1)" end="(38, 58)" name="getElem?_eraseIdx" full_name="List.getElem?_eraseIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(17, 1)" end="(38, 58)" name="getElem?_eraseIdx" full_name="List.getElem?_eraseIdx" _is_private_decl="False">
        <AtomNode start="(17, 1)" end="(17, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(17, 9)" end="(17, 26)">
          <IdentNode start="(17, 9)" end="(17, 26)" leading="" trailing=" " raw_val="getElem?_eraseIdx" val="getElem?_eraseIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(17, 27)" end="(18, 60)">
          <NullNode start="(17, 27)" end="(17, 59)">
            <OtherNode start="(17, 27)" end="(17, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(17, 27)" end="(17, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(17, 28)" end="(17, 29)">
                <IdentNode start="(17, 28)" end="(17, 29)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(17, 30)" end="(17, 38)">
                <AtomNode start="(17, 30)" end="(17, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(17, 32)" end="(17, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(17, 32)" end="(17, 36)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(17, 37)" end="(17, 38)">
                    <IdentNode start="(17, 37)" end="(17, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(17, 38)" end="(17, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(17, 40)" end="(17, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(17, 40)" end="(17, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(17, 41)" end="(17, 42)">
                <IdentNode start="(17, 41)" end="(17, 42)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(17, 43)" end="(17, 48)">
                <AtomNode start="(17, 43)" end="(17, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(17, 45)" end="(17, 48)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(17, 48)" end="(17, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(17, 50)" end="(17, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(17, 50)" end="(17, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(17, 51)" end="(17, 52)">
                <IdentNode start="(17, 51)" end="(17, 52)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(17, 53)" end="(17, 58)">
                <AtomNode start="(17, 53)" end="(17, 54)" leading="" trailing=" " val=":"/>
                <IdentNode start="(17, 55)" end="(17, 58)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(17, 58)" end="(17, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(17, 60)" end="(18, 60)">
            <AtomNode start="(17, 60)" end="(17, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(18, 5)" end="(18, 60)" kind="«term_=_»">
              <OtherNode start="(18, 5)" end="(18, 23)" kind="«term__[_]_?»">
                <OtherNode start="(18, 5)" end="(18, 19)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(18, 5)" end="(18, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(18, 6)" end="(18, 18)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(18, 6)" end="(18, 16)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                    <NullNode start="(18, 17)" end="(18, 18)">
                      <IdentNode start="(18, 17)" end="(18, 18)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(18, 18)" end="(18, 19)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(18, 19)" end="(18, 20)" leading="" trailing="" val="["/>
                <IdentNode start="(18, 20)" end="(18, 21)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(18, 21)" end="(18, 22)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(18, 22)" end="(18, 23)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(18, 24)" end="(18, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(18, 26)" end="(18, 60)" kind="termIfThenElse">
                <AtomNode start="(18, 26)" end="(18, 28)" leading="" trailing=" " val="if"/>
                <OtherNode start="(18, 29)" end="(18, 34)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(18, 29)" end="(18, 30)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(18, 31)" end="(18, 32)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(18, 33)" end="(18, 34)" leading="" trailing=" " raw_val="i" val="i"/>
                </OtherNode>
                <AtomNode start="(18, 35)" end="(18, 39)" leading="" trailing=" " val="then"/>
                <OtherNode start="(18, 40)" end="(18, 45)" kind="«term__[_]_?»">
                  <IdentNode start="(18, 40)" end="(18, 41)" leading="" trailing="" raw_val="l" val="l"/>
                  <GroupNode/>
                  <AtomNode start="(18, 41)" end="(18, 42)" leading="" trailing="" val="["/>
                  <IdentNode start="(18, 42)" end="(18, 43)" leading="" trailing="" raw_val="j" val="j"/>
                  <AtomNode start="(18, 43)" end="(18, 44)" leading="" trailing="" val="]"/>
                  <GroupNode/>
                  <AtomNode start="(18, 44)" end="(18, 45)" leading="" trailing=" " val="?"/>
                </OtherNode>
                <AtomNode start="(18, 46)" end="(18, 50)" leading="" trailing=" " val="else"/>
                <OtherNode start="(18, 51)" end="(18, 60)" kind="«term__[_]_?»">
                  <IdentNode start="(18, 51)" end="(18, 52)" leading="" trailing="" raw_val="l" val="l"/>
                  <GroupNode/>
                  <AtomNode start="(18, 52)" end="(18, 53)" leading="" trailing="" val="["/>
                  <OtherNode start="(18, 53)" end="(18, 58)" kind="«term_+_»">
                    <IdentNode start="(18, 53)" end="(18, 54)" leading="" trailing=" " raw_val="j" val="j"/>
                    <AtomNode start="(18, 55)" end="(18, 56)" leading="" trailing=" " val="+"/>
                    <OtherNode start="(18, 57)" end="(18, 58)" kind="num">
                      <AtomNode start="(18, 57)" end="(18, 58)" leading="" trailing="" val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(18, 58)" end="(18, 59)" leading="" trailing="" val="]"/>
                  <GroupNode/>
                  <AtomNode start="(18, 59)" end="(18, 60)" leading="" trailing=" " val="?"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(18, 61)" end="(38, 58)">
          <AtomNode start="(18, 61)" end="(18, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(18, 64)" end="(38, 58)">
            <AtomNode start="(18, 64)" end="(18, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(19, 3)" end="(38, 58)">
              <TacticTacticseq1IndentedNode start="(19, 3)" end="(38, 58)">
                <NullNode start="(19, 3)" end="(38, 58)">
                  <OtherNode start="(19, 3)" end="(19, 51)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;⊢ (l.eraseIdx i)[j]? = if j &amp;lt; i then l[j]? else l[j + 1]?" state_after="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;⊢ (if j &amp;lt; (take i l).length then (take i l)[j]? else (drop (i + 1) l)[j - (take i l).length]?) =&#10;    if j &amp;lt; i then l[j]? else l[j + 1]?" tactic="rw [eraseIdx_eq_take_drop_succ, getElem?_append]">
                    <AtomNode start="(19, 3)" end="(19, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(19, 6)" end="(19, 51)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(19, 6)" end="(19, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(19, 7)" end="(19, 50)">
                        <OtherNode start="(19, 7)" end="(19, 33)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(19, 7)" end="(19, 33)" leading="" trailing="" raw_val="eraseIdx_eq_take_drop_succ" val="eraseIdx_eq_take_drop_succ" full_name="List.eraseIdx_eq_take_drop_succ" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(19, 33)" end="(19, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(19, 35)" end="(19, 50)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(19, 35)" end="(19, 50)" leading="" trailing="" raw_val="getElem?_append" val="getElem?_append" full_name="List.getElem?_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(19, 50)" end="(19, 51)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(20, 3)" end="(20, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;⊢ (if j &amp;lt; (take i l).length then (take i l)[j]? else (drop (i + 1) l)[j - (take i l).length]?) =&#10;    if j &amp;lt; i then l[j]? else l[j + 1]?" state_after="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (take i l).length&#10;⊢ (take i l)[j]? = if j &amp;lt; i then l[j]? else l[j + 1]?&#10;&#10;case isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;⊢ (drop (i + 1) l)[j - (take i l).length]? = if j &amp;lt; i then l[j]? else l[j + 1]?" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(20, 3)" end="(20, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(20, 3)" end="(20, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(20, 9)" end="(20, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(20, 13)" end="(20, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(20, 13)" end="(20, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(20, 22)" end="(20, 23)">
                        <LeanBinderidentNode start="(20, 22)" end="(20, 23)">
                          <IdentNode start="(20, 22)" end="(20, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(21, 3)" end="(25, 12)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (take i l).length&#10;⊢ (take i l)[j]? = if j &amp;lt; i then l[j]? else l[j + 1]?&#10;&#10;case isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;⊢ (drop (i + 1) l)[j - (take i l).length]? = if j &amp;lt; i then l[j]? else l[j + 1]?" state_after="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;⊢ (drop (i + 1) l)[j - (take i l).length]? = if j &amp;lt; i then l[j]? else l[j + 1]?" tactic="· rw [getElem?_take]&#10;  split&#10;  · rfl&#10;  · simp_all&#10;    omega">
                    <OtherNode start="(21, 3)" end="(21, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(21, 3)" end="(21, 4)" kind="patternIgnore">
                        <OtherNode start="(21, 3)" end="(21, 4)" kind="token.«· »">
                          <AtomNode start="(21, 3)" end="(21, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(21, 5)" end="(25, 12)">
                      <TacticTacticseq1IndentedNode start="(21, 5)" end="(25, 12)">
                        <NullNode start="(21, 5)" end="(25, 12)">
                          <OtherNode start="(21, 5)" end="(21, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (take i l).length&#10;⊢ (take i l)[j]? = if j &amp;lt; i then l[j]? else l[j + 1]?" state_after="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (take i l).length&#10;⊢ (if j &amp;lt; i then l[j]? else none) = if j &amp;lt; i then l[j]? else l[j + 1]?" tactic="rw [getElem?_take]">
                            <AtomNode start="(21, 5)" end="(21, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(21, 8)" end="(21, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(21, 8)" end="(21, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(21, 9)" end="(21, 22)">
                                <OtherNode start="(21, 9)" end="(21, 22)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(21, 9)" end="(21, 22)" leading="" trailing="" raw_val="getElem?_take" val="getElem?_take" full_name="List.getElem?_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(21, 22)" end="(21, 23)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(22, 5)" end="(22, 10)" kind="Lean.Parser.Tactic.split" state_before="case isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (take i l).length&#10;⊢ (if j &amp;lt; i then l[j]? else none) = if j &amp;lt; i then l[j]? else l[j + 1]?" state_after="case isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (take i l).length&#10;h✝ : j &amp;lt; i&#10;⊢ l[j]? = l[j]?&#10;&#10;case isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (take i l).length&#10;h✝ : ¬j &amp;lt; i&#10;⊢ none = l[j + 1]?" tactic="split">
                            <AtomNode start="(22, 5)" end="(22, 10)" leading="" trailing="&#10;    " val="split"/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(23, 5)" end="(23, 10)" kind="Lean.cdot" state_before="case isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (take i l).length&#10;h✝ : j &amp;lt; i&#10;⊢ l[j]? = l[j]?&#10;&#10;case isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (take i l).length&#10;h✝ : ¬j &amp;lt; i&#10;⊢ none = l[j + 1]?" state_after="case isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (take i l).length&#10;h✝ : ¬j &amp;lt; i&#10;⊢ none = l[j + 1]?" tactic="· rfl">
                            <OtherNode start="(23, 5)" end="(23, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(23, 5)" end="(23, 6)" kind="patternIgnore">
                                <OtherNode start="(23, 5)" end="(23, 6)" kind="token.«· »">
                                  <AtomNode start="(23, 5)" end="(23, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(23, 7)" end="(23, 10)">
                              <TacticTacticseq1IndentedNode start="(23, 7)" end="(23, 10)">
                                <NullNode start="(23, 7)" end="(23, 10)">
                                  <OtherNode start="(23, 7)" end="(23, 10)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (take i l).length&#10;h✝ : j &amp;lt; i&#10;⊢ l[j]? = l[j]?" state_after="no goals" tactic="rfl">
                                    <AtomNode start="(23, 7)" end="(23, 10)" leading="" trailing="&#10;    " val="rfl"/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(24, 5)" end="(25, 12)" kind="Lean.cdot" state_before="case isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (take i l).length&#10;h✝ : ¬j &amp;lt; i&#10;⊢ none = l[j + 1]?" state_after="no goals" tactic="· simp_all&#10;  omega">
                            <OtherNode start="(24, 5)" end="(24, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(24, 5)" end="(24, 6)" kind="patternIgnore">
                                <OtherNode start="(24, 5)" end="(24, 6)" kind="token.«· »">
                                  <AtomNode start="(24, 5)" end="(24, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(24, 7)" end="(25, 12)">
                              <TacticTacticseq1IndentedNode start="(24, 7)" end="(25, 12)">
                                <NullNode start="(24, 7)" end="(25, 12)">
                                  <OtherNode start="(24, 7)" end="(24, 15)" kind="Lean.Parser.Tactic.simpAll" state_before="case isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (take i l).length&#10;h✝ : ¬j &amp;lt; i&#10;⊢ none = l[j + 1]?" state_after="case isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; min i l.length&#10;h✝ : i ≤ j&#10;⊢ l.length ≤ j + 1" tactic="simp_all">
                                    <AtomNode start="(24, 7)" end="(24, 15)" leading="" trailing="&#10;      " val="simp_all"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(25, 7)" end="(25, 12)" kind="Lean.Parser.Tactic.omega" state_before="case isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; min i l.length&#10;h✝ : i ≤ j&#10;⊢ l.length ≤ j + 1" state_after="no goals" tactic="omega">
                                    <AtomNode start="(25, 7)" end="(25, 12)" leading="" trailing="&#10;  " val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(26, 3)" end="(38, 58)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;⊢ (drop (i + 1) l)[j - (take i l).length]? = if j &amp;lt; i then l[j]? else l[j + 1]?" state_after="no goals" tactic="· rw [getElem?_drop]&#10;  split &amp;lt;;&amp;gt; rename_i h'&#10;  · simp only [length_take, Nat.min_def, Nat.not_lt] at h&#10;    split at h&#10;    · omega&#10;    · simp_all [getElem?_eq_none]&#10;      omega&#10;  · simp only [length_take]&#10;    simp only [length_take, Nat.min_def, Nat.not_lt] at h&#10;    split at h&#10;    · congr 1&#10;      omega&#10;    · rw [getElem?_eq_none, getElem?_eq_none] &amp;lt;;&amp;gt; omega">
                    <OtherNode start="(26, 3)" end="(26, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(26, 3)" end="(26, 4)" kind="patternIgnore">
                        <OtherNode start="(26, 3)" end="(26, 4)" kind="token.«· »">
                          <AtomNode start="(26, 3)" end="(26, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(26, 5)" end="(38, 58)">
                      <TacticTacticseq1IndentedNode start="(26, 5)" end="(38, 58)">
                        <NullNode start="(26, 5)" end="(38, 58)">
                          <OtherNode start="(26, 5)" end="(26, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;⊢ (drop (i + 1) l)[j - (take i l).length]? = if j &amp;lt; i then l[j]? else l[j + 1]?" state_after="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;⊢ l[i + 1 + (j - (take i l).length)]? = if j &amp;lt; i then l[j]? else l[j + 1]?" tactic="rw [getElem?_drop]">
                            <AtomNode start="(26, 5)" end="(26, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(26, 8)" end="(26, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(26, 8)" end="(26, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(26, 9)" end="(26, 22)">
                                <OtherNode start="(26, 9)" end="(26, 22)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(26, 9)" end="(26, 22)" leading="" trailing="" raw_val="getElem?_drop" val="getElem?_drop" full_name="List.getElem?_drop" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(26, 22)" end="(26, 23)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(27, 5)" end="(27, 26)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;⊢ l[i + 1 + (j - (take i l).length)]? = if j &amp;lt; i then l[j]? else l[j + 1]?" state_after="case isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;h' : j &amp;lt; i&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j]?&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;h' : ¬j &amp;lt; i&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j + 1]?" tactic="split &amp;lt;;&amp;gt; rename_i h'">
                            <OtherNode start="(27, 5)" end="(27, 10)" kind="Lean.Parser.Tactic.split">
                              <AtomNode start="(27, 5)" end="(27, 10)" leading="" trailing=" " val="split"/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(27, 11)" end="(27, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(27, 15)" end="(27, 26)" kind="Lean.Parser.Tactic.renameI">
                              <AtomNode start="(27, 15)" end="(27, 23)" leading="" trailing=" " val="rename_i"/>
                              <NullNode start="(27, 24)" end="(27, 26)">
                                <LeanBinderidentNode start="(27, 24)" end="(27, 26)">
                                  <IdentNode start="(27, 24)" end="(27, 26)" leading="" trailing="&#10;    " raw_val="h'" val="h'"/>
                                </LeanBinderidentNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(28, 5)" end="(32, 14)" kind="Lean.cdot" state_before="case isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;h' : j &amp;lt; i&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j]?&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;h' : ¬j &amp;lt; i&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j + 1]?" state_after="case isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;h' : ¬j &amp;lt; i&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j + 1]?" tactic="· simp only [length_take, Nat.min_def, Nat.not_lt] at h&#10;  split at h&#10;  · omega&#10;  · simp_all [getElem?_eq_none]&#10;    omega">
                            <OtherNode start="(28, 5)" end="(28, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(28, 5)" end="(28, 6)" kind="patternIgnore">
                                <OtherNode start="(28, 5)" end="(28, 6)" kind="token.«· »">
                                  <AtomNode start="(28, 5)" end="(28, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(28, 7)" end="(32, 14)">
                              <TacticTacticseq1IndentedNode start="(28, 7)" end="(32, 14)">
                                <NullNode start="(28, 7)" end="(32, 14)">
                                  <OtherNode start="(28, 7)" end="(28, 60)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;h' : j &amp;lt; i&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j]?" state_after="case isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : j &amp;lt; i&#10;h : (if i ≤ l.length then i else l.length) ≤ j&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j]?" tactic="simp only [length_take, Nat.min_def, Nat.not_lt] at h">
                                    <AtomNode start="(28, 7)" end="(28, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(28, 12)" end="(28, 16)">
                                      <AtomNode start="(28, 12)" end="(28, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(28, 17)" end="(28, 55)">
                                      <AtomNode start="(28, 17)" end="(28, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(28, 18)" end="(28, 54)">
                                        <OtherNode start="(28, 18)" end="(28, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(28, 18)" end="(28, 29)" leading="" trailing="" raw_val="length_take" val="length_take" full_name="List.length_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(28, 29)" end="(28, 30)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(28, 31)" end="(28, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(28, 31)" end="(28, 42)" leading="" trailing="" raw_val="Nat.min_def" val="Nat.min_def" full_name="Nat.min_def" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(28, 42)" end="(28, 43)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(28, 44)" end="(28, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(28, 44)" end="(28, 54)" leading="" trailing="" raw_val="Nat.not_lt" val="Nat.not_lt" full_name="Nat.not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(28, 54)" end="(28, 55)" leading="" trailing=" " val="]"/>
                                    </NullNode>
                                    <NullNode start="(28, 56)" end="(28, 60)">
                                      <OtherNode start="(28, 56)" end="(28, 60)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(28, 56)" end="(28, 58)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(28, 59)" end="(28, 60)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(28, 59)" end="(28, 60)">
                                            <IdentNode start="(28, 59)" end="(28, 60)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(29, 7)" end="(29, 17)" kind="Lean.Parser.Tactic.split" state_before="case isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : j &amp;lt; i&#10;h : (if i ≤ l.length then i else l.length) ≤ j&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j]?" state_after="case isFalse.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : j &amp;lt; i&#10;h✝ : i ≤ l.length&#10;h : i ≤ j&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j]?&#10;&#10;case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : j &amp;lt; i&#10;h✝ : ¬i ≤ l.length&#10;h : l.length ≤ j&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j]?" tactic="split at h">
                                    <AtomNode start="(29, 7)" end="(29, 12)" leading="" trailing=" " val="split"/>
                                    <NullNode/>
                                    <NullNode start="(29, 13)" end="(29, 17)">
                                      <OtherNode start="(29, 13)" end="(29, 17)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(29, 13)" end="(29, 15)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(29, 16)" end="(29, 17)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(29, 16)" end="(29, 17)">
                                            <IdentNode start="(29, 16)" end="(29, 17)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(30, 7)" end="(30, 14)" kind="Lean.cdot" state_before="case isFalse.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : j &amp;lt; i&#10;h✝ : i ≤ l.length&#10;h : i ≤ j&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j]?&#10;&#10;case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : j &amp;lt; i&#10;h✝ : ¬i ≤ l.length&#10;h : l.length ≤ j&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j]?" state_after="case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : j &amp;lt; i&#10;h✝ : ¬i ≤ l.length&#10;h : l.length ≤ j&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j]?" tactic="· omega">
                                    <OtherNode start="(30, 7)" end="(30, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(30, 7)" end="(30, 8)" kind="patternIgnore">
                                        <OtherNode start="(30, 7)" end="(30, 8)" kind="token.«· »">
                                          <AtomNode start="(30, 7)" end="(30, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(30, 9)" end="(30, 14)">
                                      <TacticTacticseq1IndentedNode start="(30, 9)" end="(30, 14)">
                                        <NullNode start="(30, 9)" end="(30, 14)">
                                          <OtherNode start="(30, 9)" end="(30, 14)" kind="Lean.Parser.Tactic.omega" state_before="case isFalse.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : j &amp;lt; i&#10;h✝ : i ≤ l.length&#10;h : i ≤ j&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j]?" state_after="no goals" tactic="omega">
                                            <AtomNode start="(30, 9)" end="(30, 14)" leading="" trailing="&#10;      " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(31, 7)" end="(32, 14)" kind="Lean.cdot" state_before="case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : j &amp;lt; i&#10;h✝ : ¬i ≤ l.length&#10;h : l.length ≤ j&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j]?" state_after="no goals" tactic="· simp_all [getElem?_eq_none]&#10;  omega">
                                    <OtherNode start="(31, 7)" end="(31, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(31, 7)" end="(31, 8)" kind="patternIgnore">
                                        <OtherNode start="(31, 7)" end="(31, 8)" kind="token.«· »">
                                          <AtomNode start="(31, 7)" end="(31, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(31, 9)" end="(32, 14)">
                                      <TacticTacticseq1IndentedNode start="(31, 9)" end="(32, 14)">
                                        <NullNode start="(31, 9)" end="(32, 14)">
                                          <OtherNode start="(31, 9)" end="(31, 36)" kind="Lean.Parser.Tactic.simpAll" state_before="case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : j &amp;lt; i&#10;h✝ : ¬i ≤ l.length&#10;h : l.length ≤ j&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j]?" state_after="case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : j &amp;lt; i&#10;h✝ : l.length &amp;lt; i&#10;h : l.length ≤ j&#10;⊢ l.length ≤ i + 1 + (j - min i l.length)" tactic="simp_all [getElem?_eq_none]">
                                            <AtomNode start="(31, 9)" end="(31, 17)" leading="" trailing=" " val="simp_all"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(31, 18)" end="(31, 36)">
                                              <AtomNode start="(31, 18)" end="(31, 19)" leading="" trailing="" val="["/>
                                              <NullNode start="(31, 19)" end="(31, 35)">
                                                <OtherNode start="(31, 19)" end="(31, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(31, 19)" end="(31, 35)" leading="" trailing="" raw_val="getElem?_eq_none" val="getElem?_eq_none" full_name="List.getElem?_eq_none" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(31, 35)" end="(31, 36)" leading="" trailing="&#10;        " val="]"/>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(32, 9)" end="(32, 14)" kind="Lean.Parser.Tactic.omega" state_before="case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : j &amp;lt; i&#10;h✝ : l.length &amp;lt; i&#10;h : l.length ≤ j&#10;⊢ l.length ≤ i + 1 + (j - min i l.length)" state_after="no goals" tactic="omega">
                                            <AtomNode start="(32, 9)" end="(32, 14)" leading="" trailing="&#10;    " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(33, 5)" end="(38, 58)" kind="Lean.cdot" state_before="case isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;h' : ¬j &amp;lt; i&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j + 1]?" state_after="no goals" tactic="· simp only [length_take]&#10;  simp only [length_take, Nat.min_def, Nat.not_lt] at h&#10;  split at h&#10;  · congr 1&#10;    omega&#10;  · rw [getElem?_eq_none, getElem?_eq_none] &amp;lt;;&amp;gt; omega">
                            <OtherNode start="(33, 5)" end="(33, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(33, 5)" end="(33, 6)" kind="patternIgnore">
                                <OtherNode start="(33, 5)" end="(33, 6)" kind="token.«· »">
                                  <AtomNode start="(33, 5)" end="(33, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(33, 7)" end="(38, 58)">
                              <TacticTacticseq1IndentedNode start="(33, 7)" end="(38, 58)">
                                <NullNode start="(33, 7)" end="(38, 58)">
                                  <OtherNode start="(33, 7)" end="(33, 30)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;h' : ¬j &amp;lt; i&#10;⊢ l[i + 1 + (j - (take i l).length)]? = l[j + 1]?" state_after="case isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;h' : ¬j &amp;lt; i&#10;⊢ l[i + 1 + (j - min i l.length)]? = l[j + 1]?" tactic="simp only [length_take]">
                                    <AtomNode start="(33, 7)" end="(33, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(33, 12)" end="(33, 16)">
                                      <AtomNode start="(33, 12)" end="(33, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(33, 17)" end="(33, 30)">
                                      <AtomNode start="(33, 17)" end="(33, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(33, 18)" end="(33, 29)">
                                        <OtherNode start="(33, 18)" end="(33, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(33, 18)" end="(33, 29)" leading="" trailing="" raw_val="length_take" val="length_take" full_name="List.length_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(33, 29)" end="(33, 30)" leading="" trailing="&#10;      " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(34, 7)" end="(34, 60)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : ¬j &amp;lt; (take i l).length&#10;h' : ¬j &amp;lt; i&#10;⊢ l[i + 1 + (j - min i l.length)]? = l[j + 1]?" state_after="case isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : ¬j &amp;lt; i&#10;h : (if i ≤ l.length then i else l.length) ≤ j&#10;⊢ l[i + 1 + (j - min i l.length)]? = l[j + 1]?" tactic="simp only [length_take, Nat.min_def, Nat.not_lt] at h">
                                    <AtomNode start="(34, 7)" end="(34, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(34, 12)" end="(34, 16)">
                                      <AtomNode start="(34, 12)" end="(34, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(34, 17)" end="(34, 55)">
                                      <AtomNode start="(34, 17)" end="(34, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(34, 18)" end="(34, 54)">
                                        <OtherNode start="(34, 18)" end="(34, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(34, 18)" end="(34, 29)" leading="" trailing="" raw_val="length_take" val="length_take" full_name="List.length_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(34, 29)" end="(34, 30)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(34, 31)" end="(34, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(34, 31)" end="(34, 42)" leading="" trailing="" raw_val="Nat.min_def" val="Nat.min_def" full_name="Nat.min_def" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(34, 42)" end="(34, 43)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(34, 44)" end="(34, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(34, 44)" end="(34, 54)" leading="" trailing="" raw_val="Nat.not_lt" val="Nat.not_lt" full_name="Nat.not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(34, 54)" end="(34, 55)" leading="" trailing=" " val="]"/>
                                    </NullNode>
                                    <NullNode start="(34, 56)" end="(34, 60)">
                                      <OtherNode start="(34, 56)" end="(34, 60)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(34, 56)" end="(34, 58)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(34, 59)" end="(34, 60)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(34, 59)" end="(34, 60)">
                                            <IdentNode start="(34, 59)" end="(34, 60)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(35, 7)" end="(35, 17)" kind="Lean.Parser.Tactic.split" state_before="case isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : ¬j &amp;lt; i&#10;h : (if i ≤ l.length then i else l.length) ≤ j&#10;⊢ l[i + 1 + (j - min i l.length)]? = l[j + 1]?" state_after="case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : ¬j &amp;lt; i&#10;h✝ : i ≤ l.length&#10;h : i ≤ j&#10;⊢ l[i + 1 + (j - min i l.length)]? = l[j + 1]?&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : ¬j &amp;lt; i&#10;h✝ : ¬i ≤ l.length&#10;h : l.length ≤ j&#10;⊢ l[i + 1 + (j - min i l.length)]? = l[j + 1]?" tactic="split at h">
                                    <AtomNode start="(35, 7)" end="(35, 12)" leading="" trailing=" " val="split"/>
                                    <NullNode/>
                                    <NullNode start="(35, 13)" end="(35, 17)">
                                      <OtherNode start="(35, 13)" end="(35, 17)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(35, 13)" end="(35, 15)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(35, 16)" end="(35, 17)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(35, 16)" end="(35, 17)">
                                            <IdentNode start="(35, 16)" end="(35, 17)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(36, 7)" end="(37, 14)" kind="Lean.cdot" state_before="case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : ¬j &amp;lt; i&#10;h✝ : i ≤ l.length&#10;h : i ≤ j&#10;⊢ l[i + 1 + (j - min i l.length)]? = l[j + 1]?&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : ¬j &amp;lt; i&#10;h✝ : ¬i ≤ l.length&#10;h : l.length ≤ j&#10;⊢ l[i + 1 + (j - min i l.length)]? = l[j + 1]?" state_after="case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : ¬j &amp;lt; i&#10;h✝ : ¬i ≤ l.length&#10;h : l.length ≤ j&#10;⊢ l[i + 1 + (j - min i l.length)]? = l[j + 1]?" tactic="· congr 1&#10;  omega">
                                    <OtherNode start="(36, 7)" end="(36, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(36, 7)" end="(36, 8)" kind="patternIgnore">
                                        <OtherNode start="(36, 7)" end="(36, 8)" kind="token.«· »">
                                          <AtomNode start="(36, 7)" end="(36, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(36, 9)" end="(37, 14)">
                                      <TacticTacticseq1IndentedNode start="(36, 9)" end="(37, 14)">
                                        <NullNode start="(36, 9)" end="(37, 14)">
                                          <OtherNode start="(36, 9)" end="(36, 16)" kind="Lean.Parser.Tactic.congr" state_before="case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : ¬j &amp;lt; i&#10;h✝ : i ≤ l.length&#10;h : i ≤ j&#10;⊢ l[i + 1 + (j - min i l.length)]? = l[j + 1]?" state_after="case isFalse.isFalse.isTrue.e_a&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : ¬j &amp;lt; i&#10;h✝ : i ≤ l.length&#10;h : i ≤ j&#10;⊢ i + 1 + (j - min i l.length) = j + 1" tactic="congr 1">
                                            <AtomNode start="(36, 9)" end="(36, 14)" leading="" trailing=" " val="congr"/>
                                            <NullNode start="(36, 15)" end="(36, 16)">
                                              <OtherNode start="(36, 15)" end="(36, 16)" kind="num">
                                                <AtomNode start="(36, 15)" end="(36, 16)" leading="" trailing="&#10;        " val="1"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(37, 9)" end="(37, 14)" kind="Lean.Parser.Tactic.omega" state_before="case isFalse.isFalse.isTrue.e_a&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : ¬j &amp;lt; i&#10;h✝ : i ≤ l.length&#10;h : i ≤ j&#10;⊢ i + 1 + (j - min i l.length) = j + 1" state_after="no goals" tactic="omega">
                                            <AtomNode start="(37, 9)" end="(37, 14)" leading="" trailing="&#10;      " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(38, 7)" end="(38, 58)" kind="Lean.cdot" state_before="case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : ¬j &amp;lt; i&#10;h✝ : ¬i ≤ l.length&#10;h : l.length ≤ j&#10;⊢ l[i + 1 + (j - min i l.length)]? = l[j + 1]?" state_after="no goals" tactic="· rw [getElem?_eq_none, getElem?_eq_none] &amp;lt;;&amp;gt; omega">
                                    <OtherNode start="(38, 7)" end="(38, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(38, 7)" end="(38, 8)" kind="patternIgnore">
                                        <OtherNode start="(38, 7)" end="(38, 8)" kind="token.«· »">
                                          <AtomNode start="(38, 7)" end="(38, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(38, 9)" end="(38, 58)">
                                      <TacticTacticseq1IndentedNode start="(38, 9)" end="(38, 58)">
                                        <NullNode start="(38, 9)" end="(38, 58)">
                                          <OtherNode start="(38, 9)" end="(38, 58)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h' : ¬j &amp;lt; i&#10;h✝ : ¬i ≤ l.length&#10;h : l.length ≤ j&#10;⊢ l[i + 1 + (j - min i l.length)]? = l[j + 1]?" state_after="no goals" tactic="rw [getElem?_eq_none, getElem?_eq_none] &amp;lt;;&amp;gt; omega">
                                            <OtherNode start="(38, 9)" end="(38, 48)" kind="Lean.Parser.Tactic.rwSeq">
                                              <AtomNode start="(38, 9)" end="(38, 11)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(38, 12)" end="(38, 48)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(38, 12)" end="(38, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(38, 13)" end="(38, 47)">
                                                  <OtherNode start="(38, 13)" end="(38, 29)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(38, 13)" end="(38, 29)" leading="" trailing="" raw_val="getElem?_eq_none" val="getElem?_eq_none" full_name="List.getElem?_eq_none" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(38, 29)" end="(38, 30)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(38, 31)" end="(38, 47)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(38, 31)" end="(38, 47)" leading="" trailing="" raw_val="getElem?_eq_none" val="getElem?_eq_none" full_name="List.getElem?_eq_none" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(38, 47)" end="(38, 48)" leading="" trailing=" " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(38, 49)" end="(38, 52)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                            <OtherNode start="(38, 53)" end="(38, 58)" kind="Lean.Parser.Tactic.omega">
                                              <AtomNode start="(38, 53)" end="(38, 58)" leading="" trailing="&#10;&#10;" val="omega"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(40, 1)" end="(43, 11)" name="getElem?_eraseIdx_of_lt" full_name="List.getElem?_eraseIdx_of_lt">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(40, 1)" end="(43, 11)" name="getElem?_eraseIdx_of_lt" full_name="List.getElem?_eraseIdx_of_lt" _is_private_decl="False">
        <AtomNode start="(40, 1)" end="(40, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(40, 9)" end="(40, 32)">
          <IdentNode start="(40, 9)" end="(40, 32)" leading="" trailing=" " raw_val="getElem?_eraseIdx_of_lt" val="getElem?_eraseIdx_of_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(40, 33)" end="(41, 31)">
          <NullNode start="(40, 33)" end="(40, 77)">
            <OtherNode start="(40, 33)" end="(40, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(40, 33)" end="(40, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(40, 34)" end="(40, 35)">
                <IdentNode start="(40, 34)" end="(40, 35)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(40, 36)" end="(40, 44)">
                <AtomNode start="(40, 36)" end="(40, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(40, 38)" end="(40, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(40, 38)" end="(40, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(40, 43)" end="(40, 44)">
                    <IdentNode start="(40, 43)" end="(40, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(40, 44)" end="(40, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(40, 46)" end="(40, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(40, 46)" end="(40, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(40, 47)" end="(40, 48)">
                <IdentNode start="(40, 47)" end="(40, 48)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(40, 49)" end="(40, 54)">
                <AtomNode start="(40, 49)" end="(40, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(40, 51)" end="(40, 54)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(40, 54)" end="(40, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(40, 56)" end="(40, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(40, 56)" end="(40, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(40, 57)" end="(40, 58)">
                <IdentNode start="(40, 57)" end="(40, 58)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(40, 59)" end="(40, 64)">
                <AtomNode start="(40, 59)" end="(40, 60)" leading="" trailing=" " val=":"/>
                <IdentNode start="(40, 61)" end="(40, 64)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(40, 64)" end="(40, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(40, 66)" end="(40, 77)">
              <AtomNode start="(40, 66)" end="(40, 67)" leading="" trailing="" val="("/>
              <NullNode start="(40, 67)" end="(40, 68)">
                <IdentNode start="(40, 67)" end="(40, 68)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(40, 69)" end="(40, 76)">
                <AtomNode start="(40, 69)" end="(40, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(40, 71)" end="(40, 76)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(40, 71)" end="(40, 72)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(40, 73)" end="(40, 74)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(40, 75)" end="(40, 76)" leading="" trailing="" raw_val="i" val="i"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(40, 76)" end="(40, 77)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(40, 78)" end="(41, 31)">
            <AtomNode start="(40, 78)" end="(40, 79)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(41, 5)" end="(41, 31)" kind="«term_=_»">
              <OtherNode start="(41, 5)" end="(41, 23)" kind="«term__[_]_?»">
                <OtherNode start="(41, 5)" end="(41, 19)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(41, 5)" end="(41, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(41, 6)" end="(41, 18)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(41, 6)" end="(41, 16)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                    <NullNode start="(41, 17)" end="(41, 18)">
                      <IdentNode start="(41, 17)" end="(41, 18)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(41, 18)" end="(41, 19)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(41, 19)" end="(41, 20)" leading="" trailing="" val="["/>
                <IdentNode start="(41, 20)" end="(41, 21)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(41, 21)" end="(41, 22)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(41, 22)" end="(41, 23)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(41, 24)" end="(41, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(41, 26)" end="(41, 31)" kind="«term__[_]_?»">
                <IdentNode start="(41, 26)" end="(41, 27)" leading="" trailing="" raw_val="l" val="l"/>
                <GroupNode/>
                <AtomNode start="(41, 27)" end="(41, 28)" leading="" trailing="" val="["/>
                <IdentNode start="(41, 28)" end="(41, 29)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(41, 29)" end="(41, 30)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(41, 30)" end="(41, 31)" leading="" trailing=" " val="?"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(41, 32)" end="(43, 11)">
          <AtomNode start="(41, 32)" end="(41, 34)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(41, 35)" end="(43, 11)">
            <AtomNode start="(41, 35)" end="(41, 37)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(42, 3)" end="(43, 11)">
              <TacticTacticseq1IndentedNode start="(42, 3)" end="(43, 11)">
                <NullNode start="(42, 3)" end="(43, 11)">
                  <OtherNode start="(42, 3)" end="(42, 25)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; i&#10;⊢ (l.eraseIdx i)[j]? = l[j]?" state_after="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; i&#10;⊢ (if j &amp;lt; i then l[j]? else l[j + 1]?) = l[j]?" tactic="rw [getElem?_eraseIdx]">
                    <AtomNode start="(42, 3)" end="(42, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(42, 6)" end="(42, 25)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(42, 6)" end="(42, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(42, 7)" end="(42, 24)">
                        <OtherNode start="(42, 7)" end="(42, 24)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(42, 7)" end="(42, 24)" leading="" trailing="" raw_val="getElem?_eraseIdx" val="getElem?_eraseIdx" full_name="List.getElem?_eraseIdx" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean" def_start="(17, 9)" def_end="(17, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(42, 24)" end="(42, 25)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(43, 3)" end="(43, 11)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; i&#10;⊢ (if j &amp;lt; i then l[j]? else l[j + 1]?) = l[j]?" state_after="no goals" tactic="simp [h]">
                    <AtomNode start="(43, 3)" end="(43, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(43, 8)" end="(43, 11)">
                      <AtomNode start="(43, 8)" end="(43, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(43, 9)" end="(43, 10)">
                        <OtherNode start="(43, 9)" end="(43, 10)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(43, 9)" end="(43, 10)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(43, 10)" end="(43, 11)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(45, 1)" end="(50, 8)" name="getElem?_eraseIdx_of_ge" full_name="List.getElem?_eraseIdx_of_ge">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(45, 1)" end="(50, 8)" name="getElem?_eraseIdx_of_ge" full_name="List.getElem?_eraseIdx_of_ge" _is_private_decl="False">
        <AtomNode start="(45, 1)" end="(45, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(45, 9)" end="(45, 32)">
          <IdentNode start="(45, 9)" end="(45, 32)" leading="" trailing=" " raw_val="getElem?_eraseIdx_of_ge" val="getElem?_eraseIdx_of_ge"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(45, 33)" end="(46, 35)">
          <NullNode start="(45, 33)" end="(45, 77)">
            <OtherNode start="(45, 33)" end="(45, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(45, 33)" end="(45, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(45, 34)" end="(45, 35)">
                <IdentNode start="(45, 34)" end="(45, 35)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(45, 36)" end="(45, 44)">
                <AtomNode start="(45, 36)" end="(45, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(45, 38)" end="(45, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(45, 38)" end="(45, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(45, 43)" end="(45, 44)">
                    <IdentNode start="(45, 43)" end="(45, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(45, 44)" end="(45, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(45, 46)" end="(45, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(45, 46)" end="(45, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(45, 47)" end="(45, 48)">
                <IdentNode start="(45, 47)" end="(45, 48)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(45, 49)" end="(45, 54)">
                <AtomNode start="(45, 49)" end="(45, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(45, 51)" end="(45, 54)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(45, 54)" end="(45, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(45, 56)" end="(45, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(45, 56)" end="(45, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(45, 57)" end="(45, 58)">
                <IdentNode start="(45, 57)" end="(45, 58)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(45, 59)" end="(45, 64)">
                <AtomNode start="(45, 59)" end="(45, 60)" leading="" trailing=" " val=":"/>
                <IdentNode start="(45, 61)" end="(45, 64)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(45, 64)" end="(45, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(45, 66)" end="(45, 77)">
              <AtomNode start="(45, 66)" end="(45, 67)" leading="" trailing="" val="("/>
              <NullNode start="(45, 67)" end="(45, 68)">
                <IdentNode start="(45, 67)" end="(45, 68)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(45, 69)" end="(45, 76)">
                <AtomNode start="(45, 69)" end="(45, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(45, 71)" end="(45, 76)" kind="«term_≤_»">
                  <IdentNode start="(45, 71)" end="(45, 72)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(45, 73)" end="(45, 74)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(45, 75)" end="(45, 76)" leading="" trailing="" raw_val="j" val="j"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(45, 76)" end="(45, 77)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(45, 78)" end="(46, 35)">
            <AtomNode start="(45, 78)" end="(45, 79)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(46, 5)" end="(46, 35)" kind="«term_=_»">
              <OtherNode start="(46, 5)" end="(46, 23)" kind="«term__[_]_?»">
                <OtherNode start="(46, 5)" end="(46, 19)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(46, 5)" end="(46, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(46, 6)" end="(46, 18)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(46, 6)" end="(46, 16)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                    <NullNode start="(46, 17)" end="(46, 18)">
                      <IdentNode start="(46, 17)" end="(46, 18)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(46, 18)" end="(46, 19)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(46, 19)" end="(46, 20)" leading="" trailing="" val="["/>
                <IdentNode start="(46, 20)" end="(46, 21)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(46, 21)" end="(46, 22)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(46, 22)" end="(46, 23)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(46, 24)" end="(46, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(46, 26)" end="(46, 35)" kind="«term__[_]_?»">
                <IdentNode start="(46, 26)" end="(46, 27)" leading="" trailing="" raw_val="l" val="l"/>
                <GroupNode/>
                <AtomNode start="(46, 27)" end="(46, 28)" leading="" trailing="" val="["/>
                <OtherNode start="(46, 28)" end="(46, 33)" kind="«term_+_»">
                  <IdentNode start="(46, 28)" end="(46, 29)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(46, 30)" end="(46, 31)" leading="" trailing=" " val="+"/>
                  <OtherNode start="(46, 32)" end="(46, 33)" kind="num">
                    <AtomNode start="(46, 32)" end="(46, 33)" leading="" trailing="" val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(46, 33)" end="(46, 34)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(46, 34)" end="(46, 35)" leading="" trailing=" " val="?"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(46, 36)" end="(50, 8)">
          <AtomNode start="(46, 36)" end="(46, 38)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(46, 39)" end="(50, 8)">
            <AtomNode start="(46, 39)" end="(46, 41)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(47, 3)" end="(50, 8)">
              <TacticTacticseq1IndentedNode start="(47, 3)" end="(50, 8)">
                <NullNode start="(47, 3)" end="(50, 8)">
                  <OtherNode start="(47, 3)" end="(47, 25)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : i ≤ j&#10;⊢ (l.eraseIdx i)[j]? = l[j + 1]?" state_after="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : i ≤ j&#10;⊢ (if j &amp;lt; i then l[j]? else l[j + 1]?) = l[j + 1]?" tactic="rw [getElem?_eraseIdx]">
                    <AtomNode start="(47, 3)" end="(47, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(47, 6)" end="(47, 25)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(47, 6)" end="(47, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(47, 7)" end="(47, 24)">
                        <OtherNode start="(47, 7)" end="(47, 24)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(47, 7)" end="(47, 24)" leading="" trailing="" raw_val="getElem?_eraseIdx" val="getElem?_eraseIdx" full_name="List.getElem?_eraseIdx" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean" def_start="(17, 9)" def_end="(17, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(47, 24)" end="(47, 25)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(48, 3)" end="(48, 44)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : i ≤ j&#10;⊢ (if j &amp;lt; i then l[j]? else l[j + 1]?) = l[j + 1]?" state_after="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : i ≤ j&#10;⊢ j &amp;lt; i → l[j]? = l[j + 1]?" tactic="simp only [dite_eq_ite, ite_eq_right_iff]">
                    <AtomNode start="(48, 3)" end="(48, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(48, 8)" end="(48, 12)">
                      <AtomNode start="(48, 8)" end="(48, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(48, 13)" end="(48, 44)">
                      <AtomNode start="(48, 13)" end="(48, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(48, 14)" end="(48, 43)">
                        <OtherNode start="(48, 14)" end="(48, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(48, 14)" end="(48, 25)" leading="" trailing="" raw_val="dite_eq_ite" val="dite_eq_ite" full_name="dite_eq_ite" mod_name="Init.ByCases" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/ByCases.lean"/>
                        </OtherNode>
                        <AtomNode start="(48, 25)" end="(48, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(48, 27)" end="(48, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(48, 27)" end="(48, 43)" leading="" trailing="" raw_val="ite_eq_right_iff" val="ite_eq_right_iff" full_name="ite_eq_right_iff" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(48, 43)" end="(48, 44)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(49, 3)" end="(49, 11)" kind="Lean.Parser.Tactic.intro" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : i ≤ j&#10;⊢ j &amp;lt; i → l[j]? = l[j + 1]?" state_after="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : i ≤ j&#10;h' : j &amp;lt; i&#10;⊢ l[j]? = l[j + 1]?" tactic="intro h'">
                    <AtomNode start="(49, 3)" end="(49, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(49, 9)" end="(49, 11)">
                      <IdentNode start="(49, 9)" end="(49, 11)" leading="" trailing="&#10;  " raw_val="h'" val="h'"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(50, 3)" end="(50, 8)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : i ≤ j&#10;h' : j &amp;lt; i&#10;⊢ l[j]? = l[j + 1]?" state_after="no goals" tactic="omega">
                    <AtomNode start="(50, 3)" end="(50, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(52, 1)" end="(59, 17)" name="getElem_eraseIdx" full_name="List.getElem_eraseIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(52, 1)" end="(59, 17)" name="getElem_eraseIdx" full_name="List.getElem_eraseIdx" _is_private_decl="False">
        <AtomNode start="(52, 1)" end="(52, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(52, 9)" end="(52, 25)">
          <IdentNode start="(52, 9)" end="(52, 25)" leading="" trailing=" " raw_val="getElem_eraseIdx" val="getElem_eraseIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(52, 26)" end="(56, 70)">
          <NullNode start="(52, 26)" end="(52, 90)">
            <OtherNode start="(52, 26)" end="(52, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(52, 26)" end="(52, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(52, 27)" end="(52, 28)">
                <IdentNode start="(52, 27)" end="(52, 28)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(52, 29)" end="(52, 37)">
                <AtomNode start="(52, 29)" end="(52, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(52, 31)" end="(52, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(52, 31)" end="(52, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(52, 36)" end="(52, 37)">
                    <IdentNode start="(52, 36)" end="(52, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(52, 37)" end="(52, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(52, 39)" end="(52, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(52, 39)" end="(52, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(52, 40)" end="(52, 41)">
                <IdentNode start="(52, 40)" end="(52, 41)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(52, 42)" end="(52, 47)">
                <AtomNode start="(52, 42)" end="(52, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(52, 44)" end="(52, 47)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(52, 47)" end="(52, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(52, 49)" end="(52, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(52, 49)" end="(52, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(52, 50)" end="(52, 51)">
                <IdentNode start="(52, 50)" end="(52, 51)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(52, 52)" end="(52, 57)">
                <AtomNode start="(52, 52)" end="(52, 53)" leading="" trailing=" " val=":"/>
                <IdentNode start="(52, 54)" end="(52, 57)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(52, 57)" end="(52, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(52, 59)" end="(52, 90)">
              <AtomNode start="(52, 59)" end="(52, 60)" leading="" trailing="" val="("/>
              <NullNode start="(52, 60)" end="(52, 61)">
                <IdentNode start="(52, 60)" end="(52, 61)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(52, 62)" end="(52, 89)">
                <AtomNode start="(52, 62)" end="(52, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(52, 64)" end="(52, 89)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(52, 64)" end="(52, 65)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(52, 66)" end="(52, 67)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(52, 68)" end="(52, 89)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(52, 68)" end="(52, 82)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(52, 68)" end="(52, 69)" leading="" trailing="" val="("/>
                      <OtherNode start="(52, 69)" end="(52, 81)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(52, 69)" end="(52, 79)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                        <NullNode start="(52, 80)" end="(52, 81)">
                          <IdentNode start="(52, 80)" end="(52, 81)" leading="" trailing="" raw_val="i" val="i"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(52, 81)" end="(52, 82)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(52, 82)" end="(52, 83)" leading="" trailing="" val="."/>
                    <IdentNode start="(52, 83)" end="(52, 89)" leading="" trailing="" raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(52, 89)" end="(52, 90)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(52, 91)" end="(56, 70)">
            <AtomNode start="(52, 91)" end="(52, 92)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(53, 5)" end="(56, 70)" kind="«term_=_»">
              <OtherNode start="(53, 5)" end="(53, 22)" kind="«term__[_]»">
                <OtherNode start="(53, 5)" end="(53, 19)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(53, 5)" end="(53, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(53, 6)" end="(53, 18)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(53, 6)" end="(53, 16)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                    <NullNode start="(53, 17)" end="(53, 18)">
                      <IdentNode start="(53, 17)" end="(53, 18)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(53, 18)" end="(53, 19)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(53, 19)" end="(53, 20)" leading="" trailing="" val="["/>
                <IdentNode start="(53, 20)" end="(53, 21)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(53, 21)" end="(53, 22)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(53, 23)" end="(53, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(53, 25)" end="(56, 70)" kind="termDepIfThenElse">
                <AtomNode start="(53, 25)" end="(53, 27)" leading="" trailing=" " val="if"/>
                <LeanBinderidentNode start="(53, 28)" end="(53, 30)">
                  <IdentNode start="(53, 28)" end="(53, 30)" leading="" trailing=" " raw_val="h'" val="h'"/>
                </LeanBinderidentNode>
                <AtomNode start="(53, 31)" end="(53, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(53, 33)" end="(53, 38)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(53, 33)" end="(53, 34)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(53, 35)" end="(53, 36)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(53, 37)" end="(53, 38)" leading="" trailing=" " raw_val="i" val="i"/>
                </OtherNode>
                <AtomNode start="(53, 39)" end="(53, 43)" leading="" trailing="&#10;        " val="then"/>
                <OtherNode start="(54, 9)" end="(54, 56)" kind="«term__[_]'_»">
                  <IdentNode start="(54, 9)" end="(54, 10)" leading="" trailing="" raw_val="l" val="l"/>
                  <AtomNode start="(54, 10)" end="(54, 11)" leading="" trailing="" val="["/>
                  <IdentNode start="(54, 11)" end="(54, 12)" leading="" trailing="" raw_val="j" val="j"/>
                  <AtomNode start="(54, 12)" end="(54, 14)" leading="" trailing="" val="]'"/>
                  <OtherNode start="(54, 14)" end="(54, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(54, 14)" end="(54, 15)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(54, 15)" end="(54, 55)">
                      <AtomNode start="(54, 15)" end="(54, 17)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(54, 18)" end="(54, 55)">
                        <TacticTacticseq1IndentedNode start="(54, 18)" end="(54, 55)">
                          <NullNode start="(54, 18)" end="(54, 55)">
                            <OtherNode start="(54, 18)" end="(54, 48)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type ?u.7805&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : j &amp;lt; i&#10;⊢ j &amp;lt; l.length" state_after="α : Type ?u.7805&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : j &amp;lt; i&#10;this : (l.eraseIdx i).length ≤ l.length&#10;⊢ j &amp;lt; l.length" tactic="have := length_eraseIdx_le l i">
                              <AtomNode start="(54, 18)" end="(54, 22)" leading="" trailing=" " val="have"/>
                              <OtherNode start="(54, 23)" end="(54, 48)" kind="Lean.Parser.Term.haveDecl">
                                <OtherNode start="(54, 23)" end="(54, 48)" kind="Lean.Parser.Term.haveIdDecl">
                                  <OtherNode start="(54, 23)" end="(54, 23)" kind="Lean.Parser.Term.haveId">
                                    <OtherNode start="(54, 23)" end="(54, 23)" kind="hygieneInfo">
                                      <IdentNode start="(54, 23)" end="(54, 23)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <AtomNode start="(54, 23)" end="(54, 25)" leading="" trailing=" " val=":="/>
                                  <OtherNode start="(54, 26)" end="(54, 48)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(54, 26)" end="(54, 44)" leading="" trailing=" " raw_val="length_eraseIdx_le" val="length_eraseIdx_le" full_name="List.length_eraseIdx_le" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                                    <NullNode start="(54, 45)" end="(54, 48)">
                                      <IdentNode start="(54, 45)" end="(54, 46)" leading="" trailing=" " raw_val="l" val="l"/>
                                      <IdentNode start="(54, 47)" end="(54, 48)" leading="" trailing="" raw_val="i" val="i"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(54, 48)" end="(54, 49)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(54, 50)" end="(54, 55)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.7805&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : j &amp;lt; i&#10;this : (l.eraseIdx i).length ≤ l.length&#10;⊢ j &amp;lt; l.length" state_after="no goals" tactic="omega">
                              <AtomNode start="(54, 50)" end="(54, 55)" leading="" trailing="" val="omega"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(54, 55)" end="(54, 56)" leading="" trailing="&#10;      " val=")"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(55, 7)" end="(55, 11)" leading="" trailing="&#10;        " val="else"/>
                <OtherNode start="(56, 9)" end="(56, 70)" kind="«term__[_]'_»">
                  <IdentNode start="(56, 9)" end="(56, 10)" leading="" trailing="" raw_val="l" val="l"/>
                  <AtomNode start="(56, 10)" end="(56, 11)" leading="" trailing="" val="["/>
                  <OtherNode start="(56, 11)" end="(56, 16)" kind="«term_+_»">
                    <IdentNode start="(56, 11)" end="(56, 12)" leading="" trailing=" " raw_val="j" val="j"/>
                    <AtomNode start="(56, 13)" end="(56, 14)" leading="" trailing=" " val="+"/>
                    <OtherNode start="(56, 15)" end="(56, 16)" kind="num">
                      <AtomNode start="(56, 15)" end="(56, 16)" leading="" trailing="" val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(56, 16)" end="(56, 18)" leading="" trailing="" val="]'"/>
                  <OtherNode start="(56, 18)" end="(56, 70)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(56, 18)" end="(56, 19)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(56, 19)" end="(56, 69)">
                      <AtomNode start="(56, 19)" end="(56, 21)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(56, 22)" end="(56, 69)">
                        <TacticTacticseq1IndentedNode start="(56, 22)" end="(56, 69)">
                          <NullNode start="(56, 22)" end="(56, 69)">
                            <OtherNode start="(56, 22)" end="(56, 47)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type ?u.7805&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : ¬j &amp;lt; i&#10;⊢ j + 1 &amp;lt; l.length" state_after="α : Type ?u.7805&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; if i &amp;lt; l.length then l.length - 1 else l.length&#10;h' : ¬j &amp;lt; i&#10;⊢ j + 1 &amp;lt; l.length" tactic="rw [length_eraseIdx] at h">
                              <AtomNode start="(56, 22)" end="(56, 24)" leading="" trailing=" " val="rw"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <OtherNode start="(56, 25)" end="(56, 42)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                <AtomNode start="(56, 25)" end="(56, 26)" leading="" trailing="" val="["/>
                                <NullNode start="(56, 26)" end="(56, 41)">
                                  <OtherNode start="(56, 26)" end="(56, 41)" kind="Lean.Parser.Tactic.rwRule">
                                    <NullNode/>
                                    <IdentNode start="(56, 26)" end="(56, 41)" leading="" trailing="" raw_val="length_eraseIdx" val="length_eraseIdx" full_name="List.length_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(56, 41)" end="(56, 42)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                              <NullNode start="(56, 43)" end="(56, 47)">
                                <OtherNode start="(56, 43)" end="(56, 47)" kind="Lean.Parser.Tactic.location">
                                  <AtomNode start="(56, 43)" end="(56, 45)" leading="" trailing=" " val="at"/>
                                  <OtherNode start="(56, 46)" end="(56, 47)" kind="Lean.Parser.Tactic.locationHyp">
                                    <NullNode start="(56, 46)" end="(56, 47)">
                                      <IdentNode start="(56, 46)" end="(56, 47)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(56, 47)" end="(56, 48)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(56, 49)" end="(56, 69)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type ?u.7805&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; if i &amp;lt; l.length then l.length - 1 else l.length&#10;h' : ¬j &amp;lt; i&#10;⊢ j + 1 &amp;lt; l.length" state_after="no goals" tactic="split at h &amp;lt;;&amp;gt; omega">
                              <OtherNode start="(56, 49)" end="(56, 59)" kind="Lean.Parser.Tactic.split">
                                <AtomNode start="(56, 49)" end="(56, 54)" leading="" trailing=" " val="split"/>
                                <NullNode/>
                                <NullNode start="(56, 55)" end="(56, 59)">
                                  <OtherNode start="(56, 55)" end="(56, 59)" kind="Lean.Parser.Tactic.location">
                                    <AtomNode start="(56, 55)" end="(56, 57)" leading="" trailing=" " val="at"/>
                                    <OtherNode start="(56, 58)" end="(56, 59)" kind="Lean.Parser.Tactic.locationHyp">
                                      <NullNode start="(56, 58)" end="(56, 59)">
                                        <IdentNode start="(56, 58)" end="(56, 59)" leading="" trailing=" " raw_val="h" val="h"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(56, 60)" end="(56, 63)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                              <OtherNode start="(56, 64)" end="(56, 69)" kind="Lean.Parser.Tactic.omega">
                                <AtomNode start="(56, 64)" end="(56, 69)" leading="" trailing="" val="omega"/>
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(56, 69)" end="(56, 70)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(56, 71)" end="(59, 17)">
          <AtomNode start="(56, 71)" end="(56, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(56, 74)" end="(59, 17)">
            <AtomNode start="(56, 74)" end="(56, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(57, 3)" end="(59, 17)">
              <TacticTacticseq1IndentedNode start="(57, 3)" end="(59, 17)">
                <NullNode start="(57, 3)" end="(59, 17)">
                  <OtherNode start="(57, 3)" end="(57, 24)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;⊢ (l.eraseIdx i)[j] = if h' : j &amp;lt; i then l[j] else l[j + 1]" state_after="case x&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;⊢ some (l.eraseIdx i)[j] = some (if h' : j &amp;lt; i then l[j] else l[j + 1])" tactic="apply Option.some.inj">
                    <AtomNode start="(57, 3)" end="(57, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(57, 9)" end="(57, 24)" leading="" trailing="&#10;  " raw_val="Option.some.inj" val="Option.some.inj" full_name="Option.some.inj" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(58, 3)" end="(58, 48)" kind="Lean.Parser.Tactic.rwSeq" state_before="case x&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;⊢ some (l.eraseIdx i)[j] = some (if h' : j &amp;lt; i then l[j] else l[j + 1])" state_after="case x&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;⊢ (if j &amp;lt; i then l[j]? else l[j + 1]?) = some (if h' : j &amp;lt; i then l[j] else l[j + 1])" tactic="rw [← getElem?_eq_getElem, getElem?_eraseIdx]">
                    <AtomNode start="(58, 3)" end="(58, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(58, 6)" end="(58, 48)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(58, 6)" end="(58, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(58, 7)" end="(58, 47)">
                        <OtherNode start="(58, 7)" end="(58, 28)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(58, 7)" end="(58, 8)">
                            <OtherNode start="(58, 7)" end="(58, 8)" kind="patternIgnore">
                              <OtherNode start="(58, 7)" end="(58, 8)" kind="token.«← »">
                                <AtomNode start="(58, 7)" end="(58, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(58, 9)" end="(58, 28)" leading="" trailing="" raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="List.getElem?_eq_getElem" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                        </OtherNode>
                        <AtomNode start="(58, 28)" end="(58, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(58, 30)" end="(58, 47)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(58, 30)" end="(58, 47)" leading="" trailing="" raw_val="getElem?_eraseIdx" val="getElem?_eraseIdx" full_name="List.getElem?_eraseIdx" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean" def_start="(17, 9)" def_end="(17, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(58, 47)" end="(58, 48)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(59, 3)" end="(59, 17)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case x&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;⊢ (if j &amp;lt; i then l[j]? else l[j + 1]?) = some (if h' : j &amp;lt; i then l[j] else l[j + 1])" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(59, 3)" end="(59, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(59, 3)" end="(59, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(59, 9)" end="(59, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(59, 13)" end="(59, 17)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(59, 13)" end="(59, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(61, 1)" end="(66, 8)" name="getElem_eraseIdx_of_lt" full_name="List.getElem_eraseIdx_of_lt">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(61, 1)" end="(66, 8)" name="getElem_eraseIdx_of_lt" full_name="List.getElem_eraseIdx_of_lt" _is_private_decl="False">
        <AtomNode start="(61, 1)" end="(61, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(61, 9)" end="(61, 31)">
          <IdentNode start="(61, 9)" end="(61, 31)" leading="" trailing=" " raw_val="getElem_eraseIdx_of_lt" val="getElem_eraseIdx_of_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(61, 32)" end="(62, 72)">
          <NullNode start="(61, 32)" end="(61, 109)">
            <OtherNode start="(61, 32)" end="(61, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(61, 32)" end="(61, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(61, 33)" end="(61, 34)">
                <IdentNode start="(61, 33)" end="(61, 34)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(61, 35)" end="(61, 43)">
                <AtomNode start="(61, 35)" end="(61, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(61, 37)" end="(61, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(61, 37)" end="(61, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(61, 42)" end="(61, 43)">
                    <IdentNode start="(61, 42)" end="(61, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(61, 43)" end="(61, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(61, 45)" end="(61, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(61, 45)" end="(61, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(61, 46)" end="(61, 47)">
                <IdentNode start="(61, 46)" end="(61, 47)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(61, 48)" end="(61, 53)">
                <AtomNode start="(61, 48)" end="(61, 49)" leading="" trailing=" " val=":"/>
                <IdentNode start="(61, 50)" end="(61, 53)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(61, 53)" end="(61, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(61, 55)" end="(61, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(61, 55)" end="(61, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(61, 56)" end="(61, 57)">
                <IdentNode start="(61, 56)" end="(61, 57)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(61, 58)" end="(61, 63)">
                <AtomNode start="(61, 58)" end="(61, 59)" leading="" trailing=" " val=":"/>
                <IdentNode start="(61, 60)" end="(61, 63)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(61, 63)" end="(61, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(61, 65)" end="(61, 96)">
              <AtomNode start="(61, 65)" end="(61, 66)" leading="" trailing="" val="("/>
              <NullNode start="(61, 66)" end="(61, 67)">
                <IdentNode start="(61, 66)" end="(61, 67)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(61, 68)" end="(61, 95)">
                <AtomNode start="(61, 68)" end="(61, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(61, 70)" end="(61, 95)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(61, 70)" end="(61, 71)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(61, 72)" end="(61, 73)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(61, 74)" end="(61, 95)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(61, 74)" end="(61, 88)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(61, 74)" end="(61, 75)" leading="" trailing="" val="("/>
                      <OtherNode start="(61, 75)" end="(61, 87)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(61, 75)" end="(61, 85)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                        <NullNode start="(61, 86)" end="(61, 87)">
                          <IdentNode start="(61, 86)" end="(61, 87)" leading="" trailing="" raw_val="i" val="i"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(61, 87)" end="(61, 88)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(61, 88)" end="(61, 89)" leading="" trailing="" val="."/>
                    <IdentNode start="(61, 89)" end="(61, 95)" leading="" trailing="" raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(61, 95)" end="(61, 96)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(61, 97)" end="(61, 109)">
              <AtomNode start="(61, 97)" end="(61, 98)" leading="" trailing="" val="("/>
              <NullNode start="(61, 98)" end="(61, 100)">
                <IdentNode start="(61, 98)" end="(61, 100)" leading="" trailing=" " raw_val="h'" val="h'"/>
              </NullNode>
              <NullNode start="(61, 101)" end="(61, 108)">
                <AtomNode start="(61, 101)" end="(61, 102)" leading="" trailing=" " val=":"/>
                <OtherNode start="(61, 103)" end="(61, 108)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(61, 103)" end="(61, 104)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(61, 105)" end="(61, 106)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(61, 107)" end="(61, 108)" leading="" trailing="" raw_val="i" val="i"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(61, 108)" end="(61, 109)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(61, 110)" end="(62, 72)">
            <AtomNode start="(61, 110)" end="(61, 111)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(62, 5)" end="(62, 72)" kind="«term_=_»">
              <OtherNode start="(62, 5)" end="(62, 22)" kind="«term__[_]»">
                <OtherNode start="(62, 5)" end="(62, 19)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(62, 5)" end="(62, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(62, 6)" end="(62, 18)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(62, 6)" end="(62, 16)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                    <NullNode start="(62, 17)" end="(62, 18)">
                      <IdentNode start="(62, 17)" end="(62, 18)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(62, 18)" end="(62, 19)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(62, 19)" end="(62, 20)" leading="" trailing="" val="["/>
                <IdentNode start="(62, 20)" end="(62, 21)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(62, 21)" end="(62, 22)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(62, 23)" end="(62, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(62, 25)" end="(62, 72)" kind="«term__[_]'_»">
                <IdentNode start="(62, 25)" end="(62, 26)" leading="" trailing="" raw_val="l" val="l"/>
                <AtomNode start="(62, 26)" end="(62, 27)" leading="" trailing="" val="["/>
                <IdentNode start="(62, 27)" end="(62, 28)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(62, 28)" end="(62, 30)" leading="" trailing="" val="]'"/>
                <OtherNode start="(62, 30)" end="(62, 72)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(62, 30)" end="(62, 31)" leading="" trailing="" val="("/>
                  <TermBytacticNode start="(62, 31)" end="(62, 71)">
                    <AtomNode start="(62, 31)" end="(62, 33)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(62, 34)" end="(62, 71)">
                      <TacticTacticseq1IndentedNode start="(62, 34)" end="(62, 71)">
                        <NullNode start="(62, 34)" end="(62, 71)">
                          <OtherNode start="(62, 34)" end="(62, 64)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type ?u.10312&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : j &amp;lt; i&#10;⊢ j &amp;lt; l.length" state_after="α : Type ?u.10312&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : j &amp;lt; i&#10;this : (l.eraseIdx i).length ≤ l.length&#10;⊢ j &amp;lt; l.length" tactic="have := length_eraseIdx_le l i">
                            <AtomNode start="(62, 34)" end="(62, 38)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(62, 39)" end="(62, 64)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(62, 39)" end="(62, 64)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(62, 39)" end="(62, 39)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(62, 39)" end="(62, 39)" kind="hygieneInfo">
                                    <IdentNode start="(62, 39)" end="(62, 39)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(62, 39)" end="(62, 41)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(62, 42)" end="(62, 64)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(62, 42)" end="(62, 60)" leading="" trailing=" " raw_val="length_eraseIdx_le" val="length_eraseIdx_le" full_name="List.length_eraseIdx_le" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                                  <NullNode start="(62, 61)" end="(62, 64)">
                                    <IdentNode start="(62, 61)" end="(62, 62)" leading="" trailing=" " raw_val="l" val="l"/>
                                    <IdentNode start="(62, 63)" end="(62, 64)" leading="" trailing="" raw_val="i" val="i"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(62, 64)" end="(62, 65)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(62, 66)" end="(62, 71)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.10312&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : j &amp;lt; i&#10;this : (l.eraseIdx i).length ≤ l.length&#10;⊢ j &amp;lt; l.length" state_after="no goals" tactic="omega">
                            <AtomNode start="(62, 66)" end="(62, 71)" leading="" trailing="" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                  <AtomNode start="(62, 71)" end="(62, 72)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(62, 73)" end="(66, 8)">
          <AtomNode start="(62, 73)" end="(62, 75)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(62, 76)" end="(66, 8)">
            <AtomNode start="(62, 76)" end="(62, 78)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(63, 3)" end="(66, 8)">
              <TacticTacticseq1IndentedNode start="(63, 3)" end="(66, 8)">
                <NullNode start="(63, 3)" end="(66, 8)">
                  <OtherNode start="(63, 3)" end="(63, 24)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : j &amp;lt; i&#10;⊢ (l.eraseIdx i)[j] = l[j]" state_after="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : j &amp;lt; i&#10;⊢ (if h' : j &amp;lt; i then l[j] else l[j + 1]) = l[j]" tactic="rw [getElem_eraseIdx]">
                    <AtomNode start="(63, 3)" end="(63, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(63, 6)" end="(63, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(63, 6)" end="(63, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(63, 7)" end="(63, 23)">
                        <OtherNode start="(63, 7)" end="(63, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(63, 7)" end="(63, 23)" leading="" trailing="" raw_val="getElem_eraseIdx" val="getElem_eraseIdx" full_name="List.getElem_eraseIdx" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean" def_start="(52, 9)" def_end="(52, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(63, 23)" end="(63, 24)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(64, 3)" end="(64, 43)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : j &amp;lt; i&#10;⊢ (if h' : j &amp;lt; i then l[j] else l[j + 1]) = l[j]" state_after="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : j &amp;lt; i&#10;⊢ ∀ (h_1 : i ≤ j), l[j + 1] = l[j]" tactic="simp only [dite_eq_left_iff, Nat.not_lt]">
                    <AtomNode start="(64, 3)" end="(64, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(64, 8)" end="(64, 12)">
                      <AtomNode start="(64, 8)" end="(64, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(64, 13)" end="(64, 43)">
                      <AtomNode start="(64, 13)" end="(64, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(64, 14)" end="(64, 42)">
                        <OtherNode start="(64, 14)" end="(64, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(64, 14)" end="(64, 30)" leading="" trailing="" raw_val="dite_eq_left_iff" val="dite_eq_left_iff" full_name="dite_eq_left_iff" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(64, 30)" end="(64, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(64, 32)" end="(64, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(64, 32)" end="(64, 42)" leading="" trailing="" raw_val="Nat.not_lt" val="Nat.not_lt" full_name="Nat.not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(64, 42)" end="(64, 43)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(65, 3)" end="(65, 11)" kind="Lean.Parser.Tactic.intro" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : j &amp;lt; i&#10;⊢ ∀ (h_1 : i ≤ j), l[j + 1] = l[j]" state_after="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h'✝ : j &amp;lt; i&#10;h' : i ≤ j&#10;⊢ l[j + 1] = l[j]" tactic="intro h'">
                    <AtomNode start="(65, 3)" end="(65, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(65, 9)" end="(65, 11)">
                      <IdentNode start="(65, 9)" end="(65, 11)" leading="" trailing="&#10;  " raw_val="h'" val="h'"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(66, 3)" end="(66, 8)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h'✝ : j &amp;lt; i&#10;h' : i ≤ j&#10;⊢ l[j + 1] = l[j]" state_after="no goals" tactic="omega">
                    <AtomNode start="(66, 3)" end="(66, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(68, 1)" end="(71, 8)" name="getElem_eraseIdx_of_ge" full_name="List.getElem_eraseIdx_of_ge">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(68, 1)" end="(71, 8)" name="getElem_eraseIdx_of_ge" full_name="List.getElem_eraseIdx_of_ge" _is_private_decl="False">
        <AtomNode start="(68, 1)" end="(68, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(68, 9)" end="(68, 31)">
          <IdentNode start="(68, 9)" end="(68, 31)" leading="" trailing=" " raw_val="getElem_eraseIdx_of_ge" val="getElem_eraseIdx_of_ge"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(68, 32)" end="(69, 86)">
          <NullNode start="(68, 32)" end="(68, 109)">
            <OtherNode start="(68, 32)" end="(68, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(68, 32)" end="(68, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(68, 33)" end="(68, 34)">
                <IdentNode start="(68, 33)" end="(68, 34)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(68, 35)" end="(68, 43)">
                <AtomNode start="(68, 35)" end="(68, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(68, 37)" end="(68, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(68, 37)" end="(68, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(68, 42)" end="(68, 43)">
                    <IdentNode start="(68, 42)" end="(68, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(68, 43)" end="(68, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(68, 45)" end="(68, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(68, 45)" end="(68, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(68, 46)" end="(68, 47)">
                <IdentNode start="(68, 46)" end="(68, 47)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(68, 48)" end="(68, 53)">
                <AtomNode start="(68, 48)" end="(68, 49)" leading="" trailing=" " val=":"/>
                <IdentNode start="(68, 50)" end="(68, 53)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(68, 53)" end="(68, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(68, 55)" end="(68, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(68, 55)" end="(68, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(68, 56)" end="(68, 57)">
                <IdentNode start="(68, 56)" end="(68, 57)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(68, 58)" end="(68, 63)">
                <AtomNode start="(68, 58)" end="(68, 59)" leading="" trailing=" " val=":"/>
                <IdentNode start="(68, 60)" end="(68, 63)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(68, 63)" end="(68, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(68, 65)" end="(68, 96)">
              <AtomNode start="(68, 65)" end="(68, 66)" leading="" trailing="" val="("/>
              <NullNode start="(68, 66)" end="(68, 67)">
                <IdentNode start="(68, 66)" end="(68, 67)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(68, 68)" end="(68, 95)">
                <AtomNode start="(68, 68)" end="(68, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(68, 70)" end="(68, 95)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(68, 70)" end="(68, 71)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(68, 72)" end="(68, 73)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(68, 74)" end="(68, 95)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(68, 74)" end="(68, 88)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(68, 74)" end="(68, 75)" leading="" trailing="" val="("/>
                      <OtherNode start="(68, 75)" end="(68, 87)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(68, 75)" end="(68, 85)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                        <NullNode start="(68, 86)" end="(68, 87)">
                          <IdentNode start="(68, 86)" end="(68, 87)" leading="" trailing="" raw_val="i" val="i"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(68, 87)" end="(68, 88)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(68, 88)" end="(68, 89)" leading="" trailing="" val="."/>
                    <IdentNode start="(68, 89)" end="(68, 95)" leading="" trailing="" raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(68, 95)" end="(68, 96)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(68, 97)" end="(68, 109)">
              <AtomNode start="(68, 97)" end="(68, 98)" leading="" trailing="" val="("/>
              <NullNode start="(68, 98)" end="(68, 100)">
                <IdentNode start="(68, 98)" end="(68, 100)" leading="" trailing=" " raw_val="h'" val="h'"/>
              </NullNode>
              <NullNode start="(68, 101)" end="(68, 108)">
                <AtomNode start="(68, 101)" end="(68, 102)" leading="" trailing=" " val=":"/>
                <OtherNode start="(68, 103)" end="(68, 108)" kind="«term_≤_»">
                  <IdentNode start="(68, 103)" end="(68, 104)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(68, 105)" end="(68, 106)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(68, 107)" end="(68, 108)" leading="" trailing="" raw_val="j" val="j"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(68, 108)" end="(68, 109)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(68, 110)" end="(69, 86)">
            <AtomNode start="(68, 110)" end="(68, 111)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(69, 5)" end="(69, 86)" kind="«term_=_»">
              <OtherNode start="(69, 5)" end="(69, 22)" kind="«term__[_]»">
                <OtherNode start="(69, 5)" end="(69, 19)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(69, 5)" end="(69, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(69, 6)" end="(69, 18)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(69, 6)" end="(69, 16)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                    <NullNode start="(69, 17)" end="(69, 18)">
                      <IdentNode start="(69, 17)" end="(69, 18)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(69, 18)" end="(69, 19)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(69, 19)" end="(69, 20)" leading="" trailing="" val="["/>
                <IdentNode start="(69, 20)" end="(69, 21)" leading="" trailing="" raw_val="j" val="j"/>
                <AtomNode start="(69, 21)" end="(69, 22)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(69, 23)" end="(69, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(69, 25)" end="(69, 86)" kind="«term__[_]'_»">
                <IdentNode start="(69, 25)" end="(69, 26)" leading="" trailing="" raw_val="l" val="l"/>
                <AtomNode start="(69, 26)" end="(69, 27)" leading="" trailing="" val="["/>
                <OtherNode start="(69, 27)" end="(69, 32)" kind="«term_+_»">
                  <IdentNode start="(69, 27)" end="(69, 28)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(69, 29)" end="(69, 30)" leading="" trailing=" " val="+"/>
                  <OtherNode start="(69, 31)" end="(69, 32)" kind="num">
                    <AtomNode start="(69, 31)" end="(69, 32)" leading="" trailing="" val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(69, 32)" end="(69, 34)" leading="" trailing="" val="]'"/>
                <OtherNode start="(69, 34)" end="(69, 86)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(69, 34)" end="(69, 35)" leading="" trailing="" val="("/>
                  <TermBytacticNode start="(69, 35)" end="(69, 85)">
                    <AtomNode start="(69, 35)" end="(69, 37)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(69, 38)" end="(69, 85)">
                      <TacticTacticseq1IndentedNode start="(69, 38)" end="(69, 85)">
                        <NullNode start="(69, 38)" end="(69, 85)">
                          <OtherNode start="(69, 38)" end="(69, 63)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type ?u.11125&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : i ≤ j&#10;⊢ j + 1 &amp;lt; l.length" state_after="α : Type ?u.11125&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; if i &amp;lt; l.length then l.length - 1 else l.length&#10;h' : i ≤ j&#10;⊢ j + 1 &amp;lt; l.length" tactic="rw [length_eraseIdx] at h">
                            <AtomNode start="(69, 38)" end="(69, 40)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(69, 41)" end="(69, 58)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(69, 41)" end="(69, 42)" leading="" trailing="" val="["/>
                              <NullNode start="(69, 42)" end="(69, 57)">
                                <OtherNode start="(69, 42)" end="(69, 57)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(69, 42)" end="(69, 57)" leading="" trailing="" raw_val="length_eraseIdx" val="length_eraseIdx" full_name="List.length_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(69, 57)" end="(69, 58)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(69, 59)" end="(69, 63)">
                              <OtherNode start="(69, 59)" end="(69, 63)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(69, 59)" end="(69, 61)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(69, 62)" end="(69, 63)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(69, 62)" end="(69, 63)">
                                    <IdentNode start="(69, 62)" end="(69, 63)" leading="" trailing="" raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(69, 63)" end="(69, 64)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(69, 65)" end="(69, 85)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type ?u.11125&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; if i &amp;lt; l.length then l.length - 1 else l.length&#10;h' : i ≤ j&#10;⊢ j + 1 &amp;lt; l.length" state_after="no goals" tactic="split at h &amp;lt;;&amp;gt; omega">
                            <OtherNode start="(69, 65)" end="(69, 75)" kind="Lean.Parser.Tactic.split">
                              <AtomNode start="(69, 65)" end="(69, 70)" leading="" trailing=" " val="split"/>
                              <NullNode/>
                              <NullNode start="(69, 71)" end="(69, 75)">
                                <OtherNode start="(69, 71)" end="(69, 75)" kind="Lean.Parser.Tactic.location">
                                  <AtomNode start="(69, 71)" end="(69, 73)" leading="" trailing=" " val="at"/>
                                  <OtherNode start="(69, 74)" end="(69, 75)" kind="Lean.Parser.Tactic.locationHyp">
                                    <NullNode start="(69, 74)" end="(69, 75)">
                                      <IdentNode start="(69, 74)" end="(69, 75)" leading="" trailing=" " raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(69, 76)" end="(69, 79)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(69, 80)" end="(69, 85)" kind="Lean.Parser.Tactic.omega">
                              <AtomNode start="(69, 80)" end="(69, 85)" leading="" trailing="" val="omega"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                  <AtomNode start="(69, 85)" end="(69, 86)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(69, 87)" end="(71, 8)">
          <AtomNode start="(69, 87)" end="(69, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(69, 90)" end="(71, 8)">
            <AtomNode start="(69, 90)" end="(69, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(70, 3)" end="(71, 8)">
              <TacticTacticseq1IndentedNode start="(70, 3)" end="(71, 8)">
                <NullNode start="(70, 3)" end="(71, 8)">
                  <OtherNode start="(70, 3)" end="(70, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : i ≤ j&#10;⊢ (l.eraseIdx i)[j] = l[j + 1]" state_after="case hnc&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : i ≤ j&#10;⊢ ¬j &amp;lt; i" tactic="rw [getElem_eraseIdx, dif_neg]">
                    <AtomNode start="(70, 3)" end="(70, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(70, 6)" end="(70, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(70, 6)" end="(70, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(70, 7)" end="(70, 32)">
                        <OtherNode start="(70, 7)" end="(70, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(70, 7)" end="(70, 23)" leading="" trailing="" raw_val="getElem_eraseIdx" val="getElem_eraseIdx" full_name="List.getElem_eraseIdx" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean" def_start="(52, 9)" def_end="(52, 25)"/>
                        </OtherNode>
                        <AtomNode start="(70, 23)" end="(70, 24)" leading="" trailing=" " val=","/>
                        <OtherNode start="(70, 25)" end="(70, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(70, 25)" end="(70, 32)" leading="" trailing="" raw_val="dif_neg" val="dif_neg" full_name="dif_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(70, 32)" end="(70, 33)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(71, 3)" end="(71, 8)" kind="Lean.Parser.Tactic.omega" state_before="case hnc&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;h : j &amp;lt; (l.eraseIdx i).length&#10;h' : i ≤ j&#10;⊢ ¬j &amp;lt; i" state_after="no goals" tactic="omega">
                    <AtomNode start="(71, 3)" end="(71, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(73, 1)" end="(76, 26)" name="eraseIdx_eq_dropLast" full_name="List.eraseIdx_eq_dropLast">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(73, 1)" end="(76, 26)" name="eraseIdx_eq_dropLast" full_name="List.eraseIdx_eq_dropLast" _is_private_decl="False">
        <AtomNode start="(73, 1)" end="(73, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(73, 9)" end="(73, 29)">
          <IdentNode start="(73, 9)" end="(73, 29)" leading="" trailing=" " raw_val="eraseIdx_eq_dropLast" val="eraseIdx_eq_dropLast"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(73, 30)" end="(74, 30)">
          <NullNode start="(73, 30)" end="(73, 75)">
            <OtherNode start="(73, 30)" end="(73, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(73, 30)" end="(73, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(73, 31)" end="(73, 32)">
                <IdentNode start="(73, 31)" end="(73, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(73, 33)" end="(73, 41)">
                <AtomNode start="(73, 33)" end="(73, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(73, 35)" end="(73, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(73, 35)" end="(73, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(73, 40)" end="(73, 41)">
                    <IdentNode start="(73, 40)" end="(73, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(73, 41)" end="(73, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(73, 43)" end="(73, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(73, 43)" end="(73, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(73, 44)" end="(73, 45)">
                <IdentNode start="(73, 44)" end="(73, 45)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(73, 46)" end="(73, 51)">
                <AtomNode start="(73, 46)" end="(73, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(73, 48)" end="(73, 51)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(73, 51)" end="(73, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(73, 53)" end="(73, 75)">
              <AtomNode start="(73, 53)" end="(73, 54)" leading="" trailing="" val="("/>
              <NullNode start="(73, 54)" end="(73, 55)">
                <IdentNode start="(73, 54)" end="(73, 55)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(73, 56)" end="(73, 74)">
                <AtomNode start="(73, 56)" end="(73, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(73, 58)" end="(73, 74)" kind="«term_=_»">
                  <OtherNode start="(73, 58)" end="(73, 63)" kind="«term_+_»">
                    <IdentNode start="(73, 58)" end="(73, 59)" leading="" trailing=" " raw_val="i" val="i"/>
                    <AtomNode start="(73, 60)" end="(73, 61)" leading="" trailing=" " val="+"/>
                    <OtherNode start="(73, 62)" end="(73, 63)" kind="num">
                      <AtomNode start="(73, 62)" end="(73, 63)" leading="" trailing=" " val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(73, 64)" end="(73, 65)" leading="" trailing=" " val="="/>
                  <IdentNode start="(73, 66)" end="(73, 74)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(73, 74)" end="(73, 75)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(73, 76)" end="(74, 30)">
            <AtomNode start="(73, 76)" end="(73, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(74, 5)" end="(74, 30)" kind="«term_=_»">
              <OtherNode start="(74, 5)" end="(74, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(74, 5)" end="(74, 15)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                <NullNode start="(74, 16)" end="(74, 17)">
                  <IdentNode start="(74, 16)" end="(74, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(74, 18)" end="(74, 19)" leading="" trailing=" " val="="/>
              <IdentNode start="(74, 20)" end="(74, 30)" leading="" trailing=" " raw_val="l.dropLast" val="l.dropLast"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(74, 31)" end="(76, 26)">
          <AtomNode start="(74, 31)" end="(74, 33)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(74, 34)" end="(76, 26)">
            <AtomNode start="(74, 34)" end="(74, 36)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(75, 3)" end="(76, 26)">
              <TacticTacticseq1IndentedNode start="(75, 3)" end="(76, 26)">
                <NullNode start="(75, 3)" end="(76, 26)">
                  <OtherNode start="(75, 3)" end="(75, 39)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 = l.length&#10;⊢ l.eraseIdx i = l.dropLast" state_after="α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 = l.length&#10;⊢ take i l = l.dropLast" tactic="simp [eraseIdx_eq_take_drop_succ, h]">
                    <AtomNode start="(75, 3)" end="(75, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(75, 8)" end="(75, 39)">
                      <AtomNode start="(75, 8)" end="(75, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(75, 9)" end="(75, 38)">
                        <OtherNode start="(75, 9)" end="(75, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(75, 9)" end="(75, 35)" leading="" trailing="" raw_val="eraseIdx_eq_take_drop_succ" val="eraseIdx_eq_take_drop_succ" full_name="List.eraseIdx_eq_take_drop_succ" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                        </OtherNode>
                        <AtomNode start="(75, 35)" end="(75, 36)" leading="" trailing=" " val=","/>
                        <OtherNode start="(75, 37)" end="(75, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(75, 37)" end="(75, 38)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(75, 38)" end="(75, 39)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(76, 3)" end="(76, 26)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 = l.length&#10;⊢ take i l = l.dropLast" state_after="no goals" tactic="rw [take_eq_dropLast h]">
                    <AtomNode start="(76, 3)" end="(76, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(76, 6)" end="(76, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(76, 6)" end="(76, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(76, 7)" end="(76, 25)">
                        <OtherNode start="(76, 7)" end="(76, 25)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(76, 7)" end="(76, 25)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(76, 7)" end="(76, 23)" leading="" trailing=" " raw_val="take_eq_dropLast" val="take_eq_dropLast" full_name="List.take_eq_dropLast" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                            <NullNode start="(76, 24)" end="(76, 25)">
                              <IdentNode start="(76, 24)" end="(76, 25)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(76, 25)" end="(76, 26)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(78, 1)" end="(86, 12)" name="eraseIdx_set_eq" full_name="List.eraseIdx_set_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(78, 1)" end="(86, 12)" name="eraseIdx_set_eq" full_name="List.eraseIdx_set_eq" _is_private_decl="False">
        <AtomNode start="(78, 1)" end="(78, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(78, 9)" end="(78, 24)">
          <IdentNode start="(78, 9)" end="(78, 24)" leading="" trailing=" " raw_val="eraseIdx_set_eq" val="eraseIdx_set_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(78, 25)" end="(79, 42)">
          <NullNode start="(78, 25)" end="(78, 55)">
            <OtherNode start="(78, 25)" end="(78, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(78, 25)" end="(78, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(78, 26)" end="(78, 27)">
                <IdentNode start="(78, 26)" end="(78, 27)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(78, 28)" end="(78, 36)">
                <AtomNode start="(78, 28)" end="(78, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(78, 30)" end="(78, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(78, 30)" end="(78, 34)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(78, 35)" end="(78, 36)">
                    <IdentNode start="(78, 35)" end="(78, 36)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(78, 36)" end="(78, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(78, 38)" end="(78, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(78, 38)" end="(78, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(78, 39)" end="(78, 40)">
                <IdentNode start="(78, 39)" end="(78, 40)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(78, 41)" end="(78, 46)">
                <AtomNode start="(78, 41)" end="(78, 42)" leading="" trailing=" " val=":"/>
                <IdentNode start="(78, 43)" end="(78, 46)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(78, 46)" end="(78, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(78, 48)" end="(78, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(78, 48)" end="(78, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(78, 49)" end="(78, 50)">
                <IdentNode start="(78, 49)" end="(78, 50)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(78, 51)" end="(78, 54)">
                <AtomNode start="(78, 51)" end="(78, 52)" leading="" trailing=" " val=":"/>
                <IdentNode start="(78, 53)" end="(78, 54)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(78, 54)" end="(78, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(78, 56)" end="(79, 42)">
            <AtomNode start="(78, 56)" end="(78, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(79, 5)" end="(79, 42)" kind="«term_=_»">
              <OtherNode start="(79, 5)" end="(79, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(79, 5)" end="(79, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(79, 5)" end="(79, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(79, 5)" end="(79, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(79, 6)" end="(79, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(79, 6)" end="(79, 11)" leading="" trailing=" " raw_val="l.set" val="l.set"/>
                      <NullNode start="(79, 12)" end="(79, 15)">
                        <IdentNode start="(79, 12)" end="(79, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(79, 14)" end="(79, 15)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(79, 15)" end="(79, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(79, 16)" end="(79, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(79, 17)" end="(79, 25)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(79, 26)" end="(79, 27)">
                  <IdentNode start="(79, 26)" end="(79, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(79, 28)" end="(79, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(79, 30)" end="(79, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(79, 30)" end="(79, 40)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                <NullNode start="(79, 41)" end="(79, 42)">
                  <IdentNode start="(79, 41)" end="(79, 42)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(79, 43)" end="(86, 12)">
          <AtomNode start="(79, 43)" end="(79, 45)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(79, 46)" end="(86, 12)">
            <AtomNode start="(79, 46)" end="(79, 48)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(80, 3)" end="(86, 12)">
              <TacticTacticseq1IndentedNode start="(80, 3)" end="(86, 12)">
                <NullNode start="(80, 3)" end="(86, 12)">
                  <OtherNode start="(80, 3)" end="(80, 20)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ (l.set i a).eraseIdx i = l.eraseIdx i" state_after="case hl&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ ((l.set i a).eraseIdx i).length = (l.eraseIdx i).length&#10;&#10;case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx i).length) (h₂ : i_1 &amp;lt; (l.eraseIdx i).length),&#10;    ((l.set i a).eraseIdx i)[i_1] = (l.eraseIdx i)[i_1]" tactic="apply ext_getElem">
                    <AtomNode start="(80, 3)" end="(80, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(80, 9)" end="(80, 20)" leading="" trailing="&#10;  " raw_val="ext_getElem" val="ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(81, 3)" end="(81, 27)" kind="Lean.cdot" state_before="case hl&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ ((l.set i a).eraseIdx i).length = (l.eraseIdx i).length&#10;&#10;case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx i).length) (h₂ : i_1 &amp;lt; (l.eraseIdx i).length),&#10;    ((l.set i a).eraseIdx i)[i_1] = (l.eraseIdx i)[i_1]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx i).length) (h₂ : i_1 &amp;lt; (l.eraseIdx i).length),&#10;    ((l.set i a).eraseIdx i)[i_1] = (l.eraseIdx i)[i_1]" tactic="· simp [length_eraseIdx]">
                    <OtherNode start="(81, 3)" end="(81, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(81, 3)" end="(81, 4)" kind="patternIgnore">
                        <OtherNode start="(81, 3)" end="(81, 4)" kind="token.«· »">
                          <AtomNode start="(81, 3)" end="(81, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(81, 5)" end="(81, 27)">
                      <TacticTacticseq1IndentedNode start="(81, 5)" end="(81, 27)">
                        <NullNode start="(81, 5)" end="(81, 27)">
                          <OtherNode start="(81, 5)" end="(81, 27)" kind="Lean.Parser.Tactic.simp" state_before="case hl&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ ((l.set i a).eraseIdx i).length = (l.eraseIdx i).length" state_after="no goals" tactic="simp [length_eraseIdx]">
                            <AtomNode start="(81, 5)" end="(81, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(81, 10)" end="(81, 27)">
                              <AtomNode start="(81, 10)" end="(81, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(81, 11)" end="(81, 26)">
                                <OtherNode start="(81, 11)" end="(81, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(81, 11)" end="(81, 26)" leading="" trailing="" raw_val="length_eraseIdx" val="length_eraseIdx" full_name="List.length_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(81, 26)" end="(81, 27)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(82, 3)" end="(86, 12)" kind="Lean.cdot" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx i).length) (h₂ : i_1 &amp;lt; (l.eraseIdx i).length),&#10;    ((l.set i a).eraseIdx i)[i_1] = (l.eraseIdx i)[i_1]" state_after="no goals" tactic="· intro n h₁ h₂&#10;  rw [getElem_eraseIdx, getElem_eraseIdx]&#10;  split &amp;lt;;&amp;gt;&#10;  · rw [getElem_set_ne]&#10;    omega">
                    <OtherNode start="(82, 3)" end="(82, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(82, 3)" end="(82, 4)" kind="patternIgnore">
                        <OtherNode start="(82, 3)" end="(82, 4)" kind="token.«· »">
                          <AtomNode start="(82, 3)" end="(82, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(82, 5)" end="(86, 12)">
                      <TacticTacticseq1IndentedNode start="(82, 5)" end="(86, 12)">
                        <NullNode start="(82, 5)" end="(86, 12)">
                          <OtherNode start="(82, 5)" end="(82, 18)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx i).length) (h₂ : i_1 &amp;lt; (l.eraseIdx i).length),&#10;    ((l.set i a).eraseIdx i)[i_1] = (l.eraseIdx i)[i_1]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.set i a).eraseIdx i).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;⊢ ((l.set i a).eraseIdx i)[n] = (l.eraseIdx i)[n]" tactic="intro n h₁ h₂">
                            <AtomNode start="(82, 5)" end="(82, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(82, 11)" end="(82, 18)">
                              <IdentNode start="(82, 11)" end="(82, 12)" leading="" trailing=" " raw_val="n" val="n"/>
                              <IdentNode start="(82, 13)" end="(82, 15)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                              <IdentNode start="(82, 16)" end="(82, 18)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(83, 5)" end="(83, 44)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.set i a).eraseIdx i).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;⊢ ((l.set i a).eraseIdx i)[n] = (l.eraseIdx i)[n]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.set i a).eraseIdx i).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;⊢ (if h' : n &amp;lt; i then (l.set i a)[n] else (l.set i a)[n + 1]) = if h' : n &amp;lt; i then l[n] else l[n + 1]" tactic="rw [getElem_eraseIdx, getElem_eraseIdx]">
                            <AtomNode start="(83, 5)" end="(83, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(83, 8)" end="(83, 44)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(83, 8)" end="(83, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(83, 9)" end="(83, 43)">
                                <OtherNode start="(83, 9)" end="(83, 25)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(83, 9)" end="(83, 25)" leading="" trailing="" raw_val="getElem_eraseIdx" val="getElem_eraseIdx" full_name="List.getElem_eraseIdx" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean" def_start="(52, 9)" def_end="(52, 25)"/>
                                </OtherNode>
                                <AtomNode start="(83, 25)" end="(83, 26)" leading="" trailing=" " val=","/>
                                <OtherNode start="(83, 27)" end="(83, 43)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(83, 27)" end="(83, 43)" leading="" trailing="" raw_val="getElem_eraseIdx" val="getElem_eraseIdx" full_name="List.getElem_eraseIdx" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean" def_start="(52, 9)" def_end="(52, 25)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(83, 43)" end="(83, 44)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(84, 5)" end="(86, 12)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.set i a).eraseIdx i).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;⊢ (if h' : n &amp;lt; i then (l.set i a)[n] else (l.set i a)[n + 1]) = if h' : n &amp;lt; i then l[n] else l[n + 1]" state_after="no goals" tactic="split &amp;lt;;&amp;gt;&#10;· rw [getElem_set_ne]&#10;  omega">
                            <OtherNode start="(84, 5)" end="(84, 10)" kind="Lean.Parser.Tactic.split">
                              <AtomNode start="(84, 5)" end="(84, 10)" leading="" trailing=" " val="split"/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(84, 11)" end="(84, 14)" leading="" trailing="&#10;    " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(85, 5)" end="(86, 12)" kind="Lean.cdot">
                              <OtherNode start="(85, 5)" end="(85, 6)" kind="Lean.cdotTk">
                                <OtherNode start="(85, 5)" end="(85, 6)" kind="patternIgnore">
                                  <OtherNode start="(85, 5)" end="(85, 6)" kind="token.«· »">
                                    <AtomNode start="(85, 5)" end="(85, 6)" leading="" trailing=" " val="·"/>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                              <TacticTacticseqNode start="(85, 7)" end="(86, 12)">
                                <TacticTacticseq1IndentedNode start="(85, 7)" end="(86, 12)">
                                  <NullNode start="(85, 7)" end="(86, 12)">
                                    <OtherNode start="(85, 7)" end="(85, 26)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.set i a).eraseIdx i).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝ : ¬n &amp;lt; i&#10;⊢ (l.set i a)[n + 1] = l[n + 1]" state_after="case h.isFalse.h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.set i a).eraseIdx i).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝ : ¬n &amp;lt; i&#10;⊢ i ≠ n + 1" tactic="rw [getElem_set_ne]">
                                      <AtomNode start="(85, 7)" end="(85, 9)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(85, 10)" end="(85, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(85, 10)" end="(85, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(85, 11)" end="(85, 25)">
                                          <OtherNode start="(85, 11)" end="(85, 25)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(85, 11)" end="(85, 25)" leading="" trailing="" raw_val="getElem_set_ne" val="getElem_set_ne" full_name="List.getElem_set_ne" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(85, 25)" end="(85, 26)" leading="" trailing="&#10;      " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(86, 7)" end="(86, 12)" kind="Lean.Parser.Tactic.omega" state_before="case h.isFalse.h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.set i a).eraseIdx i).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝ : ¬n &amp;lt; i&#10;⊢ i ≠ n + 1" state_after="no goals" tactic="omega">
                                      <AtomNode start="(86, 7)" end="(86, 12)" leading="" trailing="&#10;&#10;" val="omega"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(88, 1)" end="(108, 17)" name="eraseIdx_set_lt" full_name="List.eraseIdx_set_lt">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(88, 1)" end="(108, 17)" name="eraseIdx_set_lt" full_name="List.eraseIdx_set_lt" _is_private_decl="False">
        <AtomNode start="(88, 1)" end="(88, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(88, 9)" end="(88, 24)">
          <IdentNode start="(88, 9)" end="(88, 24)" leading="" trailing=" " raw_val="eraseIdx_set_lt" val="eraseIdx_set_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(88, 25)" end="(89, 58)">
          <NullNode start="(88, 25)" end="(88, 77)">
            <OtherNode start="(88, 25)" end="(88, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(88, 25)" end="(88, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(88, 26)" end="(88, 27)">
                <IdentNode start="(88, 26)" end="(88, 27)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(88, 28)" end="(88, 36)">
                <AtomNode start="(88, 28)" end="(88, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 30)" end="(88, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(88, 30)" end="(88, 34)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(88, 35)" end="(88, 36)">
                    <IdentNode start="(88, 35)" end="(88, 36)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(88, 36)" end="(88, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(88, 38)" end="(88, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(88, 38)" end="(88, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(88, 39)" end="(88, 40)">
                <IdentNode start="(88, 39)" end="(88, 40)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(88, 41)" end="(88, 46)">
                <AtomNode start="(88, 41)" end="(88, 42)" leading="" trailing=" " val=":"/>
                <IdentNode start="(88, 43)" end="(88, 46)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(88, 46)" end="(88, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(88, 48)" end="(88, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(88, 48)" end="(88, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(88, 49)" end="(88, 50)">
                <IdentNode start="(88, 49)" end="(88, 50)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(88, 51)" end="(88, 56)">
                <AtomNode start="(88, 51)" end="(88, 52)" leading="" trailing=" " val=":"/>
                <IdentNode start="(88, 53)" end="(88, 56)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(88, 56)" end="(88, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(88, 58)" end="(88, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(88, 58)" end="(88, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(88, 59)" end="(88, 60)">
                <IdentNode start="(88, 59)" end="(88, 60)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(88, 61)" end="(88, 64)">
                <AtomNode start="(88, 61)" end="(88, 62)" leading="" trailing=" " val=":"/>
                <IdentNode start="(88, 63)" end="(88, 64)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(88, 64)" end="(88, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(88, 66)" end="(88, 77)">
              <AtomNode start="(88, 66)" end="(88, 67)" leading="" trailing="" val="("/>
              <NullNode start="(88, 67)" end="(88, 68)">
                <IdentNode start="(88, 67)" end="(88, 68)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(88, 69)" end="(88, 76)">
                <AtomNode start="(88, 69)" end="(88, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 71)" end="(88, 76)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(88, 71)" end="(88, 72)" leading="" trailing=" " raw_val="j" val="j"/>
                  <AtomNode start="(88, 73)" end="(88, 74)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(88, 75)" end="(88, 76)" leading="" trailing="" raw_val="i" val="i"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(88, 76)" end="(88, 77)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(88, 78)" end="(89, 58)">
            <AtomNode start="(88, 78)" end="(88, 79)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(89, 5)" end="(89, 58)" kind="«term_=_»">
              <OtherNode start="(89, 5)" end="(89, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(89, 5)" end="(89, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(89, 5)" end="(89, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(89, 5)" end="(89, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(89, 6)" end="(89, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(89, 6)" end="(89, 11)" leading="" trailing=" " raw_val="l.set" val="l.set"/>
                      <NullNode start="(89, 12)" end="(89, 15)">
                        <IdentNode start="(89, 12)" end="(89, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(89, 14)" end="(89, 15)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(89, 15)" end="(89, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(89, 16)" end="(89, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(89, 17)" end="(89, 25)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(89, 26)" end="(89, 27)">
                  <IdentNode start="(89, 26)" end="(89, 27)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(89, 28)" end="(89, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(89, 30)" end="(89, 58)" kind="Lean.Parser.Term.app">
                <OtherNode start="(89, 30)" end="(89, 48)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(89, 30)" end="(89, 44)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(89, 30)" end="(89, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(89, 31)" end="(89, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(89, 31)" end="(89, 41)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                      <NullNode start="(89, 42)" end="(89, 43)">
                        <IdentNode start="(89, 42)" end="(89, 43)" leading="" trailing="" raw_val="j" val="j"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(89, 43)" end="(89, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(89, 44)" end="(89, 45)" leading="" trailing="" val="."/>
                  <IdentNode start="(89, 45)" end="(89, 48)" leading="" trailing=" " raw_val="set" val="set" full_name="List.set" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(89, 49)" end="(89, 58)">
                  <OtherNode start="(89, 49)" end="(89, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(89, 49)" end="(89, 50)" leading="" trailing="" val="("/>
                    <OtherNode start="(89, 50)" end="(89, 55)" kind="«term_-_»">
                      <IdentNode start="(89, 50)" end="(89, 51)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(89, 52)" end="(89, 53)" leading="" trailing=" " val="-"/>
                      <OtherNode start="(89, 54)" end="(89, 55)" kind="num">
                        <AtomNode start="(89, 54)" end="(89, 55)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(89, 55)" end="(89, 56)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(89, 57)" end="(89, 58)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(89, 59)" end="(108, 17)">
          <AtomNode start="(89, 59)" end="(89, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(89, 62)" end="(108, 17)">
            <AtomNode start="(89, 62)" end="(89, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(90, 3)" end="(108, 17)">
              <TacticTacticseq1IndentedNode start="(90, 3)" end="(108, 17)">
                <NullNode start="(90, 3)" end="(108, 17)">
                  <OtherNode start="(90, 3)" end="(90, 20)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ (l.set i a).eraseIdx j = (l.eraseIdx j).set (i - 1) a" state_after="case hl&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ ((l.set i a).eraseIdx j).length = ((l.eraseIdx j).set (i - 1) a).length&#10;&#10;case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx j).length) (h₂ : i_1 &amp;lt; ((l.eraseIdx j).set (i - 1) a).length),&#10;    ((l.set i a).eraseIdx j)[i_1] = ((l.eraseIdx j).set (i - 1) a)[i_1]" tactic="apply ext_getElem">
                    <AtomNode start="(90, 3)" end="(90, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(90, 9)" end="(90, 20)" leading="" trailing="&#10;  " raw_val="ext_getElem" val="ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(91, 3)" end="(91, 27)" kind="Lean.cdot" state_before="case hl&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ ((l.set i a).eraseIdx j).length = ((l.eraseIdx j).set (i - 1) a).length&#10;&#10;case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx j).length) (h₂ : i_1 &amp;lt; ((l.eraseIdx j).set (i - 1) a).length),&#10;    ((l.set i a).eraseIdx j)[i_1] = ((l.eraseIdx j).set (i - 1) a)[i_1]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx j).length) (h₂ : i_1 &amp;lt; ((l.eraseIdx j).set (i - 1) a).length),&#10;    ((l.set i a).eraseIdx j)[i_1] = ((l.eraseIdx j).set (i - 1) a)[i_1]" tactic="· simp [length_eraseIdx]">
                    <OtherNode start="(91, 3)" end="(91, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(91, 3)" end="(91, 4)" kind="patternIgnore">
                        <OtherNode start="(91, 3)" end="(91, 4)" kind="token.«· »">
                          <AtomNode start="(91, 3)" end="(91, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(91, 5)" end="(91, 27)">
                      <TacticTacticseq1IndentedNode start="(91, 5)" end="(91, 27)">
                        <NullNode start="(91, 5)" end="(91, 27)">
                          <OtherNode start="(91, 5)" end="(91, 27)" kind="Lean.Parser.Tactic.simp" state_before="case hl&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ ((l.set i a).eraseIdx j).length = ((l.eraseIdx j).set (i - 1) a).length" state_after="no goals" tactic="simp [length_eraseIdx]">
                            <AtomNode start="(91, 5)" end="(91, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(91, 10)" end="(91, 27)">
                              <AtomNode start="(91, 10)" end="(91, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(91, 11)" end="(91, 26)">
                                <OtherNode start="(91, 11)" end="(91, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(91, 11)" end="(91, 26)" leading="" trailing="" raw_val="length_eraseIdx" val="length_eraseIdx" full_name="List.length_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(91, 26)" end="(91, 27)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(92, 3)" end="(108, 17)" kind="Lean.cdot" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx j).length) (h₂ : i_1 &amp;lt; ((l.eraseIdx j).set (i - 1) a).length),&#10;    ((l.set i a).eraseIdx j)[i_1] = ((l.eraseIdx j).set (i - 1) a)[i_1]" state_after="no goals" tactic="· intro n h₁ h₂&#10;  simp only [length_eraseIdx, length_set] at h₁&#10;  simp only [getElem_eraseIdx, getElem_set]&#10;  split&#10;  · split&#10;    · split&#10;      · rfl&#10;      · omega&#10;    · split&#10;      · omega&#10;      · rfl&#10;  · split&#10;    · split&#10;      · rfl&#10;      · omega&#10;    · have t : i - 1 ≠ n := by omega&#10;      simp [t]">
                    <OtherNode start="(92, 3)" end="(92, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(92, 3)" end="(92, 4)" kind="patternIgnore">
                        <OtherNode start="(92, 3)" end="(92, 4)" kind="token.«· »">
                          <AtomNode start="(92, 3)" end="(92, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(92, 5)" end="(108, 17)">
                      <TacticTacticseq1IndentedNode start="(92, 5)" end="(108, 17)">
                        <NullNode start="(92, 5)" end="(108, 17)">
                          <OtherNode start="(92, 5)" end="(92, 18)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx j).length) (h₂ : i_1 &amp;lt; ((l.eraseIdx j).set (i - 1) a).length),&#10;    ((l.set i a).eraseIdx j)[i_1] = ((l.eraseIdx j).set (i - 1) a)[i_1]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;⊢ ((l.set i a).eraseIdx j)[n] = ((l.eraseIdx j).set (i - 1) a)[n]" tactic="intro n h₁ h₂">
                            <AtomNode start="(92, 5)" end="(92, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(92, 11)" end="(92, 18)">
                              <IdentNode start="(92, 11)" end="(92, 12)" leading="" trailing=" " raw_val="n" val="n"/>
                              <IdentNode start="(92, 13)" end="(92, 15)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                              <IdentNode start="(92, 16)" end="(92, 18)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(93, 5)" end="(93, 50)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;⊢ ((l.set i a).eraseIdx j)[n] = ((l.eraseIdx j).set (i - 1) a)[n]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;⊢ ((l.set i a).eraseIdx j)[n] = ((l.eraseIdx j).set (i - 1) a)[n]" tactic="simp only [length_eraseIdx, length_set] at h₁">
                            <AtomNode start="(93, 5)" end="(93, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(93, 10)" end="(93, 14)">
                              <AtomNode start="(93, 10)" end="(93, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(93, 15)" end="(93, 44)">
                              <AtomNode start="(93, 15)" end="(93, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(93, 16)" end="(93, 43)">
                                <OtherNode start="(93, 16)" end="(93, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(93, 16)" end="(93, 31)" leading="" trailing="" raw_val="length_eraseIdx" val="length_eraseIdx" full_name="List.length_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                                </OtherNode>
                                <AtomNode start="(93, 31)" end="(93, 32)" leading="" trailing=" " val=","/>
                                <OtherNode start="(93, 33)" end="(93, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(93, 33)" end="(93, 43)" leading="" trailing="" raw_val="length_set" val="length_set" full_name="List.length_set" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(93, 43)" end="(93, 44)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(93, 45)" end="(93, 50)">
                              <OtherNode start="(93, 45)" end="(93, 50)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(93, 45)" end="(93, 47)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(93, 48)" end="(93, 50)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(93, 48)" end="(93, 50)">
                                    <IdentNode start="(93, 48)" end="(93, 50)" leading="" trailing="&#10;    " raw_val="h₁" val="h₁"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(94, 5)" end="(94, 46)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;⊢ ((l.set i a).eraseIdx j)[n] = ((l.eraseIdx j).set (i - 1) a)[n]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;⊢ (if h : n &amp;lt; j then if i = n then a else l[n] else if i = n + 1 then a else l[n + 1]) =&#10;    if i - 1 = n then a else if h' : n &amp;lt; j then l[n] else l[n + 1]" tactic="simp only [getElem_eraseIdx, getElem_set]">
                            <AtomNode start="(94, 5)" end="(94, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(94, 10)" end="(94, 14)">
                              <AtomNode start="(94, 10)" end="(94, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(94, 15)" end="(94, 46)">
                              <AtomNode start="(94, 15)" end="(94, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(94, 16)" end="(94, 45)">
                                <OtherNode start="(94, 16)" end="(94, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(94, 16)" end="(94, 32)" leading="" trailing="" raw_val="getElem_eraseIdx" val="getElem_eraseIdx" full_name="List.getElem_eraseIdx" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean" def_start="(52, 9)" def_end="(52, 25)"/>
                                </OtherNode>
                                <AtomNode start="(94, 32)" end="(94, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(94, 34)" end="(94, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(94, 34)" end="(94, 45)" leading="" trailing="" raw_val="getElem_set" val="getElem_set" full_name="List.getElem_set" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(94, 45)" end="(94, 46)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(95, 5)" end="(95, 10)" kind="Lean.Parser.Tactic.split" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;⊢ (if h : n &amp;lt; j then if i = n then a else l[n] else if i = n + 1 then a else l[n + 1]) =&#10;    if i - 1 = n then a else if h' : n &amp;lt; j then l[n] else l[n + 1]" state_after="case h.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : n &amp;lt; j&#10;⊢ (if i = n then a else l[n]) = if i - 1 = n then a else l[n]&#10;&#10;case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : ¬n &amp;lt; j&#10;⊢ (if i = n + 1 then a else l[n + 1]) = if i - 1 = n then a else l[n + 1]" tactic="split">
                            <AtomNode start="(95, 5)" end="(95, 10)" leading="" trailing="&#10;    " val="split"/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(96, 5)" end="(102, 14)" kind="Lean.cdot" state_before="case h.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : n &amp;lt; j&#10;⊢ (if i = n then a else l[n]) = if i - 1 = n then a else l[n]&#10;&#10;case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : ¬n &amp;lt; j&#10;⊢ (if i = n + 1 then a else l[n + 1]) = if i - 1 = n then a else l[n + 1]" state_after="case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : ¬n &amp;lt; j&#10;⊢ (if i = n + 1 then a else l[n + 1]) = if i - 1 = n then a else l[n + 1]" tactic="· split&#10;  · split&#10;    · rfl&#10;    · omega&#10;  · split&#10;    · omega&#10;    · rfl">
                            <OtherNode start="(96, 5)" end="(96, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(96, 5)" end="(96, 6)" kind="patternIgnore">
                                <OtherNode start="(96, 5)" end="(96, 6)" kind="token.«· »">
                                  <AtomNode start="(96, 5)" end="(96, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(96, 7)" end="(102, 14)">
                              <TacticTacticseq1IndentedNode start="(96, 7)" end="(102, 14)">
                                <NullNode start="(96, 7)" end="(102, 14)">
                                  <OtherNode start="(96, 7)" end="(96, 12)" kind="Lean.Parser.Tactic.split" state_before="case h.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : n &amp;lt; j&#10;⊢ (if i = n then a else l[n]) = if i - 1 = n then a else l[n]" state_after="case h.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : n &amp;lt; j&#10;h✝ : i = n&#10;⊢ a = if i - 1 = n then a else l[n]&#10;&#10;case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : n &amp;lt; j&#10;h✝ : ¬i = n&#10;⊢ l[n] = if i - 1 = n then a else l[n]" tactic="split">
                                    <AtomNode start="(96, 7)" end="(96, 12)" leading="" trailing="&#10;      " val="split"/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(97, 7)" end="(99, 16)" kind="Lean.cdot" state_before="case h.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : n &amp;lt; j&#10;h✝ : i = n&#10;⊢ a = if i - 1 = n then a else l[n]&#10;&#10;case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : n &amp;lt; j&#10;h✝ : ¬i = n&#10;⊢ l[n] = if i - 1 = n then a else l[n]" state_after="case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : n &amp;lt; j&#10;h✝ : ¬i = n&#10;⊢ l[n] = if i - 1 = n then a else l[n]" tactic="· split&#10;  · rfl&#10;  · omega">
                                    <OtherNode start="(97, 7)" end="(97, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(97, 7)" end="(97, 8)" kind="patternIgnore">
                                        <OtherNode start="(97, 7)" end="(97, 8)" kind="token.«· »">
                                          <AtomNode start="(97, 7)" end="(97, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(97, 9)" end="(99, 16)">
                                      <TacticTacticseq1IndentedNode start="(97, 9)" end="(99, 16)">
                                        <NullNode start="(97, 9)" end="(99, 16)">
                                          <OtherNode start="(97, 9)" end="(97, 14)" kind="Lean.Parser.Tactic.split" state_before="case h.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : n &amp;lt; j&#10;h✝ : i = n&#10;⊢ a = if i - 1 = n then a else l[n]" state_after="case h.isTrue.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : i = n&#10;h✝ : i - 1 = n&#10;⊢ a = a&#10;&#10;case h.isTrue.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : i = n&#10;h✝ : ¬i - 1 = n&#10;⊢ a = l[n]" tactic="split">
                                            <AtomNode start="(97, 9)" end="(97, 14)" leading="" trailing="&#10;        " val="split"/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(98, 9)" end="(98, 14)" kind="Lean.cdot" state_before="case h.isTrue.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : i = n&#10;h✝ : i - 1 = n&#10;⊢ a = a&#10;&#10;case h.isTrue.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : i = n&#10;h✝ : ¬i - 1 = n&#10;⊢ a = l[n]" state_after="case h.isTrue.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : i = n&#10;h✝ : ¬i - 1 = n&#10;⊢ a = l[n]" tactic="· rfl">
                                            <OtherNode start="(98, 9)" end="(98, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(98, 9)" end="(98, 10)" kind="patternIgnore">
                                                <OtherNode start="(98, 9)" end="(98, 10)" kind="token.«· »">
                                                  <AtomNode start="(98, 9)" end="(98, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(98, 11)" end="(98, 14)">
                                              <TacticTacticseq1IndentedNode start="(98, 11)" end="(98, 14)">
                                                <NullNode start="(98, 11)" end="(98, 14)">
                                                  <OtherNode start="(98, 11)" end="(98, 14)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case h.isTrue.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : i = n&#10;h✝ : i - 1 = n&#10;⊢ a = a" state_after="no goals" tactic="rfl">
                                                    <AtomNode start="(98, 11)" end="(98, 14)" leading="" trailing="&#10;        " val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(99, 9)" end="(99, 16)" kind="Lean.cdot" state_before="case h.isTrue.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : i = n&#10;h✝ : ¬i - 1 = n&#10;⊢ a = l[n]" state_after="no goals" tactic="· omega">
                                            <OtherNode start="(99, 9)" end="(99, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(99, 9)" end="(99, 10)" kind="patternIgnore">
                                                <OtherNode start="(99, 9)" end="(99, 10)" kind="token.«· »">
                                                  <AtomNode start="(99, 9)" end="(99, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(99, 11)" end="(99, 16)">
                                              <TacticTacticseq1IndentedNode start="(99, 11)" end="(99, 16)">
                                                <NullNode start="(99, 11)" end="(99, 16)">
                                                  <OtherNode start="(99, 11)" end="(99, 16)" kind="Lean.Parser.Tactic.omega" state_before="case h.isTrue.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : i = n&#10;h✝ : ¬i - 1 = n&#10;⊢ a = l[n]" state_after="no goals" tactic="omega">
                                                    <AtomNode start="(99, 11)" end="(99, 16)" leading="" trailing="&#10;      " val="omega"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(100, 7)" end="(102, 14)" kind="Lean.cdot" state_before="case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : n &amp;lt; j&#10;h✝ : ¬i = n&#10;⊢ l[n] = if i - 1 = n then a else l[n]" state_after="no goals" tactic="· split&#10;  · omega&#10;  · rfl">
                                    <OtherNode start="(100, 7)" end="(100, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(100, 7)" end="(100, 8)" kind="patternIgnore">
                                        <OtherNode start="(100, 7)" end="(100, 8)" kind="token.«· »">
                                          <AtomNode start="(100, 7)" end="(100, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(100, 9)" end="(102, 14)">
                                      <TacticTacticseq1IndentedNode start="(100, 9)" end="(102, 14)">
                                        <NullNode start="(100, 9)" end="(102, 14)">
                                          <OtherNode start="(100, 9)" end="(100, 14)" kind="Lean.Parser.Tactic.split" state_before="case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : n &amp;lt; j&#10;h✝ : ¬i = n&#10;⊢ l[n] = if i - 1 = n then a else l[n]" state_after="case h.isTrue.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : ¬i = n&#10;h✝ : i - 1 = n&#10;⊢ l[n] = a&#10;&#10;case h.isTrue.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : ¬i = n&#10;h✝ : ¬i - 1 = n&#10;⊢ l[n] = l[n]" tactic="split">
                                            <AtomNode start="(100, 9)" end="(100, 14)" leading="" trailing="&#10;        " val="split"/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(101, 9)" end="(101, 16)" kind="Lean.cdot" state_before="case h.isTrue.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : ¬i = n&#10;h✝ : i - 1 = n&#10;⊢ l[n] = a&#10;&#10;case h.isTrue.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : ¬i = n&#10;h✝ : ¬i - 1 = n&#10;⊢ l[n] = l[n]" state_after="case h.isTrue.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : ¬i = n&#10;h✝ : ¬i - 1 = n&#10;⊢ l[n] = l[n]" tactic="· omega">
                                            <OtherNode start="(101, 9)" end="(101, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(101, 9)" end="(101, 10)" kind="patternIgnore">
                                                <OtherNode start="(101, 9)" end="(101, 10)" kind="token.«· »">
                                                  <AtomNode start="(101, 9)" end="(101, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(101, 11)" end="(101, 16)">
                                              <TacticTacticseq1IndentedNode start="(101, 11)" end="(101, 16)">
                                                <NullNode start="(101, 11)" end="(101, 16)">
                                                  <OtherNode start="(101, 11)" end="(101, 16)" kind="Lean.Parser.Tactic.omega" state_before="case h.isTrue.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : ¬i = n&#10;h✝ : i - 1 = n&#10;⊢ l[n] = a" state_after="no goals" tactic="omega">
                                                    <AtomNode start="(101, 11)" end="(101, 16)" leading="" trailing="&#10;        " val="omega"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(102, 9)" end="(102, 14)" kind="Lean.cdot" state_before="case h.isTrue.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : ¬i = n&#10;h✝ : ¬i - 1 = n&#10;⊢ l[n] = l[n]" state_after="no goals" tactic="· rfl">
                                            <OtherNode start="(102, 9)" end="(102, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(102, 9)" end="(102, 10)" kind="patternIgnore">
                                                <OtherNode start="(102, 9)" end="(102, 10)" kind="token.«· »">
                                                  <AtomNode start="(102, 9)" end="(102, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(102, 11)" end="(102, 14)">
                                              <TacticTacticseq1IndentedNode start="(102, 11)" end="(102, 14)">
                                                <NullNode start="(102, 11)" end="(102, 14)">
                                                  <OtherNode start="(102, 11)" end="(102, 14)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case h.isTrue.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : n &amp;lt; j&#10;h✝¹ : ¬i = n&#10;h✝ : ¬i - 1 = n&#10;⊢ l[n] = l[n]" state_after="no goals" tactic="rfl">
                                                    <AtomNode start="(102, 11)" end="(102, 14)" leading="" trailing="&#10;    " val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(103, 5)" end="(108, 17)" kind="Lean.cdot" state_before="case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : ¬n &amp;lt; j&#10;⊢ (if i = n + 1 then a else l[n + 1]) = if i - 1 = n then a else l[n + 1]" state_after="no goals" tactic="· split&#10;  · split&#10;    · rfl&#10;    · omega&#10;  · have t : i - 1 ≠ n := by omega&#10;    simp [t]">
                            <OtherNode start="(103, 5)" end="(103, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(103, 5)" end="(103, 6)" kind="patternIgnore">
                                <OtherNode start="(103, 5)" end="(103, 6)" kind="token.«· »">
                                  <AtomNode start="(103, 5)" end="(103, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(103, 7)" end="(108, 17)">
                              <TacticTacticseq1IndentedNode start="(103, 7)" end="(108, 17)">
                                <NullNode start="(103, 7)" end="(108, 17)">
                                  <OtherNode start="(103, 7)" end="(103, 12)" kind="Lean.Parser.Tactic.split" state_before="case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : ¬n &amp;lt; j&#10;⊢ (if i = n + 1 then a else l[n + 1]) = if i - 1 = n then a else l[n + 1]" state_after="case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : i = n + 1&#10;⊢ a = if i - 1 = n then a else l[n + 1]&#10;&#10;case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;⊢ l[n + 1] = if i - 1 = n then a else l[n + 1]" tactic="split">
                                    <AtomNode start="(103, 7)" end="(103, 12)" leading="" trailing="&#10;      " val="split"/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(104, 7)" end="(106, 16)" kind="Lean.cdot" state_before="case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : i = n + 1&#10;⊢ a = if i - 1 = n then a else l[n + 1]&#10;&#10;case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;⊢ l[n + 1] = if i - 1 = n then a else l[n + 1]" state_after="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;⊢ l[n + 1] = if i - 1 = n then a else l[n + 1]" tactic="· split&#10;  · rfl&#10;  · omega">
                                    <OtherNode start="(104, 7)" end="(104, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(104, 7)" end="(104, 8)" kind="patternIgnore">
                                        <OtherNode start="(104, 7)" end="(104, 8)" kind="token.«· »">
                                          <AtomNode start="(104, 7)" end="(104, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(104, 9)" end="(106, 16)">
                                      <TacticTacticseq1IndentedNode start="(104, 9)" end="(106, 16)">
                                        <NullNode start="(104, 9)" end="(106, 16)">
                                          <OtherNode start="(104, 9)" end="(104, 14)" kind="Lean.Parser.Tactic.split" state_before="case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : i = n + 1&#10;⊢ a = if i - 1 = n then a else l[n + 1]" state_after="case h.isFalse.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : i - 1 = n&#10;⊢ a = a&#10;&#10;case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : ¬i - 1 = n&#10;⊢ a = l[n + 1]" tactic="split">
                                            <AtomNode start="(104, 9)" end="(104, 14)" leading="" trailing="&#10;        " val="split"/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(105, 9)" end="(105, 14)" kind="Lean.cdot" state_before="case h.isFalse.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : i - 1 = n&#10;⊢ a = a&#10;&#10;case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : ¬i - 1 = n&#10;⊢ a = l[n + 1]" state_after="case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : ¬i - 1 = n&#10;⊢ a = l[n + 1]" tactic="· rfl">
                                            <OtherNode start="(105, 9)" end="(105, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(105, 9)" end="(105, 10)" kind="patternIgnore">
                                                <OtherNode start="(105, 9)" end="(105, 10)" kind="token.«· »">
                                                  <AtomNode start="(105, 9)" end="(105, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(105, 11)" end="(105, 14)">
                                              <TacticTacticseq1IndentedNode start="(105, 11)" end="(105, 14)">
                                                <NullNode start="(105, 11)" end="(105, 14)">
                                                  <OtherNode start="(105, 11)" end="(105, 14)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case h.isFalse.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : i - 1 = n&#10;⊢ a = a" state_after="no goals" tactic="rfl">
                                                    <AtomNode start="(105, 11)" end="(105, 14)" leading="" trailing="&#10;        " val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(106, 9)" end="(106, 16)" kind="Lean.cdot" state_before="case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : ¬i - 1 = n&#10;⊢ a = l[n + 1]" state_after="no goals" tactic="· omega">
                                            <OtherNode start="(106, 9)" end="(106, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(106, 9)" end="(106, 10)" kind="patternIgnore">
                                                <OtherNode start="(106, 9)" end="(106, 10)" kind="token.«· »">
                                                  <AtomNode start="(106, 9)" end="(106, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(106, 11)" end="(106, 16)">
                                              <TacticTacticseq1IndentedNode start="(106, 11)" end="(106, 16)">
                                                <NullNode start="(106, 11)" end="(106, 16)">
                                                  <OtherNode start="(106, 11)" end="(106, 16)" kind="Lean.Parser.Tactic.omega" state_before="case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : ¬i - 1 = n&#10;⊢ a = l[n + 1]" state_after="no goals" tactic="omega">
                                                    <AtomNode start="(106, 11)" end="(106, 16)" leading="" trailing="&#10;      " val="omega"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(107, 7)" end="(108, 17)" kind="Lean.cdot" state_before="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;⊢ l[n + 1] = if i - 1 = n then a else l[n + 1]" state_after="no goals" tactic="· have t : i - 1 ≠ n := by omega&#10;  simp [t]">
                                    <OtherNode start="(107, 7)" end="(107, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(107, 7)" end="(107, 8)" kind="patternIgnore">
                                        <OtherNode start="(107, 7)" end="(107, 8)" kind="token.«· »">
                                          <AtomNode start="(107, 7)" end="(107, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(107, 9)" end="(108, 17)">
                                      <TacticTacticseq1IndentedNode start="(107, 9)" end="(108, 17)">
                                        <NullNode start="(107, 9)" end="(108, 17)">
                                          <OtherNode start="(107, 9)" end="(107, 39)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;⊢ l[n + 1] = if i - 1 = n then a else l[n + 1]" state_after="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;t : i - 1 ≠ n&#10;⊢ l[n + 1] = if i - 1 = n then a else l[n + 1]" tactic="have t : i - 1 ≠ n := by omega">
                                            <AtomNode start="(107, 9)" end="(107, 13)" leading="" trailing=" " val="have"/>
                                            <OtherNode start="(107, 14)" end="(107, 39)" kind="Lean.Parser.Term.haveDecl">
                                              <OtherNode start="(107, 14)" end="(107, 39)" kind="Lean.Parser.Term.haveIdDecl">
                                                <OtherNode start="(107, 14)" end="(107, 15)" kind="Lean.Parser.Term.haveId">
                                                  <IdentNode start="(107, 14)" end="(107, 15)" leading="" trailing=" " raw_val="t" val="t"/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode start="(107, 16)" end="(107, 27)">
                                                  <TermTypespecNode start="(107, 16)" end="(107, 27)">
                                                    <AtomNode start="(107, 16)" end="(107, 17)" leading="" trailing=" " val=":"/>
                                                    <OtherNode start="(107, 18)" end="(107, 27)" kind="«term_≠_»">
                                                      <OtherNode start="(107, 18)" end="(107, 23)" kind="«term_-_»">
                                                        <IdentNode start="(107, 18)" end="(107, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                                                        <AtomNode start="(107, 20)" end="(107, 21)" leading="" trailing=" " val="-"/>
                                                        <OtherNode start="(107, 22)" end="(107, 23)" kind="num">
                                                          <AtomNode start="(107, 22)" end="(107, 23)" leading="" trailing=" " val="1"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <AtomNode start="(107, 24)" end="(107, 25)" leading="" trailing=" " val="≠"/>
                                                      <IdentNode start="(107, 26)" end="(107, 27)" leading="" trailing=" " raw_val="n" val="n"/>
                                                    </OtherNode>
                                                  </TermTypespecNode>
                                                </NullNode>
                                                <AtomNode start="(107, 28)" end="(107, 30)" leading="" trailing=" " val=":="/>
                                                <TermBytacticNode start="(107, 31)" end="(107, 39)">
                                                  <AtomNode start="(107, 31)" end="(107, 33)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(107, 34)" end="(107, 39)">
                                                    <TacticTacticseq1IndentedNode start="(107, 34)" end="(107, 39)">
                                                      <NullNode start="(107, 34)" end="(107, 39)">
                                                        <OtherNode start="(107, 34)" end="(107, 39)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;⊢ i - 1 ≠ n" state_after="no goals" tactic="omega">
                                                          <AtomNode start="(107, 34)" end="(107, 39)" leading="" trailing="&#10;        " val="omega"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(108, 9)" end="(108, 17)" kind="Lean.Parser.Tactic.simp" state_before="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : j &amp;lt; i&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set (i - 1) a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;t : i - 1 ≠ n&#10;⊢ l[n + 1] = if i - 1 = n then a else l[n + 1]" state_after="no goals" tactic="simp [t]">
                                            <AtomNode start="(108, 9)" end="(108, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(108, 14)" end="(108, 17)">
                                              <AtomNode start="(108, 14)" end="(108, 15)" leading="" trailing="" val="["/>
                                              <NullNode start="(108, 15)" end="(108, 16)">
                                                <OtherNode start="(108, 15)" end="(108, 16)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(108, 15)" end="(108, 16)" leading="" trailing="" raw_val="t" val="t"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(108, 16)" end="(108, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(110, 1)" end="(124, 17)" name="eraseIdx_set_gt" full_name="List.eraseIdx_set_gt">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(110, 1)" end="(124, 17)" name="eraseIdx_set_gt" full_name="List.eraseIdx_set_gt" _is_private_decl="False">
        <AtomNode start="(110, 1)" end="(110, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(110, 9)" end="(110, 24)">
          <IdentNode start="(110, 9)" end="(110, 24)" leading="" trailing=" " raw_val="eraseIdx_set_gt" val="eraseIdx_set_gt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(110, 25)" end="(111, 52)">
          <NullNode start="(110, 25)" end="(110, 77)">
            <OtherNode start="(110, 25)" end="(110, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(110, 25)" end="(110, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(110, 26)" end="(110, 27)">
                <IdentNode start="(110, 26)" end="(110, 27)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(110, 28)" end="(110, 36)">
                <AtomNode start="(110, 28)" end="(110, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(110, 30)" end="(110, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(110, 30)" end="(110, 34)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(110, 35)" end="(110, 36)">
                    <IdentNode start="(110, 35)" end="(110, 36)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(110, 36)" end="(110, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(110, 38)" end="(110, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(110, 38)" end="(110, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(110, 39)" end="(110, 40)">
                <IdentNode start="(110, 39)" end="(110, 40)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(110, 41)" end="(110, 46)">
                <AtomNode start="(110, 41)" end="(110, 42)" leading="" trailing=" " val=":"/>
                <IdentNode start="(110, 43)" end="(110, 46)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(110, 46)" end="(110, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(110, 48)" end="(110, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(110, 48)" end="(110, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(110, 49)" end="(110, 50)">
                <IdentNode start="(110, 49)" end="(110, 50)" leading="" trailing=" " raw_val="j" val="j"/>
              </NullNode>
              <NullNode start="(110, 51)" end="(110, 56)">
                <AtomNode start="(110, 51)" end="(110, 52)" leading="" trailing=" " val=":"/>
                <IdentNode start="(110, 53)" end="(110, 56)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(110, 56)" end="(110, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(110, 58)" end="(110, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(110, 58)" end="(110, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(110, 59)" end="(110, 60)">
                <IdentNode start="(110, 59)" end="(110, 60)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(110, 61)" end="(110, 64)">
                <AtomNode start="(110, 61)" end="(110, 62)" leading="" trailing=" " val=":"/>
                <IdentNode start="(110, 63)" end="(110, 64)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(110, 64)" end="(110, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(110, 66)" end="(110, 77)">
              <AtomNode start="(110, 66)" end="(110, 67)" leading="" trailing="" val="("/>
              <NullNode start="(110, 67)" end="(110, 68)">
                <IdentNode start="(110, 67)" end="(110, 68)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(110, 69)" end="(110, 76)">
                <AtomNode start="(110, 69)" end="(110, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(110, 71)" end="(110, 76)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(110, 71)" end="(110, 72)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(110, 73)" end="(110, 74)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(110, 75)" end="(110, 76)" leading="" trailing="" raw_val="j" val="j"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(110, 76)" end="(110, 77)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(110, 78)" end="(111, 52)">
            <AtomNode start="(110, 78)" end="(110, 79)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(111, 5)" end="(111, 52)" kind="«term_=_»">
              <OtherNode start="(111, 5)" end="(111, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(111, 5)" end="(111, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(111, 5)" end="(111, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(111, 5)" end="(111, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(111, 6)" end="(111, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(111, 6)" end="(111, 11)" leading="" trailing=" " raw_val="l.set" val="l.set"/>
                      <NullNode start="(111, 12)" end="(111, 15)">
                        <IdentNode start="(111, 12)" end="(111, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(111, 14)" end="(111, 15)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(111, 15)" end="(111, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(111, 16)" end="(111, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(111, 17)" end="(111, 25)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(111, 26)" end="(111, 27)">
                  <IdentNode start="(111, 26)" end="(111, 27)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(111, 28)" end="(111, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(111, 30)" end="(111, 52)" kind="Lean.Parser.Term.app">
                <OtherNode start="(111, 30)" end="(111, 48)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(111, 30)" end="(111, 44)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(111, 30)" end="(111, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(111, 31)" end="(111, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(111, 31)" end="(111, 41)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                      <NullNode start="(111, 42)" end="(111, 43)">
                        <IdentNode start="(111, 42)" end="(111, 43)" leading="" trailing="" raw_val="j" val="j"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(111, 43)" end="(111, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(111, 44)" end="(111, 45)" leading="" trailing="" val="."/>
                  <IdentNode start="(111, 45)" end="(111, 48)" leading="" trailing=" " raw_val="set" val="set" full_name="List.set" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(111, 49)" end="(111, 52)">
                  <IdentNode start="(111, 49)" end="(111, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(111, 51)" end="(111, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(111, 53)" end="(124, 17)">
          <AtomNode start="(111, 53)" end="(111, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(111, 56)" end="(124, 17)">
            <AtomNode start="(111, 56)" end="(111, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(112, 3)" end="(124, 17)">
              <TacticTacticseq1IndentedNode start="(112, 3)" end="(124, 17)">
                <NullNode start="(112, 3)" end="(124, 17)">
                  <OtherNode start="(112, 3)" end="(112, 20)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;⊢ (l.set i a).eraseIdx j = (l.eraseIdx j).set i a" state_after="case hl&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;⊢ ((l.set i a).eraseIdx j).length = ((l.eraseIdx j).set i a).length&#10;&#10;case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx j).length) (h₂ : i_1 &amp;lt; ((l.eraseIdx j).set i a).length),&#10;    ((l.set i a).eraseIdx j)[i_1] = ((l.eraseIdx j).set i a)[i_1]" tactic="apply ext_getElem">
                    <AtomNode start="(112, 3)" end="(112, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(112, 9)" end="(112, 20)" leading="" trailing="&#10;  " raw_val="ext_getElem" val="ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(113, 3)" end="(113, 27)" kind="Lean.cdot" state_before="case hl&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;⊢ ((l.set i a).eraseIdx j).length = ((l.eraseIdx j).set i a).length&#10;&#10;case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx j).length) (h₂ : i_1 &amp;lt; ((l.eraseIdx j).set i a).length),&#10;    ((l.set i a).eraseIdx j)[i_1] = ((l.eraseIdx j).set i a)[i_1]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx j).length) (h₂ : i_1 &amp;lt; ((l.eraseIdx j).set i a).length),&#10;    ((l.set i a).eraseIdx j)[i_1] = ((l.eraseIdx j).set i a)[i_1]" tactic="· simp [length_eraseIdx]">
                    <OtherNode start="(113, 3)" end="(113, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(113, 3)" end="(113, 4)" kind="patternIgnore">
                        <OtherNode start="(113, 3)" end="(113, 4)" kind="token.«· »">
                          <AtomNode start="(113, 3)" end="(113, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(113, 5)" end="(113, 27)">
                      <TacticTacticseq1IndentedNode start="(113, 5)" end="(113, 27)">
                        <NullNode start="(113, 5)" end="(113, 27)">
                          <OtherNode start="(113, 5)" end="(113, 27)" kind="Lean.Parser.Tactic.simp" state_before="case hl&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;⊢ ((l.set i a).eraseIdx j).length = ((l.eraseIdx j).set i a).length" state_after="no goals" tactic="simp [length_eraseIdx]">
                            <AtomNode start="(113, 5)" end="(113, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(113, 10)" end="(113, 27)">
                              <AtomNode start="(113, 10)" end="(113, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(113, 11)" end="(113, 26)">
                                <OtherNode start="(113, 11)" end="(113, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(113, 11)" end="(113, 26)" leading="" trailing="" raw_val="length_eraseIdx" val="length_eraseIdx" full_name="List.length_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(113, 26)" end="(113, 27)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(114, 3)" end="(124, 17)" kind="Lean.cdot" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx j).length) (h₂ : i_1 &amp;lt; ((l.eraseIdx j).set i a).length),&#10;    ((l.set i a).eraseIdx j)[i_1] = ((l.eraseIdx j).set i a)[i_1]" state_after="no goals" tactic="· intro n h₁ h₂&#10;  simp only [length_eraseIdx, length_set] at h₁&#10;  simp only [getElem_eraseIdx, getElem_set]&#10;  split&#10;  · rfl&#10;  · split&#10;    · split&#10;      · rfl&#10;      · omega&#10;    · have t : i ≠ n := by omega&#10;      simp [t]">
                    <OtherNode start="(114, 3)" end="(114, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(114, 3)" end="(114, 4)" kind="patternIgnore">
                        <OtherNode start="(114, 3)" end="(114, 4)" kind="token.«· »">
                          <AtomNode start="(114, 3)" end="(114, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(114, 5)" end="(124, 17)">
                      <TacticTacticseq1IndentedNode start="(114, 5)" end="(124, 17)">
                        <NullNode start="(114, 5)" end="(124, 17)">
                          <OtherNode start="(114, 5)" end="(114, 18)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.set i a).eraseIdx j).length) (h₂ : i_1 &amp;lt; ((l.eraseIdx j).set i a).length),&#10;    ((l.set i a).eraseIdx j)[i_1] = ((l.eraseIdx j).set i a)[i_1]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;⊢ ((l.set i a).eraseIdx j)[n] = ((l.eraseIdx j).set i a)[n]" tactic="intro n h₁ h₂">
                            <AtomNode start="(114, 5)" end="(114, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(114, 11)" end="(114, 18)">
                              <IdentNode start="(114, 11)" end="(114, 12)" leading="" trailing=" " raw_val="n" val="n"/>
                              <IdentNode start="(114, 13)" end="(114, 15)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                              <IdentNode start="(114, 16)" end="(114, 18)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(115, 5)" end="(115, 50)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;⊢ ((l.set i a).eraseIdx j)[n] = ((l.eraseIdx j).set i a)[n]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;⊢ ((l.set i a).eraseIdx j)[n] = ((l.eraseIdx j).set i a)[n]" tactic="simp only [length_eraseIdx, length_set] at h₁">
                            <AtomNode start="(115, 5)" end="(115, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(115, 10)" end="(115, 14)">
                              <AtomNode start="(115, 10)" end="(115, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(115, 15)" end="(115, 44)">
                              <AtomNode start="(115, 15)" end="(115, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(115, 16)" end="(115, 43)">
                                <OtherNode start="(115, 16)" end="(115, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(115, 16)" end="(115, 31)" leading="" trailing="" raw_val="length_eraseIdx" val="length_eraseIdx" full_name="List.length_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                                </OtherNode>
                                <AtomNode start="(115, 31)" end="(115, 32)" leading="" trailing=" " val=","/>
                                <OtherNode start="(115, 33)" end="(115, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(115, 33)" end="(115, 43)" leading="" trailing="" raw_val="length_set" val="length_set" full_name="List.length_set" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(115, 43)" end="(115, 44)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(115, 45)" end="(115, 50)">
                              <OtherNode start="(115, 45)" end="(115, 50)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(115, 45)" end="(115, 47)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(115, 48)" end="(115, 50)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(115, 48)" end="(115, 50)">
                                    <IdentNode start="(115, 48)" end="(115, 50)" leading="" trailing="&#10;    " raw_val="h₁" val="h₁"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(116, 5)" end="(116, 46)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;⊢ ((l.set i a).eraseIdx j)[n] = ((l.eraseIdx j).set i a)[n]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;⊢ (if h : n &amp;lt; j then if i = n then a else l[n] else if i = n + 1 then a else l[n + 1]) =&#10;    if i = n then a else if h' : n &amp;lt; j then l[n] else l[n + 1]" tactic="simp only [getElem_eraseIdx, getElem_set]">
                            <AtomNode start="(116, 5)" end="(116, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(116, 10)" end="(116, 14)">
                              <AtomNode start="(116, 10)" end="(116, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(116, 15)" end="(116, 46)">
                              <AtomNode start="(116, 15)" end="(116, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(116, 16)" end="(116, 45)">
                                <OtherNode start="(116, 16)" end="(116, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(116, 16)" end="(116, 32)" leading="" trailing="" raw_val="getElem_eraseIdx" val="getElem_eraseIdx" full_name="List.getElem_eraseIdx" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean" def_start="(52, 9)" def_end="(52, 25)"/>
                                </OtherNode>
                                <AtomNode start="(116, 32)" end="(116, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(116, 34)" end="(116, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(116, 34)" end="(116, 45)" leading="" trailing="" raw_val="getElem_set" val="getElem_set" full_name="List.getElem_set" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(116, 45)" end="(116, 46)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(117, 5)" end="(117, 10)" kind="Lean.Parser.Tactic.split" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;⊢ (if h : n &amp;lt; j then if i = n then a else l[n] else if i = n + 1 then a else l[n + 1]) =&#10;    if i = n then a else if h' : n &amp;lt; j then l[n] else l[n + 1]" state_after="case h.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : n &amp;lt; j&#10;⊢ (if i = n then a else l[n]) = if i = n then a else l[n]&#10;&#10;case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : ¬n &amp;lt; j&#10;⊢ (if i = n + 1 then a else l[n + 1]) = if i = n then a else l[n + 1]" tactic="split">
                            <AtomNode start="(117, 5)" end="(117, 10)" leading="" trailing="&#10;    " val="split"/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(118, 5)" end="(118, 10)" kind="Lean.cdot" state_before="case h.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : n &amp;lt; j&#10;⊢ (if i = n then a else l[n]) = if i = n then a else l[n]&#10;&#10;case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : ¬n &amp;lt; j&#10;⊢ (if i = n + 1 then a else l[n + 1]) = if i = n then a else l[n + 1]" state_after="case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : ¬n &amp;lt; j&#10;⊢ (if i = n + 1 then a else l[n + 1]) = if i = n then a else l[n + 1]" tactic="· rfl">
                            <OtherNode start="(118, 5)" end="(118, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(118, 5)" end="(118, 6)" kind="patternIgnore">
                                <OtherNode start="(118, 5)" end="(118, 6)" kind="token.«· »">
                                  <AtomNode start="(118, 5)" end="(118, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(118, 7)" end="(118, 10)">
                              <TacticTacticseq1IndentedNode start="(118, 7)" end="(118, 10)">
                                <NullNode start="(118, 7)" end="(118, 10)">
                                  <OtherNode start="(118, 7)" end="(118, 10)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case h.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : n &amp;lt; j&#10;⊢ (if i = n then a else l[n]) = if i = n then a else l[n]" state_after="no goals" tactic="rfl">
                                    <AtomNode start="(118, 7)" end="(118, 10)" leading="" trailing="&#10;    " val="rfl"/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(119, 5)" end="(124, 17)" kind="Lean.cdot" state_before="case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : ¬n &amp;lt; j&#10;⊢ (if i = n + 1 then a else l[n + 1]) = if i = n then a else l[n + 1]" state_after="no goals" tactic="· split&#10;  · split&#10;    · rfl&#10;    · omega&#10;  · have t : i ≠ n := by omega&#10;    simp [t]">
                            <OtherNode start="(119, 5)" end="(119, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(119, 5)" end="(119, 6)" kind="patternIgnore">
                                <OtherNode start="(119, 5)" end="(119, 6)" kind="token.«· »">
                                  <AtomNode start="(119, 5)" end="(119, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(119, 7)" end="(124, 17)">
                              <TacticTacticseq1IndentedNode start="(119, 7)" end="(124, 17)">
                                <NullNode start="(119, 7)" end="(124, 17)">
                                  <OtherNode start="(119, 7)" end="(119, 12)" kind="Lean.Parser.Tactic.split" state_before="case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝ : ¬n &amp;lt; j&#10;⊢ (if i = n + 1 then a else l[n + 1]) = if i = n then a else l[n + 1]" state_after="case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : i = n + 1&#10;⊢ a = if i = n then a else l[n + 1]&#10;&#10;case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;⊢ l[n + 1] = if i = n then a else l[n + 1]" tactic="split">
                                    <AtomNode start="(119, 7)" end="(119, 12)" leading="" trailing="&#10;      " val="split"/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(120, 7)" end="(122, 16)" kind="Lean.cdot" state_before="case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : i = n + 1&#10;⊢ a = if i = n then a else l[n + 1]&#10;&#10;case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;⊢ l[n + 1] = if i = n then a else l[n + 1]" state_after="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;⊢ l[n + 1] = if i = n then a else l[n + 1]" tactic="· split&#10;  · rfl&#10;  · omega">
                                    <OtherNode start="(120, 7)" end="(120, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(120, 7)" end="(120, 8)" kind="patternIgnore">
                                        <OtherNode start="(120, 7)" end="(120, 8)" kind="token.«· »">
                                          <AtomNode start="(120, 7)" end="(120, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(120, 9)" end="(122, 16)">
                                      <TacticTacticseq1IndentedNode start="(120, 9)" end="(122, 16)">
                                        <NullNode start="(120, 9)" end="(122, 16)">
                                          <OtherNode start="(120, 9)" end="(120, 14)" kind="Lean.Parser.Tactic.split" state_before="case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : i = n + 1&#10;⊢ a = if i = n then a else l[n + 1]" state_after="case h.isFalse.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : i = n&#10;⊢ a = a&#10;&#10;case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : ¬i = n&#10;⊢ a = l[n + 1]" tactic="split">
                                            <AtomNode start="(120, 9)" end="(120, 14)" leading="" trailing="&#10;        " val="split"/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(121, 9)" end="(121, 14)" kind="Lean.cdot" state_before="case h.isFalse.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : i = n&#10;⊢ a = a&#10;&#10;case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : ¬i = n&#10;⊢ a = l[n + 1]" state_after="case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : ¬i = n&#10;⊢ a = l[n + 1]" tactic="· rfl">
                                            <OtherNode start="(121, 9)" end="(121, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(121, 9)" end="(121, 10)" kind="patternIgnore">
                                                <OtherNode start="(121, 9)" end="(121, 10)" kind="token.«· »">
                                                  <AtomNode start="(121, 9)" end="(121, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(121, 11)" end="(121, 14)">
                                              <TacticTacticseq1IndentedNode start="(121, 11)" end="(121, 14)">
                                                <NullNode start="(121, 11)" end="(121, 14)">
                                                  <OtherNode start="(121, 11)" end="(121, 14)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case h.isFalse.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : i = n&#10;⊢ a = a" state_after="no goals" tactic="rfl">
                                                    <AtomNode start="(121, 11)" end="(121, 14)" leading="" trailing="&#10;        " val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(122, 9)" end="(122, 16)" kind="Lean.cdot" state_before="case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : ¬i = n&#10;⊢ a = l[n + 1]" state_after="no goals" tactic="· omega">
                                            <OtherNode start="(122, 9)" end="(122, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(122, 9)" end="(122, 10)" kind="patternIgnore">
                                                <OtherNode start="(122, 9)" end="(122, 10)" kind="token.«· »">
                                                  <AtomNode start="(122, 9)" end="(122, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(122, 11)" end="(122, 16)">
                                              <TacticTacticseq1IndentedNode start="(122, 11)" end="(122, 16)">
                                                <NullNode start="(122, 11)" end="(122, 16)">
                                                  <OtherNode start="(122, 11)" end="(122, 16)" kind="Lean.Parser.Tactic.omega" state_before="case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝² : ¬n &amp;lt; j&#10;h✝¹ : i = n + 1&#10;h✝ : ¬i = n&#10;⊢ a = l[n + 1]" state_after="no goals" tactic="omega">
                                                    <AtomNode start="(122, 11)" end="(122, 16)" leading="" trailing="&#10;      " val="omega"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(123, 7)" end="(124, 17)" kind="Lean.cdot" state_before="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;⊢ l[n + 1] = if i = n then a else l[n + 1]" state_after="no goals" tactic="· have t : i ≠ n := by omega&#10;  simp [t]">
                                    <OtherNode start="(123, 7)" end="(123, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(123, 7)" end="(123, 8)" kind="patternIgnore">
                                        <OtherNode start="(123, 7)" end="(123, 8)" kind="token.«· »">
                                          <AtomNode start="(123, 7)" end="(123, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(123, 9)" end="(124, 17)">
                                      <TacticTacticseq1IndentedNode start="(123, 9)" end="(124, 17)">
                                        <NullNode start="(123, 9)" end="(124, 17)">
                                          <OtherNode start="(123, 9)" end="(123, 35)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;⊢ l[n + 1] = if i = n then a else l[n + 1]" state_after="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;t : i ≠ n&#10;⊢ l[n + 1] = if i = n then a else l[n + 1]" tactic="have t : i ≠ n := by omega">
                                            <AtomNode start="(123, 9)" end="(123, 13)" leading="" trailing=" " val="have"/>
                                            <OtherNode start="(123, 14)" end="(123, 35)" kind="Lean.Parser.Term.haveDecl">
                                              <OtherNode start="(123, 14)" end="(123, 35)" kind="Lean.Parser.Term.haveIdDecl">
                                                <OtherNode start="(123, 14)" end="(123, 15)" kind="Lean.Parser.Term.haveId">
                                                  <IdentNode start="(123, 14)" end="(123, 15)" leading="" trailing=" " raw_val="t" val="t"/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode start="(123, 16)" end="(123, 23)">
                                                  <TermTypespecNode start="(123, 16)" end="(123, 23)">
                                                    <AtomNode start="(123, 16)" end="(123, 17)" leading="" trailing=" " val=":"/>
                                                    <OtherNode start="(123, 18)" end="(123, 23)" kind="«term_≠_»">
                                                      <IdentNode start="(123, 18)" end="(123, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                                                      <AtomNode start="(123, 20)" end="(123, 21)" leading="" trailing=" " val="≠"/>
                                                      <IdentNode start="(123, 22)" end="(123, 23)" leading="" trailing=" " raw_val="n" val="n"/>
                                                    </OtherNode>
                                                  </TermTypespecNode>
                                                </NullNode>
                                                <AtomNode start="(123, 24)" end="(123, 26)" leading="" trailing=" " val=":="/>
                                                <TermBytacticNode start="(123, 27)" end="(123, 35)">
                                                  <AtomNode start="(123, 27)" end="(123, 29)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(123, 30)" end="(123, 35)">
                                                    <TacticTacticseq1IndentedNode start="(123, 30)" end="(123, 35)">
                                                      <NullNode start="(123, 30)" end="(123, 35)">
                                                        <OtherNode start="(123, 30)" end="(123, 35)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;⊢ i ≠ n" state_after="no goals" tactic="omega">
                                                          <AtomNode start="(123, 30)" end="(123, 35)" leading="" trailing="&#10;        " val="omega"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(124, 9)" end="(124, 17)" kind="Lean.Parser.Tactic.simp" state_before="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i j : Nat&#10;a : α&#10;h : i &amp;lt; j&#10;n : Nat&#10;h₁✝ : n &amp;lt; ((l.set i a).eraseIdx j).length&#10;h₂ : n &amp;lt; ((l.eraseIdx j).set i a).length&#10;h₁ : n &amp;lt; if j &amp;lt; l.length then l.length - 1 else l.length&#10;h✝¹ : ¬n &amp;lt; j&#10;h✝ : ¬i = n + 1&#10;t : i ≠ n&#10;⊢ l[n + 1] = if i = n then a else l[n + 1]" state_after="no goals" tactic="simp [t]">
                                            <AtomNode start="(124, 9)" end="(124, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(124, 14)" end="(124, 17)">
                                              <AtomNode start="(124, 14)" end="(124, 15)" leading="" trailing="" val="["/>
                                              <NullNode start="(124, 15)" end="(124, 16)">
                                                <OtherNode start="(124, 15)" end="(124, 16)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(124, 15)" end="(124, 16)" leading="" trailing="" raw_val="t" val="t"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(124, 16)" end="(124, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(126, 1)" end="(144, 17)" name="set_getElem_succ_eraseIdx_succ" full_name="List.set_getElem_succ_eraseIdx_succ">
      <CommandDeclmodifiersNode start="(126, 1)" end="(126, 8)">
        <NullNode/>
        <NullNode start="(126, 1)" end="(126, 8)">
          <OtherNode start="(126, 1)" end="(126, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(126, 1)" end="(126, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(126, 3)" end="(126, 7)">
              <OtherNode start="(126, 3)" end="(126, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(126, 3)" end="(126, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(126, 3)" end="(126, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(126, 7)" end="(126, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(126, 9)" end="(144, 17)" name="set_getElem_succ_eraseIdx_succ" full_name="List.set_getElem_succ_eraseIdx_succ" _is_private_decl="False">
        <AtomNode start="(126, 9)" end="(126, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(126, 17)" end="(126, 47)">
          <IdentNode start="(126, 17)" end="(126, 47)" leading="" trailing="&#10;    " raw_val="set_getElem_succ_eraseIdx_succ" val="set_getElem_succ_eraseIdx_succ"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(127, 5)" end="(128, 55)">
          <NullNode start="(127, 5)" end="(127, 50)">
            <OtherNode start="(127, 5)" end="(127, 17)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(127, 5)" end="(127, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(127, 6)" end="(127, 7)">
                <IdentNode start="(127, 6)" end="(127, 7)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(127, 8)" end="(127, 16)">
                <AtomNode start="(127, 8)" end="(127, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(127, 10)" end="(127, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(127, 10)" end="(127, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(127, 15)" end="(127, 16)">
                    <IdentNode start="(127, 15)" end="(127, 16)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(127, 16)" end="(127, 17)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(127, 18)" end="(127, 27)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(127, 18)" end="(127, 19)" leading="" trailing="" val="{"/>
              <NullNode start="(127, 19)" end="(127, 20)">
                <IdentNode start="(127, 19)" end="(127, 20)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(127, 21)" end="(127, 26)">
                <AtomNode start="(127, 21)" end="(127, 22)" leading="" trailing=" " val=":"/>
                <IdentNode start="(127, 23)" end="(127, 26)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(127, 26)" end="(127, 27)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(127, 28)" end="(127, 50)">
              <AtomNode start="(127, 28)" end="(127, 29)" leading="" trailing="" val="("/>
              <NullNode start="(127, 29)" end="(127, 30)">
                <IdentNode start="(127, 29)" end="(127, 30)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(127, 31)" end="(127, 49)">
                <AtomNode start="(127, 31)" end="(127, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(127, 33)" end="(127, 49)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(127, 33)" end="(127, 38)" kind="«term_+_»">
                    <IdentNode start="(127, 33)" end="(127, 34)" leading="" trailing=" " raw_val="i" val="i"/>
                    <AtomNode start="(127, 35)" end="(127, 36)" leading="" trailing=" " val="+"/>
                    <OtherNode start="(127, 37)" end="(127, 38)" kind="num">
                      <AtomNode start="(127, 37)" end="(127, 38)" leading="" trailing=" " val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(127, 39)" end="(127, 40)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(127, 41)" end="(127, 49)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(127, 49)" end="(127, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(127, 51)" end="(128, 55)">
            <AtomNode start="(127, 51)" end="(127, 52)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(128, 5)" end="(128, 55)" kind="«term_=_»">
              <OtherNode start="(128, 5)" end="(128, 40)" kind="Lean.Parser.Term.app">
                <OtherNode start="(128, 5)" end="(128, 29)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(128, 5)" end="(128, 25)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(128, 5)" end="(128, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(128, 6)" end="(128, 24)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(128, 6)" end="(128, 16)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                      <NullNode start="(128, 17)" end="(128, 24)">
                        <OtherNode start="(128, 17)" end="(128, 24)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(128, 17)" end="(128, 18)" leading="" trailing="" val="("/>
                          <OtherNode start="(128, 18)" end="(128, 23)" kind="«term_+_»">
                            <IdentNode start="(128, 18)" end="(128, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(128, 20)" end="(128, 21)" leading="" trailing=" " val="+"/>
                            <OtherNode start="(128, 22)" end="(128, 23)" kind="num">
                              <AtomNode start="(128, 22)" end="(128, 23)" leading="" trailing="" val="1"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(128, 23)" end="(128, 24)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(128, 24)" end="(128, 25)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(128, 25)" end="(128, 26)" leading="" trailing="" val="."/>
                  <IdentNode start="(128, 26)" end="(128, 29)" leading="" trailing=" " raw_val="set" val="set" full_name="List.set" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(128, 30)" end="(128, 40)">
                  <IdentNode start="(128, 30)" end="(128, 31)" leading="" trailing=" " raw_val="i" val="i"/>
                  <OtherNode start="(128, 32)" end="(128, 40)" kind="«term__[_]»">
                    <IdentNode start="(128, 32)" end="(128, 33)" leading="" trailing="" raw_val="l" val="l"/>
                    <AtomNode start="(128, 33)" end="(128, 34)" leading="" trailing="" val="["/>
                    <OtherNode start="(128, 34)" end="(128, 39)" kind="«term_+_»">
                      <IdentNode start="(128, 34)" end="(128, 35)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(128, 36)" end="(128, 37)" leading="" trailing=" " val="+"/>
                      <OtherNode start="(128, 38)" end="(128, 39)" kind="num">
                        <AtomNode start="(128, 38)" end="(128, 39)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(128, 39)" end="(128, 40)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(128, 41)" end="(128, 42)" leading="" trailing=" " val="="/>
              <OtherNode start="(128, 43)" end="(128, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(128, 43)" end="(128, 53)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                <NullNode start="(128, 54)" end="(128, 55)">
                  <IdentNode start="(128, 54)" end="(128, 55)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(128, 56)" end="(144, 17)">
          <AtomNode start="(128, 56)" end="(128, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(128, 59)" end="(144, 17)">
            <AtomNode start="(128, 59)" end="(128, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(129, 3)" end="(144, 17)">
              <TacticTacticseq1IndentedNode start="(129, 3)" end="(144, 17)">
                <NullNode start="(129, 3)" end="(144, 17)">
                  <OtherNode start="(129, 3)" end="(129, 20)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;⊢ (l.eraseIdx (i + 1)).set i l[i + 1] = l.eraseIdx i" state_after="case hl&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;⊢ ((l.eraseIdx (i + 1)).set i l[i + 1]).length = (l.eraseIdx i).length&#10;&#10;case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length) (h₂ : i_1 &amp;lt; (l.eraseIdx i).length),&#10;    ((l.eraseIdx (i + 1)).set i l[i + 1])[i_1] = (l.eraseIdx i)[i_1]" tactic="apply ext_getElem">
                    <AtomNode start="(129, 3)" end="(129, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(129, 9)" end="(129, 20)" leading="" trailing="&#10;  " raw_val="ext_getElem" val="ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(130, 3)" end="(132, 10)" kind="Lean.cdot" state_before="case hl&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;⊢ ((l.eraseIdx (i + 1)).set i l[i + 1]).length = (l.eraseIdx i).length&#10;&#10;case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length) (h₂ : i_1 &amp;lt; (l.eraseIdx i).length),&#10;    ((l.eraseIdx (i + 1)).set i l[i + 1])[i_1] = (l.eraseIdx i)[i_1]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length) (h₂ : i_1 &amp;lt; (l.eraseIdx i).length),&#10;    ((l.eraseIdx (i + 1)).set i l[i + 1])[i_1] = (l.eraseIdx i)[i_1]" tactic="· simp only [length_set, length_eraseIdx, h, ↓reduceIte]&#10;  rw [if_pos]&#10;  omega">
                    <OtherNode start="(130, 3)" end="(130, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(130, 3)" end="(130, 4)" kind="patternIgnore">
                        <OtherNode start="(130, 3)" end="(130, 4)" kind="token.«· »">
                          <AtomNode start="(130, 3)" end="(130, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(130, 5)" end="(132, 10)">
                      <TacticTacticseq1IndentedNode start="(130, 5)" end="(132, 10)">
                        <NullNode start="(130, 5)" end="(132, 10)">
                          <OtherNode start="(130, 5)" end="(130, 59)" kind="Lean.Parser.Tactic.simp" state_before="case hl&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;⊢ ((l.eraseIdx (i + 1)).set i l[i + 1]).length = (l.eraseIdx i).length" state_after="case hl&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;⊢ l.length - 1 = if i &amp;lt; l.length then l.length - 1 else l.length" tactic="simp only [length_set, length_eraseIdx, h, ↓reduceIte]">
                            <AtomNode start="(130, 5)" end="(130, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(130, 10)" end="(130, 14)">
                              <AtomNode start="(130, 10)" end="(130, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(130, 15)" end="(130, 59)">
                              <AtomNode start="(130, 15)" end="(130, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(130, 16)" end="(130, 58)">
                                <OtherNode start="(130, 16)" end="(130, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(130, 16)" end="(130, 26)" leading="" trailing="" raw_val="length_set" val="length_set" full_name="List.length_set" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(130, 26)" end="(130, 27)" leading="" trailing=" " val=","/>
                                <OtherNode start="(130, 28)" end="(130, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(130, 28)" end="(130, 43)" leading="" trailing="" raw_val="length_eraseIdx" val="length_eraseIdx" full_name="List.length_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                                </OtherNode>
                                <AtomNode start="(130, 43)" end="(130, 44)" leading="" trailing=" " val=","/>
                                <OtherNode start="(130, 45)" end="(130, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(130, 45)" end="(130, 46)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                                <AtomNode start="(130, 46)" end="(130, 47)" leading="" trailing=" " val=","/>
                                <OtherNode start="(130, 48)" end="(130, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode start="(130, 48)" end="(130, 49)">
                                    <OtherNode start="(130, 48)" end="(130, 49)" kind="Lean.Parser.Tactic.simpPre">
                                      <AtomNode start="(130, 48)" end="(130, 49)" leading="" trailing="" val="↓"/>
                                    </OtherNode>
                                  </NullNode>
                                  <NullNode/>
                                  <IdentNode start="(130, 49)" end="(130, 58)" leading="" trailing="" raw_val="reduceIte" val="reduceIte"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(130, 58)" end="(130, 59)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(131, 5)" end="(131, 16)" kind="Lean.Parser.Tactic.rwSeq" state_before="case hl&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;⊢ l.length - 1 = if i &amp;lt; l.length then l.length - 1 else l.length" state_after="case hl.hc&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;⊢ i &amp;lt; l.length" tactic="rw [if_pos]">
                            <AtomNode start="(131, 5)" end="(131, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(131, 8)" end="(131, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(131, 8)" end="(131, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(131, 9)" end="(131, 15)">
                                <OtherNode start="(131, 9)" end="(131, 15)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(131, 9)" end="(131, 15)" leading="" trailing="" raw_val="if_pos" val="if_pos" full_name="if_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(131, 15)" end="(131, 16)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(132, 5)" end="(132, 10)" kind="Lean.Parser.Tactic.omega" state_before="case hl.hc&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;⊢ i &amp;lt; l.length" state_after="no goals" tactic="omega">
                            <AtomNode start="(132, 5)" end="(132, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(133, 3)" end="(144, 17)" kind="Lean.cdot" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length) (h₂ : i_1 &amp;lt; (l.eraseIdx i).length),&#10;    ((l.eraseIdx (i + 1)).set i l[i + 1])[i_1] = (l.eraseIdx i)[i_1]" state_after="no goals" tactic="· intro n h₁ h₂&#10;  simp [getElem_set, getElem_eraseIdx]&#10;  split&#10;  · split&#10;    · omega&#10;    · simp_all&#10;  · split&#10;    · split&#10;      · rfl&#10;      · omega&#10;    · have t : ¬ n &amp;lt; i := by omega&#10;      simp [t]">
                    <OtherNode start="(133, 3)" end="(133, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(133, 3)" end="(133, 4)" kind="patternIgnore">
                        <OtherNode start="(133, 3)" end="(133, 4)" kind="token.«· »">
                          <AtomNode start="(133, 3)" end="(133, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(133, 5)" end="(144, 17)">
                      <TacticTacticseq1IndentedNode start="(133, 5)" end="(144, 17)">
                        <NullNode start="(133, 5)" end="(144, 17)">
                          <OtherNode start="(133, 5)" end="(133, 18)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;⊢ ∀ (i_1 : Nat) (h₁ : i_1 &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length) (h₂ : i_1 &amp;lt; (l.eraseIdx i).length),&#10;    ((l.eraseIdx (i + 1)).set i l[i + 1])[i_1] = (l.eraseIdx i)[i_1]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;⊢ ((l.eraseIdx (i + 1)).set i l[i + 1])[n] = (l.eraseIdx i)[n]" tactic="intro n h₁ h₂">
                            <AtomNode start="(133, 5)" end="(133, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(133, 11)" end="(133, 18)">
                              <IdentNode start="(133, 11)" end="(133, 12)" leading="" trailing=" " raw_val="n" val="n"/>
                              <IdentNode start="(133, 13)" end="(133, 15)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                              <IdentNode start="(133, 16)" end="(133, 18)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(134, 5)" end="(134, 41)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;⊢ ((l.eraseIdx (i + 1)).set i l[i + 1])[n] = (l.eraseIdx i)[n]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;⊢ (if i = n then l[i + 1] else if h' : n &amp;lt; i + 1 then l[n] else l[n + 1]) = if h' : n &amp;lt; i then l[n] else l[n + 1]" tactic="simp [getElem_set, getElem_eraseIdx]">
                            <AtomNode start="(134, 5)" end="(134, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(134, 10)" end="(134, 41)">
                              <AtomNode start="(134, 10)" end="(134, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(134, 11)" end="(134, 40)">
                                <OtherNode start="(134, 11)" end="(134, 22)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(134, 11)" end="(134, 22)" leading="" trailing="" raw_val="getElem_set" val="getElem_set" full_name="List.getElem_set" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(134, 22)" end="(134, 23)" leading="" trailing=" " val=","/>
                                <OtherNode start="(134, 24)" end="(134, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(134, 24)" end="(134, 40)" leading="" trailing="" raw_val="getElem_eraseIdx" val="getElem_eraseIdx" full_name="List.getElem_eraseIdx" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean" def_start="(52, 9)" def_end="(52, 25)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(134, 40)" end="(134, 41)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(135, 5)" end="(135, 10)" kind="Lean.Parser.Tactic.split" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;⊢ (if i = n then l[i + 1] else if h' : n &amp;lt; i + 1 then l[n] else l[n + 1]) = if h' : n &amp;lt; i then l[n] else l[n + 1]" state_after="case h.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝ : i = n&#10;⊢ l[i + 1] = if h' : n &amp;lt; i then l[n] else l[n + 1]&#10;&#10;case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝ : ¬i = n&#10;⊢ (if h' : n &amp;lt; i + 1 then l[n] else l[n + 1]) = if h' : n &amp;lt; i then l[n] else l[n + 1]" tactic="split">
                            <AtomNode start="(135, 5)" end="(135, 10)" leading="" trailing="&#10;    " val="split"/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(136, 5)" end="(138, 17)" kind="Lean.cdot" state_before="case h.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝ : i = n&#10;⊢ l[i + 1] = if h' : n &amp;lt; i then l[n] else l[n + 1]&#10;&#10;case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝ : ¬i = n&#10;⊢ (if h' : n &amp;lt; i + 1 then l[n] else l[n + 1]) = if h' : n &amp;lt; i then l[n] else l[n + 1]" state_after="case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝ : ¬i = n&#10;⊢ (if h' : n &amp;lt; i + 1 then l[n] else l[n + 1]) = if h' : n &amp;lt; i then l[n] else l[n + 1]" tactic="· split&#10;  · omega&#10;  · simp_all">
                            <OtherNode start="(136, 5)" end="(136, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(136, 5)" end="(136, 6)" kind="patternIgnore">
                                <OtherNode start="(136, 5)" end="(136, 6)" kind="token.«· »">
                                  <AtomNode start="(136, 5)" end="(136, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(136, 7)" end="(138, 17)">
                              <TacticTacticseq1IndentedNode start="(136, 7)" end="(138, 17)">
                                <NullNode start="(136, 7)" end="(138, 17)">
                                  <OtherNode start="(136, 7)" end="(136, 12)" kind="Lean.Parser.Tactic.split" state_before="case h.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝ : i = n&#10;⊢ l[i + 1] = if h' : n &amp;lt; i then l[n] else l[n + 1]" state_after="case h.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : i = n&#10;h✝ : n &amp;lt; i&#10;⊢ l[i + 1] = l[n]&#10;&#10;case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : i = n&#10;h✝ : ¬n &amp;lt; i&#10;⊢ l[i + 1] = l[n + 1]" tactic="split">
                                    <AtomNode start="(136, 7)" end="(136, 12)" leading="" trailing="&#10;      " val="split"/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(137, 7)" end="(137, 14)" kind="Lean.cdot" state_before="case h.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : i = n&#10;h✝ : n &amp;lt; i&#10;⊢ l[i + 1] = l[n]&#10;&#10;case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : i = n&#10;h✝ : ¬n &amp;lt; i&#10;⊢ l[i + 1] = l[n + 1]" state_after="case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : i = n&#10;h✝ : ¬n &amp;lt; i&#10;⊢ l[i + 1] = l[n + 1]" tactic="· omega">
                                    <OtherNode start="(137, 7)" end="(137, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(137, 7)" end="(137, 8)" kind="patternIgnore">
                                        <OtherNode start="(137, 7)" end="(137, 8)" kind="token.«· »">
                                          <AtomNode start="(137, 7)" end="(137, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(137, 9)" end="(137, 14)">
                                      <TacticTacticseq1IndentedNode start="(137, 9)" end="(137, 14)">
                                        <NullNode start="(137, 9)" end="(137, 14)">
                                          <OtherNode start="(137, 9)" end="(137, 14)" kind="Lean.Parser.Tactic.omega" state_before="case h.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : i = n&#10;h✝ : n &amp;lt; i&#10;⊢ l[i + 1] = l[n]" state_after="no goals" tactic="omega">
                                            <AtomNode start="(137, 9)" end="(137, 14)" leading="" trailing="&#10;      " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(138, 7)" end="(138, 17)" kind="Lean.cdot" state_before="case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : i = n&#10;h✝ : ¬n &amp;lt; i&#10;⊢ l[i + 1] = l[n + 1]" state_after="no goals" tactic="· simp_all">
                                    <OtherNode start="(138, 7)" end="(138, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(138, 7)" end="(138, 8)" kind="patternIgnore">
                                        <OtherNode start="(138, 7)" end="(138, 8)" kind="token.«· »">
                                          <AtomNode start="(138, 7)" end="(138, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(138, 9)" end="(138, 17)">
                                      <TacticTacticseq1IndentedNode start="(138, 9)" end="(138, 17)">
                                        <NullNode start="(138, 9)" end="(138, 17)">
                                          <OtherNode start="(138, 9)" end="(138, 17)" kind="Lean.Parser.Tactic.simpAll" state_before="case h.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : i = n&#10;h✝ : ¬n &amp;lt; i&#10;⊢ l[i + 1] = l[n + 1]" state_after="no goals" tactic="simp_all">
                                            <AtomNode start="(138, 9)" end="(138, 17)" leading="" trailing="&#10;    " val="simp_all"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(139, 5)" end="(144, 17)" kind="Lean.cdot" state_before="case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝ : ¬i = n&#10;⊢ (if h' : n &amp;lt; i + 1 then l[n] else l[n + 1]) = if h' : n &amp;lt; i then l[n] else l[n + 1]" state_after="no goals" tactic="· split&#10;  · split&#10;    · rfl&#10;    · omega&#10;  · have t : ¬ n &amp;lt; i := by omega&#10;    simp [t]">
                            <OtherNode start="(139, 5)" end="(139, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(139, 5)" end="(139, 6)" kind="patternIgnore">
                                <OtherNode start="(139, 5)" end="(139, 6)" kind="token.«· »">
                                  <AtomNode start="(139, 5)" end="(139, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(139, 7)" end="(144, 17)">
                              <TacticTacticseq1IndentedNode start="(139, 7)" end="(144, 17)">
                                <NullNode start="(139, 7)" end="(144, 17)">
                                  <OtherNode start="(139, 7)" end="(139, 12)" kind="Lean.Parser.Tactic.split" state_before="case h.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝ : ¬i = n&#10;⊢ (if h' : n &amp;lt; i + 1 then l[n] else l[n + 1]) = if h' : n &amp;lt; i then l[n] else l[n + 1]" state_after="case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : ¬i = n&#10;h✝ : n &amp;lt; i + 1&#10;⊢ l[n] = if h' : n &amp;lt; i then l[n] else l[n + 1]&#10;&#10;case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : ¬i = n&#10;h✝ : ¬n &amp;lt; i + 1&#10;⊢ l[n + 1] = if h' : n &amp;lt; i then l[n] else l[n + 1]" tactic="split">
                                    <AtomNode start="(139, 7)" end="(139, 12)" leading="" trailing="&#10;      " val="split"/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(140, 7)" end="(142, 16)" kind="Lean.cdot" state_before="case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : ¬i = n&#10;h✝ : n &amp;lt; i + 1&#10;⊢ l[n] = if h' : n &amp;lt; i then l[n] else l[n + 1]&#10;&#10;case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : ¬i = n&#10;h✝ : ¬n &amp;lt; i + 1&#10;⊢ l[n + 1] = if h' : n &amp;lt; i then l[n] else l[n + 1]" state_after="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : ¬i = n&#10;h✝ : ¬n &amp;lt; i + 1&#10;⊢ l[n + 1] = if h' : n &amp;lt; i then l[n] else l[n + 1]" tactic="· split&#10;  · rfl&#10;  · omega">
                                    <OtherNode start="(140, 7)" end="(140, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(140, 7)" end="(140, 8)" kind="patternIgnore">
                                        <OtherNode start="(140, 7)" end="(140, 8)" kind="token.«· »">
                                          <AtomNode start="(140, 7)" end="(140, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(140, 9)" end="(142, 16)">
                                      <TacticTacticseq1IndentedNode start="(140, 9)" end="(142, 16)">
                                        <NullNode start="(140, 9)" end="(142, 16)">
                                          <OtherNode start="(140, 9)" end="(140, 14)" kind="Lean.Parser.Tactic.split" state_before="case h.isFalse.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : ¬i = n&#10;h✝ : n &amp;lt; i + 1&#10;⊢ l[n] = if h' : n &amp;lt; i then l[n] else l[n + 1]" state_after="case h.isFalse.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝² : ¬i = n&#10;h✝¹ : n &amp;lt; i + 1&#10;h✝ : n &amp;lt; i&#10;⊢ l[n] = l[n]&#10;&#10;case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝² : ¬i = n&#10;h✝¹ : n &amp;lt; i + 1&#10;h✝ : ¬n &amp;lt; i&#10;⊢ l[n] = l[n + 1]" tactic="split">
                                            <AtomNode start="(140, 9)" end="(140, 14)" leading="" trailing="&#10;        " val="split"/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(141, 9)" end="(141, 14)" kind="Lean.cdot" state_before="case h.isFalse.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝² : ¬i = n&#10;h✝¹ : n &amp;lt; i + 1&#10;h✝ : n &amp;lt; i&#10;⊢ l[n] = l[n]&#10;&#10;case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝² : ¬i = n&#10;h✝¹ : n &amp;lt; i + 1&#10;h✝ : ¬n &amp;lt; i&#10;⊢ l[n] = l[n + 1]" state_after="case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝² : ¬i = n&#10;h✝¹ : n &amp;lt; i + 1&#10;h✝ : ¬n &amp;lt; i&#10;⊢ l[n] = l[n + 1]" tactic="· rfl">
                                            <OtherNode start="(141, 9)" end="(141, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(141, 9)" end="(141, 10)" kind="patternIgnore">
                                                <OtherNode start="(141, 9)" end="(141, 10)" kind="token.«· »">
                                                  <AtomNode start="(141, 9)" end="(141, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(141, 11)" end="(141, 14)">
                                              <TacticTacticseq1IndentedNode start="(141, 11)" end="(141, 14)">
                                                <NullNode start="(141, 11)" end="(141, 14)">
                                                  <OtherNode start="(141, 11)" end="(141, 14)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case h.isFalse.isTrue.isTrue&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝² : ¬i = n&#10;h✝¹ : n &amp;lt; i + 1&#10;h✝ : n &amp;lt; i&#10;⊢ l[n] = l[n]" state_after="no goals" tactic="rfl">
                                                    <AtomNode start="(141, 11)" end="(141, 14)" leading="" trailing="&#10;        " val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(142, 9)" end="(142, 16)" kind="Lean.cdot" state_before="case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝² : ¬i = n&#10;h✝¹ : n &amp;lt; i + 1&#10;h✝ : ¬n &amp;lt; i&#10;⊢ l[n] = l[n + 1]" state_after="no goals" tactic="· omega">
                                            <OtherNode start="(142, 9)" end="(142, 10)" kind="Lean.cdotTk">
                                              <OtherNode start="(142, 9)" end="(142, 10)" kind="patternIgnore">
                                                <OtherNode start="(142, 9)" end="(142, 10)" kind="token.«· »">
                                                  <AtomNode start="(142, 9)" end="(142, 10)" leading="" trailing=" " val="·"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <TacticTacticseqNode start="(142, 11)" end="(142, 16)">
                                              <TacticTacticseq1IndentedNode start="(142, 11)" end="(142, 16)">
                                                <NullNode start="(142, 11)" end="(142, 16)">
                                                  <OtherNode start="(142, 11)" end="(142, 16)" kind="Lean.Parser.Tactic.omega" state_before="case h.isFalse.isTrue.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝² : ¬i = n&#10;h✝¹ : n &amp;lt; i + 1&#10;h✝ : ¬n &amp;lt; i&#10;⊢ l[n] = l[n + 1]" state_after="no goals" tactic="omega">
                                                    <AtomNode start="(142, 11)" end="(142, 16)" leading="" trailing="&#10;      " val="omega"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(143, 7)" end="(144, 17)" kind="Lean.cdot" state_before="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : ¬i = n&#10;h✝ : ¬n &amp;lt; i + 1&#10;⊢ l[n + 1] = if h' : n &amp;lt; i then l[n] else l[n + 1]" state_after="no goals" tactic="· have t : ¬ n &amp;lt; i := by omega&#10;  simp [t]">
                                    <OtherNode start="(143, 7)" end="(143, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(143, 7)" end="(143, 8)" kind="patternIgnore">
                                        <OtherNode start="(143, 7)" end="(143, 8)" kind="token.«· »">
                                          <AtomNode start="(143, 7)" end="(143, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(143, 9)" end="(144, 17)">
                                      <TacticTacticseq1IndentedNode start="(143, 9)" end="(144, 17)">
                                        <NullNode start="(143, 9)" end="(144, 17)">
                                          <OtherNode start="(143, 9)" end="(143, 37)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : ¬i = n&#10;h✝ : ¬n &amp;lt; i + 1&#10;⊢ l[n + 1] = if h' : n &amp;lt; i then l[n] else l[n + 1]" state_after="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : ¬i = n&#10;h✝ : ¬n &amp;lt; i + 1&#10;t : ¬n &amp;lt; i&#10;⊢ l[n + 1] = if h' : n &amp;lt; i then l[n] else l[n + 1]" tactic="have t : ¬ n &amp;lt; i := by omega">
                                            <AtomNode start="(143, 9)" end="(143, 13)" leading="" trailing=" " val="have"/>
                                            <OtherNode start="(143, 14)" end="(143, 37)" kind="Lean.Parser.Term.haveDecl">
                                              <OtherNode start="(143, 14)" end="(143, 37)" kind="Lean.Parser.Term.haveIdDecl">
                                                <OtherNode start="(143, 14)" end="(143, 15)" kind="Lean.Parser.Term.haveId">
                                                  <IdentNode start="(143, 14)" end="(143, 15)" leading="" trailing=" " raw_val="t" val="t"/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode start="(143, 16)" end="(143, 25)">
                                                  <TermTypespecNode start="(143, 16)" end="(143, 25)">
                                                    <AtomNode start="(143, 16)" end="(143, 17)" leading="" trailing=" " val=":"/>
                                                    <OtherNode start="(143, 18)" end="(143, 25)" kind="«term¬_»">
                                                      <AtomNode start="(143, 18)" end="(143, 19)" leading="" trailing=" " val="¬"/>
                                                      <OtherNode start="(143, 20)" end="(143, 25)" kind="«term_&amp;lt;_»">
                                                        <IdentNode start="(143, 20)" end="(143, 21)" leading="" trailing=" " raw_val="n" val="n"/>
                                                        <AtomNode start="(143, 22)" end="(143, 23)" leading="" trailing=" " val="&amp;lt;"/>
                                                        <IdentNode start="(143, 24)" end="(143, 25)" leading="" trailing=" " raw_val="i" val="i"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </TermTypespecNode>
                                                </NullNode>
                                                <AtomNode start="(143, 26)" end="(143, 28)" leading="" trailing=" " val=":="/>
                                                <TermBytacticNode start="(143, 29)" end="(143, 37)">
                                                  <AtomNode start="(143, 29)" end="(143, 31)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(143, 32)" end="(143, 37)">
                                                    <TacticTacticseq1IndentedNode start="(143, 32)" end="(143, 37)">
                                                      <NullNode start="(143, 32)" end="(143, 37)">
                                                        <OtherNode start="(143, 32)" end="(143, 37)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : ¬i = n&#10;h✝ : ¬n &amp;lt; i + 1&#10;⊢ ¬n &amp;lt; i" state_after="no goals" tactic="omega">
                                                          <AtomNode start="(143, 32)" end="(143, 37)" leading="" trailing="&#10;        " val="omega"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(144, 9)" end="(144, 17)" kind="Lean.Parser.Tactic.simp" state_before="case h.isFalse.isFalse&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i + 1 &amp;lt; l.length&#10;n : Nat&#10;h₁ : n &amp;lt; ((l.eraseIdx (i + 1)).set i l[i + 1]).length&#10;h₂ : n &amp;lt; (l.eraseIdx i).length&#10;h✝¹ : ¬i = n&#10;h✝ : ¬n &amp;lt; i + 1&#10;t : ¬n &amp;lt; i&#10;⊢ l[n + 1] = if h' : n &amp;lt; i then l[n] else l[n + 1]" state_after="no goals" tactic="simp [t]">
                                            <AtomNode start="(144, 9)" end="(144, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(144, 14)" end="(144, 17)">
                                              <AtomNode start="(144, 14)" end="(144, 15)" leading="" trailing="" val="["/>
                                              <NullNode start="(144, 15)" end="(144, 16)">
                                                <OtherNode start="(144, 15)" end="(144, 16)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(144, 15)" end="(144, 16)" leading="" trailing="" raw_val="t" val="t"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(144, 16)" end="(144, 17)" leading="" trailing="&#10;&#10;" val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(146, 1)" end="(153, 13)" name="eraseIdx_length_sub_one" full_name="List.eraseIdx_length_sub_one">
      <CommandDeclmodifiersNode start="(146, 1)" end="(146, 8)">
        <NullNode/>
        <NullNode start="(146, 1)" end="(146, 8)">
          <OtherNode start="(146, 1)" end="(146, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(146, 1)" end="(146, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(146, 3)" end="(146, 7)">
              <OtherNode start="(146, 3)" end="(146, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(146, 3)" end="(146, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(146, 3)" end="(146, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(146, 7)" end="(146, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(146, 9)" end="(153, 13)" name="eraseIdx_length_sub_one" full_name="List.eraseIdx_length_sub_one" _is_private_decl="False">
        <AtomNode start="(146, 9)" end="(146, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(146, 17)" end="(146, 40)">
          <IdentNode start="(146, 17)" end="(146, 40)" leading="" trailing=" " raw_val="eraseIdx_length_sub_one" val="eraseIdx_length_sub_one"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(146, 41)" end="(147, 45)">
          <NullNode start="(146, 41)" end="(146, 53)">
            <OtherNode start="(146, 41)" end="(146, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(146, 41)" end="(146, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(146, 42)" end="(146, 43)">
                <IdentNode start="(146, 42)" end="(146, 43)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(146, 44)" end="(146, 52)">
                <AtomNode start="(146, 44)" end="(146, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(146, 46)" end="(146, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(146, 46)" end="(146, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(146, 51)" end="(146, 52)">
                    <IdentNode start="(146, 51)" end="(146, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(146, 52)" end="(146, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(146, 54)" end="(147, 45)">
            <AtomNode start="(146, 54)" end="(146, 55)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(147, 5)" end="(147, 45)" kind="«term_=_»">
              <OtherNode start="(147, 5)" end="(147, 32)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(147, 5)" end="(147, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(147, 6)" end="(147, 31)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(147, 6)" end="(147, 16)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                  <NullNode start="(147, 17)" end="(147, 31)">
                    <OtherNode start="(147, 17)" end="(147, 31)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(147, 17)" end="(147, 18)" leading="" trailing="" val="("/>
                      <OtherNode start="(147, 18)" end="(147, 30)" kind="«term_-_»">
                        <IdentNode start="(147, 18)" end="(147, 26)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                        <AtomNode start="(147, 27)" end="(147, 28)" leading="" trailing=" " val="-"/>
                        <OtherNode start="(147, 29)" end="(147, 30)" kind="num">
                          <AtomNode start="(147, 29)" end="(147, 30)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(147, 30)" end="(147, 31)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(147, 31)" end="(147, 32)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(147, 33)" end="(147, 34)" leading="" trailing=" " val="="/>
              <IdentNode start="(147, 35)" end="(147, 45)" leading="" trailing=" " raw_val="l.dropLast" val="l.dropLast"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(147, 46)" end="(153, 13)">
          <AtomNode start="(147, 46)" end="(147, 48)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(147, 49)" end="(153, 13)">
            <AtomNode start="(147, 49)" end="(147, 51)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(148, 3)" end="(153, 13)">
              <TacticTacticseq1IndentedNode start="(148, 3)" end="(153, 13)">
                <NullNode start="(148, 3)" end="(153, 13)">
                  <OtherNode start="(148, 3)" end="(148, 20)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;l : List α&#10;⊢ l.eraseIdx (l.length - 1) = l.dropLast" state_after="case hl&#10;α : Type u_1&#10;l : List α&#10;⊢ (l.eraseIdx (l.length - 1)).length = l.dropLast.length&#10;&#10;case h&#10;α : Type u_1&#10;l : List α&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; (l.eraseIdx (l.length - 1)).length) (h₂ : i &amp;lt; l.dropLast.length),&#10;    (l.eraseIdx (l.length - 1))[i] = l.dropLast[i]" tactic="apply ext_getElem">
                    <AtomNode start="(148, 3)" end="(148, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(148, 9)" end="(148, 20)" leading="" trailing="&#10;  " raw_val="ext_getElem" val="ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(149, 3)" end="(150, 10)" kind="Lean.cdot" state_before="case hl&#10;α : Type u_1&#10;l : List α&#10;⊢ (l.eraseIdx (l.length - 1)).length = l.dropLast.length&#10;&#10;case h&#10;α : Type u_1&#10;l : List α&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; (l.eraseIdx (l.length - 1)).length) (h₂ : i &amp;lt; l.dropLast.length),&#10;    (l.eraseIdx (l.length - 1))[i] = l.dropLast[i]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; (l.eraseIdx (l.length - 1)).length) (h₂ : i &amp;lt; l.dropLast.length),&#10;    (l.eraseIdx (l.length - 1))[i] = l.dropLast[i]" tactic="· simp [length_eraseIdx]&#10;  omega">
                    <OtherNode start="(149, 3)" end="(149, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(149, 3)" end="(149, 4)" kind="patternIgnore">
                        <OtherNode start="(149, 3)" end="(149, 4)" kind="token.«· »">
                          <AtomNode start="(149, 3)" end="(149, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(149, 5)" end="(150, 10)">
                      <TacticTacticseq1IndentedNode start="(149, 5)" end="(150, 10)">
                        <NullNode start="(149, 5)" end="(150, 10)">
                          <OtherNode start="(149, 5)" end="(149, 27)" kind="Lean.Parser.Tactic.simp" state_before="case hl&#10;α : Type u_1&#10;l : List α&#10;⊢ (l.eraseIdx (l.length - 1)).length = l.dropLast.length" state_after="case hl&#10;α : Type u_1&#10;l : List α&#10;⊢ l.length ≤ l.length - 1 → l.length = l.length - 1" tactic="simp [length_eraseIdx]">
                            <AtomNode start="(149, 5)" end="(149, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(149, 10)" end="(149, 27)">
                              <AtomNode start="(149, 10)" end="(149, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(149, 11)" end="(149, 26)">
                                <OtherNode start="(149, 11)" end="(149, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(149, 11)" end="(149, 26)" leading="" trailing="" raw_val="length_eraseIdx" val="length_eraseIdx" full_name="List.length_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(149, 26)" end="(149, 27)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(150, 5)" end="(150, 10)" kind="Lean.Parser.Tactic.omega" state_before="case hl&#10;α : Type u_1&#10;l : List α&#10;⊢ l.length ≤ l.length - 1 → l.length = l.length - 1" state_after="no goals" tactic="omega">
                            <AtomNode start="(150, 5)" end="(150, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(151, 3)" end="(153, 13)" kind="Lean.cdot" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; (l.eraseIdx (l.length - 1)).length) (h₂ : i &amp;lt; l.dropLast.length),&#10;    (l.eraseIdx (l.length - 1))[i] = l.dropLast[i]" state_after="no goals" tactic="· intro n h₁ h₂&#10;  rw [getElem_eraseIdx_of_lt, getElem_dropLast]&#10;  simp_all">
                    <OtherNode start="(151, 3)" end="(151, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(151, 3)" end="(151, 4)" kind="patternIgnore">
                        <OtherNode start="(151, 3)" end="(151, 4)" kind="token.«· »">
                          <AtomNode start="(151, 3)" end="(151, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(151, 5)" end="(153, 13)">
                      <TacticTacticseq1IndentedNode start="(151, 5)" end="(153, 13)">
                        <NullNode start="(151, 5)" end="(153, 13)">
                          <OtherNode start="(151, 5)" end="(151, 18)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; (l.eraseIdx (l.length - 1)).length) (h₂ : i &amp;lt; l.dropLast.length),&#10;    (l.eraseIdx (l.length - 1))[i] = l.dropLast[i]" state_after="case h&#10;α : Type u_1&#10;l : List α&#10;n : Nat&#10;h₁ : n &amp;lt; (l.eraseIdx (l.length - 1)).length&#10;h₂ : n &amp;lt; l.dropLast.length&#10;⊢ (l.eraseIdx (l.length - 1))[n] = l.dropLast[n]" tactic="intro n h₁ h₂">
                            <AtomNode start="(151, 5)" end="(151, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(151, 11)" end="(151, 18)">
                              <IdentNode start="(151, 11)" end="(151, 12)" leading="" trailing=" " raw_val="n" val="n"/>
                              <IdentNode start="(151, 13)" end="(151, 15)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                              <IdentNode start="(151, 16)" end="(151, 18)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(152, 5)" end="(152, 50)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h&#10;α : Type u_1&#10;l : List α&#10;n : Nat&#10;h₁ : n &amp;lt; (l.eraseIdx (l.length - 1)).length&#10;h₂ : n &amp;lt; l.dropLast.length&#10;⊢ (l.eraseIdx (l.length - 1))[n] = l.dropLast[n]" state_after="case h.h'&#10;α : Type u_1&#10;l : List α&#10;n : Nat&#10;h₁ : n &amp;lt; (l.eraseIdx (l.length - 1)).length&#10;h₂ : n &amp;lt; l.dropLast.length&#10;⊢ n &amp;lt; l.length - 1" tactic="rw [getElem_eraseIdx_of_lt, getElem_dropLast]">
                            <AtomNode start="(152, 5)" end="(152, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(152, 8)" end="(152, 50)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(152, 8)" end="(152, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(152, 9)" end="(152, 49)">
                                <OtherNode start="(152, 9)" end="(152, 31)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(152, 9)" end="(152, 31)" leading="" trailing="" raw_val="getElem_eraseIdx_of_lt" val="getElem_eraseIdx_of_lt" full_name="List.getElem_eraseIdx_of_lt" mod_name="Init.Data.List.Nat.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Erase.lean" def_start="(61, 9)" def_end="(61, 31)"/>
                                </OtherNode>
                                <AtomNode start="(152, 31)" end="(152, 32)" leading="" trailing=" " val=","/>
                                <OtherNode start="(152, 33)" end="(152, 49)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(152, 33)" end="(152, 49)" leading="" trailing="" raw_val="getElem_dropLast" val="getElem_dropLast" full_name="List.getElem_dropLast" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(152, 49)" end="(152, 50)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(153, 5)" end="(153, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case h.h'&#10;α : Type u_1&#10;l : List α&#10;n : Nat&#10;h₁ : n &amp;lt; (l.eraseIdx (l.length - 1)).length&#10;h₂ : n &amp;lt; l.dropLast.length&#10;⊢ n &amp;lt; l.length - 1" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(153, 5)" end="(153, 13)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(155, 1)" end="(155, 9)" name="List">
      <AtomNode start="(155, 1)" end="(155, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(155, 5)" end="(155, 9)">
        <IdentNode start="(155, 5)" end="(155, 9)" leading="" trailing="&#10;" raw_val="List" val="List"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(12, 38)" end="(13, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(13, 39)" end="(15, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
  </Comments>
</TracedFile>
