<TracedFile path="src/lean/Init/Data/List/MapIdx.lean" md5="3e98bb667a4cdb01c6d902e73819ee3c">
  <FileNode start="(1, 1)" end="(532, 9)">
    <ModuleHeaderNode start="(7, 1)" end="(14, 31)">
      <NullNode start="(7, 1)" end="(7, 7)">
        <OtherNode start="(7, 1)" end="(7, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(7, 1)" end="(7, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(9, 8)">
        <ModulePreludeNode start="(9, 1)" end="(9, 8)">
          <AtomNode start="(9, 1)" end="(9, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(10, 1)" end="(14, 31)">
        <ModuleImportNode start="(10, 1)" end="(10, 30)" module="Init.Data.Array.Lemmas" path="src/lean/Init/Data/Array/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 30)" leading="" trailing="&#10;" raw_val="Init.Data.Array.Lemmas" val="Init.Data.Array.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 32)" module="Init.Data.List.Nat.Range" path="src/lean/Init/Data/List/Nat/Range.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 32)" leading="" trailing="&#10;" raw_val="Init.Data.List.Nat.Range" val="Init.Data.List.Nat.Range"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(12, 1)" end="(12, 27)" module="Init.Data.List.OfFn" path="src/lean/Init/Data/List/OfFn.lean">
          <NullNode/>
          <AtomNode start="(12, 1)" end="(12, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(12, 8)" end="(12, 27)" leading="" trailing="&#10;" raw_val="Init.Data.List.OfFn" val="Init.Data.List.OfFn"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(13, 1)" end="(13, 28)" module="Init.Data.Fin.Lemmas" path="src/lean/Init/Data/Fin/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(13, 1)" end="(13, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(13, 8)" end="(13, 28)" leading="" trailing="&#10;" raw_val="Init.Data.Fin.Lemmas" val="Init.Data.Fin.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(14, 1)" end="(14, 31)" module="Init.Data.Option.Attach" path="src/lean/Init/Data/Option/Attach.lean">
          <NullNode/>
          <AtomNode start="(14, 1)" end="(14, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(14, 8)" end="(14, 31)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.Option.Attach" val="Init.Data.Option.Attach"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <OtherNode start="(16, 1)" end="(16, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(16, 1)" end="(16, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(16, 12)" end="(16, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(16, 33)" end="(16, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(17, 1)" end="(17, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(17, 1)" end="(17, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(17, 12)" end="(17, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(17, 34)" end="(17, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(19, 1)" end="(19, 15)" name="List">
      <AtomNode start="(19, 1)" end="(19, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(19, 11)" end="(19, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandModuledocNode start="(21, 1)" end="(21, 35)" comment="## Operations using indexes -/">
      <AtomNode start="(21, 1)" end="(21, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(21, 5)" end="(21, 35)" leading="" trailing="&#10;&#10;" val="## Operations using indexes -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(23, 1)" end="(38, 82)" name="mapFinIdx" full_name="List.mapFinIdx">
      <CommandDeclmodifiersNode start="(23, 1)" end="(30, 10)">
        <NullNode start="(23, 1)" end="(29, 3)">
          <CommandDoccommentNode start="(23, 1)" end="(29, 3)" comment="Applies a function to each element of the list along with the index at which that element is found,&#10;returning the list of results. In addition to the index, the function is also provided with a proof&#10;that the index is valid.&#10;&#10;`List.mapIdx` is a variant that does not provide the function with evidence that the index is valid.&#10;-/">
            <AtomNode start="(23, 1)" end="(23, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(24, 1)" end="(29, 3)" leading="" trailing="&#10;" val="Applies a function to each element of the list along with the index at which that element is found,&#10;returning the list of results. In addition to the index, the function is also provided with a proof&#10;that the index is valid.&#10;&#10;`List.mapIdx` is a variant that does not provide the function with evidence that the index is valid.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(30, 1)" end="(30, 10)">
          <OtherNode start="(30, 1)" end="(30, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(30, 1)" end="(30, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(30, 3)" end="(30, 9)">
              <OtherNode start="(30, 3)" end="(30, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(30, 3)" end="(30, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(30, 3)" end="(30, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(30, 9)" end="(30, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(30, 11)" end="(38, 82)" name="mapFinIdx">
        <AtomNode start="(30, 11)" end="(30, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(30, 15)" end="(30, 24)">
          <IdentNode start="(30, 15)" end="(30, 24)" leading="" trailing=" " raw_val="mapFinIdx" val="mapFinIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(30, 25)" end="(30, 93)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(30, 25)" end="(30, 84)">
            <TermExplicitbinderNode start="(30, 25)" end="(30, 38)">
              <AtomNode start="(30, 25)" end="(30, 26)" leading="" trailing="" val="("/>
              <NullNode start="(30, 26)" end="(30, 28)">
                <IdentNode start="(30, 26)" end="(30, 28)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(30, 29)" end="(30, 37)">
                <AtomNode start="(30, 29)" end="(30, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(30, 31)" end="(30, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(30, 31)" end="(30, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(30, 36)" end="(30, 37)">
                    <IdentNode start="(30, 36)" end="(30, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(30, 37)" end="(30, 38)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(30, 39)" end="(30, 84)">
              <AtomNode start="(30, 39)" end="(30, 40)" leading="" trailing="" val="("/>
              <NullNode start="(30, 40)" end="(30, 41)">
                <IdentNode start="(30, 40)" end="(30, 41)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(30, 42)" end="(30, 83)">
                <AtomNode start="(30, 42)" end="(30, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(30, 44)" end="(30, 83)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(30, 44)" end="(30, 53)">
                    <AtomNode start="(30, 44)" end="(30, 45)" leading="" trailing="" val="("/>
                    <NullNode start="(30, 45)" end="(30, 46)">
                      <IdentNode start="(30, 45)" end="(30, 46)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(30, 47)" end="(30, 52)">
                      <AtomNode start="(30, 47)" end="(30, 48)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(30, 49)" end="(30, 52)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(30, 52)" end="(30, 53)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(30, 54)" end="(30, 55)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(30, 56)" end="(30, 83)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(30, 56)" end="(30, 57)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(30, 58)" end="(30, 59)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(30, 60)" end="(30, 83)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(30, 60)" end="(30, 79)">
                        <AtomNode start="(30, 60)" end="(30, 61)" leading="" trailing="" val="("/>
                        <NullNode start="(30, 61)" end="(30, 62)">
                          <IdentNode start="(30, 61)" end="(30, 62)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(30, 63)" end="(30, 78)">
                          <AtomNode start="(30, 63)" end="(30, 64)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(30, 65)" end="(30, 78)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(30, 65)" end="(30, 66)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(30, 67)" end="(30, 68)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(30, 69)" end="(30, 78)" leading="" trailing="" raw_val="as.length" val="as.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(30, 78)" end="(30, 79)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(30, 80)" end="(30, 81)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(30, 82)" end="(30, 83)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(30, 83)" end="(30, 84)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(30, 85)" end="(30, 93)">
            <TermTypespecNode start="(30, 85)" end="(30, 93)">
              <AtomNode start="(30, 85)" end="(30, 86)" leading="" trailing=" " val=":"/>
              <OtherNode start="(30, 87)" end="(30, 93)" kind="Lean.Parser.Term.app">
                <IdentNode start="(30, 87)" end="(30, 91)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(30, 92)" end="(30, 93)">
                  <IdentNode start="(30, 92)" end="(30, 93)" leading="" trailing=" " raw_val="β" val="β"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(30, 94)" end="(38, 82)">
          <AtomNode start="(30, 94)" end="(30, 96)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(31, 3)" end="(31, 22)" kind="Lean.Parser.Term.app">
            <IdentNode start="(31, 3)" end="(31, 5)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(31, 6)" end="(31, 22)">
              <IdentNode start="(31, 6)" end="(31, 8)" leading="" trailing=" " raw_val="as" val="as"/>
              <OtherNode start="(31, 9)" end="(31, 12)" kind="«term#[_,]»">
                <AtomNode start="(31, 9)" end="(31, 11)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(31, 11)" end="(31, 12)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <OtherNode start="(31, 13)" end="(31, 22)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(31, 13)" end="(31, 14)" leading="" trailing="" val="("/>
                <TermBytacticNode start="(31, 14)" end="(31, 21)">
                  <AtomNode start="(31, 14)" end="(31, 16)" leading="" trailing=" " val="by"/>
                  <TacticTacticseqNode start="(31, 17)" end="(31, 21)">
                    <TacticTacticseq1IndentedNode start="(31, 17)" end="(31, 21)">
                      <NullNode start="(31, 17)" end="(31, 21)">
                        <OtherNode start="(31, 17)" end="(31, 21)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.32&#10;β : Type ?u.53&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;⊢ as.length + #[].size = as.length" state_after="no goals" tactic="simp">
                          <AtomNode start="(31, 17)" end="(31, 21)" leading="" trailing="" val="simp"/>
                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <NullNode/>
                          <NullNode/>
                          <NullNode/>
                        </OtherNode>
                      </NullNode>
                    </TacticTacticseq1IndentedNode>
                  </TacticTacticseqNode>
                </TermBytacticNode>
                <AtomNode start="(31, 21)" end="(31, 22)" leading="" trailing="&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(32, 1)" end="(38, 82)">
            <OtherNode start="(32, 1)" end="(38, 82)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(32, 1)" end="(32, 6)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(33, 3)" end="(38, 82)">
                <OtherNode start="(33, 3)" end="(38, 82)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(33, 3)" end="(34, 80)">
                    <CommandDoccommentNode start="(33, 3)" end="(34, 80)" comment="Auxiliary for `mapFinIdx`:&#10;  `mapFinIdx.go [a₀, a₁, ...] acc = acc.toList ++ [f 0 a₀ ⋯, f 1 a₁ ⋯, ...]` -/">
                      <AtomNode start="(33, 3)" end="(33, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(33, 7)" end="(34, 80)" leading="" trailing="&#10;  " val="Auxiliary for `mapFinIdx`:&#10;  `mapFinIdx.go [a₀, a₁, ...] acc = acc.toList ++ [f 0 a₀ ⋯, f 1 a₁ ⋯, ...]` -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode start="(35, 3)" end="(35, 16)">
                    <OtherNode start="(35, 3)" end="(35, 16)" kind="Lean.Parser.Term.attributes">
                      <AtomNode start="(35, 3)" end="(35, 5)" leading="" trailing="" val="@["/>
                      <NullNode start="(35, 5)" end="(35, 15)">
                        <OtherNode start="(35, 5)" end="(35, 15)" kind="Lean.Parser.Term.attrInstance">
                          <TermAttrkindNode>
                            <NullNode/>
                          </TermAttrkindNode>
                          <OtherNode start="(35, 5)" end="(35, 15)" kind="Lean.Parser.Attr.specialize">
                            <AtomNode start="(35, 5)" end="(35, 15)" leading="" trailing="" val="specialize"/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(35, 15)" end="(35, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                  <OtherNode start="(35, 17)" end="(38, 82)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(35, 17)" end="(38, 82)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(35, 17)" end="(35, 19)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(35, 20)" end="(35, 97)">
                        <TermTypespecNode start="(35, 20)" end="(35, 97)">
                          <AtomNode start="(35, 20)" end="(35, 21)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(35, 22)" end="(35, 97)" kind="Lean.Parser.Term.depArrow">
                            <TermExplicitbinderNode start="(35, 22)" end="(35, 35)">
                              <AtomNode start="(35, 22)" end="(35, 23)" leading="" trailing="" val="("/>
                              <NullNode start="(35, 23)" end="(35, 25)">
                                <IdentNode start="(35, 23)" end="(35, 25)" leading="" trailing=" " raw_val="bs" val="bs"/>
                              </NullNode>
                              <NullNode start="(35, 26)" end="(35, 34)">
                                <AtomNode start="(35, 26)" end="(35, 27)" leading="" trailing=" " val=":"/>
                                <OtherNode start="(35, 28)" end="(35, 34)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(35, 28)" end="(35, 32)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(35, 33)" end="(35, 34)">
                                    <IdentNode start="(35, 33)" end="(35, 34)" leading="" trailing="" raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(35, 34)" end="(35, 35)" leading="" trailing=" " val=")"/>
                            </TermExplicitbinderNode>
                            <AtomNode start="(35, 36)" end="(35, 37)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(35, 38)" end="(35, 97)" kind="Lean.Parser.Term.depArrow">
                              <TermExplicitbinderNode start="(35, 38)" end="(35, 53)">
                                <AtomNode start="(35, 38)" end="(35, 39)" leading="" trailing="" val="("/>
                                <NullNode start="(35, 39)" end="(35, 42)">
                                  <IdentNode start="(35, 39)" end="(35, 42)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                </NullNode>
                                <NullNode start="(35, 43)" end="(35, 52)">
                                  <AtomNode start="(35, 43)" end="(35, 44)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(35, 45)" end="(35, 52)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(35, 45)" end="(35, 50)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(35, 51)" end="(35, 52)">
                                      <IdentNode start="(35, 51)" end="(35, 52)" leading="" trailing="" raw_val="β" val="β"/>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(35, 52)" end="(35, 53)" leading="" trailing=" " val=")"/>
                              </TermExplicitbinderNode>
                              <AtomNode start="(35, 54)" end="(35, 55)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(35, 56)" end="(35, 97)" kind="Lean.Parser.Term.arrow">
                                <OtherNode start="(35, 56)" end="(35, 88)" kind="«term_=_»">
                                  <OtherNode start="(35, 56)" end="(35, 76)" kind="«term_+_»">
                                    <IdentNode start="(35, 56)" end="(35, 65)" leading="" trailing=" " raw_val="bs.length" val="bs.length"/>
                                    <AtomNode start="(35, 66)" end="(35, 67)" leading="" trailing=" " val="+"/>
                                    <IdentNode start="(35, 68)" end="(35, 76)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
                                  </OtherNode>
                                  <AtomNode start="(35, 77)" end="(35, 78)" leading="" trailing=" " val="="/>
                                  <IdentNode start="(35, 79)" end="(35, 88)" leading="" trailing=" " raw_val="as.length" val="as.length"/>
                                </OtherNode>
                                <AtomNode start="(35, 89)" end="(35, 90)" leading="" trailing=" " val="→"/>
                                <OtherNode start="(35, 91)" end="(35, 97)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(35, 91)" end="(35, 95)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(35, 96)" end="(35, 97)">
                                    <IdentNode start="(35, 96)" end="(35, 97)" leading="" trailing="&#10;  " raw_val="β" val="β"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(36, 3)" end="(38, 82)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(36, 3)" end="(38, 82)">
                          <OtherNode start="(36, 3)" end="(36, 29)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(36, 3)" end="(36, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(36, 5)" end="(36, 15)">
                              <NullNode start="(36, 5)" end="(36, 15)">
                                <OtherNode start="(36, 5)" end="(36, 7)" kind="«term[_]»">
                                  <AtomNode start="(36, 5)" end="(36, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(36, 6)" end="(36, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(36, 7)" end="(36, 8)" leading="" trailing=" " val=","/>
                                <IdentNode start="(36, 9)" end="(36, 12)" leading="" trailing="" raw_val="acc" val="acc"/>
                                <AtomNode start="(36, 12)" end="(36, 13)" leading="" trailing=" " val=","/>
                                <IdentNode start="(36, 14)" end="(36, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(36, 16)" end="(36, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(36, 19)" end="(36, 29)" leading="" trailing="&#10;  " raw_val="acc.toList" val="acc.toList"/>
                          </OtherNode>
                          <OtherNode start="(37, 3)" end="(38, 82)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(37, 3)" end="(37, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(37, 5)" end="(37, 20)">
                              <NullNode start="(37, 5)" end="(37, 20)">
                                <OtherNode start="(37, 5)" end="(37, 12)" kind="«term_::_»">
                                  <IdentNode start="(37, 5)" end="(37, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <AtomNode start="(37, 7)" end="(37, 9)" leading="" trailing=" " val="::"/>
                                  <IdentNode start="(37, 10)" end="(37, 12)" leading="" trailing="" raw_val="as" val="as"/>
                                </OtherNode>
                                <AtomNode start="(37, 12)" end="(37, 13)" leading="" trailing=" " val=","/>
                                <IdentNode start="(37, 14)" end="(37, 17)" leading="" trailing="" raw_val="acc" val="acc"/>
                                <AtomNode start="(37, 17)" end="(37, 18)" leading="" trailing=" " val=","/>
                                <IdentNode start="(37, 19)" end="(37, 20)" leading="" trailing=" " raw_val="h" val="h"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(37, 21)" end="(37, 23)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                            <OtherNode start="(38, 5)" end="(38, 82)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(38, 5)" end="(38, 7)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode start="(38, 8)" end="(38, 82)">
                                <IdentNode start="(38, 8)" end="(38, 10)" leading="" trailing=" " raw_val="as" val="as"/>
                                <OtherNode start="(38, 11)" end="(38, 58)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(38, 11)" end="(38, 12)" leading="" trailing="" val="("/>
                                  <OtherNode start="(38, 12)" end="(38, 57)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(38, 12)" end="(38, 20)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                    <NullNode start="(38, 21)" end="(38, 57)">
                                      <OtherNode start="(38, 21)" end="(38, 57)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(38, 21)" end="(38, 22)" leading="" trailing="" val="("/>
                                        <OtherNode start="(38, 22)" end="(38, 56)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(38, 22)" end="(38, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                                          <NullNode start="(38, 24)" end="(38, 56)">
                                            <IdentNode start="(38, 24)" end="(38, 32)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
                                            <IdentNode start="(38, 33)" end="(38, 34)" leading="" trailing=" " raw_val="a" val="a"/>
                                            <OtherNode start="(38, 35)" end="(38, 56)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(38, 35)" end="(38, 36)" leading="" trailing="" val="("/>
                                              <TermBytacticNode start="(38, 36)" end="(38, 55)">
                                                <AtomNode start="(38, 36)" end="(38, 38)" leading="" trailing=" " val="by"/>
                                                <TacticTacticseqNode start="(38, 39)" end="(38, 55)">
                                                  <TacticTacticseq1IndentedNode start="(38, 39)" end="(38, 55)">
                                                    <NullNode start="(38, 39)" end="(38, 55)">
                                                      <OtherNode start="(38, 39)" end="(38, 48)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.32&#10;β : Type ?u.53&#10;as✝ : List α&#10;f : (i : Nat) → α → i &amp;lt; as✝.length → β&#10;a : α&#10;as : List α&#10;acc : Array β&#10;h : (a :: as).length + acc.size = as✝.length&#10;⊢ acc.size &amp;lt; as✝.length" state_after="α : Type ?u.32&#10;β : Type ?u.53&#10;as✝ : List α&#10;f : (i : Nat) → α → i &amp;lt; as✝.length → β&#10;a : α&#10;as : List α&#10;acc : Array β&#10;h : as.length + 1 + acc.size = as✝.length&#10;⊢ acc.size &amp;lt; as✝.length" tactic="simp at h">
                                                        <AtomNode start="(38, 39)" end="(38, 43)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(38, 44)" end="(38, 48)">
                                                          <OtherNode start="(38, 44)" end="(38, 48)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(38, 44)" end="(38, 46)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(38, 47)" end="(38, 48)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(38, 47)" end="(38, 48)">
                                                            <IdentNode start="(38, 47)" end="(38, 48)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <AtomNode start="(38, 48)" end="(38, 49)" leading="" trailing=" " val=";"/>
                                                      <OtherNode start="(38, 50)" end="(38, 55)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.32&#10;β : Type ?u.53&#10;as✝ : List α&#10;f : (i : Nat) → α → i &amp;lt; as✝.length → β&#10;a : α&#10;as : List α&#10;acc : Array β&#10;h : as.length + 1 + acc.size = as✝.length&#10;⊢ acc.size &amp;lt; as✝.length" state_after="no goals" tactic="omega">
                                                        <AtomNode start="(38, 50)" end="(38, 55)" leading="" trailing="" val="omega"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </TermBytacticNode>
                                              <AtomNode start="(38, 55)" end="(38, 56)" leading="" trailing="" val=")"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(38, 56)" end="(38, 57)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(38, 57)" end="(38, 58)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <OtherNode start="(38, 59)" end="(38, 82)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(38, 59)" end="(38, 60)" leading="" trailing="" val="("/>
                                  <TermBytacticNode start="(38, 60)" end="(38, 81)">
                                    <AtomNode start="(38, 60)" end="(38, 62)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(38, 63)" end="(38, 81)">
                                      <TacticTacticseq1IndentedNode start="(38, 63)" end="(38, 81)">
                                        <NullNode start="(38, 63)" end="(38, 81)">
                                          <OtherNode start="(38, 63)" end="(38, 74)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.32&#10;β : Type ?u.53&#10;as✝ : List α&#10;f : (i : Nat) → α → i &amp;lt; as✝.length → β&#10;a : α&#10;as : List α&#10;acc : Array β&#10;h : (a :: as).length + acc.size = as✝.length&#10;⊢ as.length + (acc.push (f acc.size a ⋯)).size = as✝.length" state_after="α : Type ?u.32&#10;β : Type ?u.53&#10;as✝ : List α&#10;f : (i : Nat) → α → i &amp;lt; as✝.length → β&#10;a : α&#10;as : List α&#10;acc : Array β&#10;h : as.length + 1 + acc.size = as✝.length&#10;⊢ as.length + (acc.size + 1) = as✝.length" tactic="simp at h ⊢">
                                            <AtomNode start="(38, 63)" end="(38, 67)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(38, 68)" end="(38, 74)">
                                              <OtherNode start="(38, 68)" end="(38, 74)" kind="Lean.Parser.Tactic.location">
                                                <AtomNode start="(38, 68)" end="(38, 70)" leading="" trailing=" " val="at"/>
                                                <OtherNode start="(38, 71)" end="(38, 74)" kind="Lean.Parser.Tactic.locationHyp">
                                                  <NullNode start="(38, 71)" end="(38, 74)">
                                                    <IdentNode start="(38, 71)" end="(38, 72)" leading="" trailing=" " raw_val="h" val="h"/>
                                                    <OtherNode start="(38, 73)" end="(38, 74)" kind="Lean.Parser.Tactic.locationType">
                                                      <OtherNode start="(38, 73)" end="(38, 74)" kind="patternIgnore">
                                                        <OtherNode start="(38, 73)" end="(38, 74)" kind="token.«⊢»">
                                                          <AtomNode start="(38, 73)" end="(38, 74)" leading="" trailing="" val="⊢"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(38, 74)" end="(38, 75)" leading="" trailing=" " val=";"/>
                                          <OtherNode start="(38, 76)" end="(38, 81)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.32&#10;β : Type ?u.53&#10;as✝ : List α&#10;f : (i : Nat) → α → i &amp;lt; as✝.length → β&#10;a : α&#10;as : List α&#10;acc : Array β&#10;h : as.length + 1 + acc.size = as✝.length&#10;⊢ as.length + (acc.size + 1) = as✝.length" state_after="no goals" tactic="omega">
                                            <AtomNode start="(38, 76)" end="(38, 81)" leading="" trailing="" val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                  <AtomNode start="(38, 81)" end="(38, 82)" leading="" trailing="&#10;&#10;" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(40, 1)" end="(52, 52)" name="mapIdx" full_name="List.mapIdx">
      <CommandDeclmodifiersNode start="(40, 1)" end="(47, 10)">
        <NullNode start="(40, 1)" end="(46, 3)">
          <CommandDoccommentNode start="(40, 1)" end="(46, 3)" comment="Applies a function to each element of the list along with the index at which that element is found,&#10;returning the list of results.&#10;&#10;`List.mapFinIdx` is a variant that additionally provides the function with a proof that the index&#10;is valid.&#10;-/">
            <AtomNode start="(40, 1)" end="(40, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(41, 1)" end="(46, 3)" leading="" trailing="&#10;" val="Applies a function to each element of the list along with the index at which that element is found,&#10;returning the list of results.&#10;&#10;`List.mapFinIdx` is a variant that additionally provides the function with a proof that the index&#10;is valid.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(47, 1)" end="(47, 10)">
          <OtherNode start="(47, 1)" end="(47, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(47, 1)" end="(47, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(47, 3)" end="(47, 9)">
              <OtherNode start="(47, 3)" end="(47, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(47, 3)" end="(47, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(47, 3)" end="(47, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(47, 9)" end="(47, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(47, 11)" end="(52, 52)" name="mapIdx">
        <AtomNode start="(47, 11)" end="(47, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(47, 15)" end="(47, 21)">
          <IdentNode start="(47, 15)" end="(47, 21)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(47, 22)" end="(47, 62)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(47, 22)" end="(47, 53)">
            <TermExplicitbinderNode start="(47, 22)" end="(47, 39)">
              <AtomNode start="(47, 22)" end="(47, 23)" leading="" trailing="" val="("/>
              <NullNode start="(47, 23)" end="(47, 24)">
                <IdentNode start="(47, 23)" end="(47, 24)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(47, 25)" end="(47, 38)">
                <AtomNode start="(47, 25)" end="(47, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(47, 27)" end="(47, 38)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(47, 27)" end="(47, 30)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(47, 31)" end="(47, 32)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(47, 33)" end="(47, 38)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(47, 33)" end="(47, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(47, 35)" end="(47, 36)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(47, 37)" end="(47, 38)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(47, 38)" end="(47, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(47, 40)" end="(47, 53)">
              <AtomNode start="(47, 40)" end="(47, 41)" leading="" trailing="" val="("/>
              <NullNode start="(47, 41)" end="(47, 43)">
                <IdentNode start="(47, 41)" end="(47, 43)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(47, 44)" end="(47, 52)">
                <AtomNode start="(47, 44)" end="(47, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(47, 46)" end="(47, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(47, 46)" end="(47, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(47, 51)" end="(47, 52)">
                    <IdentNode start="(47, 51)" end="(47, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(47, 52)" end="(47, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(47, 54)" end="(47, 62)">
            <TermTypespecNode start="(47, 54)" end="(47, 62)">
              <AtomNode start="(47, 54)" end="(47, 55)" leading="" trailing=" " val=":"/>
              <OtherNode start="(47, 56)" end="(47, 62)" kind="Lean.Parser.Term.app">
                <IdentNode start="(47, 56)" end="(47, 60)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(47, 61)" end="(47, 62)">
                  <IdentNode start="(47, 61)" end="(47, 62)" leading="" trailing=" " raw_val="β" val="β"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(47, 63)" end="(52, 52)">
          <AtomNode start="(47, 63)" end="(47, 65)" leading="" trailing=" " val=":="/>
          <OtherNode start="(47, 66)" end="(47, 75)" kind="Lean.Parser.Term.app">
            <IdentNode start="(47, 66)" end="(47, 68)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(47, 69)" end="(47, 75)">
              <IdentNode start="(47, 69)" end="(47, 71)" leading="" trailing=" " raw_val="as" val="as"/>
              <OtherNode start="(47, 72)" end="(47, 75)" kind="«term#[_,]»">
                <AtomNode start="(47, 72)" end="(47, 74)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(47, 74)" end="(47, 75)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(47, 76)" end="(52, 52)">
            <OtherNode start="(47, 76)" end="(52, 52)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(47, 76)" end="(47, 81)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(48, 3)" end="(52, 52)">
                <OtherNode start="(48, 3)" end="(52, 52)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(48, 3)" end="(49, 93)">
                    <CommandDoccommentNode start="(48, 3)" end="(49, 93)" comment="Auxiliary for `mapIdx`:&#10;  `mapIdx.go [a₀, a₁, ...] acc = acc.toList ++ [f acc.size a₀, f (acc.size + 1) a₁, ...]` -/">
                      <AtomNode start="(48, 3)" end="(48, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(48, 7)" end="(49, 93)" leading="" trailing="&#10;  " val="Auxiliary for `mapIdx`:&#10;  `mapIdx.go [a₀, a₁, ...] acc = acc.toList ++ [f acc.size a₀, f (acc.size + 1) a₁, ...]` -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode start="(50, 3)" end="(50, 16)">
                    <OtherNode start="(50, 3)" end="(50, 16)" kind="Lean.Parser.Term.attributes">
                      <AtomNode start="(50, 3)" end="(50, 5)" leading="" trailing="" val="@["/>
                      <NullNode start="(50, 5)" end="(50, 15)">
                        <OtherNode start="(50, 5)" end="(50, 15)" kind="Lean.Parser.Term.attrInstance">
                          <TermAttrkindNode>
                            <NullNode/>
                          </TermAttrkindNode>
                          <OtherNode start="(50, 5)" end="(50, 15)" kind="Lean.Parser.Attr.specialize">
                            <AtomNode start="(50, 5)" end="(50, 15)" leading="" trailing="" val="specialize"/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(50, 15)" end="(50, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                  <OtherNode start="(50, 17)" end="(52, 52)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(50, 17)" end="(52, 52)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(50, 17)" end="(50, 19)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(50, 20)" end="(50, 47)">
                        <TermTypespecNode start="(50, 20)" end="(50, 47)">
                          <AtomNode start="(50, 20)" end="(50, 21)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(50, 22)" end="(50, 47)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(50, 22)" end="(50, 28)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(50, 22)" end="(50, 26)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(50, 27)" end="(50, 28)">
                                <IdentNode start="(50, 27)" end="(50, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(50, 29)" end="(50, 30)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(50, 31)" end="(50, 47)" kind="Lean.Parser.Term.arrow">
                              <OtherNode start="(50, 31)" end="(50, 38)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(50, 31)" end="(50, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(50, 37)" end="(50, 38)">
                                  <IdentNode start="(50, 37)" end="(50, 38)" leading="" trailing=" " raw_val="β" val="β"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(50, 39)" end="(50, 40)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(50, 41)" end="(50, 47)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(50, 41)" end="(50, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(50, 46)" end="(50, 47)">
                                  <IdentNode start="(50, 46)" end="(50, 47)" leading="" trailing="&#10;  " raw_val="β" val="β"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(51, 3)" end="(52, 52)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(51, 3)" end="(52, 52)">
                          <OtherNode start="(51, 3)" end="(51, 26)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(51, 3)" end="(51, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(51, 5)" end="(51, 12)">
                              <NullNode start="(51, 5)" end="(51, 12)">
                                <OtherNode start="(51, 5)" end="(51, 7)" kind="«term[_]»">
                                  <AtomNode start="(51, 5)" end="(51, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(51, 6)" end="(51, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(51, 7)" end="(51, 8)" leading="" trailing=" " val=","/>
                                <IdentNode start="(51, 9)" end="(51, 12)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(51, 13)" end="(51, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(51, 16)" end="(51, 26)" leading="" trailing="&#10;  " raw_val="acc.toList" val="acc.toList"/>
                          </OtherNode>
                          <OtherNode start="(52, 3)" end="(52, 52)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(52, 3)" end="(52, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(52, 5)" end="(52, 17)">
                              <NullNode start="(52, 5)" end="(52, 17)">
                                <OtherNode start="(52, 5)" end="(52, 12)" kind="«term_::_»">
                                  <IdentNode start="(52, 5)" end="(52, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <AtomNode start="(52, 7)" end="(52, 9)" leading="" trailing=" " val="::"/>
                                  <IdentNode start="(52, 10)" end="(52, 12)" leading="" trailing="" raw_val="as" val="as"/>
                                </OtherNode>
                                <AtomNode start="(52, 12)" end="(52, 13)" leading="" trailing=" " val=","/>
                                <IdentNode start="(52, 14)" end="(52, 17)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(52, 18)" end="(52, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(52, 21)" end="(52, 52)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(52, 21)" end="(52, 23)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode start="(52, 24)" end="(52, 52)">
                                <IdentNode start="(52, 24)" end="(52, 26)" leading="" trailing=" " raw_val="as" val="as"/>
                                <OtherNode start="(52, 27)" end="(52, 52)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(52, 27)" end="(52, 28)" leading="" trailing="" val="("/>
                                  <OtherNode start="(52, 28)" end="(52, 51)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(52, 28)" end="(52, 36)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                    <NullNode start="(52, 37)" end="(52, 51)">
                                      <OtherNode start="(52, 37)" end="(52, 51)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(52, 37)" end="(52, 38)" leading="" trailing="" val="("/>
                                        <OtherNode start="(52, 38)" end="(52, 50)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(52, 38)" end="(52, 39)" leading="" trailing=" " raw_val="f" val="f"/>
                                          <NullNode start="(52, 40)" end="(52, 50)">
                                            <IdentNode start="(52, 40)" end="(52, 48)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
                                            <IdentNode start="(52, 49)" end="(52, 50)" leading="" trailing="" raw_val="a" val="a"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(52, 50)" end="(52, 51)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(52, 51)" end="(52, 52)" leading="" trailing="&#10;&#10;" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(54, 1)" end="(70, 84)" name="mapFinIdxM" full_name="List.mapFinIdxM">
      <CommandDeclmodifiersNode start="(54, 1)" end="(62, 10)">
        <NullNode start="(54, 1)" end="(61, 3)">
          <CommandDoccommentNode start="(54, 1)" end="(61, 3)" comment="Applies a monadic function to each element of the list along with the index at which that element is&#10;found, returning the list of results. In addition to the index, the function is also provided with a&#10;proof that the index is valid.&#10;&#10;`List.mapIdxM` is a variant that does not provide the function with evidence that the index is&#10;valid.&#10;-/">
            <AtomNode start="(54, 1)" end="(54, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(55, 1)" end="(61, 3)" leading="" trailing="&#10;" val="Applies a monadic function to each element of the list along with the index at which that element is&#10;found, returning the list of results. In addition to the index, the function is also provided with a&#10;proof that the index is valid.&#10;&#10;`List.mapIdxM` is a variant that does not provide the function with evidence that the index is&#10;valid.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(62, 1)" end="(62, 10)">
          <OtherNode start="(62, 1)" end="(62, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(62, 1)" end="(62, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(62, 3)" end="(62, 9)">
              <OtherNode start="(62, 3)" end="(62, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(62, 3)" end="(62, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(62, 3)" end="(62, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(62, 9)" end="(62, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(62, 11)" end="(70, 84)" name="mapFinIdxM">
        <AtomNode start="(62, 11)" end="(62, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(62, 15)" end="(62, 25)">
          <IdentNode start="(62, 15)" end="(62, 25)" leading="" trailing=" " raw_val="mapFinIdxM" val="mapFinIdxM"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(62, 26)" end="(62, 110)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(62, 26)" end="(62, 97)">
            <OtherNode start="(62, 26)" end="(62, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(62, 26)" end="(62, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(62, 27)" end="(62, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(62, 27)" end="(62, 32)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(62, 33)" end="(62, 34)">
                  <IdentNode start="(62, 33)" end="(62, 34)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(62, 34)" end="(62, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(62, 36)" end="(62, 49)">
              <AtomNode start="(62, 36)" end="(62, 37)" leading="" trailing="" val="("/>
              <NullNode start="(62, 37)" end="(62, 39)">
                <IdentNode start="(62, 37)" end="(62, 39)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(62, 40)" end="(62, 48)">
                <AtomNode start="(62, 40)" end="(62, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(62, 42)" end="(62, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(62, 42)" end="(62, 46)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(62, 47)" end="(62, 48)">
                    <IdentNode start="(62, 47)" end="(62, 48)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(62, 48)" end="(62, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(62, 50)" end="(62, 97)">
              <AtomNode start="(62, 50)" end="(62, 51)" leading="" trailing="" val="("/>
              <NullNode start="(62, 51)" end="(62, 52)">
                <IdentNode start="(62, 51)" end="(62, 52)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(62, 53)" end="(62, 96)">
                <AtomNode start="(62, 53)" end="(62, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(62, 55)" end="(62, 96)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(62, 55)" end="(62, 64)">
                    <AtomNode start="(62, 55)" end="(62, 56)" leading="" trailing="" val="("/>
                    <NullNode start="(62, 56)" end="(62, 57)">
                      <IdentNode start="(62, 56)" end="(62, 57)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(62, 58)" end="(62, 63)">
                      <AtomNode start="(62, 58)" end="(62, 59)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(62, 60)" end="(62, 63)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(62, 63)" end="(62, 64)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(62, 65)" end="(62, 66)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(62, 67)" end="(62, 96)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(62, 67)" end="(62, 68)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(62, 69)" end="(62, 70)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(62, 71)" end="(62, 96)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(62, 71)" end="(62, 90)">
                        <AtomNode start="(62, 71)" end="(62, 72)" leading="" trailing="" val="("/>
                        <NullNode start="(62, 72)" end="(62, 73)">
                          <IdentNode start="(62, 72)" end="(62, 73)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(62, 74)" end="(62, 89)">
                          <AtomNode start="(62, 74)" end="(62, 75)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(62, 76)" end="(62, 89)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(62, 76)" end="(62, 77)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(62, 78)" end="(62, 79)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(62, 80)" end="(62, 89)" leading="" trailing="" raw_val="as.length" val="as.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(62, 89)" end="(62, 90)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(62, 91)" end="(62, 92)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(62, 93)" end="(62, 96)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(62, 93)" end="(62, 94)" leading="" trailing=" " raw_val="m" val="m"/>
                        <NullNode start="(62, 95)" end="(62, 96)">
                          <IdentNode start="(62, 95)" end="(62, 96)" leading="" trailing="" raw_val="β" val="β"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(62, 96)" end="(62, 97)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(62, 98)" end="(62, 110)">
            <TermTypespecNode start="(62, 98)" end="(62, 110)">
              <AtomNode start="(62, 98)" end="(62, 99)" leading="" trailing=" " val=":"/>
              <OtherNode start="(62, 100)" end="(62, 110)" kind="Lean.Parser.Term.app">
                <IdentNode start="(62, 100)" end="(62, 101)" leading="" trailing=" " raw_val="m" val="m"/>
                <NullNode start="(62, 102)" end="(62, 110)">
                  <OtherNode start="(62, 102)" end="(62, 110)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(62, 102)" end="(62, 103)" leading="" trailing="" val="("/>
                    <OtherNode start="(62, 103)" end="(62, 109)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(62, 103)" end="(62, 107)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(62, 108)" end="(62, 109)">
                        <IdentNode start="(62, 108)" end="(62, 109)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(62, 109)" end="(62, 110)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(62, 111)" end="(70, 84)">
          <AtomNode start="(62, 111)" end="(62, 113)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(63, 3)" end="(63, 22)" kind="Lean.Parser.Term.app">
            <IdentNode start="(63, 3)" end="(63, 5)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(63, 6)" end="(63, 22)">
              <IdentNode start="(63, 6)" end="(63, 8)" leading="" trailing=" " raw_val="as" val="as"/>
              <OtherNode start="(63, 9)" end="(63, 12)" kind="«term#[_,]»">
                <AtomNode start="(63, 9)" end="(63, 11)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(63, 11)" end="(63, 12)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <OtherNode start="(63, 13)" end="(63, 22)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(63, 13)" end="(63, 14)" leading="" trailing="" val="("/>
                <TermBytacticNode start="(63, 14)" end="(63, 21)">
                  <AtomNode start="(63, 14)" end="(63, 16)" leading="" trailing=" " val="by"/>
                  <TacticTacticseqNode start="(63, 17)" end="(63, 21)">
                    <TacticTacticseq1IndentedNode start="(63, 17)" end="(63, 21)">
                      <NullNode start="(63, 17)" end="(63, 21)">
                        <OtherNode start="(63, 17)" end="(63, 21)" kind="Lean.Parser.Tactic.simp" state_before="m : Type ?u.1809 → Type ?u.1700&#10;α : Type ?u.1705&#10;β : Type ?u.1809&#10;inst✝ : Monad m&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → m β&#10;⊢ as.length + #[].size = as.length" state_after="no goals" tactic="simp">
                          <AtomNode start="(63, 17)" end="(63, 21)" leading="" trailing="" val="simp"/>
                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <NullNode/>
                          <NullNode/>
                          <NullNode/>
                        </OtherNode>
                      </NullNode>
                    </TacticTacticseq1IndentedNode>
                  </TacticTacticseqNode>
                </TermBytacticNode>
                <AtomNode start="(63, 21)" end="(63, 22)" leading="" trailing="&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(64, 1)" end="(70, 84)">
            <OtherNode start="(64, 1)" end="(70, 84)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(64, 1)" end="(64, 6)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(65, 3)" end="(70, 84)">
                <OtherNode start="(65, 3)" end="(70, 84)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(65, 3)" end="(66, 81)">
                    <CommandDoccommentNode start="(65, 3)" end="(66, 81)" comment="Auxiliary for `mapFinIdxM`:&#10;  `mapFinIdxM.go [a₀, a₁, ...] acc = acc.toList ++ [f 0 a₀ ⋯, f 1 a₁ ⋯, ...]` -/">
                      <AtomNode start="(65, 3)" end="(65, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(65, 7)" end="(66, 81)" leading="" trailing="&#10;  " val="Auxiliary for `mapFinIdxM`:&#10;  `mapFinIdxM.go [a₀, a₁, ...] acc = acc.toList ++ [f 0 a₀ ⋯, f 1 a₁ ⋯, ...]` -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode start="(67, 3)" end="(67, 16)">
                    <OtherNode start="(67, 3)" end="(67, 16)" kind="Lean.Parser.Term.attributes">
                      <AtomNode start="(67, 3)" end="(67, 5)" leading="" trailing="" val="@["/>
                      <NullNode start="(67, 5)" end="(67, 15)">
                        <OtherNode start="(67, 5)" end="(67, 15)" kind="Lean.Parser.Term.attrInstance">
                          <TermAttrkindNode>
                            <NullNode/>
                          </TermAttrkindNode>
                          <OtherNode start="(67, 5)" end="(67, 15)" kind="Lean.Parser.Attr.specialize">
                            <AtomNode start="(67, 5)" end="(67, 15)" leading="" trailing="" val="specialize"/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(67, 15)" end="(67, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                  <OtherNode start="(67, 17)" end="(70, 84)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(67, 17)" end="(70, 84)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(67, 17)" end="(67, 19)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(67, 20)" end="(67, 101)">
                        <TermTypespecNode start="(67, 20)" end="(67, 101)">
                          <AtomNode start="(67, 20)" end="(67, 21)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(67, 22)" end="(67, 101)" kind="Lean.Parser.Term.depArrow">
                            <TermExplicitbinderNode start="(67, 22)" end="(67, 35)">
                              <AtomNode start="(67, 22)" end="(67, 23)" leading="" trailing="" val="("/>
                              <NullNode start="(67, 23)" end="(67, 25)">
                                <IdentNode start="(67, 23)" end="(67, 25)" leading="" trailing=" " raw_val="bs" val="bs"/>
                              </NullNode>
                              <NullNode start="(67, 26)" end="(67, 34)">
                                <AtomNode start="(67, 26)" end="(67, 27)" leading="" trailing=" " val=":"/>
                                <OtherNode start="(67, 28)" end="(67, 34)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(67, 28)" end="(67, 32)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(67, 33)" end="(67, 34)">
                                    <IdentNode start="(67, 33)" end="(67, 34)" leading="" trailing="" raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(67, 34)" end="(67, 35)" leading="" trailing=" " val=")"/>
                            </TermExplicitbinderNode>
                            <AtomNode start="(67, 36)" end="(67, 37)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(67, 38)" end="(67, 101)" kind="Lean.Parser.Term.depArrow">
                              <TermExplicitbinderNode start="(67, 38)" end="(67, 53)">
                                <AtomNode start="(67, 38)" end="(67, 39)" leading="" trailing="" val="("/>
                                <NullNode start="(67, 39)" end="(67, 42)">
                                  <IdentNode start="(67, 39)" end="(67, 42)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                </NullNode>
                                <NullNode start="(67, 43)" end="(67, 52)">
                                  <AtomNode start="(67, 43)" end="(67, 44)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(67, 45)" end="(67, 52)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(67, 45)" end="(67, 50)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(67, 51)" end="(67, 52)">
                                      <IdentNode start="(67, 51)" end="(67, 52)" leading="" trailing="" raw_val="β" val="β"/>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(67, 52)" end="(67, 53)" leading="" trailing=" " val=")"/>
                              </TermExplicitbinderNode>
                              <AtomNode start="(67, 54)" end="(67, 55)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(67, 56)" end="(67, 101)" kind="Lean.Parser.Term.arrow">
                                <OtherNode start="(67, 56)" end="(67, 88)" kind="«term_=_»">
                                  <OtherNode start="(67, 56)" end="(67, 76)" kind="«term_+_»">
                                    <IdentNode start="(67, 56)" end="(67, 65)" leading="" trailing=" " raw_val="bs.length" val="bs.length"/>
                                    <AtomNode start="(67, 66)" end="(67, 67)" leading="" trailing=" " val="+"/>
                                    <IdentNode start="(67, 68)" end="(67, 76)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
                                  </OtherNode>
                                  <AtomNode start="(67, 77)" end="(67, 78)" leading="" trailing=" " val="="/>
                                  <IdentNode start="(67, 79)" end="(67, 88)" leading="" trailing=" " raw_val="as.length" val="as.length"/>
                                </OtherNode>
                                <AtomNode start="(67, 89)" end="(67, 90)" leading="" trailing=" " val="→"/>
                                <OtherNode start="(67, 91)" end="(67, 101)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(67, 91)" end="(67, 92)" leading="" trailing=" " raw_val="m" val="m"/>
                                  <NullNode start="(67, 93)" end="(67, 101)">
                                    <OtherNode start="(67, 93)" end="(67, 101)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(67, 93)" end="(67, 94)" leading="" trailing="" val="("/>
                                      <OtherNode start="(67, 94)" end="(67, 100)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(67, 94)" end="(67, 98)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        <NullNode start="(67, 99)" end="(67, 100)">
                                          <IdentNode start="(67, 99)" end="(67, 100)" leading="" trailing="" raw_val="β" val="β"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(67, 100)" end="(67, 101)" leading="" trailing="&#10;  " val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(68, 3)" end="(70, 84)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(68, 3)" end="(70, 84)">
                          <OtherNode start="(68, 3)" end="(68, 34)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(68, 3)" end="(68, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(68, 5)" end="(68, 15)">
                              <NullNode start="(68, 5)" end="(68, 15)">
                                <OtherNode start="(68, 5)" end="(68, 7)" kind="«term[_]»">
                                  <AtomNode start="(68, 5)" end="(68, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(68, 6)" end="(68, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(68, 7)" end="(68, 8)" leading="" trailing=" " val=","/>
                                <IdentNode start="(68, 9)" end="(68, 12)" leading="" trailing="" raw_val="acc" val="acc"/>
                                <AtomNode start="(68, 12)" end="(68, 13)" leading="" trailing=" " val=","/>
                                <IdentNode start="(68, 14)" end="(68, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(68, 16)" end="(68, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(68, 19)" end="(68, 34)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(68, 19)" end="(68, 23)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(68, 24)" end="(68, 34)">
                                <IdentNode start="(68, 24)" end="(68, 34)" leading="" trailing="&#10;  " raw_val="acc.toList" val="acc.toList"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(69, 3)" end="(70, 84)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(69, 3)" end="(69, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(69, 5)" end="(69, 20)">
                              <NullNode start="(69, 5)" end="(69, 20)">
                                <OtherNode start="(69, 5)" end="(69, 12)" kind="«term_::_»">
                                  <IdentNode start="(69, 5)" end="(69, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <AtomNode start="(69, 7)" end="(69, 9)" leading="" trailing=" " val="::"/>
                                  <IdentNode start="(69, 10)" end="(69, 12)" leading="" trailing="" raw_val="as" val="as"/>
                                </OtherNode>
                                <AtomNode start="(69, 12)" end="(69, 13)" leading="" trailing=" " val=","/>
                                <IdentNode start="(69, 14)" end="(69, 17)" leading="" trailing="" raw_val="acc" val="acc"/>
                                <AtomNode start="(69, 17)" end="(69, 18)" leading="" trailing=" " val=","/>
                                <IdentNode start="(69, 19)" end="(69, 20)" leading="" trailing=" " raw_val="h" val="h"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(69, 21)" end="(69, 23)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(69, 24)" end="(70, 84)" kind="Lean.Parser.Term.do">
                              <AtomNode start="(69, 24)" end="(69, 26)" leading="" trailing="&#10;    " val="do"/>
                              <OtherNode start="(70, 5)" end="(70, 84)" kind="Lean.Parser.Term.doSeqIndent">
                                <NullNode start="(70, 5)" end="(70, 84)">
                                  <OtherNode start="(70, 5)" end="(70, 84)" kind="Lean.Parser.Term.doSeqItem">
                                    <OtherNode start="(70, 5)" end="(70, 84)" kind="Lean.Parser.Term.doExpr">
                                      <OtherNode start="(70, 5)" end="(70, 84)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(70, 5)" end="(70, 7)" leading="" trailing=" " raw_val="go" val="go"/>
                                        <NullNode start="(70, 8)" end="(70, 84)">
                                          <IdentNode start="(70, 8)" end="(70, 10)" leading="" trailing=" " raw_val="as" val="as"/>
                                          <OtherNode start="(70, 11)" end="(70, 60)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(70, 11)" end="(70, 12)" leading="" trailing="" val="("/>
                                            <OtherNode start="(70, 12)" end="(70, 59)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(70, 12)" end="(70, 20)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                              <NullNode start="(70, 21)" end="(70, 59)">
                                                <OtherNode start="(70, 21)" end="(70, 59)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(70, 21)" end="(70, 22)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(70, 22)" end="(70, 58)" kind="Lean.Parser.Term.liftMethod">
                                                    <AtomNode start="(70, 22)" end="(70, 23)" leading="" trailing=" " val="←"/>
                                                    <OtherNode start="(70, 24)" end="(70, 58)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(70, 24)" end="(70, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                                                      <NullNode start="(70, 26)" end="(70, 58)">
                                                        <IdentNode start="(70, 26)" end="(70, 34)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
                                                        <IdentNode start="(70, 35)" end="(70, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                                                        <OtherNode start="(70, 37)" end="(70, 58)" kind="Lean.Parser.Term.paren">
                                                          <AtomNode start="(70, 37)" end="(70, 38)" leading="" trailing="" val="("/>
                                                          <TermBytacticNode start="(70, 38)" end="(70, 57)">
                                                            <AtomNode start="(70, 38)" end="(70, 40)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(70, 41)" end="(70, 57)">
                                                            <TacticTacticseq1IndentedNode start="(70, 41)" end="(70, 57)">
                                                            <NullNode start="(70, 41)" end="(70, 57)">
                                                            <OtherNode start="(70, 41)" end="(70, 50)" kind="Lean.Parser.Tactic.simp" state_before="m : Type ?u.1809 → Type ?u.1700&#10;α : Type ?u.1705&#10;β : Type ?u.1809&#10;inst✝ : Monad m&#10;as✝ : List α&#10;f : (i : Nat) → α → i &amp;lt; as✝.length → m β&#10;a : α&#10;as : List α&#10;acc : Array β&#10;h : (a :: as).length + acc.size = as✝.length&#10;⊢ acc.size &amp;lt; as✝.length" state_after="m : Type ?u.1809 → Type ?u.1700&#10;α : Type ?u.1705&#10;β : Type ?u.1809&#10;inst✝ : Monad m&#10;as✝ : List α&#10;f : (i : Nat) → α → i &amp;lt; as✝.length → m β&#10;a : α&#10;as : List α&#10;acc : Array β&#10;h : as.length + 1 + acc.size = as✝.length&#10;⊢ acc.size &amp;lt; as✝.length" tactic="simp at h">
                                                            <AtomNode start="(70, 41)" end="(70, 45)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(70, 46)" end="(70, 50)">
                                                            <OtherNode start="(70, 46)" end="(70, 50)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(70, 46)" end="(70, 48)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(70, 49)" end="(70, 50)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(70, 49)" end="(70, 50)">
                                                            <IdentNode start="(70, 49)" end="(70, 50)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(70, 50)" end="(70, 51)" leading="" trailing=" " val=";"/>
                                                            <OtherNode start="(70, 52)" end="(70, 57)" kind="Lean.Parser.Tactic.omega" state_before="m : Type ?u.1809 → Type ?u.1700&#10;α : Type ?u.1705&#10;β : Type ?u.1809&#10;inst✝ : Monad m&#10;as✝ : List α&#10;f : (i : Nat) → α → i &amp;lt; as✝.length → m β&#10;a : α&#10;as : List α&#10;acc : Array β&#10;h : as.length + 1 + acc.size = as✝.length&#10;⊢ acc.size &amp;lt; as✝.length" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(70, 52)" end="(70, 57)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </TermBytacticNode>
                                                          <AtomNode start="(70, 57)" end="(70, 58)" leading="" trailing="" val=")"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <AtomNode start="(70, 58)" end="(70, 59)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(70, 59)" end="(70, 60)" leading="" trailing=" " val=")"/>
                                          </OtherNode>
                                          <OtherNode start="(70, 61)" end="(70, 84)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(70, 61)" end="(70, 62)" leading="" trailing="" val="("/>
                                            <TermBytacticNode start="(70, 62)" end="(70, 83)">
                                              <AtomNode start="(70, 62)" end="(70, 64)" leading="" trailing=" " val="by"/>
                                              <TacticTacticseqNode start="(70, 65)" end="(70, 83)">
                                                <TacticTacticseq1IndentedNode start="(70, 65)" end="(70, 83)">
                                                  <NullNode start="(70, 65)" end="(70, 83)">
                                                    <OtherNode start="(70, 65)" end="(70, 76)" kind="Lean.Parser.Tactic.simp" state_before="m : Type ?u.1809 → Type ?u.1700&#10;α : Type ?u.1705&#10;β : Type ?u.1809&#10;inst✝ : Monad m&#10;as✝ : List α&#10;f : (i : Nat) → α → i &amp;lt; as✝.length → m β&#10;a : α&#10;as : List α&#10;acc : Array β&#10;h : (a :: as).length + acc.size = as✝.length&#10;⊢ as.length + (acc.push __do_lift✝).size = as✝.length" state_after="m : Type ?u.1809 → Type ?u.1700&#10;α : Type ?u.1705&#10;β : Type ?u.1809&#10;inst✝ : Monad m&#10;as✝ : List α&#10;f : (i : Nat) → α → i &amp;lt; as✝.length → m β&#10;a : α&#10;as : List α&#10;acc : Array β&#10;h : as.length + 1 + acc.size = as✝.length&#10;⊢ as.length + (acc.size + 1) = as✝.length" tactic="simp at h ⊢">
                                                      <AtomNode start="(70, 65)" end="(70, 69)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(70, 70)" end="(70, 76)">
                                                        <OtherNode start="(70, 70)" end="(70, 76)" kind="Lean.Parser.Tactic.location">
                                                          <AtomNode start="(70, 70)" end="(70, 72)" leading="" trailing=" " val="at"/>
                                                          <OtherNode start="(70, 73)" end="(70, 76)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(70, 73)" end="(70, 76)">
                                                            <IdentNode start="(70, 73)" end="(70, 74)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <OtherNode start="(70, 75)" end="(70, 76)" kind="Lean.Parser.Tactic.locationType">
                                                            <OtherNode start="(70, 75)" end="(70, 76)" kind="patternIgnore">
                                                            <OtherNode start="(70, 75)" end="(70, 76)" kind="token.«⊢»">
                                                            <AtomNode start="(70, 75)" end="(70, 76)" leading="" trailing="" val="⊢"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <AtomNode start="(70, 76)" end="(70, 77)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(70, 78)" end="(70, 83)" kind="Lean.Parser.Tactic.omega" state_before="m : Type ?u.1809 → Type ?u.1700&#10;α : Type ?u.1705&#10;β : Type ?u.1809&#10;inst✝ : Monad m&#10;as✝ : List α&#10;f : (i : Nat) → α → i &amp;lt; as✝.length → m β&#10;a : α&#10;as : List α&#10;acc : Array β&#10;h : as.length + 1 + acc.size = as✝.length&#10;⊢ as.length + (acc.size + 1) = as✝.length" state_after="no goals" tactic="omega">
                                                      <AtomNode start="(70, 78)" end="(70, 83)" leading="" trailing="" val="omega"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </TermBytacticNode>
                                            <AtomNode start="(70, 83)" end="(70, 84)" leading="" trailing="&#10;&#10;" val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(72, 1)" end="(84, 57)" name="mapIdxM" full_name="List.mapIdxM">
      <CommandDeclmodifiersNode start="(72, 1)" end="(79, 10)">
        <NullNode start="(72, 1)" end="(78, 3)">
          <CommandDoccommentNode start="(72, 1)" end="(78, 3)" comment="Applies a monadic function to each element of the list along with the index at which that element is&#10;found, returning the list of results.&#10;&#10;`List.mapFinIdxM` is a variant that additionally provides the function with a proof that the index&#10;is valid.&#10;-/">
            <AtomNode start="(72, 1)" end="(72, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(73, 1)" end="(78, 3)" leading="" trailing="&#10;" val="Applies a monadic function to each element of the list along with the index at which that element is&#10;found, returning the list of results.&#10;&#10;`List.mapFinIdxM` is a variant that additionally provides the function with a proof that the index&#10;is valid.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(79, 1)" end="(79, 10)">
          <OtherNode start="(79, 1)" end="(79, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(79, 1)" end="(79, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(79, 3)" end="(79, 9)">
              <OtherNode start="(79, 3)" end="(79, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(79, 3)" end="(79, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(79, 3)" end="(79, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(79, 9)" end="(79, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(79, 11)" end="(84, 57)" name="mapIdxM">
        <AtomNode start="(79, 11)" end="(79, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(79, 15)" end="(79, 22)">
          <IdentNode start="(79, 15)" end="(79, 22)" leading="" trailing=" " raw_val="mapIdxM" val="mapIdxM"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(79, 23)" end="(79, 79)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(79, 23)" end="(79, 66)">
            <OtherNode start="(79, 23)" end="(79, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(79, 23)" end="(79, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(79, 24)" end="(79, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(79, 24)" end="(79, 29)" leading="" trailing=" " raw_val="Monad" val="Monad" full_name="Monad" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(79, 30)" end="(79, 31)">
                  <IdentNode start="(79, 30)" end="(79, 31)" leading="" trailing="" raw_val="m" val="m"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(79, 31)" end="(79, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(79, 33)" end="(79, 52)">
              <AtomNode start="(79, 33)" end="(79, 34)" leading="" trailing="" val="("/>
              <NullNode start="(79, 34)" end="(79, 35)">
                <IdentNode start="(79, 34)" end="(79, 35)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(79, 36)" end="(79, 51)">
                <AtomNode start="(79, 36)" end="(79, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(79, 38)" end="(79, 51)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(79, 38)" end="(79, 41)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(79, 42)" end="(79, 43)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(79, 44)" end="(79, 51)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(79, 44)" end="(79, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(79, 46)" end="(79, 47)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(79, 48)" end="(79, 51)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(79, 48)" end="(79, 49)" leading="" trailing=" " raw_val="m" val="m"/>
                      <NullNode start="(79, 50)" end="(79, 51)">
                        <IdentNode start="(79, 50)" end="(79, 51)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(79, 51)" end="(79, 52)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(79, 53)" end="(79, 66)">
              <AtomNode start="(79, 53)" end="(79, 54)" leading="" trailing="" val="("/>
              <NullNode start="(79, 54)" end="(79, 56)">
                <IdentNode start="(79, 54)" end="(79, 56)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(79, 57)" end="(79, 65)">
                <AtomNode start="(79, 57)" end="(79, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(79, 59)" end="(79, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(79, 59)" end="(79, 63)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(79, 64)" end="(79, 65)">
                    <IdentNode start="(79, 64)" end="(79, 65)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(79, 65)" end="(79, 66)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(79, 67)" end="(79, 79)">
            <TermTypespecNode start="(79, 67)" end="(79, 79)">
              <AtomNode start="(79, 67)" end="(79, 68)" leading="" trailing=" " val=":"/>
              <OtherNode start="(79, 69)" end="(79, 79)" kind="Lean.Parser.Term.app">
                <IdentNode start="(79, 69)" end="(79, 70)" leading="" trailing=" " raw_val="m" val="m"/>
                <NullNode start="(79, 71)" end="(79, 79)">
                  <OtherNode start="(79, 71)" end="(79, 79)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(79, 71)" end="(79, 72)" leading="" trailing="" val="("/>
                    <OtherNode start="(79, 72)" end="(79, 78)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(79, 72)" end="(79, 76)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(79, 77)" end="(79, 78)">
                        <IdentNode start="(79, 77)" end="(79, 78)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(79, 78)" end="(79, 79)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(79, 80)" end="(84, 57)">
          <AtomNode start="(79, 80)" end="(79, 82)" leading="" trailing=" " val=":="/>
          <OtherNode start="(79, 83)" end="(79, 92)" kind="Lean.Parser.Term.app">
            <IdentNode start="(79, 83)" end="(79, 85)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(79, 86)" end="(79, 92)">
              <IdentNode start="(79, 86)" end="(79, 88)" leading="" trailing=" " raw_val="as" val="as"/>
              <OtherNode start="(79, 89)" end="(79, 92)" kind="«term#[_,]»">
                <AtomNode start="(79, 89)" end="(79, 91)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(79, 91)" end="(79, 92)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(79, 93)" end="(84, 57)">
            <OtherNode start="(79, 93)" end="(84, 57)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(79, 93)" end="(79, 98)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(80, 3)" end="(84, 57)">
                <OtherNode start="(80, 3)" end="(84, 57)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(80, 3)" end="(81, 94)">
                    <CommandDoccommentNode start="(80, 3)" end="(81, 94)" comment="Auxiliary for `mapIdxM`:&#10;  `mapIdxM.go [a₀, a₁, ...] acc = acc.toList ++ [f acc.size a₀, f (acc.size + 1) a₁, ...]` -/">
                      <AtomNode start="(80, 3)" end="(80, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(80, 7)" end="(81, 94)" leading="" trailing="&#10;  " val="Auxiliary for `mapIdxM`:&#10;  `mapIdxM.go [a₀, a₁, ...] acc = acc.toList ++ [f acc.size a₀, f (acc.size + 1) a₁, ...]` -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode start="(82, 3)" end="(82, 16)">
                    <OtherNode start="(82, 3)" end="(82, 16)" kind="Lean.Parser.Term.attributes">
                      <AtomNode start="(82, 3)" end="(82, 5)" leading="" trailing="" val="@["/>
                      <NullNode start="(82, 5)" end="(82, 15)">
                        <OtherNode start="(82, 5)" end="(82, 15)" kind="Lean.Parser.Term.attrInstance">
                          <TermAttrkindNode>
                            <NullNode/>
                          </TermAttrkindNode>
                          <OtherNode start="(82, 5)" end="(82, 15)" kind="Lean.Parser.Attr.specialize">
                            <AtomNode start="(82, 5)" end="(82, 15)" leading="" trailing="" val="specialize"/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(82, 15)" end="(82, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                  <OtherNode start="(82, 17)" end="(84, 57)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(82, 17)" end="(84, 57)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(82, 17)" end="(82, 19)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(82, 20)" end="(82, 51)">
                        <TermTypespecNode start="(82, 20)" end="(82, 51)">
                          <AtomNode start="(82, 20)" end="(82, 21)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(82, 22)" end="(82, 51)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(82, 22)" end="(82, 28)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(82, 22)" end="(82, 26)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(82, 27)" end="(82, 28)">
                                <IdentNode start="(82, 27)" end="(82, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(82, 29)" end="(82, 30)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(82, 31)" end="(82, 51)" kind="Lean.Parser.Term.arrow">
                              <OtherNode start="(82, 31)" end="(82, 38)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(82, 31)" end="(82, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(82, 37)" end="(82, 38)">
                                  <IdentNode start="(82, 37)" end="(82, 38)" leading="" trailing=" " raw_val="β" val="β"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(82, 39)" end="(82, 40)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(82, 41)" end="(82, 51)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(82, 41)" end="(82, 42)" leading="" trailing=" " raw_val="m" val="m"/>
                                <NullNode start="(82, 43)" end="(82, 51)">
                                  <OtherNode start="(82, 43)" end="(82, 51)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(82, 43)" end="(82, 44)" leading="" trailing="" val="("/>
                                    <OtherNode start="(82, 44)" end="(82, 50)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(82, 44)" end="(82, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(82, 49)" end="(82, 50)">
                                        <IdentNode start="(82, 49)" end="(82, 50)" leading="" trailing="" raw_val="β" val="β"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(82, 50)" end="(82, 51)" leading="" trailing="&#10;  " val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(83, 3)" end="(84, 57)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(83, 3)" end="(84, 57)">
                          <OtherNode start="(83, 3)" end="(83, 31)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(83, 3)" end="(83, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(83, 5)" end="(83, 12)">
                              <NullNode start="(83, 5)" end="(83, 12)">
                                <OtherNode start="(83, 5)" end="(83, 7)" kind="«term[_]»">
                                  <AtomNode start="(83, 5)" end="(83, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(83, 6)" end="(83, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(83, 7)" end="(83, 8)" leading="" trailing=" " val=","/>
                                <IdentNode start="(83, 9)" end="(83, 12)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(83, 13)" end="(83, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(83, 16)" end="(83, 31)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(83, 16)" end="(83, 20)" leading="" trailing=" " raw_val="pure" val="pure" full_name="Pure.pure" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(83, 21)" end="(83, 31)">
                                <IdentNode start="(83, 21)" end="(83, 31)" leading="" trailing="&#10;  " raw_val="acc.toList" val="acc.toList"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(84, 3)" end="(84, 57)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(84, 3)" end="(84, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(84, 5)" end="(84, 17)">
                              <NullNode start="(84, 5)" end="(84, 17)">
                                <OtherNode start="(84, 5)" end="(84, 12)" kind="«term_::_»">
                                  <IdentNode start="(84, 5)" end="(84, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <AtomNode start="(84, 7)" end="(84, 9)" leading="" trailing=" " val="::"/>
                                  <IdentNode start="(84, 10)" end="(84, 12)" leading="" trailing="" raw_val="as" val="as"/>
                                </OtherNode>
                                <AtomNode start="(84, 12)" end="(84, 13)" leading="" trailing=" " val=","/>
                                <IdentNode start="(84, 14)" end="(84, 17)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(84, 18)" end="(84, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(84, 21)" end="(84, 57)" kind="Lean.Parser.Term.do">
                              <AtomNode start="(84, 21)" end="(84, 23)" leading="" trailing=" " val="do"/>
                              <OtherNode start="(84, 24)" end="(84, 57)" kind="Lean.Parser.Term.doSeqIndent">
                                <NullNode start="(84, 24)" end="(84, 57)">
                                  <OtherNode start="(84, 24)" end="(84, 57)" kind="Lean.Parser.Term.doSeqItem">
                                    <OtherNode start="(84, 24)" end="(84, 57)" kind="Lean.Parser.Term.doExpr">
                                      <OtherNode start="(84, 24)" end="(84, 57)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(84, 24)" end="(84, 26)" leading="" trailing=" " raw_val="go" val="go"/>
                                        <NullNode start="(84, 27)" end="(84, 57)">
                                          <IdentNode start="(84, 27)" end="(84, 29)" leading="" trailing=" " raw_val="as" val="as"/>
                                          <OtherNode start="(84, 30)" end="(84, 57)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(84, 30)" end="(84, 31)" leading="" trailing="" val="("/>
                                            <OtherNode start="(84, 31)" end="(84, 56)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(84, 31)" end="(84, 39)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                              <NullNode start="(84, 40)" end="(84, 56)">
                                                <OtherNode start="(84, 40)" end="(84, 56)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(84, 40)" end="(84, 41)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(84, 41)" end="(84, 55)" kind="Lean.Parser.Term.liftMethod">
                                                    <AtomNode start="(84, 41)" end="(84, 42)" leading="" trailing=" " val="←"/>
                                                    <OtherNode start="(84, 43)" end="(84, 55)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(84, 43)" end="(84, 44)" leading="" trailing=" " raw_val="f" val="f"/>
                                                      <NullNode start="(84, 45)" end="(84, 55)">
                                                        <IdentNode start="(84, 45)" end="(84, 53)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
                                                        <IdentNode start="(84, 54)" end="(84, 55)" leading="" trailing="" raw_val="a" val="a"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <AtomNode start="(84, 55)" end="(84, 56)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(84, 56)" end="(84, 57)" leading="" trailing="&#10;&#10;" val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(86, 1)" end="(86, 21)" comment="### mapFinIdx -/">
      <AtomNode start="(86, 1)" end="(86, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(86, 5)" end="(86, 21)" leading="" trailing="&#10;&#10;" val="### mapFinIdx -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(88, 1)" end="(92, 6)" name="mapFinIdx_congr" full_name="List.mapFinIdx_congr">
      <CommandDeclmodifiersNode start="(88, 1)" end="(88, 9)">
        <NullNode/>
        <NullNode start="(88, 1)" end="(88, 9)">
          <OtherNode start="(88, 1)" end="(88, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(88, 1)" end="(88, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(88, 3)" end="(88, 8)">
              <OtherNode start="(88, 3)" end="(88, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(88, 3)" end="(88, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(88, 3)" end="(88, 8)" leading="" trailing="" raw_val="congr" val="congr"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(88, 8)" end="(88, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(88, 10)" end="(92, 6)" name="mapFinIdx_congr" full_name="List.mapFinIdx_congr" _is_private_decl="False">
        <AtomNode start="(88, 10)" end="(88, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(88, 18)" end="(88, 33)">
          <IdentNode start="(88, 18)" end="(88, 33)" leading="" trailing=" " raw_val="mapFinIdx_congr" val="mapFinIdx_congr"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(88, 34)" end="(90, 76)">
          <NullNode start="(88, 34)" end="(89, 50)">
            <OtherNode start="(88, 34)" end="(88, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(88, 34)" end="(88, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(88, 35)" end="(88, 40)">
                <IdentNode start="(88, 35)" end="(88, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(88, 38)" end="(88, 40)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(88, 41)" end="(88, 49)">
                <AtomNode start="(88, 41)" end="(88, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 43)" end="(88, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(88, 43)" end="(88, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(88, 48)" end="(88, 49)">
                    <IdentNode start="(88, 48)" end="(88, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(88, 49)" end="(88, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(88, 51)" end="(88, 64)">
              <AtomNode start="(88, 51)" end="(88, 52)" leading="" trailing="" val="("/>
              <NullNode start="(88, 52)" end="(88, 53)">
                <IdentNode start="(88, 52)" end="(88, 53)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(88, 54)" end="(88, 63)">
                <AtomNode start="(88, 54)" end="(88, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 56)" end="(88, 63)" kind="«term_=_»">
                  <IdentNode start="(88, 56)" end="(88, 58)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(88, 59)" end="(88, 60)" leading="" trailing=" " val="="/>
                  <IdentNode start="(88, 61)" end="(88, 63)" leading="" trailing="" raw_val="ys" val="ys"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(88, 63)" end="(88, 64)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(89, 5)" end="(89, 50)">
              <AtomNode start="(89, 5)" end="(89, 6)" leading="" trailing="" val="("/>
              <NullNode start="(89, 6)" end="(89, 7)">
                <IdentNode start="(89, 6)" end="(89, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(89, 8)" end="(89, 49)">
                <AtomNode start="(89, 8)" end="(89, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(89, 10)" end="(89, 49)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(89, 10)" end="(89, 19)">
                    <AtomNode start="(89, 10)" end="(89, 11)" leading="" trailing="" val="("/>
                    <NullNode start="(89, 11)" end="(89, 12)">
                      <IdentNode start="(89, 11)" end="(89, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(89, 13)" end="(89, 18)">
                      <AtomNode start="(89, 13)" end="(89, 14)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(89, 15)" end="(89, 18)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(89, 18)" end="(89, 19)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(89, 20)" end="(89, 21)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(89, 22)" end="(89, 49)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(89, 22)" end="(89, 23)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(89, 24)" end="(89, 25)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(89, 26)" end="(89, 49)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(89, 26)" end="(89, 45)">
                        <AtomNode start="(89, 26)" end="(89, 27)" leading="" trailing="" val="("/>
                        <NullNode start="(89, 27)" end="(89, 28)">
                          <IdentNode start="(89, 27)" end="(89, 28)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(89, 29)" end="(89, 44)">
                          <AtomNode start="(89, 29)" end="(89, 30)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(89, 31)" end="(89, 44)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(89, 31)" end="(89, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(89, 33)" end="(89, 34)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(89, 35)" end="(89, 44)" leading="" trailing="" raw_val="xs.length" val="xs.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(89, 44)" end="(89, 45)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(89, 46)" end="(89, 47)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(89, 48)" end="(89, 49)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(89, 49)" end="(89, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(89, 51)" end="(90, 76)">
            <AtomNode start="(89, 51)" end="(89, 52)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(90, 5)" end="(90, 76)" kind="«term_=_»">
              <OtherNode start="(90, 5)" end="(90, 19)" kind="Lean.Parser.Term.app">
                <IdentNode start="(90, 5)" end="(90, 14)" leading="" trailing=" " raw_val="mapFinIdx" val="mapFinIdx" full_name="List.mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(30, 15)" def_end="(30, 24)"/>
                <NullNode start="(90, 15)" end="(90, 19)">
                  <IdentNode start="(90, 15)" end="(90, 17)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(90, 18)" end="(90, 19)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(90, 20)" end="(90, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(90, 22)" end="(90, 76)" kind="Lean.Parser.Term.app">
                <IdentNode start="(90, 22)" end="(90, 31)" leading="" trailing=" " raw_val="mapFinIdx" val="mapFinIdx" full_name="List.mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(30, 15)" def_end="(30, 24)"/>
                <NullNode start="(90, 32)" end="(90, 76)">
                  <IdentNode start="(90, 32)" end="(90, 34)" leading="" trailing=" " raw_val="ys" val="ys"/>
                  <OtherNode start="(90, 35)" end="(90, 76)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(90, 35)" end="(90, 36)" leading="" trailing="" val="("/>
                    <OtherNode start="(90, 36)" end="(90, 75)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(90, 36)" end="(90, 39)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(90, 40)" end="(90, 75)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(90, 40)" end="(90, 45)">
                          <IdentNode start="(90, 40)" end="(90, 41)" leading="" trailing=" " raw_val="i" val="i"/>
                          <IdentNode start="(90, 42)" end="(90, 43)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(90, 44)" end="(90, 45)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(90, 46)" end="(90, 48)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(90, 49)" end="(90, 75)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(90, 49)" end="(90, 50)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(90, 51)" end="(90, 75)">
                            <IdentNode start="(90, 51)" end="(90, 52)" leading="" trailing=" " raw_val="i" val="i"/>
                            <IdentNode start="(90, 53)" end="(90, 54)" leading="" trailing=" " raw_val="a" val="a"/>
                            <OtherNode start="(90, 55)" end="(90, 75)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(90, 55)" end="(90, 56)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(90, 56)" end="(90, 74)">
                                <AtomNode start="(90, 56)" end="(90, 58)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(90, 59)" end="(90, 74)">
                                  <TacticTacticseq1IndentedNode start="(90, 59)" end="(90, 74)">
                                    <NullNode start="(90, 59)" end="(90, 74)">
                                      <OtherNode start="(90, 59)" end="(90, 67)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.3666&#10;β : Type ?u.3695&#10;xs ys : List α&#10;w : xs = ys&#10;f : (i : Nat) → α → i &amp;lt; xs.length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; ys.length&#10;⊢ i &amp;lt; xs.length" state_after="α : Type ?u.3666&#10;β : Type ?u.3695&#10;xs ys : List α&#10;w : xs = ys&#10;f : (i : Nat) → α → i &amp;lt; xs.length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; ys.length&#10;⊢ i &amp;lt; ys.length" tactic="simp [w]">
                                        <AtomNode start="(90, 59)" end="(90, 63)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(90, 64)" end="(90, 67)">
                                          <AtomNode start="(90, 64)" end="(90, 65)" leading="" trailing="" val="["/>
                                          <NullNode start="(90, 65)" end="(90, 66)">
                                            <OtherNode start="(90, 65)" end="(90, 66)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(90, 65)" end="(90, 66)" leading="" trailing="" raw_val="w" val="w"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(90, 66)" end="(90, 67)" leading="" trailing="" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(90, 67)" end="(90, 68)" leading="" trailing=" " val=";"/>
                                      <OtherNode start="(90, 69)" end="(90, 74)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.3666&#10;β : Type ?u.3695&#10;xs ys : List α&#10;w : xs = ys&#10;f : (i : Nat) → α → i &amp;lt; xs.length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; ys.length&#10;⊢ i &amp;lt; ys.length" state_after="no goals" tactic="omega">
                                        <AtomNode start="(90, 69)" end="(90, 74)" leading="" trailing="" val="omega"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(90, 74)" end="(90, 75)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(90, 75)" end="(90, 76)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(90, 77)" end="(92, 6)">
          <AtomNode start="(90, 77)" end="(90, 79)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(90, 80)" end="(92, 6)">
            <AtomNode start="(90, 80)" end="(90, 82)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(91, 3)" end="(92, 6)">
              <TacticTacticseq1IndentedNode start="(91, 3)" end="(92, 6)">
                <NullNode start="(91, 3)" end="(92, 6)">
                  <OtherNode start="(91, 3)" end="(91, 10)" kind="Lean.Parser.Tactic.subst" state_before="α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;w : xs = ys&#10;f : (i : Nat) → α → i &amp;lt; xs.length → β&#10;⊢ xs.mapFinIdx f = ys.mapFinIdx fun i a h =&amp;gt; f i a ⋯" state_after="α : Type u_1&#10;β : Type u_2&#10;xs : List α&#10;f : (i : Nat) → α → i &amp;lt; xs.length → β&#10;⊢ xs.mapFinIdx f = xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯" tactic="subst w">
                    <AtomNode start="(91, 3)" end="(91, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(91, 9)" end="(91, 10)">
                      <IdentNode start="(91, 9)" end="(91, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(92, 3)" end="(92, 6)" kind="Lean.Parser.Tactic.tacticRfl" state_before="α : Type u_1&#10;β : Type u_2&#10;xs : List α&#10;f : (i : Nat) → α → i &amp;lt; xs.length → β&#10;⊢ xs.mapFinIdx f = xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯" state_after="no goals" tactic="rfl">
                    <AtomNode start="(92, 3)" end="(92, 6)" leading="" trailing="&#10;&#10;" val="rfl"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(94, 1)" end="(96, 6)" name="mapFinIdx_nil" full_name="List.mapFinIdx_nil">
      <CommandDeclmodifiersNode start="(94, 1)" end="(94, 8)">
        <NullNode/>
        <NullNode start="(94, 1)" end="(94, 8)">
          <OtherNode start="(94, 1)" end="(94, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(94, 1)" end="(94, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(94, 3)" end="(94, 7)">
              <OtherNode start="(94, 3)" end="(94, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(94, 3)" end="(94, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(94, 3)" end="(94, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(94, 7)" end="(94, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(95, 1)" end="(96, 6)" name="mapFinIdx_nil" full_name="List.mapFinIdx_nil" _is_private_decl="False">
        <AtomNode start="(95, 1)" end="(95, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(95, 9)" end="(95, 22)">
          <IdentNode start="(95, 9)" end="(95, 22)" leading="" trailing=" " raw_val="mapFinIdx_nil" val="mapFinIdx_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(95, 23)" end="(95, 82)">
          <NullNode start="(95, 23)" end="(95, 60)">
            <OtherNode start="(95, 23)" end="(95, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(95, 23)" end="(95, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(95, 24)" end="(95, 25)">
                <IdentNode start="(95, 24)" end="(95, 25)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(95, 26)" end="(95, 59)">
                <AtomNode start="(95, 26)" end="(95, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(95, 28)" end="(95, 59)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(95, 28)" end="(95, 37)">
                    <AtomNode start="(95, 28)" end="(95, 29)" leading="" trailing="" val="("/>
                    <NullNode start="(95, 29)" end="(95, 30)">
                      <IdentNode start="(95, 29)" end="(95, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(95, 31)" end="(95, 36)">
                      <AtomNode start="(95, 31)" end="(95, 32)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(95, 33)" end="(95, 36)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(95, 36)" end="(95, 37)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(95, 38)" end="(95, 39)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(95, 40)" end="(95, 59)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(95, 40)" end="(95, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(95, 42)" end="(95, 43)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(95, 44)" end="(95, 59)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(95, 44)" end="(95, 55)">
                        <AtomNode start="(95, 44)" end="(95, 45)" leading="" trailing="" val="("/>
                        <NullNode start="(95, 45)" end="(95, 46)">
                          <IdentNode start="(95, 45)" end="(95, 46)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(95, 47)" end="(95, 54)">
                          <AtomNode start="(95, 47)" end="(95, 48)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(95, 49)" end="(95, 54)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(95, 49)" end="(95, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(95, 51)" end="(95, 52)" leading="" trailing=" " val="&amp;lt;"/>
                            <OtherNode start="(95, 53)" end="(95, 54)" kind="num">
                              <AtomNode start="(95, 53)" end="(95, 54)" leading="" trailing="" val="0"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(95, 54)" end="(95, 55)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(95, 56)" end="(95, 57)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(95, 58)" end="(95, 59)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(95, 59)" end="(95, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(95, 61)" end="(95, 82)">
            <AtomNode start="(95, 61)" end="(95, 62)" leading="" trailing=" " val=":"/>
            <OtherNode start="(95, 63)" end="(95, 82)" kind="«term_=_»">
              <OtherNode start="(95, 63)" end="(95, 77)" kind="Lean.Parser.Term.app">
                <IdentNode start="(95, 63)" end="(95, 72)" leading="" trailing=" " raw_val="mapFinIdx" val="mapFinIdx" full_name="List.mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(30, 15)" def_end="(30, 24)"/>
                <NullNode start="(95, 73)" end="(95, 77)">
                  <OtherNode start="(95, 73)" end="(95, 75)" kind="«term[_]»">
                    <AtomNode start="(95, 73)" end="(95, 74)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(95, 74)" end="(95, 75)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                  <IdentNode start="(95, 76)" end="(95, 77)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(95, 78)" end="(95, 79)" leading="" trailing=" " val="="/>
              <OtherNode start="(95, 80)" end="(95, 82)" kind="«term[_]»">
                <AtomNode start="(95, 80)" end="(95, 81)" leading="" trailing="" val="["/>
                <NullNode/>
                <AtomNode start="(95, 81)" end="(95, 82)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(95, 83)" end="(96, 6)">
          <AtomNode start="(95, 83)" end="(95, 85)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(96, 3)" end="(96, 6)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(98, 1)" end="(102, 43)" name="length_mapFinIdx_go" full_name="List.length_mapFinIdx_go">
      <CommandDeclmodifiersNode start="(98, 1)" end="(98, 8)">
        <NullNode/>
        <NullNode start="(98, 1)" end="(98, 8)">
          <OtherNode start="(98, 1)" end="(98, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(98, 1)" end="(98, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(98, 3)" end="(98, 7)">
              <OtherNode start="(98, 3)" end="(98, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(98, 3)" end="(98, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(98, 3)" end="(98, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(98, 7)" end="(98, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(98, 9)" end="(102, 43)" name="length_mapFinIdx_go" full_name="List.length_mapFinIdx_go" _is_private_decl="False">
        <AtomNode start="(98, 9)" end="(98, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(98, 17)" end="(98, 36)">
          <IdentNode start="(98, 17)" end="(98, 36)" leading="" trailing=" " raw_val="length_mapFinIdx_go" val="length_mapFinIdx_go"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(98, 37)" end="(99, 52)">
          <NullNode/>
          <TermTypespecNode start="(98, 37)" end="(99, 52)">
            <AtomNode start="(98, 37)" end="(98, 38)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(99, 5)" end="(99, 52)" kind="«term_=_»">
              <OtherNode start="(99, 5)" end="(99, 40)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(99, 5)" end="(99, 33)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(99, 5)" end="(99, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(99, 6)" end="(99, 32)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(99, 6)" end="(99, 18)" leading="" trailing=" " raw_val="mapFinIdx.go" val="mapFinIdx.go" full_name="List.mapFinIdx.go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(35, 17)" def_end="(35, 19)"/>
                    <NullNode start="(99, 19)" end="(99, 32)">
                      <IdentNode start="(99, 19)" end="(99, 21)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(99, 22)" end="(99, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(99, 24)" end="(99, 26)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      <IdentNode start="(99, 27)" end="(99, 30)" leading="" trailing=" " raw_val="acc" val="acc"/>
                      <IdentNode start="(99, 31)" end="(99, 32)" leading="" trailing="" raw_val="h" val="h"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(99, 32)" end="(99, 33)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(99, 33)" end="(99, 34)" leading="" trailing="" val="."/>
                <IdentNode start="(99, 34)" end="(99, 40)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(99, 41)" end="(99, 42)" leading="" trailing=" " val="="/>
              <IdentNode start="(99, 43)" end="(99, 52)" leading="" trailing=" " raw_val="as.length" val="as.length"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(99, 53)" end="(102, 43)">
          <AtomNode start="(99, 53)" end="(99, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(99, 56)" end="(102, 43)">
            <AtomNode start="(99, 56)" end="(99, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(100, 3)" end="(102, 43)">
              <TacticTacticseq1IndentedNode start="(100, 3)" end="(102, 43)">
                <NullNode start="(100, 3)" end="(102, 43)">
                  <OtherNode start="(100, 3)" end="(102, 43)" kind="Lean.Parser.Tactic.induction" state_before="α✝¹ : Type u_1&#10;as : List α✝¹&#10;α✝ : Type u_2&#10;f : (i : Nat) → α✝¹ → i &amp;lt; as.length → α✝&#10;bs : List α✝¹&#10;acc : Array α✝&#10;h : bs.length + acc.size = as.length&#10;⊢ (mapFinIdx.go as f bs acc h).length = as.length" state_after="no goals" tactic="induction bs generalizing acc with&#10;| nil =&amp;gt; simpa using h&#10;| cons _ _ ih =&amp;gt; simp [mapFinIdx.go, ih]">
                    <AtomNode start="(100, 3)" end="(100, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(100, 13)" end="(100, 15)">
                      <OtherNode start="(100, 13)" end="(100, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(100, 13)" end="(100, 15)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(100, 16)" end="(100, 32)">
                      <AtomNode start="(100, 16)" end="(100, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(100, 29)" end="(100, 32)">
                        <IdentNode start="(100, 29)" end="(100, 32)" leading="" trailing=" " raw_val="acc" val="acc"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(100, 33)" end="(102, 43)">
                      <OtherNode start="(100, 33)" end="(102, 43)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(100, 33)" end="(100, 37)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(101, 3)" end="(102, 43)">
                          <OtherNode start="(101, 3)" end="(101, 25)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(101, 3)" end="(101, 8)">
                              <OtherNode start="(101, 3)" end="(101, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(101, 3)" end="(101, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(101, 5)" end="(101, 8)">
                                  <NullNode/>
                                  <IdentNode start="(101, 5)" end="(101, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(101, 9)" end="(101, 25)">
                              <AtomNode start="(101, 9)" end="(101, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(101, 12)" end="(101, 25)">
                                <TacticTacticseq1IndentedNode start="(101, 12)" end="(101, 25)">
                                  <NullNode start="(101, 12)" end="(101, 25)">
                                    <OtherNode start="(101, 12)" end="(101, 25)" kind="Lean.Parser.Tactic.simpa" state_before="case nil&#10;α✝¹ : Type u_1&#10;as : List α✝¹&#10;α✝ : Type u_2&#10;f : (i : Nat) → α✝¹ → i &amp;lt; as.length → α✝&#10;acc : Array α✝&#10;h : [].length + acc.size = as.length&#10;⊢ (mapFinIdx.go as f [] acc h).length = as.length" state_after="no goals" tactic="simpa using h">
                                      <AtomNode start="(101, 12)" end="(101, 17)" leading="" trailing=" " val="simpa"/>
                                      <NullNode/>
                                      <NullNode/>
                                      <OtherNode start="(101, 18)" end="(101, 25)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(101, 18)" end="(101, 25)">
                                          <AtomNode start="(101, 18)" end="(101, 23)" leading="" trailing=" " val="using"/>
                                          <IdentNode start="(101, 24)" end="(101, 25)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(102, 3)" end="(102, 43)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(102, 3)" end="(102, 16)">
                              <OtherNode start="(102, 3)" end="(102, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(102, 3)" end="(102, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(102, 5)" end="(102, 9)">
                                  <NullNode/>
                                  <IdentNode start="(102, 5)" end="(102, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(102, 10)" end="(102, 16)">
                                  <TermHoleNode start="(102, 10)" end="(102, 11)">
                                    <AtomNode start="(102, 10)" end="(102, 11)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(102, 12)" end="(102, 13)">
                                    <AtomNode start="(102, 12)" end="(102, 13)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <IdentNode start="(102, 14)" end="(102, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(102, 17)" end="(102, 43)">
                              <AtomNode start="(102, 17)" end="(102, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(102, 20)" end="(102, 43)">
                                <TacticTacticseq1IndentedNode start="(102, 20)" end="(102, 43)">
                                  <NullNode start="(102, 20)" end="(102, 43)">
                                    <OtherNode start="(102, 20)" end="(102, 43)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α✝¹ : Type u_1&#10;as : List α✝¹&#10;α✝ : Type u_2&#10;f : (i : Nat) → α✝¹ → i &amp;lt; as.length → α✝&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;ih : ∀ {acc : Array α✝} {h : tail✝.length + acc.size = as.length}, (mapFinIdx.go as f tail✝ acc h).length = as.length&#10;acc : Array α✝&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;⊢ (mapFinIdx.go as f (head✝ :: tail✝) acc h).length = as.length" state_after="no goals" tactic="simp [mapFinIdx.go, ih]">
                                      <AtomNode start="(102, 20)" end="(102, 24)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(102, 25)" end="(102, 43)">
                                        <AtomNode start="(102, 25)" end="(102, 26)" leading="" trailing="" val="["/>
                                        <NullNode start="(102, 26)" end="(102, 42)">
                                          <OtherNode start="(102, 26)" end="(102, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(102, 26)" end="(102, 38)" leading="" trailing="" raw_val="mapFinIdx.go" val="mapFinIdx.go" full_name="List.mapFinIdx.go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(35, 17)" def_end="(35, 19)"/>
                                          </OtherNode>
                                          <AtomNode start="(102, 38)" end="(102, 39)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(102, 40)" end="(102, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(102, 40)" end="(102, 42)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(102, 42)" end="(102, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(104, 1)" end="(106, 40)" name="length_mapFinIdx" full_name="List.length_mapFinIdx">
      <CommandDeclmodifiersNode start="(104, 1)" end="(104, 8)">
        <NullNode/>
        <NullNode start="(104, 1)" end="(104, 8)">
          <OtherNode start="(104, 1)" end="(104, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(104, 1)" end="(104, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(104, 3)" end="(104, 7)">
              <OtherNode start="(104, 3)" end="(104, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(104, 3)" end="(104, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(104, 3)" end="(104, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(104, 7)" end="(104, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(104, 9)" end="(106, 40)" name="length_mapFinIdx" full_name="List.length_mapFinIdx" _is_private_decl="False">
        <AtomNode start="(104, 9)" end="(104, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(104, 17)" end="(104, 33)">
          <IdentNode start="(104, 17)" end="(104, 33)" leading="" trailing=" " raw_val="length_mapFinIdx" val="length_mapFinIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(104, 34)" end="(105, 40)">
          <NullNode start="(104, 34)" end="(104, 93)">
            <OtherNode start="(104, 34)" end="(104, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(104, 34)" end="(104, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(104, 35)" end="(104, 37)">
                <IdentNode start="(104, 35)" end="(104, 37)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(104, 38)" end="(104, 46)">
                <AtomNode start="(104, 38)" end="(104, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(104, 40)" end="(104, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(104, 40)" end="(104, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(104, 45)" end="(104, 46)">
                    <IdentNode start="(104, 45)" end="(104, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(104, 46)" end="(104, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(104, 48)" end="(104, 93)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(104, 48)" end="(104, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(104, 49)" end="(104, 50)">
                <IdentNode start="(104, 49)" end="(104, 50)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(104, 51)" end="(104, 92)">
                <AtomNode start="(104, 51)" end="(104, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(104, 53)" end="(104, 92)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(104, 53)" end="(104, 62)">
                    <AtomNode start="(104, 53)" end="(104, 54)" leading="" trailing="" val="("/>
                    <NullNode start="(104, 54)" end="(104, 55)">
                      <IdentNode start="(104, 54)" end="(104, 55)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(104, 56)" end="(104, 61)">
                      <AtomNode start="(104, 56)" end="(104, 57)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(104, 58)" end="(104, 61)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(104, 61)" end="(104, 62)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(104, 63)" end="(104, 64)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(104, 65)" end="(104, 92)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(104, 65)" end="(104, 66)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(104, 67)" end="(104, 68)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(104, 69)" end="(104, 92)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(104, 69)" end="(104, 88)">
                        <AtomNode start="(104, 69)" end="(104, 70)" leading="" trailing="" val="("/>
                        <NullNode start="(104, 70)" end="(104, 71)">
                          <IdentNode start="(104, 70)" end="(104, 71)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(104, 72)" end="(104, 87)">
                          <AtomNode start="(104, 72)" end="(104, 73)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(104, 74)" end="(104, 87)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(104, 74)" end="(104, 75)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(104, 76)" end="(104, 77)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(104, 78)" end="(104, 87)" leading="" trailing="" raw_val="as.length" val="as.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(104, 87)" end="(104, 88)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(104, 89)" end="(104, 90)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(104, 91)" end="(104, 92)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(104, 92)" end="(104, 93)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(104, 94)" end="(105, 40)">
            <AtomNode start="(104, 94)" end="(104, 95)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(105, 5)" end="(105, 40)" kind="«term_=_»">
              <OtherNode start="(105, 5)" end="(105, 28)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(105, 5)" end="(105, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(105, 5)" end="(105, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(105, 6)" end="(105, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(105, 6)" end="(105, 18)" leading="" trailing=" " raw_val="as.mapFinIdx" val="as.mapFinIdx"/>
                    <NullNode start="(105, 19)" end="(105, 20)">
                      <IdentNode start="(105, 19)" end="(105, 20)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(105, 20)" end="(105, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(105, 21)" end="(105, 22)" leading="" trailing="" val="."/>
                <IdentNode start="(105, 22)" end="(105, 28)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(105, 29)" end="(105, 30)" leading="" trailing=" " val="="/>
              <IdentNode start="(105, 31)" end="(105, 40)" leading="" trailing=" " raw_val="as.length" val="as.length"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(105, 41)" end="(106, 40)">
          <AtomNode start="(105, 41)" end="(105, 43)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(105, 44)" end="(106, 40)">
            <AtomNode start="(105, 44)" end="(105, 46)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(106, 3)" end="(106, 40)">
              <TacticTacticseq1IndentedNode start="(106, 3)" end="(106, 40)">
                <NullNode start="(106, 3)" end="(106, 40)">
                  <OtherNode start="(106, 3)" end="(106, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;⊢ (as.mapFinIdx f).length = as.length" state_after="no goals" tactic="simp [mapFinIdx, length_mapFinIdx_go]">
                    <AtomNode start="(106, 3)" end="(106, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(106, 8)" end="(106, 40)">
                      <AtomNode start="(106, 8)" end="(106, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(106, 9)" end="(106, 39)">
                        <OtherNode start="(106, 9)" end="(106, 18)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(106, 9)" end="(106, 18)" leading="" trailing="" raw_val="mapFinIdx" val="mapFinIdx" full_name="List.mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(30, 15)" def_end="(30, 24)"/>
                        </OtherNode>
                        <AtomNode start="(106, 18)" end="(106, 19)" leading="" trailing=" " val=","/>
                        <OtherNode start="(106, 20)" end="(106, 39)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(106, 20)" end="(106, 39)" leading="" trailing="" raw_val="length_mapFinIdx_go" val="length_mapFinIdx_go" full_name="List.length_mapFinIdx_go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(98, 17)" def_end="(98, 36)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(106, 39)" end="(106, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(108, 1)" end="(130, 16)" name="getElem_mapFinIdx_go" full_name="List.getElem_mapFinIdx_go">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(108, 1)" end="(130, 16)" name="getElem_mapFinIdx_go" full_name="List.getElem_mapFinIdx_go" _is_private_decl="False">
        <AtomNode start="(108, 1)" end="(108, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(108, 9)" end="(108, 29)">
          <IdentNode start="(108, 9)" end="(108, 29)" leading="" trailing=" " raw_val="getElem_mapFinIdx_go" val="getElem_mapFinIdx_go"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(108, 30)" end="(113, 75)">
          <NullNode start="(108, 30)" end="(108, 107)">
            <OtherNode start="(108, 30)" end="(108, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(108, 30)" end="(108, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(108, 31)" end="(108, 33)">
                <IdentNode start="(108, 31)" end="(108, 33)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(108, 34)" end="(108, 42)">
                <AtomNode start="(108, 34)" end="(108, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(108, 36)" end="(108, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(108, 36)" end="(108, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(108, 41)" end="(108, 42)">
                    <IdentNode start="(108, 41)" end="(108, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(108, 42)" end="(108, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(108, 44)" end="(108, 89)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(108, 44)" end="(108, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(108, 45)" end="(108, 46)">
                <IdentNode start="(108, 45)" end="(108, 46)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(108, 47)" end="(108, 88)">
                <AtomNode start="(108, 47)" end="(108, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(108, 49)" end="(108, 88)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(108, 49)" end="(108, 58)">
                    <AtomNode start="(108, 49)" end="(108, 50)" leading="" trailing="" val="("/>
                    <NullNode start="(108, 50)" end="(108, 51)">
                      <IdentNode start="(108, 50)" end="(108, 51)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(108, 52)" end="(108, 57)">
                      <AtomNode start="(108, 52)" end="(108, 53)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(108, 54)" end="(108, 57)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(108, 57)" end="(108, 58)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(108, 59)" end="(108, 60)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(108, 61)" end="(108, 88)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(108, 61)" end="(108, 62)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(108, 63)" end="(108, 64)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(108, 65)" end="(108, 88)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(108, 65)" end="(108, 84)">
                        <AtomNode start="(108, 65)" end="(108, 66)" leading="" trailing="" val="("/>
                        <NullNode start="(108, 66)" end="(108, 67)">
                          <IdentNode start="(108, 66)" end="(108, 67)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(108, 68)" end="(108, 83)">
                          <AtomNode start="(108, 68)" end="(108, 69)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(108, 70)" end="(108, 83)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(108, 70)" end="(108, 71)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(108, 72)" end="(108, 73)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(108, 74)" end="(108, 83)" leading="" trailing="" raw_val="as.length" val="as.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(108, 83)" end="(108, 84)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(108, 85)" end="(108, 86)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(108, 87)" end="(108, 88)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(108, 88)" end="(108, 89)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(108, 90)" end="(108, 99)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(108, 90)" end="(108, 91)" leading="" trailing="" val="{"/>
              <NullNode start="(108, 91)" end="(108, 92)">
                <IdentNode start="(108, 91)" end="(108, 92)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(108, 93)" end="(108, 98)">
                <AtomNode start="(108, 93)" end="(108, 94)" leading="" trailing=" " val=":"/>
                <IdentNode start="(108, 95)" end="(108, 98)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(108, 98)" end="(108, 99)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(108, 100)" end="(108, 103)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(108, 100)" end="(108, 101)" leading="" trailing="" val="{"/>
              <NullNode start="(108, 101)" end="(108, 102)">
                <IdentNode start="(108, 101)" end="(108, 102)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(108, 102)" end="(108, 103)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(108, 104)" end="(108, 107)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(108, 104)" end="(108, 105)" leading="" trailing="" val="{"/>
              <NullNode start="(108, 105)" end="(108, 106)">
                <IdentNode start="(108, 105)" end="(108, 106)" leading="" trailing="" raw_val="w" val="w"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(108, 106)" end="(108, 107)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(108, 108)" end="(113, 75)">
            <AtomNode start="(108, 108)" end="(108, 109)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(109, 5)" end="(113, 75)" kind="«term_=_»">
              <OtherNode start="(109, 5)" end="(109, 36)" kind="«term__[_]»">
                <OtherNode start="(109, 5)" end="(109, 33)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(109, 5)" end="(109, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(109, 6)" end="(109, 32)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(109, 6)" end="(109, 18)" leading="" trailing=" " raw_val="mapFinIdx.go" val="mapFinIdx.go" full_name="List.mapFinIdx.go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(35, 17)" def_end="(35, 19)"/>
                    <NullNode start="(109, 19)" end="(109, 32)">
                      <IdentNode start="(109, 19)" end="(109, 21)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(109, 22)" end="(109, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(109, 24)" end="(109, 26)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      <IdentNode start="(109, 27)" end="(109, 30)" leading="" trailing=" " raw_val="acc" val="acc"/>
                      <IdentNode start="(109, 31)" end="(109, 32)" leading="" trailing="" raw_val="h" val="h"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(109, 32)" end="(109, 33)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(109, 33)" end="(109, 34)" leading="" trailing="" val="["/>
                <IdentNode start="(109, 34)" end="(109, 35)" leading="" trailing="" raw_val="i" val="i"/>
                <AtomNode start="(109, 35)" end="(109, 36)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(109, 37)" end="(109, 38)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(110, 7)" end="(113, 75)" kind="termDepIfThenElse">
                <AtomNode start="(110, 7)" end="(110, 9)" leading="" trailing=" " val="if"/>
                <LeanBinderidentNode start="(110, 10)" end="(110, 12)">
                  <IdentNode start="(110, 10)" end="(110, 12)" leading="" trailing=" " raw_val="w'" val="w'"/>
                </LeanBinderidentNode>
                <AtomNode start="(110, 13)" end="(110, 14)" leading="" trailing=" " val=":"/>
                <OtherNode start="(110, 15)" end="(110, 27)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(110, 15)" end="(110, 16)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(110, 17)" end="(110, 18)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(110, 19)" end="(110, 27)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
                </OtherNode>
                <AtomNode start="(110, 28)" end="(110, 32)" leading="" trailing="&#10;        " val="then"/>
                <OtherNode start="(111, 9)" end="(111, 15)" kind="«term__[_]»">
                  <IdentNode start="(111, 9)" end="(111, 12)" leading="" trailing="" raw_val="acc" val="acc"/>
                  <AtomNode start="(111, 12)" end="(111, 13)" leading="" trailing="" val="["/>
                  <IdentNode start="(111, 13)" end="(111, 14)" leading="" trailing="" raw_val="i" val="i"/>
                  <AtomNode start="(111, 14)" end="(111, 15)" leading="" trailing="&#10;      " val="]"/>
                </OtherNode>
                <AtomNode start="(112, 7)" end="(112, 11)" leading="" trailing="&#10;        " val="else"/>
                <OtherNode start="(113, 9)" end="(113, 75)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(113, 9)" end="(113, 10)" leading="" trailing=" " raw_val="f" val="f"/>
                  <NullNode start="(113, 11)" end="(113, 75)">
                    <IdentNode start="(113, 11)" end="(113, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                    <OtherNode start="(113, 13)" end="(113, 53)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(113, 13)" end="(113, 14)" leading="" trailing="" val="("/>
                      <OtherNode start="(113, 14)" end="(113, 52)" kind="«term__[_]'_»">
                        <IdentNode start="(113, 14)" end="(113, 16)" leading="" trailing="" raw_val="bs" val="bs"/>
                        <AtomNode start="(113, 16)" end="(113, 17)" leading="" trailing="" val="["/>
                        <OtherNode start="(113, 17)" end="(113, 29)" kind="«term_-_»">
                          <IdentNode start="(113, 17)" end="(113, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(113, 19)" end="(113, 20)" leading="" trailing=" " val="-"/>
                          <IdentNode start="(113, 21)" end="(113, 29)" leading="" trailing="" raw_val="acc.size" val="acc.size"/>
                        </OtherNode>
                        <AtomNode start="(113, 29)" end="(113, 31)" leading="" trailing="" val="]'"/>
                        <OtherNode start="(113, 31)" end="(113, 52)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(113, 31)" end="(113, 32)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(113, 32)" end="(113, 51)">
                            <AtomNode start="(113, 32)" end="(113, 34)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(113, 35)" end="(113, 51)">
                              <TacticTacticseq1IndentedNode start="(113, 35)" end="(113, 51)">
                                <NullNode start="(113, 35)" end="(113, 51)">
                                  <OtherNode start="(113, 35)" end="(113, 44)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.5541&#10;β : Type ?u.5580&#10;bs : List α&#10;acc : Array β&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;h : bs.length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f bs acc h).length&#10;w' : ¬i &amp;lt; acc.size&#10;⊢ i - acc.size &amp;lt; bs.length" state_after="α : Type ?u.5541&#10;β : Type ?u.5580&#10;bs : List α&#10;acc : Array β&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;h : bs.length + acc.size = as.length&#10;w' : ¬i &amp;lt; acc.size&#10;w : i &amp;lt; as.length&#10;⊢ i - acc.size &amp;lt; bs.length" tactic="simp at w">
                                    <AtomNode start="(113, 35)" end="(113, 39)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(113, 40)" end="(113, 44)">
                                      <OtherNode start="(113, 40)" end="(113, 44)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(113, 40)" end="(113, 42)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(113, 43)" end="(113, 44)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(113, 43)" end="(113, 44)">
                                            <IdentNode start="(113, 43)" end="(113, 44)" leading="" trailing="" raw_val="w" val="w"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(113, 44)" end="(113, 45)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(113, 46)" end="(113, 51)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.5541&#10;β : Type ?u.5580&#10;bs : List α&#10;acc : Array β&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;h : bs.length + acc.size = as.length&#10;w' : ¬i &amp;lt; acc.size&#10;w : i &amp;lt; as.length&#10;⊢ i - acc.size &amp;lt; bs.length" state_after="no goals" tactic="omega">
                                    <AtomNode start="(113, 46)" end="(113, 51)" leading="" trailing="" val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(113, 51)" end="(113, 52)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(113, 52)" end="(113, 53)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(113, 54)" end="(113, 75)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(113, 54)" end="(113, 55)" leading="" trailing="" val="("/>
                      <TermBytacticNode start="(113, 55)" end="(113, 74)">
                        <AtomNode start="(113, 55)" end="(113, 57)" leading="" trailing=" " val="by"/>
                        <TacticTacticseqNode start="(113, 58)" end="(113, 74)">
                          <TacticTacticseq1IndentedNode start="(113, 58)" end="(113, 74)">
                            <NullNode start="(113, 58)" end="(113, 74)">
                              <OtherNode start="(113, 58)" end="(113, 67)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.5541&#10;β : Type ?u.5580&#10;bs : List α&#10;acc : Array β&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;h : bs.length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f bs acc h).length&#10;w' : ¬i &amp;lt; acc.size&#10;⊢ i &amp;lt; as.length" state_after="α : Type ?u.5541&#10;β : Type ?u.5580&#10;bs : List α&#10;acc : Array β&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;h : bs.length + acc.size = as.length&#10;w' : ¬i &amp;lt; acc.size&#10;w : i &amp;lt; as.length&#10;⊢ i &amp;lt; as.length" tactic="simp at w">
                                <AtomNode start="(113, 58)" end="(113, 62)" leading="" trailing=" " val="simp"/>
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(113, 63)" end="(113, 67)">
                                  <OtherNode start="(113, 63)" end="(113, 67)" kind="Lean.Parser.Tactic.location">
                                    <AtomNode start="(113, 63)" end="(113, 65)" leading="" trailing=" " val="at"/>
                                    <OtherNode start="(113, 66)" end="(113, 67)" kind="Lean.Parser.Tactic.locationHyp">
                                      <NullNode start="(113, 66)" end="(113, 67)">
                                        <IdentNode start="(113, 66)" end="(113, 67)" leading="" trailing="" raw_val="w" val="w"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(113, 67)" end="(113, 68)" leading="" trailing=" " val=";"/>
                              <OtherNode start="(113, 69)" end="(113, 74)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.5541&#10;β : Type ?u.5580&#10;bs : List α&#10;acc : Array β&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;h : bs.length + acc.size = as.length&#10;w' : ¬i &amp;lt; acc.size&#10;w : i &amp;lt; as.length&#10;⊢ i &amp;lt; as.length" state_after="no goals" tactic="omega">
                                <AtomNode start="(113, 69)" end="(113, 74)" leading="" trailing="" val="omega"/>
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </TacticTacticseq1IndentedNode>
                        </TacticTacticseqNode>
                      </TermBytacticNode>
                      <AtomNode start="(113, 74)" end="(113, 75)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(113, 76)" end="(130, 16)">
          <AtomNode start="(113, 76)" end="(113, 78)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(113, 79)" end="(130, 16)">
            <AtomNode start="(113, 79)" end="(113, 81)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(114, 3)" end="(130, 16)">
              <TacticTacticseq1IndentedNode start="(114, 3)" end="(130, 16)">
                <NullNode start="(114, 3)" end="(130, 16)">
                  <OtherNode start="(114, 3)" end="(130, 16)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;bs : List α&#10;acc : Array β&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;h : bs.length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f bs acc h).length&#10;⊢ (mapFinIdx.go as f bs acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i bs[i - acc.size] ⋯" state_after="no goals" tactic="induction bs generalizing acc with&#10;| nil =&amp;gt;&#10;  simp only [length_mapFinIdx_go, length_nil, Nat.zero_add] at w h&#10;  simp only [mapFinIdx.go, Array.getElem_toList]&#10;  rw [dif_pos]&#10;| cons _ _ ih =&amp;gt;&#10;  simp [mapFinIdx.go]&#10;  rw [ih]&#10;  simp&#10;  split &amp;lt;;&amp;gt; rename_i h₁ &amp;lt;;&amp;gt; split &amp;lt;;&amp;gt; rename_i h₂&#10;  · rw [Array.getElem_push_lt]&#10;  · have h₃ : i = acc.size := by omega&#10;    subst h₃&#10;    simp&#10;  · omega&#10;  · have h₃ : i - acc.size = (i - (acc.size + 1)) + 1 := by omega&#10;    simp [h₃]">
                    <AtomNode start="(114, 3)" end="(114, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(114, 13)" end="(114, 15)">
                      <OtherNode start="(114, 13)" end="(114, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(114, 13)" end="(114, 15)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(114, 16)" end="(114, 32)">
                      <AtomNode start="(114, 16)" end="(114, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(114, 29)" end="(114, 32)">
                        <IdentNode start="(114, 29)" end="(114, 32)" leading="" trailing=" " raw_val="acc" val="acc"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(114, 33)" end="(130, 16)">
                      <OtherNode start="(114, 33)" end="(130, 16)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(114, 33)" end="(114, 37)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(115, 3)" end="(130, 16)">
                          <OtherNode start="(115, 3)" end="(118, 17)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(115, 3)" end="(115, 8)">
                              <OtherNode start="(115, 3)" end="(115, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(115, 3)" end="(115, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(115, 5)" end="(115, 8)">
                                  <NullNode/>
                                  <IdentNode start="(115, 5)" end="(115, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(115, 9)" end="(118, 17)">
                              <AtomNode start="(115, 9)" end="(115, 11)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(116, 5)" end="(118, 17)">
                                <TacticTacticseq1IndentedNode start="(116, 5)" end="(118, 17)">
                                  <NullNode start="(116, 5)" end="(118, 17)">
                                    <OtherNode start="(116, 5)" end="(116, 69)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;acc : Array β&#10;h : [].length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f [] acc h).length&#10;⊢ (mapFinIdx.go as f [] acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i [][i - acc.size] ⋯" state_after="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;acc : Array β&#10;h✝ : [].length + acc.size = as.length&#10;w✝ : i &amp;lt; (mapFinIdx.go as f [] acc h✝).length&#10;w : i &amp;lt; as.length&#10;h : acc.size = as.length&#10;⊢ (mapFinIdx.go as f [] acc h✝)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i [][i - acc.size] ⋯" tactic="simp only [length_mapFinIdx_go, length_nil, Nat.zero_add] at w h">
                                      <AtomNode start="(116, 5)" end="(116, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(116, 10)" end="(116, 14)">
                                        <AtomNode start="(116, 10)" end="(116, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(116, 15)" end="(116, 62)">
                                        <AtomNode start="(116, 15)" end="(116, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(116, 16)" end="(116, 61)">
                                          <OtherNode start="(116, 16)" end="(116, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(116, 16)" end="(116, 35)" leading="" trailing="" raw_val="length_mapFinIdx_go" val="length_mapFinIdx_go" full_name="List.length_mapFinIdx_go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(98, 17)" def_end="(98, 36)"/>
                                          </OtherNode>
                                          <AtomNode start="(116, 35)" end="(116, 36)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(116, 37)" end="(116, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(116, 37)" end="(116, 47)" leading="" trailing="" raw_val="length_nil" val="length_nil" full_name="List.length_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(116, 47)" end="(116, 48)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(116, 49)" end="(116, 61)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(116, 49)" end="(116, 61)" leading="" trailing="" raw_val="Nat.zero_add" val="Nat.zero_add" full_name="Nat.zero_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(116, 61)" end="(116, 62)" leading="" trailing=" " val="]"/>
                                      </NullNode>
                                      <NullNode start="(116, 63)" end="(116, 69)">
                                        <OtherNode start="(116, 63)" end="(116, 69)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(116, 63)" end="(116, 65)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(116, 66)" end="(116, 69)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(116, 66)" end="(116, 69)">
                                              <IdentNode start="(116, 66)" end="(116, 67)" leading="" trailing=" " raw_val="w" val="w"/>
                                              <IdentNode start="(116, 68)" end="(116, 69)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(117, 5)" end="(117, 51)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;acc : Array β&#10;h✝ : [].length + acc.size = as.length&#10;w✝ : i &amp;lt; (mapFinIdx.go as f [] acc h✝).length&#10;w : i &amp;lt; as.length&#10;h : acc.size = as.length&#10;⊢ (mapFinIdx.go as f [] acc h✝)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i [][i - acc.size] ⋯" state_after="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;acc : Array β&#10;h✝ : [].length + acc.size = as.length&#10;w✝ : i &amp;lt; (mapFinIdx.go as f [] acc h✝).length&#10;w : i &amp;lt; as.length&#10;h : acc.size = as.length&#10;⊢ acc[i] = if w' : i &amp;lt; acc.size then acc[i] else f i [][i - acc.size] ⋯" tactic="simp only [mapFinIdx.go, Array.getElem_toList]">
                                      <AtomNode start="(117, 5)" end="(117, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(117, 10)" end="(117, 14)">
                                        <AtomNode start="(117, 10)" end="(117, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(117, 15)" end="(117, 51)">
                                        <AtomNode start="(117, 15)" end="(117, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(117, 16)" end="(117, 50)">
                                          <OtherNode start="(117, 16)" end="(117, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(117, 16)" end="(117, 28)" leading="" trailing="" raw_val="mapFinIdx.go" val="mapFinIdx.go" full_name="List.mapFinIdx.go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(35, 17)" def_end="(35, 19)"/>
                                          </OtherNode>
                                          <AtomNode start="(117, 28)" end="(117, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(117, 30)" end="(117, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(117, 30)" end="(117, 50)" leading="" trailing="" raw_val="Array.getElem_toList" val="Array.getElem_toList" full_name="Array.getElem_toList" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(117, 50)" end="(117, 51)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(118, 5)" end="(118, 17)" kind="Lean.Parser.Tactic.rwSeq" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;acc : Array β&#10;h✝ : [].length + acc.size = as.length&#10;w✝ : i &amp;lt; (mapFinIdx.go as f [] acc h✝).length&#10;w : i &amp;lt; as.length&#10;h : acc.size = as.length&#10;⊢ acc[i] = if w' : i &amp;lt; acc.size then acc[i] else f i [][i - acc.size] ⋯" state_after="no goals" tactic="rw [dif_pos]">
                                      <AtomNode start="(118, 5)" end="(118, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(118, 8)" end="(118, 17)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(118, 8)" end="(118, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(118, 9)" end="(118, 16)">
                                          <OtherNode start="(118, 9)" end="(118, 16)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(118, 9)" end="(118, 16)" leading="" trailing="" raw_val="dif_pos" val="dif_pos" full_name="dif_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(118, 16)" end="(118, 17)" leading="" trailing="&#10;  " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(119, 3)" end="(130, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(119, 3)" end="(119, 16)">
                              <OtherNode start="(119, 3)" end="(119, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(119, 3)" end="(119, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(119, 5)" end="(119, 9)">
                                  <NullNode/>
                                  <IdentNode start="(119, 5)" end="(119, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(119, 10)" end="(119, 16)">
                                  <TermHoleNode start="(119, 10)" end="(119, 11)">
                                    <AtomNode start="(119, 10)" end="(119, 11)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(119, 12)" end="(119, 13)">
                                    <AtomNode start="(119, 12)" end="(119, 13)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <IdentNode start="(119, 14)" end="(119, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(119, 17)" end="(130, 16)">
                              <AtomNode start="(119, 17)" end="(119, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(120, 5)" end="(130, 16)">
                                <TacticTacticseq1IndentedNode start="(120, 5)" end="(130, 16)">
                                  <NullNode start="(120, 5)" end="(130, 16)">
                                    <OtherNode start="(120, 5)" end="(120, 24)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;⊢ (mapFinIdx.go as f (head✝ :: tail✝) acc h)[i] =&#10;    if w' : i &amp;lt; acc.size then acc[i] else f i (head✝ :: tail✝)[i - acc.size] ⋯" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;⊢ (mapFinIdx.go as f tail✝ (acc.push (f acc.size head✝ ⋯)) ⋯)[i] =&#10;    if w' : i &amp;lt; acc.size then acc[i] else f i (head✝ :: tail✝)[i - acc.size] ⋯" tactic="simp [mapFinIdx.go]">
                                      <AtomNode start="(120, 5)" end="(120, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(120, 10)" end="(120, 24)">
                                        <AtomNode start="(120, 10)" end="(120, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(120, 11)" end="(120, 23)">
                                          <OtherNode start="(120, 11)" end="(120, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(120, 11)" end="(120, 23)" leading="" trailing="" raw_val="mapFinIdx.go" val="mapFinIdx.go" full_name="List.mapFinIdx.go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(35, 17)" def_end="(35, 19)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(120, 23)" end="(120, 24)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(121, 5)" end="(121, 12)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;⊢ (mapFinIdx.go as f tail✝ (acc.push (f acc.size head✝ ⋯)) ⋯)[i] =&#10;    if w' : i &amp;lt; acc.size then acc[i] else f i (head✝ :: tail✝)[i - acc.size] ⋯" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;⊢ (if w' : i &amp;lt; (acc.push (f acc.size head✝ ⋯)).size then (acc.push (f acc.size head✝ ⋯))[i]&#10;    else f i tail✝[i - (acc.push (f acc.size head✝ ⋯)).size] ⋯) =&#10;    if w' : i &amp;lt; acc.size then acc[i] else f i (head✝ :: tail✝)[i - acc.size] ⋯" tactic="rw [ih]">
                                      <AtomNode start="(121, 5)" end="(121, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(121, 8)" end="(121, 12)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(121, 8)" end="(121, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(121, 9)" end="(121, 11)">
                                          <OtherNode start="(121, 9)" end="(121, 11)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(121, 9)" end="(121, 11)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(121, 11)" end="(121, 12)" leading="" trailing="&#10;    " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(122, 5)" end="(122, 9)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;⊢ (if w' : i &amp;lt; (acc.push (f acc.size head✝ ⋯)).size then (acc.push (f acc.size head✝ ⋯))[i]&#10;    else f i tail✝[i - (acc.push (f acc.size head✝ ⋯)).size] ⋯) =&#10;    if w' : i &amp;lt; acc.size then acc[i] else f i (head✝ :: tail✝)[i - acc.size] ⋯" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;⊢ (if h_1 : i &amp;lt; acc.size + 1 then (acc.push (f acc.size head✝ ⋯))[i] else f i tail✝[i - (acc.size + 1)] ⋯) =&#10;    if w' : i &amp;lt; acc.size then acc[i] else f i (head✝ :: tail✝)[i - acc.size] ⋯" tactic="simp">
                                      <AtomNode start="(122, 5)" end="(122, 9)" leading="" trailing="&#10;    " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(123, 5)" end="(123, 52)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;⊢ (if h_1 : i &amp;lt; acc.size + 1 then (acc.push (f acc.size head✝ ⋯))[i] else f i tail✝[i - (acc.size + 1)] ⋯) =&#10;    if w' : i &amp;lt; acc.size then acc[i] else f i (head✝ :: tail✝)[i - acc.size] ⋯" state_after="case cons.isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : i &amp;lt; acc.size + 1&#10;h₂ : i &amp;lt; acc.size&#10;⊢ (acc.push (f acc.size head✝ ⋯))[i] = acc[i]&#10;&#10;case cons.isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ (acc.push (f acc.size head✝ ⋯))[i] = f i (head✝ :: tail✝)[i - acc.size] ⋯&#10;&#10;case cons.isFalse.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = acc[i]&#10;&#10;case cons.isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = f i (head✝ :: tail✝)[i - acc.size] ⋯" tactic="split &amp;lt;;&amp;gt; rename_i h₁ &amp;lt;;&amp;gt; split &amp;lt;;&amp;gt; rename_i h₂">
                                      <OtherNode start="(123, 5)" end="(123, 36)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                                        <OtherNode start="(123, 5)" end="(123, 26)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                                          <OtherNode start="(123, 5)" end="(123, 10)" kind="Lean.Parser.Tactic.split">
                                            <AtomNode start="(123, 5)" end="(123, 10)" leading="" trailing=" " val="split"/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                          <AtomNode start="(123, 11)" end="(123, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                          <OtherNode start="(123, 15)" end="(123, 26)" kind="Lean.Parser.Tactic.renameI">
                                            <AtomNode start="(123, 15)" end="(123, 23)" leading="" trailing=" " val="rename_i"/>
                                            <NullNode start="(123, 24)" end="(123, 26)">
                                              <LeanBinderidentNode start="(123, 24)" end="(123, 26)">
                                                <IdentNode start="(123, 24)" end="(123, 26)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                              </LeanBinderidentNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(123, 27)" end="(123, 30)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                        <OtherNode start="(123, 31)" end="(123, 36)" kind="Lean.Parser.Tactic.split">
                                          <AtomNode start="(123, 31)" end="(123, 36)" leading="" trailing=" " val="split"/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(123, 37)" end="(123, 40)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(123, 41)" end="(123, 52)" kind="Lean.Parser.Tactic.renameI">
                                        <AtomNode start="(123, 41)" end="(123, 49)" leading="" trailing=" " val="rename_i"/>
                                        <NullNode start="(123, 50)" end="(123, 52)">
                                          <LeanBinderidentNode start="(123, 50)" end="(123, 52)">
                                            <IdentNode start="(123, 50)" end="(123, 52)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                          </LeanBinderidentNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(124, 5)" end="(124, 33)" kind="Lean.cdot" state_before="case cons.isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : i &amp;lt; acc.size + 1&#10;h₂ : i &amp;lt; acc.size&#10;⊢ (acc.push (f acc.size head✝ ⋯))[i] = acc[i]&#10;&#10;case cons.isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ (acc.push (f acc.size head✝ ⋯))[i] = f i (head✝ :: tail✝)[i - acc.size] ⋯&#10;&#10;case cons.isFalse.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = acc[i]&#10;&#10;case cons.isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = f i (head✝ :: tail✝)[i - acc.size] ⋯" state_after="case cons.isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ (acc.push (f acc.size head✝ ⋯))[i] = f i (head✝ :: tail✝)[i - acc.size] ⋯&#10;&#10;case cons.isFalse.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = acc[i]&#10;&#10;case cons.isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = f i (head✝ :: tail✝)[i - acc.size] ⋯" tactic="· rw [Array.getElem_push_lt]">
                                      <OtherNode start="(124, 5)" end="(124, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(124, 5)" end="(124, 6)" kind="patternIgnore">
                                          <OtherNode start="(124, 5)" end="(124, 6)" kind="token.«· »">
                                            <AtomNode start="(124, 5)" end="(124, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(124, 7)" end="(124, 33)">
                                        <TacticTacticseq1IndentedNode start="(124, 7)" end="(124, 33)">
                                          <NullNode start="(124, 7)" end="(124, 33)">
                                            <OtherNode start="(124, 7)" end="(124, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : i &amp;lt; acc.size + 1&#10;h₂ : i &amp;lt; acc.size&#10;⊢ (acc.push (f acc.size head✝ ⋯))[i] = acc[i]" state_after="no goals" tactic="rw [Array.getElem_push_lt]">
                                              <AtomNode start="(124, 7)" end="(124, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(124, 10)" end="(124, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(124, 10)" end="(124, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(124, 11)" end="(124, 32)">
                                                  <OtherNode start="(124, 11)" end="(124, 32)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(124, 11)" end="(124, 32)" leading="" trailing="" raw_val="Array.getElem_push_lt" val="Array.getElem_push_lt" full_name="Array.getElem_push_lt" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(124, 32)" end="(124, 33)" leading="" trailing="&#10;    " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(125, 5)" end="(127, 11)" kind="Lean.cdot" state_before="case cons.isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ (acc.push (f acc.size head✝ ⋯))[i] = f i (head✝ :: tail✝)[i - acc.size] ⋯&#10;&#10;case cons.isFalse.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = acc[i]&#10;&#10;case cons.isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = f i (head✝ :: tail✝)[i - acc.size] ⋯" state_after="case cons.isFalse.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = acc[i]&#10;&#10;case cons.isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = f i (head✝ :: tail✝)[i - acc.size] ⋯" tactic="· have h₃ : i = acc.size := by omega&#10;  subst h₃&#10;  simp">
                                      <OtherNode start="(125, 5)" end="(125, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(125, 5)" end="(125, 6)" kind="patternIgnore">
                                          <OtherNode start="(125, 5)" end="(125, 6)" kind="token.«· »">
                                            <AtomNode start="(125, 5)" end="(125, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(125, 7)" end="(127, 11)">
                                        <TacticTacticseq1IndentedNode start="(125, 7)" end="(127, 11)">
                                          <NullNode start="(125, 7)" end="(127, 11)">
                                            <OtherNode start="(125, 7)" end="(125, 41)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case cons.isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ (acc.push (f acc.size head✝ ⋯))[i] = f i (head✝ :: tail✝)[i - acc.size] ⋯" state_after="case cons.isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;h₃ : i = acc.size&#10;⊢ (acc.push (f acc.size head✝ ⋯))[i] = f i (head✝ :: tail✝)[i - acc.size] ⋯" tactic="have h₃ : i = acc.size := by omega">
                                              <AtomNode start="(125, 7)" end="(125, 11)" leading="" trailing=" " val="have"/>
                                              <OtherNode start="(125, 12)" end="(125, 41)" kind="Lean.Parser.Term.haveDecl">
                                                <OtherNode start="(125, 12)" end="(125, 41)" kind="Lean.Parser.Term.haveIdDecl">
                                                  <OtherNode start="(125, 12)" end="(125, 14)" kind="Lean.Parser.Term.haveId">
                                                    <IdentNode start="(125, 12)" end="(125, 14)" leading="" trailing=" " raw_val="h₃" val="h₃"/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode start="(125, 15)" end="(125, 29)">
                                                    <TermTypespecNode start="(125, 15)" end="(125, 29)">
                                                      <AtomNode start="(125, 15)" end="(125, 16)" leading="" trailing=" " val=":"/>
                                                      <OtherNode start="(125, 17)" end="(125, 29)" kind="«term_=_»">
                                                        <IdentNode start="(125, 17)" end="(125, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                                                        <AtomNode start="(125, 19)" end="(125, 20)" leading="" trailing=" " val="="/>
                                                        <IdentNode start="(125, 21)" end="(125, 29)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
                                                      </OtherNode>
                                                    </TermTypespecNode>
                                                  </NullNode>
                                                  <AtomNode start="(125, 30)" end="(125, 32)" leading="" trailing=" " val=":="/>
                                                  <TermBytacticNode start="(125, 33)" end="(125, 41)">
                                                    <AtomNode start="(125, 33)" end="(125, 35)" leading="" trailing=" " val="by"/>
                                                    <TacticTacticseqNode start="(125, 36)" end="(125, 41)">
                                                      <TacticTacticseq1IndentedNode start="(125, 36)" end="(125, 41)">
                                                        <NullNode start="(125, 36)" end="(125, 41)">
                                                          <OtherNode start="(125, 36)" end="(125, 41)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ i = acc.size" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(125, 36)" end="(125, 41)" leading="" trailing="&#10;      " val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </TermBytacticNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(126, 7)" end="(126, 15)" kind="Lean.Parser.Tactic.subst" state_before="case cons.isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;h₃ : i = acc.size&#10;⊢ (acc.push (f acc.size head✝ ⋯))[i] = f i (head✝ :: tail✝)[i - acc.size] ⋯" state_after="case cons.isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;head✝ : α&#10;tail✝ : List α&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;ih :&#10;  ∀ {acc_1 : Array β} {h : tail✝.length + acc_1.size = as.length}&#10;    {w : acc.size &amp;lt; (mapFinIdx.go as f tail✝ acc_1 h).length},&#10;    (mapFinIdx.go as f tail✝ acc_1 h)[acc.size] =&#10;      if w' : acc.size &amp;lt; acc_1.size then acc_1[acc.size] else f acc.size tail✝[acc.size - acc_1.size] ⋯&#10;w : acc.size &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : acc.size &amp;lt; acc.size + 1&#10;h₂ : ¬acc.size &amp;lt; acc.size&#10;⊢ (acc.push (f acc.size head✝ ⋯))[acc.size] = f acc.size (head✝ :: tail✝)[acc.size - acc.size] ⋯" tactic="subst h₃">
                                              <AtomNode start="(126, 7)" end="(126, 12)" leading="" trailing=" " val="subst"/>
                                              <NullNode start="(126, 13)" end="(126, 15)">
                                                <IdentNode start="(126, 13)" end="(126, 15)" leading="" trailing="&#10;      " raw_val="h₃" val="h₃"/>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(127, 7)" end="(127, 11)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;head✝ : α&#10;tail✝ : List α&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;ih :&#10;  ∀ {acc_1 : Array β} {h : tail✝.length + acc_1.size = as.length}&#10;    {w : acc.size &amp;lt; (mapFinIdx.go as f tail✝ acc_1 h).length},&#10;    (mapFinIdx.go as f tail✝ acc_1 h)[acc.size] =&#10;      if w' : acc.size &amp;lt; acc_1.size then acc_1[acc.size] else f acc.size tail✝[acc.size - acc_1.size] ⋯&#10;w : acc.size &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : acc.size &amp;lt; acc.size + 1&#10;h₂ : ¬acc.size &amp;lt; acc.size&#10;⊢ (acc.push (f acc.size head✝ ⋯))[acc.size] = f acc.size (head✝ :: tail✝)[acc.size - acc.size] ⋯" state_after="no goals" tactic="simp">
                                              <AtomNode start="(127, 7)" end="(127, 11)" leading="" trailing="&#10;    " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(128, 5)" end="(128, 12)" kind="Lean.cdot" state_before="case cons.isFalse.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = acc[i]&#10;&#10;case cons.isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = f i (head✝ :: tail✝)[i - acc.size] ⋯" state_after="case cons.isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = f i (head✝ :: tail✝)[i - acc.size] ⋯" tactic="· omega">
                                      <OtherNode start="(128, 5)" end="(128, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(128, 5)" end="(128, 6)" kind="patternIgnore">
                                          <OtherNode start="(128, 5)" end="(128, 6)" kind="token.«· »">
                                            <AtomNode start="(128, 5)" end="(128, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(128, 7)" end="(128, 12)">
                                        <TacticTacticseq1IndentedNode start="(128, 7)" end="(128, 12)">
                                          <NullNode start="(128, 7)" end="(128, 12)">
                                            <OtherNode start="(128, 7)" end="(128, 12)" kind="Lean.Parser.Tactic.omega" state_before="case cons.isFalse.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = acc[i]" state_after="no goals" tactic="omega">
                                              <AtomNode start="(128, 7)" end="(128, 12)" leading="" trailing="&#10;    " val="omega"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(129, 5)" end="(130, 16)" kind="Lean.cdot" state_before="case cons.isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = f i (head✝ :: tail✝)[i - acc.size] ⋯" state_after="no goals" tactic="· have h₃ : i - acc.size = (i - (acc.size + 1)) + 1 := by omega&#10;  simp [h₃]">
                                      <OtherNode start="(129, 5)" end="(129, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(129, 5)" end="(129, 6)" kind="patternIgnore">
                                          <OtherNode start="(129, 5)" end="(129, 6)" kind="token.«· »">
                                            <AtomNode start="(129, 5)" end="(129, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(129, 7)" end="(130, 16)">
                                        <TacticTacticseq1IndentedNode start="(129, 7)" end="(130, 16)">
                                          <NullNode start="(129, 7)" end="(130, 16)">
                                            <OtherNode start="(129, 7)" end="(129, 68)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case cons.isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = f i (head✝ :: tail✝)[i - acc.size] ⋯" state_after="case cons.isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;h₃ : i - acc.size = i - (acc.size + 1) + 1&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = f i (head✝ :: tail✝)[i - acc.size] ⋯" tactic="have h₃ : i - acc.size = (i - (acc.size + 1)) + 1 := by omega">
                                              <AtomNode start="(129, 7)" end="(129, 11)" leading="" trailing=" " val="have"/>
                                              <OtherNode start="(129, 12)" end="(129, 68)" kind="Lean.Parser.Term.haveDecl">
                                                <OtherNode start="(129, 12)" end="(129, 68)" kind="Lean.Parser.Term.haveIdDecl">
                                                  <OtherNode start="(129, 12)" end="(129, 14)" kind="Lean.Parser.Term.haveId">
                                                    <IdentNode start="(129, 12)" end="(129, 14)" leading="" trailing=" " raw_val="h₃" val="h₃"/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode start="(129, 15)" end="(129, 56)">
                                                    <TermTypespecNode start="(129, 15)" end="(129, 56)">
                                                      <AtomNode start="(129, 15)" end="(129, 16)" leading="" trailing=" " val=":"/>
                                                      <OtherNode start="(129, 17)" end="(129, 56)" kind="«term_=_»">
                                                        <OtherNode start="(129, 17)" end="(129, 29)" kind="«term_-_»">
                                                          <IdentNode start="(129, 17)" end="(129, 18)" leading="" trailing=" " raw_val="i" val="i"/>
                                                          <AtomNode start="(129, 19)" end="(129, 20)" leading="" trailing=" " val="-"/>
                                                          <IdentNode start="(129, 21)" end="(129, 29)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
                                                        </OtherNode>
                                                        <AtomNode start="(129, 30)" end="(129, 31)" leading="" trailing=" " val="="/>
                                                        <OtherNode start="(129, 32)" end="(129, 56)" kind="«term_+_»">
                                                          <OtherNode start="(129, 32)" end="(129, 52)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(129, 32)" end="(129, 33)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(129, 33)" end="(129, 51)" kind="«term_-_»">
                                                            <IdentNode start="(129, 33)" end="(129, 34)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            <AtomNode start="(129, 35)" end="(129, 36)" leading="" trailing=" " val="-"/>
                                                            <OtherNode start="(129, 37)" end="(129, 51)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(129, 37)" end="(129, 38)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(129, 38)" end="(129, 50)" kind="«term_+_»">
                                                            <IdentNode start="(129, 38)" end="(129, 46)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
                                                            <AtomNode start="(129, 47)" end="(129, 48)" leading="" trailing=" " val="+"/>
                                                            <OtherNode start="(129, 49)" end="(129, 50)" kind="num">
                                                            <AtomNode start="(129, 49)" end="(129, 50)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(129, 50)" end="(129, 51)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(129, 51)" end="(129, 52)" leading="" trailing=" " val=")"/>
                                                          </OtherNode>
                                                          <AtomNode start="(129, 53)" end="(129, 54)" leading="" trailing=" " val="+"/>
                                                          <OtherNode start="(129, 55)" end="(129, 56)" kind="num">
                                                            <AtomNode start="(129, 55)" end="(129, 56)" leading="" trailing=" " val="1"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </TermTypespecNode>
                                                  </NullNode>
                                                  <AtomNode start="(129, 57)" end="(129, 59)" leading="" trailing=" " val=":="/>
                                                  <TermBytacticNode start="(129, 60)" end="(129, 68)">
                                                    <AtomNode start="(129, 60)" end="(129, 62)" leading="" trailing=" " val="by"/>
                                                    <TacticTacticseqNode start="(129, 63)" end="(129, 68)">
                                                      <TacticTacticseq1IndentedNode start="(129, 63)" end="(129, 68)">
                                                        <NullNode start="(129, 63)" end="(129, 68)">
                                                          <OtherNode start="(129, 63)" end="(129, 68)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;⊢ i - acc.size = i - (acc.size + 1) + 1" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(129, 63)" end="(129, 68)" leading="" trailing="&#10;      " val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </TermBytacticNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(130, 7)" end="(130, 16)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;head✝ : α&#10;tail✝ : List α&#10;ih :&#10;  ∀ {acc : Array β} {h : tail✝.length + acc.size = as.length} {w : i &amp;lt; (mapFinIdx.go as f tail✝ acc h).length},&#10;    (mapFinIdx.go as f tail✝ acc h)[i] = if w' : i &amp;lt; acc.size then acc[i] else f i tail✝[i - acc.size] ⋯&#10;acc : Array β&#10;h : (head✝ :: tail✝).length + acc.size = as.length&#10;w : i &amp;lt; (mapFinIdx.go as f (head✝ :: tail✝) acc h).length&#10;h₁ : ¬i &amp;lt; acc.size + 1&#10;h₂ : ¬i &amp;lt; acc.size&#10;h₃ : i - acc.size = i - (acc.size + 1) + 1&#10;⊢ f i tail✝[i - (acc.size + 1)] ⋯ = f i (head✝ :: tail✝)[i - acc.size] ⋯" state_after="no goals" tactic="simp [h₃]">
                                              <AtomNode start="(130, 7)" end="(130, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(130, 12)" end="(130, 16)">
                                                <AtomNode start="(130, 12)" end="(130, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(130, 13)" end="(130, 15)">
                                                  <OtherNode start="(130, 13)" end="(130, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(130, 13)" end="(130, 15)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(130, 15)" end="(130, 16)" leading="" trailing="&#10;&#10;" val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(132, 1)" end="(134, 41)" name="getElem_mapFinIdx" full_name="List.getElem_mapFinIdx">
      <CommandDeclmodifiersNode start="(132, 1)" end="(132, 8)">
        <NullNode/>
        <NullNode start="(132, 1)" end="(132, 8)">
          <OtherNode start="(132, 1)" end="(132, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(132, 1)" end="(132, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(132, 3)" end="(132, 7)">
              <OtherNode start="(132, 3)" end="(132, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(132, 3)" end="(132, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(132, 3)" end="(132, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(132, 7)" end="(132, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(132, 9)" end="(134, 41)" name="getElem_mapFinIdx" full_name="List.getElem_mapFinIdx" _is_private_decl="False">
        <AtomNode start="(132, 9)" end="(132, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(132, 17)" end="(132, 34)">
          <IdentNode start="(132, 17)" end="(132, 34)" leading="" trailing=" " raw_val="getElem_mapFinIdx" val="getElem_mapFinIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(132, 35)" end="(133, 82)">
          <NullNode start="(132, 35)" end="(132, 108)">
            <OtherNode start="(132, 35)" end="(132, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(132, 35)" end="(132, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(132, 36)" end="(132, 38)">
                <IdentNode start="(132, 36)" end="(132, 38)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(132, 39)" end="(132, 47)">
                <AtomNode start="(132, 39)" end="(132, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(132, 41)" end="(132, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(132, 41)" end="(132, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(132, 46)" end="(132, 47)">
                    <IdentNode start="(132, 46)" end="(132, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(132, 47)" end="(132, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(132, 49)" end="(132, 94)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(132, 49)" end="(132, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(132, 50)" end="(132, 51)">
                <IdentNode start="(132, 50)" end="(132, 51)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(132, 52)" end="(132, 93)">
                <AtomNode start="(132, 52)" end="(132, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(132, 54)" end="(132, 93)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(132, 54)" end="(132, 63)">
                    <AtomNode start="(132, 54)" end="(132, 55)" leading="" trailing="" val="("/>
                    <NullNode start="(132, 55)" end="(132, 56)">
                      <IdentNode start="(132, 55)" end="(132, 56)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(132, 57)" end="(132, 62)">
                      <AtomNode start="(132, 57)" end="(132, 58)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(132, 59)" end="(132, 62)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(132, 62)" end="(132, 63)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(132, 64)" end="(132, 65)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(132, 66)" end="(132, 93)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(132, 66)" end="(132, 67)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(132, 68)" end="(132, 69)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(132, 70)" end="(132, 93)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(132, 70)" end="(132, 89)">
                        <AtomNode start="(132, 70)" end="(132, 71)" leading="" trailing="" val="("/>
                        <NullNode start="(132, 71)" end="(132, 72)">
                          <IdentNode start="(132, 71)" end="(132, 72)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(132, 73)" end="(132, 88)">
                          <AtomNode start="(132, 73)" end="(132, 74)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(132, 75)" end="(132, 88)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(132, 75)" end="(132, 76)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(132, 77)" end="(132, 78)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(132, 79)" end="(132, 88)" leading="" trailing="" raw_val="as.length" val="as.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(132, 88)" end="(132, 89)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(132, 90)" end="(132, 91)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(132, 92)" end="(132, 93)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(132, 93)" end="(132, 94)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(132, 95)" end="(132, 104)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(132, 95)" end="(132, 96)" leading="" trailing="" val="{"/>
              <NullNode start="(132, 96)" end="(132, 97)">
                <IdentNode start="(132, 96)" end="(132, 97)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(132, 98)" end="(132, 103)">
                <AtomNode start="(132, 98)" end="(132, 99)" leading="" trailing=" " val=":"/>
                <IdentNode start="(132, 100)" end="(132, 103)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(132, 103)" end="(132, 104)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(132, 105)" end="(132, 108)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(132, 105)" end="(132, 106)" leading="" trailing="" val="{"/>
              <NullNode start="(132, 106)" end="(132, 107)">
                <IdentNode start="(132, 106)" end="(132, 107)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(132, 107)" end="(132, 108)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(132, 109)" end="(133, 82)">
            <AtomNode start="(132, 109)" end="(132, 110)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(133, 5)" end="(133, 82)" kind="«term_=_»">
              <OtherNode start="(133, 5)" end="(133, 24)" kind="«term__[_]»">
                <OtherNode start="(133, 5)" end="(133, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(133, 5)" end="(133, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(133, 6)" end="(133, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(133, 6)" end="(133, 18)" leading="" trailing=" " raw_val="as.mapFinIdx" val="as.mapFinIdx"/>
                    <NullNode start="(133, 19)" end="(133, 20)">
                      <IdentNode start="(133, 19)" end="(133, 20)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(133, 20)" end="(133, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(133, 21)" end="(133, 22)" leading="" trailing="" val="["/>
                <IdentNode start="(133, 22)" end="(133, 23)" leading="" trailing="" raw_val="i" val="i"/>
                <AtomNode start="(133, 23)" end="(133, 24)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(133, 25)" end="(133, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(133, 27)" end="(133, 82)" kind="Lean.Parser.Term.app">
                <IdentNode start="(133, 27)" end="(133, 28)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(133, 29)" end="(133, 82)">
                  <IdentNode start="(133, 29)" end="(133, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                  <OtherNode start="(133, 31)" end="(133, 60)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(133, 31)" end="(133, 32)" leading="" trailing="" val="("/>
                    <OtherNode start="(133, 32)" end="(133, 59)" kind="«term__[_]'_»">
                      <IdentNode start="(133, 32)" end="(133, 34)" leading="" trailing="" raw_val="as" val="as"/>
                      <AtomNode start="(133, 34)" end="(133, 35)" leading="" trailing="" val="["/>
                      <IdentNode start="(133, 35)" end="(133, 36)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(133, 36)" end="(133, 38)" leading="" trailing="" val="]'"/>
                      <OtherNode start="(133, 38)" end="(133, 59)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(133, 38)" end="(133, 39)" leading="" trailing="" val="("/>
                        <TermBytacticNode start="(133, 39)" end="(133, 58)">
                          <AtomNode start="(133, 39)" end="(133, 41)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(133, 42)" end="(133, 58)">
                            <TacticTacticseq1IndentedNode start="(133, 42)" end="(133, 58)">
                              <NullNode start="(133, 42)" end="(133, 58)">
                                <OtherNode start="(133, 42)" end="(133, 51)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.13150&#10;β : Type ?u.13186&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;h : i &amp;lt; (as.mapFinIdx f).length&#10;⊢ i &amp;lt; as.length" state_after="α : Type ?u.13150&#10;β : Type ?u.13186&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;h : i &amp;lt; as.length&#10;⊢ i &amp;lt; as.length" tactic="simp at h">
                                  <AtomNode start="(133, 42)" end="(133, 46)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(133, 47)" end="(133, 51)">
                                    <OtherNode start="(133, 47)" end="(133, 51)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(133, 47)" end="(133, 49)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(133, 50)" end="(133, 51)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(133, 50)" end="(133, 51)">
                                          <IdentNode start="(133, 50)" end="(133, 51)" leading="" trailing="" raw_val="h" val="h"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(133, 51)" end="(133, 52)" leading="" trailing=" " val=";"/>
                                <OtherNode start="(133, 53)" end="(133, 58)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.13150&#10;β : Type ?u.13186&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;h : i &amp;lt; as.length&#10;⊢ i &amp;lt; as.length" state_after="no goals" tactic="omega">
                                  <AtomNode start="(133, 53)" end="(133, 58)" leading="" trailing="" val="omega"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                        <AtomNode start="(133, 58)" end="(133, 59)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(133, 59)" end="(133, 60)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(133, 61)" end="(133, 82)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(133, 61)" end="(133, 62)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(133, 62)" end="(133, 81)">
                      <AtomNode start="(133, 62)" end="(133, 64)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(133, 65)" end="(133, 81)">
                        <TacticTacticseq1IndentedNode start="(133, 65)" end="(133, 81)">
                          <NullNode start="(133, 65)" end="(133, 81)">
                            <OtherNode start="(133, 65)" end="(133, 74)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.13150&#10;β : Type ?u.13186&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;h : i &amp;lt; (as.mapFinIdx f).length&#10;⊢ i &amp;lt; as.length" state_after="α : Type ?u.13150&#10;β : Type ?u.13186&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;h : i &amp;lt; as.length&#10;⊢ i &amp;lt; as.length" tactic="simp at h">
                              <AtomNode start="(133, 65)" end="(133, 69)" leading="" trailing=" " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(133, 70)" end="(133, 74)">
                                <OtherNode start="(133, 70)" end="(133, 74)" kind="Lean.Parser.Tactic.location">
                                  <AtomNode start="(133, 70)" end="(133, 72)" leading="" trailing=" " val="at"/>
                                  <OtherNode start="(133, 73)" end="(133, 74)" kind="Lean.Parser.Tactic.locationHyp">
                                    <NullNode start="(133, 73)" end="(133, 74)">
                                      <IdentNode start="(133, 73)" end="(133, 74)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(133, 74)" end="(133, 75)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(133, 76)" end="(133, 81)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.13150&#10;β : Type ?u.13186&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;h : i &amp;lt; as.length&#10;⊢ i &amp;lt; as.length" state_after="no goals" tactic="omega">
                              <AtomNode start="(133, 76)" end="(133, 81)" leading="" trailing="" val="omega"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(133, 81)" end="(133, 82)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(133, 83)" end="(134, 41)">
          <AtomNode start="(133, 83)" end="(133, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(133, 86)" end="(134, 41)">
            <AtomNode start="(133, 86)" end="(133, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(134, 3)" end="(134, 41)">
              <TacticTacticseq1IndentedNode start="(134, 3)" end="(134, 41)">
                <NullNode start="(134, 3)" end="(134, 41)">
                  <OtherNode start="(134, 3)" end="(134, 41)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;i : Nat&#10;h : i &amp;lt; (as.mapFinIdx f).length&#10;⊢ (as.mapFinIdx f)[i] = f i as[i] ⋯" state_after="no goals" tactic="simp [mapFinIdx, getElem_mapFinIdx_go]">
                    <AtomNode start="(134, 3)" end="(134, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(134, 8)" end="(134, 41)">
                      <AtomNode start="(134, 8)" end="(134, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(134, 9)" end="(134, 40)">
                        <OtherNode start="(134, 9)" end="(134, 18)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(134, 9)" end="(134, 18)" leading="" trailing="" raw_val="mapFinIdx" val="mapFinIdx" full_name="List.mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(30, 15)" def_end="(30, 24)"/>
                        </OtherNode>
                        <AtomNode start="(134, 18)" end="(134, 19)" leading="" trailing=" " val=","/>
                        <OtherNode start="(134, 20)" end="(134, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(134, 20)" end="(134, 40)" leading="" trailing="" raw_val="getElem_mapFinIdx_go" val="getElem_mapFinIdx_go" full_name="List.getElem_mapFinIdx_go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(108, 9)" def_end="(108, 29)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(134, 40)" end="(134, 41)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(136, 1)" end="(138, 29)" name="mapFinIdx_eq_ofFn" full_name="List.mapFinIdx_eq_ofFn">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(136, 1)" end="(138, 29)" name="mapFinIdx_eq_ofFn" full_name="List.mapFinIdx_eq_ofFn" _is_private_decl="False">
        <AtomNode start="(136, 1)" end="(136, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(136, 9)" end="(136, 26)">
          <IdentNode start="(136, 9)" end="(136, 26)" leading="" trailing=" " raw_val="mapFinIdx_eq_ofFn" val="mapFinIdx_eq_ofFn"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(136, 27)" end="(137, 70)">
          <NullNode start="(136, 27)" end="(136, 86)">
            <OtherNode start="(136, 27)" end="(136, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(136, 27)" end="(136, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(136, 28)" end="(136, 30)">
                <IdentNode start="(136, 28)" end="(136, 30)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(136, 31)" end="(136, 39)">
                <AtomNode start="(136, 31)" end="(136, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(136, 33)" end="(136, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(136, 33)" end="(136, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(136, 38)" end="(136, 39)">
                    <IdentNode start="(136, 38)" end="(136, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(136, 39)" end="(136, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(136, 41)" end="(136, 86)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(136, 41)" end="(136, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(136, 42)" end="(136, 43)">
                <IdentNode start="(136, 42)" end="(136, 43)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(136, 44)" end="(136, 85)">
                <AtomNode start="(136, 44)" end="(136, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(136, 46)" end="(136, 85)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(136, 46)" end="(136, 55)">
                    <AtomNode start="(136, 46)" end="(136, 47)" leading="" trailing="" val="("/>
                    <NullNode start="(136, 47)" end="(136, 48)">
                      <IdentNode start="(136, 47)" end="(136, 48)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(136, 49)" end="(136, 54)">
                      <AtomNode start="(136, 49)" end="(136, 50)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(136, 51)" end="(136, 54)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(136, 54)" end="(136, 55)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(136, 56)" end="(136, 57)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(136, 58)" end="(136, 85)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(136, 58)" end="(136, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(136, 60)" end="(136, 61)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(136, 62)" end="(136, 85)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(136, 62)" end="(136, 81)">
                        <AtomNode start="(136, 62)" end="(136, 63)" leading="" trailing="" val="("/>
                        <NullNode start="(136, 63)" end="(136, 64)">
                          <IdentNode start="(136, 63)" end="(136, 64)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(136, 65)" end="(136, 80)">
                          <AtomNode start="(136, 65)" end="(136, 66)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(136, 67)" end="(136, 80)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(136, 67)" end="(136, 68)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(136, 69)" end="(136, 70)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(136, 71)" end="(136, 80)" leading="" trailing="" raw_val="as.length" val="as.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(136, 80)" end="(136, 81)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(136, 82)" end="(136, 83)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(136, 84)" end="(136, 85)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(136, 85)" end="(136, 86)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(136, 87)" end="(137, 70)">
            <AtomNode start="(136, 87)" end="(136, 88)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(137, 5)" end="(137, 70)" kind="«term_=_»">
              <OtherNode start="(137, 5)" end="(137, 19)" kind="Lean.Parser.Term.app">
                <IdentNode start="(137, 5)" end="(137, 17)" leading="" trailing=" " raw_val="as.mapFinIdx" val="as.mapFinIdx"/>
                <NullNode start="(137, 18)" end="(137, 19)">
                  <IdentNode start="(137, 18)" end="(137, 19)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(137, 20)" end="(137, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(137, 22)" end="(137, 70)" kind="Lean.Parser.Term.app">
                <IdentNode start="(137, 22)" end="(137, 31)" leading="" trailing=" " raw_val="List.ofFn" val="List.ofFn" full_name="List.ofFn" mod_name="Init.Data.List.OfFn" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/OfFn.lean"/>
                <NullNode start="(137, 32)" end="(137, 70)">
                  <OtherNode start="(137, 32)" end="(137, 70)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(137, 32)" end="(137, 35)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(137, 36)" end="(137, 70)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(137, 36)" end="(137, 37)">
                        <IdentNode start="(137, 36)" end="(137, 37)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                      <NullNode start="(137, 38)" end="(137, 53)">
                        <TermTypespecNode start="(137, 38)" end="(137, 53)">
                          <AtomNode start="(137, 38)" end="(137, 39)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(137, 40)" end="(137, 53)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(137, 40)" end="(137, 43)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(137, 44)" end="(137, 53)">
                              <IdentNode start="(137, 44)" end="(137, 53)" leading="" trailing=" " raw_val="as.length" val="as.length"/>
                            </NullNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <AtomNode start="(137, 54)" end="(137, 56)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(137, 57)" end="(137, 70)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(137, 57)" end="(137, 58)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(137, 59)" end="(137, 70)">
                          <IdentNode start="(137, 59)" end="(137, 60)" leading="" trailing=" " raw_val="i" val="i"/>
                          <OtherNode start="(137, 61)" end="(137, 66)" kind="«term__[_]»">
                            <IdentNode start="(137, 61)" end="(137, 63)" leading="" trailing="" raw_val="as" val="as"/>
                            <AtomNode start="(137, 63)" end="(137, 64)" leading="" trailing="" val="["/>
                            <IdentNode start="(137, 64)" end="(137, 65)" leading="" trailing="" raw_val="i" val="i"/>
                            <AtomNode start="(137, 65)" end="(137, 66)" leading="" trailing=" " val="]"/>
                          </OtherNode>
                          <OtherNode start="(137, 67)" end="(137, 70)" kind="Lean.Parser.Term.proj">
                            <IdentNode start="(137, 67)" end="(137, 68)" leading="" trailing="" raw_val="i" val="i"/>
                            <AtomNode start="(137, 68)" end="(137, 69)" leading="" trailing="" val="."/>
                            <OtherNode start="(137, 69)" end="(137, 70)" kind="fieldIdx">
                              <AtomNode start="(137, 69)" end="(137, 70)" leading="" trailing=" " val="2"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(137, 71)" end="(138, 29)">
          <AtomNode start="(137, 71)" end="(137, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(137, 74)" end="(138, 29)">
            <AtomNode start="(137, 74)" end="(137, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(138, 3)" end="(138, 29)">
              <TacticTacticseq1IndentedNode start="(138, 3)" end="(138, 29)">
                <NullNode start="(138, 3)" end="(138, 29)">
                  <OtherNode start="(138, 3)" end="(138, 29)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;as : List α&#10;f : (i : Nat) → α → i &amp;lt; as.length → β&#10;⊢ as.mapFinIdx f = ofFn fun i =&amp;gt; f (↑i) as[i] ⋯" state_after="no goals" tactic="apply ext_getElem &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(138, 3)" end="(138, 20)" kind="Lean.Parser.Tactic.apply">
                      <AtomNode start="(138, 3)" end="(138, 8)" leading="" trailing=" " val="apply"/>
                      <IdentNode start="(138, 9)" end="(138, 20)" leading="" trailing=" " raw_val="ext_getElem" val="ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                    </OtherNode>
                    <AtomNode start="(138, 21)" end="(138, 24)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(138, 25)" end="(138, 29)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(138, 25)" end="(138, 29)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(140, 1)" end="(143, 17)" name="getElem?_mapFinIdx" full_name="List.getElem?_mapFinIdx">
      <CommandDeclmodifiersNode start="(140, 1)" end="(140, 8)">
        <NullNode/>
        <NullNode start="(140, 1)" end="(140, 8)">
          <OtherNode start="(140, 1)" end="(140, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(140, 1)" end="(140, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(140, 3)" end="(140, 7)">
              <OtherNode start="(140, 3)" end="(140, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(140, 3)" end="(140, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(140, 3)" end="(140, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(140, 7)" end="(140, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(140, 9)" end="(143, 17)" name="getElem?_mapFinIdx" full_name="List.getElem?_mapFinIdx" _is_private_decl="False">
        <AtomNode start="(140, 9)" end="(140, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(140, 17)" end="(140, 35)">
          <IdentNode start="(140, 17)" end="(140, 35)" leading="" trailing=" " raw_val="getElem?_mapFinIdx" val="getElem?_mapFinIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(140, 36)" end="(141, 112)">
          <NullNode start="(140, 36)" end="(140, 103)">
            <OtherNode start="(140, 36)" end="(140, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(140, 36)" end="(140, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(140, 37)" end="(140, 38)">
                <IdentNode start="(140, 37)" end="(140, 38)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(140, 39)" end="(140, 47)">
                <AtomNode start="(140, 39)" end="(140, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(140, 41)" end="(140, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(140, 41)" end="(140, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(140, 46)" end="(140, 47)">
                    <IdentNode start="(140, 46)" end="(140, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(140, 47)" end="(140, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(140, 49)" end="(140, 93)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(140, 49)" end="(140, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(140, 50)" end="(140, 51)">
                <IdentNode start="(140, 50)" end="(140, 51)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(140, 52)" end="(140, 92)">
                <AtomNode start="(140, 52)" end="(140, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(140, 54)" end="(140, 92)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(140, 54)" end="(140, 63)">
                    <AtomNode start="(140, 54)" end="(140, 55)" leading="" trailing="" val="("/>
                    <NullNode start="(140, 55)" end="(140, 56)">
                      <IdentNode start="(140, 55)" end="(140, 56)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(140, 57)" end="(140, 62)">
                      <AtomNode start="(140, 57)" end="(140, 58)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(140, 59)" end="(140, 62)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(140, 62)" end="(140, 63)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(140, 64)" end="(140, 65)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(140, 66)" end="(140, 92)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(140, 66)" end="(140, 67)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(140, 68)" end="(140, 69)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(140, 70)" end="(140, 92)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(140, 70)" end="(140, 88)">
                        <AtomNode start="(140, 70)" end="(140, 71)" leading="" trailing="" val="("/>
                        <NullNode start="(140, 71)" end="(140, 72)">
                          <IdentNode start="(140, 71)" end="(140, 72)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(140, 73)" end="(140, 87)">
                          <AtomNode start="(140, 73)" end="(140, 74)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(140, 75)" end="(140, 87)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(140, 75)" end="(140, 76)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(140, 77)" end="(140, 78)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(140, 79)" end="(140, 87)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(140, 87)" end="(140, 88)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(140, 89)" end="(140, 90)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(140, 91)" end="(140, 92)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(140, 92)" end="(140, 93)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(140, 94)" end="(140, 103)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(140, 94)" end="(140, 95)" leading="" trailing="" val="{"/>
              <NullNode start="(140, 95)" end="(140, 96)">
                <IdentNode start="(140, 95)" end="(140, 96)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(140, 97)" end="(140, 102)">
                <AtomNode start="(140, 97)" end="(140, 98)" leading="" trailing=" " val=":"/>
                <IdentNode start="(140, 99)" end="(140, 102)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(140, 102)" end="(140, 103)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(140, 104)" end="(141, 112)">
            <AtomNode start="(140, 104)" end="(140, 105)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(141, 5)" end="(141, 112)" kind="«term_=_»">
              <OtherNode start="(141, 5)" end="(141, 24)" kind="«term__[_]_?»">
                <OtherNode start="(141, 5)" end="(141, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(141, 5)" end="(141, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(141, 6)" end="(141, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(141, 6)" end="(141, 17)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                    <NullNode start="(141, 18)" end="(141, 19)">
                      <IdentNode start="(141, 18)" end="(141, 19)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(141, 19)" end="(141, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(141, 20)" end="(141, 21)" leading="" trailing="" val="["/>
                <IdentNode start="(141, 21)" end="(141, 22)" leading="" trailing="" raw_val="i" val="i"/>
                <AtomNode start="(141, 22)" end="(141, 23)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(141, 23)" end="(141, 24)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(141, 25)" end="(141, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(141, 27)" end="(141, 112)" kind="Lean.Parser.Term.app">
                <OtherNode start="(141, 27)" end="(141, 38)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(141, 27)" end="(141, 32)" kind="«term__[_]_?»">
                    <IdentNode start="(141, 27)" end="(141, 28)" leading="" trailing="" raw_val="l" val="l"/>
                    <GroupNode/>
                    <AtomNode start="(141, 28)" end="(141, 29)" leading="" trailing="" val="["/>
                    <IdentNode start="(141, 29)" end="(141, 30)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(141, 30)" end="(141, 31)" leading="" trailing="" val="]"/>
                    <GroupNode/>
                    <AtomNode start="(141, 31)" end="(141, 32)" leading="" trailing="" val="?"/>
                  </OtherNode>
                  <AtomNode start="(141, 32)" end="(141, 33)" leading="" trailing="" val="."/>
                  <IdentNode start="(141, 33)" end="(141, 38)" leading="" trailing=" " raw_val="pbind" val="pbind" full_name="Option.pbind" mod_name="Init.Data.Option.Instances" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Instances.lean"/>
                </OtherNode>
                <NullNode start="(141, 39)" end="(141, 112)">
                  <OtherNode start="(141, 39)" end="(141, 112)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(141, 39)" end="(141, 42)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(141, 43)" end="(141, 112)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(141, 43)" end="(141, 46)">
                        <IdentNode start="(141, 43)" end="(141, 44)" leading="" trailing=" " raw_val="x" val="x"/>
                        <IdentNode start="(141, 45)" end="(141, 46)" leading="" trailing=" " raw_val="m" val="m"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(141, 47)" end="(141, 49)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(141, 50)" end="(141, 112)" kind="«term_&amp;lt;|_»">
                        <IdentNode start="(141, 50)" end="(141, 54)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <AtomNode start="(141, 55)" end="(141, 57)" leading="" trailing=" " val="&amp;lt;|"/>
                        <OtherNode start="(141, 58)" end="(141, 112)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(141, 58)" end="(141, 59)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(141, 60)" end="(141, 112)">
                            <IdentNode start="(141, 60)" end="(141, 61)" leading="" trailing=" " raw_val="i" val="i"/>
                            <IdentNode start="(141, 62)" end="(141, 63)" leading="" trailing=" " raw_val="x" val="x"/>
                            <OtherNode start="(141, 64)" end="(141, 112)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(141, 64)" end="(141, 65)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(141, 65)" end="(141, 111)">
                                <AtomNode start="(141, 65)" end="(141, 67)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(141, 68)" end="(141, 111)">
                                  <TacticTacticseq1IndentedNode start="(141, 68)" end="(141, 111)">
                                    <NullNode start="(141, 68)" end="(141, 111)">
                                      <OtherNode start="(141, 68)" end="(141, 100)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.15422&#10;β : Type ?u.15454&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;i : Nat&#10;x : α&#10;m : l[i]? = some x&#10;⊢ i &amp;lt; l.length" state_after="α : Type ?u.15422&#10;β : Type ?u.15454&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;i : Nat&#10;x : α&#10;m : ∃ h, l[i] = x&#10;⊢ i &amp;lt; l.length" tactic="simp [getElem?_eq_some_iff] at m">
                                        <AtomNode start="(141, 68)" end="(141, 72)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(141, 73)" end="(141, 95)">
                                          <AtomNode start="(141, 73)" end="(141, 74)" leading="" trailing="" val="["/>
                                          <NullNode start="(141, 74)" end="(141, 94)">
                                            <OtherNode start="(141, 74)" end="(141, 94)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(141, 74)" end="(141, 94)" leading="" trailing="" raw_val="getElem?_eq_some_iff" val="getElem?_eq_some_iff" full_name="List.getElem?_eq_some_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(141, 94)" end="(141, 95)" leading="" trailing=" " val="]"/>
                                        </NullNode>
                                        <NullNode start="(141, 96)" end="(141, 100)">
                                          <OtherNode start="(141, 96)" end="(141, 100)" kind="Lean.Parser.Tactic.location">
                                            <AtomNode start="(141, 96)" end="(141, 98)" leading="" trailing=" " val="at"/>
                                            <OtherNode start="(141, 99)" end="(141, 100)" kind="Lean.Parser.Tactic.locationHyp">
                                              <NullNode start="(141, 99)" end="(141, 100)">
                                                <IdentNode start="(141, 99)" end="(141, 100)" leading="" trailing="" raw_val="m" val="m"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(141, 100)" end="(141, 101)" leading="" trailing=" " val=";"/>
                                      <OtherNode start="(141, 102)" end="(141, 111)" kind="Lean.Parser.Tactic.exact" state_before="α : Type ?u.15422&#10;β : Type ?u.15454&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;i : Nat&#10;x : α&#10;m : ∃ h, l[i] = x&#10;⊢ i &amp;lt; l.length" state_after="no goals" tactic="exact m.1">
                                        <AtomNode start="(141, 102)" end="(141, 107)" leading="" trailing=" " val="exact"/>
                                        <OtherNode start="(141, 108)" end="(141, 111)" kind="Lean.Parser.Term.proj">
                                          <IdentNode start="(141, 108)" end="(141, 109)" leading="" trailing="" raw_val="m" val="m"/>
                                          <AtomNode start="(141, 109)" end="(141, 110)" leading="" trailing="" val="."/>
                                          <OtherNode start="(141, 110)" end="(141, 111)" kind="fieldIdx">
                                            <AtomNode start="(141, 110)" end="(141, 111)" leading="" trailing="" val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(141, 111)" end="(141, 112)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(141, 113)" end="(143, 17)">
          <AtomNode start="(141, 113)" end="(141, 115)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(141, 116)" end="(143, 17)">
            <AtomNode start="(141, 116)" end="(141, 118)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(142, 3)" end="(143, 17)">
              <TacticTacticseq1IndentedNode start="(142, 3)" end="(143, 17)">
                <NullNode start="(142, 3)" end="(143, 17)">
                  <OtherNode start="(142, 3)" end="(142, 64)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;i : Nat&#10;⊢ (l.mapFinIdx f)[i]? = l[i]?.pbind fun x m =&amp;gt; some (f i x ⋯)" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;i : Nat&#10;⊢ (if h : i &amp;lt; l.length then some (f i l[i] ⋯) else none) =&#10;    (if h : i &amp;lt; l.length then some l[i] else none).pbind fun a h =&amp;gt; some (f i a ⋯)" tactic="simp only [getElem?_def, length_mapFinIdx, getElem_mapFinIdx]">
                    <AtomNode start="(142, 3)" end="(142, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(142, 8)" end="(142, 12)">
                      <AtomNode start="(142, 8)" end="(142, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(142, 13)" end="(142, 64)">
                      <AtomNode start="(142, 13)" end="(142, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(142, 14)" end="(142, 63)">
                        <OtherNode start="(142, 14)" end="(142, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(142, 14)" end="(142, 26)" leading="" trailing="" raw_val="getElem?_def" val="getElem?_def" full_name="LawfulGetElem.getElem?_def" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                        </OtherNode>
                        <AtomNode start="(142, 26)" end="(142, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(142, 28)" end="(142, 44)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(142, 28)" end="(142, 44)" leading="" trailing="" raw_val="length_mapFinIdx" val="length_mapFinIdx" full_name="List.length_mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(104, 17)" def_end="(104, 33)"/>
                        </OtherNode>
                        <AtomNode start="(142, 44)" end="(142, 45)" leading="" trailing=" " val=","/>
                        <OtherNode start="(142, 46)" end="(142, 63)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(142, 46)" end="(142, 63)" leading="" trailing="" raw_val="getElem_mapFinIdx" val="getElem_mapFinIdx" full_name="List.getElem_mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(132, 17)" def_end="(132, 34)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(142, 63)" end="(142, 64)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(143, 3)" end="(143, 17)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;i : Nat&#10;⊢ (if h : i &amp;lt; l.length then some (f i l[i] ⋯) else none) =&#10;    (if h : i &amp;lt; l.length then some l[i] else none).pbind fun a h =&amp;gt; some (f i a ⋯)" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(143, 3)" end="(143, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(143, 3)" end="(143, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(143, 9)" end="(143, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(143, 13)" end="(143, 17)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(143, 13)" end="(143, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(145, 1)" end="(150, 32)" name="mapFinIdx_cons" full_name="List.mapFinIdx_cons">
      <CommandDeclmodifiersNode start="(145, 1)" end="(145, 8)">
        <NullNode/>
        <NullNode start="(145, 1)" end="(145, 8)">
          <OtherNode start="(145, 1)" end="(145, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(145, 1)" end="(145, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(145, 3)" end="(145, 7)">
              <OtherNode start="(145, 3)" end="(145, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(145, 3)" end="(145, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(145, 3)" end="(145, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(145, 7)" end="(145, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(146, 1)" end="(150, 32)" name="mapFinIdx_cons" full_name="List.mapFinIdx_cons" _is_private_decl="False">
        <AtomNode start="(146, 1)" end="(146, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(146, 9)" end="(146, 23)">
          <IdentNode start="(146, 9)" end="(146, 23)" leading="" trailing=" " raw_val="mapFinIdx_cons" val="mapFinIdx_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(146, 24)" end="(147, 97)">
          <NullNode start="(146, 24)" end="(146, 93)">
            <OtherNode start="(146, 24)" end="(146, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(146, 24)" end="(146, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(146, 25)" end="(146, 26)">
                <IdentNode start="(146, 25)" end="(146, 26)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(146, 27)" end="(146, 35)">
                <AtomNode start="(146, 27)" end="(146, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(146, 29)" end="(146, 35)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(146, 29)" end="(146, 33)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(146, 34)" end="(146, 35)">
                    <IdentNode start="(146, 34)" end="(146, 35)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(146, 35)" end="(146, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(146, 37)" end="(146, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(146, 37)" end="(146, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(146, 38)" end="(146, 39)">
                <IdentNode start="(146, 38)" end="(146, 39)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(146, 40)" end="(146, 43)">
                <AtomNode start="(146, 40)" end="(146, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(146, 42)" end="(146, 43)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(146, 43)" end="(146, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(146, 45)" end="(146, 93)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(146, 45)" end="(146, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(146, 46)" end="(146, 47)">
                <IdentNode start="(146, 46)" end="(146, 47)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(146, 48)" end="(146, 92)">
                <AtomNode start="(146, 48)" end="(146, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(146, 50)" end="(146, 92)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(146, 50)" end="(146, 59)">
                    <AtomNode start="(146, 50)" end="(146, 51)" leading="" trailing="" val="("/>
                    <NullNode start="(146, 51)" end="(146, 52)">
                      <IdentNode start="(146, 51)" end="(146, 52)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(146, 53)" end="(146, 58)">
                      <AtomNode start="(146, 53)" end="(146, 54)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(146, 55)" end="(146, 58)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(146, 58)" end="(146, 59)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(146, 60)" end="(146, 61)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(146, 62)" end="(146, 92)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(146, 62)" end="(146, 63)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(146, 64)" end="(146, 65)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(146, 66)" end="(146, 92)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(146, 66)" end="(146, 88)">
                        <AtomNode start="(146, 66)" end="(146, 67)" leading="" trailing="" val="("/>
                        <NullNode start="(146, 67)" end="(146, 68)">
                          <IdentNode start="(146, 67)" end="(146, 68)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(146, 69)" end="(146, 87)">
                          <AtomNode start="(146, 69)" end="(146, 70)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(146, 71)" end="(146, 87)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(146, 71)" end="(146, 72)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(146, 73)" end="(146, 74)" leading="" trailing=" " val="&amp;lt;"/>
                            <OtherNode start="(146, 75)" end="(146, 87)" kind="«term_+_»">
                              <IdentNode start="(146, 75)" end="(146, 83)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                              <AtomNode start="(146, 84)" end="(146, 85)" leading="" trailing=" " val="+"/>
                              <OtherNode start="(146, 86)" end="(146, 87)" kind="num">
                                <AtomNode start="(146, 86)" end="(146, 87)" leading="" trailing="" val="1"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(146, 87)" end="(146, 88)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(146, 89)" end="(146, 90)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(146, 91)" end="(146, 92)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(146, 92)" end="(146, 93)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(146, 94)" end="(147, 97)">
            <AtomNode start="(146, 94)" end="(146, 95)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(147, 5)" end="(147, 97)" kind="«term_=_»">
              <OtherNode start="(147, 5)" end="(147, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(147, 5)" end="(147, 14)" leading="" trailing=" " raw_val="mapFinIdx" val="mapFinIdx" full_name="List.mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(30, 15)" def_end="(30, 24)"/>
                <NullNode start="(147, 15)" end="(147, 25)">
                  <OtherNode start="(147, 15)" end="(147, 23)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(147, 15)" end="(147, 16)" leading="" trailing="" val="("/>
                    <OtherNode start="(147, 16)" end="(147, 22)" kind="«term_::_»">
                      <IdentNode start="(147, 16)" end="(147, 17)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(147, 18)" end="(147, 20)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(147, 21)" end="(147, 22)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(147, 22)" end="(147, 23)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(147, 24)" end="(147, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(147, 26)" end="(147, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(147, 28)" end="(147, 97)" kind="«term_::_»">
                <OtherNode start="(147, 28)" end="(147, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(147, 28)" end="(147, 29)" leading="" trailing=" " raw_val="f" val="f"/>
                  <NullNode start="(147, 30)" end="(147, 44)">
                    <OtherNode start="(147, 30)" end="(147, 31)" kind="num">
                      <AtomNode start="(147, 30)" end="(147, 31)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                    <IdentNode start="(147, 32)" end="(147, 33)" leading="" trailing=" " raw_val="a" val="a"/>
                    <OtherNode start="(147, 34)" end="(147, 44)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(147, 34)" end="(147, 35)" leading="" trailing="" val="("/>
                      <TermBytacticNode start="(147, 35)" end="(147, 43)">
                        <AtomNode start="(147, 35)" end="(147, 37)" leading="" trailing=" " val="by"/>
                        <TacticTacticseqNode start="(147, 38)" end="(147, 43)">
                          <TacticTacticseq1IndentedNode start="(147, 38)" end="(147, 43)">
                            <NullNode start="(147, 38)" end="(147, 43)">
                              <OtherNode start="(147, 38)" end="(147, 43)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.18569&#10;β : Type ?u.18628&#10;l : List α&#10;a : α&#10;f : (i : Nat) → α → i &amp;lt; l.length + 1 → β&#10;⊢ 0 &amp;lt; l.length + 1" state_after="no goals" tactic="omega">
                                <AtomNode start="(147, 38)" end="(147, 43)" leading="" trailing="" val="omega"/>
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </TacticTacticseq1IndentedNode>
                        </TacticTacticseqNode>
                      </TermBytacticNode>
                      <AtomNode start="(147, 43)" end="(147, 44)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(147, 45)" end="(147, 47)" leading="" trailing=" " val="::"/>
                <OtherNode start="(147, 48)" end="(147, 97)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(147, 48)" end="(147, 57)" leading="" trailing=" " raw_val="mapFinIdx" val="mapFinIdx" full_name="List.mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(30, 15)" def_end="(30, 24)"/>
                  <NullNode start="(147, 58)" end="(147, 97)">
                    <IdentNode start="(147, 58)" end="(147, 59)" leading="" trailing=" " raw_val="l" val="l"/>
                    <OtherNode start="(147, 60)" end="(147, 97)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(147, 60)" end="(147, 61)" leading="" trailing="" val="("/>
                      <OtherNode start="(147, 61)" end="(147, 96)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(147, 61)" end="(147, 64)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(147, 65)" end="(147, 96)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(147, 65)" end="(147, 70)">
                            <IdentNode start="(147, 65)" end="(147, 66)" leading="" trailing=" " raw_val="i" val="i"/>
                            <IdentNode start="(147, 67)" end="(147, 68)" leading="" trailing=" " raw_val="a" val="a"/>
                            <IdentNode start="(147, 69)" end="(147, 70)" leading="" trailing=" " raw_val="h" val="h"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(147, 71)" end="(147, 73)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(147, 74)" end="(147, 96)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(147, 74)" end="(147, 75)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(147, 76)" end="(147, 96)">
                              <OtherNode start="(147, 76)" end="(147, 83)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(147, 76)" end="(147, 77)" leading="" trailing="" val="("/>
                                <OtherNode start="(147, 77)" end="(147, 82)" kind="«term_+_»">
                                  <IdentNode start="(147, 77)" end="(147, 78)" leading="" trailing=" " raw_val="i" val="i"/>
                                  <AtomNode start="(147, 79)" end="(147, 80)" leading="" trailing=" " val="+"/>
                                  <OtherNode start="(147, 81)" end="(147, 82)" kind="num">
                                    <AtomNode start="(147, 81)" end="(147, 82)" leading="" trailing="" val="1"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(147, 82)" end="(147, 83)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                              <IdentNode start="(147, 84)" end="(147, 85)" leading="" trailing=" " raw_val="a" val="a"/>
                              <OtherNode start="(147, 86)" end="(147, 96)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(147, 86)" end="(147, 87)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(147, 87)" end="(147, 95)">
                                  <AtomNode start="(147, 87)" end="(147, 89)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(147, 90)" end="(147, 95)">
                                    <TacticTacticseq1IndentedNode start="(147, 90)" end="(147, 95)">
                                      <NullNode start="(147, 90)" end="(147, 95)">
                                        <OtherNode start="(147, 90)" end="(147, 95)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.18569&#10;β : Type ?u.18628&#10;l : List α&#10;a✝ : α&#10;f : (i : Nat) → α → i &amp;lt; l.length + 1 → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l.length&#10;⊢ i + 1 &amp;lt; l.length + 1" state_after="no goals" tactic="omega">
                                          <AtomNode start="(147, 90)" end="(147, 95)" leading="" trailing="" val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(147, 95)" end="(147, 96)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(147, 96)" end="(147, 97)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(147, 98)" end="(150, 32)">
          <AtomNode start="(147, 98)" end="(147, 100)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(147, 101)" end="(150, 32)">
            <AtomNode start="(147, 101)" end="(147, 103)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(148, 3)" end="(150, 32)">
              <TacticTacticseq1IndentedNode start="(148, 3)" end="(150, 32)">
                <NullNode start="(148, 3)" end="(150, 32)">
                  <OtherNode start="(148, 3)" end="(148, 20)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;a : α&#10;f : (i : Nat) → α → i &amp;lt; l.length + 1 → β&#10;⊢ (a :: l).mapFinIdx f = f 0 a ⋯ :: l.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯" state_after="case hl&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;a : α&#10;f : (i : Nat) → α → i &amp;lt; l.length + 1 → β&#10;⊢ ((a :: l).mapFinIdx f).length = (f 0 a ⋯ :: l.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯).length&#10;&#10;case h&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;a : α&#10;f : (i : Nat) → α → i &amp;lt; l.length + 1 → β&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((a :: l).mapFinIdx f).length)&#10;    (h₂ : i &amp;lt; (f 0 a ⋯ :: l.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯).length),&#10;    ((a :: l).mapFinIdx f)[i] = (f 0 a ⋯ :: l.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯)[i]" tactic="apply ext_getElem">
                    <AtomNode start="(148, 3)" end="(148, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(148, 9)" end="(148, 20)" leading="" trailing="&#10;  " raw_val="ext_getElem" val="ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(149, 3)" end="(149, 9)" kind="Lean.cdot" state_before="case hl&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;a : α&#10;f : (i : Nat) → α → i &amp;lt; l.length + 1 → β&#10;⊢ ((a :: l).mapFinIdx f).length = (f 0 a ⋯ :: l.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯).length&#10;&#10;case h&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;a : α&#10;f : (i : Nat) → α → i &amp;lt; l.length + 1 → β&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((a :: l).mapFinIdx f).length)&#10;    (h₂ : i &amp;lt; (f 0 a ⋯ :: l.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯).length),&#10;    ((a :: l).mapFinIdx f)[i] = (f 0 a ⋯ :: l.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯)[i]" state_after="case h&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;a : α&#10;f : (i : Nat) → α → i &amp;lt; l.length + 1 → β&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((a :: l).mapFinIdx f).length)&#10;    (h₂ : i &amp;lt; (f 0 a ⋯ :: l.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯).length),&#10;    ((a :: l).mapFinIdx f)[i] = (f 0 a ⋯ :: l.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯)[i]" tactic="· simp">
                    <OtherNode start="(149, 3)" end="(149, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(149, 3)" end="(149, 4)" kind="patternIgnore">
                        <OtherNode start="(149, 3)" end="(149, 4)" kind="token.«· »">
                          <AtomNode start="(149, 3)" end="(149, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(149, 5)" end="(149, 9)">
                      <TacticTacticseq1IndentedNode start="(149, 5)" end="(149, 9)">
                        <NullNode start="(149, 5)" end="(149, 9)">
                          <OtherNode start="(149, 5)" end="(149, 9)" kind="Lean.Parser.Tactic.simp" state_before="case hl&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;a : α&#10;f : (i : Nat) → α → i &amp;lt; l.length + 1 → β&#10;⊢ ((a :: l).mapFinIdx f).length = (f 0 a ⋯ :: l.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯).length" state_after="no goals" tactic="simp">
                            <AtomNode start="(149, 5)" end="(149, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(150, 3)" end="(150, 32)" kind="Lean.cdot" state_before="case h&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;a : α&#10;f : (i : Nat) → α → i &amp;lt; l.length + 1 → β&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((a :: l).mapFinIdx f).length)&#10;    (h₂ : i &amp;lt; (f 0 a ⋯ :: l.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯).length),&#10;    ((a :: l).mapFinIdx f)[i] = (f 0 a ⋯ :: l.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯)[i]" state_after="no goals" tactic="· rintro (_|i) h₁ h₂ &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(150, 3)" end="(150, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(150, 3)" end="(150, 4)" kind="patternIgnore">
                        <OtherNode start="(150, 3)" end="(150, 4)" kind="token.«· »">
                          <AtomNode start="(150, 3)" end="(150, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(150, 5)" end="(150, 32)">
                      <TacticTacticseq1IndentedNode start="(150, 5)" end="(150, 32)">
                        <NullNode start="(150, 5)" end="(150, 32)">
                          <OtherNode start="(150, 5)" end="(150, 32)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;a : α&#10;f : (i : Nat) → α → i &amp;lt; l.length + 1 → β&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((a :: l).mapFinIdx f).length)&#10;    (h₂ : i &amp;lt; (f 0 a ⋯ :: l.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯).length),&#10;    ((a :: l).mapFinIdx f)[i] = (f 0 a ⋯ :: l.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯)[i]" state_after="no goals" tactic="rintro (_|i) h₁ h₂ &amp;lt;;&amp;gt; simp">
                            <OtherNode start="(150, 5)" end="(150, 23)" kind="Lean.Parser.Tactic.rintro">
                              <AtomNode start="(150, 5)" end="(150, 11)" leading="" trailing=" " val="rintro"/>
                              <NullNode start="(150, 12)" end="(150, 23)">
                                <OtherNode start="(150, 12)" end="(150, 17)" kind="Lean.Parser.Tactic.rintroPat.one">
                                  <OtherNode start="(150, 12)" end="(150, 17)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                    <AtomNode start="(150, 12)" end="(150, 13)" leading="" trailing="" val="("/>
                                    <OtherNode start="(150, 13)" end="(150, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(150, 13)" end="(150, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(150, 13)" end="(150, 16)">
                                          <OtherNode start="(150, 13)" end="(150, 14)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                            <AtomNode start="(150, 13)" end="(150, 14)" leading="" trailing="" val="_"/>
                                          </OtherNode>
                                          <AtomNode start="(150, 14)" end="(150, 15)" leading="" trailing="" val="|"/>
                                          <OtherNode start="(150, 15)" end="(150, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(150, 15)" end="(150, 16)" leading="" trailing="" raw_val="i" val="i"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(150, 16)" end="(150, 17)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                </OtherNode>
                                <OtherNode start="(150, 18)" end="(150, 20)" kind="Lean.Parser.Tactic.rintroPat.one">
                                  <OtherNode start="(150, 18)" end="(150, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                    <IdentNode start="(150, 18)" end="(150, 20)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                  </OtherNode>
                                </OtherNode>
                                <OtherNode start="(150, 21)" end="(150, 23)" kind="Lean.Parser.Tactic.rintroPat.one">
                                  <OtherNode start="(150, 21)" end="(150, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                    <IdentNode start="(150, 21)" end="(150, 23)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(150, 24)" end="(150, 27)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(150, 28)" end="(150, 32)" kind="Lean.Parser.Tactic.simp">
                              <AtomNode start="(150, 28)" end="(150, 32)" leading="" trailing="&#10;&#10;" val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(152, 1)" end="(166, 12)" name="mapFinIdx_append" full_name="List.mapFinIdx_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(152, 1)" end="(166, 12)" name="mapFinIdx_append" full_name="List.mapFinIdx_append" _is_private_decl="False">
        <AtomNode start="(152, 1)" end="(152, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(152, 9)" end="(152, 25)">
          <IdentNode start="(152, 9)" end="(152, 25)" leading="" trailing=" " raw_val="mapFinIdx_append" val="mapFinIdx_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(152, 26)" end="(155, 73)">
          <NullNode start="(152, 26)" end="(152, 96)">
            <OtherNode start="(152, 26)" end="(152, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(152, 26)" end="(152, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(152, 27)" end="(152, 32)">
                <IdentNode start="(152, 27)" end="(152, 29)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(152, 30)" end="(152, 32)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(152, 33)" end="(152, 41)">
                <AtomNode start="(152, 33)" end="(152, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(152, 35)" end="(152, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(152, 35)" end="(152, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(152, 40)" end="(152, 41)">
                    <IdentNode start="(152, 40)" end="(152, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(152, 41)" end="(152, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(152, 43)" end="(152, 96)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(152, 43)" end="(152, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(152, 44)" end="(152, 45)">
                <IdentNode start="(152, 44)" end="(152, 45)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(152, 46)" end="(152, 95)">
                <AtomNode start="(152, 46)" end="(152, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(152, 48)" end="(152, 95)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(152, 48)" end="(152, 57)">
                    <AtomNode start="(152, 48)" end="(152, 49)" leading="" trailing="" val="("/>
                    <NullNode start="(152, 49)" end="(152, 50)">
                      <IdentNode start="(152, 49)" end="(152, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(152, 51)" end="(152, 56)">
                      <AtomNode start="(152, 51)" end="(152, 52)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(152, 53)" end="(152, 56)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(152, 56)" end="(152, 57)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(152, 58)" end="(152, 59)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(152, 60)" end="(152, 95)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(152, 60)" end="(152, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(152, 62)" end="(152, 63)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(152, 64)" end="(152, 95)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(152, 64)" end="(152, 91)">
                        <AtomNode start="(152, 64)" end="(152, 65)" leading="" trailing="" val="("/>
                        <NullNode start="(152, 65)" end="(152, 66)">
                          <IdentNode start="(152, 65)" end="(152, 66)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(152, 67)" end="(152, 90)">
                          <AtomNode start="(152, 67)" end="(152, 68)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(152, 69)" end="(152, 90)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(152, 69)" end="(152, 70)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(152, 71)" end="(152, 72)" leading="" trailing=" " val="&amp;lt;"/>
                            <OtherNode start="(152, 73)" end="(152, 90)" kind="Lean.Parser.Term.proj">
                              <OtherNode start="(152, 73)" end="(152, 83)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(152, 73)" end="(152, 74)" leading="" trailing="" val="("/>
                                <OtherNode start="(152, 74)" end="(152, 82)" kind="«term_++_»">
                                  <IdentNode start="(152, 74)" end="(152, 76)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <AtomNode start="(152, 77)" end="(152, 79)" leading="" trailing=" " val="++"/>
                                  <IdentNode start="(152, 80)" end="(152, 82)" leading="" trailing="" raw_val="ys" val="ys"/>
                                </OtherNode>
                                <AtomNode start="(152, 82)" end="(152, 83)" leading="" trailing="" val=")"/>
                              </OtherNode>
                              <AtomNode start="(152, 83)" end="(152, 84)" leading="" trailing="" val="."/>
                              <IdentNode start="(152, 84)" end="(152, 90)" leading="" trailing="" raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(152, 90)" end="(152, 91)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(152, 92)" end="(152, 93)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(152, 94)" end="(152, 95)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(152, 95)" end="(152, 96)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(152, 97)" end="(155, 73)">
            <AtomNode start="(152, 97)" end="(152, 98)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(153, 5)" end="(155, 73)" kind="«term_=_»">
              <OtherNode start="(153, 5)" end="(153, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(153, 5)" end="(153, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(153, 5)" end="(153, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(153, 5)" end="(153, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(153, 6)" end="(153, 14)" kind="«term_++_»">
                      <IdentNode start="(153, 6)" end="(153, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(153, 9)" end="(153, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(153, 12)" end="(153, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(153, 14)" end="(153, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(153, 15)" end="(153, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(153, 16)" end="(153, 25)" leading="" trailing=" " raw_val="mapFinIdx" val="mapFinIdx" full_name="List.mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(30, 15)" def_end="(30, 24)"/>
                </OtherNode>
                <NullNode start="(153, 26)" end="(153, 27)">
                  <IdentNode start="(153, 26)" end="(153, 27)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(153, 28)" end="(153, 29)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(154, 7)" end="(155, 73)" kind="«term_++_»">
                <OtherNode start="(154, 7)" end="(154, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(154, 7)" end="(154, 19)" leading="" trailing=" " raw_val="xs.mapFinIdx" val="xs.mapFinIdx"/>
                  <NullNode start="(154, 20)" end="(154, 57)">
                    <OtherNode start="(154, 20)" end="(154, 57)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(154, 20)" end="(154, 21)" leading="" trailing="" val="("/>
                      <OtherNode start="(154, 21)" end="(154, 56)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(154, 21)" end="(154, 24)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(154, 25)" end="(154, 56)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(154, 25)" end="(154, 30)">
                            <IdentNode start="(154, 25)" end="(154, 26)" leading="" trailing=" " raw_val="i" val="i"/>
                            <IdentNode start="(154, 27)" end="(154, 28)" leading="" trailing=" " raw_val="a" val="a"/>
                            <IdentNode start="(154, 29)" end="(154, 30)" leading="" trailing=" " raw_val="h" val="h"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(154, 31)" end="(154, 33)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(154, 34)" end="(154, 56)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(154, 34)" end="(154, 35)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(154, 36)" end="(154, 56)">
                              <IdentNode start="(154, 36)" end="(154, 37)" leading="" trailing=" " raw_val="i" val="i"/>
                              <IdentNode start="(154, 38)" end="(154, 39)" leading="" trailing=" " raw_val="a" val="a"/>
                              <OtherNode start="(154, 40)" end="(154, 56)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(154, 40)" end="(154, 41)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(154, 41)" end="(154, 55)">
                                  <AtomNode start="(154, 41)" end="(154, 43)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(154, 44)" end="(154, 55)">
                                    <TacticTacticseq1IndentedNode start="(154, 44)" end="(154, 55)">
                                      <NullNode start="(154, 44)" end="(154, 55)">
                                        <OtherNode start="(154, 44)" end="(154, 48)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.19951&#10;β : Type ?u.20041&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; xs.length&#10;⊢ i &amp;lt; (xs ++ ys).length" state_after="α : Type ?u.19951&#10;β : Type ?u.20041&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; xs.length&#10;⊢ i &amp;lt; xs.length + ys.length" tactic="simp">
                                          <AtomNode start="(154, 44)" end="(154, 48)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                        <AtomNode start="(154, 48)" end="(154, 49)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(154, 50)" end="(154, 55)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.19951&#10;β : Type ?u.20041&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; xs.length&#10;⊢ i &amp;lt; xs.length + ys.length" state_after="no goals" tactic="omega">
                                          <AtomNode start="(154, 50)" end="(154, 55)" leading="" trailing="" val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(154, 55)" end="(154, 56)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(154, 56)" end="(154, 57)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(154, 58)" end="(154, 60)" leading="" trailing="&#10;        " val="++"/>
                <OtherNode start="(155, 9)" end="(155, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(155, 9)" end="(155, 21)" leading="" trailing=" " raw_val="ys.mapFinIdx" val="ys.mapFinIdx"/>
                  <NullNode start="(155, 22)" end="(155, 73)">
                    <OtherNode start="(155, 22)" end="(155, 73)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(155, 22)" end="(155, 23)" leading="" trailing="" val="("/>
                      <OtherNode start="(155, 23)" end="(155, 72)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(155, 23)" end="(155, 26)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(155, 27)" end="(155, 72)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(155, 27)" end="(155, 32)">
                            <IdentNode start="(155, 27)" end="(155, 28)" leading="" trailing=" " raw_val="i" val="i"/>
                            <IdentNode start="(155, 29)" end="(155, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                            <IdentNode start="(155, 31)" end="(155, 32)" leading="" trailing=" " raw_val="h" val="h"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(155, 33)" end="(155, 35)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(155, 36)" end="(155, 72)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(155, 36)" end="(155, 37)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(155, 38)" end="(155, 72)">
                              <OtherNode start="(155, 38)" end="(155, 53)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(155, 38)" end="(155, 39)" leading="" trailing="" val="("/>
                                <OtherNode start="(155, 39)" end="(155, 52)" kind="«term_+_»">
                                  <IdentNode start="(155, 39)" end="(155, 40)" leading="" trailing=" " raw_val="i" val="i"/>
                                  <AtomNode start="(155, 41)" end="(155, 42)" leading="" trailing=" " val="+"/>
                                  <IdentNode start="(155, 43)" end="(155, 52)" leading="" trailing="" raw_val="xs.length" val="xs.length"/>
                                </OtherNode>
                                <AtomNode start="(155, 52)" end="(155, 53)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                              <IdentNode start="(155, 54)" end="(155, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                              <OtherNode start="(155, 56)" end="(155, 72)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(155, 56)" end="(155, 57)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(155, 57)" end="(155, 71)">
                                  <AtomNode start="(155, 57)" end="(155, 59)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(155, 60)" end="(155, 71)">
                                    <TacticTacticseq1IndentedNode start="(155, 60)" end="(155, 71)">
                                      <NullNode start="(155, 60)" end="(155, 71)">
                                        <OtherNode start="(155, 60)" end="(155, 64)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.19951&#10;β : Type ?u.20041&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; ys.length&#10;⊢ i + xs.length &amp;lt; (xs ++ ys).length" state_after="α : Type ?u.19951&#10;β : Type ?u.20041&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; ys.length&#10;⊢ i + xs.length &amp;lt; xs.length + ys.length" tactic="simp">
                                          <AtomNode start="(155, 60)" end="(155, 64)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                        <AtomNode start="(155, 64)" end="(155, 65)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(155, 66)" end="(155, 71)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.19951&#10;β : Type ?u.20041&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; ys.length&#10;⊢ i + xs.length &amp;lt; xs.length + ys.length" state_after="no goals" tactic="omega">
                                          <AtomNode start="(155, 66)" end="(155, 71)" leading="" trailing="" val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(155, 71)" end="(155, 72)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(155, 72)" end="(155, 73)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(155, 74)" end="(166, 12)">
          <AtomNode start="(155, 74)" end="(155, 76)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(155, 77)" end="(166, 12)">
            <AtomNode start="(155, 77)" end="(155, 79)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(156, 3)" end="(166, 12)">
              <TacticTacticseq1IndentedNode start="(156, 3)" end="(166, 12)">
                <NullNode start="(156, 3)" end="(166, 12)">
                  <OtherNode start="(156, 3)" end="(156, 20)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;⊢ (xs ++ ys).mapFinIdx f = (xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯" state_after="case hl&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;⊢ ((xs ++ ys).mapFinIdx f).length =&#10;    ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;&#10;case h&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length)&#10;    (h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length),&#10;    ((xs ++ ys).mapFinIdx f)[i] =&#10;      ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯)[i]" tactic="apply ext_getElem">
                    <AtomNode start="(156, 3)" end="(156, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(156, 9)" end="(156, 20)" leading="" trailing="&#10;  " raw_val="ext_getElem" val="ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(157, 3)" end="(157, 9)" kind="Lean.cdot" state_before="case hl&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;⊢ ((xs ++ ys).mapFinIdx f).length =&#10;    ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;&#10;case h&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length)&#10;    (h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length),&#10;    ((xs ++ ys).mapFinIdx f)[i] =&#10;      ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯)[i]" state_after="case h&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length)&#10;    (h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length),&#10;    ((xs ++ ys).mapFinIdx f)[i] =&#10;      ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯)[i]" tactic="· simp">
                    <OtherNode start="(157, 3)" end="(157, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(157, 3)" end="(157, 4)" kind="patternIgnore">
                        <OtherNode start="(157, 3)" end="(157, 4)" kind="token.«· »">
                          <AtomNode start="(157, 3)" end="(157, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(157, 5)" end="(157, 9)">
                      <TacticTacticseq1IndentedNode start="(157, 5)" end="(157, 9)">
                        <NullNode start="(157, 5)" end="(157, 9)">
                          <OtherNode start="(157, 5)" end="(157, 9)" kind="Lean.Parser.Tactic.simp" state_before="case hl&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;⊢ ((xs ++ ys).mapFinIdx f).length =&#10;    ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length" state_after="no goals" tactic="simp">
                            <AtomNode start="(157, 5)" end="(157, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(158, 3)" end="(166, 12)" kind="Lean.cdot" state_before="case h&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length)&#10;    (h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length),&#10;    ((xs ++ ys).mapFinIdx f)[i] =&#10;      ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯)[i]" state_after="no goals" tactic="· intro i h₁ h₂&#10;  rw [getElem_append]&#10;  simp only [getElem_mapFinIdx, length_mapFinIdx]&#10;  split &amp;lt;;&amp;gt; rename_i h&#10;  · rw [getElem_append_left]&#10;  · simp only [Nat.not_lt] at h&#10;    rw [getElem_append_right h]&#10;    congr&#10;    omega">
                    <OtherNode start="(158, 3)" end="(158, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(158, 3)" end="(158, 4)" kind="patternIgnore">
                        <OtherNode start="(158, 3)" end="(158, 4)" kind="token.«· »">
                          <AtomNode start="(158, 3)" end="(158, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(158, 5)" end="(166, 12)">
                      <TacticTacticseq1IndentedNode start="(158, 5)" end="(166, 12)">
                        <NullNode start="(158, 5)" end="(166, 12)">
                          <OtherNode start="(158, 5)" end="(158, 18)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length)&#10;    (h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length),&#10;    ((xs ++ ys).mapFinIdx f)[i] =&#10;      ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯)[i]" state_after="case h&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;⊢ ((xs ++ ys).mapFinIdx f)[i] =&#10;    ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯)[i]" tactic="intro i h₁ h₂">
                            <AtomNode start="(158, 5)" end="(158, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(158, 11)" end="(158, 18)">
                              <IdentNode start="(158, 11)" end="(158, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                              <IdentNode start="(158, 13)" end="(158, 15)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                              <IdentNode start="(158, 16)" end="(158, 18)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(159, 5)" end="(159, 24)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;⊢ ((xs ++ ys).mapFinIdx f)[i] =&#10;    ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯)[i]" state_after="case h&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;⊢ ((xs ++ ys).mapFinIdx f)[i] =&#10;    if h' : i &amp;lt; (xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length then (xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯)[i]&#10;    else (ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯)[i - (xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length]" tactic="rw [getElem_append]">
                            <AtomNode start="(159, 5)" end="(159, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(159, 8)" end="(159, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(159, 8)" end="(159, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(159, 9)" end="(159, 23)">
                                <OtherNode start="(159, 9)" end="(159, 23)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(159, 9)" end="(159, 23)" leading="" trailing="" raw_val="getElem_append" val="getElem_append" full_name="List.getElem_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(159, 23)" end="(159, 24)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(160, 5)" end="(160, 52)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;⊢ ((xs ++ ys).mapFinIdx f)[i] =&#10;    if h' : i &amp;lt; (xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length then (xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯)[i]&#10;    else (ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯)[i - (xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length]" state_after="case h&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;⊢ f i (xs ++ ys)[i] ⋯ = if h : i &amp;lt; xs.length then f i xs[i] ⋯ else f (i - xs.length + xs.length) ys[i - xs.length] ⋯" tactic="simp only [getElem_mapFinIdx, length_mapFinIdx]">
                            <AtomNode start="(160, 5)" end="(160, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(160, 10)" end="(160, 14)">
                              <AtomNode start="(160, 10)" end="(160, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(160, 15)" end="(160, 52)">
                              <AtomNode start="(160, 15)" end="(160, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(160, 16)" end="(160, 51)">
                                <OtherNode start="(160, 16)" end="(160, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(160, 16)" end="(160, 33)" leading="" trailing="" raw_val="getElem_mapFinIdx" val="getElem_mapFinIdx" full_name="List.getElem_mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(132, 17)" def_end="(132, 34)"/>
                                </OtherNode>
                                <AtomNode start="(160, 33)" end="(160, 34)" leading="" trailing=" " val=","/>
                                <OtherNode start="(160, 35)" end="(160, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(160, 35)" end="(160, 51)" leading="" trailing="" raw_val="length_mapFinIdx" val="length_mapFinIdx" full_name="List.length_mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(104, 17)" def_end="(104, 33)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(160, 51)" end="(160, 52)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(161, 5)" end="(161, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;⊢ f i (xs ++ ys)[i] ⋯ = if h : i &amp;lt; xs.length then f i xs[i] ⋯ else f (i - xs.length + xs.length) ys[i - xs.length] ⋯" state_after="case h.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;h : i &amp;lt; xs.length&#10;⊢ f i (xs ++ ys)[i] ⋯ = f i xs[i] ⋯&#10;&#10;case h.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;h : ¬i &amp;lt; xs.length&#10;⊢ f i (xs ++ ys)[i] ⋯ = f (i - xs.length + xs.length) ys[i - xs.length] ⋯" tactic="split &amp;lt;;&amp;gt; rename_i h">
                            <OtherNode start="(161, 5)" end="(161, 10)" kind="Lean.Parser.Tactic.split">
                              <AtomNode start="(161, 5)" end="(161, 10)" leading="" trailing=" " val="split"/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(161, 11)" end="(161, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(161, 15)" end="(161, 25)" kind="Lean.Parser.Tactic.renameI">
                              <AtomNode start="(161, 15)" end="(161, 23)" leading="" trailing=" " val="rename_i"/>
                              <NullNode start="(161, 24)" end="(161, 25)">
                                <LeanBinderidentNode start="(161, 24)" end="(161, 25)">
                                  <IdentNode start="(161, 24)" end="(161, 25)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                </LeanBinderidentNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(162, 5)" end="(162, 31)" kind="Lean.cdot" state_before="case h.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;h : i &amp;lt; xs.length&#10;⊢ f i (xs ++ ys)[i] ⋯ = f i xs[i] ⋯&#10;&#10;case h.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;h : ¬i &amp;lt; xs.length&#10;⊢ f i (xs ++ ys)[i] ⋯ = f (i - xs.length + xs.length) ys[i - xs.length] ⋯" state_after="case h.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;h : ¬i &amp;lt; xs.length&#10;⊢ f i (xs ++ ys)[i] ⋯ = f (i - xs.length + xs.length) ys[i - xs.length] ⋯" tactic="· rw [getElem_append_left]">
                            <OtherNode start="(162, 5)" end="(162, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(162, 5)" end="(162, 6)" kind="patternIgnore">
                                <OtherNode start="(162, 5)" end="(162, 6)" kind="token.«· »">
                                  <AtomNode start="(162, 5)" end="(162, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(162, 7)" end="(162, 31)">
                              <TacticTacticseq1IndentedNode start="(162, 7)" end="(162, 31)">
                                <NullNode start="(162, 7)" end="(162, 31)">
                                  <OtherNode start="(162, 7)" end="(162, 31)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;h : i &amp;lt; xs.length&#10;⊢ f i (xs ++ ys)[i] ⋯ = f i xs[i] ⋯" state_after="no goals" tactic="rw [getElem_append_left]">
                                    <AtomNode start="(162, 7)" end="(162, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(162, 10)" end="(162, 31)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(162, 10)" end="(162, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(162, 11)" end="(162, 30)">
                                        <OtherNode start="(162, 11)" end="(162, 30)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(162, 11)" end="(162, 30)" leading="" trailing="" raw_val="getElem_append_left" val="getElem_append_left" full_name="List.getElem_append_left" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(162, 30)" end="(162, 31)" leading="" trailing="&#10;    " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(163, 5)" end="(166, 12)" kind="Lean.cdot" state_before="case h.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;h : ¬i &amp;lt; xs.length&#10;⊢ f i (xs ++ ys)[i] ⋯ = f (i - xs.length + xs.length) ys[i - xs.length] ⋯" state_after="no goals" tactic="· simp only [Nat.not_lt] at h&#10;  rw [getElem_append_right h]&#10;  congr&#10;  omega">
                            <OtherNode start="(163, 5)" end="(163, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(163, 5)" end="(163, 6)" kind="patternIgnore">
                                <OtherNode start="(163, 5)" end="(163, 6)" kind="token.«· »">
                                  <AtomNode start="(163, 5)" end="(163, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(163, 7)" end="(166, 12)">
                              <TacticTacticseq1IndentedNode start="(163, 7)" end="(166, 12)">
                                <NullNode start="(163, 7)" end="(166, 12)">
                                  <OtherNode start="(163, 7)" end="(163, 34)" kind="Lean.Parser.Tactic.simp" state_before="case h.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;h : ¬i &amp;lt; xs.length&#10;⊢ f i (xs ++ ys)[i] ⋯ = f (i - xs.length + xs.length) ys[i - xs.length] ⋯" state_after="case h.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;h✝ : ¬i &amp;lt; xs.length&#10;h : xs.length ≤ i&#10;⊢ f i (xs ++ ys)[i] ⋯ = f (i - xs.length + xs.length) ys[i - xs.length] ⋯" tactic="simp only [Nat.not_lt] at h">
                                    <AtomNode start="(163, 7)" end="(163, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(163, 12)" end="(163, 16)">
                                      <AtomNode start="(163, 12)" end="(163, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(163, 17)" end="(163, 29)">
                                      <AtomNode start="(163, 17)" end="(163, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(163, 18)" end="(163, 28)">
                                        <OtherNode start="(163, 18)" end="(163, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(163, 18)" end="(163, 28)" leading="" trailing="" raw_val="Nat.not_lt" val="Nat.not_lt" full_name="Nat.not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(163, 28)" end="(163, 29)" leading="" trailing=" " val="]"/>
                                    </NullNode>
                                    <NullNode start="(163, 30)" end="(163, 34)">
                                      <OtherNode start="(163, 30)" end="(163, 34)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(163, 30)" end="(163, 32)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(163, 33)" end="(163, 34)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(163, 33)" end="(163, 34)">
                                            <IdentNode start="(163, 33)" end="(163, 34)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(164, 7)" end="(164, 34)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;h✝ : ¬i &amp;lt; xs.length&#10;h : xs.length ≤ i&#10;⊢ f i (xs ++ ys)[i] ⋯ = f (i - xs.length + xs.length) ys[i - xs.length] ⋯" state_after="case h.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;h✝ : ¬i &amp;lt; xs.length&#10;h : xs.length ≤ i&#10;⊢ f i ys[i - xs.length] ⋯ = f (i - xs.length + xs.length) ys[i - xs.length] ⋯" tactic="rw [getElem_append_right h]">
                                    <AtomNode start="(164, 7)" end="(164, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(164, 10)" end="(164, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(164, 10)" end="(164, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(164, 11)" end="(164, 33)">
                                        <OtherNode start="(164, 11)" end="(164, 33)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <OtherNode start="(164, 11)" end="(164, 33)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(164, 11)" end="(164, 31)" leading="" trailing=" " raw_val="getElem_append_right" val="getElem_append_right" full_name="List.getElem_append_right" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                                            <NullNode start="(164, 32)" end="(164, 33)">
                                              <IdentNode start="(164, 32)" end="(164, 33)" leading="" trailing="" raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(164, 33)" end="(164, 34)" leading="" trailing="&#10;      " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(165, 7)" end="(165, 12)" kind="Lean.Parser.Tactic.congr" state_before="case h.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;h✝ : ¬i &amp;lt; xs.length&#10;h : xs.length ≤ i&#10;⊢ f i ys[i - xs.length] ⋯ = f (i - xs.length + xs.length) ys[i - xs.length] ⋯" state_after="case h.isFalse.e_i&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;h✝ : ¬i &amp;lt; xs.length&#10;h : xs.length ≤ i&#10;⊢ i = i - xs.length + xs.length" tactic="congr">
                                    <AtomNode start="(165, 7)" end="(165, 12)" leading="" trailing="&#10;      " val="congr"/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(166, 7)" end="(166, 12)" kind="Lean.Parser.Tactic.omega" state_before="case h.isFalse.e_i&#10;α : Type u_1&#10;β : Type u_2&#10;xs ys : List α&#10;f : (i : Nat) → α → i &amp;lt; (xs ++ ys).length → β&#10;i : Nat&#10;h₁ : i &amp;lt; ((xs ++ ys).mapFinIdx f).length&#10;h₂ : i &amp;lt; ((xs.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ ys.mapFinIdx fun i a h =&amp;gt; f (i + xs.length) a ⋯).length&#10;h✝ : ¬i &amp;lt; xs.length&#10;h : xs.length ≤ i&#10;⊢ i = i - xs.length + xs.length" state_after="no goals" tactic="omega">
                                    <AtomNode start="(166, 7)" end="(166, 12)" leading="" trailing="&#10;&#10;" val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(168, 1)" end="(170, 26)" name="mapFinIdx_concat" full_name="List.mapFinIdx_concat">
      <CommandDeclmodifiersNode start="(168, 1)" end="(168, 8)">
        <NullNode/>
        <NullNode start="(168, 1)" end="(168, 8)">
          <OtherNode start="(168, 1)" end="(168, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(168, 1)" end="(168, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(168, 3)" end="(168, 7)">
              <OtherNode start="(168, 3)" end="(168, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(168, 3)" end="(168, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(168, 3)" end="(168, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(168, 7)" end="(168, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(168, 9)" end="(170, 26)" name="mapFinIdx_concat" full_name="List.mapFinIdx_concat" _is_private_decl="False">
        <AtomNode start="(168, 9)" end="(168, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(168, 17)" end="(168, 33)">
          <IdentNode start="(168, 17)" end="(168, 33)" leading="" trailing=" " raw_val="mapFinIdx_concat" val="mapFinIdx_concat"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(168, 34)" end="(169, 107)">
          <NullNode start="(168, 34)" end="(168, 108)">
            <OtherNode start="(168, 34)" end="(168, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(168, 34)" end="(168, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(168, 35)" end="(168, 36)">
                <IdentNode start="(168, 35)" end="(168, 36)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(168, 37)" end="(168, 45)">
                <AtomNode start="(168, 37)" end="(168, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(168, 39)" end="(168, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(168, 39)" end="(168, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(168, 44)" end="(168, 45)">
                    <IdentNode start="(168, 44)" end="(168, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(168, 45)" end="(168, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(168, 47)" end="(168, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(168, 47)" end="(168, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(168, 48)" end="(168, 49)">
                <IdentNode start="(168, 48)" end="(168, 49)" leading="" trailing=" " raw_val="e" val="e"/>
              </NullNode>
              <NullNode start="(168, 50)" end="(168, 53)">
                <AtomNode start="(168, 50)" end="(168, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(168, 52)" end="(168, 53)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(168, 53)" end="(168, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(168, 55)" end="(168, 108)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(168, 55)" end="(168, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(168, 56)" end="(168, 57)">
                <IdentNode start="(168, 56)" end="(168, 57)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(168, 58)" end="(168, 107)">
                <AtomNode start="(168, 58)" end="(168, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(168, 60)" end="(168, 107)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(168, 60)" end="(168, 69)">
                    <AtomNode start="(168, 60)" end="(168, 61)" leading="" trailing="" val="("/>
                    <NullNode start="(168, 61)" end="(168, 62)">
                      <IdentNode start="(168, 61)" end="(168, 62)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(168, 63)" end="(168, 68)">
                      <AtomNode start="(168, 63)" end="(168, 64)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(168, 65)" end="(168, 68)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(168, 68)" end="(168, 69)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(168, 70)" end="(168, 71)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(168, 72)" end="(168, 107)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(168, 72)" end="(168, 73)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(168, 74)" end="(168, 75)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(168, 76)" end="(168, 107)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(168, 76)" end="(168, 103)">
                        <AtomNode start="(168, 76)" end="(168, 77)" leading="" trailing="" val="("/>
                        <NullNode start="(168, 77)" end="(168, 78)">
                          <IdentNode start="(168, 77)" end="(168, 78)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(168, 79)" end="(168, 102)">
                          <AtomNode start="(168, 79)" end="(168, 80)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(168, 81)" end="(168, 102)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(168, 81)" end="(168, 82)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(168, 83)" end="(168, 84)" leading="" trailing=" " val="&amp;lt;"/>
                            <OtherNode start="(168, 85)" end="(168, 102)" kind="Lean.Parser.Term.proj">
                              <OtherNode start="(168, 85)" end="(168, 95)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(168, 85)" end="(168, 86)" leading="" trailing="" val="("/>
                                <OtherNode start="(168, 86)" end="(168, 94)" kind="«term_++_»">
                                  <IdentNode start="(168, 86)" end="(168, 87)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <AtomNode start="(168, 88)" end="(168, 90)" leading="" trailing=" " val="++"/>
                                  <OtherNode start="(168, 91)" end="(168, 94)" kind="«term[_]»">
                                    <AtomNode start="(168, 91)" end="(168, 92)" leading="" trailing="" val="["/>
                                    <NullNode start="(168, 92)" end="(168, 93)">
                                      <IdentNode start="(168, 92)" end="(168, 93)" leading="" trailing="" raw_val="e" val="e"/>
                                    </NullNode>
                                    <AtomNode start="(168, 93)" end="(168, 94)" leading="" trailing="" val="]"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(168, 94)" end="(168, 95)" leading="" trailing="" val=")"/>
                              </OtherNode>
                              <AtomNode start="(168, 95)" end="(168, 96)" leading="" trailing="" val="."/>
                              <IdentNode start="(168, 96)" end="(168, 102)" leading="" trailing="" raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(168, 102)" end="(168, 103)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(168, 104)" end="(168, 105)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(168, 106)" end="(168, 107)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(168, 107)" end="(168, 108)" leading="" trailing="" val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(168, 108)" end="(169, 107)">
            <AtomNode start="(168, 108)" end="(168, 109)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(169, 5)" end="(169, 107)" kind="«term_=_»">
              <OtherNode start="(169, 5)" end="(169, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(169, 5)" end="(169, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(169, 5)" end="(169, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(169, 5)" end="(169, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(169, 6)" end="(169, 14)" kind="«term_++_»">
                      <IdentNode start="(169, 6)" end="(169, 7)" leading="" trailing=" " raw_val="l" val="l"/>
                      <AtomNode start="(169, 8)" end="(169, 10)" leading="" trailing=" " val="++"/>
                      <OtherNode start="(169, 11)" end="(169, 14)" kind="«term[_]»">
                        <AtomNode start="(169, 11)" end="(169, 12)" leading="" trailing="" val="["/>
                        <NullNode start="(169, 12)" end="(169, 13)">
                          <IdentNode start="(169, 12)" end="(169, 13)" leading="" trailing="" raw_val="e" val="e"/>
                        </NullNode>
                        <AtomNode start="(169, 13)" end="(169, 14)" leading="" trailing="" val="]"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(169, 14)" end="(169, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(169, 15)" end="(169, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(169, 16)" end="(169, 25)" leading="" trailing=" " raw_val="mapFinIdx" val="mapFinIdx" full_name="List.mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(30, 15)" def_end="(30, 24)"/>
                </OtherNode>
                <NullNode start="(169, 26)" end="(169, 27)">
                  <IdentNode start="(169, 26)" end="(169, 27)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(169, 28)" end="(169, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(169, 30)" end="(169, 107)" kind="«term_++_»">
                <OtherNode start="(169, 30)" end="(169, 79)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(169, 30)" end="(169, 41)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                  <NullNode start="(169, 42)" end="(169, 79)">
                    <OtherNode start="(169, 42)" end="(169, 79)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(169, 42)" end="(169, 43)" leading="" trailing="" val="("/>
                      <OtherNode start="(169, 43)" end="(169, 78)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(169, 43)" end="(169, 46)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(169, 47)" end="(169, 78)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(169, 47)" end="(169, 52)">
                            <IdentNode start="(169, 47)" end="(169, 48)" leading="" trailing=" " raw_val="i" val="i"/>
                            <IdentNode start="(169, 49)" end="(169, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                            <IdentNode start="(169, 51)" end="(169, 52)" leading="" trailing=" " raw_val="h" val="h"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(169, 53)" end="(169, 55)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(169, 56)" end="(169, 78)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(169, 56)" end="(169, 57)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(169, 58)" end="(169, 78)">
                              <IdentNode start="(169, 58)" end="(169, 59)" leading="" trailing=" " raw_val="i" val="i"/>
                              <IdentNode start="(169, 60)" end="(169, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                              <OtherNode start="(169, 62)" end="(169, 78)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(169, 62)" end="(169, 63)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(169, 63)" end="(169, 77)">
                                  <AtomNode start="(169, 63)" end="(169, 65)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(169, 66)" end="(169, 77)">
                                    <TacticTacticseq1IndentedNode start="(169, 66)" end="(169, 77)">
                                      <NullNode start="(169, 66)" end="(169, 77)">
                                        <OtherNode start="(169, 66)" end="(169, 70)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.23365&#10;β : Type ?u.23462&#10;l : List α&#10;e : α&#10;f : (i : Nat) → α → i &amp;lt; (l ++ [e]).length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l.length&#10;⊢ i &amp;lt; (l ++ [e]).length" state_after="α : Type ?u.23365&#10;β : Type ?u.23462&#10;l : List α&#10;e : α&#10;f : (i : Nat) → α → i &amp;lt; (l ++ [e]).length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l.length&#10;⊢ i &amp;lt; l.length + 1" tactic="simp">
                                          <AtomNode start="(169, 66)" end="(169, 70)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                        <AtomNode start="(169, 70)" end="(169, 71)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(169, 72)" end="(169, 77)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.23365&#10;β : Type ?u.23462&#10;l : List α&#10;e : α&#10;f : (i : Nat) → α → i &amp;lt; (l ++ [e]).length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l.length&#10;⊢ i &amp;lt; l.length + 1" state_after="no goals" tactic="omega">
                                          <AtomNode start="(169, 72)" end="(169, 77)" leading="" trailing="" val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(169, 77)" end="(169, 78)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(169, 78)" end="(169, 79)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(169, 80)" end="(169, 82)" leading="" trailing=" " val="++"/>
                <OtherNode start="(169, 83)" end="(169, 107)" kind="«term[_]»">
                  <AtomNode start="(169, 83)" end="(169, 84)" leading="" trailing="" val="["/>
                  <NullNode start="(169, 84)" end="(169, 106)">
                    <OtherNode start="(169, 84)" end="(169, 106)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(169, 84)" end="(169, 85)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(169, 86)" end="(169, 106)">
                        <IdentNode start="(169, 86)" end="(169, 94)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                        <IdentNode start="(169, 95)" end="(169, 96)" leading="" trailing=" " raw_val="e" val="e"/>
                        <OtherNode start="(169, 97)" end="(169, 106)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(169, 97)" end="(169, 98)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(169, 98)" end="(169, 105)">
                            <AtomNode start="(169, 98)" end="(169, 100)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(169, 101)" end="(169, 105)">
                              <TacticTacticseq1IndentedNode start="(169, 101)" end="(169, 105)">
                                <NullNode start="(169, 101)" end="(169, 105)">
                                  <OtherNode start="(169, 101)" end="(169, 105)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.23365&#10;β : Type ?u.23462&#10;l : List α&#10;e : α&#10;f : (i : Nat) → α → i &amp;lt; (l ++ [e]).length → β&#10;⊢ l.length &amp;lt; (l ++ [e]).length" state_after="no goals" tactic="simp">
                                    <AtomNode start="(169, 101)" end="(169, 105)" leading="" trailing="" val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(169, 105)" end="(169, 106)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(169, 106)" end="(169, 107)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(169, 108)" end="(170, 26)">
          <AtomNode start="(169, 108)" end="(169, 110)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(169, 111)" end="(170, 26)">
            <AtomNode start="(169, 111)" end="(169, 113)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(170, 3)" end="(170, 26)">
              <TacticTacticseq1IndentedNode start="(170, 3)" end="(170, 26)">
                <NullNode start="(170, 3)" end="(170, 26)">
                  <OtherNode start="(170, 3)" end="(170, 26)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;e : α&#10;f : (i : Nat) → α → i &amp;lt; (l ++ [e]).length → β&#10;⊢ (l ++ [e]).mapFinIdx f = (l.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ [f l.length e ⋯]" state_after="no goals" tactic="simp [mapFinIdx_append]">
                    <AtomNode start="(170, 3)" end="(170, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(170, 8)" end="(170, 26)">
                      <AtomNode start="(170, 8)" end="(170, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(170, 9)" end="(170, 25)">
                        <OtherNode start="(170, 9)" end="(170, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(170, 9)" end="(170, 25)" leading="" trailing="" raw_val="mapFinIdx_append" val="mapFinIdx_append" full_name="List.mapFinIdx_append" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(152, 9)" def_end="(152, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(170, 25)" end="(170, 26)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(172, 1)" end="(174, 7)" name="mapFinIdx_singleton" full_name="List.mapFinIdx_singleton">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(172, 1)" end="(174, 7)" name="mapFinIdx_singleton" full_name="List.mapFinIdx_singleton" _is_private_decl="False">
        <AtomNode start="(172, 1)" end="(172, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(172, 9)" end="(172, 28)">
          <IdentNode start="(172, 9)" end="(172, 28)" leading="" trailing=" " raw_val="mapFinIdx_singleton" val="mapFinIdx_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(172, 29)" end="(173, 40)">
          <NullNode start="(172, 29)" end="(172, 74)">
            <OtherNode start="(172, 29)" end="(172, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(172, 29)" end="(172, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(172, 30)" end="(172, 31)">
                <IdentNode start="(172, 30)" end="(172, 31)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(172, 32)" end="(172, 35)">
                <AtomNode start="(172, 32)" end="(172, 33)" leading="" trailing=" " val=":"/>
                <IdentNode start="(172, 34)" end="(172, 35)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(172, 35)" end="(172, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(172, 37)" end="(172, 74)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(172, 37)" end="(172, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(172, 38)" end="(172, 39)">
                <IdentNode start="(172, 38)" end="(172, 39)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(172, 40)" end="(172, 73)">
                <AtomNode start="(172, 40)" end="(172, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(172, 42)" end="(172, 73)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(172, 42)" end="(172, 51)">
                    <AtomNode start="(172, 42)" end="(172, 43)" leading="" trailing="" val="("/>
                    <NullNode start="(172, 43)" end="(172, 44)">
                      <IdentNode start="(172, 43)" end="(172, 44)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(172, 45)" end="(172, 50)">
                      <AtomNode start="(172, 45)" end="(172, 46)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(172, 47)" end="(172, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(172, 50)" end="(172, 51)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(172, 52)" end="(172, 53)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(172, 54)" end="(172, 73)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(172, 54)" end="(172, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(172, 56)" end="(172, 57)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(172, 58)" end="(172, 73)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(172, 58)" end="(172, 69)">
                        <AtomNode start="(172, 58)" end="(172, 59)" leading="" trailing="" val="("/>
                        <NullNode start="(172, 59)" end="(172, 60)">
                          <IdentNode start="(172, 59)" end="(172, 60)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(172, 61)" end="(172, 68)">
                          <AtomNode start="(172, 61)" end="(172, 62)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(172, 63)" end="(172, 68)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(172, 63)" end="(172, 64)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(172, 65)" end="(172, 66)" leading="" trailing=" " val="&amp;lt;"/>
                            <OtherNode start="(172, 67)" end="(172, 68)" kind="num">
                              <AtomNode start="(172, 67)" end="(172, 68)" leading="" trailing="" val="1"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(172, 68)" end="(172, 69)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(172, 70)" end="(172, 71)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(172, 72)" end="(172, 73)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(172, 73)" end="(172, 74)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(172, 75)" end="(173, 40)">
            <AtomNode start="(172, 75)" end="(172, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(173, 5)" end="(173, 40)" kind="«term_=_»">
              <OtherNode start="(173, 5)" end="(173, 20)" kind="Lean.Parser.Term.app">
                <OtherNode start="(173, 5)" end="(173, 18)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(173, 5)" end="(173, 8)" kind="«term[_]»">
                    <AtomNode start="(173, 5)" end="(173, 6)" leading="" trailing="" val="["/>
                    <NullNode start="(173, 6)" end="(173, 7)">
                      <IdentNode start="(173, 6)" end="(173, 7)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(173, 7)" end="(173, 8)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(173, 8)" end="(173, 9)" leading="" trailing="" val="."/>
                  <IdentNode start="(173, 9)" end="(173, 18)" leading="" trailing=" " raw_val="mapFinIdx" val="mapFinIdx" full_name="List.mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(30, 15)" def_end="(30, 24)"/>
                </OtherNode>
                <NullNode start="(173, 19)" end="(173, 20)">
                  <IdentNode start="(173, 19)" end="(173, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(173, 21)" end="(173, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(173, 23)" end="(173, 40)" kind="«term[_]»">
                <AtomNode start="(173, 23)" end="(173, 24)" leading="" trailing="" val="["/>
                <NullNode start="(173, 24)" end="(173, 39)">
                  <OtherNode start="(173, 24)" end="(173, 39)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(173, 24)" end="(173, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(173, 26)" end="(173, 39)">
                      <OtherNode start="(173, 26)" end="(173, 27)" kind="num">
                        <AtomNode start="(173, 26)" end="(173, 27)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                      <IdentNode start="(173, 28)" end="(173, 29)" leading="" trailing=" " raw_val="a" val="a"/>
                      <OtherNode start="(173, 30)" end="(173, 39)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(173, 30)" end="(173, 31)" leading="" trailing="" val="("/>
                        <TermBytacticNode start="(173, 31)" end="(173, 38)">
                          <AtomNode start="(173, 31)" end="(173, 33)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(173, 34)" end="(173, 38)">
                            <TacticTacticseq1IndentedNode start="(173, 34)" end="(173, 38)">
                              <NullNode start="(173, 34)" end="(173, 38)">
                                <OtherNode start="(173, 34)" end="(173, 38)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.24477&#10;β : Type ?u.24482&#10;a : α&#10;f : (i : Nat) → α → i &amp;lt; 1 → β&#10;⊢ 0 &amp;lt; 1" state_after="no goals" tactic="simp">
                                  <AtomNode start="(173, 34)" end="(173, 38)" leading="" trailing="" val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                        <AtomNode start="(173, 38)" end="(173, 39)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(173, 39)" end="(173, 40)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(173, 41)" end="(174, 7)">
          <AtomNode start="(173, 41)" end="(173, 43)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(173, 44)" end="(174, 7)">
            <AtomNode start="(173, 44)" end="(173, 46)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(174, 3)" end="(174, 7)">
              <TacticTacticseq1IndentedNode start="(174, 3)" end="(174, 7)">
                <NullNode start="(174, 3)" end="(174, 7)">
                  <OtherNode start="(174, 3)" end="(174, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;f : (i : Nat) → α → i &amp;lt; 1 → β&#10;⊢ [a].mapFinIdx f = [f 0 a ⋯]" state_after="no goals" tactic="simp">
                    <AtomNode start="(174, 3)" end="(174, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(176, 1)" end="(180, 29)" name="mapFinIdx_eq_zipIdx_map" full_name="List.mapFinIdx_eq_zipIdx_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(176, 1)" end="(180, 29)" name="mapFinIdx_eq_zipIdx_map" full_name="List.mapFinIdx_eq_zipIdx_map" _is_private_decl="False">
        <AtomNode start="(176, 1)" end="(176, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(176, 9)" end="(176, 32)">
          <IdentNode start="(176, 9)" end="(176, 32)" leading="" trailing=" " raw_val="mapFinIdx_eq_zipIdx_map" val="mapFinIdx_eq_zipIdx_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(176, 33)" end="(179, 89)">
          <NullNode start="(176, 33)" end="(176, 90)">
            <OtherNode start="(176, 33)" end="(176, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(176, 33)" end="(176, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(176, 34)" end="(176, 35)">
                <IdentNode start="(176, 34)" end="(176, 35)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(176, 36)" end="(176, 44)">
                <AtomNode start="(176, 36)" end="(176, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(176, 38)" end="(176, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(176, 38)" end="(176, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(176, 43)" end="(176, 44)">
                    <IdentNode start="(176, 43)" end="(176, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(176, 44)" end="(176, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(176, 46)" end="(176, 90)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(176, 46)" end="(176, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(176, 47)" end="(176, 48)">
                <IdentNode start="(176, 47)" end="(176, 48)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(176, 49)" end="(176, 89)">
                <AtomNode start="(176, 49)" end="(176, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(176, 51)" end="(176, 89)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(176, 51)" end="(176, 60)">
                    <AtomNode start="(176, 51)" end="(176, 52)" leading="" trailing="" val="("/>
                    <NullNode start="(176, 52)" end="(176, 53)">
                      <IdentNode start="(176, 52)" end="(176, 53)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(176, 54)" end="(176, 59)">
                      <AtomNode start="(176, 54)" end="(176, 55)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(176, 56)" end="(176, 59)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(176, 59)" end="(176, 60)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(176, 61)" end="(176, 62)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(176, 63)" end="(176, 89)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(176, 63)" end="(176, 64)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(176, 65)" end="(176, 66)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(176, 67)" end="(176, 89)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(176, 67)" end="(176, 85)">
                        <AtomNode start="(176, 67)" end="(176, 68)" leading="" trailing="" val="("/>
                        <NullNode start="(176, 68)" end="(176, 69)">
                          <IdentNode start="(176, 68)" end="(176, 69)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(176, 70)" end="(176, 84)">
                          <AtomNode start="(176, 70)" end="(176, 71)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(176, 72)" end="(176, 84)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(176, 72)" end="(176, 73)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(176, 74)" end="(176, 75)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(176, 76)" end="(176, 84)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(176, 84)" end="(176, 85)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(176, 86)" end="(176, 87)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(176, 88)" end="(176, 89)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(176, 89)" end="(176, 90)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(176, 91)" end="(179, 89)">
            <AtomNode start="(176, 91)" end="(176, 92)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(177, 5)" end="(179, 89)" kind="«term_=_»">
              <OtherNode start="(177, 5)" end="(177, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(177, 5)" end="(177, 16)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                <NullNode start="(177, 17)" end="(177, 18)">
                  <IdentNode start="(177, 17)" end="(177, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(177, 19)" end="(177, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(177, 21)" end="(179, 89)" kind="Lean.Parser.Term.app">
                <IdentNode start="(177, 21)" end="(177, 40)" leading="" trailing="&#10;      " raw_val="l.zipIdx.attach.map" val="l.zipIdx.attach.map"/>
                <NullNode start="(178, 7)" end="(179, 89)">
                  <OtherNode start="(178, 7)" end="(179, 89)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(178, 7)" end="(178, 10)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(178, 11)" end="(179, 89)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(178, 11)" end="(178, 22)">
                        <OtherNode start="(178, 11)" end="(178, 22)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(178, 11)" end="(178, 12)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(178, 12)" end="(178, 21)">
                            <OtherNode start="(178, 12)" end="(178, 18)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(178, 12)" end="(178, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(178, 13)" end="(178, 17)">
                                <IdentNode start="(178, 13)" end="(178, 14)" leading="" trailing="" raw_val="x" val="x"/>
                                <AtomNode start="(178, 14)" end="(178, 15)" leading="" trailing=" " val=","/>
                                <IdentNode start="(178, 16)" end="(178, 17)" leading="" trailing="" raw_val="i" val="i"/>
                              </NullNode>
                              <AtomNode start="(178, 17)" end="(178, 18)" leading="" trailing="" val="⟩"/>
                            </OtherNode>
                            <AtomNode start="(178, 18)" end="(178, 19)" leading="" trailing=" " val=","/>
                            <IdentNode start="(178, 20)" end="(178, 21)" leading="" trailing="" raw_val="m" val="m"/>
                          </NullNode>
                          <AtomNode start="(178, 21)" end="(178, 22)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(178, 23)" end="(178, 25)" leading="" trailing="&#10;        " val="=&amp;gt;"/>
                      <OtherNode start="(179, 9)" end="(179, 89)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(179, 9)" end="(179, 10)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(179, 11)" end="(179, 89)">
                          <IdentNode start="(179, 11)" end="(179, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                          <IdentNode start="(179, 13)" end="(179, 14)" leading="" trailing=" " raw_val="x" val="x"/>
                          <OtherNode start="(179, 15)" end="(179, 89)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(179, 15)" end="(179, 16)" leading="" trailing="" val="("/>
                            <TermBytacticNode start="(179, 16)" end="(179, 88)">
                              <AtomNode start="(179, 16)" end="(179, 18)" leading="" trailing=" " val="by"/>
                              <TacticTacticseqNode start="(179, 19)" end="(179, 88)">
                                <TacticTacticseq1IndentedNode start="(179, 19)" end="(179, 88)">
                                  <NullNode start="(179, 19)" end="(179, 88)">
                                    <OtherNode start="(179, 19)" end="(179, 77)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type ?u.24823&#10;β : Type ?u.24845&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;x✝ : { x // x ∈ l.zipIdx }&#10;x : α&#10;i : Nat&#10;m : (x, i) ∈ l.zipIdx&#10;⊢ i &amp;lt; l.length" state_after="α : Type ?u.24823&#10;β : Type ?u.24845&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;x✝ : { x // x ∈ l.zipIdx }&#10;x : α&#10;i : Nat&#10;m : ∃ h, l[i] = x&#10;⊢ i &amp;lt; l.length" tactic="rw [mk_mem_zipIdx_iff_getElem?, getElem?_eq_some_iff] at m">
                                      <AtomNode start="(179, 19)" end="(179, 21)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(179, 22)" end="(179, 72)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(179, 22)" end="(179, 23)" leading="" trailing="" val="["/>
                                        <NullNode start="(179, 23)" end="(179, 71)">
                                          <OtherNode start="(179, 23)" end="(179, 49)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(179, 23)" end="(179, 49)" leading="" trailing="" raw_val="mk_mem_zipIdx_iff_getElem?" val="mk_mem_zipIdx_iff_getElem?" full_name="List.mk_mem_zipIdx_iff_getElem?" mod_name="Init.Data.List.Nat.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Range.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(179, 49)" end="(179, 50)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(179, 51)" end="(179, 71)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(179, 51)" end="(179, 71)" leading="" trailing="" raw_val="getElem?_eq_some_iff" val="getElem?_eq_some_iff" full_name="List.getElem?_eq_some_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(179, 71)" end="(179, 72)" leading="" trailing=" " val="]"/>
                                      </OtherNode>
                                      <NullNode start="(179, 73)" end="(179, 77)">
                                        <OtherNode start="(179, 73)" end="(179, 77)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(179, 73)" end="(179, 75)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(179, 76)" end="(179, 77)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(179, 76)" end="(179, 77)">
                                              <IdentNode start="(179, 76)" end="(179, 77)" leading="" trailing="" raw_val="m" val="m"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(179, 77)" end="(179, 78)" leading="" trailing=" " val=";"/>
                                    <OtherNode start="(179, 79)" end="(179, 88)" kind="Lean.Parser.Tactic.exact" state_before="α : Type ?u.24823&#10;β : Type ?u.24845&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;x✝ : { x // x ∈ l.zipIdx }&#10;x : α&#10;i : Nat&#10;m : ∃ h, l[i] = x&#10;⊢ i &amp;lt; l.length" state_after="no goals" tactic="exact m.1">
                                      <AtomNode start="(179, 79)" end="(179, 84)" leading="" trailing=" " val="exact"/>
                                      <OtherNode start="(179, 85)" end="(179, 88)" kind="Lean.Parser.Term.proj">
                                        <IdentNode start="(179, 85)" end="(179, 86)" leading="" trailing="" raw_val="m" val="m"/>
                                        <AtomNode start="(179, 86)" end="(179, 87)" leading="" trailing="" val="."/>
                                        <OtherNode start="(179, 87)" end="(179, 88)" kind="fieldIdx">
                                          <AtomNode start="(179, 87)" end="(179, 88)" leading="" trailing="" val="1"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </TermBytacticNode>
                            <AtomNode start="(179, 88)" end="(179, 89)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(179, 90)" end="(180, 29)">
          <AtomNode start="(179, 90)" end="(179, 92)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(179, 93)" end="(180, 29)">
            <AtomNode start="(179, 93)" end="(179, 95)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(180, 3)" end="(180, 29)">
              <TacticTacticseq1IndentedNode start="(180, 3)" end="(180, 29)">
                <NullNode start="(180, 3)" end="(180, 29)">
                  <OtherNode start="(180, 3)" end="(180, 29)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ l.mapFinIdx f =&#10;    map&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | ⟨(x, i), m⟩ =&amp;gt; f i x ⋯)&#10;      l.zipIdx.attach" state_after="no goals" tactic="apply ext_getElem &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(180, 3)" end="(180, 20)" kind="Lean.Parser.Tactic.apply">
                      <AtomNode start="(180, 3)" end="(180, 8)" leading="" trailing=" " val="apply"/>
                      <IdentNode start="(180, 9)" end="(180, 20)" leading="" trailing=" " raw_val="ext_getElem" val="ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                    </OtherNode>
                    <AtomNode start="(180, 21)" end="(180, 24)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(180, 25)" end="(180, 29)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(180, 25)" end="(180, 29)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(182, 1)" end="(183, 65)" name="mapFinIdx_eq_zipWithIndex_map" full_name="List.mapFinIdx_eq_zipWithIndex_map">
      <CommandDeclmodifiersNode start="(182, 1)" end="(182, 62)">
        <NullNode/>
        <NullNode start="(182, 1)" end="(182, 62)">
          <OtherNode start="(182, 1)" end="(182, 62)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(182, 1)" end="(182, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(182, 3)" end="(182, 61)">
              <OtherNode start="(182, 3)" end="(182, 61)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(182, 3)" end="(182, 61)" kind="Lean.deprecated">
                  <AtomNode start="(182, 3)" end="(182, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(182, 14)" end="(182, 37)">
                    <IdentNode start="(182, 14)" end="(182, 37)" leading="" trailing=" " raw_val="mapFinIdx_eq_zipIdx_map" val="mapFinIdx_eq_zipIdx_map" full_name="List.mapFinIdx_eq_zipIdx_map" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(176, 9)" def_end="(176, 32)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(182, 38)" end="(182, 61)">
                    <AtomNode start="(182, 38)" end="(182, 39)" leading="" trailing="" val="("/>
                    <AtomNode start="(182, 39)" end="(182, 44)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(182, 45)" end="(182, 47)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(182, 48)" end="(182, 60)" kind="str">
                      <AtomNode start="(182, 48)" end="(182, 60)" leading="" trailing="" val="&amp;quot;2025-01-21&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(182, 60)" end="(182, 61)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(182, 61)" end="(182, 62)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(183, 1)" end="(183, 65)" name="mapFinIdx_eq_zipWithIndex_map">
        <AtomNode start="(183, 1)" end="(183, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(183, 8)" end="(183, 37)">
          <IdentNode start="(183, 8)" end="(183, 37)" leading="" trailing=" " raw_val="mapFinIdx_eq_zipWithIndex_map" val="mapFinIdx_eq_zipWithIndex_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(183, 38)" end="(183, 65)">
          <AtomNode start="(183, 38)" end="(183, 40)" leading="" trailing=" " val=":="/>
          <OtherNode start="(183, 41)" end="(183, 65)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(183, 41)" end="(183, 42)" leading="" trailing="" val="@"/>
            <IdentNode start="(183, 42)" end="(183, 65)" leading="" trailing="&#10;&#10;" raw_val="mapFinIdx_eq_zipIdx_map" val="mapFinIdx_eq_zipIdx_map" full_name="List.mapFinIdx_eq_zipIdx_map" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(176, 9)" def_end="(176, 32)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(185, 1)" end="(188, 85)" name="mapFinIdx_eq_nil_iff" full_name="List.mapFinIdx_eq_nil_iff">
      <CommandDeclmodifiersNode start="(185, 1)" end="(185, 8)">
        <NullNode/>
        <NullNode start="(185, 1)" end="(185, 8)">
          <OtherNode start="(185, 1)" end="(185, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(185, 1)" end="(185, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(185, 3)" end="(185, 7)">
              <OtherNode start="(185, 3)" end="(185, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(185, 3)" end="(185, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(185, 3)" end="(185, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(185, 7)" end="(185, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(186, 1)" end="(188, 85)" name="mapFinIdx_eq_nil_iff" full_name="List.mapFinIdx_eq_nil_iff" _is_private_decl="False">
        <AtomNode start="(186, 1)" end="(186, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(186, 9)" end="(186, 29)">
          <IdentNode start="(186, 9)" end="(186, 29)" leading="" trailing=" " raw_val="mapFinIdx_eq_nil_iff" val="mapFinIdx_eq_nil_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(186, 30)" end="(187, 32)">
          <NullNode start="(186, 30)" end="(186, 87)">
            <OtherNode start="(186, 30)" end="(186, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(186, 30)" end="(186, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(186, 31)" end="(186, 32)">
                <IdentNode start="(186, 31)" end="(186, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(186, 33)" end="(186, 41)">
                <AtomNode start="(186, 33)" end="(186, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(186, 35)" end="(186, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(186, 35)" end="(186, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(186, 40)" end="(186, 41)">
                    <IdentNode start="(186, 40)" end="(186, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(186, 41)" end="(186, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(186, 43)" end="(186, 87)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(186, 43)" end="(186, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(186, 44)" end="(186, 45)">
                <IdentNode start="(186, 44)" end="(186, 45)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(186, 46)" end="(186, 86)">
                <AtomNode start="(186, 46)" end="(186, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(186, 48)" end="(186, 86)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(186, 48)" end="(186, 57)">
                    <AtomNode start="(186, 48)" end="(186, 49)" leading="" trailing="" val="("/>
                    <NullNode start="(186, 49)" end="(186, 50)">
                      <IdentNode start="(186, 49)" end="(186, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(186, 51)" end="(186, 56)">
                      <AtomNode start="(186, 51)" end="(186, 52)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(186, 53)" end="(186, 56)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(186, 56)" end="(186, 57)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(186, 58)" end="(186, 59)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(186, 60)" end="(186, 86)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(186, 60)" end="(186, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(186, 62)" end="(186, 63)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(186, 64)" end="(186, 86)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(186, 64)" end="(186, 82)">
                        <AtomNode start="(186, 64)" end="(186, 65)" leading="" trailing="" val="("/>
                        <NullNode start="(186, 65)" end="(186, 66)">
                          <IdentNode start="(186, 65)" end="(186, 66)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(186, 67)" end="(186, 81)">
                          <AtomNode start="(186, 67)" end="(186, 68)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(186, 69)" end="(186, 81)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(186, 69)" end="(186, 70)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(186, 71)" end="(186, 72)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(186, 73)" end="(186, 81)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(186, 81)" end="(186, 82)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(186, 83)" end="(186, 84)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(186, 85)" end="(186, 86)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(186, 86)" end="(186, 87)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(186, 88)" end="(187, 32)">
            <AtomNode start="(186, 88)" end="(186, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(187, 5)" end="(187, 32)" kind="«term_↔_»">
              <OtherNode start="(187, 5)" end="(187, 23)" kind="«term_=_»">
                <OtherNode start="(187, 5)" end="(187, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(187, 5)" end="(187, 16)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                  <NullNode start="(187, 17)" end="(187, 18)">
                    <IdentNode start="(187, 17)" end="(187, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(187, 19)" end="(187, 20)" leading="" trailing=" " val="="/>
                <OtherNode start="(187, 21)" end="(187, 23)" kind="«term[_]»">
                  <AtomNode start="(187, 21)" end="(187, 22)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(187, 22)" end="(187, 23)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(187, 24)" end="(187, 25)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(187, 26)" end="(187, 32)" kind="«term_=_»">
                <IdentNode start="(187, 26)" end="(187, 27)" leading="" trailing=" " raw_val="l" val="l"/>
                <AtomNode start="(187, 28)" end="(187, 29)" leading="" trailing=" " val="="/>
                <OtherNode start="(187, 30)" end="(187, 32)" kind="«term[_]»">
                  <AtomNode start="(187, 30)" end="(187, 31)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(187, 31)" end="(187, 32)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(187, 33)" end="(188, 85)">
          <AtomNode start="(187, 33)" end="(187, 35)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(187, 36)" end="(188, 85)">
            <AtomNode start="(187, 36)" end="(187, 38)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(188, 3)" end="(188, 85)">
              <TacticTacticseq1IndentedNode start="(188, 3)" end="(188, 85)">
                <NullNode start="(188, 3)" end="(188, 85)">
                  <OtherNode start="(188, 3)" end="(188, 85)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ l.mapFinIdx f = [] ↔ l = []" state_after="no goals" tactic="rw [mapFinIdx_eq_zipIdx_map, map_eq_nil_iff, attach_eq_nil_iff, zipIdx_eq_nil_iff]">
                    <AtomNode start="(188, 3)" end="(188, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(188, 6)" end="(188, 85)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(188, 6)" end="(188, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(188, 7)" end="(188, 84)">
                        <OtherNode start="(188, 7)" end="(188, 30)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(188, 7)" end="(188, 30)" leading="" trailing="" raw_val="mapFinIdx_eq_zipIdx_map" val="mapFinIdx_eq_zipIdx_map" full_name="List.mapFinIdx_eq_zipIdx_map" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(176, 9)" def_end="(176, 32)"/>
                        </OtherNode>
                        <AtomNode start="(188, 30)" end="(188, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(188, 32)" end="(188, 46)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(188, 32)" end="(188, 46)" leading="" trailing="" raw_val="map_eq_nil_iff" val="map_eq_nil_iff" full_name="List.map_eq_nil_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(188, 46)" end="(188, 47)" leading="" trailing=" " val=","/>
                        <OtherNode start="(188, 48)" end="(188, 65)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(188, 48)" end="(188, 65)" leading="" trailing="" raw_val="attach_eq_nil_iff" val="attach_eq_nil_iff" full_name="List.attach_eq_nil_iff" mod_name="Init.Data.List.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Attach.lean"/>
                        </OtherNode>
                        <AtomNode start="(188, 65)" end="(188, 66)" leading="" trailing=" " val=","/>
                        <OtherNode start="(188, 67)" end="(188, 84)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(188, 67)" end="(188, 84)" leading="" trailing="" raw_val="zipIdx_eq_nil_iff" val="zipIdx_eq_nil_iff" full_name="List.zipIdx_eq_nil_iff" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(188, 84)" end="(188, 85)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(190, 1)" end="(192, 7)" name="mapFinIdx_ne_nil_iff" full_name="List.mapFinIdx_ne_nil_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(190, 1)" end="(192, 7)" name="mapFinIdx_ne_nil_iff" full_name="List.mapFinIdx_ne_nil_iff" _is_private_decl="False">
        <AtomNode start="(190, 1)" end="(190, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(190, 9)" end="(190, 29)">
          <IdentNode start="(190, 9)" end="(190, 29)" leading="" trailing=" " raw_val="mapFinIdx_ne_nil_iff" val="mapFinIdx_ne_nil_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(190, 30)" end="(191, 32)">
          <NullNode start="(190, 30)" end="(190, 87)">
            <OtherNode start="(190, 30)" end="(190, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(190, 30)" end="(190, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(190, 31)" end="(190, 32)">
                <IdentNode start="(190, 31)" end="(190, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(190, 33)" end="(190, 41)">
                <AtomNode start="(190, 33)" end="(190, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(190, 35)" end="(190, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(190, 35)" end="(190, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(190, 40)" end="(190, 41)">
                    <IdentNode start="(190, 40)" end="(190, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(190, 41)" end="(190, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(190, 43)" end="(190, 87)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(190, 43)" end="(190, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(190, 44)" end="(190, 45)">
                <IdentNode start="(190, 44)" end="(190, 45)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(190, 46)" end="(190, 86)">
                <AtomNode start="(190, 46)" end="(190, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(190, 48)" end="(190, 86)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(190, 48)" end="(190, 57)">
                    <AtomNode start="(190, 48)" end="(190, 49)" leading="" trailing="" val="("/>
                    <NullNode start="(190, 49)" end="(190, 50)">
                      <IdentNode start="(190, 49)" end="(190, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(190, 51)" end="(190, 56)">
                      <AtomNode start="(190, 51)" end="(190, 52)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(190, 53)" end="(190, 56)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(190, 56)" end="(190, 57)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(190, 58)" end="(190, 59)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(190, 60)" end="(190, 86)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(190, 60)" end="(190, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(190, 62)" end="(190, 63)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(190, 64)" end="(190, 86)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(190, 64)" end="(190, 82)">
                        <AtomNode start="(190, 64)" end="(190, 65)" leading="" trailing="" val="("/>
                        <NullNode start="(190, 65)" end="(190, 66)">
                          <IdentNode start="(190, 65)" end="(190, 66)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(190, 67)" end="(190, 81)">
                          <AtomNode start="(190, 67)" end="(190, 68)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(190, 69)" end="(190, 81)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(190, 69)" end="(190, 70)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(190, 71)" end="(190, 72)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(190, 73)" end="(190, 81)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(190, 81)" end="(190, 82)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(190, 83)" end="(190, 84)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(190, 85)" end="(190, 86)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(190, 86)" end="(190, 87)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(190, 88)" end="(191, 32)">
            <AtomNode start="(190, 88)" end="(190, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(191, 5)" end="(191, 32)" kind="«term_↔_»">
              <OtherNode start="(191, 5)" end="(191, 23)" kind="«term_≠_»">
                <OtherNode start="(191, 5)" end="(191, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(191, 5)" end="(191, 16)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                  <NullNode start="(191, 17)" end="(191, 18)">
                    <IdentNode start="(191, 17)" end="(191, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(191, 19)" end="(191, 20)" leading="" trailing=" " val="≠"/>
                <OtherNode start="(191, 21)" end="(191, 23)" kind="«term[_]»">
                  <AtomNode start="(191, 21)" end="(191, 22)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(191, 22)" end="(191, 23)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(191, 24)" end="(191, 25)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(191, 26)" end="(191, 32)" kind="«term_≠_»">
                <IdentNode start="(191, 26)" end="(191, 27)" leading="" trailing=" " raw_val="l" val="l"/>
                <AtomNode start="(191, 28)" end="(191, 29)" leading="" trailing=" " val="≠"/>
                <OtherNode start="(191, 30)" end="(191, 32)" kind="«term[_]»">
                  <AtomNode start="(191, 30)" end="(191, 31)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(191, 31)" end="(191, 32)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(191, 33)" end="(192, 7)">
          <AtomNode start="(191, 33)" end="(191, 35)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(191, 36)" end="(192, 7)">
            <AtomNode start="(191, 36)" end="(191, 38)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(192, 3)" end="(192, 7)">
              <TacticTacticseq1IndentedNode start="(192, 3)" end="(192, 7)">
                <NullNode start="(192, 3)" end="(192, 7)">
                  <OtherNode start="(192, 3)" end="(192, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ l.mapFinIdx f ≠ [] ↔ l ≠ []" state_after="no goals" tactic="simp">
                    <AtomNode start="(192, 3)" end="(192, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(194, 1)" end="(202, 21)" name="exists_of_mem_mapFinIdx" full_name="List.exists_of_mem_mapFinIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(194, 1)" end="(202, 21)" name="exists_of_mem_mapFinIdx" full_name="List.exists_of_mem_mapFinIdx" _is_private_decl="False">
        <AtomNode start="(194, 1)" end="(194, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(194, 9)" end="(194, 32)">
          <IdentNode start="(194, 9)" end="(194, 32)" leading="" trailing=" " raw_val="exists_of_mem_mapFinIdx" val="exists_of_mem_mapFinIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(194, 33)" end="(195, 77)">
          <NullNode start="(194, 33)" end="(195, 28)">
            <OtherNode start="(194, 33)" end="(194, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(194, 33)" end="(194, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(194, 34)" end="(194, 35)">
                <IdentNode start="(194, 34)" end="(194, 35)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(194, 36)" end="(194, 39)">
                <AtomNode start="(194, 36)" end="(194, 37)" leading="" trailing=" " val=":"/>
                <IdentNode start="(194, 38)" end="(194, 39)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(194, 39)" end="(194, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(194, 41)" end="(194, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(194, 41)" end="(194, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(194, 42)" end="(194, 43)">
                <IdentNode start="(194, 42)" end="(194, 43)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(194, 44)" end="(194, 52)">
                <AtomNode start="(194, 44)" end="(194, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(194, 46)" end="(194, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(194, 46)" end="(194, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(194, 51)" end="(194, 52)">
                    <IdentNode start="(194, 51)" end="(194, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(194, 52)" end="(194, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(194, 54)" end="(194, 98)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(194, 54)" end="(194, 55)" leading="" trailing="" val="{"/>
              <NullNode start="(194, 55)" end="(194, 56)">
                <IdentNode start="(194, 55)" end="(194, 56)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(194, 57)" end="(194, 97)">
                <AtomNode start="(194, 57)" end="(194, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(194, 59)" end="(194, 97)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(194, 59)" end="(194, 68)">
                    <AtomNode start="(194, 59)" end="(194, 60)" leading="" trailing="" val="("/>
                    <NullNode start="(194, 60)" end="(194, 61)">
                      <IdentNode start="(194, 60)" end="(194, 61)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(194, 62)" end="(194, 67)">
                      <AtomNode start="(194, 62)" end="(194, 63)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(194, 64)" end="(194, 67)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(194, 67)" end="(194, 68)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(194, 69)" end="(194, 70)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(194, 71)" end="(194, 97)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(194, 71)" end="(194, 72)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(194, 73)" end="(194, 74)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(194, 75)" end="(194, 97)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(194, 75)" end="(194, 93)">
                        <AtomNode start="(194, 75)" end="(194, 76)" leading="" trailing="" val="("/>
                        <NullNode start="(194, 76)" end="(194, 77)">
                          <IdentNode start="(194, 76)" end="(194, 77)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(194, 78)" end="(194, 92)">
                          <AtomNode start="(194, 78)" end="(194, 79)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(194, 80)" end="(194, 92)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(194, 80)" end="(194, 81)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(194, 82)" end="(194, 83)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(194, 84)" end="(194, 92)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(194, 92)" end="(194, 93)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(194, 94)" end="(194, 95)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(194, 96)" end="(194, 97)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(194, 97)" end="(194, 98)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(195, 5)" end="(195, 28)">
              <AtomNode start="(195, 5)" end="(195, 6)" leading="" trailing="" val="("/>
              <NullNode start="(195, 6)" end="(195, 7)">
                <IdentNode start="(195, 6)" end="(195, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(195, 8)" end="(195, 27)">
                <AtomNode start="(195, 8)" end="(195, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(195, 10)" end="(195, 27)" kind="«term_∈_»">
                  <IdentNode start="(195, 10)" end="(195, 11)" leading="" trailing=" " raw_val="b" val="b"/>
                  <AtomNode start="(195, 12)" end="(195, 13)" leading="" trailing=" " val="∈"/>
                  <OtherNode start="(195, 14)" end="(195, 27)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(195, 14)" end="(195, 25)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                    <NullNode start="(195, 26)" end="(195, 27)">
                      <IdentNode start="(195, 26)" end="(195, 27)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(195, 27)" end="(195, 28)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(195, 29)" end="(195, 77)">
            <AtomNode start="(195, 29)" end="(195, 30)" leading="" trailing=" " val=":"/>
            <OtherNode start="(195, 31)" end="(195, 77)" kind="«term∃_,_»">
              <AtomNode start="(195, 31)" end="(195, 32)" leading="" trailing=" " val="∃"/>
              <OtherNode start="(195, 33)" end="(195, 61)" kind="Lean.explicitBinders">
                <NullNode start="(195, 33)" end="(195, 61)">
                  <OtherNode start="(195, 33)" end="(195, 42)" kind="Lean.bracketedExplicitBinders">
                    <AtomNode start="(195, 33)" end="(195, 34)" leading="" trailing="" val="("/>
                    <NullNode start="(195, 34)" end="(195, 35)">
                      <LeanBinderidentNode start="(195, 34)" end="(195, 35)">
                        <IdentNode start="(195, 34)" end="(195, 35)" leading="" trailing=" " raw_val="i" val="i"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <AtomNode start="(195, 36)" end="(195, 37)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(195, 38)" end="(195, 41)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <AtomNode start="(195, 41)" end="(195, 42)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(195, 43)" end="(195, 61)" kind="Lean.bracketedExplicitBinders">
                    <AtomNode start="(195, 43)" end="(195, 44)" leading="" trailing="" val="("/>
                    <NullNode start="(195, 44)" end="(195, 45)">
                      <LeanBinderidentNode start="(195, 44)" end="(195, 45)">
                        <IdentNode start="(195, 44)" end="(195, 45)" leading="" trailing=" " raw_val="h" val="h"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <AtomNode start="(195, 46)" end="(195, 47)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(195, 48)" end="(195, 60)" kind="«term_&amp;lt;_»">
                      <IdentNode start="(195, 48)" end="(195, 49)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(195, 50)" end="(195, 51)" leading="" trailing=" " val="&amp;lt;"/>
                      <IdentNode start="(195, 52)" end="(195, 60)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                    </OtherNode>
                    <AtomNode start="(195, 60)" end="(195, 61)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(195, 61)" end="(195, 62)" leading="" trailing=" " val=","/>
              <OtherNode start="(195, 63)" end="(195, 77)" kind="«term_=_»">
                <OtherNode start="(195, 63)" end="(195, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(195, 63)" end="(195, 64)" leading="" trailing=" " raw_val="f" val="f"/>
                  <NullNode start="(195, 65)" end="(195, 73)">
                    <IdentNode start="(195, 65)" end="(195, 66)" leading="" trailing=" " raw_val="i" val="i"/>
                    <OtherNode start="(195, 67)" end="(195, 71)" kind="«term__[_]»">
                      <IdentNode start="(195, 67)" end="(195, 68)" leading="" trailing="" raw_val="l" val="l"/>
                      <AtomNode start="(195, 68)" end="(195, 69)" leading="" trailing="" val="["/>
                      <IdentNode start="(195, 69)" end="(195, 70)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(195, 70)" end="(195, 71)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <IdentNode start="(195, 72)" end="(195, 73)" leading="" trailing=" " raw_val="h" val="h"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(195, 74)" end="(195, 75)" leading="" trailing=" " val="="/>
                <IdentNode start="(195, 76)" end="(195, 77)" leading="" trailing=" " raw_val="b" val="b"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(195, 78)" end="(202, 21)">
          <AtomNode start="(195, 78)" end="(195, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(195, 81)" end="(202, 21)">
            <AtomNode start="(195, 81)" end="(195, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(196, 3)" end="(202, 21)">
              <TacticTacticseq1IndentedNode start="(196, 3)" end="(202, 21)">
                <NullNode start="(196, 3)" end="(202, 21)">
                  <OtherNode start="(196, 3)" end="(196, 36)" kind="Lean.Parser.Tactic.rwSeq" state_before="β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h : b ∈ l.mapFinIdx f&#10;⊢ ∃ i h, f i l[i] h = b" state_after="β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h :&#10;  b ∈&#10;    map&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | ⟨(x, i), m⟩ =&amp;gt; f i x ⋯)&#10;      l.zipIdx.attach&#10;⊢ ∃ i h, f i l[i] h = b" tactic="rw [mapFinIdx_eq_zipIdx_map] at h">
                    <AtomNode start="(196, 3)" end="(196, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(196, 6)" end="(196, 31)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(196, 6)" end="(196, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(196, 7)" end="(196, 30)">
                        <OtherNode start="(196, 7)" end="(196, 30)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(196, 7)" end="(196, 30)" leading="" trailing="" raw_val="mapFinIdx_eq_zipIdx_map" val="mapFinIdx_eq_zipIdx_map" full_name="List.mapFinIdx_eq_zipIdx_map" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(176, 9)" def_end="(176, 32)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(196, 30)" end="(196, 31)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(196, 32)" end="(196, 36)">
                      <OtherNode start="(196, 32)" end="(196, 36)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(196, 32)" end="(196, 34)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(196, 35)" end="(196, 36)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(196, 35)" end="(196, 36)">
                            <IdentNode start="(196, 35)" end="(196, 36)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(197, 3)" end="(197, 35)" kind="Lean.Parser.Tactic.replace" state_before="β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h :&#10;  b ∈&#10;    map&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | ⟨(x, i), m⟩ =&amp;gt; f i x ⋯)&#10;      l.zipIdx.attach&#10;⊢ ∃ i h, f i l[i] h = b" state_after="β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h :&#10;  ∃ a,&#10;    a ∈ l.zipIdx.attach ∧&#10;      (match a with&#10;        | ⟨(x, i), m⟩ =&amp;gt; f i x ⋯) =&#10;        b&#10;⊢ ∃ i h, f i l[i] h = b" tactic="replace h := exists_of_mem_map h">
                    <AtomNode start="(197, 3)" end="(197, 10)" leading="" trailing=" " val="replace"/>
                    <OtherNode start="(197, 11)" end="(197, 35)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(197, 11)" end="(197, 35)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(197, 11)" end="(197, 12)" kind="Lean.Parser.Term.haveId">
                          <IdentNode start="(197, 11)" end="(197, 12)" leading="" trailing=" " raw_val="h" val="h"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(197, 13)" end="(197, 15)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(197, 16)" end="(197, 35)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(197, 16)" end="(197, 33)" leading="" trailing=" " raw_val="exists_of_mem_map" val="exists_of_mem_map" full_name="List.exists_of_mem_map" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                          <NullNode start="(197, 34)" end="(197, 35)">
                            <IdentNode start="(197, 34)" end="(197, 35)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(198, 3)" end="(198, 97)" kind="Lean.Parser.Tactic.simp" state_before="β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h :&#10;  ∃ a,&#10;    a ∈ l.zipIdx.attach ∧&#10;      (match a with&#10;        | ⟨(x, i), m⟩ =&amp;gt; f i x ⋯) =&#10;        b&#10;⊢ ∃ i h, f i l[i] h = b" state_after="β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h : ∃ a b_1 h, f b_1 a ⋯ = b&#10;⊢ ∃ i h, f i l[i] h = b" tactic="simp only [mem_attach, true_and, Subtype.exists, Prod.exists, mk_mem_zipIdx_iff_getElem?] at h">
                    <AtomNode start="(198, 3)" end="(198, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(198, 8)" end="(198, 12)">
                      <AtomNode start="(198, 8)" end="(198, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(198, 13)" end="(198, 92)">
                      <AtomNode start="(198, 13)" end="(198, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(198, 14)" end="(198, 91)">
                        <OtherNode start="(198, 14)" end="(198, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(198, 14)" end="(198, 24)" leading="" trailing="" raw_val="mem_attach" val="mem_attach" full_name="List.mem_attach" mod_name="Init.Data.List.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Attach.lean"/>
                        </OtherNode>
                        <AtomNode start="(198, 24)" end="(198, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(198, 26)" end="(198, 34)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(198, 26)" end="(198, 34)" leading="" trailing="" raw_val="true_and" val="true_and" full_name="true_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(198, 34)" end="(198, 35)" leading="" trailing=" " val=","/>
                        <OtherNode start="(198, 36)" end="(198, 50)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(198, 36)" end="(198, 50)" leading="" trailing="" raw_val="Subtype.exists" val="Subtype.exists" full_name="Subtype.exists" mod_name="Init.Data.Subtype" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Subtype.lean"/>
                        </OtherNode>
                        <AtomNode start="(198, 50)" end="(198, 51)" leading="" trailing=" " val=","/>
                        <OtherNode start="(198, 52)" end="(198, 63)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(198, 52)" end="(198, 63)" leading="" trailing="" raw_val="Prod.exists" val="Prod.exists" full_name="Prod.exists" mod_name="Init.Data.Prod" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Prod.lean"/>
                        </OtherNode>
                        <AtomNode start="(198, 63)" end="(198, 64)" leading="" trailing=" " val=","/>
                        <OtherNode start="(198, 65)" end="(198, 91)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(198, 65)" end="(198, 91)" leading="" trailing="" raw_val="mk_mem_zipIdx_iff_getElem?" val="mk_mem_zipIdx_iff_getElem?" full_name="List.mk_mem_zipIdx_iff_getElem?" mod_name="Init.Data.List.Nat.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Range.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(198, 91)" end="(198, 92)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(198, 93)" end="(198, 97)">
                      <OtherNode start="(198, 93)" end="(198, 97)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(198, 93)" end="(198, 95)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(198, 96)" end="(198, 97)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(198, 96)" end="(198, 97)">
                            <IdentNode start="(198, 96)" end="(198, 97)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(199, 3)" end="(199, 29)" kind="Lean.Parser.Tactic.obtain" state_before="β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h : ∃ a b_1 h, f b_1 a ⋯ = b&#10;⊢ ∃ i h, f i l[i] h = b" state_after="case intro.intro.intro&#10;β : Type u_1&#10;α : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : α&#10;i : Nat&#10;h : l[i]? = some b&#10;⊢ ∃ i_1 h_1, f i_1 l[i_1] h_1 = f i b ⋯" tactic="obtain ⟨b, i, h, rfl⟩ := h">
                    <AtomNode start="(199, 3)" end="(199, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(199, 10)" end="(199, 24)">
                      <OtherNode start="(199, 10)" end="(199, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(199, 10)" end="(199, 24)">
                          <OtherNode start="(199, 10)" end="(199, 24)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                            <AtomNode start="(199, 10)" end="(199, 11)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(199, 11)" end="(199, 23)">
                              <OtherNode start="(199, 11)" end="(199, 12)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(199, 11)" end="(199, 12)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(199, 11)" end="(199, 12)">
                                    <OtherNode start="(199, 11)" end="(199, 12)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(199, 11)" end="(199, 12)" leading="" trailing="" raw_val="b" val="b"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(199, 12)" end="(199, 13)" leading="" trailing=" " val=","/>
                              <OtherNode start="(199, 14)" end="(199, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(199, 14)" end="(199, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(199, 14)" end="(199, 15)">
                                    <OtherNode start="(199, 14)" end="(199, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(199, 14)" end="(199, 15)" leading="" trailing="" raw_val="i" val="i"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(199, 15)" end="(199, 16)" leading="" trailing=" " val=","/>
                              <OtherNode start="(199, 17)" end="(199, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(199, 17)" end="(199, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(199, 17)" end="(199, 18)">
                                    <OtherNode start="(199, 17)" end="(199, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(199, 17)" end="(199, 18)" leading="" trailing="" raw_val="h" val="h"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(199, 18)" end="(199, 19)" leading="" trailing=" " val=","/>
                              <OtherNode start="(199, 20)" end="(199, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(199, 20)" end="(199, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(199, 20)" end="(199, 23)">
                                    <OtherNode start="(199, 20)" end="(199, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(199, 20)" end="(199, 23)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(199, 23)" end="(199, 24)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(199, 25)" end="(199, 29)">
                      <AtomNode start="(199, 25)" end="(199, 27)" leading="" trailing=" " val=":="/>
                      <NullNode start="(199, 28)" end="(199, 29)">
                        <IdentNode start="(199, 28)" end="(199, 29)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(200, 3)" end="(200, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="case intro.intro.intro&#10;β : Type u_1&#10;α : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : α&#10;i : Nat&#10;h : l[i]? = some b&#10;⊢ ∃ i_1 h_1, f i_1 l[i_1] h_1 = f i b ⋯" state_after="case intro.intro.intro&#10;β : Type u_1&#10;α : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : α&#10;i : Nat&#10;h✝ : l[i]? = some b&#10;h : ∃ h, l[i] = b&#10;⊢ ∃ i_1 h, f i_1 l[i_1] h = f i b ⋯" tactic="rw [getElem?_eq_some_iff] at h">
                    <AtomNode start="(200, 3)" end="(200, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(200, 6)" end="(200, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(200, 6)" end="(200, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(200, 7)" end="(200, 27)">
                        <OtherNode start="(200, 7)" end="(200, 27)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(200, 7)" end="(200, 27)" leading="" trailing="" raw_val="getElem?_eq_some_iff" val="getElem?_eq_some_iff" full_name="List.getElem?_eq_some_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(200, 27)" end="(200, 28)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(200, 29)" end="(200, 33)">
                      <OtherNode start="(200, 29)" end="(200, 33)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(200, 29)" end="(200, 31)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(200, 32)" end="(200, 33)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(200, 32)" end="(200, 33)">
                            <IdentNode start="(200, 32)" end="(200, 33)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(201, 3)" end="(201, 24)" kind="Lean.Parser.Tactic.obtain" state_before="case intro.intro.intro&#10;β : Type u_1&#10;α : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : α&#10;i : Nat&#10;h✝ : l[i]? = some b&#10;h : ∃ h, l[i] = b&#10;⊢ ∃ i_1 h, f i_1 l[i_1] h = f i b ⋯" state_after="case intro.intro.intro.intro&#10;β : Type u_1&#10;α : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;i : Nat&#10;h' : i &amp;lt; l.length&#10;h : l[i]? = some l[i]&#10;⊢ ∃ i_1 h_1, f i_1 l[i_1] h_1 = f i l[i] ⋯" tactic="obtain ⟨h', rfl⟩ := h">
                    <AtomNode start="(201, 3)" end="(201, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(201, 10)" end="(201, 19)">
                      <OtherNode start="(201, 10)" end="(201, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(201, 10)" end="(201, 19)">
                          <OtherNode start="(201, 10)" end="(201, 19)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                            <AtomNode start="(201, 10)" end="(201, 11)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(201, 11)" end="(201, 18)">
                              <OtherNode start="(201, 11)" end="(201, 13)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(201, 11)" end="(201, 13)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(201, 11)" end="(201, 13)">
                                    <OtherNode start="(201, 11)" end="(201, 13)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(201, 11)" end="(201, 13)" leading="" trailing="" raw_val="h'" val="h'"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(201, 13)" end="(201, 14)" leading="" trailing=" " val=","/>
                              <OtherNode start="(201, 15)" end="(201, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(201, 15)" end="(201, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(201, 15)" end="(201, 18)">
                                    <OtherNode start="(201, 15)" end="(201, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(201, 15)" end="(201, 18)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(201, 18)" end="(201, 19)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(201, 20)" end="(201, 24)">
                      <AtomNode start="(201, 20)" end="(201, 22)" leading="" trailing=" " val=":="/>
                      <NullNode start="(201, 23)" end="(201, 24)">
                        <IdentNode start="(201, 23)" end="(201, 24)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(202, 3)" end="(202, 21)" kind="Lean.Parser.Tactic.exact" state_before="case intro.intro.intro.intro&#10;β : Type u_1&#10;α : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;i : Nat&#10;h' : i &amp;lt; l.length&#10;h : l[i]? = some l[i]&#10;⊢ ∃ i_1 h_1, f i_1 l[i_1] h_1 = f i l[i] ⋯" state_after="no goals" tactic="exact ⟨i, h', rfl⟩">
                    <AtomNode start="(202, 3)" end="(202, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(202, 9)" end="(202, 21)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(202, 9)" end="(202, 10)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(202, 10)" end="(202, 20)">
                        <IdentNode start="(202, 10)" end="(202, 11)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(202, 11)" end="(202, 12)" leading="" trailing=" " val=","/>
                        <IdentNode start="(202, 13)" end="(202, 15)" leading="" trailing="" raw_val="h'" val="h'"/>
                        <AtomNode start="(202, 15)" end="(202, 16)" leading="" trailing=" " val=","/>
                        <IdentNode start="(202, 17)" end="(202, 20)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                      <AtomNode start="(202, 20)" end="(202, 21)" leading="" trailing="&#10;&#10;" val="⟩"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(204, 1)" end="(211, 41)" name="mem_mapFinIdx" full_name="List.mem_mapFinIdx">
      <CommandDeclmodifiersNode start="(204, 1)" end="(204, 8)">
        <NullNode/>
        <NullNode start="(204, 1)" end="(204, 8)">
          <OtherNode start="(204, 1)" end="(204, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(204, 1)" end="(204, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(204, 3)" end="(204, 7)">
              <OtherNode start="(204, 3)" end="(204, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(204, 3)" end="(204, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(204, 3)" end="(204, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(204, 7)" end="(204, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(204, 9)" end="(211, 41)" name="mem_mapFinIdx" full_name="List.mem_mapFinIdx" _is_private_decl="False">
        <AtomNode start="(204, 9)" end="(204, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(204, 17)" end="(204, 30)">
          <IdentNode start="(204, 17)" end="(204, 30)" leading="" trailing=" " raw_val="mem_mapFinIdx" val="mem_mapFinIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(204, 31)" end="(205, 71)">
          <NullNode start="(204, 31)" end="(204, 96)">
            <OtherNode start="(204, 31)" end="(204, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(204, 31)" end="(204, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(204, 32)" end="(204, 33)">
                <IdentNode start="(204, 32)" end="(204, 33)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(204, 34)" end="(204, 37)">
                <AtomNode start="(204, 34)" end="(204, 35)" leading="" trailing=" " val=":"/>
                <IdentNode start="(204, 36)" end="(204, 37)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(204, 37)" end="(204, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(204, 39)" end="(204, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(204, 39)" end="(204, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(204, 40)" end="(204, 41)">
                <IdentNode start="(204, 40)" end="(204, 41)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(204, 42)" end="(204, 50)">
                <AtomNode start="(204, 42)" end="(204, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(204, 44)" end="(204, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(204, 44)" end="(204, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(204, 49)" end="(204, 50)">
                    <IdentNode start="(204, 49)" end="(204, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(204, 50)" end="(204, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(204, 52)" end="(204, 96)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(204, 52)" end="(204, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(204, 53)" end="(204, 54)">
                <IdentNode start="(204, 53)" end="(204, 54)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(204, 55)" end="(204, 95)">
                <AtomNode start="(204, 55)" end="(204, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(204, 57)" end="(204, 95)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(204, 57)" end="(204, 66)">
                    <AtomNode start="(204, 57)" end="(204, 58)" leading="" trailing="" val="("/>
                    <NullNode start="(204, 58)" end="(204, 59)">
                      <IdentNode start="(204, 58)" end="(204, 59)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(204, 60)" end="(204, 65)">
                      <AtomNode start="(204, 60)" end="(204, 61)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(204, 62)" end="(204, 65)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(204, 65)" end="(204, 66)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(204, 67)" end="(204, 68)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(204, 69)" end="(204, 95)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(204, 69)" end="(204, 70)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(204, 71)" end="(204, 72)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(204, 73)" end="(204, 95)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(204, 73)" end="(204, 91)">
                        <AtomNode start="(204, 73)" end="(204, 74)" leading="" trailing="" val="("/>
                        <NullNode start="(204, 74)" end="(204, 75)">
                          <IdentNode start="(204, 74)" end="(204, 75)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(204, 76)" end="(204, 90)">
                          <AtomNode start="(204, 76)" end="(204, 77)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(204, 78)" end="(204, 90)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(204, 78)" end="(204, 79)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(204, 80)" end="(204, 81)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(204, 82)" end="(204, 90)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(204, 90)" end="(204, 91)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(204, 92)" end="(204, 93)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(204, 94)" end="(204, 95)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(204, 95)" end="(204, 96)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(204, 97)" end="(205, 71)">
            <AtomNode start="(204, 97)" end="(204, 98)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(205, 5)" end="(205, 71)" kind="«term_↔_»">
              <OtherNode start="(205, 5)" end="(205, 22)" kind="«term_∈_»">
                <IdentNode start="(205, 5)" end="(205, 6)" leading="" trailing=" " raw_val="b" val="b"/>
                <AtomNode start="(205, 7)" end="(205, 8)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(205, 9)" end="(205, 22)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(205, 9)" end="(205, 20)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                  <NullNode start="(205, 21)" end="(205, 22)">
                    <IdentNode start="(205, 21)" end="(205, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(205, 23)" end="(205, 24)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(205, 25)" end="(205, 71)" kind="«term∃_,_»">
                <AtomNode start="(205, 25)" end="(205, 26)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(205, 27)" end="(205, 55)" kind="Lean.explicitBinders">
                  <NullNode start="(205, 27)" end="(205, 55)">
                    <OtherNode start="(205, 27)" end="(205, 36)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(205, 27)" end="(205, 28)" leading="" trailing="" val="("/>
                      <NullNode start="(205, 28)" end="(205, 29)">
                        <LeanBinderidentNode start="(205, 28)" end="(205, 29)">
                          <IdentNode start="(205, 28)" end="(205, 29)" leading="" trailing=" " raw_val="i" val="i"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(205, 30)" end="(205, 31)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(205, 32)" end="(205, 35)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(205, 35)" end="(205, 36)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(205, 37)" end="(205, 55)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(205, 37)" end="(205, 38)" leading="" trailing="" val="("/>
                      <NullNode start="(205, 38)" end="(205, 39)">
                        <LeanBinderidentNode start="(205, 38)" end="(205, 39)">
                          <IdentNode start="(205, 38)" end="(205, 39)" leading="" trailing=" " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(205, 40)" end="(205, 41)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(205, 42)" end="(205, 54)" kind="«term_&amp;lt;_»">
                        <IdentNode start="(205, 42)" end="(205, 43)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(205, 44)" end="(205, 45)" leading="" trailing=" " val="&amp;lt;"/>
                        <IdentNode start="(205, 46)" end="(205, 54)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                      </OtherNode>
                      <AtomNode start="(205, 54)" end="(205, 55)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(205, 55)" end="(205, 56)" leading="" trailing=" " val=","/>
                <OtherNode start="(205, 57)" end="(205, 71)" kind="«term_=_»">
                  <OtherNode start="(205, 57)" end="(205, 67)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(205, 57)" end="(205, 58)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(205, 59)" end="(205, 67)">
                      <IdentNode start="(205, 59)" end="(205, 60)" leading="" trailing=" " raw_val="i" val="i"/>
                      <OtherNode start="(205, 61)" end="(205, 65)" kind="«term__[_]»">
                        <IdentNode start="(205, 61)" end="(205, 62)" leading="" trailing="" raw_val="l" val="l"/>
                        <AtomNode start="(205, 62)" end="(205, 63)" leading="" trailing="" val="["/>
                        <IdentNode start="(205, 63)" end="(205, 64)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(205, 64)" end="(205, 65)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                      <IdentNode start="(205, 66)" end="(205, 67)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(205, 68)" end="(205, 69)" leading="" trailing=" " val="="/>
                  <IdentNode start="(205, 70)" end="(205, 71)" leading="" trailing=" " raw_val="b" val="b"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(205, 72)" end="(211, 41)">
          <AtomNode start="(205, 72)" end="(205, 74)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(205, 75)" end="(211, 41)">
            <AtomNode start="(205, 75)" end="(205, 77)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(206, 3)" end="(211, 41)">
              <TacticTacticseq1IndentedNode start="(206, 3)" end="(211, 41)">
                <NullNode start="(206, 3)" end="(211, 41)">
                  <OtherNode start="(206, 3)" end="(206, 14)" kind="Lean.Parser.Tactic.constructor" state_before="β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ b ∈ l.mapFinIdx f ↔ ∃ i h, f i l[i] h = b" state_after="case mp&#10;β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ b ∈ l.mapFinIdx f → ∃ i h, f i l[i] h = b&#10;&#10;case mpr&#10;β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ i h, f i l[i] h = b) → b ∈ l.mapFinIdx f" tactic="constructor">
                    <AtomNode start="(206, 3)" end="(206, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(207, 3)" end="(208, 36)" kind="Lean.cdot" state_before="case mp&#10;β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ b ∈ l.mapFinIdx f → ∃ i h, f i l[i] h = b&#10;&#10;case mpr&#10;β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ i h, f i l[i] h = b) → b ∈ l.mapFinIdx f" state_after="case mpr&#10;β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ i h, f i l[i] h = b) → b ∈ l.mapFinIdx f" tactic="· intro h&#10;  exact exists_of_mem_mapFinIdx h">
                    <OtherNode start="(207, 3)" end="(207, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(207, 3)" end="(207, 4)" kind="patternIgnore">
                        <OtherNode start="(207, 3)" end="(207, 4)" kind="token.«· »">
                          <AtomNode start="(207, 3)" end="(207, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(207, 5)" end="(208, 36)">
                      <TacticTacticseq1IndentedNode start="(207, 5)" end="(208, 36)">
                        <NullNode start="(207, 5)" end="(208, 36)">
                          <OtherNode start="(207, 5)" end="(207, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ b ∈ l.mapFinIdx f → ∃ i h, f i l[i] h = b" state_after="case mp&#10;β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h : b ∈ l.mapFinIdx f&#10;⊢ ∃ i h, f i l[i] h = b" tactic="intro h">
                            <AtomNode start="(207, 5)" end="(207, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(207, 11)" end="(207, 12)">
                              <IdentNode start="(207, 11)" end="(207, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(208, 5)" end="(208, 36)" kind="Lean.Parser.Tactic.exact" state_before="case mp&#10;β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h : b ∈ l.mapFinIdx f&#10;⊢ ∃ i h, f i l[i] h = b" state_after="no goals" tactic="exact exists_of_mem_mapFinIdx h">
                            <AtomNode start="(208, 5)" end="(208, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(208, 11)" end="(208, 36)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(208, 11)" end="(208, 34)" leading="" trailing=" " raw_val="exists_of_mem_mapFinIdx" val="exists_of_mem_mapFinIdx" full_name="List.exists_of_mem_mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(194, 9)" def_end="(194, 32)"/>
                              <NullNode start="(208, 35)" end="(208, 36)">
                                <IdentNode start="(208, 35)" end="(208, 36)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(209, 3)" end="(211, 41)" kind="Lean.cdot" state_before="case mpr&#10;β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ i h, f i l[i] h = b) → b ∈ l.mapFinIdx f" state_after="no goals" tactic="· rintro ⟨i, h, rfl⟩&#10;  rw [mem_iff_getElem]&#10;  exact ⟨i, by simpa using h, by simp⟩">
                    <OtherNode start="(209, 3)" end="(209, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(209, 3)" end="(209, 4)" kind="patternIgnore">
                        <OtherNode start="(209, 3)" end="(209, 4)" kind="token.«· »">
                          <AtomNode start="(209, 3)" end="(209, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(209, 5)" end="(211, 41)">
                      <TacticTacticseq1IndentedNode start="(209, 5)" end="(211, 41)">
                        <NullNode start="(209, 5)" end="(211, 41)">
                          <OtherNode start="(209, 5)" end="(209, 23)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;β : Type u_1&#10;α : Type u_2&#10;b : β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ i h, f i l[i] h = b) → b ∈ l.mapFinIdx f" state_after="case mpr.intro.intro&#10;β : Type u_1&#10;α : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f i l[i] h ∈ l.mapFinIdx f" tactic="rintro ⟨i, h, rfl⟩">
                            <AtomNode start="(209, 5)" end="(209, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(209, 12)" end="(209, 23)">
                              <OtherNode start="(209, 12)" end="(209, 23)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(209, 12)" end="(209, 23)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(209, 12)" end="(209, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(209, 13)" end="(209, 22)">
                                    <OtherNode start="(209, 13)" end="(209, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(209, 13)" end="(209, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(209, 13)" end="(209, 14)">
                                          <OtherNode start="(209, 13)" end="(209, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(209, 13)" end="(209, 14)" leading="" trailing="" raw_val="i" val="i"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(209, 14)" end="(209, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(209, 16)" end="(209, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(209, 16)" end="(209, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(209, 16)" end="(209, 17)">
                                          <OtherNode start="(209, 16)" end="(209, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(209, 16)" end="(209, 17)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(209, 17)" end="(209, 18)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(209, 19)" end="(209, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(209, 19)" end="(209, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(209, 19)" end="(209, 22)">
                                          <OtherNode start="(209, 19)" end="(209, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(209, 19)" end="(209, 22)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(209, 22)" end="(209, 23)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(210, 5)" end="(210, 25)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr.intro.intro&#10;β : Type u_1&#10;α : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f i l[i] h ∈ l.mapFinIdx f" state_after="case mpr.intro.intro&#10;β : Type u_1&#10;α : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ ∃ i_1 h_1, (l.mapFinIdx f)[i_1] = f i l[i] h" tactic="rw [mem_iff_getElem]">
                            <AtomNode start="(210, 5)" end="(210, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(210, 8)" end="(210, 25)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(210, 8)" end="(210, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(210, 9)" end="(210, 24)">
                                <OtherNode start="(210, 9)" end="(210, 24)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(210, 9)" end="(210, 24)" leading="" trailing="" raw_val="mem_iff_getElem" val="mem_iff_getElem" full_name="List.mem_iff_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(210, 24)" end="(210, 25)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(211, 5)" end="(211, 41)" kind="Lean.Parser.Tactic.exact" state_before="case mpr.intro.intro&#10;β : Type u_1&#10;α : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ ∃ i_1 h_1, (l.mapFinIdx f)[i_1] = f i l[i] h" state_after="no goals" tactic="exact ⟨i, by simpa using h, by simp⟩">
                            <AtomNode start="(211, 5)" end="(211, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(211, 11)" end="(211, 41)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(211, 11)" end="(211, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(211, 12)" end="(211, 40)">
                                <IdentNode start="(211, 12)" end="(211, 13)" leading="" trailing="" raw_val="i" val="i"/>
                                <AtomNode start="(211, 13)" end="(211, 14)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(211, 15)" end="(211, 31)">
                                  <AtomNode start="(211, 15)" end="(211, 17)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(211, 18)" end="(211, 31)">
                                    <TacticTacticseq1IndentedNode start="(211, 18)" end="(211, 31)">
                                      <NullNode start="(211, 18)" end="(211, 31)">
                                        <OtherNode start="(211, 18)" end="(211, 31)" kind="Lean.Parser.Tactic.simpa" state_before="β : Type u_1&#10;α : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ i &amp;lt; (l.mapFinIdx f).length" state_after="no goals" tactic="simpa using h">
                                          <AtomNode start="(211, 18)" end="(211, 23)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(211, 24)" end="(211, 31)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(211, 24)" end="(211, 31)">
                                              <AtomNode start="(211, 24)" end="(211, 29)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(211, 30)" end="(211, 31)" leading="" trailing="" raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(211, 31)" end="(211, 32)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(211, 33)" end="(211, 40)">
                                  <AtomNode start="(211, 33)" end="(211, 35)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(211, 36)" end="(211, 40)">
                                    <TacticTacticseq1IndentedNode start="(211, 36)" end="(211, 40)">
                                      <NullNode start="(211, 36)" end="(211, 40)">
                                        <OtherNode start="(211, 36)" end="(211, 40)" kind="Lean.Parser.Tactic.simp" state_before="β : Type u_1&#10;α : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ (l.mapFinIdx f)[i] = f i l[i] h" state_after="no goals" tactic="simp">
                                          <AtomNode start="(211, 36)" end="(211, 40)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(211, 40)" end="(211, 41)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(213, 1)" end="(226, 27)" name="mapFinIdx_eq_cons_iff" full_name="List.mapFinIdx_eq_cons_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(213, 1)" end="(226, 27)" name="mapFinIdx_eq_cons_iff" full_name="List.mapFinIdx_eq_cons_iff" _is_private_decl="False">
        <AtomNode start="(213, 1)" end="(213, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(213, 9)" end="(213, 30)">
          <IdentNode start="(213, 9)" end="(213, 30)" leading="" trailing=" " raw_val="mapFinIdx_eq_cons_iff" val="mapFinIdx_eq_cons_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(213, 31)" end="(216, 100)">
          <NullNode start="(213, 31)" end="(213, 96)">
            <OtherNode start="(213, 31)" end="(213, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(213, 31)" end="(213, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(213, 32)" end="(213, 33)">
                <IdentNode start="(213, 32)" end="(213, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(213, 34)" end="(213, 42)">
                <AtomNode start="(213, 34)" end="(213, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(213, 36)" end="(213, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(213, 36)" end="(213, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(213, 41)" end="(213, 42)">
                    <IdentNode start="(213, 41)" end="(213, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(213, 42)" end="(213, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(213, 44)" end="(213, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(213, 44)" end="(213, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(213, 45)" end="(213, 46)">
                <IdentNode start="(213, 45)" end="(213, 46)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(213, 47)" end="(213, 50)">
                <AtomNode start="(213, 47)" end="(213, 48)" leading="" trailing=" " val=":"/>
                <IdentNode start="(213, 49)" end="(213, 50)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(213, 50)" end="(213, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(213, 52)" end="(213, 96)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(213, 52)" end="(213, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(213, 53)" end="(213, 54)">
                <IdentNode start="(213, 53)" end="(213, 54)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(213, 55)" end="(213, 95)">
                <AtomNode start="(213, 55)" end="(213, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(213, 57)" end="(213, 95)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(213, 57)" end="(213, 66)">
                    <AtomNode start="(213, 57)" end="(213, 58)" leading="" trailing="" val="("/>
                    <NullNode start="(213, 58)" end="(213, 59)">
                      <IdentNode start="(213, 58)" end="(213, 59)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(213, 60)" end="(213, 65)">
                      <AtomNode start="(213, 60)" end="(213, 61)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(213, 62)" end="(213, 65)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(213, 65)" end="(213, 66)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(213, 67)" end="(213, 68)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(213, 69)" end="(213, 95)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(213, 69)" end="(213, 70)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(213, 71)" end="(213, 72)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(213, 73)" end="(213, 95)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(213, 73)" end="(213, 91)">
                        <AtomNode start="(213, 73)" end="(213, 74)" leading="" trailing="" val="("/>
                        <NullNode start="(213, 74)" end="(213, 75)">
                          <IdentNode start="(213, 74)" end="(213, 75)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(213, 76)" end="(213, 90)">
                          <AtomNode start="(213, 76)" end="(213, 77)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(213, 78)" end="(213, 90)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(213, 78)" end="(213, 79)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(213, 80)" end="(213, 81)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(213, 82)" end="(213, 90)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(213, 90)" end="(213, 91)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(213, 92)" end="(213, 93)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(213, 94)" end="(213, 95)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(213, 95)" end="(213, 96)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(213, 97)" end="(216, 100)">
            <AtomNode start="(213, 97)" end="(213, 98)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(214, 5)" end="(216, 100)" kind="«term_↔_»">
              <OtherNode start="(214, 5)" end="(214, 28)" kind="«term_=_»">
                <OtherNode start="(214, 5)" end="(214, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(214, 5)" end="(214, 16)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                  <NullNode start="(214, 17)" end="(214, 18)">
                    <IdentNode start="(214, 17)" end="(214, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(214, 19)" end="(214, 20)" leading="" trailing=" " val="="/>
                <OtherNode start="(214, 21)" end="(214, 28)" kind="«term_::_»">
                  <IdentNode start="(214, 21)" end="(214, 22)" leading="" trailing=" " raw_val="b" val="b"/>
                  <AtomNode start="(214, 23)" end="(214, 25)" leading="" trailing=" " val="::"/>
                  <IdentNode start="(214, 26)" end="(214, 28)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(214, 29)" end="(214, 30)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(215, 7)" end="(216, 100)" kind="«term∃_,_»">
                <AtomNode start="(215, 7)" end="(215, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(215, 9)" end="(215, 48)" kind="Lean.explicitBinders">
                  <NullNode start="(215, 9)" end="(215, 48)">
                    <OtherNode start="(215, 9)" end="(215, 16)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(215, 9)" end="(215, 10)" leading="" trailing="" val="("/>
                      <NullNode start="(215, 10)" end="(215, 11)">
                        <LeanBinderidentNode start="(215, 10)" end="(215, 11)">
                          <IdentNode start="(215, 10)" end="(215, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(215, 12)" end="(215, 13)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(215, 14)" end="(215, 15)" leading="" trailing="" raw_val="α" val="α"/>
                      <AtomNode start="(215, 15)" end="(215, 16)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(215, 17)" end="(215, 30)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(215, 17)" end="(215, 18)" leading="" trailing="" val="("/>
                      <NullNode start="(215, 18)" end="(215, 20)">
                        <LeanBinderidentNode start="(215, 18)" end="(215, 20)">
                          <IdentNode start="(215, 18)" end="(215, 20)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(215, 21)" end="(215, 22)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(215, 23)" end="(215, 29)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(215, 23)" end="(215, 27)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(215, 28)" end="(215, 29)">
                          <IdentNode start="(215, 28)" end="(215, 29)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(215, 29)" end="(215, 30)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(215, 31)" end="(215, 48)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(215, 31)" end="(215, 32)" leading="" trailing="" val="("/>
                      <NullNode start="(215, 32)" end="(215, 33)">
                        <LeanBinderidentNode start="(215, 32)" end="(215, 33)">
                          <IdentNode start="(215, 32)" end="(215, 33)" leading="" trailing=" " raw_val="w" val="w"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(215, 34)" end="(215, 35)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(215, 36)" end="(215, 47)" kind="«term_=_»">
                        <IdentNode start="(215, 36)" end="(215, 37)" leading="" trailing=" " raw_val="l" val="l"/>
                        <AtomNode start="(215, 38)" end="(215, 39)" leading="" trailing=" " val="="/>
                        <OtherNode start="(215, 40)" end="(215, 47)" kind="«term_::_»">
                          <IdentNode start="(215, 40)" end="(215, 41)" leading="" trailing=" " raw_val="a" val="a"/>
                          <AtomNode start="(215, 42)" end="(215, 44)" leading="" trailing=" " val="::"/>
                          <IdentNode start="(215, 45)" end="(215, 47)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(215, 47)" end="(215, 48)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(215, 48)" end="(215, 49)" leading="" trailing="&#10;        " val=","/>
                <OtherNode start="(216, 9)" end="(216, 100)" kind="«term_∧_»">
                  <OtherNode start="(216, 9)" end="(216, 32)" kind="«term_=_»">
                    <OtherNode start="(216, 9)" end="(216, 28)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(216, 9)" end="(216, 10)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(216, 11)" end="(216, 28)">
                        <OtherNode start="(216, 11)" end="(216, 12)" kind="num">
                          <AtomNode start="(216, 11)" end="(216, 12)" leading="" trailing=" " val="0"/>
                        </OtherNode>
                        <IdentNode start="(216, 13)" end="(216, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                        <OtherNode start="(216, 15)" end="(216, 28)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(216, 15)" end="(216, 16)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(216, 16)" end="(216, 27)">
                            <AtomNode start="(216, 16)" end="(216, 18)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(216, 19)" end="(216, 27)">
                              <TacticTacticseq1IndentedNode start="(216, 19)" end="(216, 27)">
                                <NullNode start="(216, 19)" end="(216, 27)">
                                  <OtherNode start="(216, 19)" end="(216, 27)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.32162&#10;β : Type ?u.32186&#10;l₂ : List β&#10;l : List α&#10;b : β&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;a : α&#10;l₁ : List α&#10;w : l = a :: l₁&#10;⊢ 0 &amp;lt; l.length" state_after="no goals" tactic="simp [w]">
                                    <AtomNode start="(216, 19)" end="(216, 23)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(216, 24)" end="(216, 27)">
                                      <AtomNode start="(216, 24)" end="(216, 25)" leading="" trailing="" val="["/>
                                      <NullNode start="(216, 25)" end="(216, 26)">
                                        <OtherNode start="(216, 25)" end="(216, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(216, 25)" end="(216, 26)" leading="" trailing="" raw_val="w" val="w"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(216, 26)" end="(216, 27)" leading="" trailing="" val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(216, 27)" end="(216, 28)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(216, 29)" end="(216, 30)" leading="" trailing=" " val="="/>
                    <IdentNode start="(216, 31)" end="(216, 32)" leading="" trailing=" " raw_val="b" val="b"/>
                  </OtherNode>
                  <AtomNode start="(216, 33)" end="(216, 34)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(216, 35)" end="(216, 100)" kind="«term_=_»">
                    <OtherNode start="(216, 35)" end="(216, 95)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(216, 35)" end="(216, 47)" leading="" trailing=" " raw_val="l₁.mapFinIdx" val="l₁.mapFinIdx"/>
                      <NullNode start="(216, 48)" end="(216, 95)">
                        <OtherNode start="(216, 48)" end="(216, 95)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(216, 48)" end="(216, 49)" leading="" trailing="" val="("/>
                          <OtherNode start="(216, 49)" end="(216, 94)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(216, 49)" end="(216, 52)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(216, 53)" end="(216, 94)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(216, 53)" end="(216, 58)">
                                <IdentNode start="(216, 53)" end="(216, 54)" leading="" trailing=" " raw_val="i" val="i"/>
                                <IdentNode start="(216, 55)" end="(216, 56)" leading="" trailing=" " raw_val="a" val="a"/>
                                <IdentNode start="(216, 57)" end="(216, 58)" leading="" trailing=" " raw_val="h" val="h"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(216, 59)" end="(216, 61)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(216, 62)" end="(216, 94)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(216, 62)" end="(216, 63)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(216, 64)" end="(216, 94)">
                                  <OtherNode start="(216, 64)" end="(216, 71)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(216, 64)" end="(216, 65)" leading="" trailing="" val="("/>
                                    <OtherNode start="(216, 65)" end="(216, 70)" kind="«term_+_»">
                                      <IdentNode start="(216, 65)" end="(216, 66)" leading="" trailing=" " raw_val="i" val="i"/>
                                      <AtomNode start="(216, 67)" end="(216, 68)" leading="" trailing=" " val="+"/>
                                      <OtherNode start="(216, 69)" end="(216, 70)" kind="num">
                                        <AtomNode start="(216, 69)" end="(216, 70)" leading="" trailing="" val="1"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <AtomNode start="(216, 70)" end="(216, 71)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <IdentNode start="(216, 72)" end="(216, 73)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <OtherNode start="(216, 74)" end="(216, 94)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(216, 74)" end="(216, 75)" leading="" trailing="" val="("/>
                                    <TermBytacticNode start="(216, 75)" end="(216, 93)">
                                      <AtomNode start="(216, 75)" end="(216, 77)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(216, 78)" end="(216, 93)">
                                        <TacticTacticseq1IndentedNode start="(216, 78)" end="(216, 93)">
                                          <NullNode start="(216, 78)" end="(216, 93)">
                                            <OtherNode start="(216, 78)" end="(216, 86)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.32162&#10;β : Type ?u.32186&#10;l₂ : List β&#10;l : List α&#10;b : β&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;a✝ : α&#10;l₁ : List α&#10;w : l = a✝ :: l₁&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l₁.length&#10;⊢ i + 1 &amp;lt; l.length" state_after="α : Type ?u.32162&#10;β : Type ?u.32186&#10;l₂ : List β&#10;l : List α&#10;b : β&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;a✝ : α&#10;l₁ : List α&#10;w : l = a✝ :: l₁&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l₁.length&#10;⊢ i &amp;lt; l₁.length" tactic="simp [w]">
                                              <AtomNode start="(216, 78)" end="(216, 82)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(216, 83)" end="(216, 86)">
                                                <AtomNode start="(216, 83)" end="(216, 84)" leading="" trailing="" val="["/>
                                                <NullNode start="(216, 84)" end="(216, 85)">
                                                  <OtherNode start="(216, 84)" end="(216, 85)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(216, 84)" end="(216, 85)" leading="" trailing="" raw_val="w" val="w"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(216, 85)" end="(216, 86)" leading="" trailing="" val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(216, 86)" end="(216, 87)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(216, 88)" end="(216, 93)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.32162&#10;β : Type ?u.32186&#10;l₂ : List β&#10;l : List α&#10;b : β&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;a✝ : α&#10;l₁ : List α&#10;w : l = a✝ :: l₁&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l₁.length&#10;⊢ i &amp;lt; l₁.length" state_after="no goals" tactic="omega">
                                              <AtomNode start="(216, 88)" end="(216, 93)" leading="" trailing="" val="omega"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                    <AtomNode start="(216, 93)" end="(216, 94)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(216, 94)" end="(216, 95)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(216, 96)" end="(216, 97)" leading="" trailing=" " val="="/>
                    <IdentNode start="(216, 98)" end="(216, 100)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(216, 101)" end="(226, 27)">
          <AtomNode start="(216, 101)" end="(216, 103)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(216, 104)" end="(226, 27)">
            <AtomNode start="(216, 104)" end="(216, 106)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(217, 3)" end="(226, 27)">
              <TacticTacticseq1IndentedNode start="(217, 3)" end="(226, 27)">
                <NullNode start="(217, 3)" end="(226, 27)">
                  <OtherNode start="(217, 3)" end="(226, 27)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;l : List α&#10;b : β&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ l.mapFinIdx f = b :: l₂ ↔ ∃ a l₁ w, f 0 a ⋯ = b ∧ (l₁.mapFinIdx fun i a_1 h =&amp;gt; f (i + 1) a_1 ⋯) = l₂" state_after="no goals" tactic="cases l with&#10;| nil =&amp;gt; simp&#10;| cons x l' =&amp;gt;&#10;  simp only [mapFinIdx_cons, cons.injEq, length_cons, Fin.zero_eta, Fin.cast_succ_eq,&#10;    exists_and_left]&#10;  constructor&#10;  · rintro ⟨rfl, rfl⟩&#10;    refine ⟨x, l', ⟨rfl, rfl⟩, by simp⟩&#10;  · rintro ⟨a, l', ⟨rfl, rfl⟩, ⟨rfl, rfl⟩⟩&#10;    exact ⟨rfl, by simp⟩">
                    <AtomNode start="(217, 3)" end="(217, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(217, 9)" end="(217, 10)">
                      <OtherNode start="(217, 9)" end="(217, 10)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(217, 9)" end="(217, 10)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(217, 11)" end="(226, 27)">
                      <OtherNode start="(217, 11)" end="(226, 27)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(217, 11)" end="(217, 15)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(218, 3)" end="(226, 27)">
                          <OtherNode start="(218, 3)" end="(218, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(218, 3)" end="(218, 8)">
                              <OtherNode start="(218, 3)" end="(218, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(218, 3)" end="(218, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(218, 5)" end="(218, 8)">
                                  <NullNode/>
                                  <IdentNode start="(218, 5)" end="(218, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(218, 9)" end="(218, 16)">
                              <AtomNode start="(218, 9)" end="(218, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(218, 12)" end="(218, 16)">
                                <TacticTacticseq1IndentedNode start="(218, 12)" end="(218, 16)">
                                  <NullNode start="(218, 12)" end="(218, 16)">
                                    <OtherNode start="(218, 12)" end="(218, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;b : β&#10;f : (i : Nat) → α → i &amp;lt; [].length → β&#10;⊢ [].mapFinIdx f = b :: l₂ ↔ ∃ a l₁ w, f 0 a ⋯ = b ∧ (l₁.mapFinIdx fun i a_1 h =&amp;gt; f (i + 1) a_1 ⋯) = l₂" state_after="no goals" tactic="simp">
                                      <AtomNode start="(218, 12)" end="(218, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(219, 3)" end="(226, 27)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(219, 3)" end="(219, 14)">
                              <OtherNode start="(219, 3)" end="(219, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(219, 3)" end="(219, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(219, 5)" end="(219, 9)">
                                  <NullNode/>
                                  <IdentNode start="(219, 5)" end="(219, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(219, 10)" end="(219, 14)">
                                  <IdentNode start="(219, 10)" end="(219, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(219, 12)" end="(219, 14)" leading="" trailing=" " raw_val="l'" val="l'"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(219, 15)" end="(226, 27)">
                              <AtomNode start="(219, 15)" end="(219, 17)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(220, 5)" end="(226, 27)">
                                <TacticTacticseq1IndentedNode start="(220, 5)" end="(226, 27)">
                                  <NullNode start="(220, 5)" end="(226, 27)">
                                    <OtherNode start="(220, 5)" end="(221, 23)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;b : β&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ (x :: l').mapFinIdx f = b :: l₂ ↔ ∃ a l₁ w, f 0 a ⋯ = b ∧ (l₁.mapFinIdx fun i a_1 h =&amp;gt; f (i + 1) a_1 ⋯) = l₂" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;b : β&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ f 0 x ⋯ = b ∧ (l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯) = l₂ ↔&#10;    ∃ a l₁ h, f 0 a ⋯ = b ∧ (l₁.mapFinIdx fun i a_1 h_1 =&amp;gt; f (i + 1) a_1 ⋯) = l₂" tactic="simp only [mapFinIdx_cons, cons.injEq, length_cons, Fin.zero_eta, Fin.cast_succ_eq,&#10;  exists_and_left]">
                                      <AtomNode start="(220, 5)" end="(220, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(220, 10)" end="(220, 14)">
                                        <AtomNode start="(220, 10)" end="(220, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(220, 15)" end="(221, 23)">
                                        <AtomNode start="(220, 15)" end="(220, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(220, 16)" end="(221, 22)">
                                          <OtherNode start="(220, 16)" end="(220, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(220, 16)" end="(220, 30)" leading="" trailing="" raw_val="mapFinIdx_cons" val="mapFinIdx_cons" full_name="List.mapFinIdx_cons" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(146, 9)" def_end="(146, 23)"/>
                                          </OtherNode>
                                          <AtomNode start="(220, 30)" end="(220, 31)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(220, 32)" end="(220, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(220, 32)" end="(220, 42)" leading="" trailing="" raw_val="cons.injEq" val="cons.injEq" full_name="List.cons.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(220, 42)" end="(220, 43)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(220, 44)" end="(220, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(220, 44)" end="(220, 55)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(220, 55)" end="(220, 56)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(220, 57)" end="(220, 69)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(220, 57)" end="(220, 69)" leading="" trailing="" raw_val="Fin.zero_eta" val="Fin.zero_eta" full_name="Fin.zero_eta" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(220, 69)" end="(220, 70)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(220, 71)" end="(220, 87)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(220, 71)" end="(220, 87)" leading="" trailing="" raw_val="Fin.cast_succ_eq" val="Fin.cast_succ_eq" full_name="Fin.cast_succ_eq" mod_name="Init.Data.Fin.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Lemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(220, 87)" end="(220, 88)" leading="" trailing="&#10;      " val=","/>
                                          <OtherNode start="(221, 7)" end="(221, 22)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(221, 7)" end="(221, 22)" leading="" trailing="" raw_val="exists_and_left" val="exists_and_left" full_name="exists_and_left" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(221, 22)" end="(221, 23)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(222, 5)" end="(222, 16)" kind="Lean.Parser.Tactic.constructor" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;b : β&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ f 0 x ⋯ = b ∧ (l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯) = l₂ ↔&#10;    ∃ a l₁ h, f 0 a ⋯ = b ∧ (l₁.mapFinIdx fun i a_1 h_1 =&amp;gt; f (i + 1) a_1 ⋯) = l₂" state_after="case cons.mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;b : β&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ f 0 x ⋯ = b ∧ (l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯) = l₂ →&#10;    ∃ a l₁ h, f 0 a ⋯ = b ∧ (l₁.mapFinIdx fun i a_1 h_1 =&amp;gt; f (i + 1) a_1 ⋯) = l₂&#10;&#10;case cons.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;b : β&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ (∃ a l₁ h, f 0 a ⋯ = b ∧ (l₁.mapFinIdx fun i a_1 h_1 =&amp;gt; f (i + 1) a_1 ⋯) = l₂) →&#10;    f 0 x ⋯ = b ∧ (l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯) = l₂" tactic="constructor">
                                      <AtomNode start="(222, 5)" end="(222, 16)" leading="" trailing="&#10;    " val="constructor"/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(223, 5)" end="(224, 42)" kind="Lean.cdot" state_before="case cons.mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;b : β&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ f 0 x ⋯ = b ∧ (l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯) = l₂ →&#10;    ∃ a l₁ h, f 0 a ⋯ = b ∧ (l₁.mapFinIdx fun i a_1 h_1 =&amp;gt; f (i + 1) a_1 ⋯) = l₂&#10;&#10;case cons.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;b : β&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ (∃ a l₁ h, f 0 a ⋯ = b ∧ (l₁.mapFinIdx fun i a_1 h_1 =&amp;gt; f (i + 1) a_1 ⋯) = l₂) →&#10;    f 0 x ⋯ = b ∧ (l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯) = l₂" state_after="case cons.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;b : β&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ (∃ a l₁ h, f 0 a ⋯ = b ∧ (l₁.mapFinIdx fun i a_1 h_1 =&amp;gt; f (i + 1) a_1 ⋯) = l₂) →&#10;    f 0 x ⋯ = b ∧ (l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯) = l₂" tactic="· rintro ⟨rfl, rfl⟩&#10;  refine ⟨x, l', ⟨rfl, rfl⟩, by simp⟩">
                                      <OtherNode start="(223, 5)" end="(223, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(223, 5)" end="(223, 6)" kind="patternIgnore">
                                          <OtherNode start="(223, 5)" end="(223, 6)" kind="token.«· »">
                                            <AtomNode start="(223, 5)" end="(223, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(223, 7)" end="(224, 42)">
                                        <TacticTacticseq1IndentedNode start="(223, 7)" end="(224, 42)">
                                          <NullNode start="(223, 7)" end="(224, 42)">
                                            <OtherNode start="(223, 7)" end="(223, 24)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;b : β&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ f 0 x ⋯ = b ∧ (l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯) = l₂ →&#10;    ∃ a l₁ h, f 0 a ⋯ = b ∧ (l₁.mapFinIdx fun i a_1 h_1 =&amp;gt; f (i + 1) a_1 ⋯) = l₂" state_after="case cons.mp.intro&#10;α : Type u_1&#10;β : Type u_2&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ ∃ a l₁ h,&#10;    f 0 a ⋯ = f 0 x ⋯ ∧ (l₁.mapFinIdx fun i a_1 h_1 =&amp;gt; f (i + 1) a_1 ⋯) = l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯" tactic="rintro ⟨rfl, rfl⟩">
                                              <AtomNode start="(223, 7)" end="(223, 13)" leading="" trailing=" " val="rintro"/>
                                              <NullNode start="(223, 14)" end="(223, 24)">
                                                <OtherNode start="(223, 14)" end="(223, 24)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                  <OtherNode start="(223, 14)" end="(223, 24)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                    <AtomNode start="(223, 14)" end="(223, 15)" leading="" trailing="" val="⟨"/>
                                                    <NullNode start="(223, 15)" end="(223, 23)">
                                                      <OtherNode start="(223, 15)" end="(223, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(223, 15)" end="(223, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(223, 15)" end="(223, 18)">
                                                            <OtherNode start="(223, 15)" end="(223, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(223, 15)" end="(223, 18)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(223, 18)" end="(223, 19)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(223, 20)" end="(223, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(223, 20)" end="(223, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(223, 20)" end="(223, 23)">
                                                            <OtherNode start="(223, 20)" end="(223, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(223, 20)" end="(223, 23)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(223, 23)" end="(223, 24)" leading="" trailing="&#10;      " val="⟩"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(224, 7)" end="(224, 42)" kind="Lean.Parser.Tactic.refine" state_before="case cons.mp.intro&#10;α : Type u_1&#10;β : Type u_2&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ ∃ a l₁ h,&#10;    f 0 a ⋯ = f 0 x ⋯ ∧ (l₁.mapFinIdx fun i a_1 h_1 =&amp;gt; f (i + 1) a_1 ⋯) = l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯" state_after="no goals" tactic="refine ⟨x, l', ⟨rfl, rfl⟩, by simp⟩">
                                              <AtomNode start="(224, 7)" end="(224, 13)" leading="" trailing=" " val="refine"/>
                                              <OtherNode start="(224, 14)" end="(224, 42)" kind="Lean.Parser.Term.anonymousCtor">
                                                <AtomNode start="(224, 14)" end="(224, 15)" leading="" trailing="" val="⟨"/>
                                                <NullNode start="(224, 15)" end="(224, 41)">
                                                  <IdentNode start="(224, 15)" end="(224, 16)" leading="" trailing="" raw_val="x" val="x"/>
                                                  <AtomNode start="(224, 16)" end="(224, 17)" leading="" trailing=" " val=","/>
                                                  <IdentNode start="(224, 18)" end="(224, 20)" leading="" trailing="" raw_val="l'" val="l'"/>
                                                  <AtomNode start="(224, 20)" end="(224, 21)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(224, 22)" end="(224, 32)" kind="Lean.Parser.Term.anonymousCtor">
                                                    <AtomNode start="(224, 22)" end="(224, 23)" leading="" trailing="" val="⟨"/>
                                                    <NullNode start="(224, 23)" end="(224, 31)">
                                                      <IdentNode start="(224, 23)" end="(224, 26)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                      <AtomNode start="(224, 26)" end="(224, 27)" leading="" trailing=" " val=","/>
                                                      <IdentNode start="(224, 28)" end="(224, 31)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                    </NullNode>
                                                    <AtomNode start="(224, 31)" end="(224, 32)" leading="" trailing="" val="⟩"/>
                                                  </OtherNode>
                                                  <AtomNode start="(224, 32)" end="(224, 33)" leading="" trailing=" " val=","/>
                                                  <TermBytacticNode start="(224, 34)" end="(224, 41)">
                                                    <AtomNode start="(224, 34)" end="(224, 36)" leading="" trailing=" " val="by"/>
                                                    <TacticTacticseqNode start="(224, 37)" end="(224, 41)">
                                                      <TacticTacticseq1IndentedNode start="(224, 37)" end="(224, 41)">
                                                        <NullNode start="(224, 37)" end="(224, 41)">
                                                          <OtherNode start="(224, 37)" end="(224, 41)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ f 0 x ⋯ = f 0 x ⋯ ∧ (l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯) = l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(224, 37)" end="(224, 41)" leading="" trailing="" val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </TermBytacticNode>
                                                </NullNode>
                                                <AtomNode start="(224, 41)" end="(224, 42)" leading="" trailing="&#10;    " val="⟩"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(225, 5)" end="(226, 27)" kind="Lean.cdot" state_before="case cons.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;b : β&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ (∃ a l₁ h, f 0 a ⋯ = b ∧ (l₁.mapFinIdx fun i a_1 h_1 =&amp;gt; f (i + 1) a_1 ⋯) = l₂) →&#10;    f 0 x ⋯ = b ∧ (l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯) = l₂" state_after="no goals" tactic="· rintro ⟨a, l', ⟨rfl, rfl⟩, ⟨rfl, rfl⟩⟩&#10;  exact ⟨rfl, by simp⟩">
                                      <OtherNode start="(225, 5)" end="(225, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(225, 5)" end="(225, 6)" kind="patternIgnore">
                                          <OtherNode start="(225, 5)" end="(225, 6)" kind="token.«· »">
                                            <AtomNode start="(225, 5)" end="(225, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(225, 7)" end="(226, 27)">
                                        <TacticTacticseq1IndentedNode start="(225, 7)" end="(226, 27)">
                                          <NullNode start="(225, 7)" end="(226, 27)">
                                            <OtherNode start="(225, 7)" end="(225, 45)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;b : β&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ (∃ a l₁ h, f 0 a ⋯ = b ∧ (l₁.mapFinIdx fun i a_1 h_1 =&amp;gt; f (i + 1) a_1 ⋯) = l₂) →&#10;    f 0 x ⋯ = b ∧ (l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯) = l₂" state_after="case cons.mpr.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ f 0 x ⋯ = f 0 x ⋯ ∧ (l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯) = l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯" tactic="rintro ⟨a, l', ⟨rfl, rfl⟩, ⟨rfl, rfl⟩⟩">
                                              <AtomNode start="(225, 7)" end="(225, 13)" leading="" trailing=" " val="rintro"/>
                                              <NullNode start="(225, 14)" end="(225, 45)">
                                                <OtherNode start="(225, 14)" end="(225, 45)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                  <OtherNode start="(225, 14)" end="(225, 45)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                    <AtomNode start="(225, 14)" end="(225, 15)" leading="" trailing="" val="⟨"/>
                                                    <NullNode start="(225, 15)" end="(225, 44)">
                                                      <OtherNode start="(225, 15)" end="(225, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(225, 15)" end="(225, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(225, 15)" end="(225, 16)">
                                                            <OtherNode start="(225, 15)" end="(225, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(225, 15)" end="(225, 16)" leading="" trailing="" raw_val="a" val="a"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(225, 16)" end="(225, 17)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(225, 18)" end="(225, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(225, 18)" end="(225, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(225, 18)" end="(225, 20)">
                                                            <OtherNode start="(225, 18)" end="(225, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(225, 18)" end="(225, 20)" leading="" trailing="" raw_val="l'" val="l'"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(225, 20)" end="(225, 21)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(225, 22)" end="(225, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(225, 22)" end="(225, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(225, 22)" end="(225, 32)">
                                                            <OtherNode start="(225, 22)" end="(225, 32)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(225, 22)" end="(225, 23)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(225, 23)" end="(225, 31)">
                                                            <OtherNode start="(225, 23)" end="(225, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(225, 23)" end="(225, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(225, 23)" end="(225, 26)">
                                                            <OtherNode start="(225, 23)" end="(225, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(225, 23)" end="(225, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(225, 26)" end="(225, 27)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(225, 28)" end="(225, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(225, 28)" end="(225, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(225, 28)" end="(225, 31)">
                                                            <OtherNode start="(225, 28)" end="(225, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(225, 28)" end="(225, 31)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(225, 31)" end="(225, 32)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <AtomNode start="(225, 32)" end="(225, 33)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(225, 34)" end="(225, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                        <OtherNode start="(225, 34)" end="(225, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(225, 34)" end="(225, 44)">
                                                            <OtherNode start="(225, 34)" end="(225, 44)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(225, 34)" end="(225, 35)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(225, 35)" end="(225, 43)">
                                                            <OtherNode start="(225, 35)" end="(225, 38)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(225, 35)" end="(225, 38)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(225, 35)" end="(225, 38)">
                                                            <OtherNode start="(225, 35)" end="(225, 38)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(225, 35)" end="(225, 38)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(225, 38)" end="(225, 39)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(225, 40)" end="(225, 43)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(225, 40)" end="(225, 43)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(225, 40)" end="(225, 43)">
                                                            <OtherNode start="(225, 40)" end="(225, 43)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(225, 40)" end="(225, 43)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(225, 43)" end="(225, 44)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(225, 44)" end="(225, 45)" leading="" trailing="&#10;      " val="⟩"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(226, 7)" end="(226, 27)" kind="Lean.Parser.Tactic.exact" state_before="case cons.mpr.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ f 0 x ⋯ = f 0 x ⋯ ∧ (l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯) = l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯" state_after="no goals" tactic="exact ⟨rfl, by simp⟩">
                                              <AtomNode start="(226, 7)" end="(226, 12)" leading="" trailing=" " val="exact"/>
                                              <OtherNode start="(226, 13)" end="(226, 27)" kind="Lean.Parser.Term.anonymousCtor">
                                                <AtomNode start="(226, 13)" end="(226, 14)" leading="" trailing="" val="⟨"/>
                                                <NullNode start="(226, 14)" end="(226, 26)">
                                                  <IdentNode start="(226, 14)" end="(226, 17)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  <AtomNode start="(226, 17)" end="(226, 18)" leading="" trailing=" " val=","/>
                                                  <TermBytacticNode start="(226, 19)" end="(226, 26)">
                                                    <AtomNode start="(226, 19)" end="(226, 21)" leading="" trailing=" " val="by"/>
                                                    <TacticTacticseqNode start="(226, 22)" end="(226, 26)">
                                                      <TacticTacticseq1IndentedNode start="(226, 22)" end="(226, 26)">
                                                        <NullNode start="(226, 22)" end="(226, 26)">
                                                          <OtherNode start="(226, 22)" end="(226, 26)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;x : α&#10;l' : List α&#10;f : (i : Nat) → α → i &amp;lt; (x :: l').length → β&#10;⊢ (l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯) = l'.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(226, 22)" end="(226, 26)" leading="" trailing="" val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </TermBytacticNode>
                                                </NullNode>
                                                <AtomNode start="(226, 26)" end="(226, 27)" leading="" trailing="&#10;&#10;" val="⟩"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(228, 1)" end="(232, 19)" name="mapFinIdx_eq_cons_iff'" full_name="List.mapFinIdx_eq_cons_iff'">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(228, 1)" end="(232, 19)" name="mapFinIdx_eq_cons_iff'" full_name="List.mapFinIdx_eq_cons_iff'" _is_private_decl="False">
        <AtomNode start="(228, 1)" end="(228, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(228, 9)" end="(228, 31)">
          <IdentNode start="(228, 9)" end="(228, 31)" leading="" trailing=" " raw_val="mapFinIdx_eq_cons_iff'" val="mapFinIdx_eq_cons_iff'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(228, 32)" end="(231, 116)">
          <NullNode start="(228, 32)" end="(228, 97)">
            <OtherNode start="(228, 32)" end="(228, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(228, 32)" end="(228, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(228, 33)" end="(228, 34)">
                <IdentNode start="(228, 33)" end="(228, 34)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(228, 35)" end="(228, 43)">
                <AtomNode start="(228, 35)" end="(228, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(228, 37)" end="(228, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(228, 37)" end="(228, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(228, 42)" end="(228, 43)">
                    <IdentNode start="(228, 42)" end="(228, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(228, 43)" end="(228, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(228, 45)" end="(228, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(228, 45)" end="(228, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(228, 46)" end="(228, 47)">
                <IdentNode start="(228, 46)" end="(228, 47)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(228, 48)" end="(228, 51)">
                <AtomNode start="(228, 48)" end="(228, 49)" leading="" trailing=" " val=":"/>
                <IdentNode start="(228, 50)" end="(228, 51)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(228, 51)" end="(228, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(228, 53)" end="(228, 97)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(228, 53)" end="(228, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(228, 54)" end="(228, 55)">
                <IdentNode start="(228, 54)" end="(228, 55)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(228, 56)" end="(228, 96)">
                <AtomNode start="(228, 56)" end="(228, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(228, 58)" end="(228, 96)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(228, 58)" end="(228, 67)">
                    <AtomNode start="(228, 58)" end="(228, 59)" leading="" trailing="" val="("/>
                    <NullNode start="(228, 59)" end="(228, 60)">
                      <IdentNode start="(228, 59)" end="(228, 60)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(228, 61)" end="(228, 66)">
                      <AtomNode start="(228, 61)" end="(228, 62)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(228, 63)" end="(228, 66)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(228, 66)" end="(228, 67)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(228, 68)" end="(228, 69)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(228, 70)" end="(228, 96)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(228, 70)" end="(228, 71)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(228, 72)" end="(228, 73)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(228, 74)" end="(228, 96)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(228, 74)" end="(228, 92)">
                        <AtomNode start="(228, 74)" end="(228, 75)" leading="" trailing="" val="("/>
                        <NullNode start="(228, 75)" end="(228, 76)">
                          <IdentNode start="(228, 75)" end="(228, 76)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(228, 77)" end="(228, 91)">
                          <AtomNode start="(228, 77)" end="(228, 78)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(228, 79)" end="(228, 91)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(228, 79)" end="(228, 80)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(228, 81)" end="(228, 82)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(228, 83)" end="(228, 91)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(228, 91)" end="(228, 92)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(228, 93)" end="(228, 94)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(228, 95)" end="(228, 96)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(228, 96)" end="(228, 97)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(228, 98)" end="(231, 116)">
            <AtomNode start="(228, 98)" end="(228, 99)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(229, 5)" end="(231, 116)" kind="«term_↔_»">
              <OtherNode start="(229, 5)" end="(229, 28)" kind="«term_=_»">
                <OtherNode start="(229, 5)" end="(229, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(229, 5)" end="(229, 16)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                  <NullNode start="(229, 17)" end="(229, 18)">
                    <IdentNode start="(229, 17)" end="(229, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(229, 19)" end="(229, 20)" leading="" trailing=" " val="="/>
                <OtherNode start="(229, 21)" end="(229, 28)" kind="«term_::_»">
                  <IdentNode start="(229, 21)" end="(229, 22)" leading="" trailing=" " raw_val="b" val="b"/>
                  <AtomNode start="(229, 23)" end="(229, 25)" leading="" trailing=" " val="::"/>
                  <IdentNode start="(229, 26)" end="(229, 28)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(229, 29)" end="(229, 30)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(230, 7)" end="(231, 116)" kind="«term_∧_»">
                <OtherNode start="(230, 7)" end="(230, 81)" kind="«term_=_»">
                  <OtherNode start="(230, 7)" end="(230, 72)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(230, 7)" end="(230, 20)" leading="" trailing=" " raw_val="l.head?.pbind" val="l.head?.pbind"/>
                    <NullNode start="(230, 21)" end="(230, 72)">
                      <OtherNode start="(230, 21)" end="(230, 72)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(230, 21)" end="(230, 22)" leading="" trailing="" val="("/>
                        <OtherNode start="(230, 22)" end="(230, 71)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(230, 22)" end="(230, 25)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(230, 26)" end="(230, 71)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(230, 26)" end="(230, 29)">
                              <IdentNode start="(230, 26)" end="(230, 27)" leading="" trailing=" " raw_val="x" val="x"/>
                              <IdentNode start="(230, 28)" end="(230, 29)" leading="" trailing=" " raw_val="m" val="m"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(230, 30)" end="(230, 32)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(230, 33)" end="(230, 71)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(230, 33)" end="(230, 37)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(230, 38)" end="(230, 71)">
                                <OtherNode start="(230, 38)" end="(230, 71)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(230, 38)" end="(230, 39)" leading="" trailing="" val="("/>
                                  <OtherNode start="(230, 39)" end="(230, 70)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(230, 39)" end="(230, 40)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <NullNode start="(230, 41)" end="(230, 70)">
                                      <OtherNode start="(230, 41)" end="(230, 42)" kind="num">
                                        <AtomNode start="(230, 41)" end="(230, 42)" leading="" trailing=" " val="0"/>
                                      </OtherNode>
                                      <IdentNode start="(230, 43)" end="(230, 44)" leading="" trailing=" " raw_val="x" val="x"/>
                                      <OtherNode start="(230, 45)" end="(230, 70)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(230, 45)" end="(230, 46)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(230, 46)" end="(230, 69)">
                                          <AtomNode start="(230, 46)" end="(230, 48)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(230, 49)" end="(230, 69)">
                                            <TacticTacticseq1IndentedNode start="(230, 49)" end="(230, 69)">
                                              <NullNode start="(230, 49)" end="(230, 69)">
                                                <OtherNode start="(230, 49)" end="(230, 69)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type ?u.37179&#10;β : Type ?u.37203&#10;l₂ : List β&#10;l : List α&#10;b : β&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;x : α&#10;m : l.head? = some x&#10;⊢ 0 &amp;lt; l.length" state_after="no goals" tactic="cases l &amp;lt;;&amp;gt; simp_all">
                                                  <OtherNode start="(230, 49)" end="(230, 56)" kind="Lean.Parser.Tactic.cases">
                                                    <AtomNode start="(230, 49)" end="(230, 54)" leading="" trailing=" " val="cases"/>
                                                    <NullNode start="(230, 55)" end="(230, 56)">
                                                      <OtherNode start="(230, 55)" end="(230, 56)" kind="Lean.Parser.Tactic.elimTarget">
                                                        <NullNode/>
                                                        <IdentNode start="(230, 55)" end="(230, 56)" leading="" trailing=" " raw_val="l" val="l"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(230, 57)" end="(230, 60)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                  <OtherNode start="(230, 61)" end="(230, 69)" kind="Lean.Parser.Tactic.simpAll">
                                                    <AtomNode start="(230, 61)" end="(230, 69)" leading="" trailing="" val="simp_all"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(230, 69)" end="(230, 70)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(230, 70)" end="(230, 71)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(230, 71)" end="(230, 72)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(230, 73)" end="(230, 74)" leading="" trailing=" " val="="/>
                  <OtherNode start="(230, 75)" end="(230, 81)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(230, 75)" end="(230, 79)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(230, 80)" end="(230, 81)">
                      <IdentNode start="(230, 80)" end="(230, 81)" leading="" trailing=" " raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(230, 82)" end="(230, 83)" leading="" trailing="&#10;        " val="∧"/>
                <OtherNode start="(231, 9)" end="(231, 116)" kind="«term_=_»">
                  <OtherNode start="(231, 9)" end="(231, 106)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(231, 9)" end="(231, 27)" leading="" trailing=" " raw_val="l.tail?.attach.map" val="l.tail?.attach.map"/>
                    <NullNode start="(231, 28)" end="(231, 106)">
                      <OtherNode start="(231, 28)" end="(231, 106)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(231, 28)" end="(231, 29)" leading="" trailing="" val="("/>
                        <OtherNode start="(231, 29)" end="(231, 105)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(231, 29)" end="(231, 32)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(231, 33)" end="(231, 105)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(231, 33)" end="(231, 39)">
                              <OtherNode start="(231, 33)" end="(231, 39)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(231, 33)" end="(231, 34)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(231, 34)" end="(231, 38)">
                                  <IdentNode start="(231, 34)" end="(231, 35)" leading="" trailing="" raw_val="t" val="t"/>
                                  <AtomNode start="(231, 35)" end="(231, 36)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(231, 37)" end="(231, 38)" leading="" trailing="" raw_val="m" val="m"/>
                                </NullNode>
                                <AtomNode start="(231, 38)" end="(231, 39)" leading="" trailing=" " val="⟩"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(231, 40)" end="(231, 42)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(231, 43)" end="(231, 105)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(231, 43)" end="(231, 54)" leading="" trailing=" " raw_val="t.mapFinIdx" val="t.mapFinIdx"/>
                              <NullNode start="(231, 55)" end="(231, 105)">
                                <OtherNode start="(231, 55)" end="(231, 105)" kind="Lean.Parser.Term.fun">
                                  <AtomNode start="(231, 55)" end="(231, 58)" leading="" trailing=" " val="fun"/>
                                  <OtherNode start="(231, 59)" end="(231, 105)" kind="Lean.Parser.Term.basicFun">
                                    <NullNode start="(231, 59)" end="(231, 64)">
                                      <IdentNode start="(231, 59)" end="(231, 60)" leading="" trailing=" " raw_val="i" val="i"/>
                                      <IdentNode start="(231, 61)" end="(231, 62)" leading="" trailing=" " raw_val="a" val="a"/>
                                      <IdentNode start="(231, 63)" end="(231, 64)" leading="" trailing=" " raw_val="h" val="h"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(231, 65)" end="(231, 67)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <OtherNode start="(231, 68)" end="(231, 105)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(231, 68)" end="(231, 69)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(231, 70)" end="(231, 105)">
                                        <OtherNode start="(231, 70)" end="(231, 77)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(231, 70)" end="(231, 71)" leading="" trailing="" val="("/>
                                          <OtherNode start="(231, 71)" end="(231, 76)" kind="«term_+_»">
                                            <IdentNode start="(231, 71)" end="(231, 72)" leading="" trailing=" " raw_val="i" val="i"/>
                                            <AtomNode start="(231, 73)" end="(231, 74)" leading="" trailing=" " val="+"/>
                                            <OtherNode start="(231, 75)" end="(231, 76)" kind="num">
                                              <AtomNode start="(231, 75)" end="(231, 76)" leading="" trailing="" val="1"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(231, 76)" end="(231, 77)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                        <IdentNode start="(231, 78)" end="(231, 79)" leading="" trailing=" " raw_val="a" val="a"/>
                                        <OtherNode start="(231, 80)" end="(231, 105)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(231, 80)" end="(231, 81)" leading="" trailing="" val="("/>
                                          <TermBytacticNode start="(231, 81)" end="(231, 104)">
                                            <AtomNode start="(231, 81)" end="(231, 83)" leading="" trailing=" " val="by"/>
                                            <TacticTacticseqNode start="(231, 84)" end="(231, 104)">
                                              <TacticTacticseq1IndentedNode start="(231, 84)" end="(231, 104)">
                                                <NullNode start="(231, 84)" end="(231, 104)">
                                                  <OtherNode start="(231, 84)" end="(231, 104)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type ?u.37179&#10;β : Type ?u.37203&#10;l₂ : List β&#10;l : List α&#10;b : β&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;x✝ : { x // l.tail? = some x }&#10;t : List α&#10;m : l.tail? = some t&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; t.length&#10;⊢ i + 1 &amp;lt; l.length" state_after="no goals" tactic="cases l &amp;lt;;&amp;gt; simp_all">
                                                    <OtherNode start="(231, 84)" end="(231, 91)" kind="Lean.Parser.Tactic.cases">
                                                      <AtomNode start="(231, 84)" end="(231, 89)" leading="" trailing=" " val="cases"/>
                                                      <NullNode start="(231, 90)" end="(231, 91)">
                                                        <OtherNode start="(231, 90)" end="(231, 91)" kind="Lean.Parser.Tactic.elimTarget">
                                                          <NullNode/>
                                                          <IdentNode start="(231, 90)" end="(231, 91)" leading="" trailing=" " raw_val="l" val="l"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <AtomNode start="(231, 92)" end="(231, 95)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                    <OtherNode start="(231, 96)" end="(231, 104)" kind="Lean.Parser.Tactic.simpAll">
                                                      <AtomNode start="(231, 96)" end="(231, 104)" leading="" trailing="" val="simp_all"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </TermBytacticNode>
                                          <AtomNode start="(231, 104)" end="(231, 105)" leading="" trailing="" val=")"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(231, 105)" end="(231, 106)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(231, 107)" end="(231, 108)" leading="" trailing=" " val="="/>
                  <OtherNode start="(231, 109)" end="(231, 116)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(231, 109)" end="(231, 113)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(231, 114)" end="(231, 116)">
                      <IdentNode start="(231, 114)" end="(231, 116)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(231, 117)" end="(232, 19)">
          <AtomNode start="(231, 117)" end="(231, 119)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(231, 120)" end="(232, 19)">
            <AtomNode start="(231, 120)" end="(231, 122)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(232, 3)" end="(232, 19)">
              <TacticTacticseq1IndentedNode start="(232, 3)" end="(232, 19)">
                <NullNode start="(232, 3)" end="(232, 19)">
                  <OtherNode start="(232, 3)" end="(232, 19)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;l₂ : List β&#10;l : List α&#10;b : β&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ l.mapFinIdx f = b :: l₂ ↔&#10;    (l.head?.pbind fun x m =&amp;gt; some (f 0 x ⋯)) = some b ∧&#10;      Option.map&#10;          (fun x =&amp;gt;&#10;            match x with&#10;            | ⟨t, m⟩ =&amp;gt; t.mapFinIdx fun i a h =&amp;gt; f (i + 1) a ⋯)&#10;          l.tail?.attach =&#10;        some l₂" state_after="no goals" tactic="cases l &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(232, 3)" end="(232, 10)" kind="Lean.Parser.Tactic.cases">
                      <AtomNode start="(232, 3)" end="(232, 8)" leading="" trailing=" " val="cases"/>
                      <NullNode start="(232, 9)" end="(232, 10)">
                        <OtherNode start="(232, 9)" end="(232, 10)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(232, 9)" end="(232, 10)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(232, 11)" end="(232, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(232, 15)" end="(232, 19)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(232, 15)" end="(232, 19)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(234, 1)" end="(240, 35)" name="mapFinIdx_eq_iff" full_name="List.mapFinIdx_eq_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(234, 1)" end="(240, 35)" name="mapFinIdx_eq_iff" full_name="List.mapFinIdx_eq_iff" _is_private_decl="False">
        <AtomNode start="(234, 1)" end="(234, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(234, 9)" end="(234, 25)">
          <IdentNode start="(234, 9)" end="(234, 25)" leading="" trailing=" " raw_val="mapFinIdx_eq_iff" val="mapFinIdx_eq_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(234, 26)" end="(235, 104)">
          <NullNode start="(234, 26)" end="(234, 83)">
            <OtherNode start="(234, 26)" end="(234, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(234, 26)" end="(234, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(234, 27)" end="(234, 28)">
                <IdentNode start="(234, 27)" end="(234, 28)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(234, 29)" end="(234, 37)">
                <AtomNode start="(234, 29)" end="(234, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(234, 31)" end="(234, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(234, 31)" end="(234, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(234, 36)" end="(234, 37)">
                    <IdentNode start="(234, 36)" end="(234, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(234, 37)" end="(234, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(234, 39)" end="(234, 83)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(234, 39)" end="(234, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(234, 40)" end="(234, 41)">
                <IdentNode start="(234, 40)" end="(234, 41)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(234, 42)" end="(234, 82)">
                <AtomNode start="(234, 42)" end="(234, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(234, 44)" end="(234, 82)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(234, 44)" end="(234, 53)">
                    <AtomNode start="(234, 44)" end="(234, 45)" leading="" trailing="" val="("/>
                    <NullNode start="(234, 45)" end="(234, 46)">
                      <IdentNode start="(234, 45)" end="(234, 46)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(234, 47)" end="(234, 52)">
                      <AtomNode start="(234, 47)" end="(234, 48)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(234, 49)" end="(234, 52)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(234, 52)" end="(234, 53)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(234, 54)" end="(234, 55)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(234, 56)" end="(234, 82)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(234, 56)" end="(234, 57)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(234, 58)" end="(234, 59)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(234, 60)" end="(234, 82)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(234, 60)" end="(234, 78)">
                        <AtomNode start="(234, 60)" end="(234, 61)" leading="" trailing="" val="("/>
                        <NullNode start="(234, 61)" end="(234, 62)">
                          <IdentNode start="(234, 61)" end="(234, 62)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(234, 63)" end="(234, 77)">
                          <AtomNode start="(234, 63)" end="(234, 64)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(234, 65)" end="(234, 77)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(234, 65)" end="(234, 66)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(234, 67)" end="(234, 68)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(234, 69)" end="(234, 77)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(234, 77)" end="(234, 78)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(234, 79)" end="(234, 80)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(234, 81)" end="(234, 82)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(234, 82)" end="(234, 83)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(234, 84)" end="(235, 104)">
            <AtomNode start="(234, 84)" end="(234, 85)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(235, 5)" end="(235, 104)" kind="«term_↔_»">
              <OtherNode start="(235, 5)" end="(235, 23)" kind="«term_=_»">
                <OtherNode start="(235, 5)" end="(235, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(235, 5)" end="(235, 16)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                  <NullNode start="(235, 17)" end="(235, 18)">
                    <IdentNode start="(235, 17)" end="(235, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(235, 19)" end="(235, 20)" leading="" trailing=" " val="="/>
                <IdentNode start="(235, 21)" end="(235, 23)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </OtherNode>
              <AtomNode start="(235, 24)" end="(235, 25)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(235, 26)" end="(235, 104)" kind="«term∃_,_»">
                <AtomNode start="(235, 26)" end="(235, 27)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(235, 28)" end="(235, 52)" kind="Lean.explicitBinders">
                  <OtherNode start="(235, 28)" end="(235, 52)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(235, 28)" end="(235, 29)">
                      <LeanBinderidentNode start="(235, 28)" end="(235, 29)">
                        <IdentNode start="(235, 28)" end="(235, 29)" leading="" trailing=" " raw_val="h" val="h"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode start="(235, 30)" end="(235, 52)">
                      <AtomNode start="(235, 30)" end="(235, 31)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(235, 32)" end="(235, 52)" kind="«term_=_»">
                        <IdentNode start="(235, 32)" end="(235, 41)" leading="" trailing=" " raw_val="l'.length" val="l'.length"/>
                        <AtomNode start="(235, 42)" end="(235, 43)" leading="" trailing=" " val="="/>
                        <IdentNode start="(235, 44)" end="(235, 52)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(235, 52)" end="(235, 53)" leading="" trailing=" " val=","/>
                <OtherNode start="(235, 54)" end="(235, 104)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(235, 54)" end="(235, 55)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(235, 56)" end="(235, 84)">
                    <TermExplicitbinderNode start="(235, 56)" end="(235, 65)">
                      <AtomNode start="(235, 56)" end="(235, 57)" leading="" trailing="" val="("/>
                      <NullNode start="(235, 57)" end="(235, 58)">
                        <IdentNode start="(235, 57)" end="(235, 58)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                      <NullNode start="(235, 59)" end="(235, 64)">
                        <AtomNode start="(235, 59)" end="(235, 60)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(235, 61)" end="(235, 64)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(235, 64)" end="(235, 65)" leading="" trailing=" " val=")"/>
                    </TermExplicitbinderNode>
                    <TermExplicitbinderNode start="(235, 66)" end="(235, 84)">
                      <AtomNode start="(235, 66)" end="(235, 67)" leading="" trailing="" val="("/>
                      <NullNode start="(235, 67)" end="(235, 68)">
                        <IdentNode start="(235, 67)" end="(235, 68)" leading="" trailing=" " raw_val="h" val="h"/>
                      </NullNode>
                      <NullNode start="(235, 69)" end="(235, 83)">
                        <AtomNode start="(235, 69)" end="(235, 70)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(235, 71)" end="(235, 83)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(235, 71)" end="(235, 72)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(235, 73)" end="(235, 74)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(235, 75)" end="(235, 83)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(235, 83)" end="(235, 84)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(235, 84)" end="(235, 85)" leading="" trailing=" " val=","/>
                  <OtherNode start="(235, 86)" end="(235, 104)" kind="«term_=_»">
                    <OtherNode start="(235, 86)" end="(235, 91)" kind="«term__[_]»">
                      <IdentNode start="(235, 86)" end="(235, 88)" leading="" trailing="" raw_val="l'" val="l'"/>
                      <AtomNode start="(235, 88)" end="(235, 89)" leading="" trailing="" val="["/>
                      <IdentNode start="(235, 89)" end="(235, 90)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(235, 90)" end="(235, 91)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <AtomNode start="(235, 92)" end="(235, 93)" leading="" trailing=" " val="="/>
                    <OtherNode start="(235, 94)" end="(235, 104)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(235, 94)" end="(235, 95)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(235, 96)" end="(235, 104)">
                        <IdentNode start="(235, 96)" end="(235, 97)" leading="" trailing=" " raw_val="i" val="i"/>
                        <OtherNode start="(235, 98)" end="(235, 102)" kind="«term__[_]»">
                          <IdentNode start="(235, 98)" end="(235, 99)" leading="" trailing="" raw_val="l" val="l"/>
                          <AtomNode start="(235, 99)" end="(235, 100)" leading="" trailing="" val="["/>
                          <IdentNode start="(235, 100)" end="(235, 101)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(235, 101)" end="(235, 102)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                        <IdentNode start="(235, 103)" end="(235, 104)" leading="" trailing=" " raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(235, 105)" end="(240, 35)">
          <AtomNode start="(235, 105)" end="(235, 107)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(235, 108)" end="(240, 35)">
            <AtomNode start="(235, 108)" end="(235, 110)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(236, 3)" end="(240, 35)">
              <TacticTacticseq1IndentedNode start="(236, 3)" end="(240, 35)">
                <NullNode start="(236, 3)" end="(240, 35)">
                  <OtherNode start="(236, 3)" end="(236, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;β : Type u_2&#10;l' : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ l.mapFinIdx f = l' ↔ ∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), l'[i] = f i l[i] h_1" state_after="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l' : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ l.mapFinIdx f = l' → ∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), l'[i] = f i l[i] h_1&#10;&#10;case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l' : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), l'[i] = f i l[i] h_1) → l.mapFinIdx f = l'" tactic="constructor">
                    <AtomNode start="(236, 3)" end="(236, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(237, 3)" end="(238, 9)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l' : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ l.mapFinIdx f = l' → ∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), l'[i] = f i l[i] h_1&#10;&#10;case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l' : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), l'[i] = f i l[i] h_1) → l.mapFinIdx f = l'" state_after="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l' : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), l'[i] = f i l[i] h_1) → l.mapFinIdx f = l'" tactic="· rintro rfl&#10;  simp">
                    <OtherNode start="(237, 3)" end="(237, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(237, 3)" end="(237, 4)" kind="patternIgnore">
                        <OtherNode start="(237, 3)" end="(237, 4)" kind="token.«· »">
                          <AtomNode start="(237, 3)" end="(237, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(237, 5)" end="(238, 9)">
                      <TacticTacticseq1IndentedNode start="(237, 5)" end="(238, 9)">
                        <NullNode start="(237, 5)" end="(238, 9)">
                          <OtherNode start="(237, 5)" end="(237, 15)" kind="Lean.Parser.Tactic.rintro" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l' : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ l.mapFinIdx f = l' → ∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), l'[i] = f i l[i] h_1" state_after="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ ∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l.mapFinIdx f)[i] = f i l[i] h_1" tactic="rintro rfl">
                            <AtomNode start="(237, 5)" end="(237, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(237, 12)" end="(237, 15)">
                              <OtherNode start="(237, 12)" end="(237, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(237, 12)" end="(237, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(237, 12)" end="(237, 15)" leading="" trailing="&#10;    " raw_val="rfl" val="rfl"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(238, 5)" end="(238, 9)" kind="Lean.Parser.Tactic.simp" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ ∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l.mapFinIdx f)[i] = f i l[i] h_1" state_after="no goals" tactic="simp">
                            <AtomNode start="(238, 5)" end="(238, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(239, 3)" end="(240, 35)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l' : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), l'[i] = f i l[i] h_1) → l.mapFinIdx f = l'" state_after="no goals" tactic="· rintro ⟨h, w⟩&#10;  apply ext_getElem &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(239, 3)" end="(239, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(239, 3)" end="(239, 4)" kind="patternIgnore">
                        <OtherNode start="(239, 3)" end="(239, 4)" kind="token.«· »">
                          <AtomNode start="(239, 3)" end="(239, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(239, 5)" end="(240, 35)">
                      <TacticTacticseq1IndentedNode start="(239, 5)" end="(240, 35)">
                        <NullNode start="(239, 5)" end="(240, 35)">
                          <OtherNode start="(239, 5)" end="(239, 18)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l' : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), l'[i] = f i l[i] h_1) → l.mapFinIdx f = l'" state_after="case mpr.intro&#10;α : Type u_1&#10;β : Type u_2&#10;l' : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h : l'.length = l.length&#10;w : ∀ (i : Nat) (h_1 : i &amp;lt; l.length), l'[i] = f i l[i] h_1&#10;⊢ l.mapFinIdx f = l'" tactic="rintro ⟨h, w⟩">
                            <AtomNode start="(239, 5)" end="(239, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(239, 12)" end="(239, 18)">
                              <OtherNode start="(239, 12)" end="(239, 18)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(239, 12)" end="(239, 18)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(239, 12)" end="(239, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(239, 13)" end="(239, 17)">
                                    <OtherNode start="(239, 13)" end="(239, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(239, 13)" end="(239, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(239, 13)" end="(239, 14)">
                                          <OtherNode start="(239, 13)" end="(239, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(239, 13)" end="(239, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(239, 14)" end="(239, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(239, 16)" end="(239, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(239, 16)" end="(239, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(239, 16)" end="(239, 17)">
                                          <OtherNode start="(239, 16)" end="(239, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(239, 16)" end="(239, 17)" leading="" trailing="" raw_val="w" val="w"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(239, 17)" end="(239, 18)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(240, 5)" end="(240, 35)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case mpr.intro&#10;α : Type u_1&#10;β : Type u_2&#10;l' : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h : l'.length = l.length&#10;w : ∀ (i : Nat) (h_1 : i &amp;lt; l.length), l'[i] = f i l[i] h_1&#10;⊢ l.mapFinIdx f = l'" state_after="no goals" tactic="apply ext_getElem &amp;lt;;&amp;gt; simp_all">
                            <OtherNode start="(240, 5)" end="(240, 22)" kind="Lean.Parser.Tactic.apply">
                              <AtomNode start="(240, 5)" end="(240, 10)" leading="" trailing=" " val="apply"/>
                              <IdentNode start="(240, 11)" end="(240, 22)" leading="" trailing=" " raw_val="ext_getElem" val="ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                            </OtherNode>
                            <AtomNode start="(240, 23)" end="(240, 26)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(240, 27)" end="(240, 35)" kind="Lean.Parser.Tactic.simpAll">
                              <AtomNode start="(240, 27)" end="(240, 35)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(242, 1)" end="(244, 31)" name="mapFinIdx_eq_singleton_iff" full_name="List.mapFinIdx_eq_singleton_iff">
      <CommandDeclmodifiersNode start="(242, 1)" end="(242, 8)">
        <NullNode/>
        <NullNode start="(242, 1)" end="(242, 8)">
          <OtherNode start="(242, 1)" end="(242, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(242, 1)" end="(242, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(242, 3)" end="(242, 7)">
              <OtherNode start="(242, 3)" end="(242, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(242, 3)" end="(242, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(242, 3)" end="(242, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(242, 7)" end="(242, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(242, 9)" end="(244, 31)" name="mapFinIdx_eq_singleton_iff" full_name="List.mapFinIdx_eq_singleton_iff" _is_private_decl="False">
        <AtomNode start="(242, 9)" end="(242, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(242, 17)" end="(242, 43)">
          <IdentNode start="(242, 17)" end="(242, 43)" leading="" trailing=" " raw_val="mapFinIdx_eq_singleton_iff" val="mapFinIdx_eq_singleton_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(242, 44)" end="(243, 75)">
          <NullNode start="(242, 44)" end="(242, 109)">
            <OtherNode start="(242, 44)" end="(242, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(242, 44)" end="(242, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(242, 45)" end="(242, 46)">
                <IdentNode start="(242, 45)" end="(242, 46)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(242, 47)" end="(242, 55)">
                <AtomNode start="(242, 47)" end="(242, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(242, 49)" end="(242, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(242, 49)" end="(242, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(242, 54)" end="(242, 55)">
                    <IdentNode start="(242, 54)" end="(242, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(242, 55)" end="(242, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(242, 57)" end="(242, 101)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(242, 57)" end="(242, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(242, 58)" end="(242, 59)">
                <IdentNode start="(242, 58)" end="(242, 59)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(242, 60)" end="(242, 100)">
                <AtomNode start="(242, 60)" end="(242, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(242, 62)" end="(242, 100)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(242, 62)" end="(242, 71)">
                    <AtomNode start="(242, 62)" end="(242, 63)" leading="" trailing="" val="("/>
                    <NullNode start="(242, 63)" end="(242, 64)">
                      <IdentNode start="(242, 63)" end="(242, 64)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(242, 65)" end="(242, 70)">
                      <AtomNode start="(242, 65)" end="(242, 66)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(242, 67)" end="(242, 70)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(242, 70)" end="(242, 71)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(242, 72)" end="(242, 73)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(242, 74)" end="(242, 100)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(242, 74)" end="(242, 75)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(242, 76)" end="(242, 77)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(242, 78)" end="(242, 100)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(242, 78)" end="(242, 96)">
                        <AtomNode start="(242, 78)" end="(242, 79)" leading="" trailing="" val="("/>
                        <NullNode start="(242, 79)" end="(242, 80)">
                          <IdentNode start="(242, 79)" end="(242, 80)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(242, 81)" end="(242, 95)">
                          <AtomNode start="(242, 81)" end="(242, 82)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(242, 83)" end="(242, 95)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(242, 83)" end="(242, 84)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(242, 85)" end="(242, 86)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(242, 87)" end="(242, 95)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(242, 95)" end="(242, 96)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(242, 97)" end="(242, 98)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(242, 99)" end="(242, 100)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(242, 100)" end="(242, 101)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(242, 102)" end="(242, 109)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(242, 102)" end="(242, 103)" leading="" trailing="" val="{"/>
              <NullNode start="(242, 103)" end="(242, 104)">
                <IdentNode start="(242, 103)" end="(242, 104)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(242, 105)" end="(242, 108)">
                <AtomNode start="(242, 105)" end="(242, 106)" leading="" trailing=" " val=":"/>
                <IdentNode start="(242, 107)" end="(242, 108)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(242, 108)" end="(242, 109)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(242, 110)" end="(243, 75)">
            <AtomNode start="(242, 110)" end="(242, 111)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(243, 5)" end="(243, 75)" kind="«term_↔_»">
              <OtherNode start="(243, 5)" end="(243, 24)" kind="«term_=_»">
                <OtherNode start="(243, 5)" end="(243, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(243, 5)" end="(243, 16)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                  <NullNode start="(243, 17)" end="(243, 18)">
                    <IdentNode start="(243, 17)" end="(243, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(243, 19)" end="(243, 20)" leading="" trailing=" " val="="/>
                <OtherNode start="(243, 21)" end="(243, 24)" kind="«term[_]»">
                  <AtomNode start="(243, 21)" end="(243, 22)" leading="" trailing="" val="["/>
                  <NullNode start="(243, 22)" end="(243, 23)">
                    <IdentNode start="(243, 22)" end="(243, 23)" leading="" trailing="" raw_val="b" val="b"/>
                  </NullNode>
                  <AtomNode start="(243, 23)" end="(243, 24)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(243, 25)" end="(243, 26)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(243, 27)" end="(243, 75)" kind="«term∃_,_»">
                <AtomNode start="(243, 27)" end="(243, 28)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(243, 29)" end="(243, 50)" kind="Lean.explicitBinders">
                  <NullNode start="(243, 29)" end="(243, 50)">
                    <OtherNode start="(243, 29)" end="(243, 36)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(243, 29)" end="(243, 30)" leading="" trailing="" val="("/>
                      <NullNode start="(243, 30)" end="(243, 31)">
                        <LeanBinderidentNode start="(243, 30)" end="(243, 31)">
                          <IdentNode start="(243, 30)" end="(243, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(243, 32)" end="(243, 33)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(243, 34)" end="(243, 35)" leading="" trailing="" raw_val="α" val="α"/>
                      <AtomNode start="(243, 35)" end="(243, 36)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(243, 37)" end="(243, 50)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(243, 37)" end="(243, 38)" leading="" trailing="" val="("/>
                      <NullNode start="(243, 38)" end="(243, 39)">
                        <LeanBinderidentNode start="(243, 38)" end="(243, 39)">
                          <IdentNode start="(243, 38)" end="(243, 39)" leading="" trailing=" " raw_val="w" val="w"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(243, 40)" end="(243, 41)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(243, 42)" end="(243, 49)" kind="«term_=_»">
                        <IdentNode start="(243, 42)" end="(243, 43)" leading="" trailing=" " raw_val="l" val="l"/>
                        <AtomNode start="(243, 44)" end="(243, 45)" leading="" trailing=" " val="="/>
                        <OtherNode start="(243, 46)" end="(243, 49)" kind="«term[_]»">
                          <AtomNode start="(243, 46)" end="(243, 47)" leading="" trailing="" val="["/>
                          <NullNode start="(243, 47)" end="(243, 48)">
                            <IdentNode start="(243, 47)" end="(243, 48)" leading="" trailing="" raw_val="a" val="a"/>
                          </NullNode>
                          <AtomNode start="(243, 48)" end="(243, 49)" leading="" trailing="" val="]"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(243, 49)" end="(243, 50)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(243, 50)" end="(243, 51)" leading="" trailing=" " val=","/>
                <OtherNode start="(243, 52)" end="(243, 75)" kind="«term_=_»">
                  <OtherNode start="(243, 52)" end="(243, 71)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(243, 52)" end="(243, 53)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(243, 54)" end="(243, 71)">
                      <OtherNode start="(243, 54)" end="(243, 55)" kind="num">
                        <AtomNode start="(243, 54)" end="(243, 55)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                      <IdentNode start="(243, 56)" end="(243, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                      <OtherNode start="(243, 58)" end="(243, 71)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(243, 58)" end="(243, 59)" leading="" trailing="" val="("/>
                        <TermBytacticNode start="(243, 59)" end="(243, 70)">
                          <AtomNode start="(243, 59)" end="(243, 61)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(243, 62)" end="(243, 70)">
                            <TacticTacticseq1IndentedNode start="(243, 62)" end="(243, 70)">
                              <NullNode start="(243, 62)" end="(243, 70)">
                                <OtherNode start="(243, 62)" end="(243, 70)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.41719&#10;β : Type ?u.41743&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;a : α&#10;w : l = [a]&#10;⊢ 0 &amp;lt; l.length" state_after="no goals" tactic="simp [w]">
                                  <AtomNode start="(243, 62)" end="(243, 66)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(243, 67)" end="(243, 70)">
                                    <AtomNode start="(243, 67)" end="(243, 68)" leading="" trailing="" val="["/>
                                    <NullNode start="(243, 68)" end="(243, 69)">
                                      <OtherNode start="(243, 68)" end="(243, 69)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(243, 68)" end="(243, 69)" leading="" trailing="" raw_val="w" val="w"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(243, 69)" end="(243, 70)" leading="" trailing="" val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                        <AtomNode start="(243, 70)" end="(243, 71)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(243, 72)" end="(243, 73)" leading="" trailing=" " val="="/>
                  <IdentNode start="(243, 74)" end="(243, 75)" leading="" trailing=" " raw_val="b" val="b"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(243, 76)" end="(244, 31)">
          <AtomNode start="(243, 76)" end="(243, 78)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(243, 79)" end="(244, 31)">
            <AtomNode start="(243, 79)" end="(243, 81)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(244, 3)" end="(244, 31)">
              <TacticTacticseq1IndentedNode start="(244, 3)" end="(244, 31)">
                <NullNode start="(244, 3)" end="(244, 31)">
                  <OtherNode start="(244, 3)" end="(244, 31)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;⊢ l.mapFinIdx f = [b] ↔ ∃ a w, f 0 a ⋯ = b" state_after="no goals" tactic="simp [mapFinIdx_eq_cons_iff]">
                    <AtomNode start="(244, 3)" end="(244, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(244, 8)" end="(244, 31)">
                      <AtomNode start="(244, 8)" end="(244, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(244, 9)" end="(244, 30)">
                        <OtherNode start="(244, 9)" end="(244, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(244, 9)" end="(244, 30)" leading="" trailing="" raw_val="mapFinIdx_eq_cons_iff" val="mapFinIdx_eq_cons_iff" full_name="List.mapFinIdx_eq_cons_iff" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(213, 9)" def_end="(213, 30)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(244, 30)" end="(244, 31)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(246, 1)" end="(283, 43)" name="mapFinIdx_eq_append_iff" full_name="List.mapFinIdx_eq_append_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(246, 1)" end="(283, 43)" name="mapFinIdx_eq_append_iff" full_name="List.mapFinIdx_eq_append_iff" _is_private_decl="False">
        <AtomNode start="(246, 1)" end="(246, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(246, 9)" end="(246, 32)">
          <IdentNode start="(246, 9)" end="(246, 32)" leading="" trailing=" " raw_val="mapFinIdx_eq_append_iff" val="mapFinIdx_eq_append_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(246, 33)" end="(250, 84)">
          <NullNode start="(246, 33)" end="(246, 90)">
            <OtherNode start="(246, 33)" end="(246, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(246, 33)" end="(246, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(246, 34)" end="(246, 35)">
                <IdentNode start="(246, 34)" end="(246, 35)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(246, 36)" end="(246, 44)">
                <AtomNode start="(246, 36)" end="(246, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(246, 38)" end="(246, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(246, 38)" end="(246, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(246, 43)" end="(246, 44)">
                    <IdentNode start="(246, 43)" end="(246, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(246, 44)" end="(246, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(246, 46)" end="(246, 90)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(246, 46)" end="(246, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(246, 47)" end="(246, 48)">
                <IdentNode start="(246, 47)" end="(246, 48)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(246, 49)" end="(246, 89)">
                <AtomNode start="(246, 49)" end="(246, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(246, 51)" end="(246, 89)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(246, 51)" end="(246, 60)">
                    <AtomNode start="(246, 51)" end="(246, 52)" leading="" trailing="" val="("/>
                    <NullNode start="(246, 52)" end="(246, 53)">
                      <IdentNode start="(246, 52)" end="(246, 53)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(246, 54)" end="(246, 59)">
                      <AtomNode start="(246, 54)" end="(246, 55)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(246, 56)" end="(246, 59)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(246, 59)" end="(246, 60)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(246, 61)" end="(246, 62)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(246, 63)" end="(246, 89)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(246, 63)" end="(246, 64)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(246, 65)" end="(246, 66)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(246, 67)" end="(246, 89)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(246, 67)" end="(246, 85)">
                        <AtomNode start="(246, 67)" end="(246, 68)" leading="" trailing="" val="("/>
                        <NullNode start="(246, 68)" end="(246, 69)">
                          <IdentNode start="(246, 68)" end="(246, 69)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(246, 70)" end="(246, 84)">
                          <AtomNode start="(246, 70)" end="(246, 71)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(246, 72)" end="(246, 84)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(246, 72)" end="(246, 73)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(246, 74)" end="(246, 75)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(246, 76)" end="(246, 84)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(246, 84)" end="(246, 85)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(246, 86)" end="(246, 87)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(246, 88)" end="(246, 89)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(246, 89)" end="(246, 90)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(246, 91)" end="(250, 84)">
            <AtomNode start="(246, 91)" end="(246, 92)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(247, 5)" end="(250, 84)" kind="«term_↔_»">
              <OtherNode start="(247, 5)" end="(247, 29)" kind="«term_=_»">
                <OtherNode start="(247, 5)" end="(247, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(247, 5)" end="(247, 16)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                  <NullNode start="(247, 17)" end="(247, 18)">
                    <IdentNode start="(247, 17)" end="(247, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(247, 19)" end="(247, 20)" leading="" trailing=" " val="="/>
                <OtherNode start="(247, 21)" end="(247, 29)" kind="«term_++_»">
                  <IdentNode start="(247, 21)" end="(247, 23)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(247, 24)" end="(247, 26)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(247, 27)" end="(247, 29)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(247, 30)" end="(247, 31)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(248, 7)" end="(250, 84)" kind="«term∃_,_»">
                <AtomNode start="(248, 7)" end="(248, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(248, 9)" end="(248, 59)" kind="Lean.explicitBinders">
                  <NullNode start="(248, 9)" end="(248, 59)">
                    <OtherNode start="(248, 9)" end="(248, 23)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(248, 9)" end="(248, 10)" leading="" trailing="" val="("/>
                      <NullNode start="(248, 10)" end="(248, 13)">
                        <LeanBinderidentNode start="(248, 10)" end="(248, 13)">
                          <IdentNode start="(248, 10)" end="(248, 13)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(248, 14)" end="(248, 15)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(248, 16)" end="(248, 22)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(248, 16)" end="(248, 20)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(248, 21)" end="(248, 22)">
                          <IdentNode start="(248, 21)" end="(248, 22)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(248, 22)" end="(248, 23)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(248, 24)" end="(248, 38)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(248, 24)" end="(248, 25)" leading="" trailing="" val="("/>
                      <NullNode start="(248, 25)" end="(248, 28)">
                        <LeanBinderidentNode start="(248, 25)" end="(248, 28)">
                          <IdentNode start="(248, 25)" end="(248, 28)" leading="" trailing=" " raw_val="l₂'" val="l₂'"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(248, 29)" end="(248, 30)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(248, 31)" end="(248, 37)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(248, 31)" end="(248, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(248, 36)" end="(248, 37)">
                          <IdentNode start="(248, 36)" end="(248, 37)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(248, 37)" end="(248, 38)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(248, 39)" end="(248, 59)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(248, 39)" end="(248, 40)" leading="" trailing="" val="("/>
                      <NullNode start="(248, 40)" end="(248, 41)">
                        <LeanBinderidentNode start="(248, 40)" end="(248, 41)">
                          <IdentNode start="(248, 40)" end="(248, 41)" leading="" trailing=" " raw_val="w" val="w"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(248, 42)" end="(248, 43)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(248, 44)" end="(248, 58)" kind="«term_=_»">
                        <IdentNode start="(248, 44)" end="(248, 45)" leading="" trailing=" " raw_val="l" val="l"/>
                        <AtomNode start="(248, 46)" end="(248, 47)" leading="" trailing=" " val="="/>
                        <OtherNode start="(248, 48)" end="(248, 58)" kind="«term_++_»">
                          <IdentNode start="(248, 48)" end="(248, 51)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                          <AtomNode start="(248, 52)" end="(248, 54)" leading="" trailing=" " val="++"/>
                          <IdentNode start="(248, 55)" end="(248, 58)" leading="" trailing="" raw_val="l₂'" val="l₂'"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(248, 58)" end="(248, 59)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(248, 59)" end="(248, 60)" leading="" trailing="&#10;        " val=","/>
                <OtherNode start="(249, 9)" end="(250, 84)" kind="«term_∧_»">
                  <OtherNode start="(249, 9)" end="(249, 69)" kind="«term_=_»">
                    <OtherNode start="(249, 9)" end="(249, 64)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(249, 9)" end="(249, 22)" leading="" trailing=" " raw_val="l₁'.mapFinIdx" val="l₁'.mapFinIdx"/>
                      <NullNode start="(249, 23)" end="(249, 64)">
                        <OtherNode start="(249, 23)" end="(249, 64)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(249, 23)" end="(249, 24)" leading="" trailing="" val="("/>
                          <OtherNode start="(249, 24)" end="(249, 63)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(249, 24)" end="(249, 27)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(249, 28)" end="(249, 63)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(249, 28)" end="(249, 33)">
                                <IdentNode start="(249, 28)" end="(249, 29)" leading="" trailing=" " raw_val="i" val="i"/>
                                <IdentNode start="(249, 30)" end="(249, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                                <IdentNode start="(249, 32)" end="(249, 33)" leading="" trailing=" " raw_val="h" val="h"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(249, 34)" end="(249, 36)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(249, 37)" end="(249, 63)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(249, 37)" end="(249, 38)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(249, 39)" end="(249, 63)">
                                  <IdentNode start="(249, 39)" end="(249, 40)" leading="" trailing=" " raw_val="i" val="i"/>
                                  <IdentNode start="(249, 41)" end="(249, 42)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <OtherNode start="(249, 43)" end="(249, 63)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(249, 43)" end="(249, 44)" leading="" trailing="" val="("/>
                                    <TermBytacticNode start="(249, 44)" end="(249, 62)">
                                      <AtomNode start="(249, 44)" end="(249, 46)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(249, 47)" end="(249, 62)">
                                        <TacticTacticseq1IndentedNode start="(249, 47)" end="(249, 62)">
                                          <NullNode start="(249, 47)" end="(249, 62)">
                                            <OtherNode start="(249, 47)" end="(249, 55)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.44123&#10;β : Type ?u.44145&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;l₁' l₂' : List α&#10;w : l = l₁' ++ l₂'&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l₁'.length&#10;⊢ i &amp;lt; l.length" state_after="α : Type ?u.44123&#10;β : Type ?u.44145&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;l₁' l₂' : List α&#10;w : l = l₁' ++ l₂'&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l₁'.length&#10;⊢ i &amp;lt; l₁'.length + l₂'.length" tactic="simp [w]">
                                              <AtomNode start="(249, 47)" end="(249, 51)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(249, 52)" end="(249, 55)">
                                                <AtomNode start="(249, 52)" end="(249, 53)" leading="" trailing="" val="["/>
                                                <NullNode start="(249, 53)" end="(249, 54)">
                                                  <OtherNode start="(249, 53)" end="(249, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(249, 53)" end="(249, 54)" leading="" trailing="" raw_val="w" val="w"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(249, 54)" end="(249, 55)" leading="" trailing="" val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(249, 55)" end="(249, 56)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(249, 57)" end="(249, 62)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.44123&#10;β : Type ?u.44145&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;l₁' l₂' : List α&#10;w : l = l₁' ++ l₂'&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l₁'.length&#10;⊢ i &amp;lt; l₁'.length + l₂'.length" state_after="no goals" tactic="omega">
                                              <AtomNode start="(249, 57)" end="(249, 62)" leading="" trailing="" val="omega"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                    <AtomNode start="(249, 62)" end="(249, 63)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(249, 63)" end="(249, 64)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(249, 65)" end="(249, 66)" leading="" trailing=" " val="="/>
                    <IdentNode start="(249, 67)" end="(249, 69)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </OtherNode>
                  <AtomNode start="(249, 70)" end="(249, 71)" leading="" trailing="&#10;        " val="∧"/>
                  <OtherNode start="(250, 9)" end="(250, 84)" kind="«term_=_»">
                    <OtherNode start="(250, 9)" end="(250, 79)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(250, 9)" end="(250, 22)" leading="" trailing=" " raw_val="l₂'.mapFinIdx" val="l₂'.mapFinIdx"/>
                      <NullNode start="(250, 23)" end="(250, 79)">
                        <OtherNode start="(250, 23)" end="(250, 79)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(250, 23)" end="(250, 24)" leading="" trailing="" val="("/>
                          <OtherNode start="(250, 24)" end="(250, 78)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(250, 24)" end="(250, 27)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(250, 28)" end="(250, 78)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(250, 28)" end="(250, 33)">
                                <IdentNode start="(250, 28)" end="(250, 29)" leading="" trailing=" " raw_val="i" val="i"/>
                                <IdentNode start="(250, 30)" end="(250, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                                <IdentNode start="(250, 32)" end="(250, 33)" leading="" trailing=" " raw_val="h" val="h"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(250, 34)" end="(250, 36)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(250, 37)" end="(250, 78)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(250, 37)" end="(250, 38)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(250, 39)" end="(250, 78)">
                                  <OtherNode start="(250, 39)" end="(250, 55)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(250, 39)" end="(250, 40)" leading="" trailing="" val="("/>
                                    <OtherNode start="(250, 40)" end="(250, 54)" kind="«term_+_»">
                                      <IdentNode start="(250, 40)" end="(250, 41)" leading="" trailing=" " raw_val="i" val="i"/>
                                      <AtomNode start="(250, 42)" end="(250, 43)" leading="" trailing=" " val="+"/>
                                      <IdentNode start="(250, 44)" end="(250, 54)" leading="" trailing="" raw_val="l₁'.length" val="l₁'.length"/>
                                    </OtherNode>
                                    <AtomNode start="(250, 54)" end="(250, 55)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <IdentNode start="(250, 56)" end="(250, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <OtherNode start="(250, 58)" end="(250, 78)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(250, 58)" end="(250, 59)" leading="" trailing="" val="("/>
                                    <TermBytacticNode start="(250, 59)" end="(250, 77)">
                                      <AtomNode start="(250, 59)" end="(250, 61)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(250, 62)" end="(250, 77)">
                                        <TacticTacticseq1IndentedNode start="(250, 62)" end="(250, 77)">
                                          <NullNode start="(250, 62)" end="(250, 77)">
                                            <OtherNode start="(250, 62)" end="(250, 70)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.44123&#10;β : Type ?u.44145&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;l₁' l₂' : List α&#10;w : l = l₁' ++ l₂'&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l₂'.length&#10;⊢ i + l₁'.length &amp;lt; l.length" state_after="α : Type ?u.44123&#10;β : Type ?u.44145&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;l₁' l₂' : List α&#10;w : l = l₁' ++ l₂'&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l₂'.length&#10;⊢ i + l₁'.length &amp;lt; l₁'.length + l₂'.length" tactic="simp [w]">
                                              <AtomNode start="(250, 62)" end="(250, 66)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(250, 67)" end="(250, 70)">
                                                <AtomNode start="(250, 67)" end="(250, 68)" leading="" trailing="" val="["/>
                                                <NullNode start="(250, 68)" end="(250, 69)">
                                                  <OtherNode start="(250, 68)" end="(250, 69)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(250, 68)" end="(250, 69)" leading="" trailing="" raw_val="w" val="w"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(250, 69)" end="(250, 70)" leading="" trailing="" val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(250, 70)" end="(250, 71)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(250, 72)" end="(250, 77)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.44123&#10;β : Type ?u.44145&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;l₁' l₂' : List α&#10;w : l = l₁' ++ l₂'&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l₂'.length&#10;⊢ i + l₁'.length &amp;lt; l₁'.length + l₂'.length" state_after="no goals" tactic="omega">
                                              <AtomNode start="(250, 72)" end="(250, 77)" leading="" trailing="" val="omega"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                    <AtomNode start="(250, 77)" end="(250, 78)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(250, 78)" end="(250, 79)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(250, 80)" end="(250, 81)" leading="" trailing=" " val="="/>
                    <IdentNode start="(250, 82)" end="(250, 84)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(250, 85)" end="(283, 43)">
          <AtomNode start="(250, 85)" end="(250, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(250, 88)" end="(283, 43)">
            <AtomNode start="(250, 88)" end="(250, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(251, 3)" end="(283, 43)">
              <TacticTacticseq1IndentedNode start="(251, 3)" end="(283, 43)">
                <NullNode start="(251, 3)" end="(283, 43)">
                  <OtherNode start="(251, 3)" end="(251, 24)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ l.mapFinIdx f = l₁ ++ l₂ ↔&#10;    ∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂" state_after="α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h_1) ↔&#10;    ∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂" tactic="rw [mapFinIdx_eq_iff]">
                    <AtomNode start="(251, 3)" end="(251, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(251, 6)" end="(251, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(251, 6)" end="(251, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(251, 7)" end="(251, 23)">
                        <OtherNode start="(251, 7)" end="(251, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(251, 7)" end="(251, 23)" leading="" trailing="" raw_val="mapFinIdx_eq_iff" val="mapFinIdx_eq_iff" full_name="List.mapFinIdx_eq_iff" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(234, 9)" def_end="(234, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(251, 23)" end="(251, 24)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(252, 3)" end="(252, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h_1) ↔&#10;    ∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂" state_after="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h_1) →&#10;    ∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂&#10;&#10;case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂) →&#10;    ∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h_1" tactic="constructor">
                    <AtomNode start="(252, 3)" end="(252, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(253, 3)" end="(275, 27)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h_1) →&#10;    ∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂&#10;&#10;case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂) →&#10;    ∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h_1" state_after="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂) →&#10;    ∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h_1" tactic="· intro ⟨h, w⟩&#10;  simp only [length_append] at h&#10;  refine ⟨l.take l₁.length, l.drop l₁.length, by simp, ?_⟩&#10;  constructor&#10;  · apply ext_getElem&#10;    · simp&#10;      omega&#10;    · intro i hi₁ hi₂&#10;      simp only [getElem_mapFinIdx, getElem_take]&#10;      specialize w i (by omega)&#10;      rw [getElem_append_left hi₂] at w&#10;      exact w.symm&#10;  · apply ext_getElem&#10;    · simp&#10;      omega&#10;    · intro i hi₁ hi₂&#10;      simp only [getElem_mapFinIdx, getElem_take]&#10;      simp only [length_take, getElem_drop]&#10;      have : l₁.length ≤ l.length := by omega&#10;      simp only [Nat.min_eq_left this, Nat.add_comm]&#10;      specialize w (i + l₁.length) (by omega)&#10;      rw [getElem_append_right (by omega)] at w&#10;      simpa using w.symm">
                    <OtherNode start="(253, 3)" end="(253, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(253, 3)" end="(253, 4)" kind="patternIgnore">
                        <OtherNode start="(253, 3)" end="(253, 4)" kind="token.«· »">
                          <AtomNode start="(253, 3)" end="(253, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(253, 5)" end="(275, 27)">
                      <TacticTacticseq1IndentedNode start="(253, 5)" end="(275, 27)">
                        <NullNode start="(253, 5)" end="(275, 27)">
                          <OtherNode start="(253, 5)" end="(253, 17)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h_1) →&#10;    ∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂" state_after="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h_1&#10;⊢ ∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂" tactic="intro ⟨h, w⟩">
                            <AtomNode start="(253, 5)" end="(253, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(253, 11)" end="(253, 17)">
                              <OtherNode start="(253, 11)" end="(253, 17)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(253, 11)" end="(253, 12)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(253, 12)" end="(253, 16)">
                                  <IdentNode start="(253, 12)" end="(253, 13)" leading="" trailing="" raw_val="h" val="h"/>
                                  <AtomNode start="(253, 13)" end="(253, 14)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(253, 15)" end="(253, 16)" leading="" trailing="" raw_val="w" val="w"/>
                                </NullNode>
                                <AtomNode start="(253, 16)" end="(253, 17)" leading="" trailing="&#10;    " val="⟩"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(254, 5)" end="(254, 35)" kind="Lean.Parser.Tactic.simp" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h_1&#10;⊢ ∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂" state_after="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂" tactic="simp only [length_append] at h">
                            <AtomNode start="(254, 5)" end="(254, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(254, 10)" end="(254, 14)">
                              <AtomNode start="(254, 10)" end="(254, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(254, 15)" end="(254, 30)">
                              <AtomNode start="(254, 15)" end="(254, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(254, 16)" end="(254, 29)">
                                <OtherNode start="(254, 16)" end="(254, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(254, 16)" end="(254, 29)" leading="" trailing="" raw_val="length_append" val="length_append" full_name="List.length_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(254, 29)" end="(254, 30)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(254, 31)" end="(254, 35)">
                              <OtherNode start="(254, 31)" end="(254, 35)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(254, 31)" end="(254, 33)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(254, 34)" end="(254, 35)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(254, 34)" end="(254, 35)">
                                    <IdentNode start="(254, 34)" end="(254, 35)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(255, 5)" end="(255, 61)" kind="Lean.Parser.Tactic.refine" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂" state_after="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧&#10;    ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯) = l₂" tactic="refine ⟨l.take l₁.length, l.drop l₁.length, by simp, ?_⟩">
                            <AtomNode start="(255, 5)" end="(255, 11)" leading="" trailing=" " val="refine"/>
                            <OtherNode start="(255, 12)" end="(255, 61)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(255, 12)" end="(255, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(255, 13)" end="(255, 60)">
                                <OtherNode start="(255, 13)" end="(255, 29)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(255, 13)" end="(255, 19)" leading="" trailing=" " raw_val="l.take" val="l.take"/>
                                  <NullNode start="(255, 20)" end="(255, 29)">
                                    <IdentNode start="(255, 20)" end="(255, 29)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(255, 29)" end="(255, 30)" leading="" trailing=" " val=","/>
                                <OtherNode start="(255, 31)" end="(255, 47)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(255, 31)" end="(255, 37)" leading="" trailing=" " raw_val="l.drop" val="l.drop"/>
                                  <NullNode start="(255, 38)" end="(255, 47)">
                                    <IdentNode start="(255, 38)" end="(255, 47)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(255, 47)" end="(255, 48)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(255, 49)" end="(255, 56)">
                                  <AtomNode start="(255, 49)" end="(255, 51)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(255, 52)" end="(255, 56)">
                                    <TacticTacticseq1IndentedNode start="(255, 52)" end="(255, 56)">
                                      <NullNode start="(255, 52)" end="(255, 56)">
                                        <OtherNode start="(255, 52)" end="(255, 56)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ l = take l₁.length l ++ drop l₁.length l" state_after="no goals" tactic="simp">
                                          <AtomNode start="(255, 52)" end="(255, 56)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(255, 56)" end="(255, 57)" leading="" trailing=" " val=","/>
                                <OtherNode start="(255, 58)" end="(255, 60)" kind="Lean.Parser.Term.syntheticHole">
                                  <AtomNode start="(255, 58)" end="(255, 59)" leading="" trailing="" val="?"/>
                                  <AtomNode start="(255, 59)" end="(255, 60)" leading="" trailing="" val="_"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(255, 60)" end="(255, 61)" leading="" trailing="&#10;    " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(256, 5)" end="(256, 16)" kind="Lean.Parser.Tactic.constructor" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧&#10;    ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯) = l₂" state_after="case mp.left&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁&#10;&#10;case mp.right&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯) = l₂" tactic="constructor">
                            <AtomNode start="(256, 5)" end="(256, 16)" leading="" trailing="&#10;    " val="constructor"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(257, 5)" end="(264, 21)" kind="Lean.cdot" state_before="case mp.left&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁&#10;&#10;case mp.right&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯) = l₂" state_after="case mp.right&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯) = l₂" tactic="· apply ext_getElem&#10;  · simp&#10;    omega&#10;  · intro i hi₁ hi₂&#10;    simp only [getElem_mapFinIdx, getElem_take]&#10;    specialize w i (by omega)&#10;    rw [getElem_append_left hi₂] at w&#10;    exact w.symm">
                            <OtherNode start="(257, 5)" end="(257, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(257, 5)" end="(257, 6)" kind="patternIgnore">
                                <OtherNode start="(257, 5)" end="(257, 6)" kind="token.«· »">
                                  <AtomNode start="(257, 5)" end="(257, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(257, 7)" end="(264, 21)">
                              <TacticTacticseq1IndentedNode start="(257, 7)" end="(264, 21)">
                                <NullNode start="(257, 7)" end="(264, 21)">
                                  <OtherNode start="(257, 7)" end="(257, 24)" kind="Lean.Parser.Tactic.apply" state_before="case mp.left&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁" state_after="case mp.left.hl&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length = l₁.length&#10;&#10;case mp.left.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length) (h₂ : i &amp;lt; l₁.length),&#10;    ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯)[i] = l₁[i]" tactic="apply ext_getElem">
                                    <AtomNode start="(257, 7)" end="(257, 12)" leading="" trailing=" " val="apply"/>
                                    <IdentNode start="(257, 13)" end="(257, 24)" leading="" trailing="&#10;      " raw_val="ext_getElem" val="ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(258, 7)" end="(259, 14)" kind="Lean.cdot" state_before="case mp.left.hl&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length = l₁.length&#10;&#10;case mp.left.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length) (h₂ : i &amp;lt; l₁.length),&#10;    ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯)[i] = l₁[i]" state_after="case mp.left.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length) (h₂ : i &amp;lt; l₁.length),&#10;    ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯)[i] = l₁[i]" tactic="· simp&#10;  omega">
                                    <OtherNode start="(258, 7)" end="(258, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(258, 7)" end="(258, 8)" kind="patternIgnore">
                                        <OtherNode start="(258, 7)" end="(258, 8)" kind="token.«· »">
                                          <AtomNode start="(258, 7)" end="(258, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(258, 9)" end="(259, 14)">
                                      <TacticTacticseq1IndentedNode start="(258, 9)" end="(259, 14)">
                                        <NullNode start="(258, 9)" end="(259, 14)">
                                          <OtherNode start="(258, 9)" end="(258, 13)" kind="Lean.Parser.Tactic.simp" state_before="case mp.left.hl&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length = l₁.length" state_after="case mp.left.hl&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ min l₁.length l.length = l₁.length" tactic="simp">
                                            <AtomNode start="(258, 9)" end="(258, 13)" leading="" trailing="&#10;        " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(259, 9)" end="(259, 14)" kind="Lean.Parser.Tactic.omega" state_before="case mp.left.hl&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ min l₁.length l.length = l₁.length" state_after="no goals" tactic="omega">
                                            <AtomNode start="(259, 9)" end="(259, 14)" leading="" trailing="&#10;      " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(260, 7)" end="(264, 21)" kind="Lean.cdot" state_before="case mp.left.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length) (h₂ : i &amp;lt; l₁.length),&#10;    ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯)[i] = l₁[i]" state_after="no goals" tactic="· intro i hi₁ hi₂&#10;  simp only [getElem_mapFinIdx, getElem_take]&#10;  specialize w i (by omega)&#10;  rw [getElem_append_left hi₂] at w&#10;  exact w.symm">
                                    <OtherNode start="(260, 7)" end="(260, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(260, 7)" end="(260, 8)" kind="patternIgnore">
                                        <OtherNode start="(260, 7)" end="(260, 8)" kind="token.«· »">
                                          <AtomNode start="(260, 7)" end="(260, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(260, 9)" end="(264, 21)">
                                      <TacticTacticseq1IndentedNode start="(260, 9)" end="(264, 21)">
                                        <NullNode start="(260, 9)" end="(264, 21)">
                                          <OtherNode start="(260, 9)" end="(260, 24)" kind="Lean.Parser.Tactic.intro" state_before="case mp.left.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length) (h₂ : i &amp;lt; l₁.length),&#10;    ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯)[i] = l₁[i]" state_after="case mp.left.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;hi₂ : i &amp;lt; l₁.length&#10;⊢ ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯)[i] = l₁[i]" tactic="intro i hi₁ hi₂">
                                            <AtomNode start="(260, 9)" end="(260, 14)" leading="" trailing=" " val="intro"/>
                                            <NullNode start="(260, 15)" end="(260, 24)">
                                              <IdentNode start="(260, 15)" end="(260, 16)" leading="" trailing=" " raw_val="i" val="i"/>
                                              <IdentNode start="(260, 17)" end="(260, 20)" leading="" trailing=" " raw_val="hi₁" val="hi₁"/>
                                              <IdentNode start="(260, 21)" end="(260, 24)" leading="" trailing="&#10;        " raw_val="hi₂" val="hi₂"/>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(261, 9)" end="(261, 52)" kind="Lean.Parser.Tactic.simp" state_before="case mp.left.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;hi₂ : i &amp;lt; l₁.length&#10;⊢ ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯)[i] = l₁[i]" state_after="case mp.left.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;hi₂ : i &amp;lt; l₁.length&#10;⊢ f i l[i] ⋯ = l₁[i]" tactic="simp only [getElem_mapFinIdx, getElem_take]">
                                            <AtomNode start="(261, 9)" end="(261, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode start="(261, 14)" end="(261, 18)">
                                              <AtomNode start="(261, 14)" end="(261, 18)" leading="" trailing=" " val="only"/>
                                            </NullNode>
                                            <NullNode start="(261, 19)" end="(261, 52)">
                                              <AtomNode start="(261, 19)" end="(261, 20)" leading="" trailing="" val="["/>
                                              <NullNode start="(261, 20)" end="(261, 51)">
                                                <OtherNode start="(261, 20)" end="(261, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(261, 20)" end="(261, 37)" leading="" trailing="" raw_val="getElem_mapFinIdx" val="getElem_mapFinIdx" full_name="List.getElem_mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(132, 17)" def_end="(132, 34)"/>
                                                </OtherNode>
                                                <AtomNode start="(261, 37)" end="(261, 38)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(261, 39)" end="(261, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(261, 39)" end="(261, 51)" leading="" trailing="" raw_val="getElem_take" val="getElem_take" full_name="List.getElem_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(261, 51)" end="(261, 52)" leading="" trailing="&#10;        " val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(262, 9)" end="(262, 34)" kind="Lean.Parser.Tactic.specialize" state_before="case mp.left.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;hi₂ : i &amp;lt; l₁.length&#10;⊢ f i l[i] ⋯ = l₁[i]" state_after="case mp.left.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;hi₂ : i &amp;lt; l₁.length&#10;w : (l₁ ++ l₂)[i] = f i l[i] ⋯&#10;⊢ f i l[i] ⋯ = l₁[i]" tactic="specialize w i (by omega)">
                                            <AtomNode start="(262, 9)" end="(262, 19)" leading="" trailing=" " val="specialize"/>
                                            <OtherNode start="(262, 20)" end="(262, 34)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(262, 20)" end="(262, 21)" leading="" trailing=" " raw_val="w" val="w"/>
                                              <NullNode start="(262, 22)" end="(262, 34)">
                                                <IdentNode start="(262, 22)" end="(262, 23)" leading="" trailing=" " raw_val="i" val="i"/>
                                                <OtherNode start="(262, 24)" end="(262, 34)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(262, 24)" end="(262, 25)" leading="" trailing="" val="("/>
                                                  <TermBytacticNode start="(262, 25)" end="(262, 33)">
                                                    <AtomNode start="(262, 25)" end="(262, 27)" leading="" trailing=" " val="by"/>
                                                    <TacticTacticseqNode start="(262, 28)" end="(262, 33)">
                                                      <TacticTacticseq1IndentedNode start="(262, 28)" end="(262, 33)">
                                                        <NullNode start="(262, 28)" end="(262, 33)">
                                                          <OtherNode start="(262, 28)" end="(262, 33)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;hi₂ : i &amp;lt; l₁.length&#10;⊢ i &amp;lt; l.length" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(262, 28)" end="(262, 33)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </TermBytacticNode>
                                                  <AtomNode start="(262, 33)" end="(262, 34)" leading="" trailing="&#10;        " val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(263, 9)" end="(263, 42)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mp.left.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;hi₂ : i &amp;lt; l₁.length&#10;w : (l₁ ++ l₂)[i] = f i l[i] ⋯&#10;⊢ f i l[i] ⋯ = l₁[i]" state_after="case mp.left.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;hi₂ : i &amp;lt; l₁.length&#10;w : l₁[i] = f i l[i] ⋯&#10;⊢ f i l[i] ⋯ = l₁[i]" tactic="rw [getElem_append_left hi₂] at w">
                                            <AtomNode start="(263, 9)" end="(263, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(263, 12)" end="(263, 37)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(263, 12)" end="(263, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(263, 13)" end="(263, 36)">
                                                <OtherNode start="(263, 13)" end="(263, 36)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(263, 13)" end="(263, 36)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(263, 13)" end="(263, 32)" leading="" trailing=" " raw_val="getElem_append_left" val="getElem_append_left" full_name="List.getElem_append_left" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                                                    <NullNode start="(263, 33)" end="(263, 36)">
                                                      <IdentNode start="(263, 33)" end="(263, 36)" leading="" trailing="" raw_val="hi₂" val="hi₂"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(263, 36)" end="(263, 37)" leading="" trailing=" " val="]"/>
                                            </OtherNode>
                                            <NullNode start="(263, 38)" end="(263, 42)">
                                              <OtherNode start="(263, 38)" end="(263, 42)" kind="Lean.Parser.Tactic.location">
                                                <AtomNode start="(263, 38)" end="(263, 40)" leading="" trailing=" " val="at"/>
                                                <OtherNode start="(263, 41)" end="(263, 42)" kind="Lean.Parser.Tactic.locationHyp">
                                                  <NullNode start="(263, 41)" end="(263, 42)">
                                                    <IdentNode start="(263, 41)" end="(263, 42)" leading="" trailing="&#10;        " raw_val="w" val="w"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(264, 9)" end="(264, 21)" kind="Lean.Parser.Tactic.exact" state_before="case mp.left.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((take l₁.length l).mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;hi₂ : i &amp;lt; l₁.length&#10;w : l₁[i] = f i l[i] ⋯&#10;⊢ f i l[i] ⋯ = l₁[i]" state_after="no goals" tactic="exact w.symm">
                                            <AtomNode start="(264, 9)" end="(264, 14)" leading="" trailing=" " val="exact"/>
                                            <IdentNode start="(264, 15)" end="(264, 21)" leading="" trailing="&#10;    " raw_val="w.symm" val="w.symm"/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(265, 5)" end="(275, 27)" kind="Lean.cdot" state_before="case mp.right&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯) = l₂" state_after="no goals" tactic="· apply ext_getElem&#10;  · simp&#10;    omega&#10;  · intro i hi₁ hi₂&#10;    simp only [getElem_mapFinIdx, getElem_take]&#10;    simp only [length_take, getElem_drop]&#10;    have : l₁.length ≤ l.length := by omega&#10;    simp only [Nat.min_eq_left this, Nat.add_comm]&#10;    specialize w (i + l₁.length) (by omega)&#10;    rw [getElem_append_right (by omega)] at w&#10;    simpa using w.symm">
                            <OtherNode start="(265, 5)" end="(265, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(265, 5)" end="(265, 6)" kind="patternIgnore">
                                <OtherNode start="(265, 5)" end="(265, 6)" kind="token.«· »">
                                  <AtomNode start="(265, 5)" end="(265, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(265, 7)" end="(275, 27)">
                              <TacticTacticseq1IndentedNode start="(265, 7)" end="(275, 27)">
                                <NullNode start="(265, 7)" end="(275, 27)">
                                  <OtherNode start="(265, 7)" end="(265, 24)" kind="Lean.Parser.Tactic.apply" state_before="case mp.right&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯) = l₂" state_after="case mp.right.hl&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length = l₂.length&#10;&#10;case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length)&#10;    (h₂ : i &amp;lt; l₂.length), ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯)[i] = l₂[i]" tactic="apply ext_getElem">
                                    <AtomNode start="(265, 7)" end="(265, 12)" leading="" trailing=" " val="apply"/>
                                    <IdentNode start="(265, 13)" end="(265, 24)" leading="" trailing="&#10;      " raw_val="ext_getElem" val="ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(266, 7)" end="(267, 14)" kind="Lean.cdot" state_before="case mp.right.hl&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length = l₂.length&#10;&#10;case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length)&#10;    (h₂ : i &amp;lt; l₂.length), ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯)[i] = l₂[i]" state_after="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length)&#10;    (h₂ : i &amp;lt; l₂.length), ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯)[i] = l₂[i]" tactic="· simp&#10;  omega">
                                    <OtherNode start="(266, 7)" end="(266, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(266, 7)" end="(266, 8)" kind="patternIgnore">
                                        <OtherNode start="(266, 7)" end="(266, 8)" kind="token.«· »">
                                          <AtomNode start="(266, 7)" end="(266, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(266, 9)" end="(267, 14)">
                                      <TacticTacticseq1IndentedNode start="(266, 9)" end="(267, 14)">
                                        <NullNode start="(266, 9)" end="(267, 14)">
                                          <OtherNode start="(266, 9)" end="(266, 13)" kind="Lean.Parser.Tactic.simp" state_before="case mp.right.hl&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length = l₂.length" state_after="case mp.right.hl&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ l.length - l₁.length = l₂.length" tactic="simp">
                                            <AtomNode start="(266, 9)" end="(266, 13)" leading="" trailing="&#10;        " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(267, 9)" end="(267, 14)" kind="Lean.Parser.Tactic.omega" state_before="case mp.right.hl&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ l.length - l₁.length = l₂.length" state_after="no goals" tactic="omega">
                                            <AtomNode start="(267, 9)" end="(267, 14)" leading="" trailing="&#10;      " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(268, 7)" end="(275, 27)" kind="Lean.cdot" state_before="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length)&#10;    (h₂ : i &amp;lt; l₂.length), ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯)[i] = l₂[i]" state_after="no goals" tactic="· intro i hi₁ hi₂&#10;  simp only [getElem_mapFinIdx, getElem_take]&#10;  simp only [length_take, getElem_drop]&#10;  have : l₁.length ≤ l.length := by omega&#10;  simp only [Nat.min_eq_left this, Nat.add_comm]&#10;  specialize w (i + l₁.length) (by omega)&#10;  rw [getElem_append_right (by omega)] at w&#10;  simpa using w.symm">
                                    <OtherNode start="(268, 7)" end="(268, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(268, 7)" end="(268, 8)" kind="patternIgnore">
                                        <OtherNode start="(268, 7)" end="(268, 8)" kind="token.«· »">
                                          <AtomNode start="(268, 7)" end="(268, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(268, 9)" end="(275, 27)">
                                      <TacticTacticseq1IndentedNode start="(268, 9)" end="(275, 27)">
                                        <NullNode start="(268, 9)" end="(275, 27)">
                                          <OtherNode start="(268, 9)" end="(268, 24)" kind="Lean.Parser.Tactic.intro" state_before="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length)&#10;    (h₂ : i &amp;lt; l₂.length), ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯)[i] = l₂[i]" state_after="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;⊢ ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯)[i] = l₂[i]" tactic="intro i hi₁ hi₂">
                                            <AtomNode start="(268, 9)" end="(268, 14)" leading="" trailing=" " val="intro"/>
                                            <NullNode start="(268, 15)" end="(268, 24)">
                                              <IdentNode start="(268, 15)" end="(268, 16)" leading="" trailing=" " raw_val="i" val="i"/>
                                              <IdentNode start="(268, 17)" end="(268, 20)" leading="" trailing=" " raw_val="hi₁" val="hi₁"/>
                                              <IdentNode start="(268, 21)" end="(268, 24)" leading="" trailing="&#10;        " raw_val="hi₂" val="hi₂"/>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(269, 9)" end="(269, 52)" kind="Lean.Parser.Tactic.simp" state_before="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;⊢ ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯)[i] = l₂[i]" state_after="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;⊢ f (i + (take l₁.length l).length) (drop l₁.length l)[i] ⋯ = l₂[i]" tactic="simp only [getElem_mapFinIdx, getElem_take]">
                                            <AtomNode start="(269, 9)" end="(269, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode start="(269, 14)" end="(269, 18)">
                                              <AtomNode start="(269, 14)" end="(269, 18)" leading="" trailing=" " val="only"/>
                                            </NullNode>
                                            <NullNode start="(269, 19)" end="(269, 52)">
                                              <AtomNode start="(269, 19)" end="(269, 20)" leading="" trailing="" val="["/>
                                              <NullNode start="(269, 20)" end="(269, 51)">
                                                <OtherNode start="(269, 20)" end="(269, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(269, 20)" end="(269, 37)" leading="" trailing="" raw_val="getElem_mapFinIdx" val="getElem_mapFinIdx" full_name="List.getElem_mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(132, 17)" def_end="(132, 34)"/>
                                                </OtherNode>
                                                <AtomNode start="(269, 37)" end="(269, 38)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(269, 39)" end="(269, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(269, 39)" end="(269, 51)" leading="" trailing="" raw_val="getElem_take" val="getElem_take" full_name="List.getElem_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(269, 51)" end="(269, 52)" leading="" trailing="&#10;        " val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(270, 9)" end="(270, 46)" kind="Lean.Parser.Tactic.simp" state_before="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;⊢ f (i + (take l₁.length l).length) (drop l₁.length l)[i] ⋯ = l₂[i]" state_after="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;⊢ f (i + min l₁.length l.length) l[l₁.length + i] ⋯ = l₂[i]" tactic="simp only [length_take, getElem_drop]">
                                            <AtomNode start="(270, 9)" end="(270, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode start="(270, 14)" end="(270, 18)">
                                              <AtomNode start="(270, 14)" end="(270, 18)" leading="" trailing=" " val="only"/>
                                            </NullNode>
                                            <NullNode start="(270, 19)" end="(270, 46)">
                                              <AtomNode start="(270, 19)" end="(270, 20)" leading="" trailing="" val="["/>
                                              <NullNode start="(270, 20)" end="(270, 45)">
                                                <OtherNode start="(270, 20)" end="(270, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(270, 20)" end="(270, 31)" leading="" trailing="" raw_val="length_take" val="length_take" full_name="List.length_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                                </OtherNode>
                                                <AtomNode start="(270, 31)" end="(270, 32)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(270, 33)" end="(270, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(270, 33)" end="(270, 45)" leading="" trailing="" raw_val="getElem_drop" val="getElem_drop" full_name="List.getElem_drop" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(270, 45)" end="(270, 46)" leading="" trailing="&#10;        " val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(271, 9)" end="(271, 48)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;⊢ f (i + min l₁.length l.length) l[l₁.length + i] ⋯ = l₂[i]" state_after="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;this : l₁.length ≤ l.length&#10;⊢ f (i + min l₁.length l.length) l[l₁.length + i] ⋯ = l₂[i]" tactic="have : l₁.length ≤ l.length := by omega">
                                            <AtomNode start="(271, 9)" end="(271, 13)" leading="" trailing=" " val="have"/>
                                            <OtherNode start="(271, 14)" end="(271, 48)" kind="Lean.Parser.Term.haveDecl">
                                              <OtherNode start="(271, 14)" end="(271, 48)" kind="Lean.Parser.Term.haveIdDecl">
                                                <OtherNode start="(271, 14)" end="(271, 14)" kind="Lean.Parser.Term.haveId">
                                                  <OtherNode start="(271, 14)" end="(271, 14)" kind="hygieneInfo">
                                                    <IdentNode start="(271, 14)" end="(271, 14)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode start="(271, 14)" end="(271, 36)">
                                                  <TermTypespecNode start="(271, 14)" end="(271, 36)">
                                                    <AtomNode start="(271, 14)" end="(271, 15)" leading="" trailing=" " val=":"/>
                                                    <OtherNode start="(271, 16)" end="(271, 36)" kind="«term_≤_»">
                                                      <IdentNode start="(271, 16)" end="(271, 25)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                                                      <AtomNode start="(271, 26)" end="(271, 27)" leading="" trailing=" " val="≤"/>
                                                      <IdentNode start="(271, 28)" end="(271, 36)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                                    </OtherNode>
                                                  </TermTypespecNode>
                                                </NullNode>
                                                <AtomNode start="(271, 37)" end="(271, 39)" leading="" trailing=" " val=":="/>
                                                <TermBytacticNode start="(271, 40)" end="(271, 48)">
                                                  <AtomNode start="(271, 40)" end="(271, 42)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(271, 43)" end="(271, 48)">
                                                    <TacticTacticseq1IndentedNode start="(271, 43)" end="(271, 48)">
                                                      <NullNode start="(271, 43)" end="(271, 48)">
                                                        <OtherNode start="(271, 43)" end="(271, 48)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;⊢ l₁.length ≤ l.length" state_after="no goals" tactic="omega">
                                                          <AtomNode start="(271, 43)" end="(271, 48)" leading="" trailing="&#10;        " val="omega"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(272, 9)" end="(272, 55)" kind="Lean.Parser.Tactic.simp" state_before="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;this : l₁.length ≤ l.length&#10;⊢ f (i + min l₁.length l.length) l[l₁.length + i] ⋯ = l₂[i]" state_after="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;this : l₁.length ≤ l.length&#10;⊢ f (i + l₁.length) l[i + l₁.length] ⋯ = l₂[i]" tactic="simp only [Nat.min_eq_left this, Nat.add_comm]">
                                            <AtomNode start="(272, 9)" end="(272, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode start="(272, 14)" end="(272, 18)">
                                              <AtomNode start="(272, 14)" end="(272, 18)" leading="" trailing=" " val="only"/>
                                            </NullNode>
                                            <NullNode start="(272, 19)" end="(272, 55)">
                                              <AtomNode start="(272, 19)" end="(272, 20)" leading="" trailing="" val="["/>
                                              <NullNode start="(272, 20)" end="(272, 54)">
                                                <OtherNode start="(272, 20)" end="(272, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <OtherNode start="(272, 20)" end="(272, 40)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(272, 20)" end="(272, 35)" leading="" trailing=" " raw_val="Nat.min_eq_left" val="Nat.min_eq_left" full_name="Nat.min_eq_left" mod_name="Init.Data.Nat.MinMax" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/MinMax.lean"/>
                                                    <NullNode start="(272, 36)" end="(272, 40)">
                                                      <IdentNode start="(272, 36)" end="(272, 40)" leading="" trailing="" raw_val="this" val="this"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(272, 40)" end="(272, 41)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(272, 42)" end="(272, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(272, 42)" end="(272, 54)" leading="" trailing="" raw_val="Nat.add_comm" val="Nat.add_comm" full_name="Nat.add_comm" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(272, 54)" end="(272, 55)" leading="" trailing="&#10;        " val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(273, 9)" end="(273, 48)" kind="Lean.Parser.Tactic.specialize" state_before="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;this : l₁.length ≤ l.length&#10;⊢ f (i + l₁.length) l[i + l₁.length] ⋯ = l₂[i]" state_after="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;this : l₁.length ≤ l.length&#10;w : (l₁ ++ l₂)[i + l₁.length] = f (i + l₁.length) l[i + l₁.length] ⋯&#10;⊢ f (i + l₁.length) l[i + l₁.length] ⋯ = l₂[i]" tactic="specialize w (i + l₁.length) (by omega)">
                                            <AtomNode start="(273, 9)" end="(273, 19)" leading="" trailing=" " val="specialize"/>
                                            <OtherNode start="(273, 20)" end="(273, 48)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(273, 20)" end="(273, 21)" leading="" trailing=" " raw_val="w" val="w"/>
                                              <NullNode start="(273, 22)" end="(273, 48)">
                                                <OtherNode start="(273, 22)" end="(273, 37)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(273, 22)" end="(273, 23)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(273, 23)" end="(273, 36)" kind="«term_+_»">
                                                    <IdentNode start="(273, 23)" end="(273, 24)" leading="" trailing=" " raw_val="i" val="i"/>
                                                    <AtomNode start="(273, 25)" end="(273, 26)" leading="" trailing=" " val="+"/>
                                                    <IdentNode start="(273, 27)" end="(273, 36)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                                                  </OtherNode>
                                                  <AtomNode start="(273, 36)" end="(273, 37)" leading="" trailing=" " val=")"/>
                                                </OtherNode>
                                                <OtherNode start="(273, 38)" end="(273, 48)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(273, 38)" end="(273, 39)" leading="" trailing="" val="("/>
                                                  <TermBytacticNode start="(273, 39)" end="(273, 47)">
                                                    <AtomNode start="(273, 39)" end="(273, 41)" leading="" trailing=" " val="by"/>
                                                    <TacticTacticseqNode start="(273, 42)" end="(273, 47)">
                                                      <TacticTacticseq1IndentedNode start="(273, 42)" end="(273, 47)">
                                                        <NullNode start="(273, 42)" end="(273, 47)">
                                                          <OtherNode start="(273, 42)" end="(273, 47)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;this : l₁.length ≤ l.length&#10;⊢ i + l₁.length &amp;lt; l.length" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(273, 42)" end="(273, 47)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </TermBytacticNode>
                                                  <AtomNode start="(273, 47)" end="(273, 48)" leading="" trailing="&#10;        " val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(274, 9)" end="(274, 50)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;this : l₁.length ≤ l.length&#10;w : (l₁ ++ l₂)[i + l₁.length] = f (i + l₁.length) l[i + l₁.length] ⋯&#10;⊢ f (i + l₁.length) l[i + l₁.length] ⋯ = l₂[i]" state_after="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;this : l₁.length ≤ l.length&#10;w : l₂[i + l₁.length - l₁.length] = f (i + l₁.length) l[i + l₁.length] ⋯&#10;⊢ f (i + l₁.length) l[i + l₁.length] ⋯ = l₂[i]" tactic="rw [getElem_append_right (by omega)] at w">
                                            <AtomNode start="(274, 9)" end="(274, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(274, 12)" end="(274, 45)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(274, 12)" end="(274, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(274, 13)" end="(274, 44)">
                                                <OtherNode start="(274, 13)" end="(274, 44)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(274, 13)" end="(274, 44)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(274, 13)" end="(274, 33)" leading="" trailing=" " raw_val="getElem_append_right" val="getElem_append_right" full_name="List.getElem_append_right" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                                                    <NullNode start="(274, 34)" end="(274, 44)">
                                                      <OtherNode start="(274, 34)" end="(274, 44)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(274, 34)" end="(274, 35)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(274, 35)" end="(274, 43)">
                                                          <AtomNode start="(274, 35)" end="(274, 37)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(274, 38)" end="(274, 43)">
                                                            <TacticTacticseq1IndentedNode start="(274, 38)" end="(274, 43)">
                                                            <NullNode start="(274, 38)" end="(274, 43)">
                                                            <OtherNode start="(274, 38)" end="(274, 43)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;this : l₁.length ≤ l.length&#10;w : (l₁ ++ l₂)[i + l₁.length] = f (i + l₁.length) l[i + l₁.length] ⋯&#10;⊢ l₁.length ≤ i + l₁.length" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(274, 38)" end="(274, 43)" leading="" trailing="" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(274, 43)" end="(274, 44)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(274, 44)" end="(274, 45)" leading="" trailing=" " val="]"/>
                                            </OtherNode>
                                            <NullNode start="(274, 46)" end="(274, 50)">
                                              <OtherNode start="(274, 46)" end="(274, 50)" kind="Lean.Parser.Tactic.location">
                                                <AtomNode start="(274, 46)" end="(274, 48)" leading="" trailing=" " val="at"/>
                                                <OtherNode start="(274, 49)" end="(274, 50)" kind="Lean.Parser.Tactic.locationHyp">
                                                  <NullNode start="(274, 49)" end="(274, 50)">
                                                    <IdentNode start="(274, 49)" end="(274, 50)" leading="" trailing="&#10;        " raw_val="w" val="w"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(275, 9)" end="(275, 27)" kind="Lean.Parser.Tactic.simpa" state_before="case mp.right.h&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;h✝ : (l₁ ++ l₂).length = l.length&#10;h : l₁.length + l₂.length = l.length&#10;i : Nat&#10;hi₁ : i &amp;lt; ((drop l₁.length l).mapFinIdx fun i a h =&amp;gt; f (i + (take l₁.length l).length) a ⋯).length&#10;hi₂ : i &amp;lt; l₂.length&#10;this : l₁.length ≤ l.length&#10;w : l₂[i + l₁.length - l₁.length] = f (i + l₁.length) l[i + l₁.length] ⋯&#10;⊢ f (i + l₁.length) l[i + l₁.length] ⋯ = l₂[i]" state_after="no goals" tactic="simpa using w.symm">
                                            <AtomNode start="(275, 9)" end="(275, 14)" leading="" trailing=" " val="simpa"/>
                                            <NullNode/>
                                            <NullNode/>
                                            <OtherNode start="(275, 15)" end="(275, 27)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(275, 15)" end="(275, 27)">
                                                <AtomNode start="(275, 15)" end="(275, 20)" leading="" trailing=" " val="using"/>
                                                <IdentNode start="(275, 21)" end="(275, 27)" leading="" trailing="&#10;  " raw_val="w.symm" val="w.symm"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(276, 3)" end="(283, 43)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂) →&#10;    ∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h_1" state_after="no goals" tactic="· rintro ⟨l₁', l₂', rfl, rfl, rfl⟩&#10;  refine ⟨by simp, fun i h =&amp;gt; ?_⟩&#10;  rw [getElem_append]&#10;  split &amp;lt;;&amp;gt; rename_i h'&#10;  · simp [getElem_append_left (by simpa using h')]&#10;  · simp only [length_mapFinIdx, Nat.not_lt] at h'&#10;    have : i - l₁'.length + l₁'.length = i := by omega&#10;    simp [getElem_append_right h', this]">
                    <OtherNode start="(276, 3)" end="(276, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(276, 3)" end="(276, 4)" kind="patternIgnore">
                        <OtherNode start="(276, 3)" end="(276, 4)" kind="token.«· »">
                          <AtomNode start="(276, 3)" end="(276, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(276, 5)" end="(283, 43)">
                      <TacticTacticseq1IndentedNode start="(276, 5)" end="(283, 43)">
                        <NullNode start="(276, 5)" end="(283, 43)">
                          <OtherNode start="(276, 5)" end="(276, 37)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l₁ l₂ : List β&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯) = l₂) →&#10;    ∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l₁ ++ l₂)[i] = f i l[i] h_1" state_after="case mpr.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;⊢ ∃ h,&#10;    ∀ (i : Nat) (h_1 : i &amp;lt; (l₁' ++ l₂').length),&#10;      ((l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i] =&#10;        f i (l₁' ++ l₂')[i] h_1" tactic="rintro ⟨l₁', l₂', rfl, rfl, rfl⟩">
                            <AtomNode start="(276, 5)" end="(276, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(276, 12)" end="(276, 37)">
                              <OtherNode start="(276, 12)" end="(276, 37)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(276, 12)" end="(276, 37)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(276, 12)" end="(276, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(276, 13)" end="(276, 36)">
                                    <OtherNode start="(276, 13)" end="(276, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(276, 13)" end="(276, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(276, 13)" end="(276, 16)">
                                          <OtherNode start="(276, 13)" end="(276, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(276, 13)" end="(276, 16)" leading="" trailing="" raw_val="l₁'" val="l₁'"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(276, 16)" end="(276, 17)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(276, 18)" end="(276, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(276, 18)" end="(276, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(276, 18)" end="(276, 21)">
                                          <OtherNode start="(276, 18)" end="(276, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(276, 18)" end="(276, 21)" leading="" trailing="" raw_val="l₂'" val="l₂'"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(276, 21)" end="(276, 22)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(276, 23)" end="(276, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(276, 23)" end="(276, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(276, 23)" end="(276, 26)">
                                          <OtherNode start="(276, 23)" end="(276, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(276, 23)" end="(276, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(276, 26)" end="(276, 27)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(276, 28)" end="(276, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(276, 28)" end="(276, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(276, 28)" end="(276, 31)">
                                          <OtherNode start="(276, 28)" end="(276, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(276, 28)" end="(276, 31)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(276, 31)" end="(276, 32)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(276, 33)" end="(276, 36)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(276, 33)" end="(276, 36)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(276, 33)" end="(276, 36)">
                                          <OtherNode start="(276, 33)" end="(276, 36)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(276, 33)" end="(276, 36)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(276, 36)" end="(276, 37)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(277, 5)" end="(277, 36)" kind="Lean.Parser.Tactic.refine" state_before="case mpr.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;⊢ ∃ h,&#10;    ∀ (i : Nat) (h_1 : i &amp;lt; (l₁' ++ l₂').length),&#10;      ((l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i] =&#10;        f i (l₁' ++ l₂')[i] h_1" state_after="case mpr.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;⊢ ((l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i] = f i (l₁' ++ l₂')[i] h" tactic="refine ⟨by simp, fun i h =&amp;gt; ?_⟩">
                            <AtomNode start="(277, 5)" end="(277, 11)" leading="" trailing=" " val="refine"/>
                            <OtherNode start="(277, 12)" end="(277, 36)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(277, 12)" end="(277, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(277, 13)" end="(277, 35)">
                                <TermBytacticNode start="(277, 13)" end="(277, 20)">
                                  <AtomNode start="(277, 13)" end="(277, 15)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(277, 16)" end="(277, 20)">
                                    <TacticTacticseq1IndentedNode start="(277, 16)" end="(277, 20)">
                                      <NullNode start="(277, 16)" end="(277, 20)">
                                        <OtherNode start="(277, 16)" end="(277, 20)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;⊢ ((l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯).length =&#10;    (l₁' ++ l₂').length" state_after="no goals" tactic="simp">
                                          <AtomNode start="(277, 16)" end="(277, 20)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(277, 20)" end="(277, 21)" leading="" trailing=" " val=","/>
                                <OtherNode start="(277, 22)" end="(277, 35)" kind="Lean.Parser.Term.fun">
                                  <AtomNode start="(277, 22)" end="(277, 25)" leading="" trailing=" " val="fun"/>
                                  <OtherNode start="(277, 26)" end="(277, 35)" kind="Lean.Parser.Term.basicFun">
                                    <NullNode start="(277, 26)" end="(277, 29)">
                                      <IdentNode start="(277, 26)" end="(277, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                                      <IdentNode start="(277, 28)" end="(277, 29)" leading="" trailing=" " raw_val="h" val="h"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(277, 30)" end="(277, 32)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <OtherNode start="(277, 33)" end="(277, 35)" kind="Lean.Parser.Term.syntheticHole">
                                      <AtomNode start="(277, 33)" end="(277, 34)" leading="" trailing="" val="?"/>
                                      <AtomNode start="(277, 34)" end="(277, 35)" leading="" trailing="" val="_"/>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(277, 35)" end="(277, 36)" leading="" trailing="&#10;    " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(278, 5)" end="(278, 24)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;⊢ ((l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯) ++ l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i] = f i (l₁' ++ l₂')[i] h" state_after="case mpr.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;⊢ (if h' : i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length then (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯)[i]&#10;    else (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i - (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length]) =&#10;    f i (l₁' ++ l₂')[i] h" tactic="rw [getElem_append]">
                            <AtomNode start="(278, 5)" end="(278, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(278, 8)" end="(278, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(278, 8)" end="(278, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(278, 9)" end="(278, 23)">
                                <OtherNode start="(278, 9)" end="(278, 23)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(278, 9)" end="(278, 23)" leading="" trailing="" raw_val="getElem_append" val="getElem_append" full_name="List.getElem_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(278, 23)" end="(278, 24)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(279, 5)" end="(279, 26)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case mpr.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;⊢ (if h' : i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length then (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯)[i]&#10;    else (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i - (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length]) =&#10;    f i (l₁' ++ l₂')[i] h" state_after="case mpr.intro.intro.intro.intro.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;h' : i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;⊢ (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯)[i] = f i (l₁' ++ l₂')[i] h&#10;&#10;case mpr.intro.intro.intro.intro.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;h' : ¬i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;⊢ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i - (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length] =&#10;    f i (l₁' ++ l₂')[i] h" tactic="split &amp;lt;;&amp;gt; rename_i h'">
                            <OtherNode start="(279, 5)" end="(279, 10)" kind="Lean.Parser.Tactic.split">
                              <AtomNode start="(279, 5)" end="(279, 10)" leading="" trailing=" " val="split"/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(279, 11)" end="(279, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(279, 15)" end="(279, 26)" kind="Lean.Parser.Tactic.renameI">
                              <AtomNode start="(279, 15)" end="(279, 23)" leading="" trailing=" " val="rename_i"/>
                              <NullNode start="(279, 24)" end="(279, 26)">
                                <LeanBinderidentNode start="(279, 24)" end="(279, 26)">
                                  <IdentNode start="(279, 24)" end="(279, 26)" leading="" trailing="&#10;    " raw_val="h'" val="h'"/>
                                </LeanBinderidentNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(280, 5)" end="(280, 53)" kind="Lean.cdot" state_before="case mpr.intro.intro.intro.intro.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;h' : i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;⊢ (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯)[i] = f i (l₁' ++ l₂')[i] h&#10;&#10;case mpr.intro.intro.intro.intro.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;h' : ¬i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;⊢ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i - (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length] =&#10;    f i (l₁' ++ l₂')[i] h" state_after="case mpr.intro.intro.intro.intro.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;h' : ¬i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;⊢ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i - (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length] =&#10;    f i (l₁' ++ l₂')[i] h" tactic="· simp [getElem_append_left (by simpa using h')]">
                            <OtherNode start="(280, 5)" end="(280, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(280, 5)" end="(280, 6)" kind="patternIgnore">
                                <OtherNode start="(280, 5)" end="(280, 6)" kind="token.«· »">
                                  <AtomNode start="(280, 5)" end="(280, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(280, 7)" end="(280, 53)">
                              <TacticTacticseq1IndentedNode start="(280, 7)" end="(280, 53)">
                                <NullNode start="(280, 7)" end="(280, 53)">
                                  <OtherNode start="(280, 7)" end="(280, 53)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.intro.intro.intro.intro.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;h' : i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;⊢ (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯)[i] = f i (l₁' ++ l₂')[i] h" state_after="no goals" tactic="simp [getElem_append_left (by simpa using h')]">
                                    <AtomNode start="(280, 7)" end="(280, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(280, 12)" end="(280, 53)">
                                      <AtomNode start="(280, 12)" end="(280, 13)" leading="" trailing="" val="["/>
                                      <NullNode start="(280, 13)" end="(280, 52)">
                                        <OtherNode start="(280, 13)" end="(280, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(280, 13)" end="(280, 52)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(280, 13)" end="(280, 32)" leading="" trailing=" " raw_val="getElem_append_left" val="getElem_append_left" full_name="List.getElem_append_left" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                                            <NullNode start="(280, 33)" end="(280, 52)">
                                              <OtherNode start="(280, 33)" end="(280, 52)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(280, 33)" end="(280, 34)" leading="" trailing="" val="("/>
                                                <TermBytacticNode start="(280, 34)" end="(280, 51)">
                                                  <AtomNode start="(280, 34)" end="(280, 36)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(280, 37)" end="(280, 51)">
                                                    <TacticTacticseq1IndentedNode start="(280, 37)" end="(280, 51)">
                                                      <NullNode start="(280, 37)" end="(280, 51)">
                                                        <OtherNode start="(280, 37)" end="(280, 51)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;h' : i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;⊢ ?m.51041 &amp;lt; length ?m.51042" state_after="no goals" tactic="simpa using h'">
                                                          <AtomNode start="(280, 37)" end="(280, 42)" leading="" trailing=" " val="simpa"/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <OtherNode start="(280, 43)" end="(280, 51)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(280, 43)" end="(280, 51)">
                                                            <AtomNode start="(280, 43)" end="(280, 48)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(280, 49)" end="(280, 51)" leading="" trailing="" raw_val="h'" val="h'"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                                <AtomNode start="(280, 51)" end="(280, 52)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(280, 52)" end="(280, 53)" leading="" trailing="&#10;    " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(281, 5)" end="(283, 43)" kind="Lean.cdot" state_before="case mpr.intro.intro.intro.intro.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;h' : ¬i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;⊢ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i - (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length] =&#10;    f i (l₁' ++ l₂')[i] h" state_after="no goals" tactic="· simp only [length_mapFinIdx, Nat.not_lt] at h'&#10;  have : i - l₁'.length + l₁'.length = i := by omega&#10;  simp [getElem_append_right h', this]">
                            <OtherNode start="(281, 5)" end="(281, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(281, 5)" end="(281, 6)" kind="patternIgnore">
                                <OtherNode start="(281, 5)" end="(281, 6)" kind="token.«· »">
                                  <AtomNode start="(281, 5)" end="(281, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(281, 7)" end="(283, 43)">
                              <TacticTacticseq1IndentedNode start="(281, 7)" end="(283, 43)">
                                <NullNode start="(281, 7)" end="(283, 43)">
                                  <OtherNode start="(281, 7)" end="(281, 53)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.intro.intro.intro.intro.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;h' : ¬i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;⊢ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i - (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length] =&#10;    f i (l₁' ++ l₂')[i] h" state_after="case mpr.intro.intro.intro.intro.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;h'✝ : ¬i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;h' : l₁'.length ≤ i&#10;⊢ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i - (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length] =&#10;    f i (l₁' ++ l₂')[i] h" tactic="simp only [length_mapFinIdx, Nat.not_lt] at h'">
                                    <AtomNode start="(281, 7)" end="(281, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(281, 12)" end="(281, 16)">
                                      <AtomNode start="(281, 12)" end="(281, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(281, 17)" end="(281, 47)">
                                      <AtomNode start="(281, 17)" end="(281, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(281, 18)" end="(281, 46)">
                                        <OtherNode start="(281, 18)" end="(281, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(281, 18)" end="(281, 34)" leading="" trailing="" raw_val="length_mapFinIdx" val="length_mapFinIdx" full_name="List.length_mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(104, 17)" def_end="(104, 33)"/>
                                        </OtherNode>
                                        <AtomNode start="(281, 34)" end="(281, 35)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(281, 36)" end="(281, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(281, 36)" end="(281, 46)" leading="" trailing="" raw_val="Nat.not_lt" val="Nat.not_lt" full_name="Nat.not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(281, 46)" end="(281, 47)" leading="" trailing=" " val="]"/>
                                    </NullNode>
                                    <NullNode start="(281, 48)" end="(281, 53)">
                                      <OtherNode start="(281, 48)" end="(281, 53)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(281, 48)" end="(281, 50)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(281, 51)" end="(281, 53)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(281, 51)" end="(281, 53)">
                                            <IdentNode start="(281, 51)" end="(281, 53)" leading="" trailing="&#10;      " raw_val="h'" val="h'"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(282, 7)" end="(282, 57)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mpr.intro.intro.intro.intro.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;h'✝ : ¬i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;h' : l₁'.length ≤ i&#10;⊢ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i - (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length] =&#10;    f i (l₁' ++ l₂')[i] h" state_after="case mpr.intro.intro.intro.intro.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;h'✝ : ¬i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;h' : l₁'.length ≤ i&#10;this : i - l₁'.length + l₁'.length = i&#10;⊢ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i - (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length] =&#10;    f i (l₁' ++ l₂')[i] h" tactic="have : i - l₁'.length + l₁'.length = i := by omega">
                                    <AtomNode start="(282, 7)" end="(282, 11)" leading="" trailing=" " val="have"/>
                                    <OtherNode start="(282, 12)" end="(282, 57)" kind="Lean.Parser.Term.haveDecl">
                                      <OtherNode start="(282, 12)" end="(282, 57)" kind="Lean.Parser.Term.haveIdDecl">
                                        <OtherNode start="(282, 12)" end="(282, 12)" kind="Lean.Parser.Term.haveId">
                                          <OtherNode start="(282, 12)" end="(282, 12)" kind="hygieneInfo">
                                            <IdentNode start="(282, 12)" end="(282, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode start="(282, 12)" end="(282, 45)">
                                          <TermTypespecNode start="(282, 12)" end="(282, 45)">
                                            <AtomNode start="(282, 12)" end="(282, 13)" leading="" trailing=" " val=":"/>
                                            <OtherNode start="(282, 14)" end="(282, 45)" kind="«term_=_»">
                                              <OtherNode start="(282, 14)" end="(282, 41)" kind="«term_+_»">
                                                <OtherNode start="(282, 14)" end="(282, 28)" kind="«term_-_»">
                                                  <IdentNode start="(282, 14)" end="(282, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                                                  <AtomNode start="(282, 16)" end="(282, 17)" leading="" trailing=" " val="-"/>
                                                  <IdentNode start="(282, 18)" end="(282, 28)" leading="" trailing=" " raw_val="l₁'.length" val="l₁'.length"/>
                                                </OtherNode>
                                                <AtomNode start="(282, 29)" end="(282, 30)" leading="" trailing=" " val="+"/>
                                                <IdentNode start="(282, 31)" end="(282, 41)" leading="" trailing=" " raw_val="l₁'.length" val="l₁'.length"/>
                                              </OtherNode>
                                              <AtomNode start="(282, 42)" end="(282, 43)" leading="" trailing=" " val="="/>
                                              <IdentNode start="(282, 44)" end="(282, 45)" leading="" trailing=" " raw_val="i" val="i"/>
                                            </OtherNode>
                                          </TermTypespecNode>
                                        </NullNode>
                                        <AtomNode start="(282, 46)" end="(282, 48)" leading="" trailing=" " val=":="/>
                                        <TermBytacticNode start="(282, 49)" end="(282, 57)">
                                          <AtomNode start="(282, 49)" end="(282, 51)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(282, 52)" end="(282, 57)">
                                            <TacticTacticseq1IndentedNode start="(282, 52)" end="(282, 57)">
                                              <NullNode start="(282, 52)" end="(282, 57)">
                                                <OtherNode start="(282, 52)" end="(282, 57)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;h'✝ : ¬i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;h' : l₁'.length ≤ i&#10;⊢ i - l₁'.length + l₁'.length = i" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(282, 52)" end="(282, 57)" leading="" trailing="&#10;      " val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(283, 7)" end="(283, 43)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.intro.intro.intro.intro.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;l₁' l₂' : List α&#10;f : (i : Nat) → α → i &amp;lt; (l₁' ++ l₂').length → β&#10;i : Nat&#10;h : i &amp;lt; (l₁' ++ l₂').length&#10;h'✝ : ¬i &amp;lt; (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length&#10;h' : l₁'.length ≤ i&#10;this : i - l₁'.length + l₁'.length = i&#10;⊢ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a ⋯)[i - (l₁'.mapFinIdx fun i a h =&amp;gt; f i a ⋯).length] =&#10;    f i (l₁' ++ l₂')[i] h" state_after="no goals" tactic="simp [getElem_append_right h', this]">
                                    <AtomNode start="(283, 7)" end="(283, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(283, 12)" end="(283, 43)">
                                      <AtomNode start="(283, 12)" end="(283, 13)" leading="" trailing="" val="["/>
                                      <NullNode start="(283, 13)" end="(283, 42)">
                                        <OtherNode start="(283, 13)" end="(283, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(283, 13)" end="(283, 36)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(283, 13)" end="(283, 33)" leading="" trailing=" " raw_val="getElem_append_right" val="getElem_append_right" full_name="List.getElem_append_right" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                                            <NullNode start="(283, 34)" end="(283, 36)">
                                              <IdentNode start="(283, 34)" end="(283, 36)" leading="" trailing="" raw_val="h'" val="h'"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(283, 36)" end="(283, 37)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(283, 38)" end="(283, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(283, 38)" end="(283, 42)" leading="" trailing="" raw_val="this" val="this"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(283, 42)" end="(283, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(285, 1)" end="(288, 24)" name="mapFinIdx_eq_mapFinIdx_iff" full_name="List.mapFinIdx_eq_mapFinIdx_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(285, 1)" end="(288, 24)" name="mapFinIdx_eq_mapFinIdx_iff" full_name="List.mapFinIdx_eq_mapFinIdx_iff" _is_private_decl="False">
        <AtomNode start="(285, 1)" end="(285, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(285, 9)" end="(285, 35)">
          <IdentNode start="(285, 9)" end="(285, 35)" leading="" trailing=" " raw_val="mapFinIdx_eq_mapFinIdx_iff" val="mapFinIdx_eq_mapFinIdx_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(285, 36)" end="(286, 92)">
          <NullNode start="(285, 36)" end="(285, 95)">
            <OtherNode start="(285, 36)" end="(285, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(285, 36)" end="(285, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(285, 37)" end="(285, 38)">
                <IdentNode start="(285, 37)" end="(285, 38)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(285, 39)" end="(285, 47)">
                <AtomNode start="(285, 39)" end="(285, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(285, 41)" end="(285, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(285, 41)" end="(285, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(285, 46)" end="(285, 47)">
                    <IdentNode start="(285, 46)" end="(285, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(285, 47)" end="(285, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(285, 49)" end="(285, 95)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(285, 49)" end="(285, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(285, 50)" end="(285, 53)">
                <IdentNode start="(285, 50)" end="(285, 51)" leading="" trailing=" " raw_val="f" val="f"/>
                <IdentNode start="(285, 52)" end="(285, 53)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(285, 54)" end="(285, 94)">
                <AtomNode start="(285, 54)" end="(285, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(285, 56)" end="(285, 94)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(285, 56)" end="(285, 65)">
                    <AtomNode start="(285, 56)" end="(285, 57)" leading="" trailing="" val="("/>
                    <NullNode start="(285, 57)" end="(285, 58)">
                      <IdentNode start="(285, 57)" end="(285, 58)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(285, 59)" end="(285, 64)">
                      <AtomNode start="(285, 59)" end="(285, 60)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(285, 61)" end="(285, 64)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(285, 64)" end="(285, 65)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(285, 66)" end="(285, 67)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(285, 68)" end="(285, 94)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(285, 68)" end="(285, 69)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(285, 70)" end="(285, 71)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(285, 72)" end="(285, 94)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(285, 72)" end="(285, 90)">
                        <AtomNode start="(285, 72)" end="(285, 73)" leading="" trailing="" val="("/>
                        <NullNode start="(285, 73)" end="(285, 74)">
                          <IdentNode start="(285, 73)" end="(285, 74)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(285, 75)" end="(285, 89)">
                          <AtomNode start="(285, 75)" end="(285, 76)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(285, 77)" end="(285, 89)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(285, 77)" end="(285, 78)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(285, 79)" end="(285, 80)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(285, 81)" end="(285, 89)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(285, 89)" end="(285, 90)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(285, 91)" end="(285, 92)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(285, 93)" end="(285, 94)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(285, 94)" end="(285, 95)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(285, 96)" end="(286, 92)">
            <AtomNode start="(285, 96)" end="(285, 97)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(286, 5)" end="(286, 92)" kind="«term_↔_»">
              <OtherNode start="(286, 5)" end="(286, 34)" kind="«term_=_»">
                <OtherNode start="(286, 5)" end="(286, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(286, 5)" end="(286, 16)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                  <NullNode start="(286, 17)" end="(286, 18)">
                    <IdentNode start="(286, 17)" end="(286, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(286, 19)" end="(286, 20)" leading="" trailing=" " val="="/>
                <OtherNode start="(286, 21)" end="(286, 34)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(286, 21)" end="(286, 32)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                  <NullNode start="(286, 33)" end="(286, 34)">
                    <IdentNode start="(286, 33)" end="(286, 34)" leading="" trailing=" " raw_val="g" val="g"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(286, 35)" end="(286, 36)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(286, 37)" end="(286, 92)" kind="Lean.Parser.Term.forall">
                <AtomNode start="(286, 37)" end="(286, 38)" leading="" trailing=" " val="∀"/>
                <NullNode start="(286, 39)" end="(286, 67)">
                  <TermExplicitbinderNode start="(286, 39)" end="(286, 48)">
                    <AtomNode start="(286, 39)" end="(286, 40)" leading="" trailing="" val="("/>
                    <NullNode start="(286, 40)" end="(286, 41)">
                      <IdentNode start="(286, 40)" end="(286, 41)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(286, 42)" end="(286, 47)">
                      <AtomNode start="(286, 42)" end="(286, 43)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(286, 44)" end="(286, 47)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(286, 47)" end="(286, 48)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <TermExplicitbinderNode start="(286, 49)" end="(286, 67)">
                    <AtomNode start="(286, 49)" end="(286, 50)" leading="" trailing="" val="("/>
                    <NullNode start="(286, 50)" end="(286, 51)">
                      <IdentNode start="(286, 50)" end="(286, 51)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                    <NullNode start="(286, 52)" end="(286, 66)">
                      <AtomNode start="(286, 52)" end="(286, 53)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(286, 54)" end="(286, 66)" kind="«term_&amp;lt;_»">
                        <IdentNode start="(286, 54)" end="(286, 55)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(286, 56)" end="(286, 57)" leading="" trailing=" " val="&amp;lt;"/>
                        <IdentNode start="(286, 58)" end="(286, 66)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(286, 66)" end="(286, 67)" leading="" trailing="" val=")"/>
                  </TermExplicitbinderNode>
                </NullNode>
                <NullNode/>
                <AtomNode start="(286, 67)" end="(286, 68)" leading="" trailing=" " val=","/>
                <OtherNode start="(286, 69)" end="(286, 92)" kind="«term_=_»">
                  <OtherNode start="(286, 69)" end="(286, 79)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(286, 69)" end="(286, 70)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(286, 71)" end="(286, 79)">
                      <IdentNode start="(286, 71)" end="(286, 72)" leading="" trailing=" " raw_val="i" val="i"/>
                      <OtherNode start="(286, 73)" end="(286, 77)" kind="«term__[_]»">
                        <IdentNode start="(286, 73)" end="(286, 74)" leading="" trailing="" raw_val="l" val="l"/>
                        <AtomNode start="(286, 74)" end="(286, 75)" leading="" trailing="" val="["/>
                        <IdentNode start="(286, 75)" end="(286, 76)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(286, 76)" end="(286, 77)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                      <IdentNode start="(286, 78)" end="(286, 79)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(286, 80)" end="(286, 81)" leading="" trailing=" " val="="/>
                  <OtherNode start="(286, 82)" end="(286, 92)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(286, 82)" end="(286, 83)" leading="" trailing=" " raw_val="g" val="g"/>
                    <NullNode start="(286, 84)" end="(286, 92)">
                      <IdentNode start="(286, 84)" end="(286, 85)" leading="" trailing=" " raw_val="i" val="i"/>
                      <OtherNode start="(286, 86)" end="(286, 90)" kind="«term__[_]»">
                        <IdentNode start="(286, 86)" end="(286, 87)" leading="" trailing="" raw_val="l" val="l"/>
                        <AtomNode start="(286, 87)" end="(286, 88)" leading="" trailing="" val="["/>
                        <IdentNode start="(286, 88)" end="(286, 89)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(286, 89)" end="(286, 90)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                      <IdentNode start="(286, 91)" end="(286, 92)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(286, 93)" end="(288, 24)">
          <AtomNode start="(286, 93)" end="(286, 95)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(286, 96)" end="(288, 24)">
            <AtomNode start="(286, 96)" end="(286, 98)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(287, 3)" end="(288, 24)">
              <TacticTacticseq1IndentedNode start="(287, 3)" end="(288, 24)">
                <NullNode start="(287, 3)" end="(288, 24)">
                  <OtherNode start="(287, 3)" end="(287, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f g : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ l.mapFinIdx f = l.mapFinIdx g ↔ ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = g i l[i] h" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f g : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l.mapFinIdx f)[i] = g i l[i] h_1) ↔&#10;    ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = g i l[i] h" tactic="rw [eq_comm, mapFinIdx_eq_iff]">
                    <AtomNode start="(287, 3)" end="(287, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(287, 6)" end="(287, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(287, 6)" end="(287, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(287, 7)" end="(287, 32)">
                        <OtherNode start="(287, 7)" end="(287, 14)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(287, 7)" end="(287, 14)" leading="" trailing="" raw_val="eq_comm" val="eq_comm" full_name="eq_comm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                        <AtomNode start="(287, 14)" end="(287, 15)" leading="" trailing=" " val=","/>
                        <OtherNode start="(287, 16)" end="(287, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(287, 16)" end="(287, 32)" leading="" trailing="" raw_val="mapFinIdx_eq_iff" val="mapFinIdx_eq_iff" full_name="List.mapFinIdx_eq_iff" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(234, 9)" def_end="(234, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(287, 32)" end="(287, 33)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(288, 3)" end="(288, 24)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f g : (i : Nat) → α → i &amp;lt; l.length → β&#10;⊢ (∃ h, ∀ (i : Nat) (h_1 : i &amp;lt; l.length), (l.mapFinIdx f)[i] = g i l[i] h_1) ↔&#10;    ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = g i l[i] h" state_after="no goals" tactic="simp [Fin.forall_iff]">
                    <AtomNode start="(288, 3)" end="(288, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(288, 8)" end="(288, 24)">
                      <AtomNode start="(288, 8)" end="(288, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(288, 9)" end="(288, 23)">
                        <OtherNode start="(288, 9)" end="(288, 23)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(288, 9)" end="(288, 23)" leading="" trailing="" raw_val="Fin.forall_iff" val="Fin.forall_iff" full_name="Fin.forall_iff" mod_name="Init.Data.Fin.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(288, 23)" end="(288, 24)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(290, 1)" end="(294, 26)" name="mapFinIdx_mapFinIdx" full_name="List.mapFinIdx_mapFinIdx">
      <CommandDeclmodifiersNode start="(290, 1)" end="(290, 8)">
        <NullNode/>
        <NullNode start="(290, 1)" end="(290, 8)">
          <OtherNode start="(290, 1)" end="(290, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(290, 1)" end="(290, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(290, 3)" end="(290, 7)">
              <OtherNode start="(290, 3)" end="(290, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(290, 3)" end="(290, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(290, 3)" end="(290, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(290, 7)" end="(290, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(290, 9)" end="(294, 26)" name="mapFinIdx_mapFinIdx" full_name="List.mapFinIdx_mapFinIdx" _is_private_decl="False">
        <AtomNode start="(290, 9)" end="(290, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(290, 17)" end="(290, 36)">
          <IdentNode start="(290, 17)" end="(290, 36)" leading="" trailing=" " raw_val="mapFinIdx_mapFinIdx" val="mapFinIdx_mapFinIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(290, 37)" end="(293, 86)">
          <NullNode start="(290, 37)" end="(292, 63)">
            <OtherNode start="(290, 37)" end="(290, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(290, 37)" end="(290, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(290, 38)" end="(290, 39)">
                <IdentNode start="(290, 38)" end="(290, 39)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(290, 40)" end="(290, 48)">
                <AtomNode start="(290, 40)" end="(290, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(290, 42)" end="(290, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(290, 42)" end="(290, 46)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(290, 47)" end="(290, 48)">
                    <IdentNode start="(290, 47)" end="(290, 48)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(290, 48)" end="(290, 49)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(291, 5)" end="(291, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(291, 5)" end="(291, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(291, 6)" end="(291, 7)">
                <IdentNode start="(291, 6)" end="(291, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(291, 8)" end="(291, 48)">
                <AtomNode start="(291, 8)" end="(291, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(291, 10)" end="(291, 48)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(291, 10)" end="(291, 19)">
                    <AtomNode start="(291, 10)" end="(291, 11)" leading="" trailing="" val="("/>
                    <NullNode start="(291, 11)" end="(291, 12)">
                      <IdentNode start="(291, 11)" end="(291, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(291, 13)" end="(291, 18)">
                      <AtomNode start="(291, 13)" end="(291, 14)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(291, 15)" end="(291, 18)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(291, 18)" end="(291, 19)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(291, 20)" end="(291, 21)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(291, 22)" end="(291, 48)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(291, 22)" end="(291, 23)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(291, 24)" end="(291, 25)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(291, 26)" end="(291, 48)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(291, 26)" end="(291, 44)">
                        <AtomNode start="(291, 26)" end="(291, 27)" leading="" trailing="" val="("/>
                        <NullNode start="(291, 27)" end="(291, 28)">
                          <IdentNode start="(291, 27)" end="(291, 28)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(291, 29)" end="(291, 43)">
                          <AtomNode start="(291, 29)" end="(291, 30)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(291, 31)" end="(291, 43)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(291, 31)" end="(291, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(291, 33)" end="(291, 34)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(291, 35)" end="(291, 43)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(291, 43)" end="(291, 44)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(291, 45)" end="(291, 46)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(291, 47)" end="(291, 48)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(291, 48)" end="(291, 49)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(292, 5)" end="(292, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(292, 5)" end="(292, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(292, 6)" end="(292, 7)">
                <IdentNode start="(292, 6)" end="(292, 7)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(292, 8)" end="(292, 62)">
                <AtomNode start="(292, 8)" end="(292, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(292, 10)" end="(292, 62)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(292, 10)" end="(292, 19)">
                    <AtomNode start="(292, 10)" end="(292, 11)" leading="" trailing="" val="("/>
                    <NullNode start="(292, 11)" end="(292, 12)">
                      <IdentNode start="(292, 11)" end="(292, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(292, 13)" end="(292, 18)">
                      <AtomNode start="(292, 13)" end="(292, 14)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(292, 15)" end="(292, 18)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(292, 18)" end="(292, 19)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(292, 20)" end="(292, 21)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(292, 22)" end="(292, 62)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(292, 22)" end="(292, 23)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(292, 24)" end="(292, 25)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(292, 26)" end="(292, 62)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(292, 26)" end="(292, 58)">
                        <AtomNode start="(292, 26)" end="(292, 27)" leading="" trailing="" val="("/>
                        <NullNode start="(292, 27)" end="(292, 28)">
                          <IdentNode start="(292, 27)" end="(292, 28)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(292, 29)" end="(292, 57)">
                          <AtomNode start="(292, 29)" end="(292, 30)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(292, 31)" end="(292, 57)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(292, 31)" end="(292, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(292, 33)" end="(292, 34)" leading="" trailing=" " val="&amp;lt;"/>
                            <OtherNode start="(292, 35)" end="(292, 57)" kind="Lean.Parser.Term.proj">
                              <OtherNode start="(292, 35)" end="(292, 50)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(292, 35)" end="(292, 36)" leading="" trailing="" val="("/>
                                <OtherNode start="(292, 36)" end="(292, 49)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(292, 36)" end="(292, 47)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                                  <NullNode start="(292, 48)" end="(292, 49)">
                                    <IdentNode start="(292, 48)" end="(292, 49)" leading="" trailing="" raw_val="f" val="f"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(292, 49)" end="(292, 50)" leading="" trailing="" val=")"/>
                              </OtherNode>
                              <AtomNode start="(292, 50)" end="(292, 51)" leading="" trailing="" val="."/>
                              <IdentNode start="(292, 51)" end="(292, 57)" leading="" trailing="" raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(292, 57)" end="(292, 58)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(292, 59)" end="(292, 60)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(292, 61)" end="(292, 62)" leading="" trailing="" raw_val="γ" val="γ"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(292, 62)" end="(292, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(292, 64)" end="(293, 86)">
            <AtomNode start="(292, 64)" end="(292, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(293, 5)" end="(293, 86)" kind="«term_=_»">
              <OtherNode start="(293, 5)" end="(293, 32)" kind="Lean.Parser.Term.app">
                <OtherNode start="(293, 5)" end="(293, 30)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(293, 5)" end="(293, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(293, 5)" end="(293, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(293, 6)" end="(293, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(293, 6)" end="(293, 17)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                      <NullNode start="(293, 18)" end="(293, 19)">
                        <IdentNode start="(293, 18)" end="(293, 19)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(293, 19)" end="(293, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(293, 20)" end="(293, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(293, 21)" end="(293, 30)" leading="" trailing=" " raw_val="mapFinIdx" val="mapFinIdx" full_name="List.mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(30, 15)" def_end="(30, 24)"/>
                </OtherNode>
                <NullNode start="(293, 31)" end="(293, 32)">
                  <IdentNode start="(293, 31)" end="(293, 32)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(293, 33)" end="(293, 34)" leading="" trailing=" " val="="/>
              <OtherNode start="(293, 35)" end="(293, 86)" kind="Lean.Parser.Term.app">
                <IdentNode start="(293, 35)" end="(293, 46)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                <NullNode start="(293, 47)" end="(293, 86)">
                  <OtherNode start="(293, 47)" end="(293, 86)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(293, 47)" end="(293, 48)" leading="" trailing="" val="("/>
                    <OtherNode start="(293, 48)" end="(293, 85)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(293, 48)" end="(293, 51)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(293, 52)" end="(293, 85)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(293, 52)" end="(293, 57)">
                          <IdentNode start="(293, 52)" end="(293, 53)" leading="" trailing=" " raw_val="i" val="i"/>
                          <IdentNode start="(293, 54)" end="(293, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(293, 56)" end="(293, 57)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(293, 58)" end="(293, 60)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(293, 61)" end="(293, 85)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(293, 61)" end="(293, 62)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(293, 63)" end="(293, 85)">
                            <IdentNode start="(293, 63)" end="(293, 64)" leading="" trailing=" " raw_val="i" val="i"/>
                            <OtherNode start="(293, 65)" end="(293, 74)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(293, 65)" end="(293, 66)" leading="" trailing="" val="("/>
                              <OtherNode start="(293, 66)" end="(293, 73)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(293, 66)" end="(293, 67)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(293, 68)" end="(293, 73)">
                                  <IdentNode start="(293, 68)" end="(293, 69)" leading="" trailing=" " raw_val="i" val="i"/>
                                  <IdentNode start="(293, 70)" end="(293, 71)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(293, 72)" end="(293, 73)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(293, 73)" end="(293, 74)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <OtherNode start="(293, 75)" end="(293, 85)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(293, 75)" end="(293, 76)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(293, 76)" end="(293, 84)">
                                <AtomNode start="(293, 76)" end="(293, 78)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(293, 79)" end="(293, 84)">
                                  <TacticTacticseq1IndentedNode start="(293, 79)" end="(293, 84)">
                                    <NullNode start="(293, 79)" end="(293, 84)">
                                      <OtherNode start="(293, 79)" end="(293, 84)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type ?u.54436&#10;β : Type ?u.54464&#10;γ : Type ?u.54510&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;g : (i : Nat) → β → i &amp;lt; (l.mapFinIdx f).length → γ&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l.length&#10;⊢ i &amp;lt; (l.mapFinIdx f).length" state_after="no goals" tactic="simpa">
                                        <AtomNode start="(293, 79)" end="(293, 84)" leading="" trailing="" val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(293, 84)" end="(293, 85)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(293, 85)" end="(293, 86)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(293, 87)" end="(294, 26)">
          <AtomNode start="(293, 87)" end="(293, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(293, 90)" end="(294, 26)">
            <AtomNode start="(293, 90)" end="(293, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(294, 3)" end="(294, 26)">
              <TacticTacticseq1IndentedNode start="(294, 3)" end="(294, 26)">
                <NullNode start="(294, 3)" end="(294, 26)">
                  <OtherNode start="(294, 3)" end="(294, 26)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;g : (i : Nat) → β → i &amp;lt; (l.mapFinIdx f).length → γ&#10;⊢ (l.mapFinIdx f).mapFinIdx g = l.mapFinIdx fun i a h =&amp;gt; g i (f i a h) ⋯" state_after="no goals" tactic="simp [mapFinIdx_eq_iff]">
                    <AtomNode start="(294, 3)" end="(294, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(294, 8)" end="(294, 26)">
                      <AtomNode start="(294, 8)" end="(294, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(294, 9)" end="(294, 25)">
                        <OtherNode start="(294, 9)" end="(294, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(294, 9)" end="(294, 25)" leading="" trailing="" raw_val="mapFinIdx_eq_iff" val="mapFinIdx_eq_iff" full_name="List.mapFinIdx_eq_iff" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(234, 9)" def_end="(234, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(294, 25)" end="(294, 26)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(296, 1)" end="(304, 16)" name="mapFinIdx_eq_replicate_iff" full_name="List.mapFinIdx_eq_replicate_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(296, 1)" end="(304, 16)" name="mapFinIdx_eq_replicate_iff" full_name="List.mapFinIdx_eq_replicate_iff" _is_private_decl="False">
        <AtomNode start="(296, 1)" end="(296, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(296, 9)" end="(296, 35)">
          <IdentNode start="(296, 9)" end="(296, 35)" leading="" trailing=" " raw_val="mapFinIdx_eq_replicate_iff" val="mapFinIdx_eq_replicate_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(296, 36)" end="(297, 90)">
          <NullNode start="(296, 36)" end="(296, 101)">
            <OtherNode start="(296, 36)" end="(296, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(296, 36)" end="(296, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(296, 37)" end="(296, 38)">
                <IdentNode start="(296, 37)" end="(296, 38)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(296, 39)" end="(296, 47)">
                <AtomNode start="(296, 39)" end="(296, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(296, 41)" end="(296, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(296, 41)" end="(296, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(296, 46)" end="(296, 47)">
                    <IdentNode start="(296, 46)" end="(296, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(296, 47)" end="(296, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(296, 49)" end="(296, 93)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(296, 49)" end="(296, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(296, 50)" end="(296, 51)">
                <IdentNode start="(296, 50)" end="(296, 51)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(296, 52)" end="(296, 92)">
                <AtomNode start="(296, 52)" end="(296, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(296, 54)" end="(296, 92)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(296, 54)" end="(296, 63)">
                    <AtomNode start="(296, 54)" end="(296, 55)" leading="" trailing="" val="("/>
                    <NullNode start="(296, 55)" end="(296, 56)">
                      <IdentNode start="(296, 55)" end="(296, 56)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(296, 57)" end="(296, 62)">
                      <AtomNode start="(296, 57)" end="(296, 58)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(296, 59)" end="(296, 62)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(296, 62)" end="(296, 63)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(296, 64)" end="(296, 65)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(296, 66)" end="(296, 92)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(296, 66)" end="(296, 67)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(296, 68)" end="(296, 69)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(296, 70)" end="(296, 92)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(296, 70)" end="(296, 88)">
                        <AtomNode start="(296, 70)" end="(296, 71)" leading="" trailing="" val="("/>
                        <NullNode start="(296, 71)" end="(296, 72)">
                          <IdentNode start="(296, 71)" end="(296, 72)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(296, 73)" end="(296, 87)">
                          <AtomNode start="(296, 73)" end="(296, 74)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(296, 75)" end="(296, 87)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(296, 75)" end="(296, 76)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(296, 77)" end="(296, 78)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(296, 79)" end="(296, 87)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(296, 87)" end="(296, 88)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(296, 89)" end="(296, 90)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(296, 91)" end="(296, 92)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(296, 92)" end="(296, 93)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(296, 94)" end="(296, 101)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(296, 94)" end="(296, 95)" leading="" trailing="" val="{"/>
              <NullNode start="(296, 95)" end="(296, 96)">
                <IdentNode start="(296, 95)" end="(296, 96)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(296, 97)" end="(296, 100)">
                <AtomNode start="(296, 97)" end="(296, 98)" leading="" trailing=" " val=":"/>
                <IdentNode start="(296, 99)" end="(296, 100)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(296, 100)" end="(296, 101)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(296, 102)" end="(297, 90)">
            <AtomNode start="(296, 102)" end="(296, 103)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(297, 5)" end="(297, 90)" kind="«term_↔_»">
              <OtherNode start="(297, 5)" end="(297, 41)" kind="«term_=_»">
                <OtherNode start="(297, 5)" end="(297, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(297, 5)" end="(297, 16)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                  <NullNode start="(297, 17)" end="(297, 18)">
                    <IdentNode start="(297, 17)" end="(297, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(297, 19)" end="(297, 20)" leading="" trailing=" " val="="/>
                <OtherNode start="(297, 21)" end="(297, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(297, 21)" end="(297, 30)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(297, 31)" end="(297, 41)">
                    <IdentNode start="(297, 31)" end="(297, 39)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <IdentNode start="(297, 40)" end="(297, 41)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(297, 42)" end="(297, 43)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(297, 44)" end="(297, 90)" kind="Lean.Parser.Term.forall">
                <AtomNode start="(297, 44)" end="(297, 45)" leading="" trailing=" " val="∀"/>
                <NullNode start="(297, 46)" end="(297, 74)">
                  <TermExplicitbinderNode start="(297, 46)" end="(297, 55)">
                    <AtomNode start="(297, 46)" end="(297, 47)" leading="" trailing="" val="("/>
                    <NullNode start="(297, 47)" end="(297, 48)">
                      <IdentNode start="(297, 47)" end="(297, 48)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(297, 49)" end="(297, 54)">
                      <AtomNode start="(297, 49)" end="(297, 50)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(297, 51)" end="(297, 54)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(297, 54)" end="(297, 55)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <TermExplicitbinderNode start="(297, 56)" end="(297, 74)">
                    <AtomNode start="(297, 56)" end="(297, 57)" leading="" trailing="" val="("/>
                    <NullNode start="(297, 57)" end="(297, 58)">
                      <IdentNode start="(297, 57)" end="(297, 58)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                    <NullNode start="(297, 59)" end="(297, 73)">
                      <AtomNode start="(297, 59)" end="(297, 60)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(297, 61)" end="(297, 73)" kind="«term_&amp;lt;_»">
                        <IdentNode start="(297, 61)" end="(297, 62)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(297, 63)" end="(297, 64)" leading="" trailing=" " val="&amp;lt;"/>
                        <IdentNode start="(297, 65)" end="(297, 73)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(297, 73)" end="(297, 74)" leading="" trailing="" val=")"/>
                  </TermExplicitbinderNode>
                </NullNode>
                <NullNode/>
                <AtomNode start="(297, 74)" end="(297, 75)" leading="" trailing=" " val=","/>
                <OtherNode start="(297, 76)" end="(297, 90)" kind="«term_=_»">
                  <OtherNode start="(297, 76)" end="(297, 86)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(297, 76)" end="(297, 77)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(297, 78)" end="(297, 86)">
                      <IdentNode start="(297, 78)" end="(297, 79)" leading="" trailing=" " raw_val="i" val="i"/>
                      <OtherNode start="(297, 80)" end="(297, 84)" kind="«term__[_]»">
                        <IdentNode start="(297, 80)" end="(297, 81)" leading="" trailing="" raw_val="l" val="l"/>
                        <AtomNode start="(297, 81)" end="(297, 82)" leading="" trailing="" val="["/>
                        <IdentNode start="(297, 82)" end="(297, 83)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(297, 83)" end="(297, 84)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                      <IdentNode start="(297, 85)" end="(297, 86)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(297, 87)" end="(297, 88)" leading="" trailing=" " val="="/>
                  <IdentNode start="(297, 89)" end="(297, 90)" leading="" trailing=" " raw_val="b" val="b"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(297, 91)" end="(304, 16)">
          <AtomNode start="(297, 91)" end="(297, 93)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(297, 94)" end="(304, 16)">
            <AtomNode start="(297, 94)" end="(297, 96)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(298, 3)" end="(304, 16)">
              <TacticTacticseq1IndentedNode start="(298, 3)" end="(304, 16)">
                <NullNode start="(298, 3)" end="(304, 16)">
                  <OtherNode start="(298, 3)" end="(298, 42)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;⊢ l.mapFinIdx f = replicate l.length b ↔ ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;⊢ (l.length = l.length ∧ ∀ (b_1 : β), b_1 ∈ l.mapFinIdx f → b_1 = b) ↔ ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b" tactic="rw [eq_replicate_iff, length_mapFinIdx]">
                    <AtomNode start="(298, 3)" end="(298, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(298, 6)" end="(298, 42)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(298, 6)" end="(298, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(298, 7)" end="(298, 41)">
                        <OtherNode start="(298, 7)" end="(298, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(298, 7)" end="(298, 23)" leading="" trailing="" raw_val="eq_replicate_iff" val="eq_replicate_iff" full_name="List.eq_replicate_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(298, 23)" end="(298, 24)" leading="" trailing=" " val=","/>
                        <OtherNode start="(298, 25)" end="(298, 41)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(298, 25)" end="(298, 41)" leading="" trailing="" raw_val="length_mapFinIdx" val="length_mapFinIdx" full_name="List.length_mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(104, 17)" def_end="(104, 33)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(298, 41)" end="(298, 42)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(299, 3)" end="(299, 59)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;⊢ (l.length = l.length ∧ ∀ (b_1 : β), b_1 ∈ l.mapFinIdx f → b_1 = b) ↔ ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;⊢ (∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] x_1 = b_1 → b_1 = b) ↔&#10;    ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b" tactic="simp only [mem_mapFinIdx, forall_exists_index, true_and]">
                    <AtomNode start="(299, 3)" end="(299, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(299, 8)" end="(299, 12)">
                      <AtomNode start="(299, 8)" end="(299, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(299, 13)" end="(299, 59)">
                      <AtomNode start="(299, 13)" end="(299, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(299, 14)" end="(299, 58)">
                        <OtherNode start="(299, 14)" end="(299, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(299, 14)" end="(299, 27)" leading="" trailing="" raw_val="mem_mapFinIdx" val="mem_mapFinIdx" full_name="List.mem_mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(204, 17)" def_end="(204, 30)"/>
                        </OtherNode>
                        <AtomNode start="(299, 27)" end="(299, 28)" leading="" trailing=" " val=","/>
                        <OtherNode start="(299, 29)" end="(299, 48)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(299, 29)" end="(299, 48)" leading="" trailing="" raw_val="forall_exists_index" val="forall_exists_index" full_name="forall_exists_index" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(299, 48)" end="(299, 49)" leading="" trailing=" " val=","/>
                        <OtherNode start="(299, 50)" end="(299, 58)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(299, 50)" end="(299, 58)" leading="" trailing="" raw_val="true_and" val="true_and" full_name="true_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(299, 58)" end="(299, 59)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(300, 3)" end="(300, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;⊢ (∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] x_1 = b_1 → b_1 = b) ↔&#10;    ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b" state_after="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;⊢ (∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] x_1 = b_1 → b_1 = b) →&#10;    ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b&#10;&#10;case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b) →&#10;    ∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] x_1 = b_1 → b_1 = b" tactic="constructor">
                    <AtomNode start="(300, 3)" end="(300, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(301, 3)" end="(302, 33)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;⊢ (∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] x_1 = b_1 → b_1 = b) →&#10;    ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b&#10;&#10;case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b) →&#10;    ∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] x_1 = b_1 → b_1 = b" state_after="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b) →&#10;    ∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] x_1 = b_1 → b_1 = b" tactic="· intro w i h&#10;  exact w (f i l[i] h) i h rfl">
                    <OtherNode start="(301, 3)" end="(301, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(301, 3)" end="(301, 4)" kind="patternIgnore">
                        <OtherNode start="(301, 3)" end="(301, 4)" kind="token.«· »">
                          <AtomNode start="(301, 3)" end="(301, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(301, 5)" end="(302, 33)">
                      <TacticTacticseq1IndentedNode start="(301, 5)" end="(302, 33)">
                        <NullNode start="(301, 5)" end="(302, 33)">
                          <OtherNode start="(301, 5)" end="(301, 16)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;⊢ (∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] x_1 = b_1 → b_1 = b) →&#10;    ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b" state_after="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;w : ∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] x_1 = b_1 → b_1 = b&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f i l[i] h = b" tactic="intro w i h">
                            <AtomNode start="(301, 5)" end="(301, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(301, 11)" end="(301, 16)">
                              <IdentNode start="(301, 11)" end="(301, 12)" leading="" trailing=" " raw_val="w" val="w"/>
                              <IdentNode start="(301, 13)" end="(301, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                              <IdentNode start="(301, 15)" end="(301, 16)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(302, 5)" end="(302, 33)" kind="Lean.Parser.Tactic.exact" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;w : ∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] x_1 = b_1 → b_1 = b&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f i l[i] h = b" state_after="no goals" tactic="exact w (f i l[i] h) i h rfl">
                            <AtomNode start="(302, 5)" end="(302, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(302, 11)" end="(302, 33)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(302, 11)" end="(302, 12)" leading="" trailing=" " raw_val="w" val="w"/>
                              <NullNode start="(302, 13)" end="(302, 33)">
                                <OtherNode start="(302, 13)" end="(302, 25)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(302, 13)" end="(302, 14)" leading="" trailing="" val="("/>
                                  <OtherNode start="(302, 14)" end="(302, 24)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(302, 14)" end="(302, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <NullNode start="(302, 16)" end="(302, 24)">
                                      <IdentNode start="(302, 16)" end="(302, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                                      <OtherNode start="(302, 18)" end="(302, 22)" kind="«term__[_]»">
                                        <IdentNode start="(302, 18)" end="(302, 19)" leading="" trailing="" raw_val="l" val="l"/>
                                        <AtomNode start="(302, 19)" end="(302, 20)" leading="" trailing="" val="["/>
                                        <IdentNode start="(302, 20)" end="(302, 21)" leading="" trailing="" raw_val="i" val="i"/>
                                        <AtomNode start="(302, 21)" end="(302, 22)" leading="" trailing=" " val="]"/>
                                      </OtherNode>
                                      <IdentNode start="(302, 23)" end="(302, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(302, 24)" end="(302, 25)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <IdentNode start="(302, 26)" end="(302, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                                <IdentNode start="(302, 28)" end="(302, 29)" leading="" trailing=" " raw_val="h" val="h"/>
                                <IdentNode start="(302, 30)" end="(302, 33)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(303, 3)" end="(304, 16)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b) →&#10;    ∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] x_1 = b_1 → b_1 = b" state_after="no goals" tactic="· rintro w b i h rfl&#10;  exact w i h">
                    <OtherNode start="(303, 3)" end="(303, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(303, 3)" end="(303, 4)" kind="patternIgnore">
                        <OtherNode start="(303, 3)" end="(303, 4)" kind="token.«· »">
                          <AtomNode start="(303, 3)" end="(303, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(303, 5)" end="(304, 16)">
                      <TacticTacticseq1IndentedNode start="(303, 5)" end="(304, 16)">
                        <NullNode start="(303, 5)" end="(304, 16)">
                          <OtherNode start="(303, 5)" end="(303, 23)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b) →&#10;    ∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] x_1 = b_1 → b_1 = b" state_after="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f i l[i] h = b" tactic="rintro w b i h rfl">
                            <AtomNode start="(303, 5)" end="(303, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(303, 12)" end="(303, 23)">
                              <OtherNode start="(303, 12)" end="(303, 13)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(303, 12)" end="(303, 13)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(303, 12)" end="(303, 13)" leading="" trailing=" " raw_val="w" val="w"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(303, 14)" end="(303, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(303, 14)" end="(303, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(303, 14)" end="(303, 15)" leading="" trailing=" " raw_val="b" val="b"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(303, 16)" end="(303, 17)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(303, 16)" end="(303, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(303, 16)" end="(303, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(303, 18)" end="(303, 19)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(303, 18)" end="(303, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(303, 18)" end="(303, 19)" leading="" trailing=" " raw_val="h" val="h"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(303, 20)" end="(303, 23)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(303, 20)" end="(303, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(303, 20)" end="(303, 23)" leading="" trailing="&#10;    " raw_val="rfl" val="rfl"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(304, 5)" end="(304, 16)" kind="Lean.Parser.Tactic.exact" state_before="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;b : β&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = b&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f i l[i] h = b" state_after="no goals" tactic="exact w i h">
                            <AtomNode start="(304, 5)" end="(304, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(304, 11)" end="(304, 16)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(304, 11)" end="(304, 12)" leading="" trailing=" " raw_val="w" val="w"/>
                              <NullNode start="(304, 13)" end="(304, 16)">
                                <IdentNode start="(304, 13)" end="(304, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                                <IdentNode start="(304, 15)" end="(304, 16)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(306, 1)" end="(312, 8)" name="mapFinIdx_reverse" full_name="List.mapFinIdx_reverse">
      <CommandDeclmodifiersNode start="(306, 1)" end="(306, 8)">
        <NullNode/>
        <NullNode start="(306, 1)" end="(306, 8)">
          <OtherNode start="(306, 1)" end="(306, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(306, 1)" end="(306, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(306, 3)" end="(306, 7)">
              <OtherNode start="(306, 3)" end="(306, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(306, 3)" end="(306, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(306, 3)" end="(306, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(306, 7)" end="(306, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(306, 9)" end="(312, 8)" name="mapFinIdx_reverse" full_name="List.mapFinIdx_reverse" _is_private_decl="False">
        <AtomNode start="(306, 9)" end="(306, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(306, 17)" end="(306, 34)">
          <IdentNode start="(306, 17)" end="(306, 34)" leading="" trailing=" " raw_val="mapFinIdx_reverse" val="mapFinIdx_reverse"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(306, 35)" end="(308, 83)">
          <NullNode start="(306, 35)" end="(306, 100)">
            <OtherNode start="(306, 35)" end="(306, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(306, 35)" end="(306, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(306, 36)" end="(306, 37)">
                <IdentNode start="(306, 36)" end="(306, 37)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(306, 38)" end="(306, 46)">
                <AtomNode start="(306, 38)" end="(306, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(306, 40)" end="(306, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(306, 40)" end="(306, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(306, 45)" end="(306, 46)">
                    <IdentNode start="(306, 45)" end="(306, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(306, 46)" end="(306, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(306, 48)" end="(306, 100)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(306, 48)" end="(306, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(306, 49)" end="(306, 50)">
                <IdentNode start="(306, 49)" end="(306, 50)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(306, 51)" end="(306, 99)">
                <AtomNode start="(306, 51)" end="(306, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(306, 53)" end="(306, 99)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(306, 53)" end="(306, 62)">
                    <AtomNode start="(306, 53)" end="(306, 54)" leading="" trailing="" val="("/>
                    <NullNode start="(306, 54)" end="(306, 55)">
                      <IdentNode start="(306, 54)" end="(306, 55)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(306, 56)" end="(306, 61)">
                      <AtomNode start="(306, 56)" end="(306, 57)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(306, 58)" end="(306, 61)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(306, 61)" end="(306, 62)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(306, 63)" end="(306, 64)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(306, 65)" end="(306, 99)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(306, 65)" end="(306, 66)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(306, 67)" end="(306, 68)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(306, 69)" end="(306, 99)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(306, 69)" end="(306, 95)">
                        <AtomNode start="(306, 69)" end="(306, 70)" leading="" trailing="" val="("/>
                        <NullNode start="(306, 70)" end="(306, 71)">
                          <IdentNode start="(306, 70)" end="(306, 71)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(306, 72)" end="(306, 94)">
                          <AtomNode start="(306, 72)" end="(306, 73)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(306, 74)" end="(306, 94)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(306, 74)" end="(306, 75)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(306, 76)" end="(306, 77)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(306, 78)" end="(306, 94)" leading="" trailing="" raw_val="l.reverse.length" val="l.reverse.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(306, 94)" end="(306, 95)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(306, 96)" end="(306, 97)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(306, 98)" end="(306, 99)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(306, 99)" end="(306, 100)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(306, 101)" end="(308, 83)">
            <AtomNode start="(306, 101)" end="(306, 102)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(307, 5)" end="(308, 83)" kind="«term_=_»">
              <OtherNode start="(307, 5)" end="(307, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(307, 5)" end="(307, 24)" leading="" trailing=" " raw_val="l.reverse.mapFinIdx" val="l.reverse.mapFinIdx"/>
                <NullNode start="(307, 25)" end="(307, 26)">
                  <IdentNode start="(307, 25)" end="(307, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(307, 27)" end="(307, 28)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(308, 7)" end="(308, 83)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(308, 7)" end="(308, 75)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(308, 7)" end="(308, 8)" leading="" trailing="" val="("/>
                  <OtherNode start="(308, 8)" end="(308, 74)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(308, 8)" end="(308, 19)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                    <NullNode start="(308, 20)" end="(308, 74)">
                      <OtherNode start="(308, 20)" end="(308, 74)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(308, 20)" end="(308, 21)" leading="" trailing="" val="("/>
                        <OtherNode start="(308, 21)" end="(308, 73)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(308, 21)" end="(308, 24)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(308, 25)" end="(308, 73)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(308, 25)" end="(308, 30)">
                              <IdentNode start="(308, 25)" end="(308, 26)" leading="" trailing=" " raw_val="i" val="i"/>
                              <IdentNode start="(308, 27)" end="(308, 28)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(308, 29)" end="(308, 30)" leading="" trailing=" " raw_val="h" val="h"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(308, 31)" end="(308, 33)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(308, 34)" end="(308, 73)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(308, 34)" end="(308, 35)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(308, 36)" end="(308, 73)">
                                <OtherNode start="(308, 36)" end="(308, 54)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(308, 36)" end="(308, 37)" leading="" trailing="" val="("/>
                                  <OtherNode start="(308, 37)" end="(308, 53)" kind="«term_-_»">
                                    <OtherNode start="(308, 37)" end="(308, 49)" kind="«term_-_»">
                                      <IdentNode start="(308, 37)" end="(308, 45)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                      <AtomNode start="(308, 46)" end="(308, 47)" leading="" trailing=" " val="-"/>
                                      <OtherNode start="(308, 48)" end="(308, 49)" kind="num">
                                        <AtomNode start="(308, 48)" end="(308, 49)" leading="" trailing=" " val="1"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <AtomNode start="(308, 50)" end="(308, 51)" leading="" trailing=" " val="-"/>
                                    <IdentNode start="(308, 52)" end="(308, 53)" leading="" trailing="" raw_val="i" val="i"/>
                                  </OtherNode>
                                  <AtomNode start="(308, 53)" end="(308, 54)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <IdentNode start="(308, 55)" end="(308, 56)" leading="" trailing=" " raw_val="a" val="a"/>
                                <OtherNode start="(308, 57)" end="(308, 73)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(308, 57)" end="(308, 58)" leading="" trailing="" val="("/>
                                  <TermBytacticNode start="(308, 58)" end="(308, 72)">
                                    <AtomNode start="(308, 58)" end="(308, 60)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(308, 61)" end="(308, 72)">
                                      <TacticTacticseq1IndentedNode start="(308, 61)" end="(308, 72)">
                                        <NullNode start="(308, 61)" end="(308, 72)">
                                          <OtherNode start="(308, 61)" end="(308, 65)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.56376&#10;β : Type ?u.56406&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.reverse.length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l.length&#10;⊢ l.length - 1 - i &amp;lt; l.reverse.length" state_after="α : Type ?u.56376&#10;β : Type ?u.56406&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.reverse.length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l.length&#10;⊢ l.length - 1 - i &amp;lt; l.length" tactic="simp">
                                            <AtomNode start="(308, 61)" end="(308, 65)" leading="" trailing="" val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                          <AtomNode start="(308, 65)" end="(308, 66)" leading="" trailing=" " val=";"/>
                                          <OtherNode start="(308, 67)" end="(308, 72)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.56376&#10;β : Type ?u.56406&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.reverse.length → β&#10;i : Nat&#10;a : α&#10;h : i &amp;lt; l.length&#10;⊢ l.length - 1 - i &amp;lt; l.length" state_after="no goals" tactic="omega">
                                            <AtomNode start="(308, 67)" end="(308, 72)" leading="" trailing="" val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                  <AtomNode start="(308, 72)" end="(308, 73)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(308, 73)" end="(308, 74)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(308, 74)" end="(308, 75)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(308, 75)" end="(308, 76)" leading="" trailing="" val="."/>
                <IdentNode start="(308, 76)" end="(308, 83)" leading="" trailing=" " raw_val="reverse" val="reverse" full_name="List.reverse" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(308, 84)" end="(312, 8)">
          <AtomNode start="(308, 84)" end="(308, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(308, 87)" end="(312, 8)">
            <AtomNode start="(308, 87)" end="(308, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(309, 3)" end="(312, 8)">
              <TacticTacticseq1IndentedNode start="(309, 3)" end="(312, 8)">
                <NullNode start="(309, 3)" end="(312, 8)">
                  <OtherNode start="(309, 3)" end="(309, 26)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.reverse.length → β&#10;⊢ l.reverse.mapFinIdx f = (l.mapFinIdx fun i a h =&amp;gt; f (l.length - 1 - i) a ⋯).reverse" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.reverse.length → β&#10;⊢ ∀ (i : Nat) (h : i &amp;lt; l.length),&#10;    f (l.length - 1 - (l.length - 1 - i)) l[l.length - 1 - i] ⋯ = f i l[l.length - 1 - i] ⋯" tactic="simp [mapFinIdx_eq_iff]">
                    <AtomNode start="(309, 3)" end="(309, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(309, 8)" end="(309, 26)">
                      <AtomNode start="(309, 8)" end="(309, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(309, 9)" end="(309, 25)">
                        <OtherNode start="(309, 9)" end="(309, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(309, 9)" end="(309, 25)" leading="" trailing="" raw_val="mapFinIdx_eq_iff" val="mapFinIdx_eq_iff" full_name="List.mapFinIdx_eq_iff" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(234, 9)" def_end="(234, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(309, 25)" end="(309, 26)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(310, 3)" end="(310, 12)" kind="Lean.Parser.Tactic.intro" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.reverse.length → β&#10;⊢ ∀ (i : Nat) (h : i &amp;lt; l.length),&#10;    f (l.length - 1 - (l.length - 1 - i)) l[l.length - 1 - i] ⋯ = f i l[l.length - 1 - i] ⋯" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.reverse.length → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f (l.length - 1 - (l.length - 1 - i)) l[l.length - 1 - i] ⋯ = f i l[l.length - 1 - i] ⋯" tactic="intro i h">
                    <AtomNode start="(310, 3)" end="(310, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(310, 9)" end="(310, 12)">
                      <IdentNode start="(310, 9)" end="(310, 10)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(310, 11)" end="(310, 12)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(311, 3)" end="(311, 8)" kind="Lean.Parser.Tactic.congr" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.reverse.length → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f (l.length - 1 - (l.length - 1 - i)) l[l.length - 1 - i] ⋯ = f i l[l.length - 1 - i] ⋯" state_after="case e_i&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.reverse.length → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ l.length - 1 - (l.length - 1 - i) = i" tactic="congr">
                    <AtomNode start="(311, 3)" end="(311, 8)" leading="" trailing="&#10;  " val="congr"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(312, 3)" end="(312, 8)" kind="Lean.Parser.Tactic.omega" state_before="case e_i&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.reverse.length → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ l.length - 1 - (l.length - 1 - i) = i" state_after="no goals" tactic="omega">
                    <AtomNode start="(312, 3)" end="(312, 8)" leading="" trailing="&#10;&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(314, 1)" end="(314, 18)" comment="### mapIdx -/">
      <AtomNode start="(314, 1)" end="(314, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(314, 5)" end="(314, 18)" leading="" trailing="&#10;&#10;" val="### mapIdx -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(316, 1)" end="(318, 6)" name="mapIdx_nil" full_name="List.mapIdx_nil">
      <CommandDeclmodifiersNode start="(316, 1)" end="(316, 8)">
        <NullNode/>
        <NullNode start="(316, 1)" end="(316, 8)">
          <OtherNode start="(316, 1)" end="(316, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(316, 1)" end="(316, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(316, 3)" end="(316, 7)">
              <OtherNode start="(316, 3)" end="(316, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(316, 3)" end="(316, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(316, 3)" end="(316, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(316, 7)" end="(316, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(317, 1)" end="(318, 6)" name="mapIdx_nil" full_name="List.mapIdx_nil" _is_private_decl="False">
        <AtomNode start="(317, 1)" end="(317, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(317, 9)" end="(317, 19)">
          <IdentNode start="(317, 9)" end="(317, 19)" leading="" trailing=" " raw_val="mapIdx_nil" val="mapIdx_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(317, 20)" end="(317, 56)">
          <NullNode start="(317, 20)" end="(317, 37)">
            <OtherNode start="(317, 20)" end="(317, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(317, 20)" end="(317, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(317, 21)" end="(317, 22)">
                <IdentNode start="(317, 21)" end="(317, 22)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(317, 23)" end="(317, 36)">
                <AtomNode start="(317, 23)" end="(317, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(317, 25)" end="(317, 36)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(317, 25)" end="(317, 28)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(317, 29)" end="(317, 30)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(317, 31)" end="(317, 36)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(317, 31)" end="(317, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(317, 33)" end="(317, 34)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(317, 35)" end="(317, 36)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(317, 36)" end="(317, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(317, 38)" end="(317, 56)">
            <AtomNode start="(317, 38)" end="(317, 39)" leading="" trailing=" " val=":"/>
            <OtherNode start="(317, 40)" end="(317, 56)" kind="«term_=_»">
              <OtherNode start="(317, 40)" end="(317, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(317, 40)" end="(317, 46)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                <NullNode start="(317, 47)" end="(317, 51)">
                  <IdentNode start="(317, 47)" end="(317, 48)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(317, 49)" end="(317, 51)" kind="«term[_]»">
                    <AtomNode start="(317, 49)" end="(317, 50)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(317, 50)" end="(317, 51)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(317, 52)" end="(317, 53)" leading="" trailing=" " val="="/>
              <OtherNode start="(317, 54)" end="(317, 56)" kind="«term[_]»">
                <AtomNode start="(317, 54)" end="(317, 55)" leading="" trailing="" val="["/>
                <NullNode/>
                <AtomNode start="(317, 55)" end="(317, 56)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(317, 57)" end="(318, 6)">
          <AtomNode start="(317, 57)" end="(317, 59)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(318, 3)" end="(318, 6)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(320, 1)" end="(325, 88)" name="mapIdx_go_length" full_name="List.mapIdx_go_length">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(320, 1)" end="(325, 88)" name="mapIdx_go_length" full_name="List.mapIdx_go_length" _is_private_decl="False">
        <AtomNode start="(320, 1)" end="(320, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(320, 9)" end="(320, 25)">
          <IdentNode start="(320, 9)" end="(320, 25)" leading="" trailing=" " raw_val="mapIdx_go_length" val="mapIdx_go_length"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(320, 26)" end="(321, 53)">
          <NullNode start="(320, 26)" end="(320, 41)">
            <OtherNode start="(320, 26)" end="(320, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(320, 26)" end="(320, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(320, 27)" end="(320, 30)">
                <IdentNode start="(320, 27)" end="(320, 30)" leading="" trailing=" " raw_val="acc" val="acc"/>
              </NullNode>
              <NullNode start="(320, 31)" end="(320, 40)">
                <AtomNode start="(320, 31)" end="(320, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(320, 33)" end="(320, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(320, 33)" end="(320, 38)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(320, 39)" end="(320, 40)">
                    <IdentNode start="(320, 39)" end="(320, 40)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(320, 40)" end="(320, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(320, 42)" end="(321, 53)">
            <AtomNode start="(320, 42)" end="(320, 43)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(321, 5)" end="(321, 53)" kind="«term_=_»">
              <OtherNode start="(321, 5)" end="(321, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(321, 5)" end="(321, 11)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(321, 12)" end="(321, 31)">
                  <OtherNode start="(321, 12)" end="(321, 31)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(321, 12)" end="(321, 13)" leading="" trailing="" val="("/>
                    <OtherNode start="(321, 13)" end="(321, 30)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(321, 13)" end="(321, 22)" leading="" trailing=" " raw_val="mapIdx.go" val="mapIdx.go" full_name="List.mapIdx.go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(50, 17)" def_end="(50, 19)"/>
                      <NullNode start="(321, 23)" end="(321, 30)">
                        <IdentNode start="(321, 23)" end="(321, 24)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(321, 25)" end="(321, 26)" leading="" trailing=" " raw_val="l" val="l"/>
                        <IdentNode start="(321, 27)" end="(321, 30)" leading="" trailing="" raw_val="acc" val="acc"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(321, 30)" end="(321, 31)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(321, 32)" end="(321, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(321, 34)" end="(321, 53)" kind="«term_+_»">
                <OtherNode start="(321, 34)" end="(321, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(321, 34)" end="(321, 40)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(321, 41)" end="(321, 42)">
                    <IdentNode start="(321, 41)" end="(321, 42)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(321, 43)" end="(321, 44)" leading="" trailing=" " val="+"/>
                <IdentNode start="(321, 45)" end="(321, 53)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(321, 54)" end="(325, 88)">
          <AtomNode start="(321, 54)" end="(321, 56)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(321, 57)" end="(325, 88)">
            <AtomNode start="(321, 57)" end="(321, 59)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(322, 3)" end="(325, 88)">
              <TacticTacticseq1IndentedNode start="(322, 3)" end="(325, 88)">
                <NullNode start="(322, 3)" end="(325, 88)">
                  <OtherNode start="(322, 3)" end="(325, 88)" kind="Lean.Parser.Tactic.induction" state_before="β : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α✝ → β&#10;l : List α✝&#10;acc : Array β&#10;⊢ (mapIdx.go f l acc).length = l.length + acc.size" state_after="no goals" tactic="induction l generalizing acc with&#10;| nil =&amp;gt; simp only [mapIdx.go, length_nil, Nat.zero_add]&#10;| cons _ _ ih =&amp;gt;&#10;  simp only [mapIdx.go, ih, Array.size_push, Nat.add_succ, length_cons, Nat.add_comm]">
                    <AtomNode start="(322, 3)" end="(322, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(322, 13)" end="(322, 14)">
                      <OtherNode start="(322, 13)" end="(322, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(322, 13)" end="(322, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(322, 15)" end="(322, 31)">
                      <AtomNode start="(322, 15)" end="(322, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(322, 28)" end="(322, 31)">
                        <IdentNode start="(322, 28)" end="(322, 31)" leading="" trailing=" " raw_val="acc" val="acc"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(322, 32)" end="(325, 88)">
                      <OtherNode start="(322, 32)" end="(325, 88)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(322, 32)" end="(322, 36)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(323, 3)" end="(325, 88)">
                          <OtherNode start="(323, 3)" end="(323, 59)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(323, 3)" end="(323, 8)">
                              <OtherNode start="(323, 3)" end="(323, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(323, 3)" end="(323, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(323, 5)" end="(323, 8)">
                                  <NullNode/>
                                  <IdentNode start="(323, 5)" end="(323, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(323, 9)" end="(323, 59)">
                              <AtomNode start="(323, 9)" end="(323, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(323, 12)" end="(323, 59)">
                                <TacticTacticseq1IndentedNode start="(323, 12)" end="(323, 59)">
                                  <NullNode start="(323, 12)" end="(323, 59)">
                                    <OtherNode start="(323, 12)" end="(323, 59)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;β : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α✝ → β&#10;acc : Array β&#10;⊢ (mapIdx.go f [] acc).length = [].length + acc.size" state_after="no goals" tactic="simp only [mapIdx.go, length_nil, Nat.zero_add]">
                                      <AtomNode start="(323, 12)" end="(323, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(323, 17)" end="(323, 21)">
                                        <AtomNode start="(323, 17)" end="(323, 21)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(323, 22)" end="(323, 59)">
                                        <AtomNode start="(323, 22)" end="(323, 23)" leading="" trailing="" val="["/>
                                        <NullNode start="(323, 23)" end="(323, 58)">
                                          <OtherNode start="(323, 23)" end="(323, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(323, 23)" end="(323, 32)" leading="" trailing="" raw_val="mapIdx.go" val="mapIdx.go" full_name="List.mapIdx.go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(50, 17)" def_end="(50, 19)"/>
                                          </OtherNode>
                                          <AtomNode start="(323, 32)" end="(323, 33)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(323, 34)" end="(323, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(323, 34)" end="(323, 44)" leading="" trailing="" raw_val="length_nil" val="length_nil" full_name="List.length_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(323, 44)" end="(323, 45)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(323, 46)" end="(323, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(323, 46)" end="(323, 58)" leading="" trailing="" raw_val="Nat.zero_add" val="Nat.zero_add" full_name="Nat.zero_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(323, 58)" end="(323, 59)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(324, 3)" end="(325, 88)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(324, 3)" end="(324, 16)">
                              <OtherNode start="(324, 3)" end="(324, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(324, 3)" end="(324, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(324, 5)" end="(324, 9)">
                                  <NullNode/>
                                  <IdentNode start="(324, 5)" end="(324, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(324, 10)" end="(324, 16)">
                                  <TermHoleNode start="(324, 10)" end="(324, 11)">
                                    <AtomNode start="(324, 10)" end="(324, 11)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(324, 12)" end="(324, 13)">
                                    <AtomNode start="(324, 12)" end="(324, 13)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <IdentNode start="(324, 14)" end="(324, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(324, 17)" end="(325, 88)">
                              <AtomNode start="(324, 17)" end="(324, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(325, 5)" end="(325, 88)">
                                <TacticTacticseq1IndentedNode start="(325, 5)" end="(325, 88)">
                                  <NullNode start="(325, 5)" end="(325, 88)">
                                    <OtherNode start="(325, 5)" end="(325, 88)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;β : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α✝ → β&#10;head✝ : α✝&#10;tail✝ : List α✝&#10;ih : ∀ {acc : Array β}, (mapIdx.go f tail✝ acc).length = tail✝.length + acc.size&#10;acc : Array β&#10;⊢ (mapIdx.go f (head✝ :: tail✝) acc).length = (head✝ :: tail✝).length + acc.size" state_after="no goals" tactic="simp only [mapIdx.go, ih, Array.size_push, Nat.add_succ, length_cons, Nat.add_comm]">
                                      <AtomNode start="(325, 5)" end="(325, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(325, 10)" end="(325, 14)">
                                        <AtomNode start="(325, 10)" end="(325, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(325, 15)" end="(325, 88)">
                                        <AtomNode start="(325, 15)" end="(325, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(325, 16)" end="(325, 87)">
                                          <OtherNode start="(325, 16)" end="(325, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(325, 16)" end="(325, 25)" leading="" trailing="" raw_val="mapIdx.go" val="mapIdx.go" full_name="List.mapIdx.go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(50, 17)" def_end="(50, 19)"/>
                                          </OtherNode>
                                          <AtomNode start="(325, 25)" end="(325, 26)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(325, 27)" end="(325, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(325, 27)" end="(325, 29)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(325, 29)" end="(325, 30)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(325, 31)" end="(325, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(325, 31)" end="(325, 46)" leading="" trailing="" raw_val="Array.size_push" val="Array.size_push" full_name="Array.size_push" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(325, 46)" end="(325, 47)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(325, 48)" end="(325, 60)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(325, 48)" end="(325, 60)" leading="" trailing="" raw_val="Nat.add_succ" val="Nat.add_succ" full_name="Nat.add_succ" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(325, 60)" end="(325, 61)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(325, 62)" end="(325, 73)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(325, 62)" end="(325, 73)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(325, 73)" end="(325, 74)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(325, 75)" end="(325, 87)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(325, 75)" end="(325, 87)" leading="" trailing="" raw_val="Nat.add_comm" val="Nat.add_comm" full_name="Nat.add_comm" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(325, 87)" end="(325, 88)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(327, 1)" end="(334, 10)" name="length_mapIdx_go" full_name="List.length_mapIdx_go">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(327, 1)" end="(334, 10)" name="length_mapIdx_go" full_name="List.length_mapIdx_go" _is_private_decl="False">
        <AtomNode start="(327, 1)" end="(327, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(327, 9)" end="(327, 25)">
          <IdentNode start="(327, 9)" end="(327, 25)" leading="" trailing=" " raw_val="length_mapIdx_go" val="length_mapIdx_go"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(327, 26)" end="(328, 53)">
          <NullNode/>
          <TermTypespecNode start="(327, 26)" end="(328, 53)">
            <AtomNode start="(327, 26)" end="(327, 27)" leading="" trailing=" " val=":"/>
            <OtherNode start="(327, 28)" end="(328, 53)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(327, 28)" end="(327, 29)" leading="" trailing=" " val="∀"/>
              <NullNode start="(327, 30)" end="(327, 58)">
                <OtherNode start="(327, 30)" end="(327, 42)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(327, 30)" end="(327, 31)" leading="" trailing="" val="{"/>
                  <NullNode start="(327, 31)" end="(327, 32)">
                    <IdentNode start="(327, 31)" end="(327, 32)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(327, 33)" end="(327, 41)">
                    <AtomNode start="(327, 33)" end="(327, 34)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(327, 35)" end="(327, 41)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(327, 35)" end="(327, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(327, 40)" end="(327, 41)">
                        <IdentNode start="(327, 40)" end="(327, 41)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(327, 41)" end="(327, 42)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(327, 43)" end="(327, 58)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(327, 43)" end="(327, 44)" leading="" trailing="" val="{"/>
                  <NullNode start="(327, 44)" end="(327, 47)">
                    <IdentNode start="(327, 44)" end="(327, 47)" leading="" trailing=" " raw_val="acc" val="acc"/>
                  </NullNode>
                  <NullNode start="(327, 48)" end="(327, 57)">
                    <AtomNode start="(327, 48)" end="(327, 49)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(327, 50)" end="(327, 57)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(327, 50)" end="(327, 55)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(327, 56)" end="(327, 57)">
                        <IdentNode start="(327, 56)" end="(327, 57)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(327, 57)" end="(327, 58)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(327, 58)" end="(327, 59)" leading="" trailing="&#10;    " val=","/>
              <OtherNode start="(328, 5)" end="(328, 53)" kind="«term_=_»">
                <OtherNode start="(328, 5)" end="(328, 31)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(328, 5)" end="(328, 24)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(328, 5)" end="(328, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(328, 6)" end="(328, 23)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(328, 6)" end="(328, 15)" leading="" trailing=" " raw_val="mapIdx.go" val="mapIdx.go" full_name="List.mapIdx.go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(50, 17)" def_end="(50, 19)"/>
                      <NullNode start="(328, 16)" end="(328, 23)">
                        <IdentNode start="(328, 16)" end="(328, 17)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(328, 18)" end="(328, 19)" leading="" trailing=" " raw_val="l" val="l"/>
                        <IdentNode start="(328, 20)" end="(328, 23)" leading="" trailing="" raw_val="acc" val="acc"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(328, 23)" end="(328, 24)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(328, 24)" end="(328, 25)" leading="" trailing="" val="."/>
                  <IdentNode start="(328, 25)" end="(328, 31)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <AtomNode start="(328, 32)" end="(328, 33)" leading="" trailing=" " val="="/>
                <OtherNode start="(328, 34)" end="(328, 53)" kind="«term_+_»">
                  <IdentNode start="(328, 34)" end="(328, 42)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                  <AtomNode start="(328, 43)" end="(328, 44)" leading="" trailing=" " val="+"/>
                  <IdentNode start="(328, 45)" end="(328, 53)" leading="" trailing="&#10;  " raw_val="acc.size" val="acc.size"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(329, 3)" end="(334, 10)">
          <OtherNode start="(329, 3)" end="(334, 10)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(329, 3)" end="(334, 10)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(329, 3)" end="(334, 10)">
                <OtherNode start="(329, 3)" end="(329, 33)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(329, 3)" end="(329, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(329, 5)" end="(329, 10)">
                    <NullNode start="(329, 5)" end="(329, 10)">
                      <OtherNode start="(329, 5)" end="(329, 7)" kind="«term[_]»">
                        <AtomNode start="(329, 5)" end="(329, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(329, 6)" end="(329, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(329, 7)" end="(329, 8)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(329, 9)" end="(329, 10)">
                        <AtomNode start="(329, 9)" end="(329, 10)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(329, 11)" end="(329, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(329, 14)" end="(329, 33)">
                    <AtomNode start="(329, 14)" end="(329, 16)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(329, 17)" end="(329, 33)">
                      <TacticTacticseq1IndentedNode start="(329, 17)" end="(329, 33)">
                        <NullNode start="(329, 17)" end="(329, 33)">
                          <OtherNode start="(329, 17)" end="(329, 33)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;x✝ : Array β&#10;⊢ (mapIdx.go f [] x✝).length = [].length + x✝.size" state_after="no goals" tactic="simp [mapIdx.go]">
                            <AtomNode start="(329, 17)" end="(329, 21)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(329, 22)" end="(329, 33)">
                              <AtomNode start="(329, 22)" end="(329, 23)" leading="" trailing="" val="["/>
                              <NullNode start="(329, 23)" end="(329, 32)">
                                <OtherNode start="(329, 23)" end="(329, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(329, 23)" end="(329, 32)" leading="" trailing="" raw_val="mapIdx.go" val="mapIdx.go" full_name="List.mapIdx.go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(50, 17)" def_end="(50, 19)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(329, 32)" end="(329, 33)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(330, 3)" end="(334, 10)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(330, 3)" end="(330, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(330, 5)" end="(330, 14)">
                    <NullNode start="(330, 5)" end="(330, 14)">
                      <OtherNode start="(330, 5)" end="(330, 11)" kind="«term_::_»">
                        <IdentNode start="(330, 5)" end="(330, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(330, 7)" end="(330, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(330, 10)" end="(330, 11)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(330, 11)" end="(330, 12)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(330, 13)" end="(330, 14)">
                        <AtomNode start="(330, 13)" end="(330, 14)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(330, 15)" end="(330, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(330, 18)" end="(334, 10)">
                    <AtomNode start="(330, 18)" end="(330, 20)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(331, 5)" end="(334, 10)">
                      <TacticTacticseq1IndentedNode start="(331, 5)" end="(334, 10)">
                        <NullNode start="(331, 5)" end="(334, 10)">
                          <OtherNode start="(331, 5)" end="(331, 39)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;x✝ : Array β&#10;⊢ (mapIdx.go f (a :: l) x✝).length = (a :: l).length + x✝.size" state_after="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;x✝ : Array β&#10;⊢ (mapIdx.go f l (x✝.push (f x✝.size a))).length = l.length + 1 + x✝.size" tactic="simp only [mapIdx.go, length_cons]">
                            <AtomNode start="(331, 5)" end="(331, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(331, 10)" end="(331, 14)">
                              <AtomNode start="(331, 10)" end="(331, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(331, 15)" end="(331, 39)">
                              <AtomNode start="(331, 15)" end="(331, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(331, 16)" end="(331, 38)">
                                <OtherNode start="(331, 16)" end="(331, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(331, 16)" end="(331, 25)" leading="" trailing="" raw_val="mapIdx.go" val="mapIdx.go" full_name="List.mapIdx.go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(50, 17)" def_end="(50, 19)"/>
                                </OtherNode>
                                <AtomNode start="(331, 25)" end="(331, 26)" leading="" trailing=" " val=","/>
                                <OtherNode start="(331, 27)" end="(331, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(331, 27)" end="(331, 38)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(331, 38)" end="(331, 39)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(332, 5)" end="(332, 26)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;x✝ : Array β&#10;⊢ (mapIdx.go f l (x✝.push (f x✝.size a))).length = l.length + 1 + x✝.size" state_after="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;x✝ : Array β&#10;⊢ l.length + (x✝.push (f x✝.size a)).size = l.length + 1 + x✝.size" tactic="rw [length_mapIdx_go]">
                            <AtomNode start="(332, 5)" end="(332, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(332, 8)" end="(332, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(332, 8)" end="(332, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(332, 9)" end="(332, 25)">
                                <OtherNode start="(332, 9)" end="(332, 25)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(332, 9)" end="(332, 25)" leading="" trailing="" raw_val="length_mapIdx_go" val="length_mapIdx_go"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(332, 25)" end="(332, 26)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(333, 5)" end="(333, 9)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;x✝ : Array β&#10;⊢ l.length + (x✝.push (f x✝.size a)).size = l.length + 1 + x✝.size" state_after="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;x✝ : Array β&#10;⊢ l.length + (x✝.size + 1) = l.length + 1 + x✝.size" tactic="simp">
                            <AtomNode start="(333, 5)" end="(333, 9)" leading="" trailing="&#10;    " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(334, 5)" end="(334, 10)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;x✝ : Array β&#10;⊢ l.length + (x✝.size + 1) = l.length + 1 + x✝.size" state_after="no goals" tactic="omega">
                            <AtomNode start="(334, 5)" end="(334, 10)" leading="" trailing="&#10;&#10;" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(336, 1)" end="(337, 34)" name="length_mapIdx" full_name="List.length_mapIdx">
      <CommandDeclmodifiersNode start="(336, 1)" end="(336, 8)">
        <NullNode/>
        <NullNode start="(336, 1)" end="(336, 8)">
          <OtherNode start="(336, 1)" end="(336, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(336, 1)" end="(336, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(336, 3)" end="(336, 7)">
              <OtherNode start="(336, 3)" end="(336, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(336, 3)" end="(336, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(336, 3)" end="(336, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(336, 7)" end="(336, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(336, 9)" end="(337, 34)" name="length_mapIdx" full_name="List.length_mapIdx" _is_private_decl="False">
        <AtomNode start="(336, 9)" end="(336, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(336, 17)" end="(336, 30)">
          <IdentNode start="(336, 17)" end="(336, 30)" leading="" trailing=" " raw_val="length_mapIdx" val="length_mapIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(336, 31)" end="(336, 76)">
          <NullNode start="(336, 31)" end="(336, 43)">
            <OtherNode start="(336, 31)" end="(336, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(336, 31)" end="(336, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(336, 32)" end="(336, 33)">
                <IdentNode start="(336, 32)" end="(336, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(336, 34)" end="(336, 42)">
                <AtomNode start="(336, 34)" end="(336, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(336, 36)" end="(336, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(336, 36)" end="(336, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(336, 41)" end="(336, 42)">
                    <IdentNode start="(336, 41)" end="(336, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(336, 42)" end="(336, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(336, 44)" end="(336, 76)">
            <AtomNode start="(336, 44)" end="(336, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(336, 46)" end="(336, 76)" kind="«term_=_»">
              <OtherNode start="(336, 46)" end="(336, 65)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(336, 46)" end="(336, 58)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(336, 46)" end="(336, 47)" leading="" trailing="" val="("/>
                  <OtherNode start="(336, 47)" end="(336, 57)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(336, 47)" end="(336, 55)" leading="" trailing=" " raw_val="l.mapIdx" val="l.mapIdx"/>
                    <NullNode start="(336, 56)" end="(336, 57)">
                      <IdentNode start="(336, 56)" end="(336, 57)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(336, 57)" end="(336, 58)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(336, 58)" end="(336, 59)" leading="" trailing="" val="."/>
                <IdentNode start="(336, 59)" end="(336, 65)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(336, 66)" end="(336, 67)" leading="" trailing=" " val="="/>
              <IdentNode start="(336, 68)" end="(336, 76)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(336, 77)" end="(337, 34)">
          <AtomNode start="(336, 77)" end="(336, 79)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(336, 80)" end="(337, 34)">
            <AtomNode start="(336, 80)" end="(336, 82)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(337, 3)" end="(337, 34)">
              <TacticTacticseq1IndentedNode start="(337, 3)" end="(337, 34)">
                <NullNode start="(337, 3)" end="(337, 34)">
                  <OtherNode start="(337, 3)" end="(337, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;⊢ (mapIdx f l).length = l.length" state_after="no goals" tactic="simp [mapIdx, length_mapIdx_go]">
                    <AtomNode start="(337, 3)" end="(337, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(337, 8)" end="(337, 34)">
                      <AtomNode start="(337, 8)" end="(337, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(337, 9)" end="(337, 33)">
                        <OtherNode start="(337, 9)" end="(337, 15)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(337, 9)" end="(337, 15)" leading="" trailing="" raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                        </OtherNode>
                        <AtomNode start="(337, 15)" end="(337, 16)" leading="" trailing=" " val=","/>
                        <OtherNode start="(337, 17)" end="(337, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(337, 17)" end="(337, 33)" leading="" trailing="" raw_val="length_mapIdx_go" val="length_mapIdx_go" full_name="List.length_mapIdx_go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(327, 9)" def_end="(327, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(337, 33)" end="(337, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(339, 1)" end="(357, 15)" name="getElem?_mapIdx_go" full_name="List.getElem?_mapIdx_go">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(339, 1)" end="(357, 15)" name="getElem?_mapIdx_go" full_name="List.getElem?_mapIdx_go" _is_private_decl="False">
        <AtomNode start="(339, 1)" end="(339, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(339, 9)" end="(339, 27)">
          <IdentNode start="(339, 9)" end="(339, 27)" leading="" trailing=" " raw_val="getElem?_mapIdx_go" val="getElem?_mapIdx_go"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(339, 28)" end="(341, 82)">
          <NullNode/>
          <TermTypespecNode start="(339, 28)" end="(341, 82)">
            <AtomNode start="(339, 28)" end="(339, 29)" leading="" trailing=" " val=":"/>
            <OtherNode start="(339, 30)" end="(341, 82)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(339, 30)" end="(339, 31)" leading="" trailing=" " val="∀"/>
              <NullNode start="(339, 32)" end="(339, 70)">
                <OtherNode start="(339, 32)" end="(339, 44)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(339, 32)" end="(339, 33)" leading="" trailing="" val="{"/>
                  <NullNode start="(339, 33)" end="(339, 34)">
                    <IdentNode start="(339, 33)" end="(339, 34)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(339, 35)" end="(339, 43)">
                    <AtomNode start="(339, 35)" end="(339, 36)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(339, 37)" end="(339, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(339, 37)" end="(339, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(339, 42)" end="(339, 43)">
                        <IdentNode start="(339, 42)" end="(339, 43)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(339, 43)" end="(339, 44)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(339, 45)" end="(339, 60)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(339, 45)" end="(339, 46)" leading="" trailing="" val="{"/>
                  <NullNode start="(339, 46)" end="(339, 49)">
                    <IdentNode start="(339, 46)" end="(339, 49)" leading="" trailing=" " raw_val="acc" val="acc"/>
                  </NullNode>
                  <NullNode start="(339, 50)" end="(339, 59)">
                    <AtomNode start="(339, 50)" end="(339, 51)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(339, 52)" end="(339, 59)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(339, 52)" end="(339, 57)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(339, 58)" end="(339, 59)">
                        <IdentNode start="(339, 58)" end="(339, 59)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(339, 59)" end="(339, 60)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(339, 61)" end="(339, 70)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(339, 61)" end="(339, 62)" leading="" trailing="" val="{"/>
                  <NullNode start="(339, 62)" end="(339, 63)">
                    <IdentNode start="(339, 62)" end="(339, 63)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                  <NullNode start="(339, 64)" end="(339, 69)">
                    <AtomNode start="(339, 64)" end="(339, 65)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(339, 66)" end="(339, 69)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </NullNode>
                  <AtomNode start="(339, 69)" end="(339, 70)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(339, 70)" end="(339, 71)" leading="" trailing="&#10;    " val=","/>
              <OtherNode start="(340, 5)" end="(341, 82)" kind="«term_=_»">
                <OtherNode start="(340, 5)" end="(340, 28)" kind="«term__[_]_?»">
                  <OtherNode start="(340, 5)" end="(340, 24)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(340, 5)" end="(340, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(340, 6)" end="(340, 23)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(340, 6)" end="(340, 15)" leading="" trailing=" " raw_val="mapIdx.go" val="mapIdx.go" full_name="List.mapIdx.go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(50, 17)" def_end="(50, 19)"/>
                      <NullNode start="(340, 16)" end="(340, 23)">
                        <IdentNode start="(340, 16)" end="(340, 17)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(340, 18)" end="(340, 19)" leading="" trailing=" " raw_val="l" val="l"/>
                        <IdentNode start="(340, 20)" end="(340, 23)" leading="" trailing="" raw_val="acc" val="acc"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(340, 23)" end="(340, 24)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <GroupNode/>
                  <AtomNode start="(340, 24)" end="(340, 25)" leading="" trailing="" val="["/>
                  <IdentNode start="(340, 25)" end="(340, 26)" leading="" trailing="" raw_val="i" val="i"/>
                  <AtomNode start="(340, 26)" end="(340, 27)" leading="" trailing="" val="]"/>
                  <GroupNode/>
                  <AtomNode start="(340, 27)" end="(340, 28)" leading="" trailing=" " val="?"/>
                </OtherNode>
                <AtomNode start="(340, 29)" end="(340, 30)" leading="" trailing="&#10;      " val="="/>
                <OtherNode start="(341, 7)" end="(341, 82)" kind="termDepIfThenElse">
                  <AtomNode start="(341, 7)" end="(341, 9)" leading="" trailing=" " val="if"/>
                  <LeanBinderidentNode start="(341, 10)" end="(341, 11)">
                    <IdentNode start="(341, 10)" end="(341, 11)" leading="" trailing=" " raw_val="h" val="h"/>
                  </LeanBinderidentNode>
                  <AtomNode start="(341, 12)" end="(341, 13)" leading="" trailing=" " val=":"/>
                  <OtherNode start="(341, 14)" end="(341, 26)" kind="«term_&amp;lt;_»">
                    <IdentNode start="(341, 14)" end="(341, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                    <AtomNode start="(341, 16)" end="(341, 17)" leading="" trailing=" " val="&amp;lt;"/>
                    <IdentNode start="(341, 18)" end="(341, 26)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
                  </OtherNode>
                  <AtomNode start="(341, 27)" end="(341, 31)" leading="" trailing=" " val="then"/>
                  <OtherNode start="(341, 32)" end="(341, 43)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(341, 32)" end="(341, 36)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(341, 37)" end="(341, 43)">
                      <OtherNode start="(341, 37)" end="(341, 43)" kind="«term__[_]»">
                        <IdentNode start="(341, 37)" end="(341, 40)" leading="" trailing="" raw_val="acc" val="acc"/>
                        <AtomNode start="(341, 40)" end="(341, 41)" leading="" trailing="" val="["/>
                        <IdentNode start="(341, 41)" end="(341, 42)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(341, 42)" end="(341, 43)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(341, 44)" end="(341, 48)" leading="" trailing=" " val="else"/>
                  <OtherNode start="(341, 49)" end="(341, 82)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(341, 49)" end="(341, 59)" leading="" trailing=" " raw_val="Option.map" val="Option.map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(341, 60)" end="(341, 82)">
                      <OtherNode start="(341, 60)" end="(341, 65)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(341, 60)" end="(341, 61)" leading="" trailing="" val="("/>
                        <OtherNode start="(341, 61)" end="(341, 64)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(341, 61)" end="(341, 62)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(341, 63)" end="(341, 64)">
                            <IdentNode start="(341, 63)" end="(341, 64)" leading="" trailing="" raw_val="i" val="i"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(341, 64)" end="(341, 65)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <OtherNode start="(341, 66)" end="(341, 82)" kind="«term__[_]_?»">
                        <IdentNode start="(341, 66)" end="(341, 67)" leading="" trailing="" raw_val="l" val="l"/>
                        <GroupNode/>
                        <AtomNode start="(341, 67)" end="(341, 68)" leading="" trailing="" val="["/>
                        <OtherNode start="(341, 68)" end="(341, 80)" kind="«term_-_»">
                          <IdentNode start="(341, 68)" end="(341, 69)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(341, 70)" end="(341, 71)" leading="" trailing=" " val="-"/>
                          <IdentNode start="(341, 72)" end="(341, 80)" leading="" trailing="" raw_val="acc.size" val="acc.size"/>
                        </OtherNode>
                        <AtomNode start="(341, 80)" end="(341, 81)" leading="" trailing="" val="]"/>
                        <GroupNode/>
                        <AtomNode start="(341, 81)" end="(341, 82)" leading="" trailing="&#10;  " val="?"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(342, 3)" end="(357, 15)">
          <OtherNode start="(342, 3)" end="(357, 15)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(342, 3)" end="(357, 15)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(342, 3)" end="(357, 15)">
                <OtherNode start="(342, 3)" end="(344, 89)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(342, 3)" end="(342, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(342, 5)" end="(342, 15)">
                    <NullNode start="(342, 5)" end="(342, 15)">
                      <OtherNode start="(342, 5)" end="(342, 7)" kind="«term[_]»">
                        <AtomNode start="(342, 5)" end="(342, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(342, 6)" end="(342, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(342, 7)" end="(342, 8)" leading="" trailing=" " val=","/>
                      <IdentNode start="(342, 9)" end="(342, 12)" leading="" trailing="" raw_val="acc" val="acc"/>
                      <AtomNode start="(342, 12)" end="(342, 13)" leading="" trailing=" " val=","/>
                      <IdentNode start="(342, 14)" end="(342, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(342, 16)" end="(342, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(342, 19)" end="(344, 89)">
                    <AtomNode start="(342, 19)" end="(342, 21)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(343, 5)" end="(344, 89)">
                      <TacticTacticseq1IndentedNode start="(343, 5)" end="(344, 89)">
                        <NullNode start="(343, 5)" end="(344, 89)">
                          <OtherNode start="(343, 5)" end="(344, 89)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;acc : Array β&#10;i : Nat&#10;⊢ (mapIdx.go f [] acc)[i]? = if h : i &amp;lt; acc.size then some acc[i] else Option.map (f i) [][i - acc.size]?" state_after="no goals" tactic="simp only [mapIdx.go, Array.toListImpl_eq, getElem?_def, Array.length_toList,&#10;  ← Array.getElem_toList, length_nil, Nat.not_lt_zero, ↓reduceDIte, Option.map_none]">
                            <AtomNode start="(343, 5)" end="(343, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(343, 10)" end="(343, 14)">
                              <AtomNode start="(343, 10)" end="(343, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(343, 15)" end="(344, 89)">
                              <AtomNode start="(343, 15)" end="(343, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(343, 16)" end="(344, 88)">
                                <OtherNode start="(343, 16)" end="(343, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(343, 16)" end="(343, 25)" leading="" trailing="" raw_val="mapIdx.go" val="mapIdx.go" full_name="List.mapIdx.go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(50, 17)" def_end="(50, 19)"/>
                                </OtherNode>
                                <AtomNode start="(343, 25)" end="(343, 26)" leading="" trailing=" " val=","/>
                                <OtherNode start="(343, 27)" end="(343, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(343, 27)" end="(343, 46)" leading="" trailing="" raw_val="Array.toListImpl_eq" val="Array.toListImpl_eq" full_name="Array.toListImpl_eq" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                                </OtherNode>
                                <AtomNode start="(343, 46)" end="(343, 47)" leading="" trailing=" " val=","/>
                                <OtherNode start="(343, 48)" end="(343, 60)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(343, 48)" end="(343, 60)" leading="" trailing="" raw_val="getElem?_def" val="getElem?_def" full_name="LawfulGetElem.getElem?_def" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                </OtherNode>
                                <AtomNode start="(343, 60)" end="(343, 61)" leading="" trailing=" " val=","/>
                                <OtherNode start="(343, 62)" end="(343, 81)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(343, 62)" end="(343, 81)" leading="" trailing="" raw_val="Array.length_toList" val="Array.length_toList" full_name="Array.length_toList" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(343, 81)" end="(343, 82)" leading="" trailing="&#10;      " val=","/>
                                <OtherNode start="(344, 7)" end="(344, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode start="(344, 7)" end="(344, 8)">
                                    <OtherNode start="(344, 7)" end="(344, 8)" kind="patternIgnore">
                                      <OtherNode start="(344, 7)" end="(344, 8)" kind="token.«← »">
                                        <AtomNode start="(344, 7)" end="(344, 8)" leading="" trailing=" " val="←"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <IdentNode start="(344, 9)" end="(344, 29)" leading="" trailing="" raw_val="Array.getElem_toList" val="Array.getElem_toList" full_name="Array.getElem_toList" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(344, 29)" end="(344, 30)" leading="" trailing=" " val=","/>
                                <OtherNode start="(344, 31)" end="(344, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(344, 31)" end="(344, 41)" leading="" trailing="" raw_val="length_nil" val="length_nil" full_name="List.length_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(344, 41)" end="(344, 42)" leading="" trailing=" " val=","/>
                                <OtherNode start="(344, 43)" end="(344, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(344, 43)" end="(344, 58)" leading="" trailing="" raw_val="Nat.not_lt_zero" val="Nat.not_lt_zero" full_name="Nat.not_lt_zero" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </OtherNode>
                                <AtomNode start="(344, 58)" end="(344, 59)" leading="" trailing=" " val=","/>
                                <OtherNode start="(344, 60)" end="(344, 71)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode start="(344, 60)" end="(344, 61)">
                                    <OtherNode start="(344, 60)" end="(344, 61)" kind="Lean.Parser.Tactic.simpPre">
                                      <AtomNode start="(344, 60)" end="(344, 61)" leading="" trailing="" val="↓"/>
                                    </OtherNode>
                                  </NullNode>
                                  <NullNode/>
                                  <IdentNode start="(344, 61)" end="(344, 71)" leading="" trailing="" raw_val="reduceDIte" val="reduceDIte"/>
                                </OtherNode>
                                <AtomNode start="(344, 71)" end="(344, 72)" leading="" trailing=" " val=","/>
                                <OtherNode start="(344, 73)" end="(344, 88)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(344, 73)" end="(344, 88)" leading="" trailing="" raw_val="Option.map_none" val="Option.map_none" full_name="Option.map_none" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(344, 88)" end="(344, 89)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(345, 3)" end="(357, 15)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(345, 3)" end="(345, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(345, 5)" end="(345, 19)">
                    <NullNode start="(345, 5)" end="(345, 19)">
                      <OtherNode start="(345, 5)" end="(345, 11)" kind="«term_::_»">
                        <IdentNode start="(345, 5)" end="(345, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(345, 7)" end="(345, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(345, 10)" end="(345, 11)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(345, 11)" end="(345, 12)" leading="" trailing=" " val=","/>
                      <IdentNode start="(345, 13)" end="(345, 16)" leading="" trailing="" raw_val="acc" val="acc"/>
                      <AtomNode start="(345, 16)" end="(345, 17)" leading="" trailing=" " val=","/>
                      <IdentNode start="(345, 18)" end="(345, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(345, 20)" end="(345, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(345, 23)" end="(357, 15)">
                    <AtomNode start="(345, 23)" end="(345, 25)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(346, 5)" end="(357, 15)">
                      <TacticTacticseq1IndentedNode start="(346, 5)" end="(357, 15)">
                        <NullNode start="(346, 5)" end="(357, 15)">
                          <OtherNode start="(346, 5)" end="(346, 39)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;⊢ (mapIdx.go f (a :: l) acc)[i]? = if h : i &amp;lt; acc.size then some acc[i] else Option.map (f i) (a :: l)[i - acc.size]?" state_after="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;⊢ (if h : i &amp;lt; (acc.push (f acc.size a)).size then some (acc.push (f acc.size a))[i]&#10;    else Option.map (f i) l[i - (acc.push (f acc.size a)).size]?) =&#10;    if h : i &amp;lt; acc.size then some acc[i] else Option.map (f i) (a :: l)[i - acc.size]?" tactic="rw [mapIdx.go, getElem?_mapIdx_go]">
                            <AtomNode start="(346, 5)" end="(346, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(346, 8)" end="(346, 39)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(346, 8)" end="(346, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(346, 9)" end="(346, 38)">
                                <OtherNode start="(346, 9)" end="(346, 18)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(346, 9)" end="(346, 18)" leading="" trailing="" raw_val="mapIdx.go" val="mapIdx.go" full_name="List.mapIdx.go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(50, 17)" def_end="(50, 19)"/>
                                </OtherNode>
                                <AtomNode start="(346, 18)" end="(346, 19)" leading="" trailing=" " val=","/>
                                <OtherNode start="(346, 20)" end="(346, 38)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(346, 20)" end="(346, 38)" leading="" trailing="" raw_val="getElem?_mapIdx_go" val="getElem?_mapIdx_go"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(346, 38)" end="(346, 39)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(347, 5)" end="(347, 32)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;⊢ (if h : i &amp;lt; (acc.push (f acc.size a)).size then some (acc.push (f acc.size a))[i]&#10;    else Option.map (f i) l[i - (acc.push (f acc.size a)).size]?) =&#10;    if h : i &amp;lt; acc.size then some acc[i] else Option.map (f i) (a :: l)[i - acc.size]?" state_after="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;⊢ (if h : i &amp;lt; acc.size + 1 then some (acc.push (f acc.size a))[i] else Option.map (f i) l[i - (acc.size + 1)]?) =&#10;    if h : i &amp;lt; acc.size then some acc[i] else Option.map (f i) (a :: l)[i - acc.size]?" tactic="simp only [Array.size_push]">
                            <AtomNode start="(347, 5)" end="(347, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(347, 10)" end="(347, 14)">
                              <AtomNode start="(347, 10)" end="(347, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(347, 15)" end="(347, 32)">
                              <AtomNode start="(347, 15)" end="(347, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(347, 16)" end="(347, 31)">
                                <OtherNode start="(347, 16)" end="(347, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(347, 16)" end="(347, 31)" leading="" trailing="" raw_val="Array.size_push" val="Array.size_push" full_name="Array.size_push" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(347, 31)" end="(347, 32)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(348, 5)" end="(348, 20)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;⊢ (if h : i &amp;lt; acc.size + 1 then some (acc.push (f acc.size a))[i] else Option.map (f i) l[i - (acc.size + 1)]?) =&#10;    if h : i &amp;lt; acc.size then some acc[i] else Option.map (f i) (a :: l)[i - acc.size]?" state_after="case isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ some (acc.push (f acc.size a))[i] = some acc[i]&#10;&#10;case isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ some (acc.push (f acc.size a))[i] = Option.map (f i) (a :: l)[i - acc.size]?&#10;&#10;case isFalse.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = some acc[i]&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = Option.map (f i) (a :: l)[i - acc.size]?" tactic="split &amp;lt;;&amp;gt; split">
                            <OtherNode start="(348, 5)" end="(348, 10)" kind="Lean.Parser.Tactic.split">
                              <AtomNode start="(348, 5)" end="(348, 10)" leading="" trailing=" " val="split"/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(348, 11)" end="(348, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(348, 15)" end="(348, 20)" kind="Lean.Parser.Tactic.split">
                              <AtomNode start="(348, 15)" end="(348, 20)" leading="" trailing="&#10;    " val="split"/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(349, 5)" end="(352, 55)" kind="Lean.cdot" state_before="case isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ some (acc.push (f acc.size a))[i] = some acc[i]&#10;&#10;case isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ some (acc.push (f acc.size a))[i] = Option.map (f i) (a :: l)[i - acc.size]?&#10;&#10;case isFalse.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = some acc[i]&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = Option.map (f i) (a :: l)[i - acc.size]?" state_after="case isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ some (acc.push (f acc.size a))[i] = Option.map (f i) (a :: l)[i - acc.size]?&#10;&#10;case isFalse.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = some acc[i]&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = Option.map (f i) (a :: l)[i - acc.size]?" tactic="· simp only [Option.some.injEq]&#10;  rw [← Array.getElem_toList]&#10;  simp only [Array.push_toList]&#10;  rw [getElem_append_left, ← Array.getElem_toList]">
                            <OtherNode start="(349, 5)" end="(349, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(349, 5)" end="(349, 6)" kind="patternIgnore">
                                <OtherNode start="(349, 5)" end="(349, 6)" kind="token.«· »">
                                  <AtomNode start="(349, 5)" end="(349, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(349, 7)" end="(352, 55)">
                              <TacticTacticseq1IndentedNode start="(349, 7)" end="(352, 55)">
                                <NullNode start="(349, 7)" end="(352, 55)">
                                  <OtherNode start="(349, 7)" end="(349, 36)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ some (acc.push (f acc.size a))[i] = some acc[i]" state_after="case isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ (acc.push (f acc.size a))[i] = acc[i]" tactic="simp only [Option.some.injEq]">
                                    <AtomNode start="(349, 7)" end="(349, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(349, 12)" end="(349, 16)">
                                      <AtomNode start="(349, 12)" end="(349, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(349, 17)" end="(349, 36)">
                                      <AtomNode start="(349, 17)" end="(349, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(349, 18)" end="(349, 35)">
                                        <OtherNode start="(349, 18)" end="(349, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(349, 18)" end="(349, 35)" leading="" trailing="" raw_val="Option.some.injEq" val="Option.some.injEq" full_name="Option.some.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(349, 35)" end="(349, 36)" leading="" trailing="&#10;      " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(350, 7)" end="(350, 34)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ (acc.push (f acc.size a))[i] = acc[i]" state_after="case isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ (acc.push (f acc.size a)).toList[i] = acc[i]" tactic="rw [← Array.getElem_toList]">
                                    <AtomNode start="(350, 7)" end="(350, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(350, 10)" end="(350, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(350, 10)" end="(350, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(350, 11)" end="(350, 33)">
                                        <OtherNode start="(350, 11)" end="(350, 33)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode start="(350, 11)" end="(350, 12)">
                                            <OtherNode start="(350, 11)" end="(350, 12)" kind="patternIgnore">
                                              <OtherNode start="(350, 11)" end="(350, 12)" kind="token.«← »">
                                                <AtomNode start="(350, 11)" end="(350, 12)" leading="" trailing=" " val="←"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                          <IdentNode start="(350, 13)" end="(350, 33)" leading="" trailing="" raw_val="Array.getElem_toList" val="Array.getElem_toList" full_name="Array.getElem_toList" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(350, 33)" end="(350, 34)" leading="" trailing="&#10;      " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(351, 7)" end="(351, 36)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ (acc.push (f acc.size a)).toList[i] = acc[i]" state_after="case isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ (acc.toList ++ [f acc.size a])[i] = acc[i]" tactic="simp only [Array.push_toList]">
                                    <AtomNode start="(351, 7)" end="(351, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(351, 12)" end="(351, 16)">
                                      <AtomNode start="(351, 12)" end="(351, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(351, 17)" end="(351, 36)">
                                      <AtomNode start="(351, 17)" end="(351, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(351, 18)" end="(351, 35)">
                                        <OtherNode start="(351, 18)" end="(351, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(351, 18)" end="(351, 35)" leading="" trailing="" raw_val="Array.push_toList" val="Array.push_toList" full_name="Array.push_toList" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(351, 35)" end="(351, 36)" leading="" trailing="&#10;      " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(352, 7)" end="(352, 55)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ (acc.toList ++ [f acc.size a])[i] = acc[i]" state_after="no goals" tactic="rw [getElem_append_left, ← Array.getElem_toList]">
                                    <AtomNode start="(352, 7)" end="(352, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(352, 10)" end="(352, 55)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(352, 10)" end="(352, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(352, 11)" end="(352, 54)">
                                        <OtherNode start="(352, 11)" end="(352, 30)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(352, 11)" end="(352, 30)" leading="" trailing="" raw_val="getElem_append_left" val="getElem_append_left" full_name="List.getElem_append_left" mod_name="Init.Data.List.BasicAux" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/BasicAux.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(352, 30)" end="(352, 31)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(352, 32)" end="(352, 54)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode start="(352, 32)" end="(352, 33)">
                                            <OtherNode start="(352, 32)" end="(352, 33)" kind="patternIgnore">
                                              <OtherNode start="(352, 32)" end="(352, 33)" kind="token.«← »">
                                                <AtomNode start="(352, 32)" end="(352, 33)" leading="" trailing=" " val="←"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                          <IdentNode start="(352, 34)" end="(352, 54)" leading="" trailing="" raw_val="Array.getElem_toList" val="Array.getElem_toList" full_name="Array.getElem_toList" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(352, 54)" end="(352, 55)" leading="" trailing="&#10;    " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(353, 5)" end="(354, 15)" kind="Lean.cdot" state_before="case isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ some (acc.push (f acc.size a))[i] = Option.map (f i) (a :: l)[i - acc.size]?&#10;&#10;case isFalse.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = some acc[i]&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = Option.map (f i) (a :: l)[i - acc.size]?" state_after="case isFalse.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = some acc[i]&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = Option.map (f i) (a :: l)[i - acc.size]?" tactic="· have : i = acc.size := by omega&#10;  simp_all">
                            <OtherNode start="(353, 5)" end="(353, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(353, 5)" end="(353, 6)" kind="patternIgnore">
                                <OtherNode start="(353, 5)" end="(353, 6)" kind="token.«· »">
                                  <AtomNode start="(353, 5)" end="(353, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(353, 7)" end="(354, 15)">
                              <TacticTacticseq1IndentedNode start="(353, 7)" end="(354, 15)">
                                <NullNode start="(353, 7)" end="(354, 15)">
                                  <OtherNode start="(353, 7)" end="(353, 38)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ some (acc.push (f acc.size a))[i] = Option.map (f i) (a :: l)[i - acc.size]?" state_after="case isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;this : i = acc.size&#10;⊢ some (acc.push (f acc.size a))[i] = Option.map (f i) (a :: l)[i - acc.size]?" tactic="have : i = acc.size := by omega">
                                    <AtomNode start="(353, 7)" end="(353, 11)" leading="" trailing=" " val="have"/>
                                    <OtherNode start="(353, 12)" end="(353, 38)" kind="Lean.Parser.Term.haveDecl">
                                      <OtherNode start="(353, 12)" end="(353, 38)" kind="Lean.Parser.Term.haveIdDecl">
                                        <OtherNode start="(353, 12)" end="(353, 12)" kind="Lean.Parser.Term.haveId">
                                          <OtherNode start="(353, 12)" end="(353, 12)" kind="hygieneInfo">
                                            <IdentNode start="(353, 12)" end="(353, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode start="(353, 12)" end="(353, 26)">
                                          <TermTypespecNode start="(353, 12)" end="(353, 26)">
                                            <AtomNode start="(353, 12)" end="(353, 13)" leading="" trailing=" " val=":"/>
                                            <OtherNode start="(353, 14)" end="(353, 26)" kind="«term_=_»">
                                              <IdentNode start="(353, 14)" end="(353, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                                              <AtomNode start="(353, 16)" end="(353, 17)" leading="" trailing=" " val="="/>
                                              <IdentNode start="(353, 18)" end="(353, 26)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
                                            </OtherNode>
                                          </TermTypespecNode>
                                        </NullNode>
                                        <AtomNode start="(353, 27)" end="(353, 29)" leading="" trailing=" " val=":="/>
                                        <TermBytacticNode start="(353, 30)" end="(353, 38)">
                                          <AtomNode start="(353, 30)" end="(353, 32)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(353, 33)" end="(353, 38)">
                                            <TacticTacticseq1IndentedNode start="(353, 33)" end="(353, 38)">
                                              <NullNode start="(353, 33)" end="(353, 38)">
                                                <OtherNode start="(353, 33)" end="(353, 38)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ i = acc.size" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(353, 33)" end="(353, 38)" leading="" trailing="&#10;      " val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(354, 7)" end="(354, 15)" kind="Lean.Parser.Tactic.simpAll" state_before="case isTrue.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;this : i = acc.size&#10;⊢ some (acc.push (f acc.size a))[i] = Option.map (f i) (a :: l)[i - acc.size]?" state_after="no goals" tactic="simp_all">
                                    <AtomNode start="(354, 7)" end="(354, 15)" leading="" trailing="&#10;    " val="simp_all"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(355, 5)" end="(355, 12)" kind="Lean.cdot" state_before="case isFalse.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = some acc[i]&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = Option.map (f i) (a :: l)[i - acc.size]?" state_after="case isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = Option.map (f i) (a :: l)[i - acc.size]?" tactic="· omega">
                            <OtherNode start="(355, 5)" end="(355, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(355, 5)" end="(355, 6)" kind="patternIgnore">
                                <OtherNode start="(355, 5)" end="(355, 6)" kind="token.«· »">
                                  <AtomNode start="(355, 5)" end="(355, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(355, 7)" end="(355, 12)">
                              <TacticTacticseq1IndentedNode start="(355, 7)" end="(355, 12)">
                                <NullNode start="(355, 7)" end="(355, 12)">
                                  <OtherNode start="(355, 7)" end="(355, 12)" kind="Lean.Parser.Tactic.omega" state_before="case isFalse.isTrue&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = some acc[i]" state_after="no goals" tactic="omega">
                                    <AtomNode start="(355, 7)" end="(355, 12)" leading="" trailing="&#10;    " val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(356, 5)" end="(357, 15)" kind="Lean.cdot" state_before="case isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = Option.map (f i) (a :: l)[i - acc.size]?" state_after="no goals" tactic="· have : i - acc.size = i - (acc.size + 1) + 1 := by omega&#10;  simp_all">
                            <OtherNode start="(356, 5)" end="(356, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(356, 5)" end="(356, 6)" kind="patternIgnore">
                                <OtherNode start="(356, 5)" end="(356, 6)" kind="token.«· »">
                                  <AtomNode start="(356, 5)" end="(356, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(356, 7)" end="(357, 15)">
                              <TacticTacticseq1IndentedNode start="(356, 7)" end="(357, 15)">
                                <NullNode start="(356, 7)" end="(357, 15)">
                                  <OtherNode start="(356, 7)" end="(356, 63)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = Option.map (f i) (a :: l)[i - acc.size]?" state_after="case isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;this : i - acc.size = i - (acc.size + 1) + 1&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = Option.map (f i) (a :: l)[i - acc.size]?" tactic="have : i - acc.size = i - (acc.size + 1) + 1 := by omega">
                                    <AtomNode start="(356, 7)" end="(356, 11)" leading="" trailing=" " val="have"/>
                                    <OtherNode start="(356, 12)" end="(356, 63)" kind="Lean.Parser.Term.haveDecl">
                                      <OtherNode start="(356, 12)" end="(356, 63)" kind="Lean.Parser.Term.haveIdDecl">
                                        <OtherNode start="(356, 12)" end="(356, 12)" kind="Lean.Parser.Term.haveId">
                                          <OtherNode start="(356, 12)" end="(356, 12)" kind="hygieneInfo">
                                            <IdentNode start="(356, 12)" end="(356, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode start="(356, 12)" end="(356, 51)">
                                          <TermTypespecNode start="(356, 12)" end="(356, 51)">
                                            <AtomNode start="(356, 12)" end="(356, 13)" leading="" trailing=" " val=":"/>
                                            <OtherNode start="(356, 14)" end="(356, 51)" kind="«term_=_»">
                                              <OtherNode start="(356, 14)" end="(356, 26)" kind="«term_-_»">
                                                <IdentNode start="(356, 14)" end="(356, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                                                <AtomNode start="(356, 16)" end="(356, 17)" leading="" trailing=" " val="-"/>
                                                <IdentNode start="(356, 18)" end="(356, 26)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
                                              </OtherNode>
                                              <AtomNode start="(356, 27)" end="(356, 28)" leading="" trailing=" " val="="/>
                                              <OtherNode start="(356, 29)" end="(356, 51)" kind="«term_+_»">
                                                <OtherNode start="(356, 29)" end="(356, 47)" kind="«term_-_»">
                                                  <IdentNode start="(356, 29)" end="(356, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                                                  <AtomNode start="(356, 31)" end="(356, 32)" leading="" trailing=" " val="-"/>
                                                  <OtherNode start="(356, 33)" end="(356, 47)" kind="Lean.Parser.Term.paren">
                                                    <AtomNode start="(356, 33)" end="(356, 34)" leading="" trailing="" val="("/>
                                                    <OtherNode start="(356, 34)" end="(356, 46)" kind="«term_+_»">
                                                      <IdentNode start="(356, 34)" end="(356, 42)" leading="" trailing=" " raw_val="acc.size" val="acc.size"/>
                                                      <AtomNode start="(356, 43)" end="(356, 44)" leading="" trailing=" " val="+"/>
                                                      <OtherNode start="(356, 45)" end="(356, 46)" kind="num">
                                                        <AtomNode start="(356, 45)" end="(356, 46)" leading="" trailing="" val="1"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <AtomNode start="(356, 46)" end="(356, 47)" leading="" trailing=" " val=")"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(356, 48)" end="(356, 49)" leading="" trailing=" " val="+"/>
                                                <OtherNode start="(356, 50)" end="(356, 51)" kind="num">
                                                  <AtomNode start="(356, 50)" end="(356, 51)" leading="" trailing=" " val="1"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </TermTypespecNode>
                                        </NullNode>
                                        <AtomNode start="(356, 52)" end="(356, 54)" leading="" trailing=" " val=":="/>
                                        <TermBytacticNode start="(356, 55)" end="(356, 63)">
                                          <AtomNode start="(356, 55)" end="(356, 57)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(356, 58)" end="(356, 63)">
                                            <TacticTacticseq1IndentedNode start="(356, 58)" end="(356, 63)">
                                              <NullNode start="(356, 58)" end="(356, 63)">
                                                <OtherNode start="(356, 58)" end="(356, 63)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;⊢ i - acc.size = i - (acc.size + 1) + 1" state_after="no goals" tactic="omega">
                                                  <AtomNode start="(356, 58)" end="(356, 63)" leading="" trailing="&#10;      " val="omega"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(357, 7)" end="(357, 15)" kind="Lean.Parser.Tactic.simpAll" state_before="case isFalse.isFalse&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;a : α&#10;l : List α&#10;acc : Array β&#10;i : Nat&#10;h✝¹ : ¬i &amp;lt; acc.size + 1&#10;h✝ : ¬i &amp;lt; acc.size&#10;this : i - acc.size = i - (acc.size + 1) + 1&#10;⊢ Option.map (f i) l[i - (acc.size + 1)]? = Option.map (f i) (a :: l)[i - acc.size]?" state_after="no goals" tactic="simp_all">
                                    <AtomNode start="(357, 7)" end="(357, 15)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(359, 1)" end="(361, 36)" name="getElem?_mapIdx" full_name="List.getElem?_mapIdx">
      <CommandDeclmodifiersNode start="(359, 1)" end="(359, 8)">
        <NullNode/>
        <NullNode start="(359, 1)" end="(359, 8)">
          <OtherNode start="(359, 1)" end="(359, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(359, 1)" end="(359, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(359, 3)" end="(359, 7)">
              <OtherNode start="(359, 3)" end="(359, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(359, 3)" end="(359, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(359, 3)" end="(359, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(359, 7)" end="(359, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(359, 9)" end="(361, 36)" name="getElem?_mapIdx" full_name="List.getElem?_mapIdx" _is_private_decl="False">
        <AtomNode start="(359, 9)" end="(359, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(359, 17)" end="(359, 32)">
          <IdentNode start="(359, 17)" end="(359, 32)" leading="" trailing=" " raw_val="getElem?_mapIdx" val="getElem?_mapIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(359, 33)" end="(360, 46)">
          <NullNode start="(359, 33)" end="(359, 55)">
            <OtherNode start="(359, 33)" end="(359, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(359, 33)" end="(359, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(359, 34)" end="(359, 35)">
                <IdentNode start="(359, 34)" end="(359, 35)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(359, 36)" end="(359, 44)">
                <AtomNode start="(359, 36)" end="(359, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(359, 38)" end="(359, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(359, 38)" end="(359, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(359, 43)" end="(359, 44)">
                    <IdentNode start="(359, 43)" end="(359, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(359, 44)" end="(359, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(359, 46)" end="(359, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(359, 46)" end="(359, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(359, 47)" end="(359, 48)">
                <IdentNode start="(359, 47)" end="(359, 48)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(359, 49)" end="(359, 54)">
                <AtomNode start="(359, 49)" end="(359, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(359, 51)" end="(359, 54)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(359, 54)" end="(359, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(359, 56)" end="(360, 46)">
            <AtomNode start="(359, 56)" end="(359, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(360, 5)" end="(360, 46)" kind="«term_=_»">
              <OtherNode start="(360, 5)" end="(360, 21)" kind="«term__[_]_?»">
                <OtherNode start="(360, 5)" end="(360, 17)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(360, 5)" end="(360, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(360, 6)" end="(360, 16)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(360, 6)" end="(360, 14)" leading="" trailing=" " raw_val="l.mapIdx" val="l.mapIdx"/>
                    <NullNode start="(360, 15)" end="(360, 16)">
                      <IdentNode start="(360, 15)" end="(360, 16)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(360, 16)" end="(360, 17)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(360, 17)" end="(360, 18)" leading="" trailing="" val="["/>
                <IdentNode start="(360, 18)" end="(360, 19)" leading="" trailing="" raw_val="i" val="i"/>
                <AtomNode start="(360, 19)" end="(360, 20)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(360, 20)" end="(360, 21)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(360, 22)" end="(360, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(360, 24)" end="(360, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(360, 24)" end="(360, 34)" leading="" trailing=" " raw_val="Option.map" val="Option.map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(360, 35)" end="(360, 46)">
                  <OtherNode start="(360, 35)" end="(360, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(360, 35)" end="(360, 36)" leading="" trailing="" val="("/>
                    <OtherNode start="(360, 36)" end="(360, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(360, 36)" end="(360, 37)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(360, 38)" end="(360, 39)">
                        <IdentNode start="(360, 38)" end="(360, 39)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(360, 39)" end="(360, 40)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(360, 41)" end="(360, 46)" kind="«term__[_]_?»">
                    <IdentNode start="(360, 41)" end="(360, 42)" leading="" trailing="" raw_val="l" val="l"/>
                    <GroupNode/>
                    <AtomNode start="(360, 42)" end="(360, 43)" leading="" trailing="" val="["/>
                    <IdentNode start="(360, 43)" end="(360, 44)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(360, 44)" end="(360, 45)" leading="" trailing="" val="]"/>
                    <GroupNode/>
                    <AtomNode start="(360, 45)" end="(360, 46)" leading="" trailing=" " val="?"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(360, 47)" end="(361, 36)">
          <AtomNode start="(360, 47)" end="(360, 49)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(360, 50)" end="(361, 36)">
            <AtomNode start="(360, 50)" end="(360, 52)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(361, 3)" end="(361, 36)">
              <TacticTacticseq1IndentedNode start="(361, 3)" end="(361, 36)">
                <NullNode start="(361, 3)" end="(361, 36)">
                  <OtherNode start="(361, 3)" end="(361, 36)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;i : Nat&#10;⊢ (mapIdx f l)[i]? = Option.map (f i) l[i]?" state_after="no goals" tactic="simp [mapIdx, getElem?_mapIdx_go]">
                    <AtomNode start="(361, 3)" end="(361, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(361, 8)" end="(361, 36)">
                      <AtomNode start="(361, 8)" end="(361, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(361, 9)" end="(361, 35)">
                        <OtherNode start="(361, 9)" end="(361, 15)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(361, 9)" end="(361, 15)" leading="" trailing="" raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                        </OtherNode>
                        <AtomNode start="(361, 15)" end="(361, 16)" leading="" trailing=" " val=","/>
                        <OtherNode start="(361, 17)" end="(361, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(361, 17)" end="(361, 35)" leading="" trailing="" raw_val="getElem?_mapIdx_go" val="getElem?_mapIdx_go" full_name="List.getElem?_mapIdx_go" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(339, 9)" def_end="(339, 27)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(361, 35)" end="(361, 36)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(363, 1)" end="(367, 7)" name="getElem_mapIdx" full_name="List.getElem_mapIdx">
      <CommandDeclmodifiersNode start="(363, 1)" end="(363, 8)">
        <NullNode/>
        <NullNode start="(363, 1)" end="(363, 8)">
          <OtherNode start="(363, 1)" end="(363, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(363, 1)" end="(363, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(363, 3)" end="(363, 7)">
              <OtherNode start="(363, 3)" end="(363, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(363, 3)" end="(363, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(363, 3)" end="(363, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(363, 7)" end="(363, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(363, 9)" end="(367, 7)" name="getElem_mapIdx" full_name="List.getElem_mapIdx" _is_private_decl="False">
        <AtomNode start="(363, 9)" end="(363, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(363, 17)" end="(363, 31)">
          <IdentNode start="(363, 17)" end="(363, 31)" leading="" trailing=" " raw_val="getElem_mapIdx" val="getElem_mapIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(363, 32)" end="(364, 52)">
          <NullNode start="(363, 32)" end="(363, 102)">
            <OtherNode start="(363, 32)" end="(363, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(363, 32)" end="(363, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(363, 33)" end="(363, 34)">
                <IdentNode start="(363, 33)" end="(363, 34)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(363, 35)" end="(363, 43)">
                <AtomNode start="(363, 35)" end="(363, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(363, 37)" end="(363, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(363, 37)" end="(363, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(363, 42)" end="(363, 43)">
                    <IdentNode start="(363, 42)" end="(363, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(363, 43)" end="(363, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(363, 45)" end="(363, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(363, 45)" end="(363, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(363, 46)" end="(363, 47)">
                <IdentNode start="(363, 46)" end="(363, 47)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(363, 48)" end="(363, 61)">
                <AtomNode start="(363, 48)" end="(363, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(363, 50)" end="(363, 61)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(363, 50)" end="(363, 53)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(363, 54)" end="(363, 55)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(363, 56)" end="(363, 61)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(363, 56)" end="(363, 57)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(363, 58)" end="(363, 59)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(363, 60)" end="(363, 61)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(363, 61)" end="(363, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(363, 63)" end="(363, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(363, 63)" end="(363, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(363, 64)" end="(363, 65)">
                <IdentNode start="(363, 64)" end="(363, 65)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(363, 66)" end="(363, 71)">
                <AtomNode start="(363, 66)" end="(363, 67)" leading="" trailing=" " val=":"/>
                <IdentNode start="(363, 68)" end="(363, 71)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(363, 71)" end="(363, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(363, 73)" end="(363, 102)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(363, 73)" end="(363, 74)" leading="" trailing="" val="{"/>
              <NullNode start="(363, 74)" end="(363, 75)">
                <IdentNode start="(363, 74)" end="(363, 75)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(363, 76)" end="(363, 101)">
                <AtomNode start="(363, 76)" end="(363, 77)" leading="" trailing=" " val=":"/>
                <OtherNode start="(363, 78)" end="(363, 101)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(363, 78)" end="(363, 79)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(363, 80)" end="(363, 81)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(363, 82)" end="(363, 101)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(363, 82)" end="(363, 94)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(363, 82)" end="(363, 83)" leading="" trailing="" val="("/>
                      <OtherNode start="(363, 83)" end="(363, 93)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(363, 83)" end="(363, 91)" leading="" trailing=" " raw_val="l.mapIdx" val="l.mapIdx"/>
                        <NullNode start="(363, 92)" end="(363, 93)">
                          <IdentNode start="(363, 92)" end="(363, 93)" leading="" trailing="" raw_val="f" val="f"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(363, 93)" end="(363, 94)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(363, 94)" end="(363, 95)" leading="" trailing="" val="."/>
                    <IdentNode start="(363, 95)" end="(363, 101)" leading="" trailing="" raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(363, 101)" end="(363, 102)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(363, 103)" end="(364, 52)">
            <AtomNode start="(363, 103)" end="(363, 104)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(364, 5)" end="(364, 52)" kind="«term_=_»">
              <OtherNode start="(364, 5)" end="(364, 20)" kind="«term__[_]»">
                <OtherNode start="(364, 5)" end="(364, 17)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(364, 5)" end="(364, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(364, 6)" end="(364, 16)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(364, 6)" end="(364, 14)" leading="" trailing=" " raw_val="l.mapIdx" val="l.mapIdx"/>
                    <NullNode start="(364, 15)" end="(364, 16)">
                      <IdentNode start="(364, 15)" end="(364, 16)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(364, 16)" end="(364, 17)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(364, 17)" end="(364, 18)" leading="" trailing="" val="["/>
                <IdentNode start="(364, 18)" end="(364, 19)" leading="" trailing="" raw_val="i" val="i"/>
                <AtomNode start="(364, 19)" end="(364, 20)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(364, 21)" end="(364, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(364, 23)" end="(364, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(364, 23)" end="(364, 24)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(364, 25)" end="(364, 52)">
                  <IdentNode start="(364, 25)" end="(364, 26)" leading="" trailing=" " raw_val="i" val="i"/>
                  <OtherNode start="(364, 27)" end="(364, 52)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(364, 27)" end="(364, 28)" leading="" trailing="" val="("/>
                    <OtherNode start="(364, 28)" end="(364, 51)" kind="«term__[_]'_»">
                      <IdentNode start="(364, 28)" end="(364, 29)" leading="" trailing="" raw_val="l" val="l"/>
                      <AtomNode start="(364, 29)" end="(364, 30)" leading="" trailing="" val="["/>
                      <IdentNode start="(364, 30)" end="(364, 31)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(364, 31)" end="(364, 33)" leading="" trailing="" val="]'"/>
                      <OtherNode start="(364, 33)" end="(364, 51)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(364, 33)" end="(364, 34)" leading="" trailing="" val="("/>
                        <TermBytacticNode start="(364, 34)" end="(364, 50)">
                          <AtomNode start="(364, 34)" end="(364, 36)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(364, 37)" end="(364, 50)">
                            <TacticTacticseq1IndentedNode start="(364, 37)" end="(364, 50)">
                              <NullNode start="(364, 37)" end="(364, 50)">
                                <OtherNode start="(364, 37)" end="(364, 50)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type ?u.69968&#10;β : Type ?u.69980&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : i &amp;lt; (mapIdx f l).length&#10;⊢ i &amp;lt; l.length" state_after="no goals" tactic="simpa using h">
                                  <AtomNode start="(364, 37)" end="(364, 42)" leading="" trailing=" " val="simpa"/>
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(364, 43)" end="(364, 50)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(364, 43)" end="(364, 50)">
                                      <AtomNode start="(364, 43)" end="(364, 48)" leading="" trailing=" " val="using"/>
                                      <IdentNode start="(364, 49)" end="(364, 50)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                        <AtomNode start="(364, 50)" end="(364, 51)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(364, 51)" end="(364, 52)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(364, 53)" end="(367, 7)">
          <AtomNode start="(364, 53)" end="(364, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(364, 56)" end="(367, 7)">
            <AtomNode start="(364, 56)" end="(364, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(365, 3)" end="(367, 7)">
              <TacticTacticseq1IndentedNode start="(365, 3)" end="(367, 7)">
                <NullNode start="(365, 3)" end="(367, 7)">
                  <OtherNode start="(365, 3)" end="(365, 27)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : i &amp;lt; (mapIdx f l).length&#10;⊢ (mapIdx f l)[i] = f i l[i]" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : i &amp;lt; (mapIdx f l).length&#10;⊢ some (mapIdx f l)[i] = some (f i l[i])" tactic="apply Option.some_inj.mp">
                    <AtomNode start="(365, 3)" end="(365, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(365, 9)" end="(365, 27)" leading="" trailing="&#10;  " raw_val="Option.some_inj.mp" val="Option.some_inj.mp"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(366, 3)" end="(366, 86)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : i &amp;lt; (mapIdx f l).length&#10;⊢ some (mapIdx f l)[i] = some (f i l[i])" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : i &amp;lt; (mapIdx f l).length&#10;⊢ Option.map (f i) (some l[i]) = some (f i l[i])" tactic="rw [← getElem?_eq_getElem, getElem?_mapIdx, getElem?_eq_getElem (by simpa using h)]">
                    <AtomNode start="(366, 3)" end="(366, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(366, 6)" end="(366, 86)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(366, 6)" end="(366, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(366, 7)" end="(366, 85)">
                        <OtherNode start="(366, 7)" end="(366, 28)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(366, 7)" end="(366, 8)">
                            <OtherNode start="(366, 7)" end="(366, 8)" kind="patternIgnore">
                              <OtherNode start="(366, 7)" end="(366, 8)" kind="token.«← »">
                                <AtomNode start="(366, 7)" end="(366, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(366, 9)" end="(366, 28)" leading="" trailing="" raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="List.getElem?_eq_getElem" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                        </OtherNode>
                        <AtomNode start="(366, 28)" end="(366, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(366, 30)" end="(366, 45)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(366, 30)" end="(366, 45)" leading="" trailing="" raw_val="getElem?_mapIdx" val="getElem?_mapIdx" full_name="List.getElem?_mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(359, 17)" def_end="(359, 32)"/>
                        </OtherNode>
                        <AtomNode start="(366, 45)" end="(366, 46)" leading="" trailing=" " val=","/>
                        <OtherNode start="(366, 47)" end="(366, 85)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(366, 47)" end="(366, 85)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(366, 47)" end="(366, 66)" leading="" trailing=" " raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="List.getElem?_eq_getElem" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                            <NullNode start="(366, 67)" end="(366, 85)">
                              <OtherNode start="(366, 67)" end="(366, 85)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(366, 67)" end="(366, 68)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(366, 68)" end="(366, 84)">
                                  <AtomNode start="(366, 68)" end="(366, 70)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(366, 71)" end="(366, 84)">
                                    <TacticTacticseq1IndentedNode start="(366, 71)" end="(366, 84)">
                                      <NullNode start="(366, 71)" end="(366, 84)">
                                        <OtherNode start="(366, 71)" end="(366, 84)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : i &amp;lt; (mapIdx f l).length&#10;⊢ i &amp;lt; l.length" state_after="no goals" tactic="simpa using h">
                                          <AtomNode start="(366, 71)" end="(366, 76)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(366, 77)" end="(366, 84)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(366, 77)" end="(366, 84)">
                                              <AtomNode start="(366, 77)" end="(366, 82)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(366, 83)" end="(366, 84)" leading="" trailing="" raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(366, 84)" end="(366, 85)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(366, 85)" end="(366, 86)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(367, 3)" end="(367, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : i &amp;lt; (mapIdx f l).length&#10;⊢ Option.map (f i) (some l[i]) = some (f i l[i])" state_after="no goals" tactic="simp">
                    <AtomNode start="(367, 3)" end="(367, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(369, 1)" end="(372, 30)" name="mapFinIdx_eq_mapIdx" full_name="List.mapFinIdx_eq_mapIdx">
      <CommandDeclmodifiersNode start="(369, 1)" end="(369, 8)">
        <NullNode/>
        <NullNode start="(369, 1)" end="(369, 8)">
          <OtherNode start="(369, 1)" end="(369, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(369, 1)" end="(369, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(369, 3)" end="(369, 7)">
              <OtherNode start="(369, 3)" end="(369, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(369, 3)" end="(369, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(369, 3)" end="(369, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(369, 7)" end="(369, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(369, 9)" end="(372, 30)" name="mapFinIdx_eq_mapIdx" full_name="List.mapFinIdx_eq_mapIdx" _is_private_decl="False">
        <AtomNode start="(369, 9)" end="(369, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(369, 17)" end="(369, 36)">
          <IdentNode start="(369, 17)" end="(369, 36)" leading="" trailing=" " raw_val="mapFinIdx_eq_mapIdx" val="mapFinIdx_eq_mapIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(369, 37)" end="(371, 31)">
          <NullNode start="(369, 37)" end="(370, 64)">
            <OtherNode start="(369, 37)" end="(369, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(369, 37)" end="(369, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(369, 38)" end="(369, 39)">
                <IdentNode start="(369, 38)" end="(369, 39)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(369, 40)" end="(369, 48)">
                <AtomNode start="(369, 40)" end="(369, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(369, 42)" end="(369, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(369, 42)" end="(369, 46)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(369, 47)" end="(369, 48)">
                    <IdentNode start="(369, 47)" end="(369, 48)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(369, 48)" end="(369, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(369, 50)" end="(369, 94)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(369, 50)" end="(369, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(369, 51)" end="(369, 52)">
                <IdentNode start="(369, 51)" end="(369, 52)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(369, 53)" end="(369, 93)">
                <AtomNode start="(369, 53)" end="(369, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(369, 55)" end="(369, 93)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(369, 55)" end="(369, 64)">
                    <AtomNode start="(369, 55)" end="(369, 56)" leading="" trailing="" val="("/>
                    <NullNode start="(369, 56)" end="(369, 57)">
                      <IdentNode start="(369, 56)" end="(369, 57)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(369, 58)" end="(369, 63)">
                      <AtomNode start="(369, 58)" end="(369, 59)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(369, 60)" end="(369, 63)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(369, 63)" end="(369, 64)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(369, 65)" end="(369, 66)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(369, 67)" end="(369, 93)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(369, 67)" end="(369, 68)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(369, 69)" end="(369, 70)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(369, 71)" end="(369, 93)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(369, 71)" end="(369, 89)">
                        <AtomNode start="(369, 71)" end="(369, 72)" leading="" trailing="" val="("/>
                        <NullNode start="(369, 72)" end="(369, 73)">
                          <IdentNode start="(369, 72)" end="(369, 73)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode start="(369, 74)" end="(369, 88)">
                          <AtomNode start="(369, 74)" end="(369, 75)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(369, 76)" end="(369, 88)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(369, 76)" end="(369, 77)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(369, 78)" end="(369, 79)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(369, 80)" end="(369, 88)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(369, 88)" end="(369, 89)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(369, 90)" end="(369, 91)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(369, 92)" end="(369, 93)" leading="" trailing="" raw_val="β" val="β"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(369, 93)" end="(369, 94)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(369, 95)" end="(369, 112)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(369, 95)" end="(369, 96)" leading="" trailing="" val="{"/>
              <NullNode start="(369, 96)" end="(369, 97)">
                <IdentNode start="(369, 96)" end="(369, 97)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(369, 98)" end="(369, 111)">
                <AtomNode start="(369, 98)" end="(369, 99)" leading="" trailing=" " val=":"/>
                <OtherNode start="(369, 100)" end="(369, 111)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(369, 100)" end="(369, 103)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(369, 104)" end="(369, 105)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(369, 106)" end="(369, 111)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(369, 106)" end="(369, 107)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(369, 108)" end="(369, 109)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(369, 110)" end="(369, 111)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(369, 111)" end="(369, 112)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(370, 5)" end="(370, 64)">
              <AtomNode start="(370, 5)" end="(370, 6)" leading="" trailing="" val="("/>
              <NullNode start="(370, 6)" end="(370, 7)">
                <IdentNode start="(370, 6)" end="(370, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(370, 8)" end="(370, 63)">
                <AtomNode start="(370, 8)" end="(370, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(370, 10)" end="(370, 63)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(370, 10)" end="(370, 11)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(370, 12)" end="(370, 40)">
                    <TermExplicitbinderNode start="(370, 12)" end="(370, 21)">
                      <AtomNode start="(370, 12)" end="(370, 13)" leading="" trailing="" val="("/>
                      <NullNode start="(370, 13)" end="(370, 14)">
                        <IdentNode start="(370, 13)" end="(370, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                      <NullNode start="(370, 15)" end="(370, 20)">
                        <AtomNode start="(370, 15)" end="(370, 16)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(370, 17)" end="(370, 20)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(370, 20)" end="(370, 21)" leading="" trailing=" " val=")"/>
                    </TermExplicitbinderNode>
                    <TermExplicitbinderNode start="(370, 22)" end="(370, 40)">
                      <AtomNode start="(370, 22)" end="(370, 23)" leading="" trailing="" val="("/>
                      <NullNode start="(370, 23)" end="(370, 24)">
                        <IdentNode start="(370, 23)" end="(370, 24)" leading="" trailing=" " raw_val="h" val="h"/>
                      </NullNode>
                      <NullNode start="(370, 25)" end="(370, 39)">
                        <AtomNode start="(370, 25)" end="(370, 26)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(370, 27)" end="(370, 39)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(370, 27)" end="(370, 28)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(370, 29)" end="(370, 30)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(370, 31)" end="(370, 39)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(370, 39)" end="(370, 40)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(370, 40)" end="(370, 41)" leading="" trailing=" " val=","/>
                  <OtherNode start="(370, 42)" end="(370, 63)" kind="«term_=_»">
                    <OtherNode start="(370, 42)" end="(370, 52)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(370, 42)" end="(370, 43)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(370, 44)" end="(370, 52)">
                        <IdentNode start="(370, 44)" end="(370, 45)" leading="" trailing=" " raw_val="i" val="i"/>
                        <OtherNode start="(370, 46)" end="(370, 50)" kind="«term__[_]»">
                          <IdentNode start="(370, 46)" end="(370, 47)" leading="" trailing="" raw_val="l" val="l"/>
                          <AtomNode start="(370, 47)" end="(370, 48)" leading="" trailing="" val="["/>
                          <IdentNode start="(370, 48)" end="(370, 49)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(370, 49)" end="(370, 50)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                        <IdentNode start="(370, 51)" end="(370, 52)" leading="" trailing=" " raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(370, 53)" end="(370, 54)" leading="" trailing=" " val="="/>
                    <OtherNode start="(370, 55)" end="(370, 63)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(370, 55)" end="(370, 56)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(370, 57)" end="(370, 63)">
                        <IdentNode start="(370, 57)" end="(370, 58)" leading="" trailing=" " raw_val="i" val="i"/>
                        <OtherNode start="(370, 59)" end="(370, 63)" kind="«term__[_]»">
                          <IdentNode start="(370, 59)" end="(370, 60)" leading="" trailing="" raw_val="l" val="l"/>
                          <AtomNode start="(370, 60)" end="(370, 61)" leading="" trailing="" val="["/>
                          <IdentNode start="(370, 61)" end="(370, 62)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(370, 62)" end="(370, 63)" leading="" trailing="" val="]"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(370, 63)" end="(370, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(370, 65)" end="(371, 31)">
            <AtomNode start="(370, 65)" end="(370, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(371, 5)" end="(371, 31)" kind="«term_=_»">
              <OtherNode start="(371, 5)" end="(371, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(371, 5)" end="(371, 16)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                <NullNode start="(371, 17)" end="(371, 18)">
                  <IdentNode start="(371, 17)" end="(371, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(371, 19)" end="(371, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(371, 21)" end="(371, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(371, 21)" end="(371, 29)" leading="" trailing=" " raw_val="l.mapIdx" val="l.mapIdx"/>
                <NullNode start="(371, 30)" end="(371, 31)">
                  <IdentNode start="(371, 30)" end="(371, 31)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(371, 32)" end="(372, 30)">
          <AtomNode start="(371, 32)" end="(371, 34)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(371, 35)" end="(372, 30)">
            <AtomNode start="(371, 35)" end="(371, 37)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(372, 3)" end="(372, 30)">
              <TacticTacticseq1IndentedNode start="(372, 3)" end="(372, 30)">
                <NullNode start="(372, 3)" end="(372, 30)">
                  <OtherNode start="(372, 3)" end="(372, 30)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : (i : Nat) → α → i &amp;lt; l.length → β&#10;g : Nat → α → β&#10;h : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] h = g i l[i]&#10;⊢ l.mapFinIdx f = mapIdx g l" state_after="no goals" tactic="simp_all [mapFinIdx_eq_iff]">
                    <AtomNode start="(372, 3)" end="(372, 11)" leading="" trailing=" " val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(372, 12)" end="(372, 30)">
                      <AtomNode start="(372, 12)" end="(372, 13)" leading="" trailing="" val="["/>
                      <NullNode start="(372, 13)" end="(372, 29)">
                        <OtherNode start="(372, 13)" end="(372, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(372, 13)" end="(372, 29)" leading="" trailing="" raw_val="mapFinIdx_eq_iff" val="mapFinIdx_eq_iff" full_name="List.mapFinIdx_eq_iff" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(234, 9)" def_end="(234, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(372, 29)" end="(372, 30)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(374, 1)" end="(376, 29)" name="mapIdx_eq_mapFinIdx" full_name="List.mapIdx_eq_mapFinIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(374, 1)" end="(376, 29)" name="mapIdx_eq_mapFinIdx" full_name="List.mapIdx_eq_mapFinIdx" _is_private_decl="False">
        <AtomNode start="(374, 1)" end="(374, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(374, 9)" end="(374, 28)">
          <IdentNode start="(374, 9)" end="(374, 28)" leading="" trailing=" " raw_val="mapIdx_eq_mapFinIdx" val="mapIdx_eq_mapFinIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(374, 29)" end="(375, 50)">
          <NullNode start="(374, 29)" end="(374, 59)">
            <OtherNode start="(374, 29)" end="(374, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(374, 29)" end="(374, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(374, 30)" end="(374, 31)">
                <IdentNode start="(374, 30)" end="(374, 31)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(374, 32)" end="(374, 40)">
                <AtomNode start="(374, 32)" end="(374, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(374, 34)" end="(374, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(374, 34)" end="(374, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(374, 39)" end="(374, 40)">
                    <IdentNode start="(374, 39)" end="(374, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(374, 40)" end="(374, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(374, 42)" end="(374, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(374, 42)" end="(374, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(374, 43)" end="(374, 44)">
                <IdentNode start="(374, 43)" end="(374, 44)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(374, 45)" end="(374, 58)">
                <AtomNode start="(374, 45)" end="(374, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(374, 47)" end="(374, 58)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(374, 47)" end="(374, 50)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(374, 51)" end="(374, 52)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(374, 53)" end="(374, 58)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(374, 53)" end="(374, 54)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(374, 55)" end="(374, 56)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(374, 57)" end="(374, 58)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(374, 58)" end="(374, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(374, 60)" end="(375, 50)">
            <AtomNode start="(374, 60)" end="(374, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(375, 5)" end="(375, 50)" kind="«term_=_»">
              <OtherNode start="(375, 5)" end="(375, 15)" kind="Lean.Parser.Term.app">
                <IdentNode start="(375, 5)" end="(375, 13)" leading="" trailing=" " raw_val="l.mapIdx" val="l.mapIdx"/>
                <NullNode start="(375, 14)" end="(375, 15)">
                  <IdentNode start="(375, 14)" end="(375, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(375, 16)" end="(375, 17)" leading="" trailing=" " val="="/>
              <OtherNode start="(375, 18)" end="(375, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(375, 18)" end="(375, 29)" leading="" trailing=" " raw_val="l.mapFinIdx" val="l.mapFinIdx"/>
                <NullNode start="(375, 30)" end="(375, 50)">
                  <OtherNode start="(375, 30)" end="(375, 50)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(375, 30)" end="(375, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(375, 31)" end="(375, 49)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(375, 31)" end="(375, 34)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(375, 35)" end="(375, 49)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(375, 35)" end="(375, 40)">
                          <IdentNode start="(375, 35)" end="(375, 36)" leading="" trailing=" " raw_val="i" val="i"/>
                          <IdentNode start="(375, 37)" end="(375, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                          <TermHoleNode start="(375, 39)" end="(375, 40)">
                            <AtomNode start="(375, 39)" end="(375, 40)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(375, 41)" end="(375, 43)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(375, 44)" end="(375, 49)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(375, 44)" end="(375, 45)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(375, 46)" end="(375, 49)">
                            <IdentNode start="(375, 46)" end="(375, 47)" leading="" trailing=" " raw_val="i" val="i"/>
                            <IdentNode start="(375, 48)" end="(375, 49)" leading="" trailing="" raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(375, 49)" end="(375, 50)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(375, 51)" end="(376, 29)">
          <AtomNode start="(375, 51)" end="(375, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(375, 54)" end="(376, 29)">
            <AtomNode start="(375, 54)" end="(375, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(376, 3)" end="(376, 29)">
              <TacticTacticseq1IndentedNode start="(376, 3)" end="(376, 29)">
                <NullNode start="(376, 3)" end="(376, 29)">
                  <OtherNode start="(376, 3)" end="(376, 29)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;⊢ mapIdx f l = l.mapFinIdx fun i a x =&amp;gt; f i a" state_after="no goals" tactic="simp [mapFinIdx_eq_mapIdx]">
                    <AtomNode start="(376, 3)" end="(376, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(376, 8)" end="(376, 29)">
                      <AtomNode start="(376, 8)" end="(376, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(376, 9)" end="(376, 28)">
                        <OtherNode start="(376, 9)" end="(376, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(376, 9)" end="(376, 28)" leading="" trailing="" raw_val="mapFinIdx_eq_mapIdx" val="mapFinIdx_eq_mapIdx" full_name="List.mapFinIdx_eq_mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(369, 17)" def_end="(369, 36)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(376, 28)" end="(376, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(378, 1)" end="(382, 17)" name="mapIdx_eq_zipIdx_map" full_name="List.mapIdx_eq_zipIdx_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(378, 1)" end="(382, 17)" name="mapIdx_eq_zipIdx_map" full_name="List.mapIdx_eq_zipIdx_map" _is_private_decl="False">
        <AtomNode start="(378, 1)" end="(378, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(378, 9)" end="(378, 29)">
          <IdentNode start="(378, 9)" end="(378, 29)" leading="" trailing=" " raw_val="mapIdx_eq_zipIdx_map" val="mapIdx_eq_zipIdx_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(378, 30)" end="(379, 52)">
          <NullNode start="(378, 30)" end="(378, 60)">
            <OtherNode start="(378, 30)" end="(378, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(378, 30)" end="(378, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(378, 31)" end="(378, 32)">
                <IdentNode start="(378, 31)" end="(378, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(378, 33)" end="(378, 41)">
                <AtomNode start="(378, 33)" end="(378, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(378, 35)" end="(378, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(378, 35)" end="(378, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(378, 40)" end="(378, 41)">
                    <IdentNode start="(378, 40)" end="(378, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(378, 41)" end="(378, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(378, 43)" end="(378, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(378, 43)" end="(378, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(378, 44)" end="(378, 45)">
                <IdentNode start="(378, 44)" end="(378, 45)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(378, 46)" end="(378, 59)">
                <AtomNode start="(378, 46)" end="(378, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(378, 48)" end="(378, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(378, 48)" end="(378, 51)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(378, 52)" end="(378, 53)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(378, 54)" end="(378, 59)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(378, 54)" end="(378, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(378, 56)" end="(378, 57)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(378, 58)" end="(378, 59)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(378, 59)" end="(378, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(378, 61)" end="(379, 52)">
            <AtomNode start="(378, 61)" end="(378, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(379, 5)" end="(379, 52)" kind="«term_=_»">
              <OtherNode start="(379, 5)" end="(379, 15)" kind="Lean.Parser.Term.app">
                <IdentNode start="(379, 5)" end="(379, 13)" leading="" trailing=" " raw_val="l.mapIdx" val="l.mapIdx"/>
                <NullNode start="(379, 14)" end="(379, 15)">
                  <IdentNode start="(379, 14)" end="(379, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(379, 16)" end="(379, 17)" leading="" trailing=" " val="="/>
              <OtherNode start="(379, 18)" end="(379, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(379, 18)" end="(379, 30)" leading="" trailing=" " raw_val="l.zipIdx.map" val="l.zipIdx.map"/>
                <NullNode start="(379, 31)" end="(379, 52)">
                  <OtherNode start="(379, 31)" end="(379, 52)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(379, 31)" end="(379, 32)" leading="" trailing="" val="("/>
                    <OtherNode start="(379, 32)" end="(379, 51)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(379, 32)" end="(379, 35)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(379, 36)" end="(379, 51)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(379, 36)" end="(379, 42)">
                          <OtherNode start="(379, 36)" end="(379, 42)" kind="Lean.Parser.Term.anonymousCtor">
                            <AtomNode start="(379, 36)" end="(379, 37)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(379, 37)" end="(379, 41)">
                              <IdentNode start="(379, 37)" end="(379, 38)" leading="" trailing="" raw_val="a" val="a"/>
                              <AtomNode start="(379, 38)" end="(379, 39)" leading="" trailing=" " val=","/>
                              <IdentNode start="(379, 40)" end="(379, 41)" leading="" trailing="" raw_val="i" val="i"/>
                            </NullNode>
                            <AtomNode start="(379, 41)" end="(379, 42)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(379, 43)" end="(379, 45)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(379, 46)" end="(379, 51)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(379, 46)" end="(379, 47)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(379, 48)" end="(379, 51)">
                            <IdentNode start="(379, 48)" end="(379, 49)" leading="" trailing=" " raw_val="i" val="i"/>
                            <IdentNode start="(379, 50)" end="(379, 51)" leading="" trailing="" raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(379, 51)" end="(379, 52)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(379, 53)" end="(382, 17)">
          <AtomNode start="(379, 53)" end="(379, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(379, 56)" end="(382, 17)">
            <AtomNode start="(379, 56)" end="(379, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(380, 3)" end="(382, 17)">
              <TacticTacticseq1IndentedNode start="(380, 3)" end="(382, 17)">
                <NullNode start="(380, 3)" end="(382, 17)">
                  <OtherNode start="(380, 3)" end="(380, 9)" kind="Lean.Elab.Tactic.Ext.tacticExt1___" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;⊢ mapIdx f l =&#10;    map&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; f i a)&#10;      l.zipIdx" state_after="case h&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;⊢ (mapIdx f l)[i]? =&#10;    (map&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (a, i) =&amp;gt; f i a)&#10;        l.zipIdx)[i]?" tactic="ext1 i">
                    <AtomNode start="(380, 3)" end="(380, 7)" leading="" trailing=" " val="ext1"/>
                    <NullNode start="(380, 8)" end="(380, 9)">
                      <OtherNode start="(380, 8)" end="(380, 9)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(380, 8)" end="(380, 9)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(380, 8)" end="(380, 9)" leading="" trailing="&#10;  " raw_val="i" val="i"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(381, 3)" end="(381, 73)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;⊢ (mapIdx f l)[i]? =&#10;    (map&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (a, i) =&amp;gt; f i a)&#10;        l.zipIdx)[i]?" state_after="case h&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;⊢ (match l[i]? with&#10;    | some x =&amp;gt; some (f i x)&#10;    | none =&amp;gt; none) =&#10;    match&#10;      match l[i]? with&#10;      | some x =&amp;gt; some (x, 0 + i)&#10;      | none =&amp;gt; none with&#10;    | some x =&amp;gt; some (f x.snd x.fst)&#10;    | none =&amp;gt; none" tactic="simp only [getElem?_mapIdx, Option.map, getElem?_map, getElem?_zipIdx]">
                    <AtomNode start="(381, 3)" end="(381, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(381, 8)" end="(381, 12)">
                      <AtomNode start="(381, 8)" end="(381, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(381, 13)" end="(381, 73)">
                      <AtomNode start="(381, 13)" end="(381, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(381, 14)" end="(381, 72)">
                        <OtherNode start="(381, 14)" end="(381, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(381, 14)" end="(381, 29)" leading="" trailing="" raw_val="getElem?_mapIdx" val="getElem?_mapIdx" full_name="List.getElem?_mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(359, 17)" def_end="(359, 32)"/>
                        </OtherNode>
                        <AtomNode start="(381, 29)" end="(381, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(381, 31)" end="(381, 41)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(381, 31)" end="(381, 41)" leading="" trailing="" raw_val="Option.map" val="Option.map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                        <AtomNode start="(381, 41)" end="(381, 42)" leading="" trailing=" " val=","/>
                        <OtherNode start="(381, 43)" end="(381, 55)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(381, 43)" end="(381, 55)" leading="" trailing="" raw_val="getElem?_map" val="getElem?_map" full_name="List.getElem?_map" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(381, 55)" end="(381, 56)" leading="" trailing=" " val=","/>
                        <OtherNode start="(381, 57)" end="(381, 72)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(381, 57)" end="(381, 72)" leading="" trailing="" raw_val="getElem?_zipIdx" val="getElem?_zipIdx" full_name="List.getElem?_zipIdx" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(381, 72)" end="(381, 73)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(382, 3)" end="(382, 17)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;⊢ (match l[i]? with&#10;    | some x =&amp;gt; some (f i x)&#10;    | none =&amp;gt; none) =&#10;    match&#10;      match l[i]? with&#10;      | some x =&amp;gt; some (x, 0 + i)&#10;      | none =&amp;gt; none with&#10;    | some x =&amp;gt; some (f x.snd x.fst)&#10;    | none =&amp;gt; none" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(382, 3)" end="(382, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(382, 3)" end="(382, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(382, 9)" end="(382, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(382, 13)" end="(382, 17)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(382, 13)" end="(382, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(384, 1)" end="(385, 51)" name="mapIdx_eq_enum_map" full_name="List.mapIdx_eq_enum_map">
      <CommandDeclmodifiersNode start="(384, 1)" end="(384, 59)">
        <NullNode/>
        <NullNode start="(384, 1)" end="(384, 59)">
          <OtherNode start="(384, 1)" end="(384, 59)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(384, 1)" end="(384, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(384, 3)" end="(384, 58)">
              <OtherNode start="(384, 3)" end="(384, 58)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(384, 3)" end="(384, 58)" kind="Lean.deprecated">
                  <AtomNode start="(384, 3)" end="(384, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(384, 14)" end="(384, 34)">
                    <IdentNode start="(384, 14)" end="(384, 34)" leading="" trailing=" " raw_val="mapIdx_eq_zipIdx_map" val="mapIdx_eq_zipIdx_map" full_name="List.mapIdx_eq_zipIdx_map" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(378, 9)" def_end="(378, 29)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(384, 35)" end="(384, 58)">
                    <AtomNode start="(384, 35)" end="(384, 36)" leading="" trailing="" val="("/>
                    <AtomNode start="(384, 36)" end="(384, 41)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(384, 42)" end="(384, 44)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(384, 45)" end="(384, 57)" kind="str">
                      <AtomNode start="(384, 45)" end="(384, 57)" leading="" trailing="" val="&amp;quot;2025-01-21&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(384, 57)" end="(384, 58)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(384, 58)" end="(384, 59)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(385, 1)" end="(385, 51)" name="mapIdx_eq_enum_map">
        <AtomNode start="(385, 1)" end="(385, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(385, 8)" end="(385, 26)">
          <IdentNode start="(385, 8)" end="(385, 26)" leading="" trailing=" " raw_val="mapIdx_eq_enum_map" val="mapIdx_eq_enum_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(385, 27)" end="(385, 51)">
          <AtomNode start="(385, 27)" end="(385, 29)" leading="" trailing=" " val=":="/>
          <OtherNode start="(385, 30)" end="(385, 51)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(385, 30)" end="(385, 31)" leading="" trailing="" val="@"/>
            <IdentNode start="(385, 31)" end="(385, 51)" leading="" trailing="&#10;&#10;" raw_val="mapIdx_eq_zipIdx_map" val="mapIdx_eq_zipIdx_map" full_name="List.mapIdx_eq_zipIdx_map" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(378, 9)" def_end="(378, 29)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(387, 1)" end="(390, 48)" name="mapIdx_cons" full_name="List.mapIdx_cons">
      <CommandDeclmodifiersNode start="(387, 1)" end="(387, 8)">
        <NullNode/>
        <NullNode start="(387, 1)" end="(387, 8)">
          <OtherNode start="(387, 1)" end="(387, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(387, 1)" end="(387, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(387, 3)" end="(387, 7)">
              <OtherNode start="(387, 3)" end="(387, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(387, 3)" end="(387, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(387, 3)" end="(387, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(387, 7)" end="(387, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(388, 1)" end="(390, 48)" name="mapIdx_cons" full_name="List.mapIdx_cons" _is_private_decl="False">
        <AtomNode start="(388, 1)" end="(388, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(388, 9)" end="(388, 20)">
          <IdentNode start="(388, 9)" end="(388, 20)" leading="" trailing=" " raw_val="mapIdx_cons" val="mapIdx_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(388, 21)" end="(389, 63)">
          <NullNode start="(388, 21)" end="(388, 41)">
            <OtherNode start="(388, 21)" end="(388, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(388, 21)" end="(388, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(388, 22)" end="(388, 23)">
                <IdentNode start="(388, 22)" end="(388, 23)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(388, 24)" end="(388, 32)">
                <AtomNode start="(388, 24)" end="(388, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(388, 26)" end="(388, 32)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(388, 26)" end="(388, 30)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(388, 31)" end="(388, 32)">
                    <IdentNode start="(388, 31)" end="(388, 32)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(388, 32)" end="(388, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(388, 34)" end="(388, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(388, 34)" end="(388, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(388, 35)" end="(388, 36)">
                <IdentNode start="(388, 35)" end="(388, 36)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(388, 37)" end="(388, 40)">
                <AtomNode start="(388, 37)" end="(388, 38)" leading="" trailing=" " val=":"/>
                <IdentNode start="(388, 39)" end="(388, 40)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(388, 40)" end="(388, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(388, 42)" end="(389, 63)">
            <AtomNode start="(388, 42)" end="(388, 43)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(389, 5)" end="(389, 63)" kind="«term_=_»">
              <OtherNode start="(389, 5)" end="(389, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(389, 5)" end="(389, 11)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                <NullNode start="(389, 12)" end="(389, 22)">
                  <IdentNode start="(389, 12)" end="(389, 13)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(389, 14)" end="(389, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(389, 14)" end="(389, 15)" leading="" trailing="" val="("/>
                    <OtherNode start="(389, 15)" end="(389, 21)" kind="«term_::_»">
                      <IdentNode start="(389, 15)" end="(389, 16)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(389, 17)" end="(389, 19)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(389, 20)" end="(389, 21)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(389, 21)" end="(389, 22)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(389, 23)" end="(389, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(389, 25)" end="(389, 63)" kind="«term_::_»">
                <OtherNode start="(389, 25)" end="(389, 30)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(389, 25)" end="(389, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                  <NullNode start="(389, 27)" end="(389, 30)">
                    <OtherNode start="(389, 27)" end="(389, 28)" kind="num">
                      <AtomNode start="(389, 27)" end="(389, 28)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                    <IdentNode start="(389, 29)" end="(389, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(389, 31)" end="(389, 33)" leading="" trailing=" " val="::"/>
                <OtherNode start="(389, 34)" end="(389, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(389, 34)" end="(389, 40)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                  <NullNode start="(389, 41)" end="(389, 63)">
                    <OtherNode start="(389, 41)" end="(389, 61)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(389, 41)" end="(389, 42)" leading="" trailing="" val="("/>
                      <OtherNode start="(389, 42)" end="(389, 60)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(389, 42)" end="(389, 45)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(389, 46)" end="(389, 60)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(389, 46)" end="(389, 47)">
                            <IdentNode start="(389, 46)" end="(389, 47)" leading="" trailing=" " raw_val="i" val="i"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(389, 48)" end="(389, 50)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(389, 51)" end="(389, 60)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(389, 51)" end="(389, 52)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(389, 53)" end="(389, 60)">
                              <OtherNode start="(389, 53)" end="(389, 60)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(389, 53)" end="(389, 54)" leading="" trailing="" val="("/>
                                <OtherNode start="(389, 54)" end="(389, 59)" kind="«term_+_»">
                                  <IdentNode start="(389, 54)" end="(389, 55)" leading="" trailing=" " raw_val="i" val="i"/>
                                  <AtomNode start="(389, 56)" end="(389, 57)" leading="" trailing=" " val="+"/>
                                  <OtherNode start="(389, 58)" end="(389, 59)" kind="num">
                                    <AtomNode start="(389, 58)" end="(389, 59)" leading="" trailing="" val="1"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(389, 59)" end="(389, 60)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(389, 60)" end="(389, 61)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(389, 62)" end="(389, 63)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(389, 64)" end="(390, 48)">
          <AtomNode start="(389, 64)" end="(389, 66)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(389, 67)" end="(390, 48)">
            <AtomNode start="(389, 67)" end="(389, 69)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(390, 3)" end="(390, 48)">
              <TacticTacticseq1IndentedNode start="(390, 3)" end="(390, 48)">
                <NullNode start="(390, 3)" end="(390, 48)">
                  <OtherNode start="(390, 3)" end="(390, 48)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;a : α&#10;⊢ mapIdx f (a :: l) = f 0 a :: mapIdx (fun i =&amp;gt; f (i + 1)) l" state_after="no goals" tactic="simp [mapIdx_eq_zipIdx_map, List.zipIdx_succ]">
                    <AtomNode start="(390, 3)" end="(390, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(390, 8)" end="(390, 48)">
                      <AtomNode start="(390, 8)" end="(390, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(390, 9)" end="(390, 47)">
                        <OtherNode start="(390, 9)" end="(390, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(390, 9)" end="(390, 29)" leading="" trailing="" raw_val="mapIdx_eq_zipIdx_map" val="mapIdx_eq_zipIdx_map" full_name="List.mapIdx_eq_zipIdx_map" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(378, 9)" def_end="(378, 29)"/>
                        </OtherNode>
                        <AtomNode start="(390, 29)" end="(390, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(390, 31)" end="(390, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(390, 31)" end="(390, 47)" leading="" trailing="" raw_val="List.zipIdx_succ" val="List.zipIdx_succ" full_name="List.zipIdx_succ" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(390, 47)" end="(390, 48)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(392, 1)" end="(396, 70)" name="mapIdx_append" full_name="List.mapIdx_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(392, 1)" end="(396, 70)" name="mapIdx_append" full_name="List.mapIdx_append" _is_private_decl="False">
        <AtomNode start="(392, 1)" end="(392, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(392, 9)" end="(392, 22)">
          <IdentNode start="(392, 9)" end="(392, 22)" leading="" trailing=" " raw_val="mapIdx_append" val="mapIdx_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(392, 23)" end="(393, 78)">
          <NullNode start="(392, 23)" end="(392, 39)">
            <OtherNode start="(392, 23)" end="(392, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(392, 23)" end="(392, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(392, 24)" end="(392, 29)">
                <IdentNode start="(392, 24)" end="(392, 26)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(392, 27)" end="(392, 29)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(392, 30)" end="(392, 38)">
                <AtomNode start="(392, 30)" end="(392, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(392, 32)" end="(392, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(392, 32)" end="(392, 36)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(392, 37)" end="(392, 38)">
                    <IdentNode start="(392, 37)" end="(392, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(392, 38)" end="(392, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(392, 40)" end="(393, 78)">
            <AtomNode start="(392, 40)" end="(392, 41)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(393, 5)" end="(393, 78)" kind="«term_=_»">
              <OtherNode start="(393, 5)" end="(393, 24)" kind="Lean.Parser.Term.app">
                <OtherNode start="(393, 5)" end="(393, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(393, 5)" end="(393, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(393, 5)" end="(393, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(393, 6)" end="(393, 14)" kind="«term_++_»">
                      <IdentNode start="(393, 6)" end="(393, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(393, 9)" end="(393, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(393, 12)" end="(393, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(393, 14)" end="(393, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(393, 15)" end="(393, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(393, 16)" end="(393, 22)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                </OtherNode>
                <NullNode start="(393, 23)" end="(393, 24)">
                  <IdentNode start="(393, 23)" end="(393, 24)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(393, 25)" end="(393, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(393, 27)" end="(393, 78)" kind="«term_++_»">
                <OtherNode start="(393, 27)" end="(393, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(393, 27)" end="(393, 36)" leading="" trailing=" " raw_val="xs.mapIdx" val="xs.mapIdx"/>
                  <NullNode start="(393, 37)" end="(393, 38)">
                    <IdentNode start="(393, 37)" end="(393, 38)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(393, 39)" end="(393, 41)" leading="" trailing=" " val="++"/>
                <OtherNode start="(393, 42)" end="(393, 78)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(393, 42)" end="(393, 51)" leading="" trailing=" " raw_val="ys.mapIdx" val="ys.mapIdx"/>
                  <NullNode start="(393, 52)" end="(393, 78)">
                    <OtherNode start="(393, 52)" end="(393, 78)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(393, 52)" end="(393, 55)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(393, 56)" end="(393, 78)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(393, 56)" end="(393, 57)">
                          <IdentNode start="(393, 56)" end="(393, 57)" leading="" trailing=" " raw_val="i" val="i"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(393, 58)" end="(393, 60)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(393, 61)" end="(393, 78)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(393, 61)" end="(393, 62)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(393, 63)" end="(393, 78)">
                            <OtherNode start="(393, 63)" end="(393, 78)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(393, 63)" end="(393, 64)" leading="" trailing="" val="("/>
                              <OtherNode start="(393, 64)" end="(393, 77)" kind="«term_+_»">
                                <IdentNode start="(393, 64)" end="(393, 65)" leading="" trailing=" " raw_val="i" val="i"/>
                                <AtomNode start="(393, 66)" end="(393, 67)" leading="" trailing=" " val="+"/>
                                <IdentNode start="(393, 68)" end="(393, 77)" leading="" trailing="" raw_val="xs.length" val="xs.length"/>
                              </OtherNode>
                              <AtomNode start="(393, 77)" end="(393, 78)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(393, 79)" end="(396, 70)">
          <AtomNode start="(393, 79)" end="(393, 81)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(393, 82)" end="(396, 70)">
            <AtomNode start="(393, 82)" end="(393, 84)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(394, 3)" end="(396, 70)">
              <TacticTacticseq1IndentedNode start="(394, 3)" end="(396, 70)">
                <NullNode start="(394, 3)" end="(396, 70)">
                  <OtherNode start="(394, 3)" end="(396, 70)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;xs ys : List α&#10;⊢ mapIdx f (xs ++ ys) = mapIdx f xs ++ mapIdx (fun i =&amp;gt; f (i + xs.length)) ys" state_after="no goals" tactic="induction xs generalizing f with&#10;| nil =&amp;gt; rfl&#10;| cons _ _ ih =&amp;gt; simp [ih (f := fun i =&amp;gt; f (i + 1)), Nat.add_assoc]">
                    <AtomNode start="(394, 3)" end="(394, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(394, 13)" end="(394, 15)">
                      <OtherNode start="(394, 13)" end="(394, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(394, 13)" end="(394, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(394, 16)" end="(394, 30)">
                      <AtomNode start="(394, 16)" end="(394, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(394, 29)" end="(394, 30)">
                        <IdentNode start="(394, 29)" end="(394, 30)" leading="" trailing=" " raw_val="f" val="f"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(394, 31)" end="(396, 70)">
                      <OtherNode start="(394, 31)" end="(396, 70)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(394, 31)" end="(394, 35)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(395, 3)" end="(396, 70)">
                          <OtherNode start="(395, 3)" end="(395, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(395, 3)" end="(395, 8)">
                              <OtherNode start="(395, 3)" end="(395, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(395, 3)" end="(395, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(395, 5)" end="(395, 8)">
                                  <NullNode/>
                                  <IdentNode start="(395, 5)" end="(395, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(395, 9)" end="(395, 15)">
                              <AtomNode start="(395, 9)" end="(395, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(395, 12)" end="(395, 15)">
                                <TacticTacticseq1IndentedNode start="(395, 12)" end="(395, 15)">
                                  <NullNode start="(395, 12)" end="(395, 15)">
                                    <OtherNode start="(395, 12)" end="(395, 15)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case nil&#10;α : Type u_1&#10;α✝ : Type u_2&#10;ys : List α&#10;f : Nat → α → α✝&#10;⊢ mapIdx f ([] ++ ys) = mapIdx f [] ++ mapIdx (fun i =&amp;gt; f (i + [].length)) ys" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(395, 12)" end="(395, 15)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(396, 3)" end="(396, 70)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(396, 3)" end="(396, 16)">
                              <OtherNode start="(396, 3)" end="(396, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(396, 3)" end="(396, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(396, 5)" end="(396, 9)">
                                  <NullNode/>
                                  <IdentNode start="(396, 5)" end="(396, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(396, 10)" end="(396, 16)">
                                  <TermHoleNode start="(396, 10)" end="(396, 11)">
                                    <AtomNode start="(396, 10)" end="(396, 11)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(396, 12)" end="(396, 13)">
                                    <AtomNode start="(396, 12)" end="(396, 13)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <IdentNode start="(396, 14)" end="(396, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(396, 17)" end="(396, 70)">
                              <AtomNode start="(396, 17)" end="(396, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(396, 20)" end="(396, 70)">
                                <TacticTacticseq1IndentedNode start="(396, 20)" end="(396, 70)">
                                  <NullNode start="(396, 20)" end="(396, 70)">
                                    <OtherNode start="(396, 20)" end="(396, 70)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;α✝ : Type u_2&#10;ys : List α&#10;head✝ : α&#10;tail✝ : List α&#10;ih : ∀ {f : Nat → α → α✝}, mapIdx f (tail✝ ++ ys) = mapIdx f tail✝ ++ mapIdx (fun i =&amp;gt; f (i + tail✝.length)) ys&#10;f : Nat → α → α✝&#10;⊢ mapIdx f (head✝ :: tail✝ ++ ys) = mapIdx f (head✝ :: tail✝) ++ mapIdx (fun i =&amp;gt; f (i + (head✝ :: tail✝).length)) ys" state_after="no goals" tactic="simp [ih (f := fun i =&amp;gt; f (i + 1)), Nat.add_assoc]">
                                      <AtomNode start="(396, 20)" end="(396, 24)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(396, 25)" end="(396, 70)">
                                        <AtomNode start="(396, 25)" end="(396, 26)" leading="" trailing="" val="["/>
                                        <NullNode start="(396, 26)" end="(396, 69)">
                                          <OtherNode start="(396, 26)" end="(396, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <OtherNode start="(396, 26)" end="(396, 54)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(396, 26)" end="(396, 28)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                              <NullNode start="(396, 29)" end="(396, 54)">
                                                <OtherNode start="(396, 29)" end="(396, 54)" kind="Lean.Parser.Term.namedArgument">
                                                  <AtomNode start="(396, 29)" end="(396, 30)" leading="" trailing="" val="("/>
                                                  <IdentNode start="(396, 30)" end="(396, 31)" leading="" trailing=" " raw_val="f" val="f"/>
                                                  <AtomNode start="(396, 32)" end="(396, 34)" leading="" trailing=" " val=":="/>
                                                  <OtherNode start="(396, 35)" end="(396, 53)" kind="Lean.Parser.Term.fun">
                                                    <AtomNode start="(396, 35)" end="(396, 38)" leading="" trailing=" " val="fun"/>
                                                    <OtherNode start="(396, 39)" end="(396, 53)" kind="Lean.Parser.Term.basicFun">
                                                      <NullNode start="(396, 39)" end="(396, 40)">
                                                        <IdentNode start="(396, 39)" end="(396, 40)" leading="" trailing=" " raw_val="i" val="i"/>
                                                      </NullNode>
                                                      <NullNode/>
                                                      <AtomNode start="(396, 41)" end="(396, 43)" leading="" trailing=" " val="=&amp;gt;"/>
                                                      <OtherNode start="(396, 44)" end="(396, 53)" kind="Lean.Parser.Term.app">
                                                        <IdentNode start="(396, 44)" end="(396, 45)" leading="" trailing=" " raw_val="f" val="f"/>
                                                        <NullNode start="(396, 46)" end="(396, 53)">
                                                          <OtherNode start="(396, 46)" end="(396, 53)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(396, 46)" end="(396, 47)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(396, 47)" end="(396, 52)" kind="«term_+_»">
                                                            <IdentNode start="(396, 47)" end="(396, 48)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            <AtomNode start="(396, 49)" end="(396, 50)" leading="" trailing=" " val="+"/>
                                                            <OtherNode start="(396, 51)" end="(396, 52)" kind="num">
                                                            <AtomNode start="(396, 51)" end="(396, 52)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(396, 52)" end="(396, 53)" leading="" trailing="" val=")"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <AtomNode start="(396, 53)" end="(396, 54)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(396, 54)" end="(396, 55)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(396, 56)" end="(396, 69)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(396, 56)" end="(396, 69)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(396, 69)" end="(396, 70)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(398, 1)" end="(400, 23)" name="mapIdx_concat" full_name="List.mapIdx_concat">
      <CommandDeclmodifiersNode start="(398, 1)" end="(398, 8)">
        <NullNode/>
        <NullNode start="(398, 1)" end="(398, 8)">
          <OtherNode start="(398, 1)" end="(398, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(398, 1)" end="(398, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(398, 3)" end="(398, 7)">
              <OtherNode start="(398, 3)" end="(398, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(398, 3)" end="(398, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(398, 3)" end="(398, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(398, 7)" end="(398, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(398, 9)" end="(400, 23)" name="mapIdx_concat" full_name="List.mapIdx_concat" _is_private_decl="False">
        <AtomNode start="(398, 9)" end="(398, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(398, 17)" end="(398, 30)">
          <IdentNode start="(398, 17)" end="(398, 30)" leading="" trailing=" " raw_val="mapIdx_concat" val="mapIdx_concat"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(398, 31)" end="(399, 55)">
          <NullNode start="(398, 31)" end="(398, 51)">
            <OtherNode start="(398, 31)" end="(398, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(398, 31)" end="(398, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(398, 32)" end="(398, 33)">
                <IdentNode start="(398, 32)" end="(398, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(398, 34)" end="(398, 42)">
                <AtomNode start="(398, 34)" end="(398, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(398, 36)" end="(398, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(398, 36)" end="(398, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(398, 41)" end="(398, 42)">
                    <IdentNode start="(398, 41)" end="(398, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(398, 42)" end="(398, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(398, 44)" end="(398, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(398, 44)" end="(398, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(398, 45)" end="(398, 46)">
                <IdentNode start="(398, 45)" end="(398, 46)" leading="" trailing=" " raw_val="e" val="e"/>
              </NullNode>
              <NullNode start="(398, 47)" end="(398, 50)">
                <AtomNode start="(398, 47)" end="(398, 48)" leading="" trailing=" " val=":"/>
                <IdentNode start="(398, 49)" end="(398, 50)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(398, 50)" end="(398, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(398, 52)" end="(399, 55)">
            <AtomNode start="(398, 52)" end="(398, 53)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(399, 5)" end="(399, 55)" kind="«term_=_»">
              <OtherNode start="(399, 5)" end="(399, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(399, 5)" end="(399, 11)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                <NullNode start="(399, 12)" end="(399, 24)">
                  <IdentNode start="(399, 12)" end="(399, 13)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(399, 14)" end="(399, 24)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(399, 14)" end="(399, 15)" leading="" trailing="" val="("/>
                    <OtherNode start="(399, 15)" end="(399, 23)" kind="«term_++_»">
                      <IdentNode start="(399, 15)" end="(399, 16)" leading="" trailing=" " raw_val="l" val="l"/>
                      <AtomNode start="(399, 17)" end="(399, 19)" leading="" trailing=" " val="++"/>
                      <OtherNode start="(399, 20)" end="(399, 23)" kind="«term[_]»">
                        <AtomNode start="(399, 20)" end="(399, 21)" leading="" trailing="" val="["/>
                        <NullNode start="(399, 21)" end="(399, 22)">
                          <IdentNode start="(399, 21)" end="(399, 22)" leading="" trailing="" raw_val="e" val="e"/>
                        </NullNode>
                        <AtomNode start="(399, 22)" end="(399, 23)" leading="" trailing="" val="]"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(399, 23)" end="(399, 24)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(399, 25)" end="(399, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(399, 27)" end="(399, 55)" kind="«term_++_»">
                <OtherNode start="(399, 27)" end="(399, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(399, 27)" end="(399, 33)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                  <NullNode start="(399, 34)" end="(399, 37)">
                    <IdentNode start="(399, 34)" end="(399, 35)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(399, 36)" end="(399, 37)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(399, 38)" end="(399, 40)" leading="" trailing=" " val="++"/>
                <OtherNode start="(399, 41)" end="(399, 55)" kind="«term[_]»">
                  <AtomNode start="(399, 41)" end="(399, 42)" leading="" trailing="" val="["/>
                  <NullNode start="(399, 42)" end="(399, 54)">
                    <OtherNode start="(399, 42)" end="(399, 54)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(399, 42)" end="(399, 43)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(399, 44)" end="(399, 54)">
                        <IdentNode start="(399, 44)" end="(399, 52)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                        <IdentNode start="(399, 53)" end="(399, 54)" leading="" trailing="" raw_val="e" val="e"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(399, 54)" end="(399, 55)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(399, 56)" end="(400, 23)">
          <AtomNode start="(399, 56)" end="(399, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(399, 59)" end="(400, 23)">
            <AtomNode start="(399, 59)" end="(399, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(400, 3)" end="(400, 23)">
              <TacticTacticseq1IndentedNode start="(400, 3)" end="(400, 23)">
                <NullNode start="(400, 3)" end="(400, 23)">
                  <OtherNode start="(400, 3)" end="(400, 23)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;e : α&#10;⊢ mapIdx f (l ++ [e]) = mapIdx f l ++ [f l.length e]" state_after="no goals" tactic="simp [mapIdx_append]">
                    <AtomNode start="(400, 3)" end="(400, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(400, 8)" end="(400, 23)">
                      <AtomNode start="(400, 8)" end="(400, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(400, 9)" end="(400, 22)">
                        <OtherNode start="(400, 9)" end="(400, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(400, 9)" end="(400, 22)" leading="" trailing="" raw_val="mapIdx_append" val="mapIdx_append" full_name="List.mapIdx_append" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(392, 9)" def_end="(392, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(400, 22)" end="(400, 23)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(402, 1)" end="(403, 7)" name="mapIdx_singleton" full_name="List.mapIdx_singleton">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(402, 1)" end="(403, 7)" name="mapIdx_singleton" full_name="List.mapIdx_singleton" _is_private_decl="False">
        <AtomNode start="(402, 1)" end="(402, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(402, 9)" end="(402, 25)">
          <IdentNode start="(402, 9)" end="(402, 25)" leading="" trailing=" " raw_val="mapIdx_singleton" val="mapIdx_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(402, 26)" end="(402, 58)">
          <NullNode start="(402, 26)" end="(402, 33)">
            <OtherNode start="(402, 26)" end="(402, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(402, 26)" end="(402, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(402, 27)" end="(402, 28)">
                <IdentNode start="(402, 27)" end="(402, 28)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(402, 29)" end="(402, 32)">
                <AtomNode start="(402, 29)" end="(402, 30)" leading="" trailing=" " val=":"/>
                <IdentNode start="(402, 31)" end="(402, 32)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(402, 32)" end="(402, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(402, 34)" end="(402, 58)">
            <AtomNode start="(402, 34)" end="(402, 35)" leading="" trailing=" " val=":"/>
            <OtherNode start="(402, 36)" end="(402, 58)" kind="«term_=_»">
              <OtherNode start="(402, 36)" end="(402, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(402, 36)" end="(402, 42)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                <NullNode start="(402, 43)" end="(402, 48)">
                  <IdentNode start="(402, 43)" end="(402, 44)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(402, 45)" end="(402, 48)" kind="«term[_]»">
                    <AtomNode start="(402, 45)" end="(402, 46)" leading="" trailing="" val="["/>
                    <NullNode start="(402, 46)" end="(402, 47)">
                      <IdentNode start="(402, 46)" end="(402, 47)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(402, 47)" end="(402, 48)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(402, 49)" end="(402, 50)" leading="" trailing=" " val="="/>
              <OtherNode start="(402, 51)" end="(402, 58)" kind="«term[_]»">
                <AtomNode start="(402, 51)" end="(402, 52)" leading="" trailing="" val="["/>
                <NullNode start="(402, 52)" end="(402, 57)">
                  <OtherNode start="(402, 52)" end="(402, 57)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(402, 52)" end="(402, 53)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(402, 54)" end="(402, 57)">
                      <OtherNode start="(402, 54)" end="(402, 55)" kind="num">
                        <AtomNode start="(402, 54)" end="(402, 55)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                      <IdentNode start="(402, 56)" end="(402, 57)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(402, 57)" end="(402, 58)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(402, 59)" end="(403, 7)">
          <AtomNode start="(402, 59)" end="(402, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(402, 62)" end="(403, 7)">
            <AtomNode start="(402, 62)" end="(402, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(403, 3)" end="(403, 7)">
              <TacticTacticseq1IndentedNode start="(403, 3)" end="(403, 7)">
                <NullNode start="(403, 3)" end="(403, 7)">
                  <OtherNode start="(403, 3)" end="(403, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;a : α&#10;⊢ mapIdx f [a] = [f 0 a]" state_after="no goals" tactic="simp">
                    <AtomNode start="(403, 3)" end="(403, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(405, 1)" end="(407, 78)" name="mapIdx_eq_nil_iff" full_name="List.mapIdx_eq_nil_iff">
      <CommandDeclmodifiersNode start="(405, 1)" end="(405, 8)">
        <NullNode/>
        <NullNode start="(405, 1)" end="(405, 8)">
          <OtherNode start="(405, 1)" end="(405, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(405, 1)" end="(405, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(405, 3)" end="(405, 7)">
              <OtherNode start="(405, 3)" end="(405, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(405, 3)" end="(405, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(405, 3)" end="(405, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(405, 7)" end="(405, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(406, 1)" end="(407, 78)" name="mapIdx_eq_nil_iff" full_name="List.mapIdx_eq_nil_iff" _is_private_decl="False">
        <AtomNode start="(406, 1)" end="(406, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(406, 9)" end="(406, 26)">
          <IdentNode start="(406, 9)" end="(406, 26)" leading="" trailing=" " raw_val="mapIdx_eq_nil_iff" val="mapIdx_eq_nil_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(406, 27)" end="(406, 71)">
          <NullNode start="(406, 27)" end="(406, 39)">
            <OtherNode start="(406, 27)" end="(406, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(406, 27)" end="(406, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(406, 28)" end="(406, 29)">
                <IdentNode start="(406, 28)" end="(406, 29)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(406, 30)" end="(406, 38)">
                <AtomNode start="(406, 30)" end="(406, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(406, 32)" end="(406, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(406, 32)" end="(406, 36)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(406, 37)" end="(406, 38)">
                    <IdentNode start="(406, 37)" end="(406, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(406, 38)" end="(406, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(406, 40)" end="(406, 71)">
            <AtomNode start="(406, 40)" end="(406, 41)" leading="" trailing=" " val=":"/>
            <OtherNode start="(406, 42)" end="(406, 71)" kind="«term_↔_»">
              <OtherNode start="(406, 42)" end="(406, 62)" kind="«term_=_»">
                <OtherNode start="(406, 42)" end="(406, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(406, 42)" end="(406, 53)" leading="" trailing=" " raw_val="List.mapIdx" val="List.mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                  <NullNode start="(406, 54)" end="(406, 57)">
                    <IdentNode start="(406, 54)" end="(406, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(406, 56)" end="(406, 57)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(406, 58)" end="(406, 59)" leading="" trailing=" " val="="/>
                <OtherNode start="(406, 60)" end="(406, 62)" kind="«term[_]»">
                  <AtomNode start="(406, 60)" end="(406, 61)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(406, 61)" end="(406, 62)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(406, 63)" end="(406, 64)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(406, 65)" end="(406, 71)" kind="«term_=_»">
                <IdentNode start="(406, 65)" end="(406, 66)" leading="" trailing=" " raw_val="l" val="l"/>
                <AtomNode start="(406, 67)" end="(406, 68)" leading="" trailing=" " val="="/>
                <OtherNode start="(406, 69)" end="(406, 71)" kind="«term[_]»">
                  <AtomNode start="(406, 69)" end="(406, 70)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(406, 70)" end="(406, 71)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(406, 72)" end="(407, 78)">
          <AtomNode start="(406, 72)" end="(406, 74)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(406, 75)" end="(407, 78)">
            <AtomNode start="(406, 75)" end="(406, 77)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(407, 3)" end="(407, 78)">
              <TacticTacticseq1IndentedNode start="(407, 3)" end="(407, 78)">
                <NullNode start="(407, 3)" end="(407, 78)">
                  <OtherNode start="(407, 3)" end="(407, 78)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;⊢ mapIdx f l = [] ↔ l = []" state_after="no goals" tactic="rw [List.mapIdx_eq_zipIdx_map, List.map_eq_nil_iff, List.zipIdx_eq_nil_iff]">
                    <AtomNode start="(407, 3)" end="(407, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(407, 6)" end="(407, 78)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(407, 6)" end="(407, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(407, 7)" end="(407, 77)">
                        <OtherNode start="(407, 7)" end="(407, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(407, 7)" end="(407, 32)" leading="" trailing="" raw_val="List.mapIdx_eq_zipIdx_map" val="List.mapIdx_eq_zipIdx_map" full_name="List.mapIdx_eq_zipIdx_map" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(378, 9)" def_end="(378, 29)"/>
                        </OtherNode>
                        <AtomNode start="(407, 32)" end="(407, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(407, 34)" end="(407, 53)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(407, 34)" end="(407, 53)" leading="" trailing="" raw_val="List.map_eq_nil_iff" val="List.map_eq_nil_iff" full_name="List.map_eq_nil_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(407, 53)" end="(407, 54)" leading="" trailing=" " val=","/>
                        <OtherNode start="(407, 55)" end="(407, 77)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(407, 55)" end="(407, 77)" leading="" trailing="" raw_val="List.zipIdx_eq_nil_iff" val="List.zipIdx_eq_nil_iff" full_name="List.zipIdx_eq_nil_iff" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(407, 77)" end="(407, 78)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(409, 1)" end="(411, 7)" name="mapIdx_ne_nil_iff" full_name="List.mapIdx_ne_nil_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(409, 1)" end="(411, 7)" name="mapIdx_ne_nil_iff" full_name="List.mapIdx_ne_nil_iff" _is_private_decl="False">
        <AtomNode start="(409, 1)" end="(409, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(409, 9)" end="(409, 26)">
          <IdentNode start="(409, 9)" end="(409, 26)" leading="" trailing=" " raw_val="mapIdx_ne_nil_iff" val="mapIdx_ne_nil_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(409, 27)" end="(410, 34)">
          <NullNode start="(409, 27)" end="(409, 39)">
            <OtherNode start="(409, 27)" end="(409, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(409, 27)" end="(409, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(409, 28)" end="(409, 29)">
                <IdentNode start="(409, 28)" end="(409, 29)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(409, 30)" end="(409, 38)">
                <AtomNode start="(409, 30)" end="(409, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(409, 32)" end="(409, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(409, 32)" end="(409, 36)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(409, 37)" end="(409, 38)">
                    <IdentNode start="(409, 37)" end="(409, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(409, 38)" end="(409, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(409, 40)" end="(410, 34)">
            <AtomNode start="(409, 40)" end="(409, 41)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(410, 5)" end="(410, 34)" kind="«term_↔_»">
              <OtherNode start="(410, 5)" end="(410, 25)" kind="«term_≠_»">
                <OtherNode start="(410, 5)" end="(410, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(410, 5)" end="(410, 16)" leading="" trailing=" " raw_val="List.mapIdx" val="List.mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                  <NullNode start="(410, 17)" end="(410, 20)">
                    <IdentNode start="(410, 17)" end="(410, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(410, 19)" end="(410, 20)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(410, 21)" end="(410, 22)" leading="" trailing=" " val="≠"/>
                <OtherNode start="(410, 23)" end="(410, 25)" kind="«term[_]»">
                  <AtomNode start="(410, 23)" end="(410, 24)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(410, 24)" end="(410, 25)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(410, 26)" end="(410, 27)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(410, 28)" end="(410, 34)" kind="«term_≠_»">
                <IdentNode start="(410, 28)" end="(410, 29)" leading="" trailing=" " raw_val="l" val="l"/>
                <AtomNode start="(410, 30)" end="(410, 31)" leading="" trailing=" " val="≠"/>
                <OtherNode start="(410, 32)" end="(410, 34)" kind="«term[_]»">
                  <AtomNode start="(410, 32)" end="(410, 33)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(410, 33)" end="(410, 34)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(410, 35)" end="(411, 7)">
          <AtomNode start="(410, 35)" end="(410, 37)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(410, 38)" end="(411, 7)">
            <AtomNode start="(410, 38)" end="(410, 40)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(411, 3)" end="(411, 7)">
              <TacticTacticseq1IndentedNode start="(411, 3)" end="(411, 7)">
                <NullNode start="(411, 3)" end="(411, 7)">
                  <OtherNode start="(411, 3)" end="(411, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;⊢ mapIdx f l ≠ [] ↔ l ≠ []" state_after="no goals" tactic="simp">
                    <AtomNode start="(411, 3)" end="(411, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(413, 1)" end="(416, 57)" name="exists_of_mem_mapIdx" full_name="List.exists_of_mem_mapIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(413, 1)" end="(416, 57)" name="exists_of_mem_mapIdx" full_name="List.exists_of_mem_mapIdx" _is_private_decl="False">
        <AtomNode start="(413, 1)" end="(413, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(413, 9)" end="(413, 29)">
          <IdentNode start="(413, 9)" end="(413, 29)" leading="" trailing=" " raw_val="exists_of_mem_mapIdx" val="exists_of_mem_mapIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(413, 30)" end="(414, 72)">
          <NullNode start="(413, 30)" end="(414, 25)">
            <OtherNode start="(413, 30)" end="(413, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(413, 30)" end="(413, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(413, 31)" end="(413, 32)">
                <IdentNode start="(413, 31)" end="(413, 32)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(413, 33)" end="(413, 36)">
                <AtomNode start="(413, 33)" end="(413, 34)" leading="" trailing=" " val=":"/>
                <IdentNode start="(413, 35)" end="(413, 36)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(413, 36)" end="(413, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(413, 38)" end="(413, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(413, 38)" end="(413, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(413, 39)" end="(413, 40)">
                <IdentNode start="(413, 39)" end="(413, 40)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(413, 41)" end="(413, 49)">
                <AtomNode start="(413, 41)" end="(413, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(413, 43)" end="(413, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(413, 43)" end="(413, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(413, 48)" end="(413, 49)">
                    <IdentNode start="(413, 48)" end="(413, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(413, 49)" end="(413, 50)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(414, 5)" end="(414, 25)">
              <AtomNode start="(414, 5)" end="(414, 6)" leading="" trailing="" val="("/>
              <NullNode start="(414, 6)" end="(414, 7)">
                <IdentNode start="(414, 6)" end="(414, 7)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(414, 8)" end="(414, 24)">
                <AtomNode start="(414, 8)" end="(414, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(414, 10)" end="(414, 24)" kind="«term_∈_»">
                  <IdentNode start="(414, 10)" end="(414, 11)" leading="" trailing=" " raw_val="b" val="b"/>
                  <AtomNode start="(414, 12)" end="(414, 13)" leading="" trailing=" " val="∈"/>
                  <OtherNode start="(414, 14)" end="(414, 24)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(414, 14)" end="(414, 20)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                    <NullNode start="(414, 21)" end="(414, 24)">
                      <IdentNode start="(414, 21)" end="(414, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(414, 23)" end="(414, 24)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(414, 24)" end="(414, 25)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(414, 26)" end="(414, 72)">
            <AtomNode start="(414, 26)" end="(414, 27)" leading="" trailing=" " val=":"/>
            <OtherNode start="(414, 28)" end="(414, 72)" kind="«term∃_,_»">
              <AtomNode start="(414, 28)" end="(414, 29)" leading="" trailing=" " val="∃"/>
              <OtherNode start="(414, 30)" end="(414, 58)" kind="Lean.explicitBinders">
                <NullNode start="(414, 30)" end="(414, 58)">
                  <OtherNode start="(414, 30)" end="(414, 39)" kind="Lean.bracketedExplicitBinders">
                    <AtomNode start="(414, 30)" end="(414, 31)" leading="" trailing="" val="("/>
                    <NullNode start="(414, 31)" end="(414, 32)">
                      <LeanBinderidentNode start="(414, 31)" end="(414, 32)">
                        <IdentNode start="(414, 31)" end="(414, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <AtomNode start="(414, 33)" end="(414, 34)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(414, 35)" end="(414, 38)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <AtomNode start="(414, 38)" end="(414, 39)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(414, 40)" end="(414, 58)" kind="Lean.bracketedExplicitBinders">
                    <AtomNode start="(414, 40)" end="(414, 41)" leading="" trailing="" val="("/>
                    <NullNode start="(414, 41)" end="(414, 42)">
                      <LeanBinderidentNode start="(414, 41)" end="(414, 42)">
                        <IdentNode start="(414, 41)" end="(414, 42)" leading="" trailing=" " raw_val="h" val="h"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <AtomNode start="(414, 43)" end="(414, 44)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(414, 45)" end="(414, 57)" kind="«term_&amp;lt;_»">
                      <IdentNode start="(414, 45)" end="(414, 46)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(414, 47)" end="(414, 48)" leading="" trailing=" " val="&amp;lt;"/>
                      <IdentNode start="(414, 49)" end="(414, 57)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                    </OtherNode>
                    <AtomNode start="(414, 57)" end="(414, 58)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(414, 58)" end="(414, 59)" leading="" trailing=" " val=","/>
              <OtherNode start="(414, 60)" end="(414, 72)" kind="«term_=_»">
                <OtherNode start="(414, 60)" end="(414, 68)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(414, 60)" end="(414, 61)" leading="" trailing=" " raw_val="f" val="f"/>
                  <NullNode start="(414, 62)" end="(414, 68)">
                    <IdentNode start="(414, 62)" end="(414, 63)" leading="" trailing=" " raw_val="i" val="i"/>
                    <OtherNode start="(414, 64)" end="(414, 68)" kind="«term__[_]»">
                      <IdentNode start="(414, 64)" end="(414, 65)" leading="" trailing="" raw_val="l" val="l"/>
                      <AtomNode start="(414, 65)" end="(414, 66)" leading="" trailing="" val="["/>
                      <IdentNode start="(414, 66)" end="(414, 67)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(414, 67)" end="(414, 68)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(414, 69)" end="(414, 70)" leading="" trailing=" " val="="/>
                <IdentNode start="(414, 71)" end="(414, 72)" leading="" trailing=" " raw_val="b" val="b"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(414, 73)" end="(416, 57)">
          <AtomNode start="(414, 73)" end="(414, 75)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(414, 76)" end="(416, 57)">
            <AtomNode start="(414, 76)" end="(414, 78)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(415, 3)" end="(416, 57)">
              <TacticTacticseq1IndentedNode start="(415, 3)" end="(416, 57)">
                <NullNode start="(415, 3)" end="(416, 57)">
                  <OtherNode start="(415, 3)" end="(415, 32)" kind="Lean.Parser.Tactic.rwSeq" state_before="β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;b : β&#10;l : List α&#10;h : b ∈ mapIdx f l&#10;⊢ ∃ i h, f i l[i] = b" state_after="β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;b : β&#10;l : List α&#10;h : b ∈ l.mapFinIdx fun i a x =&amp;gt; f i a&#10;⊢ ∃ i h, f i l[i] = b" tactic="rw [mapIdx_eq_mapFinIdx] at h">
                    <AtomNode start="(415, 3)" end="(415, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(415, 6)" end="(415, 27)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(415, 6)" end="(415, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(415, 7)" end="(415, 26)">
                        <OtherNode start="(415, 7)" end="(415, 26)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(415, 7)" end="(415, 26)" leading="" trailing="" raw_val="mapIdx_eq_mapFinIdx" val="mapIdx_eq_mapFinIdx" full_name="List.mapIdx_eq_mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(374, 9)" def_end="(374, 28)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(415, 26)" end="(415, 27)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(415, 28)" end="(415, 32)">
                      <OtherNode start="(415, 28)" end="(415, 32)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(415, 28)" end="(415, 30)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(415, 31)" end="(415, 32)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(415, 31)" end="(415, 32)">
                            <IdentNode start="(415, 31)" end="(415, 32)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(416, 3)" end="(416, 57)" kind="Lean.Parser.Tactic.simpa" state_before="β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;b : β&#10;l : List α&#10;h : b ∈ l.mapFinIdx fun i a x =&amp;gt; f i a&#10;⊢ ∃ i h, f i l[i] = b" state_after="no goals" tactic="simpa [Fin.exists_iff] using exists_of_mem_mapFinIdx h">
                    <AtomNode start="(416, 3)" end="(416, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(416, 9)" end="(416, 57)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(416, 9)" end="(416, 25)">
                        <OtherNode start="(416, 9)" end="(416, 25)" kind="Lean.Parser.Tactic.simpArgs">
                          <AtomNode start="(416, 9)" end="(416, 10)" leading="" trailing="" val="["/>
                          <NullNode start="(416, 10)" end="(416, 24)">
                            <OtherNode start="(416, 10)" end="(416, 24)" kind="Lean.Parser.Tactic.simpLemma">
                              <NullNode/>
                              <NullNode/>
                              <IdentNode start="(416, 10)" end="(416, 24)" leading="" trailing="" raw_val="Fin.exists_iff" val="Fin.exists_iff" full_name="Fin.exists_iff" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                            </OtherNode>
                          </NullNode>
                          <AtomNode start="(416, 24)" end="(416, 25)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode start="(416, 26)" end="(416, 57)">
                        <AtomNode start="(416, 26)" end="(416, 31)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(416, 32)" end="(416, 57)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(416, 32)" end="(416, 55)" leading="" trailing=" " raw_val="exists_of_mem_mapFinIdx" val="exists_of_mem_mapFinIdx" full_name="List.exists_of_mem_mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(194, 9)" def_end="(194, 32)"/>
                          <NullNode start="(416, 56)" end="(416, 57)">
                            <IdentNode start="(416, 56)" end="(416, 57)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(418, 1)" end="(425, 41)" name="mem_mapIdx" full_name="List.mem_mapIdx">
      <CommandDeclmodifiersNode start="(418, 1)" end="(418, 8)">
        <NullNode/>
        <NullNode start="(418, 1)" end="(418, 8)">
          <OtherNode start="(418, 1)" end="(418, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(418, 1)" end="(418, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(418, 3)" end="(418, 7)">
              <OtherNode start="(418, 3)" end="(418, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(418, 3)" end="(418, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(418, 3)" end="(418, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(418, 7)" end="(418, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(418, 9)" end="(425, 41)" name="mem_mapIdx" full_name="List.mem_mapIdx" _is_private_decl="False">
        <AtomNode start="(418, 9)" end="(418, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(418, 17)" end="(418, 27)">
          <IdentNode start="(418, 17)" end="(418, 27)" leading="" trailing=" " raw_val="mem_mapIdx" val="mem_mapIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(418, 28)" end="(419, 66)">
          <NullNode start="(418, 28)" end="(418, 48)">
            <OtherNode start="(418, 28)" end="(418, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(418, 28)" end="(418, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(418, 29)" end="(418, 30)">
                <IdentNode start="(418, 29)" end="(418, 30)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(418, 31)" end="(418, 34)">
                <AtomNode start="(418, 31)" end="(418, 32)" leading="" trailing=" " val=":"/>
                <IdentNode start="(418, 33)" end="(418, 34)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(418, 34)" end="(418, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(418, 36)" end="(418, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(418, 36)" end="(418, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(418, 37)" end="(418, 38)">
                <IdentNode start="(418, 37)" end="(418, 38)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(418, 39)" end="(418, 47)">
                <AtomNode start="(418, 39)" end="(418, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(418, 41)" end="(418, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(418, 41)" end="(418, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(418, 46)" end="(418, 47)">
                    <IdentNode start="(418, 46)" end="(418, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(418, 47)" end="(418, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(418, 49)" end="(419, 66)">
            <AtomNode start="(418, 49)" end="(418, 50)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(419, 5)" end="(419, 66)" kind="«term_↔_»">
              <OtherNode start="(419, 5)" end="(419, 19)" kind="«term_∈_»">
                <IdentNode start="(419, 5)" end="(419, 6)" leading="" trailing=" " raw_val="b" val="b"/>
                <AtomNode start="(419, 7)" end="(419, 8)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(419, 9)" end="(419, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(419, 9)" end="(419, 15)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                  <NullNode start="(419, 16)" end="(419, 19)">
                    <IdentNode start="(419, 16)" end="(419, 17)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(419, 18)" end="(419, 19)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(419, 20)" end="(419, 21)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(419, 22)" end="(419, 66)" kind="«term∃_,_»">
                <AtomNode start="(419, 22)" end="(419, 23)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(419, 24)" end="(419, 52)" kind="Lean.explicitBinders">
                  <NullNode start="(419, 24)" end="(419, 52)">
                    <OtherNode start="(419, 24)" end="(419, 33)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(419, 24)" end="(419, 25)" leading="" trailing="" val="("/>
                      <NullNode start="(419, 25)" end="(419, 26)">
                        <LeanBinderidentNode start="(419, 25)" end="(419, 26)">
                          <IdentNode start="(419, 25)" end="(419, 26)" leading="" trailing=" " raw_val="i" val="i"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(419, 27)" end="(419, 28)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(419, 29)" end="(419, 32)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(419, 32)" end="(419, 33)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(419, 34)" end="(419, 52)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(419, 34)" end="(419, 35)" leading="" trailing="" val="("/>
                      <NullNode start="(419, 35)" end="(419, 36)">
                        <LeanBinderidentNode start="(419, 35)" end="(419, 36)">
                          <IdentNode start="(419, 35)" end="(419, 36)" leading="" trailing=" " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(419, 37)" end="(419, 38)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(419, 39)" end="(419, 51)" kind="«term_&amp;lt;_»">
                        <IdentNode start="(419, 39)" end="(419, 40)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(419, 41)" end="(419, 42)" leading="" trailing=" " val="&amp;lt;"/>
                        <IdentNode start="(419, 43)" end="(419, 51)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                      </OtherNode>
                      <AtomNode start="(419, 51)" end="(419, 52)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(419, 52)" end="(419, 53)" leading="" trailing=" " val=","/>
                <OtherNode start="(419, 54)" end="(419, 66)" kind="«term_=_»">
                  <OtherNode start="(419, 54)" end="(419, 62)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(419, 54)" end="(419, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(419, 56)" end="(419, 62)">
                      <IdentNode start="(419, 56)" end="(419, 57)" leading="" trailing=" " raw_val="i" val="i"/>
                      <OtherNode start="(419, 58)" end="(419, 62)" kind="«term__[_]»">
                        <IdentNode start="(419, 58)" end="(419, 59)" leading="" trailing="" raw_val="l" val="l"/>
                        <AtomNode start="(419, 59)" end="(419, 60)" leading="" trailing="" val="["/>
                        <IdentNode start="(419, 60)" end="(419, 61)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(419, 61)" end="(419, 62)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(419, 63)" end="(419, 64)" leading="" trailing=" " val="="/>
                  <IdentNode start="(419, 65)" end="(419, 66)" leading="" trailing=" " raw_val="b" val="b"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(419, 67)" end="(425, 41)">
          <AtomNode start="(419, 67)" end="(419, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(419, 70)" end="(425, 41)">
            <AtomNode start="(419, 70)" end="(419, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(420, 3)" end="(425, 41)">
              <TacticTacticseq1IndentedNode start="(420, 3)" end="(425, 41)">
                <NullNode start="(420, 3)" end="(425, 41)">
                  <OtherNode start="(420, 3)" end="(420, 14)" kind="Lean.Parser.Tactic.constructor" state_before="β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;b : β&#10;l : List α&#10;⊢ b ∈ mapIdx f l ↔ ∃ i h, f i l[i] = b" state_after="case mp&#10;β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;b : β&#10;l : List α&#10;⊢ b ∈ mapIdx f l → ∃ i h, f i l[i] = b&#10;&#10;case mpr&#10;β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;b : β&#10;l : List α&#10;⊢ (∃ i h, f i l[i] = b) → b ∈ mapIdx f l" tactic="constructor">
                    <AtomNode start="(420, 3)" end="(420, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(421, 3)" end="(422, 33)" kind="Lean.cdot" state_before="case mp&#10;β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;b : β&#10;l : List α&#10;⊢ b ∈ mapIdx f l → ∃ i h, f i l[i] = b&#10;&#10;case mpr&#10;β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;b : β&#10;l : List α&#10;⊢ (∃ i h, f i l[i] = b) → b ∈ mapIdx f l" state_after="case mpr&#10;β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;b : β&#10;l : List α&#10;⊢ (∃ i h, f i l[i] = b) → b ∈ mapIdx f l" tactic="· intro h&#10;  exact exists_of_mem_mapIdx h">
                    <OtherNode start="(421, 3)" end="(421, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(421, 3)" end="(421, 4)" kind="patternIgnore">
                        <OtherNode start="(421, 3)" end="(421, 4)" kind="token.«· »">
                          <AtomNode start="(421, 3)" end="(421, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(421, 5)" end="(422, 33)">
                      <TacticTacticseq1IndentedNode start="(421, 5)" end="(422, 33)">
                        <NullNode start="(421, 5)" end="(422, 33)">
                          <OtherNode start="(421, 5)" end="(421, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;b : β&#10;l : List α&#10;⊢ b ∈ mapIdx f l → ∃ i h, f i l[i] = b" state_after="case mp&#10;β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;b : β&#10;l : List α&#10;h : b ∈ mapIdx f l&#10;⊢ ∃ i h, f i l[i] = b" tactic="intro h">
                            <AtomNode start="(421, 5)" end="(421, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(421, 11)" end="(421, 12)">
                              <IdentNode start="(421, 11)" end="(421, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(422, 5)" end="(422, 33)" kind="Lean.Parser.Tactic.exact" state_before="case mp&#10;β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;b : β&#10;l : List α&#10;h : b ∈ mapIdx f l&#10;⊢ ∃ i h, f i l[i] = b" state_after="no goals" tactic="exact exists_of_mem_mapIdx h">
                            <AtomNode start="(422, 5)" end="(422, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(422, 11)" end="(422, 33)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(422, 11)" end="(422, 31)" leading="" trailing=" " raw_val="exists_of_mem_mapIdx" val="exists_of_mem_mapIdx" full_name="List.exists_of_mem_mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(413, 9)" def_end="(413, 29)"/>
                              <NullNode start="(422, 32)" end="(422, 33)">
                                <IdentNode start="(422, 32)" end="(422, 33)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(423, 3)" end="(425, 41)" kind="Lean.cdot" state_before="case mpr&#10;β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;b : β&#10;l : List α&#10;⊢ (∃ i h, f i l[i] = b) → b ∈ mapIdx f l" state_after="no goals" tactic="· rintro ⟨i, h, rfl⟩&#10;  rw [mem_iff_getElem]&#10;  exact ⟨i, by simpa using h, by simp⟩">
                    <OtherNode start="(423, 3)" end="(423, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(423, 3)" end="(423, 4)" kind="patternIgnore">
                        <OtherNode start="(423, 3)" end="(423, 4)" kind="token.«· »">
                          <AtomNode start="(423, 3)" end="(423, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(423, 5)" end="(425, 41)">
                      <TacticTacticseq1IndentedNode start="(423, 5)" end="(425, 41)">
                        <NullNode start="(423, 5)" end="(425, 41)">
                          <OtherNode start="(423, 5)" end="(423, 23)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;b : β&#10;l : List α&#10;⊢ (∃ i h, f i l[i] = b) → b ∈ mapIdx f l" state_after="case mpr.intro.intro&#10;β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f i l[i] ∈ mapIdx f l" tactic="rintro ⟨i, h, rfl⟩">
                            <AtomNode start="(423, 5)" end="(423, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(423, 12)" end="(423, 23)">
                              <OtherNode start="(423, 12)" end="(423, 23)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(423, 12)" end="(423, 23)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(423, 12)" end="(423, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(423, 13)" end="(423, 22)">
                                    <OtherNode start="(423, 13)" end="(423, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(423, 13)" end="(423, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(423, 13)" end="(423, 14)">
                                          <OtherNode start="(423, 13)" end="(423, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(423, 13)" end="(423, 14)" leading="" trailing="" raw_val="i" val="i"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(423, 14)" end="(423, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(423, 16)" end="(423, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(423, 16)" end="(423, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(423, 16)" end="(423, 17)">
                                          <OtherNode start="(423, 16)" end="(423, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(423, 16)" end="(423, 17)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(423, 17)" end="(423, 18)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(423, 19)" end="(423, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(423, 19)" end="(423, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(423, 19)" end="(423, 22)">
                                          <OtherNode start="(423, 19)" end="(423, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(423, 19)" end="(423, 22)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(423, 22)" end="(423, 23)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(424, 5)" end="(424, 25)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr.intro.intro&#10;β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f i l[i] ∈ mapIdx f l" state_after="case mpr.intro.intro&#10;β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ ∃ i_1 h_1, (mapIdx f l)[i_1] = f i l[i]" tactic="rw [mem_iff_getElem]">
                            <AtomNode start="(424, 5)" end="(424, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(424, 8)" end="(424, 25)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(424, 8)" end="(424, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(424, 9)" end="(424, 24)">
                                <OtherNode start="(424, 9)" end="(424, 24)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(424, 9)" end="(424, 24)" leading="" trailing="" raw_val="mem_iff_getElem" val="mem_iff_getElem" full_name="List.mem_iff_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(424, 24)" end="(424, 25)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(425, 5)" end="(425, 41)" kind="Lean.Parser.Tactic.exact" state_before="case mpr.intro.intro&#10;β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ ∃ i_1 h_1, (mapIdx f l)[i_1] = f i l[i]" state_after="no goals" tactic="exact ⟨i, by simpa using h, by simp⟩">
                            <AtomNode start="(425, 5)" end="(425, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(425, 11)" end="(425, 41)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(425, 11)" end="(425, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(425, 12)" end="(425, 40)">
                                <IdentNode start="(425, 12)" end="(425, 13)" leading="" trailing="" raw_val="i" val="i"/>
                                <AtomNode start="(425, 13)" end="(425, 14)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(425, 15)" end="(425, 31)">
                                  <AtomNode start="(425, 15)" end="(425, 17)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(425, 18)" end="(425, 31)">
                                    <TacticTacticseq1IndentedNode start="(425, 18)" end="(425, 31)">
                                      <NullNode start="(425, 18)" end="(425, 31)">
                                        <OtherNode start="(425, 18)" end="(425, 31)" kind="Lean.Parser.Tactic.simpa" state_before="β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ i &amp;lt; (mapIdx f l).length" state_after="no goals" tactic="simpa using h">
                                          <AtomNode start="(425, 18)" end="(425, 23)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(425, 24)" end="(425, 31)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(425, 24)" end="(425, 31)">
                                              <AtomNode start="(425, 24)" end="(425, 29)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(425, 30)" end="(425, 31)" leading="" trailing="" raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(425, 31)" end="(425, 32)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(425, 33)" end="(425, 40)">
                                  <AtomNode start="(425, 33)" end="(425, 35)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(425, 36)" end="(425, 40)">
                                    <TacticTacticseq1IndentedNode start="(425, 36)" end="(425, 40)">
                                      <NullNode start="(425, 36)" end="(425, 40)">
                                        <OtherNode start="(425, 36)" end="(425, 40)" kind="Lean.Parser.Tactic.simp" state_before="β : Type u_1&#10;α : Type u_2&#10;f : Nat → α → β&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ (mapIdx f l)[i] = f i l[i]" state_after="no goals" tactic="simp">
                                          <AtomNode start="(425, 36)" end="(425, 40)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(425, 40)" end="(425, 41)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(427, 1)" end="(430, 31)" name="mapIdx_eq_cons_iff" full_name="List.mapIdx_eq_cons_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(427, 1)" end="(430, 31)" name="mapIdx_eq_cons_iff" full_name="List.mapIdx_eq_cons_iff" _is_private_decl="False">
        <AtomNode start="(427, 1)" end="(427, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(427, 9)" end="(427, 27)">
          <IdentNode start="(427, 9)" end="(427, 27)" leading="" trailing=" " raw_val="mapIdx_eq_cons_iff" val="mapIdx_eq_cons_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(427, 28)" end="(429, 93)">
          <NullNode start="(427, 28)" end="(427, 48)">
            <OtherNode start="(427, 28)" end="(427, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(427, 28)" end="(427, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(427, 29)" end="(427, 30)">
                <IdentNode start="(427, 29)" end="(427, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(427, 31)" end="(427, 39)">
                <AtomNode start="(427, 31)" end="(427, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(427, 33)" end="(427, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(427, 33)" end="(427, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(427, 38)" end="(427, 39)">
                    <IdentNode start="(427, 38)" end="(427, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(427, 39)" end="(427, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(427, 41)" end="(427, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(427, 41)" end="(427, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(427, 42)" end="(427, 43)">
                <IdentNode start="(427, 42)" end="(427, 43)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(427, 44)" end="(427, 47)">
                <AtomNode start="(427, 44)" end="(427, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(427, 46)" end="(427, 47)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(427, 47)" end="(427, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(427, 49)" end="(429, 93)">
            <AtomNode start="(427, 49)" end="(427, 50)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(428, 5)" end="(429, 93)" kind="«term_↔_»">
              <OtherNode start="(428, 5)" end="(428, 25)" kind="«term_=_»">
                <OtherNode start="(428, 5)" end="(428, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(428, 5)" end="(428, 11)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                  <NullNode start="(428, 12)" end="(428, 15)">
                    <IdentNode start="(428, 12)" end="(428, 13)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(428, 14)" end="(428, 15)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(428, 16)" end="(428, 17)" leading="" trailing=" " val="="/>
                <OtherNode start="(428, 18)" end="(428, 25)" kind="«term_::_»">
                  <IdentNode start="(428, 18)" end="(428, 19)" leading="" trailing=" " raw_val="b" val="b"/>
                  <AtomNode start="(428, 20)" end="(428, 22)" leading="" trailing=" " val="::"/>
                  <IdentNode start="(428, 23)" end="(428, 25)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(428, 26)" end="(428, 27)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(429, 7)" end="(429, 93)" kind="«term∃_,_»">
                <AtomNode start="(429, 7)" end="(429, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(429, 9)" end="(429, 30)" kind="Lean.explicitBinders">
                  <NullNode start="(429, 9)" end="(429, 30)">
                    <OtherNode start="(429, 9)" end="(429, 16)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(429, 9)" end="(429, 10)" leading="" trailing="" val="("/>
                      <NullNode start="(429, 10)" end="(429, 11)">
                        <LeanBinderidentNode start="(429, 10)" end="(429, 11)">
                          <IdentNode start="(429, 10)" end="(429, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(429, 12)" end="(429, 13)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(429, 14)" end="(429, 15)" leading="" trailing="" raw_val="α" val="α"/>
                      <AtomNode start="(429, 15)" end="(429, 16)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(429, 17)" end="(429, 30)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(429, 17)" end="(429, 18)" leading="" trailing="" val="("/>
                      <NullNode start="(429, 18)" end="(429, 20)">
                        <LeanBinderidentNode start="(429, 18)" end="(429, 20)">
                          <IdentNode start="(429, 18)" end="(429, 20)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(429, 21)" end="(429, 22)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(429, 23)" end="(429, 29)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(429, 23)" end="(429, 27)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(429, 28)" end="(429, 29)">
                          <IdentNode start="(429, 28)" end="(429, 29)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(429, 29)" end="(429, 30)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(429, 30)" end="(429, 31)" leading="" trailing=" " val=","/>
                <OtherNode start="(429, 32)" end="(429, 93)" kind="«term_∧_»">
                  <OtherNode start="(429, 32)" end="(429, 43)" kind="«term_=_»">
                    <IdentNode start="(429, 32)" end="(429, 33)" leading="" trailing=" " raw_val="l" val="l"/>
                    <AtomNode start="(429, 34)" end="(429, 35)" leading="" trailing=" " val="="/>
                    <OtherNode start="(429, 36)" end="(429, 43)" kind="«term_::_»">
                      <IdentNode start="(429, 36)" end="(429, 37)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(429, 38)" end="(429, 40)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(429, 41)" end="(429, 43)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(429, 44)" end="(429, 45)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(429, 46)" end="(429, 93)" kind="«term_∧_»">
                    <OtherNode start="(429, 46)" end="(429, 55)" kind="«term_=_»">
                      <OtherNode start="(429, 46)" end="(429, 51)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(429, 46)" end="(429, 47)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(429, 48)" end="(429, 51)">
                          <OtherNode start="(429, 48)" end="(429, 49)" kind="num">
                            <AtomNode start="(429, 48)" end="(429, 49)" leading="" trailing=" " val="0"/>
                          </OtherNode>
                          <IdentNode start="(429, 50)" end="(429, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(429, 52)" end="(429, 53)" leading="" trailing=" " val="="/>
                      <IdentNode start="(429, 54)" end="(429, 55)" leading="" trailing=" " raw_val="b" val="b"/>
                    </OtherNode>
                    <AtomNode start="(429, 56)" end="(429, 57)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(429, 58)" end="(429, 93)" kind="«term_=_»">
                      <OtherNode start="(429, 58)" end="(429, 88)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(429, 58)" end="(429, 64)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                        <NullNode start="(429, 65)" end="(429, 88)">
                          <OtherNode start="(429, 65)" end="(429, 85)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(429, 65)" end="(429, 66)" leading="" trailing="" val="("/>
                            <OtherNode start="(429, 66)" end="(429, 84)" kind="Lean.Parser.Term.fun">
                              <AtomNode start="(429, 66)" end="(429, 69)" leading="" trailing=" " val="fun"/>
                              <OtherNode start="(429, 70)" end="(429, 84)" kind="Lean.Parser.Term.basicFun">
                                <NullNode start="(429, 70)" end="(429, 71)">
                                  <IdentNode start="(429, 70)" end="(429, 71)" leading="" trailing=" " raw_val="i" val="i"/>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(429, 72)" end="(429, 74)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(429, 75)" end="(429, 84)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(429, 75)" end="(429, 76)" leading="" trailing=" " raw_val="f" val="f"/>
                                  <NullNode start="(429, 77)" end="(429, 84)">
                                    <OtherNode start="(429, 77)" end="(429, 84)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(429, 77)" end="(429, 78)" leading="" trailing="" val="("/>
                                      <OtherNode start="(429, 78)" end="(429, 83)" kind="«term_+_»">
                                        <IdentNode start="(429, 78)" end="(429, 79)" leading="" trailing=" " raw_val="i" val="i"/>
                                        <AtomNode start="(429, 80)" end="(429, 81)" leading="" trailing=" " val="+"/>
                                        <OtherNode start="(429, 82)" end="(429, 83)" kind="num">
                                          <AtomNode start="(429, 82)" end="(429, 83)" leading="" trailing="" val="1"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(429, 83)" end="(429, 84)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(429, 84)" end="(429, 85)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <IdentNode start="(429, 86)" end="(429, 88)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(429, 89)" end="(429, 90)" leading="" trailing=" " val="="/>
                      <IdentNode start="(429, 91)" end="(429, 93)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(429, 94)" end="(430, 31)">
          <AtomNode start="(429, 94)" end="(429, 96)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(429, 97)" end="(430, 31)">
            <AtomNode start="(429, 97)" end="(429, 99)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(430, 3)" end="(430, 31)">
              <TacticTacticseq1IndentedNode start="(430, 3)" end="(430, 31)">
                <NullNode start="(430, 3)" end="(430, 31)">
                  <OtherNode start="(430, 3)" end="(430, 31)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;l₂ : List β&#10;l : List α&#10;b : β&#10;⊢ mapIdx f l = b :: l₂ ↔ ∃ a l₁, l = a :: l₁ ∧ f 0 a = b ∧ mapIdx (fun i =&amp;gt; f (i + 1)) l₁ = l₂" state_after="no goals" tactic="cases l &amp;lt;;&amp;gt; simp [and_assoc]">
                    <OtherNode start="(430, 3)" end="(430, 10)" kind="Lean.Parser.Tactic.cases">
                      <AtomNode start="(430, 3)" end="(430, 8)" leading="" trailing=" " val="cases"/>
                      <NullNode start="(430, 9)" end="(430, 10)">
                        <OtherNode start="(430, 9)" end="(430, 10)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(430, 9)" end="(430, 10)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(430, 11)" end="(430, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(430, 15)" end="(430, 31)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(430, 15)" end="(430, 19)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(430, 20)" end="(430, 31)">
                        <AtomNode start="(430, 20)" end="(430, 21)" leading="" trailing="" val="["/>
                        <NullNode start="(430, 21)" end="(430, 30)">
                          <OtherNode start="(430, 21)" end="(430, 30)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(430, 21)" end="(430, 30)" leading="" trailing="" raw_val="and_assoc" val="and_assoc" full_name="and_assoc" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(430, 30)" end="(430, 31)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(432, 1)" end="(435, 19)" name="mapIdx_eq_cons_iff'" full_name="List.mapIdx_eq_cons_iff'">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(432, 1)" end="(435, 19)" name="mapIdx_eq_cons_iff'" full_name="List.mapIdx_eq_cons_iff'" _is_private_decl="False">
        <AtomNode start="(432, 1)" end="(432, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(432, 9)" end="(432, 28)">
          <IdentNode start="(432, 9)" end="(432, 28)" leading="" trailing=" " raw_val="mapIdx_eq_cons_iff'" val="mapIdx_eq_cons_iff'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(432, 29)" end="(434, 85)">
          <NullNode start="(432, 29)" end="(432, 49)">
            <OtherNode start="(432, 29)" end="(432, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(432, 29)" end="(432, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(432, 30)" end="(432, 31)">
                <IdentNode start="(432, 30)" end="(432, 31)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(432, 32)" end="(432, 40)">
                <AtomNode start="(432, 32)" end="(432, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(432, 34)" end="(432, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(432, 34)" end="(432, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(432, 39)" end="(432, 40)">
                    <IdentNode start="(432, 39)" end="(432, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(432, 40)" end="(432, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(432, 42)" end="(432, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(432, 42)" end="(432, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(432, 43)" end="(432, 44)">
                <IdentNode start="(432, 43)" end="(432, 44)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(432, 45)" end="(432, 48)">
                <AtomNode start="(432, 45)" end="(432, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(432, 47)" end="(432, 48)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(432, 48)" end="(432, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(432, 50)" end="(434, 85)">
            <AtomNode start="(432, 50)" end="(432, 51)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(433, 5)" end="(434, 85)" kind="«term_↔_»">
              <OtherNode start="(433, 5)" end="(433, 25)" kind="«term_=_»">
                <OtherNode start="(433, 5)" end="(433, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(433, 5)" end="(433, 11)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                  <NullNode start="(433, 12)" end="(433, 15)">
                    <IdentNode start="(433, 12)" end="(433, 13)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(433, 14)" end="(433, 15)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(433, 16)" end="(433, 17)" leading="" trailing=" " val="="/>
                <OtherNode start="(433, 18)" end="(433, 25)" kind="«term_::_»">
                  <IdentNode start="(433, 18)" end="(433, 19)" leading="" trailing=" " raw_val="b" val="b"/>
                  <AtomNode start="(433, 20)" end="(433, 22)" leading="" trailing=" " val="::"/>
                  <IdentNode start="(433, 23)" end="(433, 25)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(433, 26)" end="(433, 27)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(434, 7)" end="(434, 85)" kind="«term_∧_»">
                <OtherNode start="(434, 7)" end="(434, 33)" kind="«term_=_»">
                  <OtherNode start="(434, 7)" end="(434, 24)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(434, 7)" end="(434, 18)" leading="" trailing=" " raw_val="l.head?.map" val="l.head?.map"/>
                    <NullNode start="(434, 19)" end="(434, 24)">
                      <OtherNode start="(434, 19)" end="(434, 24)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(434, 19)" end="(434, 20)" leading="" trailing="" val="("/>
                        <OtherNode start="(434, 20)" end="(434, 23)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(434, 20)" end="(434, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(434, 22)" end="(434, 23)">
                            <OtherNode start="(434, 22)" end="(434, 23)" kind="num">
                              <AtomNode start="(434, 22)" end="(434, 23)" leading="" trailing="" val="0"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(434, 23)" end="(434, 24)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(434, 25)" end="(434, 26)" leading="" trailing=" " val="="/>
                  <OtherNode start="(434, 27)" end="(434, 33)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(434, 27)" end="(434, 31)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(434, 32)" end="(434, 33)">
                      <IdentNode start="(434, 32)" end="(434, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(434, 34)" end="(434, 35)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(434, 36)" end="(434, 85)" kind="«term_=_»">
                  <OtherNode start="(434, 36)" end="(434, 75)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(434, 36)" end="(434, 47)" leading="" trailing=" " raw_val="l.tail?.map" val="l.tail?.map"/>
                    <NullNode start="(434, 48)" end="(434, 75)">
                      <OtherNode start="(434, 48)" end="(434, 75)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(434, 48)" end="(434, 49)" leading="" trailing="" val="("/>
                        <OtherNode start="(434, 49)" end="(434, 74)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(434, 49)" end="(434, 55)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                          <NullNode start="(434, 56)" end="(434, 74)">
                            <OtherNode start="(434, 56)" end="(434, 74)" kind="Lean.Parser.Term.fun">
                              <AtomNode start="(434, 56)" end="(434, 59)" leading="" trailing=" " val="fun"/>
                              <OtherNode start="(434, 60)" end="(434, 74)" kind="Lean.Parser.Term.basicFun">
                                <NullNode start="(434, 60)" end="(434, 61)">
                                  <IdentNode start="(434, 60)" end="(434, 61)" leading="" trailing=" " raw_val="i" val="i"/>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(434, 62)" end="(434, 64)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(434, 65)" end="(434, 74)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(434, 65)" end="(434, 66)" leading="" trailing=" " raw_val="f" val="f"/>
                                  <NullNode start="(434, 67)" end="(434, 74)">
                                    <OtherNode start="(434, 67)" end="(434, 74)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(434, 67)" end="(434, 68)" leading="" trailing="" val="("/>
                                      <OtherNode start="(434, 68)" end="(434, 73)" kind="«term_+_»">
                                        <IdentNode start="(434, 68)" end="(434, 69)" leading="" trailing=" " raw_val="i" val="i"/>
                                        <AtomNode start="(434, 70)" end="(434, 71)" leading="" trailing=" " val="+"/>
                                        <OtherNode start="(434, 72)" end="(434, 73)" kind="num">
                                          <AtomNode start="(434, 72)" end="(434, 73)" leading="" trailing="" val="1"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(434, 73)" end="(434, 74)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(434, 74)" end="(434, 75)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(434, 76)" end="(434, 77)" leading="" trailing=" " val="="/>
                  <OtherNode start="(434, 78)" end="(434, 85)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(434, 78)" end="(434, 82)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(434, 83)" end="(434, 85)">
                      <IdentNode start="(434, 83)" end="(434, 85)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(434, 86)" end="(435, 19)">
          <AtomNode start="(434, 86)" end="(434, 88)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(434, 89)" end="(435, 19)">
            <AtomNode start="(434, 89)" end="(434, 91)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(435, 3)" end="(435, 19)">
              <TacticTacticseq1IndentedNode start="(435, 3)" end="(435, 19)">
                <NullNode start="(435, 3)" end="(435, 19)">
                  <OtherNode start="(435, 3)" end="(435, 19)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;l₂ : List β&#10;l : List α&#10;b : β&#10;⊢ mapIdx f l = b :: l₂ ↔ Option.map (f 0) l.head? = some b ∧ Option.map (mapIdx fun i =&amp;gt; f (i + 1)) l.tail? = some l₂" state_after="no goals" tactic="cases l &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(435, 3)" end="(435, 10)" kind="Lean.Parser.Tactic.cases">
                      <AtomNode start="(435, 3)" end="(435, 8)" leading="" trailing=" " val="cases"/>
                      <NullNode start="(435, 9)" end="(435, 10)">
                        <OtherNode start="(435, 9)" end="(435, 10)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(435, 9)" end="(435, 10)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(435, 11)" end="(435, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(435, 15)" end="(435, 19)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(435, 15)" end="(435, 19)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(437, 1)" end="(439, 28)" name="mapIdx_eq_singleton_iff" full_name="List.mapIdx_eq_singleton_iff">
      <CommandDeclmodifiersNode start="(437, 1)" end="(437, 8)">
        <NullNode/>
        <NullNode start="(437, 1)" end="(437, 8)">
          <OtherNode start="(437, 1)" end="(437, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(437, 1)" end="(437, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(437, 3)" end="(437, 7)">
              <OtherNode start="(437, 3)" end="(437, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(437, 3)" end="(437, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(437, 3)" end="(437, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(437, 7)" end="(437, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(437, 9)" end="(439, 28)" name="mapIdx_eq_singleton_iff" full_name="List.mapIdx_eq_singleton_iff" _is_private_decl="False">
        <AtomNode start="(437, 9)" end="(437, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(437, 17)" end="(437, 40)">
          <IdentNode start="(437, 17)" end="(437, 40)" leading="" trailing=" " raw_val="mapIdx_eq_singleton_iff" val="mapIdx_eq_singleton_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(437, 41)" end="(438, 54)">
          <NullNode start="(437, 41)" end="(437, 79)">
            <OtherNode start="(437, 41)" end="(437, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(437, 41)" end="(437, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(437, 42)" end="(437, 43)">
                <IdentNode start="(437, 42)" end="(437, 43)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(437, 44)" end="(437, 52)">
                <AtomNode start="(437, 44)" end="(437, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(437, 46)" end="(437, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(437, 46)" end="(437, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(437, 51)" end="(437, 52)">
                    <IdentNode start="(437, 51)" end="(437, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(437, 52)" end="(437, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(437, 54)" end="(437, 71)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(437, 54)" end="(437, 55)" leading="" trailing="" val="{"/>
              <NullNode start="(437, 55)" end="(437, 56)">
                <IdentNode start="(437, 55)" end="(437, 56)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(437, 57)" end="(437, 70)">
                <AtomNode start="(437, 57)" end="(437, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(437, 59)" end="(437, 70)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(437, 59)" end="(437, 62)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(437, 63)" end="(437, 64)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(437, 65)" end="(437, 70)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(437, 65)" end="(437, 66)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(437, 67)" end="(437, 68)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(437, 69)" end="(437, 70)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(437, 70)" end="(437, 71)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(437, 72)" end="(437, 79)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(437, 72)" end="(437, 73)" leading="" trailing="" val="{"/>
              <NullNode start="(437, 73)" end="(437, 74)">
                <IdentNode start="(437, 73)" end="(437, 74)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(437, 75)" end="(437, 78)">
                <AtomNode start="(437, 75)" end="(437, 76)" leading="" trailing=" " val=":"/>
                <IdentNode start="(437, 77)" end="(437, 78)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(437, 78)" end="(437, 79)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(437, 80)" end="(438, 54)">
            <AtomNode start="(437, 80)" end="(437, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(438, 5)" end="(438, 54)" kind="«term_↔_»">
              <OtherNode start="(438, 5)" end="(438, 21)" kind="«term_=_»">
                <OtherNode start="(438, 5)" end="(438, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(438, 5)" end="(438, 11)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                  <NullNode start="(438, 12)" end="(438, 15)">
                    <IdentNode start="(438, 12)" end="(438, 13)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(438, 14)" end="(438, 15)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(438, 16)" end="(438, 17)" leading="" trailing=" " val="="/>
                <OtherNode start="(438, 18)" end="(438, 21)" kind="«term[_]»">
                  <AtomNode start="(438, 18)" end="(438, 19)" leading="" trailing="" val="["/>
                  <NullNode start="(438, 19)" end="(438, 20)">
                    <IdentNode start="(438, 19)" end="(438, 20)" leading="" trailing="" raw_val="b" val="b"/>
                  </NullNode>
                  <AtomNode start="(438, 20)" end="(438, 21)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(438, 22)" end="(438, 23)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(438, 24)" end="(438, 54)" kind="«term∃_,_»">
                <AtomNode start="(438, 24)" end="(438, 25)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(438, 26)" end="(438, 33)" kind="Lean.explicitBinders">
                  <NullNode start="(438, 26)" end="(438, 33)">
                    <OtherNode start="(438, 26)" end="(438, 33)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(438, 26)" end="(438, 27)" leading="" trailing="" val="("/>
                      <NullNode start="(438, 27)" end="(438, 28)">
                        <LeanBinderidentNode start="(438, 27)" end="(438, 28)">
                          <IdentNode start="(438, 27)" end="(438, 28)" leading="" trailing=" " raw_val="a" val="a"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(438, 29)" end="(438, 30)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(438, 31)" end="(438, 32)" leading="" trailing="" raw_val="α" val="α"/>
                      <AtomNode start="(438, 32)" end="(438, 33)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(438, 33)" end="(438, 34)" leading="" trailing=" " val=","/>
                <OtherNode start="(438, 35)" end="(438, 54)" kind="«term_∧_»">
                  <OtherNode start="(438, 35)" end="(438, 42)" kind="«term_=_»">
                    <IdentNode start="(438, 35)" end="(438, 36)" leading="" trailing=" " raw_val="l" val="l"/>
                    <AtomNode start="(438, 37)" end="(438, 38)" leading="" trailing=" " val="="/>
                    <OtherNode start="(438, 39)" end="(438, 42)" kind="«term[_]»">
                      <AtomNode start="(438, 39)" end="(438, 40)" leading="" trailing="" val="["/>
                      <NullNode start="(438, 40)" end="(438, 41)">
                        <IdentNode start="(438, 40)" end="(438, 41)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                      <AtomNode start="(438, 41)" end="(438, 42)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(438, 43)" end="(438, 44)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(438, 45)" end="(438, 54)" kind="«term_=_»">
                    <OtherNode start="(438, 45)" end="(438, 50)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(438, 45)" end="(438, 46)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(438, 47)" end="(438, 50)">
                        <OtherNode start="(438, 47)" end="(438, 48)" kind="num">
                          <AtomNode start="(438, 47)" end="(438, 48)" leading="" trailing=" " val="0"/>
                        </OtherNode>
                        <IdentNode start="(438, 49)" end="(438, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(438, 51)" end="(438, 52)" leading="" trailing=" " val="="/>
                    <IdentNode start="(438, 53)" end="(438, 54)" leading="" trailing=" " raw_val="b" val="b"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(438, 55)" end="(439, 28)">
          <AtomNode start="(438, 55)" end="(438, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(438, 58)" end="(439, 28)">
            <AtomNode start="(438, 58)" end="(438, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(439, 3)" end="(439, 28)">
              <TacticTacticseq1IndentedNode start="(439, 3)" end="(439, 28)">
                <NullNode start="(439, 3)" end="(439, 28)">
                  <OtherNode start="(439, 3)" end="(439, 28)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;⊢ mapIdx f l = [b] ↔ ∃ a, l = [a] ∧ f 0 a = b" state_after="no goals" tactic="simp [mapIdx_eq_cons_iff]">
                    <AtomNode start="(439, 3)" end="(439, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(439, 8)" end="(439, 28)">
                      <AtomNode start="(439, 8)" end="(439, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(439, 9)" end="(439, 27)">
                        <OtherNode start="(439, 9)" end="(439, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(439, 9)" end="(439, 27)" leading="" trailing="" raw_val="mapIdx_eq_cons_iff" val="mapIdx_eq_cons_iff" full_name="List.mapIdx_eq_cons_iff" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(427, 9)" def_end="(427, 27)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(439, 27)" end="(439, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(441, 1)" end="(447, 13)" name="mapIdx_eq_iff" full_name="List.mapIdx_eq_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(441, 1)" end="(447, 13)" name="mapIdx_eq_iff" full_name="List.mapIdx_eq_iff" _is_private_decl="False">
        <AtomNode start="(441, 1)" end="(441, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(441, 9)" end="(441, 22)">
          <IdentNode start="(441, 9)" end="(441, 22)" leading="" trailing=" " raw_val="mapIdx_eq_iff" val="mapIdx_eq_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(441, 23)" end="(441, 91)">
          <NullNode start="(441, 23)" end="(441, 35)">
            <OtherNode start="(441, 23)" end="(441, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(441, 23)" end="(441, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(441, 24)" end="(441, 25)">
                <IdentNode start="(441, 24)" end="(441, 25)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(441, 26)" end="(441, 34)">
                <AtomNode start="(441, 26)" end="(441, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(441, 28)" end="(441, 34)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(441, 28)" end="(441, 32)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(441, 33)" end="(441, 34)">
                    <IdentNode start="(441, 33)" end="(441, 34)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(441, 34)" end="(441, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(441, 36)" end="(441, 91)">
            <AtomNode start="(441, 36)" end="(441, 37)" leading="" trailing=" " val=":"/>
            <OtherNode start="(441, 38)" end="(441, 91)" kind="«term_↔_»">
              <OtherNode start="(441, 38)" end="(441, 53)" kind="«term_=_»">
                <OtherNode start="(441, 38)" end="(441, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(441, 38)" end="(441, 44)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                  <NullNode start="(441, 45)" end="(441, 48)">
                    <IdentNode start="(441, 45)" end="(441, 46)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(441, 47)" end="(441, 48)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(441, 49)" end="(441, 50)" leading="" trailing=" " val="="/>
                <IdentNode start="(441, 51)" end="(441, 53)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </OtherNode>
              <AtomNode start="(441, 54)" end="(441, 55)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(441, 56)" end="(441, 91)" kind="Lean.Parser.Term.forall">
                <AtomNode start="(441, 56)" end="(441, 57)" leading="" trailing=" " val="∀"/>
                <NullNode start="(441, 58)" end="(441, 59)">
                  <IdentNode start="(441, 58)" end="(441, 59)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
                <NullNode start="(441, 60)" end="(441, 65)">
                  <TermTypespecNode start="(441, 60)" end="(441, 65)">
                    <AtomNode start="(441, 60)" end="(441, 61)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(441, 62)" end="(441, 65)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </TermTypespecNode>
                </NullNode>
                <AtomNode start="(441, 65)" end="(441, 66)" leading="" trailing=" " val=","/>
                <OtherNode start="(441, 67)" end="(441, 91)" kind="«term_=_»">
                  <OtherNode start="(441, 67)" end="(441, 73)" kind="«term__[_]_?»">
                    <IdentNode start="(441, 67)" end="(441, 69)" leading="" trailing="" raw_val="l'" val="l'"/>
                    <GroupNode/>
                    <AtomNode start="(441, 69)" end="(441, 70)" leading="" trailing="" val="["/>
                    <IdentNode start="(441, 70)" end="(441, 71)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(441, 71)" end="(441, 72)" leading="" trailing="" val="]"/>
                    <GroupNode/>
                    <AtomNode start="(441, 72)" end="(441, 73)" leading="" trailing=" " val="?"/>
                  </OtherNode>
                  <AtomNode start="(441, 74)" end="(441, 75)" leading="" trailing=" " val="="/>
                  <OtherNode start="(441, 76)" end="(441, 91)" kind="Lean.Parser.Term.app">
                    <OtherNode start="(441, 76)" end="(441, 85)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(441, 76)" end="(441, 81)" kind="«term__[_]_?»">
                        <IdentNode start="(441, 76)" end="(441, 77)" leading="" trailing="" raw_val="l" val="l"/>
                        <GroupNode/>
                        <AtomNode start="(441, 77)" end="(441, 78)" leading="" trailing="" val="["/>
                        <IdentNode start="(441, 78)" end="(441, 79)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(441, 79)" end="(441, 80)" leading="" trailing="" val="]"/>
                        <GroupNode/>
                        <AtomNode start="(441, 80)" end="(441, 81)" leading="" trailing="" val="?"/>
                      </OtherNode>
                      <AtomNode start="(441, 81)" end="(441, 82)" leading="" trailing="" val="."/>
                      <IdentNode start="(441, 82)" end="(441, 85)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <NullNode start="(441, 86)" end="(441, 91)">
                      <OtherNode start="(441, 86)" end="(441, 91)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(441, 86)" end="(441, 87)" leading="" trailing="" val="("/>
                        <OtherNode start="(441, 87)" end="(441, 90)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(441, 87)" end="(441, 88)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(441, 89)" end="(441, 90)">
                            <IdentNode start="(441, 89)" end="(441, 90)" leading="" trailing="" raw_val="i" val="i"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(441, 90)" end="(441, 91)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(441, 92)" end="(447, 13)">
          <AtomNode start="(441, 92)" end="(441, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(441, 95)" end="(447, 13)">
            <AtomNode start="(441, 95)" end="(441, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(442, 3)" end="(447, 13)">
              <TacticTacticseq1IndentedNode start="(442, 3)" end="(447, 13)">
                <NullNode start="(442, 3)" end="(447, 13)">
                  <OtherNode start="(442, 3)" end="(442, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;⊢ mapIdx f l = l' ↔ ∀ (i : Nat), l'[i]? = Option.map (f i) l[i]?" state_after="case mp&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;⊢ mapIdx f l = l' → ∀ (i : Nat), l'[i]? = Option.map (f i) l[i]?&#10;&#10;case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;⊢ (∀ (i : Nat), l'[i]? = Option.map (f i) l[i]?) → mapIdx f l = l'" tactic="constructor">
                    <AtomNode start="(442, 3)" end="(442, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(443, 3)" end="(444, 49)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;⊢ mapIdx f l = l' → ∀ (i : Nat), l'[i]? = Option.map (f i) l[i]?&#10;&#10;case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;⊢ (∀ (i : Nat), l'[i]? = Option.map (f i) l[i]?) → mapIdx f l = l'" state_after="case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;⊢ (∀ (i : Nat), l'[i]? = Option.map (f i) l[i]?) → mapIdx f l = l'" tactic="· intro w i&#10;  simpa using congrArg (fun l =&amp;gt; l[i]?) w.symm">
                    <OtherNode start="(443, 3)" end="(443, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(443, 3)" end="(443, 4)" kind="patternIgnore">
                        <OtherNode start="(443, 3)" end="(443, 4)" kind="token.«· »">
                          <AtomNode start="(443, 3)" end="(443, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(443, 5)" end="(444, 49)">
                      <TacticTacticseq1IndentedNode start="(443, 5)" end="(444, 49)">
                        <NullNode start="(443, 5)" end="(444, 49)">
                          <OtherNode start="(443, 5)" end="(443, 14)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;⊢ mapIdx f l = l' → ∀ (i : Nat), l'[i]? = Option.map (f i) l[i]?" state_after="case mp&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;w : mapIdx f l = l'&#10;i : Nat&#10;⊢ l'[i]? = Option.map (f i) l[i]?" tactic="intro w i">
                            <AtomNode start="(443, 5)" end="(443, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(443, 11)" end="(443, 14)">
                              <IdentNode start="(443, 11)" end="(443, 12)" leading="" trailing=" " raw_val="w" val="w"/>
                              <IdentNode start="(443, 13)" end="(443, 14)" leading="" trailing="&#10;    " raw_val="i" val="i"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(444, 5)" end="(444, 49)" kind="Lean.Parser.Tactic.simpa" state_before="case mp&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;w : mapIdx f l = l'&#10;i : Nat&#10;⊢ l'[i]? = Option.map (f i) l[i]?" state_after="no goals" tactic="simpa using congrArg (fun l =&amp;gt; l[i]?) w.symm">
                            <AtomNode start="(444, 5)" end="(444, 10)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(444, 11)" end="(444, 49)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(444, 11)" end="(444, 49)">
                                <AtomNode start="(444, 11)" end="(444, 16)" leading="" trailing=" " val="using"/>
                                <OtherNode start="(444, 17)" end="(444, 49)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(444, 17)" end="(444, 25)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(444, 26)" end="(444, 49)">
                                    <OtherNode start="(444, 26)" end="(444, 42)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(444, 26)" end="(444, 27)" leading="" trailing="" val="("/>
                                      <OtherNode start="(444, 27)" end="(444, 41)" kind="Lean.Parser.Term.fun">
                                        <AtomNode start="(444, 27)" end="(444, 30)" leading="" trailing=" " val="fun"/>
                                        <OtherNode start="(444, 31)" end="(444, 41)" kind="Lean.Parser.Term.basicFun">
                                          <NullNode start="(444, 31)" end="(444, 32)">
                                            <IdentNode start="(444, 31)" end="(444, 32)" leading="" trailing=" " raw_val="l" val="l"/>
                                          </NullNode>
                                          <NullNode/>
                                          <AtomNode start="(444, 33)" end="(444, 35)" leading="" trailing=" " val="=&amp;gt;"/>
                                          <OtherNode start="(444, 36)" end="(444, 41)" kind="«term__[_]_?»">
                                            <IdentNode start="(444, 36)" end="(444, 37)" leading="" trailing="" raw_val="l" val="l"/>
                                            <GroupNode/>
                                            <AtomNode start="(444, 37)" end="(444, 38)" leading="" trailing="" val="["/>
                                            <IdentNode start="(444, 38)" end="(444, 39)" leading="" trailing="" raw_val="i" val="i"/>
                                            <AtomNode start="(444, 39)" end="(444, 40)" leading="" trailing="" val="]"/>
                                            <GroupNode/>
                                            <AtomNode start="(444, 40)" end="(444, 41)" leading="" trailing="" val="?"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(444, 41)" end="(444, 42)" leading="" trailing=" " val=")"/>
                                    </OtherNode>
                                    <IdentNode start="(444, 43)" end="(444, 49)" leading="" trailing="&#10;  " raw_val="w.symm" val="w.symm"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(445, 3)" end="(447, 13)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;⊢ (∀ (i : Nat), l'[i]? = Option.map (f i) l[i]?) → mapIdx f l = l'" state_after="no goals" tactic="· intro w&#10;  ext1 i&#10;  simp [w]">
                    <OtherNode start="(445, 3)" end="(445, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(445, 3)" end="(445, 4)" kind="patternIgnore">
                        <OtherNode start="(445, 3)" end="(445, 4)" kind="token.«· »">
                          <AtomNode start="(445, 3)" end="(445, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(445, 5)" end="(447, 13)">
                      <TacticTacticseq1IndentedNode start="(445, 5)" end="(447, 13)">
                        <NullNode start="(445, 5)" end="(447, 13)">
                          <OtherNode start="(445, 5)" end="(445, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;⊢ (∀ (i : Nat), l'[i]? = Option.map (f i) l[i]?) → mapIdx f l = l'" state_after="case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;w : ∀ (i : Nat), l'[i]? = Option.map (f i) l[i]?&#10;⊢ mapIdx f l = l'" tactic="intro w">
                            <AtomNode start="(445, 5)" end="(445, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(445, 11)" end="(445, 12)">
                              <IdentNode start="(445, 11)" end="(445, 12)" leading="" trailing="&#10;    " raw_val="w" val="w"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(446, 5)" end="(446, 11)" kind="Lean.Elab.Tactic.Ext.tacticExt1___" state_before="case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;w : ∀ (i : Nat), l'[i]? = Option.map (f i) l[i]?&#10;⊢ mapIdx f l = l'" state_after="case mpr.h&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;w : ∀ (i : Nat), l'[i]? = Option.map (f i) l[i]?&#10;i : Nat&#10;⊢ (mapIdx f l)[i]? = l'[i]?" tactic="ext1 i">
                            <AtomNode start="(446, 5)" end="(446, 9)" leading="" trailing=" " val="ext1"/>
                            <NullNode start="(446, 10)" end="(446, 11)">
                              <OtherNode start="(446, 10)" end="(446, 11)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(446, 10)" end="(446, 11)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(446, 10)" end="(446, 11)" leading="" trailing="&#10;    " raw_val="i" val="i"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(447, 5)" end="(447, 13)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.h&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l' : List α✝&#10;l : List α&#10;w : ∀ (i : Nat), l'[i]? = Option.map (f i) l[i]?&#10;i : Nat&#10;⊢ (mapIdx f l)[i]? = l'[i]?" state_after="no goals" tactic="simp [w]">
                            <AtomNode start="(447, 5)" end="(447, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(447, 10)" end="(447, 13)">
                              <AtomNode start="(447, 10)" end="(447, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(447, 11)" end="(447, 12)">
                                <OtherNode start="(447, 11)" end="(447, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(447, 11)" end="(447, 12)" leading="" trailing="" raw_val="w" val="w"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(447, 12)" end="(447, 13)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(449, 1)" end="(460, 38)" name="mapIdx_eq_append_iff" full_name="List.mapIdx_eq_append_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(449, 1)" end="(460, 38)" name="mapIdx_eq_append_iff" full_name="List.mapIdx_eq_append_iff" _is_private_decl="False">
        <AtomNode start="(449, 1)" end="(449, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(449, 9)" end="(449, 29)">
          <IdentNode start="(449, 9)" end="(449, 29)" leading="" trailing=" " raw_val="mapIdx_eq_append_iff" val="mapIdx_eq_append_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(449, 30)" end="(453, 54)">
          <NullNode start="(449, 30)" end="(449, 42)">
            <OtherNode start="(449, 30)" end="(449, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(449, 30)" end="(449, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(449, 31)" end="(449, 32)">
                <IdentNode start="(449, 31)" end="(449, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(449, 33)" end="(449, 41)">
                <AtomNode start="(449, 33)" end="(449, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(449, 35)" end="(449, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(449, 35)" end="(449, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(449, 40)" end="(449, 41)">
                    <IdentNode start="(449, 40)" end="(449, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(449, 41)" end="(449, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(449, 43)" end="(453, 54)">
            <AtomNode start="(449, 43)" end="(449, 44)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(450, 5)" end="(453, 54)" kind="«term_↔_»">
              <OtherNode start="(450, 5)" end="(450, 26)" kind="«term_=_»">
                <OtherNode start="(450, 5)" end="(450, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(450, 5)" end="(450, 11)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                  <NullNode start="(450, 12)" end="(450, 15)">
                    <IdentNode start="(450, 12)" end="(450, 13)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(450, 14)" end="(450, 15)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(450, 16)" end="(450, 17)" leading="" trailing=" " val="="/>
                <OtherNode start="(450, 18)" end="(450, 26)" kind="«term_++_»">
                  <IdentNode start="(450, 18)" end="(450, 20)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(450, 21)" end="(450, 23)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(450, 24)" end="(450, 26)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(450, 27)" end="(450, 28)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(451, 7)" end="(453, 54)" kind="«term∃_,_»">
                <AtomNode start="(451, 7)" end="(451, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(451, 9)" end="(451, 38)" kind="Lean.explicitBinders">
                  <NullNode start="(451, 9)" end="(451, 38)">
                    <OtherNode start="(451, 9)" end="(451, 23)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(451, 9)" end="(451, 10)" leading="" trailing="" val="("/>
                      <NullNode start="(451, 10)" end="(451, 13)">
                        <LeanBinderidentNode start="(451, 10)" end="(451, 13)">
                          <IdentNode start="(451, 10)" end="(451, 13)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(451, 14)" end="(451, 15)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(451, 16)" end="(451, 22)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(451, 16)" end="(451, 20)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(451, 21)" end="(451, 22)">
                          <IdentNode start="(451, 21)" end="(451, 22)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(451, 22)" end="(451, 23)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(451, 24)" end="(451, 38)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(451, 24)" end="(451, 25)" leading="" trailing="" val="("/>
                      <NullNode start="(451, 25)" end="(451, 28)">
                        <LeanBinderidentNode start="(451, 25)" end="(451, 28)">
                          <IdentNode start="(451, 25)" end="(451, 28)" leading="" trailing=" " raw_val="l₂'" val="l₂'"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(451, 29)" end="(451, 30)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(451, 31)" end="(451, 37)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(451, 31)" end="(451, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(451, 36)" end="(451, 37)">
                          <IdentNode start="(451, 36)" end="(451, 37)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(451, 37)" end="(451, 38)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(451, 38)" end="(451, 39)" leading="" trailing=" " val=","/>
                <OtherNode start="(451, 40)" end="(453, 54)" kind="«term_∧_»">
                  <OtherNode start="(451, 40)" end="(451, 54)" kind="«term_=_»">
                    <IdentNode start="(451, 40)" end="(451, 41)" leading="" trailing=" " raw_val="l" val="l"/>
                    <AtomNode start="(451, 42)" end="(451, 43)" leading="" trailing=" " val="="/>
                    <OtherNode start="(451, 44)" end="(451, 54)" kind="«term_++_»">
                      <IdentNode start="(451, 44)" end="(451, 47)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                      <AtomNode start="(451, 48)" end="(451, 50)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(451, 51)" end="(451, 54)" leading="" trailing=" " raw_val="l₂'" val="l₂'"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(451, 55)" end="(451, 56)" leading="" trailing="&#10;        " val="∧"/>
                  <OtherNode start="(452, 9)" end="(453, 54)" kind="«term_∧_»">
                    <OtherNode start="(452, 9)" end="(452, 26)" kind="«term_=_»">
                      <OtherNode start="(452, 9)" end="(452, 21)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(452, 9)" end="(452, 15)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                        <NullNode start="(452, 16)" end="(452, 21)">
                          <IdentNode start="(452, 16)" end="(452, 17)" leading="" trailing=" " raw_val="f" val="f"/>
                          <IdentNode start="(452, 18)" end="(452, 21)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(452, 22)" end="(452, 23)" leading="" trailing=" " val="="/>
                      <IdentNode start="(452, 24)" end="(452, 26)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    </OtherNode>
                    <AtomNode start="(452, 27)" end="(452, 28)" leading="" trailing="&#10;        " val="∧"/>
                    <OtherNode start="(453, 9)" end="(453, 54)" kind="«term_=_»">
                      <OtherNode start="(453, 9)" end="(453, 49)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(453, 9)" end="(453, 15)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                        <NullNode start="(453, 16)" end="(453, 49)">
                          <OtherNode start="(453, 16)" end="(453, 45)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(453, 16)" end="(453, 17)" leading="" trailing="" val="("/>
                            <OtherNode start="(453, 17)" end="(453, 44)" kind="Lean.Parser.Term.fun">
                              <AtomNode start="(453, 17)" end="(453, 20)" leading="" trailing=" " val="fun"/>
                              <OtherNode start="(453, 21)" end="(453, 44)" kind="Lean.Parser.Term.basicFun">
                                <NullNode start="(453, 21)" end="(453, 22)">
                                  <IdentNode start="(453, 21)" end="(453, 22)" leading="" trailing=" " raw_val="i" val="i"/>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(453, 23)" end="(453, 25)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(453, 26)" end="(453, 44)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(453, 26)" end="(453, 27)" leading="" trailing=" " raw_val="f" val="f"/>
                                  <NullNode start="(453, 28)" end="(453, 44)">
                                    <OtherNode start="(453, 28)" end="(453, 44)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(453, 28)" end="(453, 29)" leading="" trailing="" val="("/>
                                      <OtherNode start="(453, 29)" end="(453, 43)" kind="«term_+_»">
                                        <IdentNode start="(453, 29)" end="(453, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                                        <AtomNode start="(453, 31)" end="(453, 32)" leading="" trailing=" " val="+"/>
                                        <IdentNode start="(453, 33)" end="(453, 43)" leading="" trailing="" raw_val="l₁'.length" val="l₁'.length"/>
                                      </OtherNode>
                                      <AtomNode start="(453, 43)" end="(453, 44)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(453, 44)" end="(453, 45)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <IdentNode start="(453, 46)" end="(453, 49)" leading="" trailing=" " raw_val="l₂'" val="l₂'"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(453, 50)" end="(453, 51)" leading="" trailing=" " val="="/>
                      <IdentNode start="(453, 52)" end="(453, 54)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(453, 55)" end="(460, 38)">
          <AtomNode start="(453, 55)" end="(453, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(453, 58)" end="(460, 38)">
            <AtomNode start="(453, 58)" end="(453, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(454, 3)" end="(460, 38)">
              <TacticTacticseq1IndentedNode start="(454, 3)" end="(460, 38)">
                <NullNode start="(454, 3)" end="(460, 38)">
                  <OtherNode start="(454, 3)" end="(454, 52)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α✝&#10;l : List α&#10;⊢ mapIdx f l = l₁ ++ l₂ ↔ ∃ l₁' l₂', l = l₁' ++ l₂' ∧ mapIdx f l₁' = l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂" state_after="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α✝&#10;l : List α&#10;⊢ (∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a) = l₂) ↔&#10;    ∃ l₁' l₂', l = l₁' ++ l₂' ∧ mapIdx f l₁' = l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂" tactic="rw [mapIdx_eq_mapFinIdx, mapFinIdx_eq_append_iff]">
                    <AtomNode start="(454, 3)" end="(454, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(454, 6)" end="(454, 52)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(454, 6)" end="(454, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(454, 7)" end="(454, 51)">
                        <OtherNode start="(454, 7)" end="(454, 26)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(454, 7)" end="(454, 26)" leading="" trailing="" raw_val="mapIdx_eq_mapFinIdx" val="mapIdx_eq_mapFinIdx" full_name="List.mapIdx_eq_mapFinIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(374, 9)" def_end="(374, 28)"/>
                        </OtherNode>
                        <AtomNode start="(454, 26)" end="(454, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(454, 28)" end="(454, 51)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(454, 28)" end="(454, 51)" leading="" trailing="" raw_val="mapFinIdx_eq_append_iff" val="mapFinIdx_eq_append_iff" full_name="List.mapFinIdx_eq_append_iff" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(246, 9)" def_end="(246, 32)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(454, 51)" end="(454, 52)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(455, 3)" end="(455, 64)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α✝&#10;l : List α&#10;⊢ (∃ l₁' l₂' w, (l₁'.mapFinIdx fun i a h =&amp;gt; f i a) = l₁ ∧ (l₂'.mapFinIdx fun i a h =&amp;gt; f (i + l₁'.length) a) = l₂) ↔&#10;    ∃ l₁' l₂', l = l₁' ++ l₂' ∧ mapIdx f l₁' = l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂" state_after="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α✝&#10;l : List α&#10;⊢ (∃ l₁', mapIdx f l₁' = l₁ ∧ ∃ x, l = l₁' ++ x ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) x = l₂) ↔&#10;    ∃ l₁' l₂', l = l₁' ++ l₂' ∧ mapIdx f l₁' = l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂" tactic="simp only [mapFinIdx_eq_mapIdx, exists_and_left, exists_prop]">
                    <AtomNode start="(455, 3)" end="(455, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(455, 8)" end="(455, 12)">
                      <AtomNode start="(455, 8)" end="(455, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(455, 13)" end="(455, 64)">
                      <AtomNode start="(455, 13)" end="(455, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(455, 14)" end="(455, 63)">
                        <OtherNode start="(455, 14)" end="(455, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(455, 14)" end="(455, 33)" leading="" trailing="" raw_val="mapFinIdx_eq_mapIdx" val="mapFinIdx_eq_mapIdx" full_name="List.mapFinIdx_eq_mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(369, 17)" def_end="(369, 36)"/>
                        </OtherNode>
                        <AtomNode start="(455, 33)" end="(455, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(455, 35)" end="(455, 50)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(455, 35)" end="(455, 50)" leading="" trailing="" raw_val="exists_and_left" val="exists_and_left" full_name="exists_and_left" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(455, 50)" end="(455, 51)" leading="" trailing=" " val=","/>
                        <OtherNode start="(455, 52)" end="(455, 63)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(455, 52)" end="(455, 63)" leading="" trailing="" raw_val="exists_prop" val="exists_prop" full_name="exists_prop" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(455, 63)" end="(455, 64)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(456, 3)" end="(456, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α✝&#10;l : List α&#10;⊢ (∃ l₁', mapIdx f l₁' = l₁ ∧ ∃ x, l = l₁' ++ x ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) x = l₂) ↔&#10;    ∃ l₁' l₂', l = l₁' ++ l₂' ∧ mapIdx f l₁' = l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂" state_after="case mp&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α✝&#10;l : List α&#10;⊢ (∃ l₁', mapIdx f l₁' = l₁ ∧ ∃ x, l = l₁' ++ x ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) x = l₂) →&#10;    ∃ l₁' l₂', l = l₁' ++ l₂' ∧ mapIdx f l₁' = l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂&#10;&#10;case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α✝&#10;l : List α&#10;⊢ (∃ l₁' l₂', l = l₁' ++ l₂' ∧ mapIdx f l₁' = l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂) →&#10;    ∃ l₁', mapIdx f l₁' = l₁ ∧ ∃ x, l = l₁' ++ x ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) x = l₂" tactic="constructor">
                    <AtomNode start="(456, 3)" end="(456, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(457, 3)" end="(458, 33)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α✝&#10;l : List α&#10;⊢ (∃ l₁', mapIdx f l₁' = l₁ ∧ ∃ x, l = l₁' ++ x ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) x = l₂) →&#10;    ∃ l₁' l₂', l = l₁' ++ l₂' ∧ mapIdx f l₁' = l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂&#10;&#10;case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α✝&#10;l : List α&#10;⊢ (∃ l₁' l₂', l = l₁' ++ l₂' ∧ mapIdx f l₁' = l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂) →&#10;    ∃ l₁', mapIdx f l₁' = l₁ ∧ ∃ x, l = l₁' ++ x ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) x = l₂" state_after="case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α✝&#10;l : List α&#10;⊢ (∃ l₁' l₂', l = l₁' ++ l₂' ∧ mapIdx f l₁' = l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂) →&#10;    ∃ l₁', mapIdx f l₁' = l₁ ∧ ∃ x, l = l₁' ++ x ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) x = l₂" tactic="· rintro ⟨l₁, rfl, l₂, rfl, h⟩&#10;  refine ⟨l₁, l₂, by simp_all⟩">
                    <OtherNode start="(457, 3)" end="(457, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(457, 3)" end="(457, 4)" kind="patternIgnore">
                        <OtherNode start="(457, 3)" end="(457, 4)" kind="token.«· »">
                          <AtomNode start="(457, 3)" end="(457, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(457, 5)" end="(458, 33)">
                      <TacticTacticseq1IndentedNode start="(457, 5)" end="(458, 33)">
                        <NullNode start="(457, 5)" end="(458, 33)">
                          <OtherNode start="(457, 5)" end="(457, 33)" kind="Lean.Parser.Tactic.rintro" state_before="case mp&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α✝&#10;l : List α&#10;⊢ (∃ l₁', mapIdx f l₁' = l₁ ∧ ∃ x, l = l₁' ++ x ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) x = l₂) →&#10;    ∃ l₁' l₂', l = l₁' ++ l₂' ∧ mapIdx f l₁' = l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂" state_after="case mp.intro.intro.intro.intro&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₂✝ : List α✝&#10;l₁ l₂ : List α&#10;h : mapIdx (fun i =&amp;gt; f (i + l₁.length)) l₂ = l₂✝&#10;⊢ ∃ l₁' l₂', l₁ ++ l₂ = l₁' ++ l₂' ∧ mapIdx f l₁' = mapIdx f l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂✝" tactic="rintro ⟨l₁, rfl, l₂, rfl, h⟩">
                            <AtomNode start="(457, 5)" end="(457, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(457, 12)" end="(457, 33)">
                              <OtherNode start="(457, 12)" end="(457, 33)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(457, 12)" end="(457, 33)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(457, 12)" end="(457, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(457, 13)" end="(457, 32)">
                                    <OtherNode start="(457, 13)" end="(457, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(457, 13)" end="(457, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(457, 13)" end="(457, 15)">
                                          <OtherNode start="(457, 13)" end="(457, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(457, 13)" end="(457, 15)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(457, 15)" end="(457, 16)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(457, 17)" end="(457, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(457, 17)" end="(457, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(457, 17)" end="(457, 20)">
                                          <OtherNode start="(457, 17)" end="(457, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(457, 17)" end="(457, 20)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(457, 20)" end="(457, 21)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(457, 22)" end="(457, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(457, 22)" end="(457, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(457, 22)" end="(457, 24)">
                                          <OtherNode start="(457, 22)" end="(457, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(457, 22)" end="(457, 24)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(457, 24)" end="(457, 25)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(457, 26)" end="(457, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(457, 26)" end="(457, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(457, 26)" end="(457, 29)">
                                          <OtherNode start="(457, 26)" end="(457, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(457, 26)" end="(457, 29)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(457, 29)" end="(457, 30)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(457, 31)" end="(457, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(457, 31)" end="(457, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(457, 31)" end="(457, 32)">
                                          <OtherNode start="(457, 31)" end="(457, 32)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(457, 31)" end="(457, 32)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(457, 32)" end="(457, 33)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(458, 5)" end="(458, 33)" kind="Lean.Parser.Tactic.refine" state_before="case mp.intro.intro.intro.intro&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₂✝ : List α✝&#10;l₁ l₂ : List α&#10;h : mapIdx (fun i =&amp;gt; f (i + l₁.length)) l₂ = l₂✝&#10;⊢ ∃ l₁' l₂', l₁ ++ l₂ = l₁' ++ l₂' ∧ mapIdx f l₁' = mapIdx f l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂✝" state_after="no goals" tactic="refine ⟨l₁, l₂, by simp_all⟩">
                            <AtomNode start="(458, 5)" end="(458, 11)" leading="" trailing=" " val="refine"/>
                            <OtherNode start="(458, 12)" end="(458, 33)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(458, 12)" end="(458, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(458, 13)" end="(458, 32)">
                                <IdentNode start="(458, 13)" end="(458, 15)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                <AtomNode start="(458, 15)" end="(458, 16)" leading="" trailing=" " val=","/>
                                <IdentNode start="(458, 17)" end="(458, 19)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                <AtomNode start="(458, 19)" end="(458, 20)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(458, 21)" end="(458, 32)">
                                  <AtomNode start="(458, 21)" end="(458, 23)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(458, 24)" end="(458, 32)">
                                    <TacticTacticseq1IndentedNode start="(458, 24)" end="(458, 32)">
                                      <NullNode start="(458, 24)" end="(458, 32)">
                                        <OtherNode start="(458, 24)" end="(458, 32)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₂✝ : List α✝&#10;l₁ l₂ : List α&#10;h : mapIdx (fun i =&amp;gt; f (i + l₁.length)) l₂ = l₂✝&#10;⊢ l₁ ++ l₂ = l₁ ++ l₂ ∧ mapIdx f l₁ = mapIdx f l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁.length)) l₂ = l₂✝" state_after="no goals" tactic="simp_all">
                                          <AtomNode start="(458, 24)" end="(458, 32)" leading="" trailing="" val="simp_all"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(458, 32)" end="(458, 33)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(459, 3)" end="(460, 38)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α✝&#10;l : List α&#10;⊢ (∃ l₁' l₂', l = l₁' ++ l₂' ∧ mapIdx f l₁' = l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂) →&#10;    ∃ l₁', mapIdx f l₁' = l₁ ∧ ∃ x, l = l₁' ++ x ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) x = l₂" state_after="no goals" tactic="· rintro ⟨l₁, l₂, rfl, rfl, rfl⟩&#10;  refine ⟨l₁, rfl, l₂, by simp_all⟩">
                    <OtherNode start="(459, 3)" end="(459, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(459, 3)" end="(459, 4)" kind="patternIgnore">
                        <OtherNode start="(459, 3)" end="(459, 4)" kind="token.«· »">
                          <AtomNode start="(459, 3)" end="(459, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(459, 5)" end="(460, 38)">
                      <TacticTacticseq1IndentedNode start="(459, 5)" end="(460, 38)">
                        <NullNode start="(459, 5)" end="(460, 38)">
                          <OtherNode start="(459, 5)" end="(459, 35)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α✝&#10;l : List α&#10;⊢ (∃ l₁' l₂', l = l₁' ++ l₂' ∧ mapIdx f l₁' = l₁ ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) l₂' = l₂) →&#10;    ∃ l₁', mapIdx f l₁' = l₁ ∧ ∃ x, l = l₁' ++ x ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) x = l₂" state_after="case mpr.intro.intro.intro.intro&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α&#10;⊢ ∃ l₁',&#10;    mapIdx f l₁' = mapIdx f l₁ ∧&#10;      ∃ x, l₁ ++ l₂ = l₁' ++ x ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) x = mapIdx (fun i =&amp;gt; f (i + l₁.length)) l₂" tactic="rintro ⟨l₁, l₂, rfl, rfl, rfl⟩">
                            <AtomNode start="(459, 5)" end="(459, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(459, 12)" end="(459, 35)">
                              <OtherNode start="(459, 12)" end="(459, 35)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(459, 12)" end="(459, 35)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(459, 12)" end="(459, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(459, 13)" end="(459, 34)">
                                    <OtherNode start="(459, 13)" end="(459, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(459, 13)" end="(459, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(459, 13)" end="(459, 15)">
                                          <OtherNode start="(459, 13)" end="(459, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(459, 13)" end="(459, 15)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(459, 15)" end="(459, 16)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(459, 17)" end="(459, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(459, 17)" end="(459, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(459, 17)" end="(459, 19)">
                                          <OtherNode start="(459, 17)" end="(459, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(459, 17)" end="(459, 19)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(459, 19)" end="(459, 20)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(459, 21)" end="(459, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(459, 21)" end="(459, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(459, 21)" end="(459, 24)">
                                          <OtherNode start="(459, 21)" end="(459, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(459, 21)" end="(459, 24)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(459, 24)" end="(459, 25)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(459, 26)" end="(459, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(459, 26)" end="(459, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(459, 26)" end="(459, 29)">
                                          <OtherNode start="(459, 26)" end="(459, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(459, 26)" end="(459, 29)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(459, 29)" end="(459, 30)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(459, 31)" end="(459, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(459, 31)" end="(459, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(459, 31)" end="(459, 34)">
                                          <OtherNode start="(459, 31)" end="(459, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(459, 31)" end="(459, 34)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(459, 34)" end="(459, 35)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(460, 5)" end="(460, 38)" kind="Lean.Parser.Tactic.refine" state_before="case mpr.intro.intro.intro.intro&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α&#10;⊢ ∃ l₁',&#10;    mapIdx f l₁' = mapIdx f l₁ ∧&#10;      ∃ x, l₁ ++ l₂ = l₁' ++ x ∧ mapIdx (fun i =&amp;gt; f (i + l₁'.length)) x = mapIdx (fun i =&amp;gt; f (i + l₁.length)) l₂" state_after="no goals" tactic="refine ⟨l₁, rfl, l₂, by simp_all⟩">
                            <AtomNode start="(460, 5)" end="(460, 11)" leading="" trailing=" " val="refine"/>
                            <OtherNode start="(460, 12)" end="(460, 38)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(460, 12)" end="(460, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(460, 13)" end="(460, 37)">
                                <IdentNode start="(460, 13)" end="(460, 15)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                <AtomNode start="(460, 15)" end="(460, 16)" leading="" trailing=" " val=","/>
                                <IdentNode start="(460, 17)" end="(460, 20)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <AtomNode start="(460, 20)" end="(460, 21)" leading="" trailing=" " val=","/>
                                <IdentNode start="(460, 22)" end="(460, 24)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                <AtomNode start="(460, 24)" end="(460, 25)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(460, 26)" end="(460, 37)">
                                  <AtomNode start="(460, 26)" end="(460, 28)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(460, 29)" end="(460, 37)">
                                    <TacticTacticseq1IndentedNode start="(460, 29)" end="(460, 37)">
                                      <NullNode start="(460, 29)" end="(460, 37)">
                                        <OtherNode start="(460, 29)" end="(460, 37)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l₁ l₂ : List α&#10;⊢ l₁ ++ l₂ = l₁ ++ l₂ ∧ mapIdx (fun i =&amp;gt; f (i + l₁.length)) l₂ = mapIdx (fun i =&amp;gt; f (i + l₁.length)) l₂" state_after="no goals" tactic="simp_all">
                                          <AtomNode start="(460, 29)" end="(460, 37)" leading="" trailing="" val="simp_all"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(460, 37)" end="(460, 38)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(462, 1)" end="(471, 15)" name="mapIdx_eq_mapIdx_iff" full_name="List.mapIdx_eq_mapIdx_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(462, 1)" end="(471, 15)" name="mapIdx_eq_mapIdx_iff" full_name="List.mapIdx_eq_mapIdx_iff" _is_private_decl="False">
        <AtomNode start="(462, 1)" end="(462, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(462, 9)" end="(462, 29)">
          <IdentNode start="(462, 9)" end="(462, 29)" leading="" trailing=" " raw_val="mapIdx_eq_mapIdx_iff" val="mapIdx_eq_mapIdx_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(462, 30)" end="(463, 82)">
          <NullNode start="(462, 30)" end="(462, 42)">
            <OtherNode start="(462, 30)" end="(462, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(462, 30)" end="(462, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(462, 31)" end="(462, 32)">
                <IdentNode start="(462, 31)" end="(462, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(462, 33)" end="(462, 41)">
                <AtomNode start="(462, 33)" end="(462, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(462, 35)" end="(462, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(462, 35)" end="(462, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(462, 40)" end="(462, 41)">
                    <IdentNode start="(462, 40)" end="(462, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(462, 41)" end="(462, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(462, 43)" end="(463, 82)">
            <AtomNode start="(462, 43)" end="(462, 44)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(463, 5)" end="(463, 82)" kind="«term_↔_»">
              <OtherNode start="(463, 5)" end="(463, 28)" kind="«term_=_»">
                <OtherNode start="(463, 5)" end="(463, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(463, 5)" end="(463, 11)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                  <NullNode start="(463, 12)" end="(463, 15)">
                    <IdentNode start="(463, 12)" end="(463, 13)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(463, 14)" end="(463, 15)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(463, 16)" end="(463, 17)" leading="" trailing=" " val="="/>
                <OtherNode start="(463, 18)" end="(463, 28)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(463, 18)" end="(463, 24)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                  <NullNode start="(463, 25)" end="(463, 28)">
                    <IdentNode start="(463, 25)" end="(463, 26)" leading="" trailing=" " raw_val="g" val="g"/>
                    <IdentNode start="(463, 27)" end="(463, 28)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(463, 29)" end="(463, 30)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(463, 31)" end="(463, 82)" kind="Lean.Parser.Term.forall">
                <AtomNode start="(463, 31)" end="(463, 32)" leading="" trailing=" " val="∀"/>
                <NullNode start="(463, 33)" end="(463, 34)">
                  <IdentNode start="(463, 33)" end="(463, 34)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
                <NullNode start="(463, 35)" end="(463, 40)">
                  <TermTypespecNode start="(463, 35)" end="(463, 40)">
                    <AtomNode start="(463, 35)" end="(463, 36)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(463, 37)" end="(463, 40)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </TermTypespecNode>
                </NullNode>
                <AtomNode start="(463, 40)" end="(463, 41)" leading="" trailing=" " val=","/>
                <OtherNode start="(463, 42)" end="(463, 82)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(463, 42)" end="(463, 60)">
                    <AtomNode start="(463, 42)" end="(463, 43)" leading="" trailing="" val="("/>
                    <NullNode start="(463, 43)" end="(463, 44)">
                      <IdentNode start="(463, 43)" end="(463, 44)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                    <NullNode start="(463, 45)" end="(463, 59)">
                      <AtomNode start="(463, 45)" end="(463, 46)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(463, 47)" end="(463, 59)" kind="«term_&amp;lt;_»">
                        <IdentNode start="(463, 47)" end="(463, 48)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(463, 49)" end="(463, 50)" leading="" trailing=" " val="&amp;lt;"/>
                        <IdentNode start="(463, 51)" end="(463, 59)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(463, 59)" end="(463, 60)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(463, 61)" end="(463, 62)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(463, 63)" end="(463, 82)" kind="«term_=_»">
                    <OtherNode start="(463, 63)" end="(463, 71)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(463, 63)" end="(463, 64)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(463, 65)" end="(463, 71)">
                        <IdentNode start="(463, 65)" end="(463, 66)" leading="" trailing=" " raw_val="i" val="i"/>
                        <OtherNode start="(463, 67)" end="(463, 71)" kind="«term__[_]»">
                          <IdentNode start="(463, 67)" end="(463, 68)" leading="" trailing="" raw_val="l" val="l"/>
                          <AtomNode start="(463, 68)" end="(463, 69)" leading="" trailing="" val="["/>
                          <IdentNode start="(463, 69)" end="(463, 70)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(463, 70)" end="(463, 71)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(463, 72)" end="(463, 73)" leading="" trailing=" " val="="/>
                    <OtherNode start="(463, 74)" end="(463, 82)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(463, 74)" end="(463, 75)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(463, 76)" end="(463, 82)">
                        <IdentNode start="(463, 76)" end="(463, 77)" leading="" trailing=" " raw_val="i" val="i"/>
                        <OtherNode start="(463, 78)" end="(463, 82)" kind="«term__[_]»">
                          <IdentNode start="(463, 78)" end="(463, 79)" leading="" trailing="" raw_val="l" val="l"/>
                          <AtomNode start="(463, 79)" end="(463, 80)" leading="" trailing="" val="["/>
                          <IdentNode start="(463, 80)" end="(463, 81)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(463, 81)" end="(463, 82)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(463, 83)" end="(471, 15)">
          <AtomNode start="(463, 83)" end="(463, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(463, 86)" end="(471, 15)">
            <AtomNode start="(463, 86)" end="(463, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(464, 3)" end="(471, 15)">
              <TacticTacticseq1IndentedNode start="(464, 3)" end="(471, 15)">
                <NullNode start="(464, 3)" end="(471, 15)">
                  <OtherNode start="(464, 3)" end="(464, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;⊢ mapIdx f l = mapIdx g l ↔ ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]" state_after="case mp&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;⊢ mapIdx f l = mapIdx g l → ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]&#10;&#10;case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]) → mapIdx f l = mapIdx g l" tactic="constructor">
                    <AtomNode start="(464, 3)" end="(464, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(465, 3)" end="(466, 48)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;⊢ mapIdx f l = mapIdx g l → ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]&#10;&#10;case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]) → mapIdx f l = mapIdx g l" state_after="case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]) → mapIdx f l = mapIdx g l" tactic="· intro w i h&#10;  simpa [h] using congrArg (fun l =&amp;gt; l[i]?) w">
                    <OtherNode start="(465, 3)" end="(465, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(465, 3)" end="(465, 4)" kind="patternIgnore">
                        <OtherNode start="(465, 3)" end="(465, 4)" kind="token.«· »">
                          <AtomNode start="(465, 3)" end="(465, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(465, 5)" end="(466, 48)">
                      <TacticTacticseq1IndentedNode start="(465, 5)" end="(466, 48)">
                        <NullNode start="(465, 5)" end="(466, 48)">
                          <OtherNode start="(465, 5)" end="(465, 16)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;⊢ mapIdx f l = mapIdx g l → ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]" state_after="case mp&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;w : mapIdx f l = mapIdx g l&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f i l[i] = g i l[i]" tactic="intro w i h">
                            <AtomNode start="(465, 5)" end="(465, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(465, 11)" end="(465, 16)">
                              <IdentNode start="(465, 11)" end="(465, 12)" leading="" trailing=" " raw_val="w" val="w"/>
                              <IdentNode start="(465, 13)" end="(465, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                              <IdentNode start="(465, 15)" end="(465, 16)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(466, 5)" end="(466, 48)" kind="Lean.Parser.Tactic.simpa" state_before="case mp&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;w : mapIdx f l = mapIdx g l&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f i l[i] = g i l[i]" state_after="no goals" tactic="simpa [h] using congrArg (fun l =&amp;gt; l[i]?) w">
                            <AtomNode start="(466, 5)" end="(466, 10)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(466, 11)" end="(466, 48)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(466, 11)" end="(466, 14)">
                                <OtherNode start="(466, 11)" end="(466, 14)" kind="Lean.Parser.Tactic.simpArgs">
                                  <AtomNode start="(466, 11)" end="(466, 12)" leading="" trailing="" val="["/>
                                  <NullNode start="(466, 12)" end="(466, 13)">
                                    <OtherNode start="(466, 12)" end="(466, 13)" kind="Lean.Parser.Tactic.simpLemma">
                                      <NullNode/>
                                      <NullNode/>
                                      <IdentNode start="(466, 12)" end="(466, 13)" leading="" trailing="" raw_val="h" val="h"/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(466, 13)" end="(466, 14)" leading="" trailing=" " val="]"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode start="(466, 15)" end="(466, 48)">
                                <AtomNode start="(466, 15)" end="(466, 20)" leading="" trailing=" " val="using"/>
                                <OtherNode start="(466, 21)" end="(466, 48)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(466, 21)" end="(466, 29)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(466, 30)" end="(466, 48)">
                                    <OtherNode start="(466, 30)" end="(466, 46)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(466, 30)" end="(466, 31)" leading="" trailing="" val="("/>
                                      <OtherNode start="(466, 31)" end="(466, 45)" kind="Lean.Parser.Term.fun">
                                        <AtomNode start="(466, 31)" end="(466, 34)" leading="" trailing=" " val="fun"/>
                                        <OtherNode start="(466, 35)" end="(466, 45)" kind="Lean.Parser.Term.basicFun">
                                          <NullNode start="(466, 35)" end="(466, 36)">
                                            <IdentNode start="(466, 35)" end="(466, 36)" leading="" trailing=" " raw_val="l" val="l"/>
                                          </NullNode>
                                          <NullNode/>
                                          <AtomNode start="(466, 37)" end="(466, 39)" leading="" trailing=" " val="=&amp;gt;"/>
                                          <OtherNode start="(466, 40)" end="(466, 45)" kind="«term__[_]_?»">
                                            <IdentNode start="(466, 40)" end="(466, 41)" leading="" trailing="" raw_val="l" val="l"/>
                                            <GroupNode/>
                                            <AtomNode start="(466, 41)" end="(466, 42)" leading="" trailing="" val="["/>
                                            <IdentNode start="(466, 42)" end="(466, 43)" leading="" trailing="" raw_val="i" val="i"/>
                                            <AtomNode start="(466, 43)" end="(466, 44)" leading="" trailing="" val="]"/>
                                            <GroupNode/>
                                            <AtomNode start="(466, 44)" end="(466, 45)" leading="" trailing="" val="?"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(466, 45)" end="(466, 46)" leading="" trailing=" " val=")"/>
                                    </OtherNode>
                                    <IdentNode start="(466, 47)" end="(466, 48)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(467, 3)" end="(471, 15)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]) → mapIdx f l = mapIdx g l" state_after="no goals" tactic="· intro w&#10;  apply ext_getElem&#10;  · simp&#10;  · intro i h₁ h₂&#10;    simp [w]">
                    <OtherNode start="(467, 3)" end="(467, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(467, 3)" end="(467, 4)" kind="patternIgnore">
                        <OtherNode start="(467, 3)" end="(467, 4)" kind="token.«· »">
                          <AtomNode start="(467, 3)" end="(467, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(467, 5)" end="(471, 15)">
                      <TacticTacticseq1IndentedNode start="(467, 5)" end="(471, 15)">
                        <NullNode start="(467, 5)" end="(471, 15)">
                          <OtherNode start="(467, 5)" end="(467, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]) → mapIdx f l = mapIdx g l" state_after="case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]&#10;⊢ mapIdx f l = mapIdx g l" tactic="intro w">
                            <AtomNode start="(467, 5)" end="(467, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(467, 11)" end="(467, 12)">
                              <IdentNode start="(467, 11)" end="(467, 12)" leading="" trailing="&#10;    " raw_val="w" val="w"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(468, 5)" end="(468, 22)" kind="Lean.Parser.Tactic.apply" state_before="case mpr&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]&#10;⊢ mapIdx f l = mapIdx g l" state_after="case mpr.hl&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]&#10;⊢ (mapIdx f l).length = (mapIdx g l).length&#10;&#10;case mpr.h&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; (mapIdx f l).length) (h₂ : i &amp;lt; (mapIdx g l).length), (mapIdx f l)[i] = (mapIdx g l)[i]" tactic="apply ext_getElem">
                            <AtomNode start="(468, 5)" end="(468, 10)" leading="" trailing=" " val="apply"/>
                            <IdentNode start="(468, 11)" end="(468, 22)" leading="" trailing="&#10;    " raw_val="ext_getElem" val="ext_getElem" full_name="List.ext_getElem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(469, 5)" end="(469, 11)" kind="Lean.cdot" state_before="case mpr.hl&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]&#10;⊢ (mapIdx f l).length = (mapIdx g l).length&#10;&#10;case mpr.h&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; (mapIdx f l).length) (h₂ : i &amp;lt; (mapIdx g l).length), (mapIdx f l)[i] = (mapIdx g l)[i]" state_after="case mpr.h&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; (mapIdx f l).length) (h₂ : i &amp;lt; (mapIdx g l).length), (mapIdx f l)[i] = (mapIdx g l)[i]" tactic="· simp">
                            <OtherNode start="(469, 5)" end="(469, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(469, 5)" end="(469, 6)" kind="patternIgnore">
                                <OtherNode start="(469, 5)" end="(469, 6)" kind="token.«· »">
                                  <AtomNode start="(469, 5)" end="(469, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(469, 7)" end="(469, 11)">
                              <TacticTacticseq1IndentedNode start="(469, 7)" end="(469, 11)">
                                <NullNode start="(469, 7)" end="(469, 11)">
                                  <OtherNode start="(469, 7)" end="(469, 11)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.hl&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]&#10;⊢ (mapIdx f l).length = (mapIdx g l).length" state_after="no goals" tactic="simp">
                                    <AtomNode start="(469, 7)" end="(469, 11)" leading="" trailing="&#10;    " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(470, 5)" end="(471, 15)" kind="Lean.cdot" state_before="case mpr.h&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; (mapIdx f l).length) (h₂ : i &amp;lt; (mapIdx g l).length), (mapIdx f l)[i] = (mapIdx g l)[i]" state_after="no goals" tactic="· intro i h₁ h₂&#10;  simp [w]">
                            <OtherNode start="(470, 5)" end="(470, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(470, 5)" end="(470, 6)" kind="patternIgnore">
                                <OtherNode start="(470, 5)" end="(470, 6)" kind="token.«· »">
                                  <AtomNode start="(470, 5)" end="(470, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(470, 7)" end="(471, 15)">
                              <TacticTacticseq1IndentedNode start="(470, 7)" end="(471, 15)">
                                <NullNode start="(470, 7)" end="(471, 15)">
                                  <OtherNode start="(470, 7)" end="(470, 20)" kind="Lean.Parser.Tactic.intro" state_before="case mpr.h&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]&#10;⊢ ∀ (i : Nat) (h₁ : i &amp;lt; (mapIdx f l).length) (h₂ : i &amp;lt; (mapIdx g l).length), (mapIdx f l)[i] = (mapIdx g l)[i]" state_after="case mpr.h&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]&#10;i : Nat&#10;h₁ : i &amp;lt; (mapIdx f l).length&#10;h₂ : i &amp;lt; (mapIdx g l).length&#10;⊢ (mapIdx f l)[i] = (mapIdx g l)[i]" tactic="intro i h₁ h₂">
                                    <AtomNode start="(470, 7)" end="(470, 12)" leading="" trailing=" " val="intro"/>
                                    <NullNode start="(470, 13)" end="(470, 20)">
                                      <IdentNode start="(470, 13)" end="(470, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                                      <IdentNode start="(470, 15)" end="(470, 17)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                      <IdentNode start="(470, 18)" end="(470, 20)" leading="" trailing="&#10;      " raw_val="h₂" val="h₂"/>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(471, 7)" end="(471, 15)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.h&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f g : Nat → α → α✝&#10;l : List α&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = g i l[i]&#10;i : Nat&#10;h₁ : i &amp;lt; (mapIdx f l).length&#10;h₂ : i &amp;lt; (mapIdx g l).length&#10;⊢ (mapIdx f l)[i] = (mapIdx g l)[i]" state_after="no goals" tactic="simp [w]">
                                    <AtomNode start="(471, 7)" end="(471, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(471, 12)" end="(471, 15)">
                                      <AtomNode start="(471, 12)" end="(471, 13)" leading="" trailing="" val="["/>
                                      <NullNode start="(471, 13)" end="(471, 14)">
                                        <OtherNode start="(471, 13)" end="(471, 14)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(471, 13)" end="(471, 14)" leading="" trailing="" raw_val="w" val="w"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(471, 14)" end="(471, 15)" leading="" trailing="&#10;&#10;" val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(473, 1)" end="(479, 8)" name="mapIdx_set" full_name="List.mapIdx_set">
      <CommandDeclmodifiersNode start="(473, 1)" end="(473, 8)">
        <NullNode/>
        <NullNode start="(473, 1)" end="(473, 8)">
          <OtherNode start="(473, 1)" end="(473, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(473, 1)" end="(473, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(473, 3)" end="(473, 7)">
              <OtherNode start="(473, 3)" end="(473, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(473, 3)" end="(473, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(473, 3)" end="(473, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(473, 7)" end="(473, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(473, 9)" end="(479, 8)" name="mapIdx_set" full_name="List.mapIdx_set" _is_private_decl="False">
        <AtomNode start="(473, 9)" end="(473, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(473, 17)" end="(473, 27)">
          <IdentNode start="(473, 17)" end="(473, 27)" leading="" trailing=" " raw_val="mapIdx_set" val="mapIdx_set"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(473, 28)" end="(474, 54)">
          <NullNode start="(473, 28)" end="(473, 58)">
            <OtherNode start="(473, 28)" end="(473, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(473, 28)" end="(473, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(473, 29)" end="(473, 30)">
                <IdentNode start="(473, 29)" end="(473, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(473, 31)" end="(473, 39)">
                <AtomNode start="(473, 31)" end="(473, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(473, 33)" end="(473, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(473, 33)" end="(473, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(473, 38)" end="(473, 39)">
                    <IdentNode start="(473, 38)" end="(473, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(473, 39)" end="(473, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(473, 41)" end="(473, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(473, 41)" end="(473, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(473, 42)" end="(473, 43)">
                <IdentNode start="(473, 42)" end="(473, 43)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(473, 44)" end="(473, 49)">
                <AtomNode start="(473, 44)" end="(473, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(473, 46)" end="(473, 49)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(473, 49)" end="(473, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(473, 51)" end="(473, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(473, 51)" end="(473, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(473, 52)" end="(473, 53)">
                <IdentNode start="(473, 52)" end="(473, 53)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(473, 54)" end="(473, 57)">
                <AtomNode start="(473, 54)" end="(473, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(473, 56)" end="(473, 57)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(473, 57)" end="(473, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(473, 59)" end="(474, 54)">
            <AtomNode start="(473, 59)" end="(473, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(474, 5)" end="(474, 54)" kind="«term_=_»">
              <OtherNode start="(474, 5)" end="(474, 25)" kind="Lean.Parser.Term.app">
                <OtherNode start="(474, 5)" end="(474, 23)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(474, 5)" end="(474, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(474, 5)" end="(474, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(474, 6)" end="(474, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(474, 6)" end="(474, 11)" leading="" trailing=" " raw_val="l.set" val="l.set"/>
                      <NullNode start="(474, 12)" end="(474, 15)">
                        <IdentNode start="(474, 12)" end="(474, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(474, 14)" end="(474, 15)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(474, 15)" end="(474, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(474, 16)" end="(474, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(474, 17)" end="(474, 23)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                </OtherNode>
                <NullNode start="(474, 24)" end="(474, 25)">
                  <IdentNode start="(474, 24)" end="(474, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(474, 26)" end="(474, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(474, 28)" end="(474, 54)" kind="Lean.Parser.Term.app">
                <OtherNode start="(474, 28)" end="(474, 44)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(474, 28)" end="(474, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(474, 28)" end="(474, 29)" leading="" trailing="" val="("/>
                    <OtherNode start="(474, 29)" end="(474, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(474, 29)" end="(474, 37)" leading="" trailing=" " raw_val="l.mapIdx" val="l.mapIdx"/>
                      <NullNode start="(474, 38)" end="(474, 39)">
                        <IdentNode start="(474, 38)" end="(474, 39)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(474, 39)" end="(474, 40)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(474, 40)" end="(474, 41)" leading="" trailing="" val="."/>
                  <IdentNode start="(474, 41)" end="(474, 44)" leading="" trailing=" " raw_val="set" val="set" full_name="List.set" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(474, 45)" end="(474, 54)">
                  <IdentNode start="(474, 45)" end="(474, 46)" leading="" trailing=" " raw_val="i" val="i"/>
                  <OtherNode start="(474, 47)" end="(474, 54)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(474, 47)" end="(474, 48)" leading="" trailing="" val="("/>
                    <OtherNode start="(474, 48)" end="(474, 53)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(474, 48)" end="(474, 49)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(474, 50)" end="(474, 53)">
                        <IdentNode start="(474, 50)" end="(474, 51)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(474, 52)" end="(474, 53)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(474, 53)" end="(474, 54)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(474, 55)" end="(479, 8)">
          <AtomNode start="(474, 55)" end="(474, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(474, 58)" end="(479, 8)">
            <AtomNode start="(474, 58)" end="(474, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(475, 3)" end="(479, 8)">
              <TacticTacticseq1IndentedNode start="(475, 3)" end="(479, 8)">
                <NullNode start="(475, 3)" end="(479, 8)">
                  <OtherNode start="(475, 3)" end="(475, 74)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ mapIdx f (l.set i a) = (mapIdx f l).set i (f i a)" state_after="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ ∀ (i_1 : Nat),&#10;    (if i = i_1 then if i &amp;lt; l.length then some (f i a) else none else Option.map (f i_1) l[i_1]?) =&#10;      Option.map (f i_1) (if i = i_1 then if i &amp;lt; l.length then some a else none else l[i_1]?)" tactic="simp only [mapIdx_eq_iff, getElem?_set, length_mapIdx, getElem?_mapIdx]">
                    <AtomNode start="(475, 3)" end="(475, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(475, 8)" end="(475, 12)">
                      <AtomNode start="(475, 8)" end="(475, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(475, 13)" end="(475, 74)">
                      <AtomNode start="(475, 13)" end="(475, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(475, 14)" end="(475, 73)">
                        <OtherNode start="(475, 14)" end="(475, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(475, 14)" end="(475, 27)" leading="" trailing="" raw_val="mapIdx_eq_iff" val="mapIdx_eq_iff" full_name="List.mapIdx_eq_iff" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(441, 9)" def_end="(441, 22)"/>
                        </OtherNode>
                        <AtomNode start="(475, 27)" end="(475, 28)" leading="" trailing=" " val=","/>
                        <OtherNode start="(475, 29)" end="(475, 41)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(475, 29)" end="(475, 41)" leading="" trailing="" raw_val="getElem?_set" val="getElem?_set" full_name="List.getElem?_set" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(475, 41)" end="(475, 42)" leading="" trailing=" " val=","/>
                        <OtherNode start="(475, 43)" end="(475, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(475, 43)" end="(475, 56)" leading="" trailing="" raw_val="length_mapIdx" val="length_mapIdx" full_name="List.length_mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(336, 17)" def_end="(336, 30)"/>
                        </OtherNode>
                        <AtomNode start="(475, 56)" end="(475, 57)" leading="" trailing=" " val=","/>
                        <OtherNode start="(475, 58)" end="(475, 73)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(475, 58)" end="(475, 73)" leading="" trailing="" raw_val="getElem?_mapIdx" val="getElem?_mapIdx" full_name="List.getElem?_mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(359, 17)" def_end="(359, 32)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(475, 73)" end="(475, 74)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(476, 3)" end="(476, 10)" kind="Lean.Parser.Tactic.intro" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ ∀ (i_1 : Nat),&#10;    (if i = i_1 then if i &amp;lt; l.length then some (f i a) else none else Option.map (f i_1) l[i_1]?) =&#10;      Option.map (f i_1) (if i = i_1 then if i &amp;lt; l.length then some a else none else l[i_1]?)" state_after="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;i✝ : Nat&#10;a : α&#10;i : Nat&#10;⊢ (if i✝ = i then if i✝ &amp;lt; l.length then some (f i✝ a) else none else Option.map (f i) l[i]?) =&#10;    Option.map (f i) (if i✝ = i then if i✝ &amp;lt; l.length then some a else none else l[i]?)" tactic="intro i">
                    <AtomNode start="(476, 3)" end="(476, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(476, 9)" end="(476, 10)">
                      <IdentNode start="(476, 9)" end="(476, 10)" leading="" trailing="&#10;  " raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(477, 3)" end="(477, 8)" kind="Lean.Parser.Tactic.split" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;i✝ : Nat&#10;a : α&#10;i : Nat&#10;⊢ (if i✝ = i then if i✝ &amp;lt; l.length then some (f i✝ a) else none else Option.map (f i) l[i]?) =&#10;    Option.map (f i) (if i✝ = i then if i✝ &amp;lt; l.length then some a else none else l[i]?)" state_after="case isTrue&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;i✝ : Nat&#10;a : α&#10;i : Nat&#10;h✝ : i✝ = i&#10;⊢ (if i✝ &amp;lt; l.length then some (f i✝ a) else none) = Option.map (f i) (if i✝ &amp;lt; l.length then some a else none)&#10;&#10;case isFalse&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;i✝ : Nat&#10;a : α&#10;i : Nat&#10;h✝ : ¬i✝ = i&#10;⊢ Option.map (f i) l[i]? = Option.map (f i) l[i]?" tactic="split">
                    <AtomNode start="(477, 3)" end="(477, 8)" leading="" trailing="&#10;  " val="split"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(478, 3)" end="(478, 23)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;i✝ : Nat&#10;a : α&#10;i : Nat&#10;h✝ : i✝ = i&#10;⊢ (if i✝ &amp;lt; l.length then some (f i✝ a) else none) = Option.map (f i) (if i✝ &amp;lt; l.length then some a else none)&#10;&#10;case isFalse&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;i✝ : Nat&#10;a : α&#10;i : Nat&#10;h✝ : ¬i✝ = i&#10;⊢ Option.map (f i) l[i]? = Option.map (f i) l[i]?" state_after="case isFalse&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;i✝ : Nat&#10;a : α&#10;i : Nat&#10;h✝ : ¬i✝ = i&#10;⊢ Option.map (f i) l[i]? = Option.map (f i) l[i]?" tactic="· split &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(478, 3)" end="(478, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(478, 3)" end="(478, 4)" kind="patternIgnore">
                        <OtherNode start="(478, 3)" end="(478, 4)" kind="token.«· »">
                          <AtomNode start="(478, 3)" end="(478, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(478, 5)" end="(478, 23)">
                      <TacticTacticseq1IndentedNode start="(478, 5)" end="(478, 23)">
                        <NullNode start="(478, 5)" end="(478, 23)">
                          <OtherNode start="(478, 5)" end="(478, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case isTrue&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;i✝ : Nat&#10;a : α&#10;i : Nat&#10;h✝ : i✝ = i&#10;⊢ (if i✝ &amp;lt; l.length then some (f i✝ a) else none) = Option.map (f i) (if i✝ &amp;lt; l.length then some a else none)" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                            <OtherNode start="(478, 5)" end="(478, 10)" kind="Lean.Parser.Tactic.split">
                              <AtomNode start="(478, 5)" end="(478, 10)" leading="" trailing=" " val="split"/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(478, 11)" end="(478, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(478, 15)" end="(478, 23)" kind="Lean.Parser.Tactic.simpAll">
                              <AtomNode start="(478, 15)" end="(478, 23)" leading="" trailing="&#10;  " val="simp_all"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(479, 3)" end="(479, 8)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;i✝ : Nat&#10;a : α&#10;i : Nat&#10;h✝ : ¬i✝ = i&#10;⊢ Option.map (f i) l[i]? = Option.map (f i) l[i]?" state_after="no goals" tactic="· rfl">
                    <OtherNode start="(479, 3)" end="(479, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(479, 3)" end="(479, 4)" kind="patternIgnore">
                        <OtherNode start="(479, 3)" end="(479, 4)" kind="token.«· »">
                          <AtomNode start="(479, 3)" end="(479, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(479, 5)" end="(479, 8)">
                      <TacticTacticseq1IndentedNode start="(479, 5)" end="(479, 8)">
                        <NullNode start="(479, 5)" end="(479, 8)">
                          <OtherNode start="(479, 5)" end="(479, 8)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case isFalse&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : Nat → α → α✝&#10;l : List α&#10;i✝ : Nat&#10;a : α&#10;i : Nat&#10;h✝ : ¬i✝ = i&#10;⊢ Option.map (f i) l[i]? = Option.map (f i) l[i]?" state_after="no goals" tactic="rfl">
                            <AtomNode start="(479, 5)" end="(479, 8)" leading="" trailing="&#10;&#10;" val="rfl"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(481, 1)" end="(485, 21)" name="head_mapIdx" full_name="List.head_mapIdx">
      <CommandDeclmodifiersNode start="(481, 1)" end="(481, 8)">
        <NullNode/>
        <NullNode start="(481, 1)" end="(481, 8)">
          <OtherNode start="(481, 1)" end="(481, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(481, 1)" end="(481, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(481, 3)" end="(481, 7)">
              <OtherNode start="(481, 3)" end="(481, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(481, 3)" end="(481, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(481, 3)" end="(481, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(481, 7)" end="(481, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(481, 9)" end="(485, 21)" name="head_mapIdx" full_name="List.head_mapIdx" _is_private_decl="False">
        <AtomNode start="(481, 9)" end="(481, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(481, 17)" end="(481, 28)">
          <IdentNode start="(481, 17)" end="(481, 28)" leading="" trailing=" " raw_val="head_mapIdx" val="head_mapIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(481, 29)" end="(482, 58)">
          <NullNode start="(481, 29)" end="(481, 81)">
            <OtherNode start="(481, 29)" end="(481, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(481, 29)" end="(481, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(481, 30)" end="(481, 31)">
                <IdentNode start="(481, 30)" end="(481, 31)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(481, 32)" end="(481, 40)">
                <AtomNode start="(481, 32)" end="(481, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(481, 34)" end="(481, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(481, 34)" end="(481, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(481, 39)" end="(481, 40)">
                    <IdentNode start="(481, 39)" end="(481, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(481, 40)" end="(481, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(481, 42)" end="(481, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(481, 42)" end="(481, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(481, 43)" end="(481, 44)">
                <IdentNode start="(481, 43)" end="(481, 44)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(481, 45)" end="(481, 58)">
                <AtomNode start="(481, 45)" end="(481, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(481, 47)" end="(481, 58)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(481, 47)" end="(481, 50)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(481, 51)" end="(481, 52)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(481, 53)" end="(481, 58)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(481, 53)" end="(481, 54)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(481, 55)" end="(481, 56)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(481, 57)" end="(481, 58)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(481, 58)" end="(481, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(481, 60)" end="(481, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(481, 60)" end="(481, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(481, 61)" end="(481, 62)">
                <IdentNode start="(481, 61)" end="(481, 62)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(481, 63)" end="(481, 80)">
                <AtomNode start="(481, 63)" end="(481, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(481, 65)" end="(481, 80)" kind="«term_≠_»">
                  <OtherNode start="(481, 65)" end="(481, 75)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(481, 65)" end="(481, 71)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                    <NullNode start="(481, 72)" end="(481, 75)">
                      <IdentNode start="(481, 72)" end="(481, 73)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(481, 74)" end="(481, 75)" leading="" trailing=" " raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(481, 76)" end="(481, 77)" leading="" trailing=" " val="≠"/>
                  <OtherNode start="(481, 78)" end="(481, 80)" kind="«term[_]»">
                    <AtomNode start="(481, 78)" end="(481, 79)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(481, 79)" end="(481, 80)" leading="" trailing="" val="]"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(481, 80)" end="(481, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(481, 82)" end="(482, 58)">
            <AtomNode start="(481, 82)" end="(481, 83)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(482, 5)" end="(482, 58)" kind="«term_=_»">
              <OtherNode start="(482, 5)" end="(482, 24)" kind="Lean.Parser.Term.app">
                <OtherNode start="(482, 5)" end="(482, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(482, 5)" end="(482, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(482, 5)" end="(482, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(482, 6)" end="(482, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(482, 6)" end="(482, 12)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                      <NullNode start="(482, 13)" end="(482, 16)">
                        <IdentNode start="(482, 13)" end="(482, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(482, 15)" end="(482, 16)" leading="" trailing="" raw_val="l" val="l"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(482, 16)" end="(482, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(482, 17)" end="(482, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(482, 18)" end="(482, 22)" leading="" trailing=" " raw_val="head" val="head" full_name="List.head" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(482, 23)" end="(482, 24)">
                  <IdentNode start="(482, 23)" end="(482, 24)" leading="" trailing=" " raw_val="w" val="w"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(482, 25)" end="(482, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(482, 27)" end="(482, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(482, 27)" end="(482, 28)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(482, 29)" end="(482, 58)">
                  <OtherNode start="(482, 29)" end="(482, 30)" kind="num">
                    <AtomNode start="(482, 29)" end="(482, 30)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <OtherNode start="(482, 31)" end="(482, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(482, 31)" end="(482, 32)" leading="" trailing="" val="("/>
                    <OtherNode start="(482, 32)" end="(482, 57)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(482, 32)" end="(482, 38)" leading="" trailing=" " raw_val="l.head" val="l.head"/>
                      <NullNode start="(482, 39)" end="(482, 57)">
                        <OtherNode start="(482, 39)" end="(482, 57)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(482, 39)" end="(482, 40)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(482, 40)" end="(482, 56)">
                            <AtomNode start="(482, 40)" end="(482, 42)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(482, 43)" end="(482, 56)">
                              <TacticTacticseq1IndentedNode start="(482, 43)" end="(482, 56)">
                                <NullNode start="(482, 43)" end="(482, 56)">
                                  <OtherNode start="(482, 43)" end="(482, 56)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type ?u.87975&#10;β : Type ?u.87986&#10;l : List α&#10;f : Nat → α → β&#10;w : mapIdx f l ≠ []&#10;⊢ l ≠ []" state_after="no goals" tactic="simpa using w">
                                    <AtomNode start="(482, 43)" end="(482, 48)" leading="" trailing=" " val="simpa"/>
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(482, 49)" end="(482, 56)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(482, 49)" end="(482, 56)">
                                        <AtomNode start="(482, 49)" end="(482, 54)" leading="" trailing=" " val="using"/>
                                        <IdentNode start="(482, 55)" end="(482, 56)" leading="" trailing="" raw_val="w" val="w"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(482, 56)" end="(482, 57)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(482, 57)" end="(482, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(482, 59)" end="(485, 21)">
          <AtomNode start="(482, 59)" end="(482, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(482, 62)" end="(485, 21)">
            <AtomNode start="(482, 62)" end="(482, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(483, 3)" end="(485, 21)">
              <TacticTacticseq1IndentedNode start="(483, 3)" end="(485, 21)">
                <NullNode start="(483, 3)" end="(485, 21)">
                  <OtherNode start="(483, 3)" end="(485, 21)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;w : mapIdx f l ≠ []&#10;⊢ (mapIdx f l).head w = f 0 (l.head ⋯)" state_after="no goals" tactic="cases l with&#10;| nil =&amp;gt; simp at w&#10;| cons _ _ =&amp;gt; simp">
                    <AtomNode start="(483, 3)" end="(483, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(483, 9)" end="(483, 10)">
                      <OtherNode start="(483, 9)" end="(483, 10)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(483, 9)" end="(483, 10)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(483, 11)" end="(485, 21)">
                      <OtherNode start="(483, 11)" end="(485, 21)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(483, 11)" end="(483, 15)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(484, 3)" end="(485, 21)">
                          <OtherNode start="(484, 3)" end="(484, 21)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(484, 3)" end="(484, 8)">
                              <OtherNode start="(484, 3)" end="(484, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(484, 3)" end="(484, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(484, 5)" end="(484, 8)">
                                  <NullNode/>
                                  <IdentNode start="(484, 5)" end="(484, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(484, 9)" end="(484, 21)">
                              <AtomNode start="(484, 9)" end="(484, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(484, 12)" end="(484, 21)">
                                <TacticTacticseq1IndentedNode start="(484, 12)" end="(484, 21)">
                                  <NullNode start="(484, 12)" end="(484, 21)">
                                    <OtherNode start="(484, 12)" end="(484, 21)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;w : mapIdx f [] ≠ []&#10;⊢ (mapIdx f []).head w = f 0 ([].head ⋯)" state_after="no goals" tactic="simp at w">
                                      <AtomNode start="(484, 12)" end="(484, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(484, 17)" end="(484, 21)">
                                        <OtherNode start="(484, 17)" end="(484, 21)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(484, 17)" end="(484, 19)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(484, 20)" end="(484, 21)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(484, 20)" end="(484, 21)">
                                              <IdentNode start="(484, 20)" end="(484, 21)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(485, 3)" end="(485, 21)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(485, 3)" end="(485, 13)">
                              <OtherNode start="(485, 3)" end="(485, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(485, 3)" end="(485, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(485, 5)" end="(485, 9)">
                                  <NullNode/>
                                  <IdentNode start="(485, 5)" end="(485, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(485, 10)" end="(485, 13)">
                                  <TermHoleNode start="(485, 10)" end="(485, 11)">
                                    <AtomNode start="(485, 10)" end="(485, 11)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(485, 12)" end="(485, 13)">
                                    <AtomNode start="(485, 12)" end="(485, 13)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(485, 14)" end="(485, 21)">
                              <AtomNode start="(485, 14)" end="(485, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(485, 17)" end="(485, 21)">
                                <TacticTacticseq1IndentedNode start="(485, 17)" end="(485, 21)">
                                  <NullNode start="(485, 17)" end="(485, 21)">
                                    <OtherNode start="(485, 17)" end="(485, 21)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;w : mapIdx f (head✝ :: tail✝) ≠ []&#10;⊢ (mapIdx f (head✝ :: tail✝)).head w = f 0 ((head✝ :: tail✝).head ⋯)" state_after="no goals" tactic="simp">
                                      <AtomNode start="(485, 17)" end="(485, 21)" leading="" trailing="&#10;&#10;" val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(487, 1)" end="(488, 19)" name="head?_mapIdx" full_name="List.head?_mapIdx">
      <CommandDeclmodifiersNode start="(487, 1)" end="(487, 8)">
        <NullNode/>
        <NullNode start="(487, 1)" end="(487, 8)">
          <OtherNode start="(487, 1)" end="(487, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(487, 1)" end="(487, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(487, 3)" end="(487, 7)">
              <OtherNode start="(487, 3)" end="(487, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(487, 3)" end="(487, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(487, 3)" end="(487, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(487, 7)" end="(487, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(487, 9)" end="(488, 19)" name="head?_mapIdx" full_name="List.head?_mapIdx" _is_private_decl="False">
        <AtomNode start="(487, 9)" end="(487, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(487, 17)" end="(487, 29)">
          <IdentNode start="(487, 17)" end="(487, 29)" leading="" trailing=" " raw_val="head?_mapIdx" val="head?_mapIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(487, 30)" end="(487, 101)">
          <NullNode start="(487, 30)" end="(487, 60)">
            <OtherNode start="(487, 30)" end="(487, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(487, 30)" end="(487, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(487, 31)" end="(487, 32)">
                <IdentNode start="(487, 31)" end="(487, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(487, 33)" end="(487, 41)">
                <AtomNode start="(487, 33)" end="(487, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(487, 35)" end="(487, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(487, 35)" end="(487, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(487, 40)" end="(487, 41)">
                    <IdentNode start="(487, 40)" end="(487, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(487, 41)" end="(487, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(487, 43)" end="(487, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(487, 43)" end="(487, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(487, 44)" end="(487, 45)">
                <IdentNode start="(487, 44)" end="(487, 45)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(487, 46)" end="(487, 59)">
                <AtomNode start="(487, 46)" end="(487, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(487, 48)" end="(487, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(487, 48)" end="(487, 51)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(487, 52)" end="(487, 53)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(487, 54)" end="(487, 59)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(487, 54)" end="(487, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(487, 56)" end="(487, 57)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(487, 58)" end="(487, 59)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(487, 59)" end="(487, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(487, 61)" end="(487, 101)">
            <AtomNode start="(487, 61)" end="(487, 62)" leading="" trailing=" " val=":"/>
            <OtherNode start="(487, 63)" end="(487, 101)" kind="«term_=_»">
              <OtherNode start="(487, 63)" end="(487, 81)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(487, 63)" end="(487, 75)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(487, 63)" end="(487, 64)" leading="" trailing="" val="("/>
                  <OtherNode start="(487, 64)" end="(487, 74)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(487, 64)" end="(487, 70)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                    <NullNode start="(487, 71)" end="(487, 74)">
                      <IdentNode start="(487, 71)" end="(487, 72)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(487, 73)" end="(487, 74)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(487, 74)" end="(487, 75)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(487, 75)" end="(487, 76)" leading="" trailing="" val="."/>
                <IdentNode start="(487, 76)" end="(487, 81)" leading="" trailing=" " raw_val="head?" val="head?" full_name="List.head?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(487, 82)" end="(487, 83)" leading="" trailing=" " val="="/>
              <OtherNode start="(487, 84)" end="(487, 101)" kind="Lean.Parser.Term.app">
                <IdentNode start="(487, 84)" end="(487, 95)" leading="" trailing=" " raw_val="l.head?.map" val="l.head?.map"/>
                <NullNode start="(487, 96)" end="(487, 101)">
                  <OtherNode start="(487, 96)" end="(487, 101)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(487, 96)" end="(487, 97)" leading="" trailing="" val="("/>
                    <OtherNode start="(487, 97)" end="(487, 100)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(487, 97)" end="(487, 98)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(487, 99)" end="(487, 100)">
                        <OtherNode start="(487, 99)" end="(487, 100)" kind="num">
                          <AtomNode start="(487, 99)" end="(487, 100)" leading="" trailing="" val="0"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(487, 100)" end="(487, 101)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(487, 102)" end="(488, 19)">
          <AtomNode start="(487, 102)" end="(487, 104)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(487, 105)" end="(488, 19)">
            <AtomNode start="(487, 105)" end="(487, 107)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(488, 3)" end="(488, 19)">
              <TacticTacticseq1IndentedNode start="(488, 3)" end="(488, 19)">
                <NullNode start="(488, 3)" end="(488, 19)">
                  <OtherNode start="(488, 3)" end="(488, 19)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;⊢ (mapIdx f l).head? = Option.map (f 0) l.head?" state_after="no goals" tactic="cases l &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(488, 3)" end="(488, 10)" kind="Lean.Parser.Tactic.cases">
                      <AtomNode start="(488, 3)" end="(488, 8)" leading="" trailing=" " val="cases"/>
                      <NullNode start="(488, 9)" end="(488, 10)">
                        <OtherNode start="(488, 9)" end="(488, 10)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(488, 9)" end="(488, 10)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(488, 11)" end="(488, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(488, 15)" end="(488, 19)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(488, 15)" end="(488, 19)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(490, 1)" end="(499, 9)" name="getLast_mapIdx" full_name="List.getLast_mapIdx">
      <CommandDeclmodifiersNode start="(490, 1)" end="(490, 8)">
        <NullNode/>
        <NullNode start="(490, 1)" end="(490, 8)">
          <OtherNode start="(490, 1)" end="(490, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(490, 1)" end="(490, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(490, 3)" end="(490, 7)">
              <OtherNode start="(490, 3)" end="(490, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(490, 3)" end="(490, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(490, 3)" end="(490, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(490, 7)" end="(490, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(490, 9)" end="(499, 9)" name="getLast_mapIdx" full_name="List.getLast_mapIdx" _is_private_decl="False">
        <AtomNode start="(490, 9)" end="(490, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(490, 17)" end="(490, 31)">
          <IdentNode start="(490, 17)" end="(490, 31)" leading="" trailing=" " raw_val="getLast_mapIdx" val="getLast_mapIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(490, 32)" end="(491, 77)">
          <NullNode start="(490, 32)" end="(490, 66)">
            <OtherNode start="(490, 32)" end="(490, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(490, 32)" end="(490, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(490, 33)" end="(490, 34)">
                <IdentNode start="(490, 33)" end="(490, 34)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(490, 35)" end="(490, 43)">
                <AtomNode start="(490, 35)" end="(490, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(490, 37)" end="(490, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(490, 37)" end="(490, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(490, 42)" end="(490, 43)">
                    <IdentNode start="(490, 42)" end="(490, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(490, 43)" end="(490, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(490, 45)" end="(490, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(490, 45)" end="(490, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(490, 46)" end="(490, 47)">
                <IdentNode start="(490, 46)" end="(490, 47)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(490, 48)" end="(490, 61)">
                <AtomNode start="(490, 48)" end="(490, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(490, 50)" end="(490, 61)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(490, 50)" end="(490, 53)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(490, 54)" end="(490, 55)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(490, 56)" end="(490, 61)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(490, 56)" end="(490, 57)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(490, 58)" end="(490, 59)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(490, 60)" end="(490, 61)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(490, 61)" end="(490, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(490, 63)" end="(490, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(490, 63)" end="(490, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(490, 64)" end="(490, 65)">
                <IdentNode start="(490, 64)" end="(490, 65)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(490, 65)" end="(490, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(490, 67)" end="(491, 77)">
            <AtomNode start="(490, 67)" end="(490, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(491, 5)" end="(491, 77)" kind="«term_=_»">
              <OtherNode start="(491, 5)" end="(491, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(491, 5)" end="(491, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(491, 5)" end="(491, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(491, 5)" end="(491, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(491, 6)" end="(491, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(491, 6)" end="(491, 12)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                      <NullNode start="(491, 13)" end="(491, 16)">
                        <IdentNode start="(491, 13)" end="(491, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(491, 15)" end="(491, 16)" leading="" trailing="" raw_val="l" val="l"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(491, 16)" end="(491, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(491, 17)" end="(491, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(491, 18)" end="(491, 25)" leading="" trailing=" " raw_val="getLast" val="getLast" full_name="List.getLast" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(491, 26)" end="(491, 27)">
                  <IdentNode start="(491, 26)" end="(491, 27)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(491, 28)" end="(491, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(491, 30)" end="(491, 77)" kind="Lean.Parser.Term.app">
                <IdentNode start="(491, 30)" end="(491, 31)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(491, 32)" end="(491, 77)">
                  <OtherNode start="(491, 32)" end="(491, 46)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(491, 32)" end="(491, 33)" leading="" trailing="" val="("/>
                    <OtherNode start="(491, 33)" end="(491, 45)" kind="«term_-_»">
                      <IdentNode start="(491, 33)" end="(491, 41)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                      <AtomNode start="(491, 42)" end="(491, 43)" leading="" trailing=" " val="-"/>
                      <OtherNode start="(491, 44)" end="(491, 45)" kind="num">
                        <AtomNode start="(491, 44)" end="(491, 45)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(491, 45)" end="(491, 46)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(491, 47)" end="(491, 77)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(491, 47)" end="(491, 48)" leading="" trailing="" val="("/>
                    <OtherNode start="(491, 48)" end="(491, 76)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(491, 48)" end="(491, 57)" leading="" trailing=" " raw_val="l.getLast" val="l.getLast"/>
                      <NullNode start="(491, 58)" end="(491, 76)">
                        <OtherNode start="(491, 58)" end="(491, 76)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(491, 58)" end="(491, 59)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(491, 59)" end="(491, 75)">
                            <AtomNode start="(491, 59)" end="(491, 61)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(491, 62)" end="(491, 75)">
                              <TacticTacticseq1IndentedNode start="(491, 62)" end="(491, 75)">
                                <NullNode start="(491, 62)" end="(491, 75)">
                                  <OtherNode start="(491, 62)" end="(491, 75)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type ?u.88853&#10;β : Type ?u.88866&#10;l : List α&#10;f : Nat → α → β&#10;h : mapIdx f l ≠ []&#10;⊢ l ≠ []" state_after="no goals" tactic="simpa using h">
                                    <AtomNode start="(491, 62)" end="(491, 67)" leading="" trailing=" " val="simpa"/>
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(491, 68)" end="(491, 75)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(491, 68)" end="(491, 75)">
                                        <AtomNode start="(491, 68)" end="(491, 73)" leading="" trailing=" " val="using"/>
                                        <IdentNode start="(491, 74)" end="(491, 75)" leading="" trailing="" raw_val="h" val="h"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(491, 75)" end="(491, 76)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(491, 76)" end="(491, 77)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(491, 78)" end="(499, 9)">
          <AtomNode start="(491, 78)" end="(491, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(491, 81)" end="(499, 9)">
            <AtomNode start="(491, 81)" end="(491, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(492, 3)" end="(499, 9)">
              <TacticTacticseq1IndentedNode start="(492, 3)" end="(499, 9)">
                <NullNode start="(492, 3)" end="(499, 9)">
                  <OtherNode start="(492, 3)" end="(499, 9)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;h : mapIdx f l ≠ []&#10;⊢ (mapIdx f l).getLast h = f (l.length - 1) (l.getLast ⋯)" state_after="no goals" tactic="cases l with&#10;| nil =&amp;gt; simp at h&#10;| cons _ _ =&amp;gt;&#10;  simp only [← getElem_cons_length rfl]&#10;  simp only [mapIdx_cons]&#10;  simp only [← getElem_cons_length rfl]&#10;  simp only [← mapIdx_cons, getElem_mapIdx]&#10;  simp">
                    <AtomNode start="(492, 3)" end="(492, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(492, 9)" end="(492, 10)">
                      <OtherNode start="(492, 9)" end="(492, 10)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(492, 9)" end="(492, 10)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(492, 11)" end="(499, 9)">
                      <OtherNode start="(492, 11)" end="(499, 9)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(492, 11)" end="(492, 15)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(493, 3)" end="(499, 9)">
                          <OtherNode start="(493, 3)" end="(493, 21)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(493, 3)" end="(493, 8)">
                              <OtherNode start="(493, 3)" end="(493, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(493, 3)" end="(493, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(493, 5)" end="(493, 8)">
                                  <NullNode/>
                                  <IdentNode start="(493, 5)" end="(493, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(493, 9)" end="(493, 21)">
                              <AtomNode start="(493, 9)" end="(493, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(493, 12)" end="(493, 21)">
                                <TacticTacticseq1IndentedNode start="(493, 12)" end="(493, 21)">
                                  <NullNode start="(493, 12)" end="(493, 21)">
                                    <OtherNode start="(493, 12)" end="(493, 21)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;h : mapIdx f [] ≠ []&#10;⊢ (mapIdx f []).getLast h = f ([].length - 1) ([].getLast ⋯)" state_after="no goals" tactic="simp at h">
                                      <AtomNode start="(493, 12)" end="(493, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(493, 17)" end="(493, 21)">
                                        <OtherNode start="(493, 17)" end="(493, 21)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(493, 17)" end="(493, 19)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(493, 20)" end="(493, 21)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(493, 20)" end="(493, 21)">
                                              <IdentNode start="(493, 20)" end="(493, 21)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(494, 3)" end="(499, 9)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(494, 3)" end="(494, 13)">
                              <OtherNode start="(494, 3)" end="(494, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(494, 3)" end="(494, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(494, 5)" end="(494, 9)">
                                  <NullNode/>
                                  <IdentNode start="(494, 5)" end="(494, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(494, 10)" end="(494, 13)">
                                  <TermHoleNode start="(494, 10)" end="(494, 11)">
                                    <AtomNode start="(494, 10)" end="(494, 11)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(494, 12)" end="(494, 13)">
                                    <AtomNode start="(494, 12)" end="(494, 13)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(494, 14)" end="(499, 9)">
                              <AtomNode start="(494, 14)" end="(494, 16)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(495, 5)" end="(499, 9)">
                                <TacticTacticseq1IndentedNode start="(495, 5)" end="(499, 9)">
                                  <NullNode start="(495, 5)" end="(499, 9)">
                                    <OtherNode start="(495, 5)" end="(495, 42)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;h : mapIdx f (head✝ :: tail✝) ≠ []&#10;⊢ (mapIdx f (head✝ :: tail✝)).getLast h = f ((head✝ :: tail✝).length - 1) ((head✝ :: tail✝).getLast ⋯)" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;h : mapIdx f (head✝ :: tail✝) ≠ []&#10;⊢ (mapIdx f (head✝ :: tail✝)).getLast h = f ((head✝ :: tail✝).length - 1) (head✝ :: tail✝)[tail✝.length]" tactic="simp only [← getElem_cons_length rfl]">
                                      <AtomNode start="(495, 5)" end="(495, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(495, 10)" end="(495, 14)">
                                        <AtomNode start="(495, 10)" end="(495, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(495, 15)" end="(495, 42)">
                                        <AtomNode start="(495, 15)" end="(495, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(495, 16)" end="(495, 41)">
                                          <OtherNode start="(495, 16)" end="(495, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode start="(495, 16)" end="(495, 17)">
                                              <OtherNode start="(495, 16)" end="(495, 17)" kind="patternIgnore">
                                                <OtherNode start="(495, 16)" end="(495, 17)" kind="token.«← »">
                                                  <AtomNode start="(495, 16)" end="(495, 17)" leading="" trailing=" " val="←"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                            <OtherNode start="(495, 18)" end="(495, 41)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(495, 18)" end="(495, 37)" leading="" trailing=" " raw_val="getElem_cons_length" val="getElem_cons_length" full_name="List.getElem_cons_length" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                              <NullNode start="(495, 38)" end="(495, 41)">
                                                <IdentNode start="(495, 38)" end="(495, 41)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(495, 41)" end="(495, 42)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(496, 5)" end="(496, 28)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;h : mapIdx f (head✝ :: tail✝) ≠ []&#10;⊢ (mapIdx f (head✝ :: tail✝)).getLast h = f ((head✝ :: tail✝).length - 1) (head✝ :: tail✝)[tail✝.length]" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;h : mapIdx f (head✝ :: tail✝) ≠ []&#10;⊢ (f 0 head✝ :: mapIdx (fun i =&amp;gt; f (i + 1)) tail✝).getLast ⋯ =&#10;    f ((head✝ :: tail✝).length - 1) (head✝ :: tail✝)[tail✝.length]" tactic="simp only [mapIdx_cons]">
                                      <AtomNode start="(496, 5)" end="(496, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(496, 10)" end="(496, 14)">
                                        <AtomNode start="(496, 10)" end="(496, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(496, 15)" end="(496, 28)">
                                        <AtomNode start="(496, 15)" end="(496, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(496, 16)" end="(496, 27)">
                                          <OtherNode start="(496, 16)" end="(496, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(496, 16)" end="(496, 27)" leading="" trailing="" raw_val="mapIdx_cons" val="mapIdx_cons" full_name="List.mapIdx_cons" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(388, 9)" def_end="(388, 20)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(496, 27)" end="(496, 28)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(497, 5)" end="(497, 42)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;h : mapIdx f (head✝ :: tail✝) ≠ []&#10;⊢ (f 0 head✝ :: mapIdx (fun i =&amp;gt; f (i + 1)) tail✝).getLast ⋯ =&#10;    f ((head✝ :: tail✝).length - 1) (head✝ :: tail✝)[tail✝.length]" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;h : mapIdx f (head✝ :: tail✝) ≠ []&#10;⊢ (f 0 head✝ :: mapIdx (fun i =&amp;gt; f (i + 1)) tail✝)[(mapIdx (fun i =&amp;gt; f (i + 1)) tail✝).length] =&#10;    f ((head✝ :: tail✝).length - 1) (head✝ :: tail✝)[tail✝.length]" tactic="simp only [← getElem_cons_length rfl]">
                                      <AtomNode start="(497, 5)" end="(497, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(497, 10)" end="(497, 14)">
                                        <AtomNode start="(497, 10)" end="(497, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(497, 15)" end="(497, 42)">
                                        <AtomNode start="(497, 15)" end="(497, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(497, 16)" end="(497, 41)">
                                          <OtherNode start="(497, 16)" end="(497, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode start="(497, 16)" end="(497, 17)">
                                              <OtherNode start="(497, 16)" end="(497, 17)" kind="patternIgnore">
                                                <OtherNode start="(497, 16)" end="(497, 17)" kind="token.«← »">
                                                  <AtomNode start="(497, 16)" end="(497, 17)" leading="" trailing=" " val="←"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                            <OtherNode start="(497, 18)" end="(497, 41)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(497, 18)" end="(497, 37)" leading="" trailing=" " raw_val="getElem_cons_length" val="getElem_cons_length" full_name="List.getElem_cons_length" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                              <NullNode start="(497, 38)" end="(497, 41)">
                                                <IdentNode start="(497, 38)" end="(497, 41)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(497, 41)" end="(497, 42)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(498, 5)" end="(498, 46)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;h : mapIdx f (head✝ :: tail✝) ≠ []&#10;⊢ (f 0 head✝ :: mapIdx (fun i =&amp;gt; f (i + 1)) tail✝)[(mapIdx (fun i =&amp;gt; f (i + 1)) tail✝).length] =&#10;    f ((head✝ :: tail✝).length - 1) (head✝ :: tail✝)[tail✝.length]" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;h : mapIdx f (head✝ :: tail✝) ≠ []&#10;⊢ f (mapIdx (fun i =&amp;gt; f (i + 1)) tail✝).length (head✝ :: tail✝)[(mapIdx (fun i =&amp;gt; f (i + 1)) tail✝).length] =&#10;    f ((head✝ :: tail✝).length - 1) (head✝ :: tail✝)[tail✝.length]" tactic="simp only [← mapIdx_cons, getElem_mapIdx]">
                                      <AtomNode start="(498, 5)" end="(498, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(498, 10)" end="(498, 14)">
                                        <AtomNode start="(498, 10)" end="(498, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(498, 15)" end="(498, 46)">
                                        <AtomNode start="(498, 15)" end="(498, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(498, 16)" end="(498, 45)">
                                          <OtherNode start="(498, 16)" end="(498, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode start="(498, 16)" end="(498, 17)">
                                              <OtherNode start="(498, 16)" end="(498, 17)" kind="patternIgnore">
                                                <OtherNode start="(498, 16)" end="(498, 17)" kind="token.«← »">
                                                  <AtomNode start="(498, 16)" end="(498, 17)" leading="" trailing=" " val="←"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                            <IdentNode start="(498, 18)" end="(498, 29)" leading="" trailing="" raw_val="mapIdx_cons" val="mapIdx_cons" full_name="List.mapIdx_cons" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(388, 9)" def_end="(388, 20)"/>
                                          </OtherNode>
                                          <AtomNode start="(498, 29)" end="(498, 30)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(498, 31)" end="(498, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(498, 31)" end="(498, 45)" leading="" trailing="" raw_val="getElem_mapIdx" val="getElem_mapIdx" full_name="List.getElem_mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(363, 17)" def_end="(363, 31)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(498, 45)" end="(498, 46)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(499, 5)" end="(499, 9)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;h : mapIdx f (head✝ :: tail✝) ≠ []&#10;⊢ f (mapIdx (fun i =&amp;gt; f (i + 1)) tail✝).length (head✝ :: tail✝)[(mapIdx (fun i =&amp;gt; f (i + 1)) tail✝).length] =&#10;    f ((head✝ :: tail✝).length - 1) (head✝ :: tail✝)[tail✝.length]" state_after="no goals" tactic="simp">
                                      <AtomNode start="(499, 5)" end="(499, 9)" leading="" trailing="&#10;&#10;" val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(501, 1)" end="(505, 75)" name="getLast?_mapIdx" full_name="List.getLast?_mapIdx">
      <CommandDeclmodifiersNode start="(501, 1)" end="(501, 8)">
        <NullNode/>
        <NullNode start="(501, 1)" end="(501, 8)">
          <OtherNode start="(501, 1)" end="(501, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(501, 1)" end="(501, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(501, 3)" end="(501, 7)">
              <OtherNode start="(501, 3)" end="(501, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(501, 3)" end="(501, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(501, 3)" end="(501, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(501, 7)" end="(501, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(501, 9)" end="(505, 75)" name="getLast?_mapIdx" full_name="List.getLast?_mapIdx" _is_private_decl="False">
        <AtomNode start="(501, 9)" end="(501, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(501, 17)" end="(501, 32)">
          <IdentNode start="(501, 17)" end="(501, 32)" leading="" trailing=" " raw_val="getLast?_mapIdx" val="getLast?_mapIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(501, 33)" end="(502, 64)">
          <NullNode start="(501, 33)" end="(501, 63)">
            <OtherNode start="(501, 33)" end="(501, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(501, 33)" end="(501, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(501, 34)" end="(501, 35)">
                <IdentNode start="(501, 34)" end="(501, 35)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(501, 36)" end="(501, 44)">
                <AtomNode start="(501, 36)" end="(501, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(501, 38)" end="(501, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(501, 38)" end="(501, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(501, 43)" end="(501, 44)">
                    <IdentNode start="(501, 43)" end="(501, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(501, 44)" end="(501, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(501, 46)" end="(501, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(501, 46)" end="(501, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(501, 47)" end="(501, 48)">
                <IdentNode start="(501, 47)" end="(501, 48)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(501, 49)" end="(501, 62)">
                <AtomNode start="(501, 49)" end="(501, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(501, 51)" end="(501, 62)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(501, 51)" end="(501, 54)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(501, 55)" end="(501, 56)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(501, 57)" end="(501, 62)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(501, 57)" end="(501, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(501, 59)" end="(501, 60)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(501, 61)" end="(501, 62)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(501, 62)" end="(501, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(501, 64)" end="(502, 64)">
            <AtomNode start="(501, 64)" end="(501, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(502, 5)" end="(502, 64)" kind="«term_=_»">
              <OtherNode start="(502, 5)" end="(502, 26)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(502, 5)" end="(502, 17)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(502, 5)" end="(502, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(502, 6)" end="(502, 16)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(502, 6)" end="(502, 12)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                    <NullNode start="(502, 13)" end="(502, 16)">
                      <IdentNode start="(502, 13)" end="(502, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(502, 15)" end="(502, 16)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(502, 16)" end="(502, 17)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(502, 17)" end="(502, 18)" leading="" trailing="" val="."/>
                <IdentNode start="(502, 18)" end="(502, 26)" leading="" trailing=" " raw_val="getLast?" val="getLast?" full_name="List.getLast?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(502, 27)" end="(502, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(502, 29)" end="(502, 64)" kind="Lean.Parser.Term.app">
                <OtherNode start="(502, 29)" end="(502, 45)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(502, 29)" end="(502, 41)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(502, 29)" end="(502, 30)" leading="" trailing="" val="("/>
                    <OtherNode start="(502, 30)" end="(502, 40)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(502, 30)" end="(502, 38)" leading="" trailing=" " raw_val="getLast?" val="getLast?" full_name="List.getLast?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(502, 39)" end="(502, 40)">
                        <IdentNode start="(502, 39)" end="(502, 40)" leading="" trailing="" raw_val="l" val="l"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(502, 40)" end="(502, 41)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(502, 41)" end="(502, 42)" leading="" trailing="" val="."/>
                  <IdentNode start="(502, 42)" end="(502, 45)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(502, 46)" end="(502, 64)">
                  <OtherNode start="(502, 46)" end="(502, 64)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(502, 46)" end="(502, 47)" leading="" trailing="" val="("/>
                    <OtherNode start="(502, 47)" end="(502, 63)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(502, 47)" end="(502, 48)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(502, 49)" end="(502, 63)">
                        <OtherNode start="(502, 49)" end="(502, 63)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(502, 49)" end="(502, 50)" leading="" trailing="" val="("/>
                          <OtherNode start="(502, 50)" end="(502, 62)" kind="«term_-_»">
                            <IdentNode start="(502, 50)" end="(502, 58)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                            <AtomNode start="(502, 59)" end="(502, 60)" leading="" trailing=" " val="-"/>
                            <OtherNode start="(502, 61)" end="(502, 62)" kind="num">
                              <AtomNode start="(502, 61)" end="(502, 62)" leading="" trailing="" val="1"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(502, 62)" end="(502, 63)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(502, 63)" end="(502, 64)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(502, 65)" end="(505, 75)">
          <AtomNode start="(502, 65)" end="(502, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(502, 68)" end="(505, 75)">
            <AtomNode start="(502, 68)" end="(502, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(503, 3)" end="(505, 75)">
              <TacticTacticseq1IndentedNode start="(503, 3)" end="(505, 75)">
                <NullNode start="(503, 3)" end="(505, 75)">
                  <OtherNode start="(503, 3)" end="(503, 10)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;⊢ (mapIdx f l).getLast? = Option.map (f (l.length - 1)) l.getLast?" state_after="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;⊢ (mapIdx f []).getLast? = Option.map (f ([].length - 1)) [].getLast?&#10;&#10;case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;⊢ (mapIdx f (head✝ :: tail✝)).getLast? = Option.map (f ((head✝ :: tail✝).length - 1)) (head✝ :: tail✝).getLast?" tactic="cases l">
                    <AtomNode start="(503, 3)" end="(503, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(503, 9)" end="(503, 10)">
                      <OtherNode start="(503, 9)" end="(503, 10)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(503, 9)" end="(503, 10)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(504, 3)" end="(504, 9)" kind="Lean.cdot" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;⊢ (mapIdx f []).getLast? = Option.map (f ([].length - 1)) [].getLast?&#10;&#10;case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;⊢ (mapIdx f (head✝ :: tail✝)).getLast? = Option.map (f ((head✝ :: tail✝).length - 1)) (head✝ :: tail✝).getLast?" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;⊢ (mapIdx f (head✝ :: tail✝)).getLast? = Option.map (f ((head✝ :: tail✝).length - 1)) (head✝ :: tail✝).getLast?" tactic="· simp">
                    <OtherNode start="(504, 3)" end="(504, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(504, 3)" end="(504, 4)" kind="patternIgnore">
                        <OtherNode start="(504, 3)" end="(504, 4)" kind="token.«· »">
                          <AtomNode start="(504, 3)" end="(504, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(504, 5)" end="(504, 9)">
                      <TacticTacticseq1IndentedNode start="(504, 5)" end="(504, 9)">
                        <NullNode start="(504, 5)" end="(504, 9)">
                          <OtherNode start="(504, 5)" end="(504, 9)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;⊢ (mapIdx f []).getLast? = Option.map (f ([].length - 1)) [].getLast?" state_after="no goals" tactic="simp">
                            <AtomNode start="(504, 5)" end="(504, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(505, 3)" end="(505, 75)" kind="Lean.cdot" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;⊢ (mapIdx f (head✝ :: tail✝)).getLast? = Option.map (f ((head✝ :: tail✝).length - 1)) (head✝ :: tail✝).getLast?" state_after="no goals" tactic="· rw [getLast?_eq_getLast, getLast?_eq_getLast, getLast_mapIdx] &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(505, 3)" end="(505, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(505, 3)" end="(505, 4)" kind="patternIgnore">
                        <OtherNode start="(505, 3)" end="(505, 4)" kind="token.«· »">
                          <AtomNode start="(505, 3)" end="(505, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(505, 5)" end="(505, 75)">
                      <TacticTacticseq1IndentedNode start="(505, 5)" end="(505, 75)">
                        <NullNode start="(505, 5)" end="(505, 75)">
                          <OtherNode start="(505, 5)" end="(505, 75)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : Nat → α → β&#10;head✝ : α&#10;tail✝ : List α&#10;⊢ (mapIdx f (head✝ :: tail✝)).getLast? = Option.map (f ((head✝ :: tail✝).length - 1)) (head✝ :: tail✝).getLast?" state_after="no goals" tactic="rw [getLast?_eq_getLast, getLast?_eq_getLast, getLast_mapIdx] &amp;lt;;&amp;gt; simp">
                            <OtherNode start="(505, 5)" end="(505, 66)" kind="Lean.Parser.Tactic.rwSeq">
                              <AtomNode start="(505, 5)" end="(505, 7)" leading="" trailing=" " val="rw"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <OtherNode start="(505, 8)" end="(505, 66)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                <AtomNode start="(505, 8)" end="(505, 9)" leading="" trailing="" val="["/>
                                <NullNode start="(505, 9)" end="(505, 65)">
                                  <OtherNode start="(505, 9)" end="(505, 28)" kind="Lean.Parser.Tactic.rwRule">
                                    <NullNode/>
                                    <IdentNode start="(505, 9)" end="(505, 28)" leading="" trailing="" raw_val="getLast?_eq_getLast" val="getLast?_eq_getLast" full_name="List.getLast?_eq_getLast" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                  </OtherNode>
                                  <AtomNode start="(505, 28)" end="(505, 29)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(505, 30)" end="(505, 49)" kind="Lean.Parser.Tactic.rwRule">
                                    <NullNode/>
                                    <IdentNode start="(505, 30)" end="(505, 49)" leading="" trailing="" raw_val="getLast?_eq_getLast" val="getLast?_eq_getLast" full_name="List.getLast?_eq_getLast" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                  </OtherNode>
                                  <AtomNode start="(505, 49)" end="(505, 50)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(505, 51)" end="(505, 65)" kind="Lean.Parser.Tactic.rwRule">
                                    <NullNode/>
                                    <IdentNode start="(505, 51)" end="(505, 65)" leading="" trailing="" raw_val="getLast_mapIdx" val="getLast_mapIdx" full_name="List.getLast_mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(490, 17)" def_end="(490, 31)"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(505, 65)" end="(505, 66)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(505, 67)" end="(505, 70)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(505, 71)" end="(505, 75)" kind="Lean.Parser.Tactic.simp">
                              <AtomNode start="(505, 71)" end="(505, 75)" leading="" trailing="&#10;&#10;" val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(507, 1)" end="(509, 23)" name="mapIdx_mapIdx" full_name="List.mapIdx_mapIdx">
      <CommandDeclmodifiersNode start="(507, 1)" end="(507, 8)">
        <NullNode/>
        <NullNode start="(507, 1)" end="(507, 8)">
          <OtherNode start="(507, 1)" end="(507, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(507, 1)" end="(507, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(507, 3)" end="(507, 7)">
              <OtherNode start="(507, 3)" end="(507, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(507, 3)" end="(507, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(507, 3)" end="(507, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(507, 7)" end="(507, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(507, 9)" end="(509, 23)" name="mapIdx_mapIdx" full_name="List.mapIdx_mapIdx" _is_private_decl="False">
        <AtomNode start="(507, 9)" end="(507, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(507, 17)" end="(507, 30)">
          <IdentNode start="(507, 17)" end="(507, 30)" leading="" trailing=" " raw_val="mapIdx_mapIdx" val="mapIdx_mapIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(507, 31)" end="(508, 58)">
          <NullNode start="(507, 31)" end="(507, 79)">
            <OtherNode start="(507, 31)" end="(507, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(507, 31)" end="(507, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(507, 32)" end="(507, 33)">
                <IdentNode start="(507, 32)" end="(507, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(507, 34)" end="(507, 42)">
                <AtomNode start="(507, 34)" end="(507, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(507, 36)" end="(507, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(507, 36)" end="(507, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(507, 41)" end="(507, 42)">
                    <IdentNode start="(507, 41)" end="(507, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(507, 42)" end="(507, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(507, 44)" end="(507, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(507, 44)" end="(507, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(507, 45)" end="(507, 46)">
                <IdentNode start="(507, 45)" end="(507, 46)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(507, 47)" end="(507, 60)">
                <AtomNode start="(507, 47)" end="(507, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(507, 49)" end="(507, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(507, 49)" end="(507, 52)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(507, 53)" end="(507, 54)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(507, 55)" end="(507, 60)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(507, 55)" end="(507, 56)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(507, 57)" end="(507, 58)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(507, 59)" end="(507, 60)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(507, 60)" end="(507, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(507, 62)" end="(507, 79)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(507, 62)" end="(507, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(507, 63)" end="(507, 64)">
                <IdentNode start="(507, 63)" end="(507, 64)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(507, 65)" end="(507, 78)">
                <AtomNode start="(507, 65)" end="(507, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(507, 67)" end="(507, 78)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(507, 67)" end="(507, 70)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(507, 71)" end="(507, 72)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(507, 73)" end="(507, 78)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(507, 73)" end="(507, 74)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(507, 75)" end="(507, 76)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(507, 77)" end="(507, 78)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(507, 78)" end="(507, 79)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(507, 80)" end="(508, 58)">
            <AtomNode start="(507, 80)" end="(507, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(508, 5)" end="(508, 58)" kind="«term_=_»">
              <OtherNode start="(508, 5)" end="(508, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(508, 5)" end="(508, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(508, 5)" end="(508, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(508, 5)" end="(508, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(508, 6)" end="(508, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(508, 6)" end="(508, 14)" leading="" trailing=" " raw_val="l.mapIdx" val="l.mapIdx"/>
                      <NullNode start="(508, 15)" end="(508, 16)">
                        <IdentNode start="(508, 15)" end="(508, 16)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(508, 16)" end="(508, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(508, 17)" end="(508, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(508, 18)" end="(508, 24)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                </OtherNode>
                <NullNode start="(508, 25)" end="(508, 26)">
                  <IdentNode start="(508, 25)" end="(508, 26)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(508, 27)" end="(508, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(508, 29)" end="(508, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(508, 29)" end="(508, 37)" leading="" trailing=" " raw_val="l.mapIdx" val="l.mapIdx"/>
                <NullNode start="(508, 38)" end="(508, 58)">
                  <OtherNode start="(508, 38)" end="(508, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(508, 38)" end="(508, 39)" leading="" trailing="" val="("/>
                    <OtherNode start="(508, 39)" end="(508, 57)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(508, 39)" end="(508, 42)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(508, 43)" end="(508, 57)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(508, 43)" end="(508, 44)">
                          <IdentNode start="(508, 43)" end="(508, 44)" leading="" trailing=" " raw_val="i" val="i"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(508, 45)" end="(508, 47)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(508, 48)" end="(508, 57)" kind="«term_∘_»">
                          <OtherNode start="(508, 48)" end="(508, 51)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(508, 48)" end="(508, 49)" leading="" trailing=" " raw_val="g" val="g"/>
                            <NullNode start="(508, 50)" end="(508, 51)">
                              <IdentNode start="(508, 50)" end="(508, 51)" leading="" trailing=" " raw_val="i" val="i"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(508, 52)" end="(508, 53)" leading="" trailing=" " val="∘"/>
                          <OtherNode start="(508, 54)" end="(508, 57)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(508, 54)" end="(508, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(508, 56)" end="(508, 57)">
                              <IdentNode start="(508, 56)" end="(508, 57)" leading="" trailing="" raw_val="i" val="i"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(508, 57)" end="(508, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(508, 59)" end="(509, 23)">
          <AtomNode start="(508, 59)" end="(508, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(508, 62)" end="(509, 23)">
            <AtomNode start="(508, 62)" end="(508, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(509, 3)" end="(509, 23)">
              <TacticTacticseq1IndentedNode start="(509, 3)" end="(509, 23)">
                <NullNode start="(509, 3)" end="(509, 23)">
                  <OtherNode start="(509, 3)" end="(509, 23)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;l : List α&#10;f : Nat → α → β&#10;g : Nat → β → γ&#10;⊢ mapIdx g (mapIdx f l) = mapIdx (fun i =&amp;gt; g i ∘ f i) l" state_after="no goals" tactic="simp [mapIdx_eq_iff]">
                    <AtomNode start="(509, 3)" end="(509, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(509, 8)" end="(509, 23)">
                      <AtomNode start="(509, 8)" end="(509, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(509, 9)" end="(509, 22)">
                        <OtherNode start="(509, 9)" end="(509, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(509, 9)" end="(509, 22)" leading="" trailing="" raw_val="mapIdx_eq_iff" val="mapIdx_eq_iff" full_name="List.mapIdx_eq_iff" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(441, 9)" def_end="(441, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(509, 22)" end="(509, 23)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(511, 1)" end="(518, 16)" name="mapIdx_eq_replicate_iff" full_name="List.mapIdx_eq_replicate_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(511, 1)" end="(518, 16)" name="mapIdx_eq_replicate_iff" full_name="List.mapIdx_eq_replicate_iff" _is_private_decl="False">
        <AtomNode start="(511, 1)" end="(511, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(511, 9)" end="(511, 32)">
          <IdentNode start="(511, 9)" end="(511, 32)" leading="" trailing=" " raw_val="mapIdx_eq_replicate_iff" val="mapIdx_eq_replicate_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(511, 33)" end="(512, 85)">
          <NullNode start="(511, 33)" end="(511, 71)">
            <OtherNode start="(511, 33)" end="(511, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(511, 33)" end="(511, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(511, 34)" end="(511, 35)">
                <IdentNode start="(511, 34)" end="(511, 35)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(511, 36)" end="(511, 44)">
                <AtomNode start="(511, 36)" end="(511, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(511, 38)" end="(511, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(511, 38)" end="(511, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(511, 43)" end="(511, 44)">
                    <IdentNode start="(511, 43)" end="(511, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(511, 44)" end="(511, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(511, 46)" end="(511, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(511, 46)" end="(511, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(511, 47)" end="(511, 48)">
                <IdentNode start="(511, 47)" end="(511, 48)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(511, 49)" end="(511, 62)">
                <AtomNode start="(511, 49)" end="(511, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(511, 51)" end="(511, 62)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(511, 51)" end="(511, 54)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(511, 55)" end="(511, 56)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(511, 57)" end="(511, 62)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(511, 57)" end="(511, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(511, 59)" end="(511, 60)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(511, 61)" end="(511, 62)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(511, 62)" end="(511, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(511, 64)" end="(511, 71)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(511, 64)" end="(511, 65)" leading="" trailing="" val="{"/>
              <NullNode start="(511, 65)" end="(511, 66)">
                <IdentNode start="(511, 65)" end="(511, 66)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(511, 67)" end="(511, 70)">
                <AtomNode start="(511, 67)" end="(511, 68)" leading="" trailing=" " val=":"/>
                <IdentNode start="(511, 69)" end="(511, 70)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(511, 70)" end="(511, 71)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(511, 72)" end="(512, 85)">
            <AtomNode start="(511, 72)" end="(511, 73)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(512, 5)" end="(512, 85)" kind="«term_↔_»">
              <OtherNode start="(512, 5)" end="(512, 38)" kind="«term_=_»">
                <OtherNode start="(512, 5)" end="(512, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(512, 5)" end="(512, 11)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                  <NullNode start="(512, 12)" end="(512, 15)">
                    <IdentNode start="(512, 12)" end="(512, 13)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(512, 14)" end="(512, 15)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(512, 16)" end="(512, 17)" leading="" trailing=" " val="="/>
                <OtherNode start="(512, 18)" end="(512, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(512, 18)" end="(512, 27)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(512, 28)" end="(512, 38)">
                    <IdentNode start="(512, 28)" end="(512, 36)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <IdentNode start="(512, 37)" end="(512, 38)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(512, 39)" end="(512, 40)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(512, 41)" end="(512, 85)" kind="Lean.Parser.Term.forall">
                <AtomNode start="(512, 41)" end="(512, 42)" leading="" trailing=" " val="∀"/>
                <NullNode start="(512, 43)" end="(512, 71)">
                  <TermExplicitbinderNode start="(512, 43)" end="(512, 52)">
                    <AtomNode start="(512, 43)" end="(512, 44)" leading="" trailing="" val="("/>
                    <NullNode start="(512, 44)" end="(512, 45)">
                      <IdentNode start="(512, 44)" end="(512, 45)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                    <NullNode start="(512, 46)" end="(512, 51)">
                      <AtomNode start="(512, 46)" end="(512, 47)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(512, 48)" end="(512, 51)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(512, 51)" end="(512, 52)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <TermExplicitbinderNode start="(512, 53)" end="(512, 71)">
                    <AtomNode start="(512, 53)" end="(512, 54)" leading="" trailing="" val="("/>
                    <NullNode start="(512, 54)" end="(512, 55)">
                      <IdentNode start="(512, 54)" end="(512, 55)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                    <NullNode start="(512, 56)" end="(512, 70)">
                      <AtomNode start="(512, 56)" end="(512, 57)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(512, 58)" end="(512, 70)" kind="«term_&amp;lt;_»">
                        <IdentNode start="(512, 58)" end="(512, 59)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(512, 60)" end="(512, 61)" leading="" trailing=" " val="&amp;lt;"/>
                        <IdentNode start="(512, 62)" end="(512, 70)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(512, 70)" end="(512, 71)" leading="" trailing="" val=")"/>
                  </TermExplicitbinderNode>
                </NullNode>
                <NullNode/>
                <AtomNode start="(512, 71)" end="(512, 72)" leading="" trailing=" " val=","/>
                <OtherNode start="(512, 73)" end="(512, 85)" kind="«term_=_»">
                  <OtherNode start="(512, 73)" end="(512, 81)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(512, 73)" end="(512, 74)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(512, 75)" end="(512, 81)">
                      <IdentNode start="(512, 75)" end="(512, 76)" leading="" trailing=" " raw_val="i" val="i"/>
                      <OtherNode start="(512, 77)" end="(512, 81)" kind="«term__[_]»">
                        <IdentNode start="(512, 77)" end="(512, 78)" leading="" trailing="" raw_val="l" val="l"/>
                        <AtomNode start="(512, 78)" end="(512, 79)" leading="" trailing="" val="["/>
                        <IdentNode start="(512, 79)" end="(512, 80)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(512, 80)" end="(512, 81)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(512, 82)" end="(512, 83)" leading="" trailing=" " val="="/>
                  <IdentNode start="(512, 84)" end="(512, 85)" leading="" trailing=" " raw_val="b" val="b"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(512, 86)" end="(518, 16)">
          <AtomNode start="(512, 86)" end="(512, 88)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(512, 89)" end="(518, 16)">
            <AtomNode start="(512, 89)" end="(512, 91)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(513, 3)" end="(518, 16)">
              <TacticTacticseq1IndentedNode start="(513, 3)" end="(518, 16)">
                <NullNode start="(513, 3)" end="(518, 16)">
                  <OtherNode start="(513, 3)" end="(513, 89)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;⊢ mapIdx f l = replicate l.length b ↔ ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = b" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;⊢ (∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] = b_1 → b_1 = b) ↔ ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = b" tactic="simp only [eq_replicate_iff, length_mapIdx, mem_mapIdx, forall_exists_index, true_and]">
                    <AtomNode start="(513, 3)" end="(513, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(513, 8)" end="(513, 12)">
                      <AtomNode start="(513, 8)" end="(513, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(513, 13)" end="(513, 89)">
                      <AtomNode start="(513, 13)" end="(513, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(513, 14)" end="(513, 88)">
                        <OtherNode start="(513, 14)" end="(513, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(513, 14)" end="(513, 30)" leading="" trailing="" raw_val="eq_replicate_iff" val="eq_replicate_iff" full_name="List.eq_replicate_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(513, 30)" end="(513, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(513, 32)" end="(513, 45)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(513, 32)" end="(513, 45)" leading="" trailing="" raw_val="length_mapIdx" val="length_mapIdx" full_name="List.length_mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(336, 17)" def_end="(336, 30)"/>
                        </OtherNode>
                        <AtomNode start="(513, 45)" end="(513, 46)" leading="" trailing=" " val=","/>
                        <OtherNode start="(513, 47)" end="(513, 57)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(513, 47)" end="(513, 57)" leading="" trailing="" raw_val="mem_mapIdx" val="mem_mapIdx" full_name="List.mem_mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(418, 17)" def_end="(418, 27)"/>
                        </OtherNode>
                        <AtomNode start="(513, 57)" end="(513, 58)" leading="" trailing=" " val=","/>
                        <OtherNode start="(513, 59)" end="(513, 78)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(513, 59)" end="(513, 78)" leading="" trailing="" raw_val="forall_exists_index" val="forall_exists_index" full_name="forall_exists_index" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(513, 78)" end="(513, 79)" leading="" trailing=" " val=","/>
                        <OtherNode start="(513, 80)" end="(513, 88)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(513, 80)" end="(513, 88)" leading="" trailing="" raw_val="true_and" val="true_and" full_name="true_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(513, 88)" end="(513, 89)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(514, 3)" end="(514, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;⊢ (∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] = b_1 → b_1 = b) ↔ ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = b" state_after="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;⊢ (∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] = b_1 → b_1 = b) → ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = b&#10;&#10;case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = b) → ∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] = b_1 → b_1 = b" tactic="constructor">
                    <AtomNode start="(514, 3)" end="(514, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(515, 3)" end="(516, 22)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;⊢ (∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] = b_1 → b_1 = b) → ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = b&#10;&#10;case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = b) → ∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] = b_1 → b_1 = b" state_after="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = b) → ∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] = b_1 → b_1 = b" tactic="· intro w i h&#10;  apply w _ _ _ rfl">
                    <OtherNode start="(515, 3)" end="(515, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(515, 3)" end="(515, 4)" kind="patternIgnore">
                        <OtherNode start="(515, 3)" end="(515, 4)" kind="token.«· »">
                          <AtomNode start="(515, 3)" end="(515, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(515, 5)" end="(516, 22)">
                      <TacticTacticseq1IndentedNode start="(515, 5)" end="(516, 22)">
                        <NullNode start="(515, 5)" end="(516, 22)">
                          <OtherNode start="(515, 5)" end="(515, 16)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;⊢ (∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] = b_1 → b_1 = b) → ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = b" state_after="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;w : ∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] = b_1 → b_1 = b&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f i l[i] = b" tactic="intro w i h">
                            <AtomNode start="(515, 5)" end="(515, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(515, 11)" end="(515, 16)">
                              <IdentNode start="(515, 11)" end="(515, 12)" leading="" trailing=" " raw_val="w" val="w"/>
                              <IdentNode start="(515, 13)" end="(515, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                              <IdentNode start="(515, 15)" end="(515, 16)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(516, 5)" end="(516, 22)" kind="Lean.Parser.Tactic.apply" state_before="case mp&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;w : ∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] = b_1 → b_1 = b&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f i l[i] = b" state_after="no goals" tactic="apply w _ _ _ rfl">
                            <AtomNode start="(516, 5)" end="(516, 10)" leading="" trailing=" " val="apply"/>
                            <OtherNode start="(516, 11)" end="(516, 22)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(516, 11)" end="(516, 12)" leading="" trailing=" " raw_val="w" val="w"/>
                              <NullNode start="(516, 13)" end="(516, 22)">
                                <TermHoleNode start="(516, 13)" end="(516, 14)">
                                  <AtomNode start="(516, 13)" end="(516, 14)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <TermHoleNode start="(516, 15)" end="(516, 16)">
                                  <AtomNode start="(516, 15)" end="(516, 16)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <TermHoleNode start="(516, 17)" end="(516, 18)">
                                  <AtomNode start="(516, 17)" end="(516, 18)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <IdentNode start="(516, 19)" end="(516, 22)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(517, 3)" end="(518, 16)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = b) → ∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] = b_1 → b_1 = b" state_after="no goals" tactic="· rintro w _ i h rfl&#10;  exact w i h">
                    <OtherNode start="(517, 3)" end="(517, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(517, 3)" end="(517, 4)" kind="patternIgnore">
                        <OtherNode start="(517, 3)" end="(517, 4)" kind="token.«· »">
                          <AtomNode start="(517, 3)" end="(517, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(517, 5)" end="(518, 16)">
                      <TacticTacticseq1IndentedNode start="(517, 5)" end="(518, 16)">
                        <NullNode start="(517, 5)" end="(518, 16)">
                          <OtherNode start="(517, 5)" end="(517, 23)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;⊢ (∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = b) → ∀ (b_1 : β) (x : Nat) (x_1 : x &amp;lt; l.length), f x l[x] = b_1 → b_1 = b" state_after="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = b&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f i l[i] = b" tactic="rintro w _ i h rfl">
                            <AtomNode start="(517, 5)" end="(517, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(517, 12)" end="(517, 23)">
                              <OtherNode start="(517, 12)" end="(517, 13)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(517, 12)" end="(517, 13)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(517, 12)" end="(517, 13)" leading="" trailing=" " raw_val="w" val="w"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(517, 14)" end="(517, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(517, 14)" end="(517, 15)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                  <AtomNode start="(517, 14)" end="(517, 15)" leading="" trailing=" " val="_"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(517, 16)" end="(517, 17)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(517, 16)" end="(517, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(517, 16)" end="(517, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(517, 18)" end="(517, 19)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(517, 18)" end="(517, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(517, 18)" end="(517, 19)" leading="" trailing=" " raw_val="h" val="h"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(517, 20)" end="(517, 23)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(517, 20)" end="(517, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(517, 20)" end="(517, 23)" leading="" trailing="&#10;    " raw_val="rfl" val="rfl"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(518, 5)" end="(518, 16)" kind="Lean.Parser.Tactic.exact" state_before="case mpr&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;b : β&#10;w : ∀ (i : Nat) (h : i &amp;lt; l.length), f i l[i] = b&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f i l[i] = b" state_after="no goals" tactic="exact w i h">
                            <AtomNode start="(518, 5)" end="(518, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(518, 11)" end="(518, 16)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(518, 11)" end="(518, 12)" leading="" trailing=" " raw_val="w" val="w"/>
                              <NullNode start="(518, 13)" end="(518, 16)">
                                <IdentNode start="(518, 13)" end="(518, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                                <IdentNode start="(518, 15)" end="(518, 16)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(520, 1)" end="(530, 9)" name="mapIdx_reverse" full_name="List.mapIdx_reverse">
      <CommandDeclmodifiersNode start="(520, 1)" end="(520, 8)">
        <NullNode/>
        <NullNode start="(520, 1)" end="(520, 8)">
          <OtherNode start="(520, 1)" end="(520, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(520, 1)" end="(520, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(520, 3)" end="(520, 7)">
              <OtherNode start="(520, 3)" end="(520, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(520, 3)" end="(520, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(520, 3)" end="(520, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(520, 7)" end="(520, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(520, 9)" end="(530, 9)" name="mapIdx_reverse" full_name="List.mapIdx_reverse" _is_private_decl="False">
        <AtomNode start="(520, 9)" end="(520, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(520, 17)" end="(520, 31)">
          <IdentNode start="(520, 17)" end="(520, 31)" leading="" trailing=" " raw_val="mapIdx_reverse" val="mapIdx_reverse"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(520, 32)" end="(521, 76)">
          <NullNode start="(520, 32)" end="(520, 62)">
            <OtherNode start="(520, 32)" end="(520, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(520, 32)" end="(520, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(520, 33)" end="(520, 34)">
                <IdentNode start="(520, 33)" end="(520, 34)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(520, 35)" end="(520, 43)">
                <AtomNode start="(520, 35)" end="(520, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(520, 37)" end="(520, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(520, 37)" end="(520, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(520, 42)" end="(520, 43)">
                    <IdentNode start="(520, 42)" end="(520, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(520, 43)" end="(520, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(520, 45)" end="(520, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(520, 45)" end="(520, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(520, 46)" end="(520, 47)">
                <IdentNode start="(520, 46)" end="(520, 47)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(520, 48)" end="(520, 61)">
                <AtomNode start="(520, 48)" end="(520, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(520, 50)" end="(520, 61)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(520, 50)" end="(520, 53)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <AtomNode start="(520, 54)" end="(520, 55)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(520, 56)" end="(520, 61)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(520, 56)" end="(520, 57)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(520, 58)" end="(520, 59)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(520, 60)" end="(520, 61)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(520, 61)" end="(520, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(520, 63)" end="(521, 76)">
            <AtomNode start="(520, 63)" end="(520, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(521, 5)" end="(521, 76)" kind="«term_=_»">
              <OtherNode start="(521, 5)" end="(521, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(521, 5)" end="(521, 21)" leading="" trailing=" " raw_val="l.reverse.mapIdx" val="l.reverse.mapIdx"/>
                <NullNode start="(521, 22)" end="(521, 23)">
                  <IdentNode start="(521, 22)" end="(521, 23)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(521, 24)" end="(521, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(521, 26)" end="(521, 76)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(521, 26)" end="(521, 68)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(521, 26)" end="(521, 27)" leading="" trailing="" val="("/>
                  <OtherNode start="(521, 27)" end="(521, 67)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(521, 27)" end="(521, 33)" leading="" trailing=" " raw_val="mapIdx" val="mapIdx" full_name="List.mapIdx" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(47, 15)" def_end="(47, 21)"/>
                    <NullNode start="(521, 34)" end="(521, 67)">
                      <OtherNode start="(521, 34)" end="(521, 65)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(521, 34)" end="(521, 35)" leading="" trailing="" val="("/>
                        <OtherNode start="(521, 35)" end="(521, 64)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(521, 35)" end="(521, 38)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(521, 39)" end="(521, 64)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(521, 39)" end="(521, 40)">
                              <IdentNode start="(521, 39)" end="(521, 40)" leading="" trailing=" " raw_val="i" val="i"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(521, 41)" end="(521, 43)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(521, 44)" end="(521, 64)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(521, 44)" end="(521, 45)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(521, 46)" end="(521, 64)">
                                <OtherNode start="(521, 46)" end="(521, 64)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(521, 46)" end="(521, 47)" leading="" trailing="" val="("/>
                                  <OtherNode start="(521, 47)" end="(521, 63)" kind="«term_-_»">
                                    <OtherNode start="(521, 47)" end="(521, 59)" kind="«term_-_»">
                                      <IdentNode start="(521, 47)" end="(521, 55)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                      <AtomNode start="(521, 56)" end="(521, 57)" leading="" trailing=" " val="-"/>
                                      <OtherNode start="(521, 58)" end="(521, 59)" kind="num">
                                        <AtomNode start="(521, 58)" end="(521, 59)" leading="" trailing=" " val="1"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <AtomNode start="(521, 60)" end="(521, 61)" leading="" trailing=" " val="-"/>
                                    <IdentNode start="(521, 62)" end="(521, 63)" leading="" trailing="" raw_val="i" val="i"/>
                                  </OtherNode>
                                  <AtomNode start="(521, 63)" end="(521, 64)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(521, 64)" end="(521, 65)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <IdentNode start="(521, 66)" end="(521, 67)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(521, 67)" end="(521, 68)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(521, 68)" end="(521, 69)" leading="" trailing="" val="."/>
                <IdentNode start="(521, 69)" end="(521, 76)" leading="" trailing=" " raw_val="reverse" val="reverse" full_name="List.reverse" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(521, 77)" end="(530, 9)">
          <AtomNode start="(521, 77)" end="(521, 79)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(521, 80)" end="(530, 9)">
            <AtomNode start="(521, 80)" end="(521, 82)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(522, 3)" end="(530, 9)">
              <TacticTacticseq1IndentedNode start="(522, 3)" end="(530, 9)">
                <NullNode start="(522, 3)" end="(530, 9)">
                  <OtherNode start="(522, 3)" end="(522, 23)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;⊢ mapIdx f l.reverse = (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;⊢ ∀ (i : Nat), (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse[i]? = Option.map (f i) l.reverse[i]?" tactic="simp [mapIdx_eq_iff]">
                    <AtomNode start="(522, 3)" end="(522, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(522, 8)" end="(522, 23)">
                      <AtomNode start="(522, 8)" end="(522, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(522, 9)" end="(522, 22)">
                        <OtherNode start="(522, 9)" end="(522, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(522, 9)" end="(522, 22)" leading="" trailing="" raw_val="mapIdx_eq_iff" val="mapIdx_eq_iff" full_name="List.mapIdx_eq_iff" mod_name="Init.Data.List.MapIdx" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/MapIdx.lean" def_start="(441, 9)" def_end="(441, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(522, 22)" end="(522, 23)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(523, 3)" end="(523, 10)" kind="Lean.Parser.Tactic.intro" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;⊢ ∀ (i : Nat), (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse[i]? = Option.map (f i) l.reverse[i]?" state_after="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;⊢ (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse[i]? = Option.map (f i) l.reverse[i]?" tactic="intro i">
                    <AtomNode start="(523, 3)" end="(523, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(523, 9)" end="(523, 10)">
                      <IdentNode start="(523, 9)" end="(523, 10)" leading="" trailing="&#10;  " raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(524, 3)" end="(524, 28)" kind="«tacticBy_cases_:_»" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;⊢ (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse[i]? = Option.map (f i) l.reverse[i]?" state_after="case pos&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse[i]? = Option.map (f i) l.reverse[i]?&#10;&#10;case neg&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : ¬i &amp;lt; l.length&#10;⊢ (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse[i]? = Option.map (f i) l.reverse[i]?" tactic="by_cases h : i &amp;lt; l.length">
                    <AtomNode start="(524, 3)" end="(524, 11)" leading="" trailing=" " val="by_cases"/>
                    <NullNode start="(524, 12)" end="(524, 15)">
                      <IdentNode start="(524, 12)" end="(524, 13)" leading="" trailing=" " raw_val="h" val="h"/>
                      <AtomNode start="(524, 14)" end="(524, 15)" leading="" trailing=" " val=":"/>
                    </NullNode>
                    <OtherNode start="(524, 16)" end="(524, 28)" kind="«term_&amp;lt;_»">
                      <IdentNode start="(524, 16)" end="(524, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(524, 18)" end="(524, 19)" leading="" trailing=" " val="&amp;lt;"/>
                      <IdentNode start="(524, 20)" end="(524, 28)" leading="" trailing="&#10;  " raw_val="l.length" val="l.length"/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(525, 3)" end="(527, 10)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse[i]? = Option.map (f i) l.reverse[i]?&#10;&#10;case neg&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : ¬i &amp;lt; l.length&#10;⊢ (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse[i]? = Option.map (f i) l.reverse[i]?" state_after="case neg&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : ¬i &amp;lt; l.length&#10;⊢ (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse[i]? = Option.map (f i) l.reverse[i]?" tactic="· simp [getElem?_reverse, h]&#10;  congr&#10;  omega">
                    <OtherNode start="(525, 3)" end="(525, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(525, 3)" end="(525, 4)" kind="patternIgnore">
                        <OtherNode start="(525, 3)" end="(525, 4)" kind="token.«· »">
                          <AtomNode start="(525, 3)" end="(525, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(525, 5)" end="(527, 10)">
                      <TacticTacticseq1IndentedNode start="(525, 5)" end="(527, 10)">
                        <NullNode start="(525, 5)" end="(527, 10)">
                          <OtherNode start="(525, 5)" end="(525, 31)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse[i]? = Option.map (f i) l.reverse[i]?" state_after="case pos&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f (l.length - 1 - (l.length - 1 - i)) l[l.length - 1 - i] = f i l[l.length - 1 - i]" tactic="simp [getElem?_reverse, h]">
                            <AtomNode start="(525, 5)" end="(525, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(525, 10)" end="(525, 31)">
                              <AtomNode start="(525, 10)" end="(525, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(525, 11)" end="(525, 30)">
                                <OtherNode start="(525, 11)" end="(525, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(525, 11)" end="(525, 27)" leading="" trailing="" raw_val="getElem?_reverse" val="getElem?_reverse" full_name="List.getElem?_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(525, 27)" end="(525, 28)" leading="" trailing=" " val=","/>
                                <OtherNode start="(525, 29)" end="(525, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(525, 29)" end="(525, 30)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(525, 30)" end="(525, 31)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(526, 5)" end="(526, 10)" kind="Lean.Parser.Tactic.congr" state_before="case pos&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ f (l.length - 1 - (l.length - 1 - i)) l[l.length - 1 - i] = f i l[l.length - 1 - i]" state_after="case pos.e_a&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ l.length - 1 - (l.length - 1 - i) = i" tactic="congr">
                            <AtomNode start="(526, 5)" end="(526, 10)" leading="" trailing="&#10;    " val="congr"/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(527, 5)" end="(527, 10)" kind="Lean.Parser.Tactic.omega" state_before="case pos.e_a&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ l.length - 1 - (l.length - 1 - i) = i" state_after="no goals" tactic="omega">
                            <AtomNode start="(527, 5)" end="(527, 10)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(528, 3)" end="(530, 9)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : ¬i &amp;lt; l.length&#10;⊢ (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse[i]? = Option.map (f i) l.reverse[i]?" state_after="no goals" tactic="· simp at h&#10;  rw [getElem?_eq_none (by simp [h]), getElem?_eq_none (by simp [h])]&#10;  simp">
                    <OtherNode start="(528, 3)" end="(528, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(528, 3)" end="(528, 4)" kind="patternIgnore">
                        <OtherNode start="(528, 3)" end="(528, 4)" kind="token.«· »">
                          <AtomNode start="(528, 3)" end="(528, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(528, 5)" end="(530, 9)">
                      <TacticTacticseq1IndentedNode start="(528, 5)" end="(530, 9)">
                        <NullNode start="(528, 5)" end="(530, 9)">
                          <OtherNode start="(528, 5)" end="(528, 14)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : ¬i &amp;lt; l.length&#10;⊢ (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse[i]? = Option.map (f i) l.reverse[i]?" state_after="case neg&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : l.length ≤ i&#10;⊢ (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse[i]? = Option.map (f i) l.reverse[i]?" tactic="simp at h">
                            <AtomNode start="(528, 5)" end="(528, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(528, 10)" end="(528, 14)">
                              <OtherNode start="(528, 10)" end="(528, 14)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(528, 10)" end="(528, 12)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(528, 13)" end="(528, 14)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(528, 13)" end="(528, 14)">
                                    <IdentNode start="(528, 13)" end="(528, 14)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(529, 5)" end="(529, 72)" kind="Lean.Parser.Tactic.rwSeq" state_before="case neg&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : l.length ≤ i&#10;⊢ (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse[i]? = Option.map (f i) l.reverse[i]?" state_after="case neg&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : l.length ≤ i&#10;⊢ none = Option.map (f i) none" tactic="rw [getElem?_eq_none (by simp [h]), getElem?_eq_none (by simp [h])]">
                            <AtomNode start="(529, 5)" end="(529, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(529, 8)" end="(529, 72)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(529, 8)" end="(529, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(529, 9)" end="(529, 71)">
                                <OtherNode start="(529, 9)" end="(529, 39)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(529, 9)" end="(529, 39)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(529, 9)" end="(529, 25)" leading="" trailing=" " raw_val="getElem?_eq_none" val="getElem?_eq_none" full_name="List.getElem?_eq_none" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                    <NullNode start="(529, 26)" end="(529, 39)">
                                      <OtherNode start="(529, 26)" end="(529, 39)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(529, 26)" end="(529, 27)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(529, 27)" end="(529, 38)">
                                          <AtomNode start="(529, 27)" end="(529, 29)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(529, 30)" end="(529, 38)">
                                            <TacticTacticseq1IndentedNode start="(529, 30)" end="(529, 38)">
                                              <NullNode start="(529, 30)" end="(529, 38)">
                                                <OtherNode start="(529, 30)" end="(529, 38)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : l.length ≤ i&#10;⊢ (mapIdx (fun i =&amp;gt; f (l.length - 1 - i)) l).reverse.length ≤ i" state_after="no goals" tactic="simp [h]">
                                                  <AtomNode start="(529, 30)" end="(529, 34)" leading="" trailing=" " val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode start="(529, 35)" end="(529, 38)">
                                                    <AtomNode start="(529, 35)" end="(529, 36)" leading="" trailing="" val="["/>
                                                    <NullNode start="(529, 36)" end="(529, 37)">
                                                      <OtherNode start="(529, 36)" end="(529, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(529, 36)" end="(529, 37)" leading="" trailing="" raw_val="h" val="h"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(529, 37)" end="(529, 38)" leading="" trailing="" val="]"/>
                                                  </NullNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(529, 38)" end="(529, 39)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(529, 39)" end="(529, 40)" leading="" trailing=" " val=","/>
                                <OtherNode start="(529, 41)" end="(529, 71)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(529, 41)" end="(529, 71)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(529, 41)" end="(529, 57)" leading="" trailing=" " raw_val="getElem?_eq_none" val="getElem?_eq_none" full_name="List.getElem?_eq_none" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                    <NullNode start="(529, 58)" end="(529, 71)">
                                      <OtherNode start="(529, 58)" end="(529, 71)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(529, 58)" end="(529, 59)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(529, 59)" end="(529, 70)">
                                          <AtomNode start="(529, 59)" end="(529, 61)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(529, 62)" end="(529, 70)">
                                            <TacticTacticseq1IndentedNode start="(529, 62)" end="(529, 70)">
                                              <NullNode start="(529, 62)" end="(529, 70)">
                                                <OtherNode start="(529, 62)" end="(529, 70)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : l.length ≤ i&#10;⊢ l.reverse.length ≤ i" state_after="no goals" tactic="simp [h]">
                                                  <AtomNode start="(529, 62)" end="(529, 66)" leading="" trailing=" " val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode start="(529, 67)" end="(529, 70)">
                                                    <AtomNode start="(529, 67)" end="(529, 68)" leading="" trailing="" val="["/>
                                                    <NullNode start="(529, 68)" end="(529, 69)">
                                                      <OtherNode start="(529, 68)" end="(529, 69)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(529, 68)" end="(529, 69)" leading="" trailing="" raw_val="h" val="h"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(529, 69)" end="(529, 70)" leading="" trailing="" val="]"/>
                                                  </NullNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(529, 70)" end="(529, 71)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(529, 71)" end="(529, 72)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(530, 5)" end="(530, 9)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : Nat → α → β&#10;i : Nat&#10;h : l.length ≤ i&#10;⊢ none = Option.map (f i) none" state_after="no goals" tactic="simp">
                            <AtomNode start="(530, 5)" end="(530, 9)" leading="" trailing="&#10;&#10;" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(532, 1)" end="(532, 9)" name="List">
      <AtomNode start="(532, 1)" end="(532, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(532, 5)" end="(532, 9)">
        <IdentNode start="(532, 5)" end="(532, 9)" leading="" trailing="&#10;" raw_val="List" val="List"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(16, 38)" end="(17, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(17, 39)" end="(19, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(21, 1)" end="(21, 35)" text="## Operations using indexes -/"/>
    <Comment start="(23, 1)" end="(29, 3)" text="Applies a function to each element of the list along with the index at which that element is found,&#10;returning the list of results. In addition to the index, the function is also provided with a proof&#10;that the index is valid.&#10;&#10;`List.mapIdx` is a variant that does not provide the function with evidence that the index is valid.&#10;-/"/>
    <Comment start="(33, 3)" end="(34, 80)" text="Auxiliary for `mapFinIdx`:&#10;  `mapFinIdx.go [a₀, a₁, ...] acc = acc.toList ++ [f 0 a₀ ⋯, f 1 a₁ ⋯, ...]` -/"/>
    <Comment start="(40, 1)" end="(46, 3)" text="Applies a function to each element of the list along with the index at which that element is found,&#10;returning the list of results.&#10;&#10;`List.mapFinIdx` is a variant that additionally provides the function with a proof that the index&#10;is valid.&#10;-/"/>
    <Comment start="(48, 3)" end="(49, 93)" text="Auxiliary for `mapIdx`:&#10;  `mapIdx.go [a₀, a₁, ...] acc = acc.toList ++ [f acc.size a₀, f (acc.size + 1) a₁, ...]` -/"/>
    <Comment start="(54, 1)" end="(61, 3)" text="Applies a monadic function to each element of the list along with the index at which that element is&#10;found, returning the list of results. In addition to the index, the function is also provided with a&#10;proof that the index is valid.&#10;&#10;`List.mapIdxM` is a variant that does not provide the function with evidence that the index is&#10;valid.&#10;-/"/>
    <Comment start="(65, 3)" end="(66, 81)" text="Auxiliary for `mapFinIdxM`:&#10;  `mapFinIdxM.go [a₀, a₁, ...] acc = acc.toList ++ [f 0 a₀ ⋯, f 1 a₁ ⋯, ...]` -/"/>
    <Comment start="(72, 1)" end="(78, 3)" text="Applies a monadic function to each element of the list along with the index at which that element is&#10;found, returning the list of results.&#10;&#10;`List.mapFinIdxM` is a variant that additionally provides the function with a proof that the index&#10;is valid.&#10;-/"/>
    <Comment start="(80, 3)" end="(81, 94)" text="Auxiliary for `mapIdxM`:&#10;  `mapIdxM.go [a₀, a₁, ...] acc = acc.toList ++ [f acc.size a₀, f (acc.size + 1) a₁, ...]` -/"/>
    <Comment start="(86, 1)" end="(86, 21)" text="### mapFinIdx -/"/>
    <Comment start="(314, 1)" end="(314, 18)" text="### mapIdx -/"/>
  </Comments>
</TracedFile>
